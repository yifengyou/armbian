diff -Nupr a/drivers/video/rockchip/bmp_helper.c b/drivers/video/rockchip/bmp_helper.c
--- a/drivers/video/rockchip/bmp_helper.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/bmp_helper.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,389 @@
+/*
+ * linux/drivers/video/rockchip/bmp_helper.c
+ *
+ * Copyright (C) 2012 Rockchip Corporation
+ * Author: Mark Yao <mark.yao@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/rk_fb.h>
+
+#include "bmp_helper.h"
+
+static void draw_unencoded_bitmap(uint16_t **dst, uint8_t *bmap, uint16_t *cmap,
+				  uint32_t cnt)
+{
+	while (cnt > 0) {
+		*(*dst)++ = cmap[*bmap++];
+		cnt--;
+	}
+}
+
+static void draw_encoded_bitmap(uint16_t **dst, uint16_t c, uint32_t cnt)
+{
+	uint16_t *fb = *dst;
+	int cnt_8copy = cnt >> 3;
+
+	cnt -= cnt_8copy << 3;
+	while (cnt_8copy > 0) {
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		*fb++ = c;
+		cnt_8copy--;
+	}
+	while (cnt > 0) {
+		*fb++ = c;
+		cnt--;
+	}
+	*dst = fb;
+}
+
+static void yuv_to_rgb(int y, int u, int v, int *r, int *g, int *b)
+{
+	int rdif, invgdif, bdif;
+
+	u -= 128;
+	v -= 128;
+	rdif = v + ((v * 103) >> 8);
+	invgdif = ((u * 88) >> 8) + ((v * 183) >> 8);
+	bdif = u + ((u*198) >> 8);
+	*r = range(y + rdif, 0, 0xff);
+	*g = range(y - invgdif, 0, 0xff);
+	*b = range(y + bdif, 0, 0xff);
+}
+
+int bmpencoder(void *__iomem *vaddr, int width, int height, u8 data_format,
+	       void *data, void (*fn)(void *, void *, int))
+{
+	uint32_t *d = NULL, *d1 = NULL, *d2 = NULL;
+	uint8_t *dst = NULL, *yrgb = NULL, *uv = NULL, *y1 = NULL, *y2 = NULL;
+	int y = 0, u = 0, v = 0, r = 0, g = 0, b = 0;
+
+	int yu = width * 4 % 4;
+	int byteperline;
+	unsigned int size;
+	BITMAPHEADER header;
+	BITMAPINFOHEADER infoheader;
+	void *buf;
+	int i, j;
+
+	yu = yu != 0 ? 4 - yu : yu;
+	byteperline = width * 4 + yu;
+	size = byteperline * height + 54;
+	memset(&header, 0, sizeof(header));
+	memset(&infoheader, 0, sizeof(infoheader));
+	header.type = 'M'<<8|'B';
+	header.size = size;
+	header.offset = 54;
+
+	infoheader.size = 40;
+	infoheader.width = width;
+	infoheader.height = 0 - height;
+	infoheader.bitcount = 4 * 8;
+	infoheader.compression = 0;
+	infoheader.imagesize = byteperline * height;
+	infoheader.xpelspermeter = 0;
+	infoheader.ypelspermeter = 0;
+	infoheader.colors = 0;
+	infoheader.colorsimportant = 0;
+	fn(data, (void *)&header, sizeof(header));
+	fn(data, (void *)&infoheader, sizeof(infoheader));
+
+	/*
+	 * if data_format is ARGB888 or XRGB888, not need convert.
+	 */
+	if (data_format == ARGB888 || data_format == XRGB888) {
+		fn(data, (char *)vaddr, width * height * 4);
+		return 0;
+	}
+	/*
+	 * alloc 2 line buffer.
+	 */
+	buf = kmalloc(width * 2 * 4, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	yrgb = (uint8_t *)vaddr;
+	uv = yrgb + width * height;
+	for (j = 0; j < height; j++) {
+		if (j % 2 == 0) {
+			dst = buf;
+			y1 = yrgb + j * width;
+			y2 = y1 + width;
+			d1 = buf;
+			d2 = d1 + width;
+		}
+
+		for (i = 0; i < width; i++) {
+			switch (data_format) {
+			case XBGR888:
+			case ABGR888:
+				dst[0] = yrgb[2];
+				dst[1] = yrgb[1];
+				dst[2] = yrgb[0];
+				dst[3] = yrgb[3];
+				dst += 4;
+				yrgb += 4;
+				break;
+			case RGB888:
+				dst[0] = yrgb[0];
+				dst[1] = yrgb[1];
+				dst[2] = yrgb[2];
+				dst[3] = 0xff;
+				dst += 4;
+				yrgb += 3;
+				break;
+			case RGB565:
+				dst[0] = (yrgb[0] & 0x1f) << 3;
+				dst[1] = (yrgb[0] & 0xe0) >> 3 |
+						(yrgb[1] & 0x7) << 5;
+				dst[2] = yrgb[1] & 0xf8;
+				dst[3] = 0xff;
+				dst += 4;
+				yrgb += 2;
+				break;
+			case YUV420:
+			case YUV422:
+			case YUV444:
+				if (data_format == YUV420) {
+					if (i % 2 == 0) {
+						d = d1++;
+						y = *y1++;
+					} else {
+						d = d2++;
+						y = *y2++;
+					}
+					if (i % 4 == 0) {
+						u = *uv++;
+						v = *uv++;
+					}
+				} else if (data_format == YUV422) {
+					if (i % 2 == 0) {
+						u = *uv++;
+						v = *uv++;
+					}
+					d = d1++;
+				} else {
+					u = *uv++;
+					v = *uv++;
+					d = d1++;
+				}
+				yuv_to_rgb(y, u, v, &r, &g, &b);
+				*d = 0xff<<24 | r << 16 | g << 8 | b;
+				break;
+			case YUV422_A:
+			case YUV444_A:
+			default:
+				pr_err("unsupport now\n");
+				return -EINVAL;
+			}
+		}
+		if (j % 2 == 1)
+			fn(data, (char *)buf, 2 * width * 4);
+	}
+
+	return 0;
+}
+
+static void decode_rle8_bitmap(uint8_t *psrc, uint8_t *pdst, uint16_t *cmap,
+			       unsigned int width, unsigned int height,
+			       int bits, int x_off, int y_off, bool flip)
+{
+	uint32_t cnt, runlen;
+	int x = 0, y = 0;
+	int decode = 1;
+	uint8_t *bmap = psrc;
+	uint8_t *dst = pdst;
+	int linesize = width * 2;
+
+	if (flip) {
+		y = height - 1;
+		dst = pdst + y * linesize;
+	}
+
+	while (decode) {
+		if (bmap[0] == BMP_RLE8_ESCAPE) {
+			switch (bmap[1]) {
+			case BMP_RLE8_EOL:
+				/* end of line */
+				bmap += 2;
+				x = 0;
+				if (flip) {
+					y--;
+					dst -= linesize * 2;
+				} else {
+					y++;
+				}
+				break;
+			case BMP_RLE8_EOBMP:
+				/* end of bitmap */
+				decode = 0;
+				break;
+			case BMP_RLE8_DELTA:
+				/* delta run */
+				x += bmap[2];
+				if (flip) {
+					y -= bmap[3];
+					dst -= bmap[3] * linesize;
+					dst += bmap[2] * 2;
+				} else {
+					y += bmap[3];
+					dst += bmap[3] * linesize;
+					dst += bmap[2] * 2;
+				}
+				bmap += 4;
+				break;
+			default:
+				/* unencoded run */
+				runlen = bmap[1];
+				bmap += 2;
+				if (y >= height || x >= width) {
+					decode = 0;
+					break;
+				}
+				if (x + runlen > width)
+					cnt = width - x;
+				else
+					cnt = runlen;
+				draw_unencoded_bitmap((uint16_t **)&dst, bmap,
+						      cmap, cnt);
+				x += runlen;
+				bmap += runlen;
+				if (runlen & 1)
+					bmap++;
+			}
+		} else {
+			/* encoded run */
+			if (y < height) {
+				runlen = bmap[0];
+				if (x < width) {
+					/* aggregate the same code */
+					while (bmap[0] == 0xff &&
+					       bmap[2] != BMP_RLE8_ESCAPE &&
+					       bmap[1] == bmap[3]) {
+						runlen += bmap[2];
+						bmap += 2;
+					}
+					if (x + runlen > width)
+						cnt = width - x;
+					else
+						cnt = runlen;
+					draw_encoded_bitmap((uint16_t **)&dst,
+							    cmap[bmap[1]], cnt);
+				}
+				x += runlen;
+			}
+			bmap += 2;
+		}
+	}
+}
+
+int bmpdecoder(void *bmp_addr, void *pdst, int *width, int *height, int *bits)
+{
+	BITMAPHEADER header;
+	BITMAPINFOHEADER infoheader;
+	uint16_t *bmp_logo_palette;
+	uint32_t size;
+	uint16_t linesize;
+	int stride;
+	char *cmap_base;
+	char *src = bmp_addr;
+	char *dst = pdst;
+	int i;
+	bool flip = false;
+
+	memcpy(&header, src, sizeof(header));
+	src += sizeof(header);
+
+	if (header.type != 0x4d42) {
+		pr_err("not bmp file type[%x], can't support\n", header.type);
+		return -1;
+	}
+	memcpy(&infoheader, src, sizeof(infoheader));
+	*width = infoheader.width;
+	*height = infoheader.height;
+
+	if (*height < 0)
+		*height = 0 - *height;
+	else
+		flip = true;
+
+	size = header.size - header.offset;
+	linesize = *width * infoheader.bitcount >> 3;
+	cmap_base = src + sizeof(infoheader);
+	src = bmp_addr + header.offset;
+
+	switch (infoheader.bitcount) {
+	case 8:
+		bmp_logo_palette = kmalloc(sizeof(bmp_logo_palette) * 256, GFP_KERNEL);
+
+		/* Set color map */
+		for (i = 0; i < 256; i++) {
+			ushort colreg = ((cmap_base[2] << 8) & 0xf800) |
+					((cmap_base[1] << 3) & 0x07e0) |
+					((cmap_base[0] >> 3) & 0x001f) ;
+			cmap_base += 4;
+			bmp_logo_palette[i] = colreg;
+		}
+
+		/*
+		 * only support convert 8bit bmap file to RGB565.
+		 */
+		decode_rle8_bitmap(src, dst, bmp_logo_palette,
+				   infoheader.width, infoheader.height,
+				   infoheader.bitcount,	0, 0, flip);
+		kfree(bmp_logo_palette);
+		*bits = 16;
+		break;
+	case 16:
+		/*
+		 * Todo
+		 */
+		pr_info("unsupport bit=%d now\n", infoheader.bitcount);
+		break;
+	case 24:
+		stride = ALIGN(*width * 3, 4);
+		if (flip)
+			src += stride * (*height - 1);
+
+		for (i = 0; i < *height; i++) {
+			memcpy(dst, src, 3 * (*width));
+			dst += stride;
+			src += stride;
+			if (flip)
+				src -= stride * 2;
+		}
+
+		*bits = 24;
+		break;
+	case 32:
+		/*
+		 * Todo
+		 */
+		pr_info("unsupport bit=%d now\n", infoheader.bitcount);
+		break;
+	default:
+		pr_info("unsupport bit=%d now\n", infoheader.bitcount);
+		break;
+	}
+
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/bmp_helper.h b/drivers/video/rockchip/bmp_helper.h
--- a/drivers/video/rockchip/bmp_helper.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/bmp_helper.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,54 @@
+/*
+ * drivers/video/rockchip/bmp_helper.h
+ *
+ * Copyright (C) 2012 Rockchip Corporation
+ * Author: Mark Yao <mark.yao@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _BMP_HELPER_H_
+#define _BMP_HELPER_H_
+
+typedef struct bmpheader {
+	unsigned short type;
+	unsigned int size;
+	unsigned int reserved;
+	unsigned int offset;
+}__attribute__((packed)) BITMAPHEADER;
+
+typedef struct bmpinfoheader {
+	unsigned int size;
+	unsigned int width;
+	unsigned int height;
+	unsigned short planes;
+	unsigned short bitcount;
+	unsigned int compression;
+	unsigned int imagesize;
+	unsigned int xpelspermeter;
+	unsigned int ypelspermeter;
+	unsigned int colors;
+	unsigned int colorsimportant;
+}__attribute__((packed)) BITMAPINFOHEADER;
+
+#define BMP_RLE8_ESCAPE		0
+#define BMP_RLE8_EOL		0
+#define BMP_RLE8_EOBMP		1
+#define BMP_RLE8_DELTA		2
+
+#define range(x, min, max) ((x) < (min)) ? (min) : (((x) > (max)) ? (max) : (x))
+
+int bmpencoder(void *__iomem *vaddr,int width, int height, u8 data_format,
+	       void *data, void (*fn)(void *, void *, int));
+int bmpdecoder(void *bmp_addr, void *dst, int *width, int *height, int *bits);
+#endif /* _BMP_HELPER_H_ */
diff -Nupr a/drivers/video/rockchip/display-sys.c b/drivers/video/rockchip/display-sys.c
--- a/drivers/video/rockchip/display-sys.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/display-sys.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,793 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/idr.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/display-sys.h>
+
+static struct list_head main_display_device_list;
+static struct list_head aux_display_device_list;
+
+static ssize_t name_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", dsp->name);
+}
+
+static DEVICE_ATTR_RO(name);
+
+static ssize_t type_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", dsp->type);
+}
+
+static DEVICE_ATTR_RO(type);
+
+static ssize_t property_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", dsp->property);
+}
+
+static DEVICE_ATTR_RO(property);
+
+static ssize_t enable_show(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int enable;
+
+	if (dsp->ops && dsp->ops->getenable)
+		enable = dsp->ops->getenable(dsp);
+	else
+		return 0;
+	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
+}
+
+static ssize_t enable_store(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int enable;
+
+	if (kstrtoint(buf, 0, &enable))
+		return size;
+	if (dsp->ops && dsp->ops->setenable)
+		dsp->ops->setenable(dsp, enable);
+	return size;
+}
+
+static DEVICE_ATTR_RW(enable);
+
+static ssize_t connect_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int connect;
+
+	if (dsp->ops && dsp->ops->getstatus)
+		connect = dsp->ops->getstatus(dsp);
+	else
+		return 0;
+	return snprintf(buf, PAGE_SIZE, "%d\n", connect);
+}
+
+static DEVICE_ATTR_RO(connect);
+
+static int mode_string(char *buf, unsigned int offset,
+		       const struct fb_videomode *mode)
+{
+	char v = 'p';
+
+	if (!buf || !mode) {
+		pr_err("%s parameter error\n", __func__);
+		return 0;
+	}
+	if (mode->xres == 0 && mode->yres == 0)
+		return snprintf(&buf[offset], PAGE_SIZE - offset, "auto\n");
+	if (mode->vmode & FB_VMODE_INTERLACED)
+		v = 'i';
+	if (mode->vmode & FB_VMODE_DOUBLE)
+		v = 'd';
+	if (mode->flag)
+		return snprintf(&buf[offset], PAGE_SIZE - offset,
+				"%dx%d%c-%d(YCbCr420)\n",
+				mode->xres, mode->yres, v, mode->refresh);
+	else
+		return snprintf(&buf[offset], PAGE_SIZE - offset,
+				"%dx%d%c-%d\n",
+				mode->xres, mode->yres, v, mode->refresh);
+}
+
+static ssize_t modes_show(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	struct list_head *modelist, *pos;
+	struct display_modelist *display_modelist;
+	const struct fb_videomode *mode;
+	int i;
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->getmodelist) {
+		if (dsp->ops->getmodelist(dsp, &modelist)) {
+			mutex_unlock(&dsp->lock);
+			return -EINVAL;
+		}
+	} else {
+		mutex_unlock(&dsp->lock);
+		return 0;
+	}
+	i = 0;
+	if (dsp->priority == DISPLAY_PRIORITY_HDMI)
+		i += snprintf(buf, PAGE_SIZE, "auto\n");
+
+	list_for_each(pos, modelist) {
+		display_modelist = list_entry(pos,
+					      struct display_modelist,
+					      list);
+		mode = &display_modelist->mode;
+		i += mode_string(buf, i, mode);
+	}
+	mutex_unlock(&dsp->lock);
+	return i;
+}
+
+static DEVICE_ATTR_RO(modes);
+
+static ssize_t mode_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	struct fb_videomode mode;
+
+	if (dsp->ops && dsp->ops->getmode)
+		if (dsp->ops->getmode(dsp, &mode) == 0)
+			return mode_string(buf, 0, &mode);
+	return 0;
+}
+
+static ssize_t mode_store(struct device *dev,
+			  struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	char mstr[100];
+	struct list_head *modelist, *pos;
+	struct display_modelist *display_modelist;
+	struct fb_videomode *mode;
+	size_t i;
+
+	mutex_lock(&dsp->lock);
+	if (!memcmp(buf, "auto", 4)) {
+		if (dsp->ops && dsp->ops->setmode)
+			dsp->ops->setmode(dsp, NULL);
+		mutex_unlock(&dsp->lock);
+		return count;
+	}
+
+	if (dsp->ops && dsp->ops->getmodelist) {
+		if (dsp->ops && dsp->ops->getmodelist) {
+			if (dsp->ops->getmodelist(dsp, &modelist)) {
+				mutex_unlock(&dsp->lock);
+				return -EINVAL;
+			}
+		}
+		list_for_each(pos, modelist) {
+			display_modelist = list_entry(pos,
+						      struct display_modelist,
+						      list);
+			mode = &display_modelist->mode;
+			i = mode_string(mstr, 0, mode);
+			if (strncmp(mstr, buf, max(count, i)) == 0) {
+				if (dsp->ops && dsp->ops->setmode)
+					dsp->ops->setmode(dsp, mode);
+				mutex_unlock(&dsp->lock);
+				return count;
+			}
+		}
+	}
+	mutex_unlock(&dsp->lock);
+	return -EINVAL;
+}
+
+static DEVICE_ATTR_RW(mode);
+
+static ssize_t scale_show(struct device *dev,
+			  struct device_attribute *attr,
+			  char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int xscale, yscale;
+
+	if (dsp->ops && dsp->ops->getscale) {
+		xscale = dsp->ops->getscale(dsp, DISPLAY_SCALE_X);
+		yscale = dsp->ops->getscale(dsp, DISPLAY_SCALE_Y);
+		if (xscale && yscale)
+			return snprintf(buf, PAGE_SIZE,
+					"xscale=%d yscale=%d\n",
+					xscale, yscale);
+	}
+	return -EINVAL;
+}
+
+static ssize_t scale_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int scale = 100;
+
+	if (dsp->ops && dsp->ops->setscale) {
+		if (!strncmp(buf, "xscale", 6)) {
+			if (!kstrtoint(buf, 0, &scale))
+				dsp->ops->setscale(dsp,
+						   DISPLAY_SCALE_X,
+						   scale);
+		} else if (!strncmp(buf, "yscale", 6)) {
+			if (!kstrtoint(buf, 0, &scale))
+				dsp->ops->setscale(dsp,
+						   DISPLAY_SCALE_Y,
+						   scale);
+		} else {
+			if (!kstrtoint(buf, 0, &scale)) {
+				dsp->ops->setscale(dsp,
+						   DISPLAY_SCALE_X,
+						   scale);
+				dsp->ops->setscale(dsp,
+						   DISPLAY_SCALE_Y,
+						   scale);
+			}
+		}
+		return count;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR_RW(scale);
+
+static ssize_t mode3d_show(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	struct list_head *modelist, *pos;
+	struct display_modelist *display_modelist;
+	struct fb_videomode mode;
+	int i = 0, cur_3d_mode = -1;
+	char mode_str[128];
+	int mode_strlen, format_3d;
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->getmodelist) {
+		if (dsp->ops->getmodelist(dsp, &modelist)) {
+			mutex_unlock(&dsp->lock);
+			return -EINVAL;
+		}
+	} else {
+		mutex_unlock(&dsp->lock);
+		return 0;
+	}
+
+	if (dsp->ops && dsp->ops->getmode) {
+		if (dsp->ops->getmode(dsp, &mode)) {
+			mutex_unlock(&dsp->lock);
+			return -EINVAL;
+		}
+	} else {
+		mutex_unlock(&dsp->lock);
+		return 0;
+	}
+
+	list_for_each(pos, modelist) {
+		display_modelist = list_entry(pos,
+					      struct display_modelist,
+					      list);
+		if (!fb_mode_is_equal(&mode, &display_modelist->mode))
+			display_modelist = NULL;
+		else
+			break;
+	}
+	if (display_modelist)
+		i = snprintf(buf, PAGE_SIZE, "3dmodes=%d\n",
+			     display_modelist->format_3d);
+	else
+		i = snprintf(buf, PAGE_SIZE, "3dmodes=0\n");
+
+	if (dsp->ops && dsp->ops->get3dmode)
+		cur_3d_mode = dsp->ops->get3dmode(dsp);
+	i += snprintf(buf + i, PAGE_SIZE - i, "cur3dmode=%d\n", cur_3d_mode);
+
+	list_for_each(pos, modelist) {
+		display_modelist = list_entry(pos,
+					      struct display_modelist,
+					      list);
+		mode_strlen = mode_string(mode_str, 0,
+					  &display_modelist->mode);
+		mode_str[mode_strlen - 1] = 0;
+		format_3d = display_modelist->format_3d;
+		i += snprintf(buf + i, PAGE_SIZE, "%s,%d\n",
+			      mode_str, format_3d);
+	}
+	mutex_unlock(&dsp->lock);
+	return i;
+}
+
+static ssize_t mode3d_store(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int mode;
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->set3dmode) {
+		if (!kstrtoint(buf, 0, &mode))
+			dsp->ops->set3dmode(dsp, mode);
+		mutex_unlock(&dsp->lock);
+		return count;
+	}
+	mutex_unlock(&dsp->lock);
+	return -EINVAL;
+}
+
+static DEVICE_ATTR_RW(mode3d);
+
+static ssize_t color_show(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int ret = 0;
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->getcolor)
+		ret = dsp->ops->getcolor(dsp, buf);
+	mutex_unlock(&dsp->lock);
+	return ret;
+}
+
+static ssize_t color_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->setcolor) {
+		if (!dsp->ops->setcolor(dsp, buf, count)) {
+			mutex_unlock(&dsp->lock);
+			return count;
+		}
+	}
+	mutex_unlock(&dsp->lock);
+	return -EINVAL;
+}
+
+static DEVICE_ATTR_RW(color);
+
+static ssize_t audioinfo_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	char audioinfo[200];
+	int ret = 0;
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->getedidaudioinfo) {
+		ret = dsp->ops->getedidaudioinfo(dsp, audioinfo, 200);
+		if (!ret) {
+			mutex_unlock(&dsp->lock);
+			return snprintf(buf, PAGE_SIZE, "%s\n", audioinfo);
+		}
+	}
+	mutex_unlock(&dsp->lock);
+	return -EINVAL;
+}
+
+static DEVICE_ATTR_RO(audioinfo);
+
+static ssize_t monspecs_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	struct fb_monspecs monspecs;
+	int ret = 0;
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->getmonspecs) {
+		ret = dsp->ops->getmonspecs(dsp, &monspecs);
+		if (!ret) {
+			mutex_unlock(&dsp->lock);
+			memcpy(buf, &monspecs, sizeof(struct fb_monspecs));
+			return sizeof(struct fb_monspecs);
+		}
+	}
+	mutex_unlock(&dsp->lock);
+	return -EINVAL;
+}
+
+static DEVICE_ATTR_RO(monspecs);
+
+static ssize_t debug_show(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int ret = -EINVAL;
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->getdebug)
+		ret = dsp->ops->getdebug(dsp, buf);
+	mutex_unlock(&dsp->lock);
+	return ret;
+}
+
+static ssize_t debug_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int cmd, ret = -EINVAL;
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->setdebug) {
+		if (kstrtoint(buf, 0, &cmd) == 0)
+			dsp->ops->setdebug(dsp, cmd);
+		ret = count;
+	}
+	mutex_unlock(&dsp->lock);
+	return ret;
+}
+
+static DEVICE_ATTR_RW(debug);
+
+static ssize_t prop_show(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+	int ret = -EINVAL;
+
+	mutex_lock(&dsp->lock);
+	if (dsp->ops && dsp->ops->getvrinfo)
+		ret = dsp->ops->getvrinfo(dsp, buf);
+	mutex_unlock(&dsp->lock);
+
+	return ret;
+}
+
+static DEVICE_ATTR_RO(prop);
+
+static struct attribute *display_device_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_type.attr,
+	&dev_attr_property.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_connect.attr,
+	&dev_attr_modes.attr,
+	&dev_attr_mode.attr,
+	&dev_attr_scale.attr,
+	&dev_attr_mode3d.attr,
+	&dev_attr_color.attr,
+	&dev_attr_audioinfo.attr,
+	&dev_attr_monspecs.attr,
+	&dev_attr_debug.attr,
+	&dev_attr_prop.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(display_device);
+
+static int display_suspend(struct device *dev, pm_message_t state)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+
+	mutex_lock(&dsp->lock);
+	if (likely(dsp->driver->suspend))
+		dsp->driver->suspend(dsp, state);
+	mutex_unlock(&dsp->lock);
+	return 0;
+};
+
+static int display_resume(struct device *dev)
+{
+	struct rk_display_device *dsp = dev_get_drvdata(dev);
+
+	mutex_lock(&dsp->lock);
+	if (likely(dsp->driver->resume))
+		dsp->driver->resume(dsp);
+	mutex_unlock(&dsp->lock);
+	return 0;
+};
+
+int display_add_videomode(const struct fb_videomode *mode,
+			  struct list_head *head)
+{
+	struct list_head *pos;
+	struct display_modelist *modelist;
+	struct fb_videomode *m;
+	int found = 0;
+
+	list_for_each(pos, head) {
+		modelist = list_entry(pos, struct display_modelist, list);
+		m = &modelist->mode;
+		if (fb_mode_is_equal(m, mode)) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		modelist = kmalloc(sizeof(*modelist),
+				   GFP_KERNEL);
+
+		if (!modelist)
+			return -ENOMEM;
+		modelist->mode = *mode;
+		list_add(&modelist->list, head);
+	}
+	return 0;
+}
+
+void rk_display_device_enable(struct rk_display_device *ddev)
+{
+	struct list_head *pos, *head;
+	struct rk_display_device *dev = NULL, *dev_enabled = NULL;
+	struct rk_display_device *dev_enable = NULL;
+	int enable = 0, connect;
+
+	if (ddev->property == DISPLAY_MAIN)
+		head = &main_display_device_list;
+	else
+		head = &aux_display_device_list;
+
+	list_for_each(pos, head) {
+		dev = list_entry(pos, struct rk_display_device, list);
+		enable = dev->ops->getenable(dev);
+		connect = dev->ops->getstatus(dev);
+		if (connect)
+			dev_enable = dev;
+		if (enable == 1)
+			dev_enabled = dev;
+	}
+	/* If no device is connected, enable highest priority device. */
+	if (!dev_enable) {
+		dev->ops->setenable(dev, 1);
+		return;
+	}
+
+	if (dev_enable == dev_enabled) {
+		if (dev_enable != ddev)
+			ddev->ops->setenable(ddev, 0);
+	} else {
+		if (dev_enabled &&
+		    dev_enabled->priority != DISPLAY_PRIORITY_HDMI)
+			dev_enabled->ops->setenable(dev_enabled, 0);
+		dev_enable->ops->setenable(dev_enable, 1);
+	}
+}
+EXPORT_SYMBOL(rk_display_device_enable);
+
+void rk_display_device_enable_other(struct rk_display_device *ddev)
+{
+#ifndef CONFIG_DISPLAY_AUTO_SWITCH
+	return;
+#else
+	struct list_head *pos, *head;
+	struct rk_display_device *dev;
+	int connect = 0;
+
+	if (ddev->property == DISPLAY_MAIN)
+		head = &main_display_device_list;
+	else
+		head = &aux_display_device_list;
+
+	list_for_each_prev(pos, head) {
+		dev = list_entry(pos, struct rk_display_device, list);
+		if (dev != ddev) {
+			connect = dev->ops->getstatus(dev);
+			if (connect) {
+				dev->ops->setenable(dev, 1);
+				return;
+			}
+		}
+	}
+#endif
+}
+EXPORT_SYMBOL(rk_display_device_enable_other);
+
+void rk_display_device_disable_other(struct rk_display_device *ddev)
+{
+#ifndef CONFIG_DISPLAY_AUTO_SWITCH
+	return;
+#else
+	struct list_head *pos, *head;
+	struct rk_display_device *dev;
+	int enable = 0;
+
+	if (ddev->property == DISPLAY_MAIN)
+		head = &main_display_device_list;
+	else
+		head = &aux_display_device_list;
+
+	list_for_each(pos, head) {
+		dev = list_entry(pos, struct rk_display_device, list);
+		if (dev != ddev) {
+			enable = dev->ops->getenable(dev);
+			if (enable)
+				dev->ops->setenable(dev, 0);
+		}
+	}
+	ddev->ops->setenable(ddev, 1);
+#endif
+}
+EXPORT_SYMBOL(rk_display_device_disable_other);
+
+void rk_display_device_select(int property, int priority)
+{
+	struct list_head *pos, *head;
+	struct rk_display_device *dev;
+	int enable, found = 0;
+
+	if (property == DISPLAY_MAIN)
+		head = &main_display_device_list;
+	else
+		head = &aux_display_device_list;
+
+	list_for_each(pos, head) {
+		dev = list_entry(pos, struct rk_display_device, list);
+		if (dev->priority == priority)
+			found = 1;
+	}
+
+	if (!found) {
+		pr_err("[%s] select display interface %d not exist\n",
+		       __func__, priority);
+		return;
+	}
+
+	list_for_each(pos, head) {
+		dev = list_entry(pos, struct rk_display_device, list);
+		enable = dev->ops->getenable(dev);
+		if (dev->priority == priority) {
+			if (!enable)
+				dev->ops->setenable(dev, 1);
+		} else if (enable) {
+			dev->ops->setenable(dev, 0);
+		}
+	}
+}
+EXPORT_SYMBOL(rk_display_device_select);
+static struct mutex allocated_dsp_lock;
+static DEFINE_IDR(allocated_dsp);
+static struct class *display_class;
+
+struct rk_display_device
+	*rk_display_device_register(struct rk_display_driver *driver,
+				    struct device *parent, void *devdata)
+{
+	struct rk_display_device *new_dev = NULL;
+	int ret = -EINVAL;
+
+	if (unlikely(!driver))
+		return ERR_PTR(ret);
+
+	new_dev = kzalloc(sizeof(*new_dev), GFP_KERNEL);
+	if (likely(new_dev) && unlikely(driver->probe(new_dev, devdata))) {
+		/* Reserve the index for this display */
+		mutex_lock(&allocated_dsp_lock);
+		new_dev->idx = idr_alloc(&allocated_dsp, new_dev,
+					 0, 0, GFP_KERNEL);
+		mutex_unlock(&allocated_dsp_lock);
+
+		if (new_dev->idx >= 0) {
+			struct list_head *pos, *head;
+			struct rk_display_device *dev;
+			int i = 0;
+
+			head = &main_display_device_list;
+			list_for_each_entry(dev, head, list) {
+				if (strcmp(dev->type, new_dev->type) == 0)
+					i++;
+			}
+			head = &aux_display_device_list;
+			list_for_each_entry(dev, head, list) {
+				if (strcmp(dev->type, new_dev->type) == 0)
+					i++;
+			}
+			if (i == 0)
+				new_dev->dev =
+				device_create(display_class, parent,
+					      MKDEV(0, 0), new_dev,
+					      "%s", new_dev->type);
+			else
+				new_dev->dev =
+				device_create(display_class, parent,
+					      MKDEV(0, 0), new_dev,
+					      "%s%d", new_dev->type, i);
+
+			if (!IS_ERR(new_dev->dev)) {
+				new_dev->parent = parent;
+				new_dev->driver = driver;
+				if (parent)
+					new_dev->dev->driver = parent->driver;
+				mutex_init(&new_dev->lock);
+				/* Add new device to display device list. */
+				if (new_dev->property == DISPLAY_MAIN)
+					head = &main_display_device_list;
+				else
+					head = &aux_display_device_list;
+
+				list_for_each(pos, head) {
+					dev =
+					list_entry(pos,
+						   struct rk_display_device,
+						   list);
+					if (dev->priority > new_dev->priority)
+						break;
+				}
+				list_add_tail(&new_dev->list, pos);
+				return new_dev;
+			}
+			mutex_lock(&allocated_dsp_lock);
+			idr_remove(&allocated_dsp, new_dev->idx);
+			mutex_unlock(&allocated_dsp_lock);
+			ret = -EINVAL;
+		}
+	}
+	kfree(new_dev);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL(rk_display_device_register);
+
+void rk_display_device_unregister(struct rk_display_device *ddev)
+{
+	if (!ddev)
+		return;
+	/* Free device */
+	mutex_lock(&ddev->lock);
+	device_unregister(ddev->dev);
+	mutex_unlock(&ddev->lock);
+	/* Mark device index as available */
+	mutex_lock(&allocated_dsp_lock);
+	idr_remove(&allocated_dsp, ddev->idx);
+	mutex_unlock(&allocated_dsp_lock);
+	list_del(&ddev->list);
+	kfree(ddev);
+}
+EXPORT_SYMBOL(rk_display_device_unregister);
+
+static int __init rk_display_class_init(void)
+{
+	display_class = class_create(THIS_MODULE, "display");
+	if (IS_ERR(display_class)) {
+		pr_err("Failed to create display class\n");
+		display_class = NULL;
+		return -EINVAL;
+	}
+	display_class->dev_groups = display_device_groups;
+	display_class->suspend = display_suspend;
+	display_class->resume = display_resume;
+	mutex_init(&allocated_dsp_lock);
+	INIT_LIST_HEAD(&main_display_device_list);
+	INIT_LIST_HEAD(&aux_display_device_list);
+	return 0;
+}
+
+static void __exit rk_display_class_exit(void)
+{
+	class_destroy(display_class);
+}
+
+subsys_initcall(rk_display_class_init);
+module_exit(rk_display_class_exit);
+
+MODULE_AUTHOR("zhengyang@rock-chips.com");
+MODULE_DESCRIPTION("Driver for rk display device");
+MODULE_LICENSE("GPL");
diff -Nupr a/drivers/video/rockchip/dp/cdn-dp-fb-reg.c b/drivers/video/rockchip/dp/cdn-dp-fb-reg.c
--- a/drivers/video/rockchip/dp/cdn-dp-fb-reg.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/dp/cdn-dp-fb-reg.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,960 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Chris Zhong <zyw@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/reset.h>
+
+#include "cdn-dp-fb-reg.h"
+
+#define CDN_DP_SPDIF_CLK		200000000
+#define FW_ALIVE_TIMEOUT_US		1000000
+#define MAILBOX_RETRY_US		1000
+#define MAILBOX_TIMEOUT_US		5000000
+#define LINK_TRAINING_RETRY_MS		20
+#define LINK_TRAINING_TIMEOUT_MS	500
+
+void cdn_dp_fb_set_fw_clk(struct cdn_dp_device *dp, u32 clk)
+{
+	writel(clk / 1000000, dp->regs + SW_CLK_H);
+}
+
+void cdn_dp_fb_clock_reset(struct cdn_dp_device *dp)
+{
+	u32 val;
+
+	val = DPTX_FRMR_DATA_CLK_RSTN_EN |
+	      DPTX_FRMR_DATA_CLK_EN |
+	      DPTX_PHY_DATA_RSTN_EN |
+	      DPTX_PHY_DATA_CLK_EN |
+	      DPTX_PHY_CHAR_RSTN_EN |
+	      DPTX_PHY_CHAR_CLK_EN |
+	      SOURCE_AUX_SYS_CLK_RSTN_EN |
+	      SOURCE_AUX_SYS_CLK_EN |
+	      DPTX_SYS_CLK_RSTN_EN |
+	      DPTX_SYS_CLK_EN |
+	      CFG_DPTX_VIF_CLK_RSTN_EN |
+	      CFG_DPTX_VIF_CLK_EN;
+	writel(val, dp->regs + SOURCE_DPTX_CAR);
+
+	val = SOURCE_PHY_RSTN_EN | SOURCE_PHY_CLK_EN;
+	writel(val, dp->regs + SOURCE_PHY_CAR);
+
+	val = SOURCE_PKT_SYS_RSTN_EN |
+	      SOURCE_PKT_SYS_CLK_EN |
+	      SOURCE_PKT_DATA_RSTN_EN |
+	      SOURCE_PKT_DATA_CLK_EN;
+	writel(val, dp->regs + SOURCE_PKT_CAR);
+
+	val = SPDIF_CDR_CLK_RSTN_EN |
+	      SPDIF_CDR_CLK_EN |
+	      SOURCE_AIF_SYS_RSTN_EN |
+	      SOURCE_AIF_SYS_CLK_EN |
+	      SOURCE_AIF_CLK_RSTN_EN |
+	      SOURCE_AIF_CLK_EN;
+	writel(val, dp->regs + SOURCE_AIF_CAR);
+
+	val = SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN |
+	      SOURCE_CIPHER_SYS_CLK_EN |
+	      SOURCE_CIPHER_CHAR_CLK_RSTN_EN |
+	      SOURCE_CIPHER_CHAR_CLK_EN;
+	writel(val, dp->regs + SOURCE_CIPHER_CAR);
+
+	val = SOURCE_CRYPTO_SYS_CLK_RSTN_EN |
+	      SOURCE_CRYPTO_SYS_CLK_EN;
+	writel(val, dp->regs + SOURCE_CRYPTO_CAR);
+
+	val = ~(MAILBOX_INT_MASK_BIT | PIF_INT_MASK_BIT) & ALL_INT_MASK;
+	writel(val, dp->regs + APB_INT_MASK);
+}
+
+static int cdn_dp_fb_mailbox_read(struct cdn_dp_device *dp, bool force)
+{
+	int val, ret;
+
+	if (!dp->fw_actived && !force)
+		return -EPERM;
+
+	ret = readx_poll_timeout(readl, dp->regs + MAILBOX_EMPTY_ADDR,
+				 val, !val, MAILBOX_RETRY_US,
+				 MAILBOX_TIMEOUT_US);
+	if (ret < 0)
+		return ret;
+
+	return readl(dp->regs + MAILBOX0_RD_DATA) & 0xff;
+}
+
+static int cdn_dp_fb_mailbox_write(struct cdn_dp_device *dp, u8 val, bool force)
+{
+	int ret, full;
+
+	if (!dp->fw_actived && !force)
+		return -EPERM;
+
+	ret = readx_poll_timeout(readl, dp->regs + MAILBOX_FULL_ADDR,
+				 full, !full, MAILBOX_RETRY_US,
+				 MAILBOX_TIMEOUT_US);
+	if (ret < 0)
+		return ret;
+
+	writel(val, dp->regs + MAILBOX0_WR_DATA);
+
+	return 0;
+}
+
+static int cdn_dp_fb_mailbox_validate_receive(struct cdn_dp_device *dp,
+					   u8 module_id, u8 opcode,
+					   u8 req_size)
+{
+	u32 mbox_size, i;
+	u8 header[4];
+	int ret;
+
+	/* read the header of the message */
+	for (i = 0; i < 4; i++) {
+		ret = cdn_dp_fb_mailbox_read(dp, 0);
+		if (ret < 0)
+			return ret;
+
+		header[i] = ret;
+	}
+
+	mbox_size = (header[2] << 8) | header[3];
+
+	if (opcode != header[0] || module_id != header[1] ||
+	    req_size != mbox_size) {
+		/*
+		 * If the message in mailbox is not what we want, we need to
+		 * clear the mailbox by reading its contents.
+		 */
+		for (i = 0; i < mbox_size; i++)
+			if (cdn_dp_fb_mailbox_read(dp, 0) < 0)
+				break;
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cdn_dp_fb_mailbox_read_receive(struct cdn_dp_device *dp,
+				       u8 *buff, u8 buff_size)
+{
+	u32 i;
+	int ret;
+
+	for (i = 0; i < buff_size; i++) {
+		ret = cdn_dp_fb_mailbox_read(dp, 0);
+		if (ret < 0)
+			return ret;
+
+		buff[i] = ret;
+	}
+
+	return 0;
+}
+
+static int cdn_dp_fb_mailbox_send(struct cdn_dp_device *dp, u8 module_id,
+			       u8 opcode, u16 size, u8 *message)
+{
+	u8 header[4];
+	int ret, i;
+
+	header[0] = opcode;
+	header[1] = module_id;
+	header[2] = (size >> 8) & 0xff;
+	header[3] = size & 0xff;
+
+	for (i = 0; i < 4; i++) {
+		ret = cdn_dp_fb_mailbox_write(dp, header[i], 0);
+		if (ret)
+			return ret;
+	}
+
+	for (i = 0; i < size; i++) {
+		ret = cdn_dp_fb_mailbox_write(dp, message[i], 0);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int cdn_dp_fb_reg_write(struct cdn_dp_device *dp, u16 addr, u32 val)
+{
+	u8 msg[6];
+
+	msg[0] = (addr >> 8) & 0xff;
+	msg[1] = addr & 0xff;
+	msg[2] = (val >> 24) & 0xff;
+	msg[3] = (val >> 16) & 0xff;
+	msg[4] = (val >> 8) & 0xff;
+	msg[5] = val & 0xff;
+	return cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_REGISTER,
+				   sizeof(msg), msg);
+}
+
+static int cdn_dp_fb_reg_write_bit(struct cdn_dp_device *dp, u16 addr,
+				u8 start_bit, u8 bits_no, u32 val)
+{
+	u8 field[8];
+
+	field[0] = (addr >> 8) & 0xff;
+	field[1] = addr & 0xff;
+	field[2] = start_bit;
+	field[3] = bits_no;
+	field[4] = (val >> 24) & 0xff;
+	field[5] = (val >> 16) & 0xff;
+	field[6] = (val >> 8) & 0xff;
+	field[7] = val & 0xff;
+
+	return cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_FIELD,
+				   sizeof(field), field);
+}
+
+int cdn_dp_fb_dpcd_read(struct cdn_dp_device *dp, u32 addr, u8 *data, u16 len)
+{
+	u8 msg[5], reg[5];
+	int ret;
+
+	msg[0] = (len >> 8) & 0xff;
+	msg[1] = len & 0xff;
+	msg[2] = (addr >> 16) & 0xff;
+	msg[3] = (addr >> 8) & 0xff;
+	msg[4] = addr & 0xff;
+	ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_READ_DPCD,
+				  sizeof(msg), msg);
+	if (ret)
+		goto err_dpcd_read;
+
+	ret = cdn_dp_fb_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,
+					      DPTX_READ_DPCD,
+					      sizeof(reg) + len);
+	if (ret)
+		goto err_dpcd_read;
+
+	ret = cdn_dp_fb_mailbox_read_receive(dp, reg, sizeof(reg));
+	if (ret)
+		goto err_dpcd_read;
+
+	ret = cdn_dp_fb_mailbox_read_receive(dp, data, len);
+
+err_dpcd_read:
+	return ret;
+}
+
+int cdn_dp_fb_dpcd_write(struct cdn_dp_device *dp, u32 addr, u8 value)
+{
+	u8 msg[6], reg[5];
+	int ret;
+
+	msg[0] = 0;
+	msg[1] = 1;
+	msg[2] = (addr >> 16) & 0xff;
+	msg[3] = (addr >> 8) & 0xff;
+	msg[4] = addr & 0xff;
+	msg[5] = value;
+	ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_WRITE_DPCD,
+				  sizeof(msg), msg);
+	if (ret)
+		goto err_dpcd_write;
+
+	ret = cdn_dp_fb_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,
+					      DPTX_WRITE_DPCD, sizeof(reg));
+	if (ret)
+		goto err_dpcd_write;
+
+	ret = cdn_dp_fb_mailbox_read_receive(dp, reg, sizeof(reg));
+	if (ret)
+		goto err_dpcd_write;
+
+	if (addr != (reg[2] << 16 | reg[3] << 8 | reg[4]))
+		ret = -EINVAL;
+
+err_dpcd_write:
+	if (ret)
+		dev_err(dp->dev, "dpcd write failed: %d\n", ret);
+	return ret;
+}
+
+int cdn_dp_fb_load_firmware(struct cdn_dp_device *dp, const u32 *i_mem,
+			 u32 i_size, const u32 *d_mem, u32 d_size)
+{
+	u32 reg;
+	int i, ret;
+
+	/* reset ucpu before load firmware*/
+	writel(APB_IRAM_PATH | APB_DRAM_PATH | APB_XT_RESET,
+	       dp->regs + APB_CTRL);
+
+	for (i = 0; i < i_size; i += 4)
+		writel(*i_mem++, dp->regs + ADDR_IMEM + i);
+
+	for (i = 0; i < d_size; i += 4)
+		writel(*d_mem++, dp->regs + ADDR_DMEM + i);
+
+	/* un-reset ucpu */
+	writel(0, dp->regs + APB_CTRL);
+
+	/* check the keep alive register to make sure fw working */
+	ret = readx_poll_timeout(readl, dp->regs + KEEP_ALIVE,
+				 reg, reg, 2000, FW_ALIVE_TIMEOUT_US);
+	if (ret < 0) {
+		dev_err(dp->dev, "failed to loaded the FW reg = %x\n", reg);
+		return -EINVAL;
+	}
+
+	reg = readl(dp->regs + VER_L) & 0xff;
+	dp->fw_version = reg;
+	reg = readl(dp->regs + VER_H) & 0xff;
+	dp->fw_version |= reg << 8;
+	reg = readl(dp->regs + VER_LIB_L_ADDR) & 0xff;
+	dp->fw_version |= reg << 16;
+	reg = readl(dp->regs + VER_LIB_H_ADDR) & 0xff;
+	dp->fw_version |= reg << 24;
+
+	dev_dbg(dp->dev, "firmware version: %x\n", dp->fw_version);
+
+	return 0;
+}
+
+int cdn_dp_fb_set_firmware_active(struct cdn_dp_device *dp, bool enable)
+{
+	u8 msg[5];
+	int ret, i;
+
+	msg[0] = GENERAL_MAIN_CONTROL;
+	msg[1] = MB_MODULE_ID_GENERAL;
+	msg[2] = 0;
+	msg[3] = 1;
+	msg[4] = enable ? FW_ACTIVE : FW_STANDBY;
+
+	for (i = 0; i < sizeof(msg); i++) {
+		ret = cdn_dp_fb_mailbox_write(dp, msg[i], 1);
+		if (ret)
+			goto err_set_firmware_active;
+	}
+
+	/* read the firmware state */
+	for (i = 0; i < sizeof(msg); i++)  {
+		ret = cdn_dp_fb_mailbox_read(dp, 1);
+		if (ret < 0)
+			goto err_set_firmware_active;
+
+		msg[i] = ret;
+	}
+
+	dp->fw_actived = (msg[4] == FW_ACTIVE);
+	ret = 0;
+
+err_set_firmware_active:
+	if (ret < 0)
+		dev_err(dp->dev, "set firmware active failed\n");
+	return ret;
+}
+
+int cdn_dp_fb_set_host_cap(struct cdn_dp_device *dp, u8 lanes, bool flip)
+{
+	u8 msg[8];
+	int ret;
+
+	msg[0] = CDN_DP_MAX_LINK_RATE;
+	msg[1] = lanes | (0x1 << 4);
+	msg[2] = VOLTAGE_LEVEL_2;
+	msg[3] = PRE_EMPHASIS_LEVEL_3;
+	msg[4] = PTS1 | PTS2 | PTS3 | PTS4;
+	msg[5] = FAST_LT_NOT_SUPPORT;
+	msg[6] = flip ? LANE_MAPPING_FLIPPED : LANE_MAPPING_NORMAL;
+	msg[7] = ENHANCED;
+
+	ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX,
+				  DPTX_SET_HOST_CAPABILITIES,
+				  sizeof(msg), msg);
+	if (ret)
+		goto err_set_host_cap;
+
+	ret = cdn_dp_fb_reg_write(dp, DP_AUX_SWAP_INVERSION_CONTROL,
+			       AUX_HOST_INVERT);
+
+err_set_host_cap:
+	if (ret)
+		dev_err(dp->dev, "set host cap failed: %d\n", ret);
+	return ret;
+}
+
+int cdn_dp_fb_event_config(struct cdn_dp_device *dp)
+{
+	u8 msg[5];
+	int ret;
+
+	memset(msg, 0, sizeof(msg));
+
+	msg[0] = DPTX_EVENT_ENABLE_HPD | DPTX_EVENT_ENABLE_TRAINING;
+
+	ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_ENABLE_EVENT,
+				  sizeof(msg), msg);
+	if (ret)
+		dev_err(dp->dev, "set event config failed: %d\n", ret);
+
+	return ret;
+}
+
+u32 cdn_dp_fb_get_event(struct cdn_dp_device *dp)
+{
+	return readl(dp->regs + SW_EVENTS0);
+}
+
+int cdn_dp_fb_get_hpd_status(struct cdn_dp_device *dp)
+{
+	u8 status;
+	int ret;
+
+	ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_HPD_STATE,
+				  0, NULL);
+	if (ret)
+		goto err_get_hpd;
+
+	ret = cdn_dp_fb_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,
+					      DPTX_HPD_STATE, sizeof(status));
+	if (ret)
+		goto err_get_hpd;
+
+	ret = cdn_dp_fb_mailbox_read_receive(dp, &status, sizeof(status));
+	if (ret)
+		goto err_get_hpd;
+
+	return status;
+
+err_get_hpd:
+	dev_err(dp->dev, "get hpd status failed: %d\n", ret);
+	return ret;
+}
+
+int cdn_dp_fb_get_edid_block(void *data, u8 *edid,
+			  unsigned int block, size_t length)
+{
+	struct cdn_dp_device *dp = data;
+	u8 msg[2], reg[2], i;
+	int ret;
+
+	for (i = 0; i < 4; i++) {
+		msg[0] = block / 2;
+		msg[1] = block % 2;
+
+		ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_GET_EDID,
+					  sizeof(msg), msg);
+		if (ret)
+			continue;
+
+		ret = cdn_dp_fb_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,
+						      DPTX_GET_EDID,
+						      sizeof(reg) + length);
+		if (ret)
+			continue;
+
+		ret = cdn_dp_fb_mailbox_read_receive(dp, reg, sizeof(reg));
+		if (ret)
+			continue;
+
+		ret = cdn_dp_fb_mailbox_read_receive(dp, edid, length);
+		if (ret)
+			continue;
+
+		if (reg[0] == length && reg[1] == block / 2)
+			break;
+	}
+
+	if (ret)
+		dev_err(dp->dev, "get block[%d] edid failed: %d\n", block, ret);
+
+	return ret;
+}
+
+int cdn_dp_fb_training_start(struct cdn_dp_device *dp)
+{
+	unsigned long timeout;
+	u8 msg, event[2];
+	int ret;
+
+	msg = LINK_TRAINING_RUN;
+
+	/* start training */
+	ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_TRAINING_CONTROL,
+				  sizeof(msg), &msg);
+	if (ret)
+		goto err_training_start;
+
+	timeout = jiffies + msecs_to_jiffies(LINK_TRAINING_TIMEOUT_MS);
+	while (time_before(jiffies, timeout)) {
+		msleep(LINK_TRAINING_RETRY_MS);
+		ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX,
+					  DPTX_READ_EVENT, 0, NULL);
+		if (ret)
+			goto err_training_start;
+
+		ret = cdn_dp_fb_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,
+						      DPTX_READ_EVENT,
+						      sizeof(event));
+		if (ret)
+			goto err_training_start;
+
+		ret = cdn_dp_fb_mailbox_read_receive(dp, event, sizeof(event));
+		if (ret)
+			goto err_training_start;
+
+		if (event[1] & EQ_PHASE_FINISHED)
+			return 0;
+	}
+
+	ret = -ETIMEDOUT;
+
+err_training_start:
+	dev_err(dp->dev, "training failed: %d\n", ret);
+	return ret;
+}
+
+int cdn_dp_fb_get_training_status(struct cdn_dp_device *dp)
+{
+	u8 status[10];
+	int ret;
+
+	ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_READ_LINK_STAT,
+				  0, NULL);
+	if (ret)
+		goto err_get_training_status;
+
+	ret = cdn_dp_fb_mailbox_validate_receive(dp, MB_MODULE_ID_DP_TX,
+					      DPTX_READ_LINK_STAT,
+					      sizeof(status));
+	if (ret)
+		goto err_get_training_status;
+
+	ret = cdn_dp_fb_mailbox_read_receive(dp, status, sizeof(status));
+	if (ret)
+		goto err_get_training_status;
+
+	dp->link.rate = status[0];
+	dp->link.num_lanes = status[1];
+
+err_get_training_status:
+	if (ret)
+		dev_err(dp->dev, "get training status failed: %d\n", ret);
+	return ret;
+}
+
+int cdn_dp_fb_set_video_status(struct cdn_dp_device *dp, int active)
+{
+	u8 msg;
+	int ret;
+
+	msg = !!active;
+
+	ret = cdn_dp_fb_mailbox_send(dp, MB_MODULE_ID_DP_TX, DPTX_SET_VIDEO,
+				  sizeof(msg), &msg);
+	if (ret)
+		dev_err(dp->dev, "set video status failed: %d\n", ret);
+
+	return ret;
+}
+
+static int cdn_dp_fb_get_msa_misc(struct video_info *video,
+			       struct drm_display_mode *mode)
+{
+	u32 msa_misc;
+	u8 val[2];
+
+	switch (video->color_fmt) {
+	case PXL_RGB:
+	case Y_ONLY:
+		val[0] = 0;
+		break;
+	/* set YUV default color space conversion to BT601 */
+	case YCBCR_4_4_4:
+		val[0] = 6 + BT_601 * 8;
+		break;
+	case YCBCR_4_2_2:
+		val[0] = 5 + BT_601 * 8;
+		break;
+	case YCBCR_4_2_0:
+		val[0] = 5;
+		break;
+	};
+
+	switch (video->color_depth) {
+	case 6:
+		val[1] = 0;
+		break;
+	case 8:
+		val[1] = 1;
+		break;
+	case 10:
+		val[1] = 2;
+		break;
+	case 12:
+		val[1] = 3;
+		break;
+	case 16:
+		val[1] = 4;
+		break;
+	};
+
+	msa_misc = 2 * val[0] + 32 * val[1] +
+		   ((video->color_fmt == Y_ONLY) ? (1 << 14) : 0);
+
+	return msa_misc;
+}
+
+int cdn_dp_fb_config_video(struct cdn_dp_device *dp)
+{
+	struct video_info *video = &dp->video_info;
+	struct drm_display_mode *mode = &dp->mode;
+	u64 symbol, tmp;
+	u32 val, link_rate;
+	u8 bit_per_pix, tu_size_reg = TU_SIZE;
+	int ret;
+
+	bit_per_pix = (video->color_fmt == YCBCR_4_2_2) ?
+		      (video->color_depth * 2) : (video->color_depth * 3);
+
+	link_rate = drm_dp_bw_code_to_link_rate(dp->link.rate) / 1000;
+
+	val = VIF_BYPASS_INTERLACE;
+	ret = cdn_dp_fb_reg_write(dp, BND_HSYNC2VSYNC, val);
+	if (ret)
+		goto err_config_video;
+
+	ret = cdn_dp_fb_reg_write(dp, HSYNC2VSYNC_POL_CTRL, 0);
+	if (ret)
+		goto err_config_video;
+
+	/*
+	 * get a best tu_size and valid symbol:
+	 * 1. chose Lclk freq(162Mhz, 270Mhz, 540Mhz), set TU to 32
+	 * 2. calculate VS(valid symbol) = TU * Pclk * Bpp / (Lclk * Lanes)
+	 * 3. if VS > *.85 or VS < *.1 or VS < 2 or TU < VS + 4, then set
+	 *    TU += 2 and repeat 2nd step.
+	 */
+	do {
+		tu_size_reg += 2;
+		tmp = tu_size_reg * mode->clock * bit_per_pix;
+		tmp /= dp->link.num_lanes * link_rate * 8;
+		symbol = tmp / 1000;
+	} while ((symbol <= 1) || (tu_size_reg - symbol < 4) ||
+		 (tmp % 1000 > 850) || (tmp % 1000 < 100));
+
+	val = symbol + (tu_size_reg << 8);
+	ret = cdn_dp_fb_reg_write(dp, DP_FRAMER_TU, val);
+	if (ret)
+		goto err_config_video;
+
+	/* set the FIFO Buffer size */
+	val = ((mode->clock * (symbol + 1) / 1000) + link_rate);
+	val /= (dp->link.num_lanes * link_rate);
+	val = 8 * (symbol + 1) / bit_per_pix - val;
+	val += 2;
+	ret = cdn_dp_fb_reg_write(dp, DP_VC_TABLE(15), val);
+
+	switch (video->color_depth) {
+	case 6:
+		val = BCS_6;
+		break;
+	case 8:
+		val = BCS_8;
+		break;
+	case 10:
+		val = BCS_10;
+		break;
+	case 12:
+		val = BCS_12;
+		break;
+	case 16:
+		val = BCS_16;
+		break;
+	};
+
+	val += video->color_fmt << 8;
+	ret = cdn_dp_fb_reg_write(dp, DP_FRAMER_PXL_REPR, val);
+	if (ret)
+		goto err_config_video;
+
+	val = video->h_sync_polarity ? DP_FRAMER_SP_HSP : 0;
+	val |= video->v_sync_polarity ? DP_FRAMER_SP_VSP : 0;
+	ret = cdn_dp_fb_reg_write(dp, DP_FRAMER_SP, val);
+	if (ret)
+		goto err_config_video;
+
+	val = (mode->hsync_start - mode->hdisplay) << 16;
+	val |= mode->htotal - mode->hsync_end;
+	ret = cdn_dp_fb_reg_write(dp, DP_FRONT_BACK_PORCH, val);
+	if (ret)
+		goto err_config_video;
+
+	val = mode->hdisplay * bit_per_pix / 8;
+	ret = cdn_dp_fb_reg_write(dp, DP_BYTE_COUNT, val);
+	if (ret)
+		goto err_config_video;
+
+	val = mode->htotal | ((mode->htotal - mode->hsync_start) << 16);
+	ret = cdn_dp_fb_reg_write(dp, MSA_HORIZONTAL_0, val);
+	if (ret)
+		goto err_config_video;
+
+	val = mode->hsync_end - mode->hsync_start;
+	val |= (mode->hdisplay << 16) | (video->h_sync_polarity << 15);
+	ret = cdn_dp_fb_reg_write(dp, MSA_HORIZONTAL_1, val);
+	if (ret)
+		goto err_config_video;
+
+	val = mode->vtotal;
+	val |= ((mode->vtotal - mode->vsync_start) << 16);
+	ret = cdn_dp_fb_reg_write(dp, MSA_VERTICAL_0, val);
+	if (ret)
+		goto err_config_video;
+
+	val = mode->vsync_end - mode->vsync_start;
+	val |= mode->vdisplay << 16 | (video->v_sync_polarity << 15);
+	ret = cdn_dp_fb_reg_write(dp, MSA_VERTICAL_1, val);
+	if (ret)
+		goto err_config_video;
+
+	val = cdn_dp_fb_get_msa_misc(video, mode);
+	ret = cdn_dp_fb_reg_write(dp, MSA_MISC, val);
+	if (ret)
+		goto err_config_video;
+
+	ret = cdn_dp_fb_reg_write(dp, STREAM_CONFIG, 1);
+	if (ret)
+		goto err_config_video;
+
+	val = mode->hsync_end - mode->hsync_start;
+	val |= (mode->hdisplay << 16);
+	ret = cdn_dp_fb_reg_write(dp, DP_HORIZONTAL, val);
+	if (ret)
+		goto err_config_video;
+
+	val = mode->vtotal;
+	val -= (mode->vtotal - mode->vdisplay);
+	val |= (mode->vtotal - mode->vsync_start) << 16;
+	ret = cdn_dp_fb_reg_write(dp, DP_VERTICAL_0, val);
+	if (ret)
+		goto err_config_video;
+
+	val = mode->vtotal;
+	ret = cdn_dp_fb_reg_write(dp, DP_VERTICAL_1, val);
+	if (ret)
+		goto err_config_video;
+
+	val =  0;
+	ret = cdn_dp_fb_reg_write_bit(dp, DP_VB_ID, 2, 1, val);
+
+err_config_video:
+	if (ret)
+		dev_err(dp->dev, "config video failed: %d\n", ret);
+	return ret;
+}
+
+int cdn_dp_fb_audio_stop(struct cdn_dp_device *dp, struct audio_info *audio)
+{
+	u32 val;
+	int ret;
+
+	ret = cdn_dp_fb_reg_write(dp, AUDIO_PACK_CONTROL, 0);
+	if (ret) {
+		dev_err(dp->dev, "audio stop failed: %d\n", ret);
+		return ret;
+	}
+
+	val = SPDIF_AVG_SEL | SPDIF_JITTER_BYPASS;
+	val |= SPDIF_FIFO_MID_RANGE(0xe0);
+	val |= SPDIF_JITTER_THRSH(0xe0);
+	val |= SPDIF_JITTER_AVG_WIN(7);
+	writel(val, dp->regs + SPDIF_CTRL_ADDR);
+
+	/* clearn the audio config and reset */
+	writel(0, dp->regs + AUDIO_SRC_CNTL);
+	writel(0, dp->regs + AUDIO_SRC_CNFG);
+	writel(AUDIO_SW_RST, dp->regs + AUDIO_SRC_CNTL);
+	writel(0, dp->regs + AUDIO_SRC_CNTL);
+
+	/* reset smpl2pckt component  */
+	writel(0, dp->regs + SMPL2PKT_CNTL);
+	writel(AUDIO_SW_RST, dp->regs + SMPL2PKT_CNTL);
+	writel(0, dp->regs + SMPL2PKT_CNTL);
+
+	/* reset FIFO */
+	writel(AUDIO_SW_RST, dp->regs + FIFO_CNTL);
+	writel(0, dp->regs + FIFO_CNTL);
+
+	if (audio->format == AFMT_SPDIF)
+		clk_disable_unprepare(dp->spdif_clk);
+
+	return 0;
+}
+
+int cdn_dp_fb_audio_mute(struct cdn_dp_device *dp, bool enable)
+{
+	int ret;
+
+	ret = cdn_dp_fb_reg_write_bit(dp, DP_VB_ID, 4, 1, enable);
+	if (ret)
+		dev_err(dp->dev, "audio mute failed: %d\n", ret);
+
+	return ret;
+}
+
+static void cdn_dp_fb_audio_config_i2s(struct cdn_dp_device *dp,
+				    struct audio_info *audio)
+{
+	int sub_pckt_num = 1, i2s_port_en_val = 0xf, i;
+	u32 val;
+
+	if (audio->channels == 2) {
+		if (dp->link.num_lanes == 1)
+			sub_pckt_num = 2;
+		else
+			sub_pckt_num = 4;
+
+		i2s_port_en_val = 1;
+	} else if (audio->channels == 4) {
+		i2s_port_en_val = 3;
+	}
+
+	writel(0x0, dp->regs + SPDIF_CTRL_ADDR);
+
+	writel(SYNC_WR_TO_CH_ZERO, dp->regs + FIFO_CNTL);
+
+	val = MAX_NUM_CH(audio->channels);
+	val |= NUM_OF_I2S_PORTS(audio->channels);
+	val |= AUDIO_TYPE_LPCM;
+	val |= CFG_SUB_PCKT_NUM(sub_pckt_num);
+	writel(val, dp->regs + SMPL2PKT_CNFG);
+
+	if (audio->sample_width == 16)
+		val = 0;
+	else if (audio->sample_width == 24)
+		val = 1 << 9;
+	else
+		val = 2 << 9;
+
+	val |= AUDIO_CH_NUM(audio->channels);
+	val |= I2S_DEC_PORT_EN(i2s_port_en_val);
+	val |= TRANS_SMPL_WIDTH_32;
+	writel(val, dp->regs + AUDIO_SRC_CNFG);
+
+	for (i = 0; i < (audio->channels + 1) / 2; i++) {
+		if (audio->sample_width == 16)
+			val = (0x08 << 8) | (0x08 << 20);
+		else if (audio->sample_width == 24)
+			val = (0x0b << 8) | (0x0b << 20);
+
+		val |= ((2 * i) << 4) | ((2 * i + 1) << 16);
+		writel(val, dp->regs + STTS_BIT_CH(i));
+	}
+
+	switch (audio->sample_rate) {
+	case 32000:
+		val = SAMPLING_FREQ(3) |
+		      ORIGINAL_SAMP_FREQ(0xc);
+		break;
+	case 44100:
+		val = SAMPLING_FREQ(0) |
+		      ORIGINAL_SAMP_FREQ(0xf);
+		break;
+	case 48000:
+		val = SAMPLING_FREQ(2) |
+		      ORIGINAL_SAMP_FREQ(0xd);
+		break;
+	case 88200:
+		val = SAMPLING_FREQ(8) |
+		      ORIGINAL_SAMP_FREQ(0x7);
+		break;
+	case 96000:
+		val = SAMPLING_FREQ(0xa) |
+		      ORIGINAL_SAMP_FREQ(5);
+		break;
+	case 176400:
+		val = SAMPLING_FREQ(0xc) |
+		      ORIGINAL_SAMP_FREQ(3);
+		break;
+	case 192000:
+		val = SAMPLING_FREQ(0xe) |
+		      ORIGINAL_SAMP_FREQ(1);
+		break;
+	}
+	val |= 4;
+	writel(val, dp->regs + COM_CH_STTS_BITS);
+
+	writel(SMPL2PKT_EN, dp->regs + SMPL2PKT_CNTL);
+	writel(I2S_DEC_START, dp->regs + AUDIO_SRC_CNTL);
+}
+
+static void cdn_dp_fb_audio_config_spdif(struct cdn_dp_device *dp)
+{
+	u32 val;
+
+	val = SPDIF_AVG_SEL | SPDIF_JITTER_BYPASS;
+	val |= SPDIF_FIFO_MID_RANGE(0xe0);
+	val |= SPDIF_JITTER_THRSH(0xe0);
+	val |= SPDIF_JITTER_AVG_WIN(7);
+	writel(val, dp->regs + SPDIF_CTRL_ADDR);
+
+	writel(SYNC_WR_TO_CH_ZERO, dp->regs + FIFO_CNTL);
+
+	val = MAX_NUM_CH(2) | AUDIO_TYPE_LPCM | CFG_SUB_PCKT_NUM(4);
+	writel(val, dp->regs + SMPL2PKT_CNFG);
+	writel(SMPL2PKT_EN, dp->regs + SMPL2PKT_CNTL);
+
+	val = SPDIF_ENABLE | SPDIF_AVG_SEL | SPDIF_JITTER_BYPASS;
+	val |= SPDIF_FIFO_MID_RANGE(0xe0);
+	val |= SPDIF_JITTER_THRSH(0xe0);
+	val |= SPDIF_JITTER_AVG_WIN(7);
+	writel(val, dp->regs + SPDIF_CTRL_ADDR);
+
+	clk_prepare_enable(dp->spdif_clk);
+	clk_set_rate(dp->spdif_clk, CDN_DP_SPDIF_CLK);
+}
+
+int cdn_dp_fb_audio_config(struct cdn_dp_device *dp, struct audio_info *audio)
+{
+	int ret;
+
+	/* reset the spdif clk before config */
+	if (audio->format == AFMT_SPDIF) {
+		reset_control_assert(dp->spdif_rst);
+		reset_control_deassert(dp->spdif_rst);
+	}
+
+	ret = cdn_dp_fb_reg_write(dp, CM_LANE_CTRL, LANE_REF_CYC);
+	if (ret)
+		goto err_audio_config;
+
+	ret = cdn_dp_fb_reg_write(dp, CM_CTRL, 0);
+	if (ret)
+		goto err_audio_config;
+
+	if (audio->format == AFMT_I2S)
+		cdn_dp_fb_audio_config_i2s(dp, audio);
+	else
+		cdn_dp_fb_audio_config_spdif(dp);
+
+	ret = cdn_dp_fb_reg_write(dp, AUDIO_PACK_CONTROL, AUDIO_PACK_EN);
+
+err_audio_config:
+	if (ret)
+		dev_err(dp->dev, "audio config failed: %d\n", ret);
+	return ret;
+}
diff -Nupr a/drivers/video/rockchip/dp/cdn-dp-fb-reg.h b/drivers/video/rockchip/dp/cdn-dp-fb-reg.h
--- a/drivers/video/rockchip/dp/cdn-dp-fb-reg.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/dp/cdn-dp-fb-reg.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,577 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Chris Zhong <zyw@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _CDN_DP_REG_H
+#define _CDN_DP_REG_H
+
+#include <linux/wakelock.h>
+#include <linux/mutex.h>
+#include <linux/bitops.h>
+#include <drm/drmP.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_dp_helper.h>
+#include <drm/drm_panel.h>
+
+#define MAX_PHY		2
+
+#define ADDR_IMEM		0x10000
+#define ADDR_DMEM		0x20000
+
+/* APB CFG addr */
+#define APB_CTRL			0
+#define XT_INT_CTRL			0x04
+#define MAILBOX_FULL_ADDR		0x08
+#define MAILBOX_EMPTY_ADDR		0x0c
+#define MAILBOX0_WR_DATA		0x10
+#define MAILBOX0_RD_DATA		0x14
+#define KEEP_ALIVE			0x18
+#define VER_L				0x1c
+#define VER_H				0x20
+#define VER_LIB_L_ADDR			0x24
+#define VER_LIB_H_ADDR			0x28
+#define SW_DEBUG_L			0x2c
+#define SW_DEBUG_H			0x30
+#define MAILBOX_INT_MASK		0x34
+#define MAILBOX_INT_STATUS		0x38
+#define SW_CLK_L			0x3c
+#define SW_CLK_H			0x40
+#define SW_EVENTS0			0x44
+#define SW_EVENTS1			0x48
+#define SW_EVENTS2			0x4c
+#define SW_EVENTS3			0x50
+#define XT_OCD_CTRL			0x60
+#define APB_INT_MASK			0x6c
+#define APB_STATUS_MASK			0x70
+
+/* audio decoder addr */
+#define AUDIO_SRC_CNTL			0x30000
+#define AUDIO_SRC_CNFG			0x30004
+#define COM_CH_STTS_BITS		0x30008
+#define STTS_BIT_CH(x)			(0x3000c + ((x) << 2))
+#define SPDIF_CTRL_ADDR			0x3004c
+#define SPDIF_CH1_CS_3100_ADDR		0x30050
+#define SPDIF_CH1_CS_6332_ADDR		0x30054
+#define SPDIF_CH1_CS_9564_ADDR		0x30058
+#define SPDIF_CH1_CS_12796_ADDR		0x3005c
+#define SPDIF_CH1_CS_159128_ADDR	0x30060
+#define SPDIF_CH1_CS_191160_ADDR	0x30064
+#define SPDIF_CH2_CS_3100_ADDR		0x30068
+#define SPDIF_CH2_CS_6332_ADDR		0x3006c
+#define SPDIF_CH2_CS_9564_ADDR		0x30070
+#define SPDIF_CH2_CS_12796_ADDR		0x30074
+#define SPDIF_CH2_CS_159128_ADDR	0x30078
+#define SPDIF_CH2_CS_191160_ADDR	0x3007c
+#define SMPL2PKT_CNTL			0x30080
+#define SMPL2PKT_CNFG			0x30084
+#define FIFO_CNTL			0x30088
+#define FIFO_STTS			0x3008c
+
+/* source pif addr */
+#define SOURCE_PIF_WR_ADDR		0x30800
+#define SOURCE_PIF_WR_REQ		0x30804
+#define SOURCE_PIF_RD_ADDR		0x30808
+#define SOURCE_PIF_RD_REQ		0x3080c
+#define SOURCE_PIF_DATA_WR		0x30810
+#define SOURCE_PIF_DATA_RD		0x30814
+#define SOURCE_PIF_FIFO1_FLUSH		0x30818
+#define SOURCE_PIF_FIFO2_FLUSH		0x3081c
+#define SOURCE_PIF_STATUS		0x30820
+#define SOURCE_PIF_INTERRUPT_SOURCE	0x30824
+#define SOURCE_PIF_INTERRUPT_MASK	0x30828
+#define SOURCE_PIF_PKT_ALLOC_REG	0x3082c
+#define SOURCE_PIF_PKT_ALLOC_WR_EN	0x30830
+#define SOURCE_PIF_SW_RESET		0x30834
+
+/* bellow registers need access by mailbox */
+/* source car addr */
+#define SOURCE_HDTX_CAR			0x0900
+#define SOURCE_DPTX_CAR			0x0904
+#define SOURCE_PHY_CAR			0x0908
+#define SOURCE_CEC_CAR			0x090c
+#define SOURCE_CBUS_CAR			0x0910
+#define SOURCE_PKT_CAR			0x0918
+#define SOURCE_AIF_CAR			0x091c
+#define SOURCE_CIPHER_CAR		0x0920
+#define SOURCE_CRYPTO_CAR		0x0924
+
+/* clock meters addr */
+#define CM_CTRL				0x0a00
+#define CM_I2S_CTRL			0x0a04
+#define CM_SPDIF_CTRL			0x0a08
+#define CM_VID_CTRL			0x0a0c
+#define CM_LANE_CTRL			0x0a10
+#define I2S_NM_STABLE			0x0a14
+#define I2S_NCTS_STABLE			0x0a18
+#define SPDIF_NM_STABLE			0x0a1c
+#define SPDIF_NCTS_STABLE		0x0a20
+#define NMVID_MEAS_STABLE		0x0a24
+#define I2S_MEAS			0x0a40
+#define SPDIF_MEAS			0x0a80
+#define NMVID_MEAS			0x0ac0
+
+/* source vif addr */
+#define BND_HSYNC2VSYNC			0x0b00
+#define HSYNC2VSYNC_F1_L1		0x0b04
+#define HSYNC2VSYNC_F2_L1		0x0b08
+#define HSYNC2VSYNC_STATUS		0x0b0c
+#define HSYNC2VSYNC_POL_CTRL		0x0b10
+
+/* dptx phy addr */
+#define DP_TX_PHY_CONFIG_REG		0x2000
+#define DP_TX_PHY_STATUS_REG		0x2004
+#define DP_TX_PHY_SW_RESET		0x2008
+#define DP_TX_PHY_SCRAMBLER_SEED	0x200c
+#define DP_TX_PHY_TRAINING_01_04	0x2010
+#define DP_TX_PHY_TRAINING_05_08	0x2014
+#define DP_TX_PHY_TRAINING_09_10	0x2018
+#define TEST_COR			0x23fc
+
+/* dptx hpd addr */
+#define HPD_IRQ_DET_MIN_TIMER		0x2100
+#define HPD_IRQ_DET_MAX_TIMER		0x2104
+#define HPD_UNPLGED_DET_MIN_TIMER	0x2108
+#define HPD_STABLE_TIMER		0x210c
+#define HPD_FILTER_TIMER		0x2110
+#define HPD_EVENT_MASK			0x211c
+#define HPD_EVENT_DET			0x2120
+
+/* dpyx framer addr */
+#define DP_FRAMER_GLOBAL_CONFIG		0x2200
+#define DP_SW_RESET			0x2204
+#define DP_FRAMER_TU			0x2208
+#define DP_FRAMER_PXL_REPR		0x220c
+#define DP_FRAMER_SP			0x2210
+#define AUDIO_PACK_CONTROL		0x2214
+#define DP_VC_TABLE(x)			(0x2218 + ((x) << 2))
+#define DP_VB_ID			0x2258
+#define DP_MTPH_LVP_CONTROL		0x225c
+#define DP_MTPH_SYMBOL_VALUES		0x2260
+#define DP_MTPH_ECF_CONTROL		0x2264
+#define DP_MTPH_ACT_CONTROL		0x2268
+#define DP_MTPH_STATUS			0x226c
+#define DP_INTERRUPT_SOURCE		0x2270
+#define DP_INTERRUPT_MASK		0x2274
+#define DP_FRONT_BACK_PORCH		0x2278
+#define DP_BYTE_COUNT			0x227c
+
+/* dptx stream addr */
+#define MSA_HORIZONTAL_0		0x2280
+#define MSA_HORIZONTAL_1		0x2284
+#define MSA_VERTICAL_0			0x2288
+#define MSA_VERTICAL_1			0x228c
+#define MSA_MISC			0x2290
+#define STREAM_CONFIG			0x2294
+#define AUDIO_PACK_STATUS		0x2298
+#define VIF_STATUS			0x229c
+#define PCK_STUFF_STATUS_0		0x22a0
+#define PCK_STUFF_STATUS_1		0x22a4
+#define INFO_PACK_STATUS		0x22a8
+#define RATE_GOVERNOR_STATUS		0x22ac
+#define DP_HORIZONTAL			0x22b0
+#define DP_VERTICAL_0			0x22b4
+#define DP_VERTICAL_1			0x22b8
+#define DP_BLOCK_SDP			0x22bc
+
+/* dptx glbl addr */
+#define DPTX_LANE_EN			0x2300
+#define DPTX_ENHNCD			0x2304
+#define DPTX_INT_MASK			0x2308
+#define DPTX_INT_STATUS			0x230c
+
+/* dp aux addr */
+#define DP_AUX_HOST_CONTROL		0x2800
+#define DP_AUX_INTERRUPT_SOURCE		0x2804
+#define DP_AUX_INTERRUPT_MASK		0x2808
+#define DP_AUX_SWAP_INVERSION_CONTROL	0x280c
+#define DP_AUX_SEND_NACK_TRANSACTION	0x2810
+#define DP_AUX_CLEAR_RX			0x2814
+#define DP_AUX_CLEAR_TX			0x2818
+#define DP_AUX_TIMER_STOP		0x281c
+#define DP_AUX_TIMER_CLEAR		0x2820
+#define DP_AUX_RESET_SW			0x2824
+#define DP_AUX_DIVIDE_2M		0x2828
+#define DP_AUX_TX_PREACHARGE_LENGTH	0x282c
+#define DP_AUX_FREQUENCY_1M_MAX		0x2830
+#define DP_AUX_FREQUENCY_1M_MIN		0x2834
+#define DP_AUX_RX_PRE_MIN		0x2838
+#define DP_AUX_RX_PRE_MAX		0x283c
+#define DP_AUX_TIMER_PRESET		0x2840
+#define DP_AUX_NACK_FORMAT		0x2844
+#define DP_AUX_TX_DATA			0x2848
+#define DP_AUX_RX_DATA			0x284c
+#define DP_AUX_TX_STATUS		0x2850
+#define DP_AUX_RX_STATUS		0x2854
+#define DP_AUX_RX_CYCLE_COUNTER		0x2858
+#define DP_AUX_MAIN_STATES		0x285c
+#define DP_AUX_MAIN_TIMER		0x2860
+#define DP_AUX_AFE_OUT			0x2864
+
+/* crypto addr */
+#define CRYPTO_HDCP_REVISION		0x5800
+#define HDCP_CRYPTO_CONFIG		0x5804
+#define CRYPTO_INTERRUPT_SOURCE		0x5808
+#define CRYPTO_INTERRUPT_MASK		0x580c
+#define CRYPTO22_CONFIG			0x5818
+#define CRYPTO22_STATUS			0x581c
+#define SHA_256_DATA_IN			0x583c
+#define SHA_256_DATA_OUT_(x)		(0x5850 + ((x) << 2))
+#define AES_32_KEY_(x)			(0x5870 + ((x) << 2))
+#define AES_32_DATA_IN			0x5880
+#define AES_32_DATA_OUT_(x)		(0x5884 + ((x) << 2))
+#define CRYPTO14_CONFIG			0x58a0
+#define CRYPTO14_STATUS			0x58a4
+#define CRYPTO14_PRNM_OUT		0x58a8
+#define CRYPTO14_KM_0			0x58ac
+#define CRYPTO14_KM_1			0x58b0
+#define CRYPTO14_AN_0			0x58b4
+#define CRYPTO14_AN_1			0x58b8
+#define CRYPTO14_YOUR_KSV_0		0x58bc
+#define CRYPTO14_YOUR_KSV_1		0x58c0
+#define CRYPTO14_MI_0			0x58c4
+#define CRYPTO14_MI_1			0x58c8
+#define CRYPTO14_TI_0			0x58cc
+#define CRYPTO14_KI_0			0x58d0
+#define CRYPTO14_KI_1			0x58d4
+#define CRYPTO14_BLOCKS_NUM		0x58d8
+#define CRYPTO14_KEY_MEM_DATA_0		0x58dc
+#define CRYPTO14_KEY_MEM_DATA_1		0x58e0
+#define CRYPTO14_SHA1_MSG_DATA		0x58e4
+#define CRYPTO14_SHA1_V_VALUE_(x)	(0x58e8 + ((x) << 2))
+#define TRNG_CTRL			0x58fc
+#define TRNG_DATA_RDY			0x5900
+#define TRNG_DATA			0x5904
+
+/* cipher addr */
+#define HDCP_REVISION			0x60000
+#define INTERRUPT_SOURCE		0x60004
+#define INTERRUPT_MASK			0x60008
+#define HDCP_CIPHER_CONFIG		0x6000c
+#define AES_128_KEY_0			0x60010
+#define AES_128_KEY_1			0x60014
+#define AES_128_KEY_2			0x60018
+#define AES_128_KEY_3			0x6001c
+#define AES_128_RANDOM_0		0x60020
+#define AES_128_RANDOM_1		0x60024
+#define CIPHER14_KM_0			0x60028
+#define CIPHER14_KM_1			0x6002c
+#define CIPHER14_STATUS			0x60030
+#define CIPHER14_RI_PJ_STATUS		0x60034
+#define CIPHER_MODE			0x60038
+#define CIPHER14_AN_0			0x6003c
+#define CIPHER14_AN_1			0x60040
+#define CIPHER22_AUTH			0x60044
+#define CIPHER14_R0_DP_STATUS		0x60048
+#define CIPHER14_BOOTSTRAP		0x6004c
+
+#define DPTX_FRMR_DATA_CLK_RSTN_EN	BIT(11)
+#define DPTX_FRMR_DATA_CLK_EN		BIT(10)
+#define DPTX_PHY_DATA_RSTN_EN		BIT(9)
+#define DPTX_PHY_DATA_CLK_EN		BIT(8)
+#define DPTX_PHY_CHAR_RSTN_EN		BIT(7)
+#define DPTX_PHY_CHAR_CLK_EN		BIT(6)
+#define SOURCE_AUX_SYS_CLK_RSTN_EN	BIT(5)
+#define SOURCE_AUX_SYS_CLK_EN		BIT(4)
+#define DPTX_SYS_CLK_RSTN_EN		BIT(3)
+#define DPTX_SYS_CLK_EN			BIT(2)
+#define CFG_DPTX_VIF_CLK_RSTN_EN	BIT(1)
+#define CFG_DPTX_VIF_CLK_EN		BIT(0)
+
+#define SOURCE_PHY_RSTN_EN		BIT(1)
+#define SOURCE_PHY_CLK_EN		BIT(0)
+
+#define SOURCE_PKT_SYS_RSTN_EN		BIT(3)
+#define SOURCE_PKT_SYS_CLK_EN		BIT(2)
+#define SOURCE_PKT_DATA_RSTN_EN		BIT(1)
+#define SOURCE_PKT_DATA_CLK_EN		BIT(0)
+
+#define SPDIF_CDR_CLK_RSTN_EN		BIT(5)
+#define SPDIF_CDR_CLK_EN		BIT(4)
+#define SOURCE_AIF_SYS_RSTN_EN		BIT(3)
+#define SOURCE_AIF_SYS_CLK_EN		BIT(2)
+#define SOURCE_AIF_CLK_RSTN_EN		BIT(1)
+#define SOURCE_AIF_CLK_EN		BIT(0)
+
+#define SOURCE_CIPHER_SYSTEM_CLK_RSTN_EN	BIT(3)
+#define SOURCE_CIPHER_SYS_CLK_EN		BIT(2)
+#define SOURCE_CIPHER_CHAR_CLK_RSTN_EN		BIT(1)
+#define SOURCE_CIPHER_CHAR_CLK_EN		BIT(0)
+
+#define SOURCE_CRYPTO_SYS_CLK_RSTN_EN	BIT(1)
+#define SOURCE_CRYPTO_SYS_CLK_EN	BIT(0)
+
+#define APB_IRAM_PATH			BIT(2)
+#define APB_DRAM_PATH			BIT(1)
+#define APB_XT_RESET			BIT(0)
+
+#define MAILBOX_INT_MASK_BIT		BIT(1)
+#define PIF_INT_MASK_BIT		BIT(0)
+#define ALL_INT_MASK			3
+
+/* mailbox */
+#define MB_OPCODE_ID			0
+#define MB_MODULE_ID			1
+#define MB_SIZE_MSB_ID			2
+#define MB_SIZE_LSB_ID			3
+#define MB_DATA_ID			4
+
+#define MB_MODULE_ID_DP_TX		0x01
+#define MB_MODULE_ID_HDCP_TX		0x07
+#define MB_MODULE_ID_HDCP_RX		0x08
+#define MB_MODULE_ID_HDCP_GENERAL	0x09
+#define MB_MODULE_ID_GENERAL		0x0a
+
+/* general opcode */
+#define GENERAL_MAIN_CONTROL            0x01
+#define GENERAL_TEST_ECHO               0x02
+#define GENERAL_BUS_SETTINGS            0x03
+#define GENERAL_TEST_ACCESS             0x04
+
+#define DPTX_SET_POWER_MNG			0x00
+#define DPTX_SET_HOST_CAPABILITIES		0x01
+#define DPTX_GET_EDID				0x02
+#define DPTX_READ_DPCD				0x03
+#define DPTX_WRITE_DPCD				0x04
+#define DPTX_ENABLE_EVENT			0x05
+#define DPTX_WRITE_REGISTER			0x06
+#define DPTX_READ_REGISTER			0x07
+#define DPTX_WRITE_FIELD			0x08
+#define DPTX_TRAINING_CONTROL			0x09
+#define DPTX_READ_EVENT				0x0a
+#define DPTX_READ_LINK_STAT			0x0b
+#define DPTX_SET_VIDEO				0x0c
+#define DPTX_SET_AUDIO				0x0d
+#define DPTX_GET_LAST_AUX_STAUS			0x0e
+#define DPTX_SET_LINK_BREAK_POINT		0x0f
+#define DPTX_FORCE_LANES			0x10
+#define DPTX_HPD_STATE				0x11
+
+#define FW_STANDBY				0
+#define FW_ACTIVE				1
+
+#define DPTX_EVENT_ENABLE_HPD			BIT(0)
+#define DPTX_EVENT_ENABLE_TRAINING		BIT(1)
+
+#define LINK_TRAINING_NOT_ACTIVE		0
+#define LINK_TRAINING_RUN			1
+#define LINK_TRAINING_RESTART			2
+
+#define CONTROL_VIDEO_IDLE			0
+#define CONTROL_VIDEO_VALID			1
+
+#define VIF_BYPASS_INTERLACE			BIT(13)
+#define INTERLACE_FMT_DET			BIT(12)
+#define INTERLACE_DTCT_WIN			0x20
+
+#define DP_FRAMER_SP_INTERLACE_EN		BIT(2)
+#define DP_FRAMER_SP_HSP			BIT(1)
+#define DP_FRAMER_SP_VSP			BIT(0)
+
+/* capability */
+#define AUX_HOST_INVERT				3
+#define	FAST_LT_SUPPORT				1
+#define FAST_LT_NOT_SUPPORT			0
+#define LANE_MAPPING_NORMAL			0x1b
+#define LANE_MAPPING_FLIPPED			0xe4
+#define ENHANCED				1
+
+#define	FULL_LT_STARTED				BIT(0)
+#define FASE_LT_STARTED				BIT(1)
+#define CLK_RECOVERY_FINISHED			BIT(2)
+#define EQ_PHASE_FINISHED			BIT(3)
+#define FASE_LT_START_FINISHED			BIT(4)
+#define CLK_RECOVERY_FAILED			BIT(5)
+#define EQ_PHASE_FAILED				BIT(6)
+#define FASE_LT_FAILED				BIT(7)
+
+#define DPTX_HPD_EVENT				BIT(0)
+#define DPTX_TRAINING_EVENT			BIT(1)
+#define HDCP_TX_STATUS_EVENT			BIT(4)
+#define HDCP2_TX_IS_KM_STORED_EVENT		BIT(5)
+#define HDCP2_TX_STORE_KM_EVENT			BIT(6)
+#define HDCP_TX_IS_RECEIVER_ID_VALID_EVENT	BIT(7)
+
+#define TU_SIZE					30
+#define CDN_DP_MAX_LINK_RATE			DP_LINK_BW_5_4
+
+/* audio */
+#define AUDIO_PACK_EN				BIT(8)
+#define SAMPLING_FREQ(x)			(((x) & 0xf) << 16)
+#define ORIGINAL_SAMP_FREQ(x)			(((x) & 0xf) << 24)
+#define SYNC_WR_TO_CH_ZERO			BIT(1)
+#define I2S_DEC_START				BIT(1)
+#define AUDIO_SW_RST				BIT(0)
+#define SMPL2PKT_EN				BIT(1)
+#define MAX_NUM_CH(x)				(((x) & 0x1f) - 1)
+#define NUM_OF_I2S_PORTS(x)			((((x) / 2 - 1) & 0x3) << 5)
+#define AUDIO_TYPE_LPCM				(2 << 7)
+#define CFG_SUB_PCKT_NUM(x)			((((x) - 1) & 0x7) << 11)
+#define AUDIO_CH_NUM(x)				((((x) - 1) & 0x1f) << 2)
+#define TRANS_SMPL_WIDTH_16			0
+#define TRANS_SMPL_WIDTH_24			BIT(11)
+#define TRANS_SMPL_WIDTH_32			(2 << 11)
+#define I2S_DEC_PORT_EN(x)			(((x) & 0xf) << 17)
+#define SPDIF_ENABLE				BIT(21)
+#define SPDIF_AVG_SEL				BIT(20)
+#define SPDIF_JITTER_BYPASS			BIT(19)
+#define SPDIF_FIFO_MID_RANGE(x)			(((x) & 0xff) << 11)
+#define SPDIF_JITTER_THRSH(x)			(((x) & 0xff) << 3)
+#define SPDIF_JITTER_AVG_WIN(x)			((x) & 0x7)
+
+/* Refernce cycles when using lane clock as refernce */
+#define LANE_REF_CYC				0x8000
+
+enum voltage_swing_level {
+	VOLTAGE_LEVEL_0,
+	VOLTAGE_LEVEL_1,
+	VOLTAGE_LEVEL_2,
+	VOLTAGE_LEVEL_3,
+};
+
+enum pre_emphasis_level {
+	PRE_EMPHASIS_LEVEL_0,
+	PRE_EMPHASIS_LEVEL_1,
+	PRE_EMPHASIS_LEVEL_2,
+	PRE_EMPHASIS_LEVEL_3,
+};
+
+enum pattern_set {
+	PTS1		= BIT(0),
+	PTS2		= BIT(1),
+	PTS3		= BIT(2),
+	PTS4		= BIT(3),
+	DP_NONE		= BIT(4)
+};
+
+enum vic_color_depth {
+	BCS_6 = 0x1,
+	BCS_8 = 0x2,
+	BCS_10 = 0x4,
+	BCS_12 = 0x8,
+	BCS_16 = 0x10,
+};
+
+enum vic_bt_type {
+	BT_601 = 0x0,
+	BT_709 = 0x1,
+};
+
+enum audio_format {
+	AFMT_I2S = 0,
+	AFMT_SPDIF = 1,
+	AFMT_UNUSED,
+};
+
+struct audio_info {
+	enum audio_format format;
+	int sample_rate;
+	int channels;
+	int sample_width;
+};
+
+enum vic_pxl_encoding_format {
+	PXL_RGB = 0x1,
+	YCBCR_4_4_4 = 0x2,
+	YCBCR_4_2_2 = 0x4,
+	YCBCR_4_2_0 = 0x8,
+	Y_ONLY = 0x10,
+};
+
+struct video_info {
+	bool h_sync_polarity;
+	bool v_sync_polarity;
+	bool interlaced;
+	int color_depth;
+	enum vic_pxl_encoding_format color_fmt;
+};
+
+struct cdn_firmware_header {
+	u32 size_bytes; /* size of the entire header+image(s) in bytes */
+	u32 header_size; /* size of just the header in bytes */
+	u32 iram_size; /* size of iram */
+	u32 dram_size; /* size of dram */
+};
+
+struct cdn_dp_port {
+	struct cdn_dp_device *dp;
+	struct notifier_block event_nb;
+	struct delayed_work event_wq;
+	struct extcon_dev *extcon;
+	struct phy *phy;
+	u8 cap_lanes;
+	bool phy_status;
+	u8 id;
+};
+
+struct cdn_dp_device {
+	struct device *dev;
+	struct drm_device *drm_dev;
+	struct drm_connector connector;
+	struct drm_encoder encoder;
+	struct drm_display_mode mode;
+	struct platform_device *audio_pdev;
+
+	const struct firmware *fw;	/* cdn dp firmware */
+	unsigned int fw_version;	/* cdn fw version */
+	u32 fw_wait;
+	bool fw_loaded;
+	bool fw_actived;
+	bool fw_clk_enabled;
+	void __iomem *regs;
+	struct regmap *grf;
+	struct clk *grf_clk;
+	struct clk *core_clk;
+	struct clk *pclk;
+	struct clk *spdif_clk;
+	struct reset_control *spdif_rst;
+	struct reset_control *dptx_rst;
+	struct reset_control *apb_rst;
+	struct reset_control *core_rst;
+	struct audio_info audio_info;
+	struct video_info video_info;
+	struct drm_dp_link link;
+	struct cdn_dp_port *port[MAX_PHY];
+	u8 ports;
+
+	u8 dpcd[DP_RECEIVER_CAP_SIZE];
+	enum drm_connector_status hpd_status;
+	int dpms_mode;
+	bool suspend;
+	bool sink_has_audio;
+
+	struct mutex lock;
+	struct wake_lock	wake_lock;
+};
+
+void cdn_dp_fb_clock_reset(struct cdn_dp_device *dp);
+
+void cdn_dp_fb_set_fw_clk(struct cdn_dp_device *dp, u32 clk);
+int cdn_dp_fb_load_firmware(struct cdn_dp_device *dp, const u32 *i_mem,
+			 u32 i_size, const u32 *d_mem, u32 d_size);
+int cdn_dp_fb_set_firmware_active(struct cdn_dp_device *dp, bool enable);
+int cdn_dp_fb_set_host_cap(struct cdn_dp_device *dp, u8 lanes, bool flip);
+int cdn_dp_fb_event_config(struct cdn_dp_device *dp);
+u32 cdn_dp_fb_get_event(struct cdn_dp_device *dp);
+int cdn_dp_fb_get_hpd_status(struct cdn_dp_device *dp);
+int cdn_dp_fb_dpcd_write(struct cdn_dp_device *dp, u32 addr, u8 value);
+int cdn_dp_fb_dpcd_read(struct cdn_dp_device *dp, u32 addr, u8 *data, u16 len);
+int cdn_dp_fb_get_edid_block(void *dp, u8 *edid,
+			  unsigned int block, size_t length);
+int cdn_dp_fb_training_start(struct cdn_dp_device *dp);
+int cdn_dp_fb_get_training_status(struct cdn_dp_device *dp);
+int cdn_dp_fb_set_video_status(struct cdn_dp_device *dp, int active);
+int cdn_dp_fb_config_video(struct cdn_dp_device *dp);
+int cdn_dp_fb_audio_stop(struct cdn_dp_device *dp, struct audio_info *audio);
+int cdn_dp_fb_audio_mute(struct cdn_dp_device *dp, bool enable);
+int cdn_dp_fb_audio_config(struct cdn_dp_device *dp, struct audio_info *audio);
+#endif /* _CDN_DP_REG_H */
diff -Nupr a/drivers/video/rockchip/dp/Kconfig b/drivers/video/rockchip/dp/Kconfig
--- a/drivers/video/rockchip/dp/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/dp/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,13 @@
+# SPDX-License-Identifier: GPL-2.0
+menu "DP"
+
+config ROCKCHIP_DP
+	tristate "ROCKCHIP fb cdn dp driver"
+	depends on RK_HDMI
+	select SND_SOC_HDMI_CODEC if SND_SOC
+	help
+	  This selects support for Rockchip SoC specific extensions
+	  for the cdn DP driver. If you want to enable Dp on
+	  RK3399 based SoC with rkfb, you should select this
+	  option.
+endmenu
diff -Nupr a/drivers/video/rockchip/dp/Makefile b/drivers/video/rockchip/dp/Makefile
--- a/drivers/video/rockchip/dp/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/dp/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_ROCKCHIP_DP) += rockchip_dp_core.o rockchip_dp.o cdn-dp-fb-reg.o
diff -Nupr a/drivers/video/rockchip/dp/rockchip_dp.c b/drivers/video/rockchip/dp/rockchip_dp.c
--- a/drivers/video/rockchip/dp/rockchip_dp.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/dp/rockchip_dp.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,328 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include "rockchip_dp.h"
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+
+static int rockchip_dp_removed(struct hdmi *hdmi_drv)
+{
+	struct dp_dev *dp_dev = hdmi_drv->property->priv;
+	int ret;
+
+	ret = cdn_dp_encoder_disable(dp_dev->dp);
+	if (ret)
+		dev_warn(hdmi_drv->dev, "dp has been removed twice:%d\n", ret);
+	return HDMI_ERROR_SUCCESS;
+}
+
+static int rockchip_dp_enable(struct hdmi *hdmi_drv)
+{
+	return 0;
+}
+
+static int rockchip_dp_disable(struct hdmi *hdmi_drv)
+{
+	return 0;
+}
+
+static int rockchip_dp_control_output(struct hdmi *hdmi_drv, int enable)
+{
+	struct dp_dev *dp_dev = hdmi_drv->property->priv;
+	int ret;
+
+	if (enable == HDMI_AV_UNMUTE) {
+		if (!dp_dev->early_suspended) {
+			ret = cdn_dp_encoder_enable(dp_dev->dp);
+			if (ret) {
+				dev_err(hdmi_drv->dev,
+					"dp enable video and audio output error:%d\n", ret);
+				return HDMI_ERROR_FALSE;
+			}
+		} else
+			dev_warn(hdmi_drv->dev,
+				"don't output video and audio after dp has been suspended!\n");
+	} else if (enable & HDMI_VIDEO_MUTE)
+		dev_dbg(hdmi_drv->dev, "dp disable video and audio output !\n");
+
+	return 0;
+}
+
+static int rockchip_dp_config_audio(struct hdmi *hdmi_drv,
+				    struct hdmi_audio *audio)
+{
+	return 0;
+}
+
+static int rockchip_dp_config_video(struct hdmi *hdmi_drv,
+				    struct hdmi_video *vpara)
+{
+	struct hdmi_video_timing *timing = NULL;
+	struct dp_dev *dp_dev = hdmi_drv->property->priv;
+	struct dp_disp_info *disp_info = &dp_dev->disp_info;
+	int ret;
+
+	if (dp_dev->early_suspended) {
+		dev_warn(hdmi_drv->dev,
+			"don't config video after dp has been suspended!\n");
+		return 0;
+	}
+
+	timing = (struct hdmi_video_timing *)hdmi_vic2timing(vpara->vic);
+	if (!timing) {
+		dev_err(hdmi_drv->dev,
+			"[%s] not found vic %d\n", __func__, vpara->vic);
+		return -ENOENT;
+	}
+	disp_info->mode = &timing->mode;
+
+	disp_info->color_depth = vpara->color_output_depth;
+	disp_info->vsync_polarity = 1;
+	disp_info->hsync_polarity = 1;
+
+	ret = cdn_dp_encoder_mode_set(dp_dev->dp, disp_info);
+	if (ret) {
+		dev_err(hdmi_drv->dev, "dp config video mode error:%d\n", ret);
+		return HDMI_ERROR_FALSE;
+	}
+
+	return 0;
+}
+
+static int rockchip_dp_detect_hotplug(struct hdmi *hdmi_drv)
+{
+	struct dp_dev *dp_dev = hdmi_drv->property->priv;
+
+	if (cdn_dp_connector_detect(dp_dev->dp))
+		return HDMI_HPD_ACTIVATED;
+	return HDMI_HPD_REMOVED;
+}
+
+static int rockchip_dp_read_edid(struct hdmi *hdmi_drv, int block, u8 *buf)
+{
+	int ret = 0;
+	struct dp_dev *dp_dev = hdmi_drv->property->priv;
+
+	if (dp_dev->lanes == 4)
+		dp_dev->hdmi->property->feature |= SUPPORT_TMDS_600M;
+	else
+		dp_dev->hdmi->property->feature &= ~SUPPORT_TMDS_600M;
+
+	ret = cdn_dp_get_edid(dp_dev->dp, buf, block);
+	if (ret)
+		dev_err(hdmi_drv->dev, "dp config video mode error:%d\n", ret);
+
+	return ret;
+}
+
+static int rockchip_dp_insert(struct hdmi *hdmi_drv)
+{
+	return 0;
+}
+
+static int rockchip_dp_config_vsi(struct hdmi *hdmi,
+				  unsigned char vic_3d,
+				  unsigned char format)
+{
+	return 0;
+}
+
+static void rockchip_dp_dev_init_ops(struct hdmi_ops *ops)
+{
+	if (ops) {
+		ops->disable = rockchip_dp_disable;
+		ops->enable = rockchip_dp_enable;
+		ops->remove = rockchip_dp_removed;
+		ops->setmute = rockchip_dp_control_output;
+		ops->setvideo = rockchip_dp_config_video;
+		ops->setaudio = rockchip_dp_config_audio;
+		ops->getstatus = rockchip_dp_detect_hotplug;
+		ops->getedid = rockchip_dp_read_edid;
+		ops->insert     = rockchip_dp_insert;
+		ops->setvsi = rockchip_dp_config_vsi;
+	}
+}
+
+void hpd_change(struct device *dev, int lanes)
+{
+	struct dp_dev *dp_dev = dev_get_drvdata(dev);
+
+	if (lanes)
+		dp_dev->lanes = lanes;
+
+	if (dp_dev->hdmi->enable) {
+		if (dp_dev->early_suspended)
+			dev_warn(dp_dev->hdmi->dev,
+				"hpd triggered after early suspend, so don't send hpd change event !\n");
+		else
+			hdmi_submit_work(dp_dev->hdmi, HDMI_HPD_CHANGE, 10, 0);
+	}
+}
+
+static void rockchip_dp_early_suspend(struct dp_dev *dp_dev)
+{
+	hdmi_submit_work(dp_dev->hdmi, HDMI_SUSPEND_CTL, 0, 1);
+	cdn_dp_fb_suspend(dp_dev->dp);
+}
+
+static void rockchip_dp_early_resume(struct dp_dev *dp_dev)
+{
+	cdn_dp_fb_resume(dp_dev->dp);
+	hdmi_submit_work(dp_dev->hdmi, HDMI_RESUME_CTL, 0, 0);
+}
+
+static int rockchip_dp_fb_event_notify(struct notifier_block *self,
+				       unsigned long action,
+					   void *data)
+{
+	struct fb_event *event = data;
+	struct dp_dev *dp_dev = container_of(self, struct dp_dev, fb_notif);
+
+	if (action == FB_EARLY_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			break;
+		default:
+			if (!dp_dev->hdmi->sleep) {
+				rockchip_dp_early_suspend(dp_dev);
+				dp_dev->early_suspended = true;
+			}
+			break;
+		}
+	} else if (action == FB_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			if (dp_dev->hdmi->sleep) {
+				dp_dev->early_suspended = false;
+				rockchip_dp_early_resume(dp_dev);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	return NOTIFY_OK;
+}
+
+static int cdn_dp_get_prop_dts(struct hdmi *hdmi, struct device_node *np)
+{
+	const struct property *prop;
+	int i = 0, nstates = 0;
+	const __be32 *val;
+	int value;
+	struct edid_prop_value *pval = NULL;
+
+	if (!hdmi || !np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "dp_edid_auto_support", &value))
+		hdmi->edid_auto_support = value;
+
+	prop = of_find_property(np, "dp_edid_prop_value", NULL);
+	if (!prop || !prop->value) {
+		pr_info("%s:No edid-prop-value, %d\n", __func__, !prop);
+		return -EINVAL;
+	}
+
+	nstates = (prop->length / sizeof(struct edid_prop_value));
+	pval = kcalloc(nstates, sizeof(struct edid_prop_value), GFP_NOWAIT);
+	if (!pval)
+		return -ENOMEM;
+
+	for (i = 0, val = prop->value; i < nstates; i++) {
+		pval[i].vid = be32_to_cpup(val++);
+		pval[i].pid = be32_to_cpup(val++);
+		pval[i].sn = be32_to_cpup(val++);
+		pval[i].xres = be32_to_cpup(val++);
+		pval[i].yres = be32_to_cpup(val++);
+		pval[i].vic = be32_to_cpup(val++);
+		pval[i].width = be32_to_cpup(val++);
+		pval[i].height = be32_to_cpup(val++);
+		pval[i].x_w = be32_to_cpup(val++);
+		pval[i].x_h = be32_to_cpup(val++);
+		pval[i].hwrotation = be32_to_cpup(val++);
+		pval[i].einit = be32_to_cpup(val++);
+		pval[i].vsync = be32_to_cpup(val++);
+		pval[i].panel = be32_to_cpup(val++);
+		pval[i].scan = be32_to_cpup(val++);
+
+		pr_info("%s: 0x%x 0x%x 0x%x %d %d %d %d %d %d %d %d %d %d %d %d\n",
+			__func__, pval[i].vid, pval[i].pid, pval[i].sn,
+			pval[i].width, pval[i].height, pval[i].xres,
+			pval[i].yres, pval[i].vic, pval[i].x_w,
+			pval[i].x_h, pval[i].hwrotation, pval[i].einit,
+			pval[i].vsync, pval[i].panel, pval[i].scan);
+	}
+
+	hdmi->pvalue = pval;
+	hdmi->nstates = nstates;
+
+	return 0;
+}
+
+int cdn_dp_fb_register(struct platform_device *pdev, void *dp)
+{
+	struct hdmi_ops *rk_dp_ops;
+	struct hdmi_property *rk_cdn_dp_prop;
+	struct device *dev = &pdev->dev;
+	struct dp_dev *dp_dev;
+	struct device_node *np = dev->of_node;
+	int val = 0;
+
+	rk_dp_ops = devm_kzalloc(dev, sizeof(struct hdmi_ops), GFP_KERNEL);
+	if (!rk_dp_ops)
+		return -ENOMEM;
+
+	rk_cdn_dp_prop = devm_kzalloc(dev, sizeof(struct hdmi_property),
+				      GFP_KERNEL);
+	if (!rk_cdn_dp_prop)
+		return -ENOMEM;
+
+	dp_dev = devm_kzalloc(dev, sizeof(struct dp_dev), GFP_KERNEL);
+	if (!dp_dev)
+		return -ENOMEM;
+
+	if (!of_property_read_u32(np, "dp_vop_sel", &val))
+		dp_dev->disp_info.vop_sel = val;
+
+	rockchip_dp_dev_init_ops(rk_dp_ops);
+	rk_cdn_dp_prop->videosrc = dp_dev->disp_info.vop_sel;
+	rk_cdn_dp_prop->display = DISPLAY_MAIN;
+	if (!of_property_read_u32(np, "dp_defaultmode", &val))
+		rk_cdn_dp_prop->defaultmode = val;
+	else
+		rk_cdn_dp_prop->defaultmode = HDMI_VIDEO_DEFAULT_MODE;
+	rk_cdn_dp_prop->name = (char *)pdev->name;
+	rk_cdn_dp_prop->priv = dp_dev;
+	rk_cdn_dp_prop->feature |=
+				SUPPORT_DEEP_10BIT |
+				SUPPORT_YCBCR_INPUT |
+				SUPPORT_1080I |
+				SUPPORT_480I_576I |
+				SUPPORT_RK_DISCRETE_VR;
+
+	if (!rk_cdn_dp_prop->videosrc) {
+		rk_cdn_dp_prop->feature |=
+					SUPPORT_4K |
+					SUPPORT_4K_4096 |
+					SUPPORT_YUV420 |
+					SUPPORT_YCBCR_INPUT |
+					SUPPORT_TMDS_600M;
+	}
+
+	dp_dev->hdmi = rockchip_hdmi_register(rk_cdn_dp_prop,
+						rk_dp_ops);
+	dp_dev->hdmi->dev = dev;
+	dp_dev->hdmi->enable = 1;
+	dp_dev->early_suspended = 0;
+	dp_dev->hdmi->sleep = 0;
+	dp_dev->hdmi->colormode = HDMI_COLOR_RGB_0_255;
+	dp_dev->dp = dp;
+
+	cdn_dp_get_prop_dts(dp_dev->hdmi, np);
+	dp_dev->fb_notif.notifier_call = rockchip_dp_fb_event_notify;
+	fb_register_client(&dp_dev->fb_notif);
+	dev_set_drvdata(dev, dp_dev);
+
+	hdmi_submit_work(dp_dev->hdmi, HDMI_HPD_CHANGE, 20, 0);
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/dp/rockchip_dp_core.c b/drivers/video/rockchip/dp/rockchip_dp_core.c
--- a/drivers/video/rockchip/dp/rockchip_dp_core.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/dp/rockchip_dp_core.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,950 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Chris Zhong <zyw@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/extcon.h>
+#include <linux/firmware.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/mfd/syscon.h>
+#include <linux/phy/phy.h>
+#include <sound/hdmi-codec.h>
+#include <video/of_videomode.h>
+#include <video/videomode.h>
+
+#include <linux/fb.h>
+#include <linux/platform_device.h>
+#include "rockchip_dp_core.h"
+#include "cdn-dp-fb-reg.h"
+
+static struct cdn_dp_data rk3399_cdn_dp = {
+	.max_phy = 2,
+};
+
+static const struct of_device_id cdn_dp_dt_ids[] = {
+	{ .compatible = "rockchip,rk3399-cdn-dp-fb",
+		.data = (void *)&rk3399_cdn_dp },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, cdn_dp_dt_ids);
+
+static int cdn_dp_grf_write(struct cdn_dp_device *dp,
+			    unsigned int reg, unsigned int val)
+{
+	int ret;
+
+	ret = clk_prepare_enable(dp->grf_clk);
+	if (ret) {
+		dev_err(dp->dev, "Failed to prepare_enable grf clock\n");
+		return ret;
+	}
+
+	ret = regmap_write(dp->grf, reg, val);
+	if (ret) {
+		dev_err(dp->dev, "Could not write to GRF: %d\n", ret);
+		return ret;
+	}
+
+	clk_disable_unprepare(dp->grf_clk);
+
+	return 0;
+}
+
+static int cdn_dp_set_fw_rate(struct cdn_dp_device *dp)
+{
+	u32 rate;
+
+	if (!dp->fw_clk_enabled) {
+		rate = clk_get_rate(dp->core_clk);
+		if (rate == 0) {
+			dev_err(dp->dev, "get clk rate failed: %d\n", rate);
+			return rate;
+		}
+		cdn_dp_fb_set_fw_clk(dp, rate);
+		cdn_dp_fb_clock_reset(dp);
+		dp->fw_clk_enabled = true;
+	}
+
+	return 0;
+}
+
+static int cdn_dp_clk_enable(struct cdn_dp_device *dp)
+{
+	int ret;
+
+	ret = clk_prepare_enable(dp->pclk);
+	if (ret < 0) {
+		dev_err(dp->dev, "cannot enable dp pclk %d\n", ret);
+		goto runtime_get_pm;
+	}
+
+	ret = clk_prepare_enable(dp->core_clk);
+	if (ret < 0) {
+		dev_err(dp->dev, "cannot enable core_clk %d\n", ret);
+		goto err_core_clk;
+	}
+
+	ret = pm_runtime_get_sync(dp->dev);
+	if (ret < 0) {
+		dev_err(dp->dev, "cannot get pm runtime %d\n", ret);
+		return ret;
+	}
+
+	reset_control_assert(dp->apb_rst);
+	reset_control_assert(dp->core_rst);
+	reset_control_assert(dp->dptx_rst);
+	udelay(1);
+	reset_control_deassert(dp->dptx_rst);
+	reset_control_deassert(dp->core_rst);
+	reset_control_deassert(dp->apb_rst);
+
+	ret = cdn_dp_set_fw_rate(dp);
+	if (ret < 0) {
+		dev_err(dp->dev, "cannot get set fw rate %d\n", ret);
+		goto err_set_rate;
+	}
+
+	return 0;
+
+err_set_rate:
+	clk_disable_unprepare(dp->core_clk);
+err_core_clk:
+	clk_disable_unprepare(dp->pclk);
+runtime_get_pm:
+	pm_runtime_put_sync(dp->dev);
+	return ret;
+}
+
+static void cdn_dp_clk_disable(struct cdn_dp_device *dp)
+{
+	pm_runtime_put_sync(dp->dev);
+	clk_disable_unprepare(dp->pclk);
+	clk_disable_unprepare(dp->core_clk);
+}
+
+int cdn_dp_get_edid(void *dp, u8 *buf, int block)
+{
+	int ret;
+	struct cdn_dp_device *dp_dev = dp;
+
+	mutex_lock(&dp_dev->lock);
+	ret = cdn_dp_fb_get_edid_block(dp_dev, buf, block, EDID_BLOCK_SIZE);
+	mutex_unlock(&dp_dev->lock);
+
+	return ret;
+}
+
+int cdn_dp_connector_detect(void *dp)
+{
+	struct cdn_dp_device *dp_dev = dp;
+	bool ret = false;
+
+	mutex_lock(&dp_dev->lock);
+	if (dp_dev->hpd_status == connector_status_connected)
+		ret = true;
+	mutex_unlock(&dp_dev->lock);
+
+	return ret;
+}
+
+int cdn_dp_encoder_disable(void *dp)
+{
+	struct cdn_dp_device *dp_dev = dp;
+	int ret = 0;
+
+	mutex_lock(&dp_dev->lock);
+	memset(&dp_dev->mode, 0, sizeof(dp_dev->mode));
+	if (dp_dev->hpd_status == connector_status_disconnected) {
+		dp_dev->dpms_mode = DRM_MODE_DPMS_OFF;
+		mutex_unlock(&dp_dev->lock);
+		return ret;
+	}
+
+	if (dp_dev->dpms_mode == DRM_MODE_DPMS_ON) {
+		dp_dev->dpms_mode = DRM_MODE_DPMS_OFF;
+	} else{
+		dev_warn(dp_dev->dev, "wrong dpms status,dp encoder has already been disabled\n");
+		ret = -1;
+	}
+	mutex_unlock(&dp_dev->lock);
+
+	return ret;
+}
+
+static void cdn_dp_commit(struct cdn_dp_device *dp)
+{
+	char guid[16];
+	int ret = cdn_dp_fb_training_start(dp);
+
+	if (ret) {
+		dev_err(dp->dev, "link training failed: %d\n", ret);
+		return;
+	}
+
+	ret = cdn_dp_fb_get_training_status(dp);
+	if (ret) {
+		dev_err(dp->dev, "get link training status failed: %d\n", ret);
+		return;
+	}
+
+	dev_info(dp->dev, "rate:%d, lanes:%d\n",
+			dp->link.rate, dp->link.num_lanes);
+
+	/**
+	* Use dpcd@0x0030~0x003f(which is GUID registers) to sync with NanoC
+	* to make sure training is ok. Nanoc will write "nanoc" in GUID registers
+	* when booting, and then we will use these registers to decide whether
+	* need to sync with device which plugged in.
+	* The sync register is 0x0035, firstly we write 0xaa to sync register,
+	* nanoc will read this register and then start the part2 code of DP.
+	*/
+	ret = cdn_dp_fb_dpcd_read(dp, 0x0030, guid, 8);
+	if (ret == 0 && guid[0] == 'n' && guid[1] == 'a' && guid[2] == 'n' &&
+			guid[3] == 'o' && guid[4] == 'c') {
+		u8 sync_number = 0xaa;
+
+		cdn_dp_fb_dpcd_write(dp, 0x0035, sync_number);
+	}
+
+	if (cdn_dp_fb_set_video_status(dp, CONTROL_VIDEO_IDLE))
+		return;
+
+	if (cdn_dp_fb_config_video(dp)) {
+		dev_err(dp->dev, "unable to config video\n");
+		return;
+	}
+
+	if (cdn_dp_fb_set_video_status(dp, CONTROL_VIDEO_VALID))
+		return;
+
+	dp->dpms_mode = DRM_MODE_DPMS_ON;
+}
+
+int cdn_dp_encoder_mode_set(void *dp, struct dp_disp_info *disp_info)
+{
+	int ret, val;
+	struct cdn_dp_device *dp_dev = dp;
+	struct video_info *video = &dp_dev->video_info;
+	struct drm_display_mode disp_mode;
+	struct fb_videomode *mode = disp_info->mode;
+
+	mutex_lock(&dp_dev->lock);
+	disp_mode.clock = mode->pixclock / 1000;
+	disp_mode.hdisplay = mode->xres;
+	disp_mode.hsync_start = disp_mode.hdisplay + mode->right_margin;
+	disp_mode.hsync_end = disp_mode.hsync_start + mode->hsync_len;
+	disp_mode.htotal = disp_mode.hsync_end + mode->left_margin;
+	disp_mode.vdisplay = mode->yres;
+	disp_mode.vsync_start = disp_mode.vdisplay + mode->lower_margin;
+	disp_mode.vsync_end = disp_mode.vsync_start + mode->vsync_len;
+	disp_mode.vtotal = disp_mode.vsync_end + mode->upper_margin;
+
+	switch (disp_info->color_depth) {
+	case 16:
+	case 12:
+	case 10:
+		video->color_depth = 10;
+		break;
+	case 6:
+		video->color_depth = 6;
+		break;
+	default:
+		video->color_depth = 8;
+		break;
+	}
+
+	video->color_fmt = PXL_RGB;
+
+	video->v_sync_polarity = disp_info->vsync_polarity;
+	video->h_sync_polarity = disp_info->hsync_polarity;
+
+	if (disp_info->vop_sel)
+		val = DP_SEL_VOP_LIT | (DP_SEL_VOP_LIT << 16);
+	else
+		val = DP_SEL_VOP_LIT << 16;
+
+	ret = cdn_dp_grf_write(dp, GRF_SOC_CON9, val);
+	if (ret != 0) {
+		dev_err(dp_dev->dev, "Could not write to GRF: %d\n", ret);
+		mutex_unlock(&dp_dev->lock);
+		return ret;
+	}
+	memcpy(&dp_dev->mode, &disp_mode, sizeof(disp_mode));
+
+	mutex_unlock(&dp_dev->lock);
+
+	return 0;
+}
+
+int cdn_dp_encoder_enable(void *dp)
+{
+	struct cdn_dp_device *dp_dev = dp;
+	int ret = 0;
+
+	mutex_lock(&dp_dev->lock);
+
+	if (dp_dev->dpms_mode == DRM_MODE_DPMS_OFF) {
+		/**
+		* the mode info of dp device will be cleared when dp encoder is disabled
+		* so if clock value of mode is 0, means rockchip_dp_config_video is not
+		* return success, so we don't do cdn_dp_commit.
+		*/
+		if (dp_dev->mode.clock == 0) {
+			dev_err(dp_dev->dev, "Error !Please make sure function cdn_dp_encoder_mode_set return success!\n");
+			mutex_unlock(&dp_dev->lock);
+			return -1;
+		}
+		cdn_dp_commit(dp_dev);
+	} else {
+		dev_warn(dp_dev->dev, "wrong dpms status,dp encoder has already been enabled\n");
+		ret = -1;
+	}
+	mutex_unlock(&dp_dev->lock);
+
+	return ret;
+}
+
+static int cdn_dp_firmware_init(struct cdn_dp_device *dp)
+{
+	int ret;
+	const u32 *iram_data, *dram_data;
+	const struct firmware *fw = dp->fw;
+	const struct cdn_firmware_header *hdr;
+
+	hdr = (struct cdn_firmware_header *)fw->data;
+	if (fw->size != le32_to_cpu(hdr->size_bytes)) {
+		dev_err(dp->dev, "firmware is invalid\n");
+		return -EINVAL;
+	}
+
+	iram_data = (const u32 *)(fw->data + hdr->header_size);
+	dram_data = (const u32 *)(fw->data + hdr->header_size + hdr->iram_size);
+
+	ret = cdn_dp_fb_load_firmware(dp, iram_data, hdr->iram_size,
+				   dram_data, hdr->dram_size);
+	if (ret)
+		return ret;
+
+	ret = cdn_dp_fb_set_firmware_active(dp, true);
+	if (ret) {
+		dev_err(dp->dev, "active ucpu failed: %d\n", ret);
+		return ret;
+	}
+
+	dp->fw_loaded = 1;
+	return cdn_dp_fb_event_config(dp);
+}
+
+static int cdn_dp_init(struct cdn_dp_device *dp)
+{
+	struct device *dev = dp->dev;
+	struct device_node *np = dev->of_node;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+
+	dp->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(dp->grf)) {
+		dev_err(dev, "cdn-dp needs rockchip,grf property\n");
+		return PTR_ERR(dp->grf);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dp->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(dp->regs)) {
+		dev_err(dev, "ioremap reg failed\n");
+		return PTR_ERR(dp->regs);
+	}
+
+	dp->core_clk = devm_clk_get(dev, "core-clk");
+	if (IS_ERR(dp->core_clk)) {
+		dev_err(dev, "cannot get core_clk_dp\n");
+		return PTR_ERR(dp->core_clk);
+	}
+
+	dp->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(dp->pclk)) {
+		dev_err(dev, "cannot get pclk\n");
+		return PTR_ERR(dp->pclk);
+	}
+
+	dp->spdif_clk = devm_clk_get(dev, "spdif");
+	if (IS_ERR(dp->spdif_clk)) {
+		dev_err(dev, "cannot get spdif_clk\n");
+		return PTR_ERR(dp->spdif_clk);
+	}
+
+	dp->grf_clk = devm_clk_get(dev, "grf");
+	if (IS_ERR(dp->grf_clk)) {
+		dev_err(dev, "cannot get grf clk\n");
+		return PTR_ERR(dp->grf_clk);
+	}
+
+	dp->spdif_rst = devm_reset_control_get(dev, "spdif");
+	if (IS_ERR(dp->spdif_rst)) {
+		dev_err(dev, "no spdif reset control found\n");
+		return PTR_ERR(dp->spdif_rst);
+	}
+
+	dp->dptx_rst = devm_reset_control_get(dev, "dptx");
+	if (IS_ERR(dp->dptx_rst)) {
+		dev_err(dev, "no uphy reset control found\n");
+		return PTR_ERR(dp->dptx_rst);
+	}
+
+	dp->apb_rst = devm_reset_control_get(dev, "apb");
+	if (IS_ERR(dp->apb_rst)) {
+		dev_err(dev, "no apb reset control found\n");
+		return PTR_ERR(dp->apb_rst);
+	}
+
+	dp->core_rst = devm_reset_control_get(dev, "core");
+	if (IS_ERR(dp->core_rst)) {
+		DRM_DEV_ERROR(dev, "no core reset control found\n");
+		return PTR_ERR(dp->core_rst);
+	}
+
+	dp->dpms_mode = DRM_MODE_DPMS_OFF;
+	dp->fw_clk_enabled = false;
+
+	pm_runtime_enable(dev);
+
+	mutex_init(&dp->lock);
+	wake_lock_init(&dp->wake_lock, WAKE_LOCK_SUSPEND, "cdn_dp_fb");
+	return 0;
+}
+
+struct cdn_dp_device *g_dp;
+static int cdn_dp_audio_hw_params(struct device *dev,  void *data,
+				  struct hdmi_codec_daifmt *daifmt,
+				  struct hdmi_codec_params *params)
+{
+	struct dp_dev *dp_dev = dev_get_drvdata(dev);
+	struct cdn_dp_device *dp = dp_dev->dp;
+	int ret;
+	struct audio_info audio = {
+		.sample_width = 16,
+		.sample_rate = 44100,
+		.channels = 8,
+	};
+
+	if (!cdn_dp_connector_detect(dp))
+		return 0;
+
+	switch (HDMI_I2S) {
+	case HDMI_I2S:
+		audio.format = AFMT_I2S;
+		break;
+	case HDMI_SPDIF:
+		audio.format = AFMT_SPDIF;
+		break;
+	default:
+		dev_err(dev, "%s: Invalid format %d\n", __func__, daifmt->fmt);
+		return -EINVAL;
+	}
+
+	ret = cdn_dp_fb_audio_config(dp, &audio);
+	if (!ret)
+		dp->audio_info = audio;
+
+	return ret;
+}
+
+static void cdn_dp_audio_shutdown(struct device *dev, void *data)
+{
+	struct dp_dev *dp_dev = dev_get_drvdata(dev);
+	struct cdn_dp_device *dp = dp_dev->dp;
+	int ret;
+
+	if (cdn_dp_connector_detect(dp)) {
+		ret = cdn_dp_fb_audio_stop(dp, &dp->audio_info);
+		if (!ret)
+			dp->audio_info.format = AFMT_UNUSED;
+	}
+}
+
+static int cdn_dp_audio_digital_mute(struct device *dev, void *data,
+				     bool enable)
+{
+	struct dp_dev *dp_dev = dev_get_drvdata(dev);
+	struct cdn_dp_device *dp = dp_dev->dp;
+
+	if (!cdn_dp_connector_detect(dp))
+		return 0;
+	return cdn_dp_fb_audio_mute(dp, enable);
+}
+
+static const struct hdmi_codec_ops audio_codec_ops = {
+	.hw_params = cdn_dp_audio_hw_params,
+	.audio_shutdown = cdn_dp_audio_shutdown,
+	.digital_mute = cdn_dp_audio_digital_mute,
+};
+
+static int cdn_dp_audio_codec_init(struct cdn_dp_device *dp,
+				   struct device *dev)
+{
+	struct hdmi_codec_pdata codec_data = {
+		.i2s = 1,
+		.spdif = 1,
+		.ops = &audio_codec_ops,
+		.max_i2s_channels = 8,
+	};
+
+	dp->audio_pdev = platform_device_register_data(
+			 dev, HDMI_CODEC_DRV_NAME, PLATFORM_DEVID_AUTO,
+			 &codec_data, sizeof(codec_data));
+
+	return PTR_ERR_OR_ZERO(dp->audio_pdev);
+}
+
+static int cdn_dp_get_cap_lanes(struct cdn_dp_device *dp,
+				struct extcon_dev *edev)
+{
+	union extcon_property_value property;
+	u8 lanes = 0;
+	int dptx;
+
+	if (dp->suspend)
+		return 0;
+
+	dptx = extcon_get_state(edev, EXTCON_DISP_DP);
+	if (dptx > 0) {
+		extcon_get_property(edev, EXTCON_DISP_DP,
+				    EXTCON_PROP_USB_SS, &property);
+		if (property.intval)
+			lanes = 2;
+		else
+			lanes = 4;
+	}
+
+	return lanes;
+}
+
+static int cdn_dp_get_dpcd(struct cdn_dp_device *dp, struct cdn_dp_port *port)
+{
+	u8 sink_count;
+	int i, ret;
+	int retry = 60;
+
+	/*
+	 * Native read with retry for link status and receiver capability reads
+	 * for cases where the sink may still not be ready.
+	 *
+	 * Sinks are *supposed* to come up within 1ms from an off state, but
+	 * some DOCKs need about 5 seconds to power up, so read the dpcd every
+	 * 100ms, if can not get a good dpcd in 10 seconds, give up.
+	 */
+	for (i = 0; i < 100; i++) {
+		ret = cdn_dp_fb_dpcd_read(dp, DP_SINK_COUNT,
+				       &sink_count, 1);
+		if (!ret) {
+			dev_dbg(dp->dev, "get dpcd success!\n");
+
+			sink_count = DP_GET_SINK_COUNT(sink_count);
+			if (!sink_count) {
+				if (retry-- <= 0) {
+					dev_err(dp->dev, "sink cout is 0, no sink device!\n");
+					return -ENODEV;
+				}
+				msleep(50);
+				continue;
+			}
+
+			ret = cdn_dp_fb_dpcd_read(dp, 0x000, dp->dpcd,
+					       DP_RECEIVER_CAP_SIZE);
+			if (ret)
+				continue;
+
+			return ret;
+		} else if (!extcon_get_state(port->extcon, EXTCON_DISP_DP)) {
+			break;
+		}
+
+		msleep(100);
+	}
+
+	dev_err(dp->dev, "get dpcd failed!\n");
+
+	return -ETIMEDOUT;
+}
+
+static void cdn_dp_enter_standy(struct cdn_dp_device *dp,
+				struct cdn_dp_port *port)
+{
+	int i, ret;
+
+	if (port->phy_status) {
+		ret = phy_power_off(port->phy);
+		if (ret) {
+			dev_err(dp->dev, "phy power off failed: %d", ret);
+			return;
+		}
+	}
+
+	port->phy_status = false;
+	port->cap_lanes = 0;
+	for (i = 0; i < dp->ports; i++)
+		if (dp->port[i]->phy_status)
+			return;
+
+	memset(dp->dpcd, 0, DP_RECEIVER_CAP_SIZE);
+	if (dp->fw_actived)
+		cdn_dp_fb_set_firmware_active(dp, false);
+	if (dp->fw_clk_enabled) {
+		cdn_dp_clk_disable(dp);
+		dp->fw_clk_enabled = false;
+	}
+	dp->hpd_status = connector_status_disconnected;
+
+	hpd_change(dp->dev, 0);
+}
+
+static int cdn_dp_start_work(struct cdn_dp_device *dp,
+			     struct cdn_dp_port *port,
+			     u8 cap_lanes)
+{
+	union extcon_property_value property;
+	int ret;
+
+	if (!dp->fw_loaded) {
+		ret = request_firmware(&dp->fw, CDN_DP_FIRMWARE, dp->dev);
+		if (ret) {
+			if (ret == -ENOENT && dp->fw_wait <= MAX_FW_WAIT_SECS) {
+				unsigned long time = msecs_to_jiffies(dp->fw_wait * HZ);
+
+				/*
+				 * Keep trying to load the firmware for up to 1 minute,
+				 * if can not find the file.
+				 */
+				schedule_delayed_work(&port->event_wq, time);
+				dp->fw_wait *= 2;
+			} else {
+				dev_err(dp->dev, "failed to request firmware: %d\n",
+					ret);
+			}
+
+			return ret;
+		} else
+			dp->fw_loaded = true;
+	}
+
+	ret = cdn_dp_clk_enable(dp);
+	if (ret < 0) {
+		dev_err(dp->dev, "failed to enable clock for dp: %d\n", ret);
+		return ret;
+	}
+
+	ret = phy_power_on(port->phy);
+	if (ret) {
+		dev_err(dp->dev, "phy power on failed: %d\n", ret);
+		goto err_phy;
+	}
+
+	port->phy_status = true;
+
+	ret = cdn_dp_firmware_init(dp);
+	if (ret) {
+		dev_err(dp->dev, "firmware init failed: %d", ret);
+		goto err_firmware;
+	}
+
+	ret = cdn_dp_grf_write(dp, GRF_SOC_CON26,
+			       DPTX_HPD_SEL_MASK | DPTX_HPD_SEL);
+	if (ret)
+		goto err_grf;
+
+	ret = cdn_dp_fb_get_hpd_status(dp);
+	if (ret <= 0) {
+		if (!ret)
+			dev_err(dp->dev, "hpd does not exist\n");
+		goto err_hpd;
+	}
+
+	ret = extcon_get_property(port->extcon, EXTCON_DISP_DP,
+				  EXTCON_PROP_USB_TYPEC_POLARITY, &property);
+	if (ret) {
+		dev_err(dp->dev, "get property failed\n");
+		goto err_hpd;
+	}
+
+	ret = cdn_dp_fb_set_host_cap(dp, cap_lanes, property.intval);
+	if (ret) {
+		dev_err(dp->dev, "set host capabilities failed: %d\n", ret);
+		goto err_hpd;
+	}
+
+	ret = cdn_dp_get_dpcd(dp, port);
+	if (ret)
+		goto err_hpd;
+
+	return 0;
+
+err_hpd:
+	cdn_dp_grf_write(dp, GRF_SOC_CON26,
+			 DPTX_HPD_SEL_MASK | DPTX_HPD_DEL);
+
+err_grf:
+	if (dp->fw_actived)
+		cdn_dp_fb_set_firmware_active(dp, false);
+
+err_firmware:
+	if (phy_power_off(port->phy))
+		dev_err(dp->dev, "phy power off failed: %d", ret);
+	else
+		port->phy_status = false;
+
+err_phy:
+	cdn_dp_clk_disable(dp);
+	dp->fw_clk_enabled = false;
+	return ret;
+}
+
+static int cdn_dp_pd_event(struct notifier_block *nb,
+			   unsigned long event, void *priv)
+{
+	struct cdn_dp_port *port;
+
+	port = container_of(nb, struct cdn_dp_port, event_nb);
+	schedule_delayed_work(&port->event_wq, 0);
+	return 0;
+}
+
+static void cdn_dp_pd_event_wq(struct work_struct *work)
+{
+	struct cdn_dp_port *port = container_of(work, struct cdn_dp_port,
+						event_wq.work);
+	struct cdn_dp_device *dp = port->dp;
+	u8 new_cap_lanes, sink_count, i;
+	int ret;
+
+	mutex_lock(&dp->lock);
+	wake_lock_timeout(&dp->wake_lock, msecs_to_jiffies(1000));
+
+	new_cap_lanes = cdn_dp_get_cap_lanes(dp, port->extcon);
+
+	if (new_cap_lanes == port->cap_lanes) {
+		if (!new_cap_lanes) {
+			dev_err(dp->dev, "dp lanes is 0, and same with last time\n");
+			goto out;
+		}
+
+		/*
+		 * If HPD interrupt is triggered, and cable states is still
+		 * attached, that means something on the Type-C Dock/Dongle
+		 * changed, check the sink count by DPCD. If sink count became
+		 * 0, this port phy can be powered off; if the sink count does
+		 * not change and dp is connected, don't do anything, because
+		 * dp video output maybe ongoing. if dp is not connected, that
+		 * means something is wrong, we don't do anything here, just
+		 * output error log.
+		 */
+		cdn_dp_fb_dpcd_read(dp, DP_SINK_COUNT, &sink_count, 1);
+		if (sink_count) {
+			if (dp->hpd_status == connector_status_connected)
+				dev_info(dp->dev,
+					 "hpd interrupt is triggered when dp has been already connected\n");
+			else
+				dev_err(dp->dev,
+					"something is wrong, hpd is triggered before dp is connected\n");
+
+			goto out;
+		} else {
+			new_cap_lanes = 0;
+		}
+	}
+
+	if (dp->hpd_status == connector_status_connected && new_cap_lanes) {
+		dev_err(dp->dev, "error, dp connector has already been connected\n");
+		goto out;
+	}
+
+	if (!new_cap_lanes) {
+		dev_info(dp->dev, "dp lanes is 0, enter standby\n");
+		cdn_dp_enter_standy(dp, port);
+		goto out;
+	}
+
+	/* if other phy is running, do not do anything, just return */
+	for (i = 0; i < dp->ports; i++) {
+		if (dp->port[i]->phy_status) {
+			dev_warn(dp->dev, "busy, phy[%d] is running",
+				 dp->port[i]->id);
+			goto out;
+		}
+	}
+
+	ret = cdn_dp_start_work(dp, port, new_cap_lanes);
+	if (ret) {
+		dev_err(dp->dev, "dp failed to connect ,error = %d\n", ret);
+		goto out;
+	}
+	port->cap_lanes = new_cap_lanes;
+	dp->hpd_status = connector_status_connected;
+	wake_unlock(&dp->wake_lock);
+	mutex_unlock(&dp->lock);
+	hpd_change(dp->dev, new_cap_lanes);
+
+	return;
+out:
+	wake_unlock(&dp->wake_lock);
+	mutex_unlock(&dp->lock);
+}
+
+static int cdn_dp_bind(struct cdn_dp_device *dp)
+{
+	struct cdn_dp_port *port;
+	int ret, i;
+
+	ret = cdn_dp_init(dp);
+	if (ret < 0)
+		return ret;
+
+	dp->hpd_status = connector_status_disconnected;
+	dp->fw_wait = 1;
+	cdn_dp_audio_codec_init(dp, dp->dev);
+
+	for (i = 0; i < dp->ports; i++) {
+		port = dp->port[i];
+
+		port->event_nb.notifier_call = cdn_dp_pd_event;
+		INIT_DELAYED_WORK(&port->event_wq, cdn_dp_pd_event_wq);
+		ret = extcon_register_notifier(port->extcon, EXTCON_DISP_DP,
+					       &port->event_nb);
+		if (ret) {
+			dev_err(dp->dev, "regitster EXTCON_DISP_DP notifier err\n");
+			return ret;
+		}
+
+		if (extcon_get_state(port->extcon, EXTCON_DISP_DP))
+			schedule_delayed_work(&port->event_wq,
+							msecs_to_jiffies(2000));
+	}
+
+	return 0;
+}
+
+int cdn_dp_fb_suspend(void *dp_dev)
+{
+	struct cdn_dp_device *dp = dp_dev;
+	struct cdn_dp_port *port;
+	int i;
+
+	for (i = 0; i < dp->ports; i++) {
+		port = dp->port[i];
+		if (port->phy_status) {
+			cdn_dp_fb_dpcd_write(dp, DP_SET_POWER, DP_SET_POWER_D3);
+			cdn_dp_enter_standy(dp, port);
+		}
+	}
+
+	/*
+	 * if dp has been suspended, need to download firmware
+	 * and set fw clk again.
+	 */
+	dp->fw_clk_enabled = false;
+	dp->fw_loaded = false;
+	dp->suspend = true;
+	return 0;
+}
+
+int cdn_dp_fb_resume(void *dp_dev)
+{
+	struct cdn_dp_device *dp = dp_dev;
+	struct cdn_dp_port *port;
+	int i;
+	if (dp->suspend) {
+		dp->suspend = false;
+		for (i = 0; i < dp->ports; i++) {
+			port = dp->port[i];
+			schedule_delayed_work(&port->event_wq, 0);
+			flush_delayed_work(&port->event_wq);
+		}
+	}
+
+	return 0;
+}
+
+static int cdn_dp_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	const struct of_device_id *match;
+	struct cdn_dp_data *dp_data;
+	struct cdn_dp_port *port;
+	struct cdn_dp_device *dp;
+	struct extcon_dev *extcon;
+	struct phy *phy;
+	int i, ret;
+
+	dp = devm_kzalloc(dev, sizeof(*dp), GFP_KERNEL);
+	if (!dp)
+		return -ENOMEM;
+	dp->dev = dev;
+	g_dp = dp;
+
+	match = of_match_node(cdn_dp_dt_ids, pdev->dev.of_node);
+	dp_data = (struct cdn_dp_data *)match->data;
+
+	for (i = 0; i < dp_data->max_phy; i++) {
+		extcon = extcon_get_edev_by_phandle(dev, i);
+		phy = devm_of_phy_get_by_index(dev, dev->of_node, i);
+
+		if (PTR_ERR(extcon) == -EPROBE_DEFER ||
+		    PTR_ERR(phy) == -EPROBE_DEFER){
+			/* don't exit if there already has one port */
+			if(dp->ports)
+				continue;
+			return -EPROBE_DEFER;
+
+		}
+
+		if (IS_ERR(extcon) || IS_ERR(phy))
+			continue;
+
+		port = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);
+		if (!port)
+			return -ENOMEM;
+
+		port->extcon = extcon;
+		port->phy = phy;
+		port->dp = dp;
+		port->id = i;
+		dp->port[dp->ports++] = port;
+	}
+
+	if (!dp->ports) {
+		dev_err(dev, "missing extcon or phy\n");
+		return -EINVAL;
+	}
+
+	cdn_dp_bind(dp);
+	ret = cdn_dp_fb_register(pdev, dp);
+
+	return ret;
+}
+
+static struct platform_driver cdn_dp_driver = {
+	.probe = cdn_dp_probe,
+	.driver = {
+		   .name = "cdn-dp-fb",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(cdn_dp_dt_ids),
+	},
+};
+
+module_platform_driver(cdn_dp_driver);
+
+MODULE_AUTHOR("Chris Zhong <zyw@rock-chips.com>");
+MODULE_DESCRIPTION("cdn DP Driver");
+MODULE_LICENSE("GPL v2");
diff -Nupr a/drivers/video/rockchip/dp/rockchip_dp_core.h b/drivers/video/rockchip/dp/rockchip_dp_core.h
--- a/drivers/video/rockchip/dp/rockchip_dp_core.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/dp/rockchip_dp_core.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_DP_CORE_H__
+#define __ROCKCHIP_DP_CORE_H__
+
+/* dp grf register offset */
+#define GRF_SOC_CON9		0x6224
+#define GRF_SOC_CON26		0x6268
+
+#define DPTX_HPD_SEL		(3 << 12)
+#define DPTX_HPD_DEL		(2 << 12)
+#define DPTX_HPD_SEL_MASK	(3 << 28)
+
+#define DP_SEL_VOP_LIT		BIT(12)
+#define MAX_FW_WAIT_SECS	64
+#define EDID_BLOCK_SIZE		128
+#define CDN_DP_FIRMWARE	"cdn/dptx.bin"
+
+struct dp_disp_info {
+	struct fb_videomode *mode;
+	int color_depth;
+	int vsync_polarity;
+	int hsync_polarity;
+	int vop_sel;
+};
+
+struct cdn_dp_data {
+	u8 max_phy;
+};
+
+struct dp_dev {
+	struct dp_disp_info disp_info;
+	struct hdmi *hdmi;
+	void *dp;
+	struct notifier_block fb_notif;
+	int lanes;
+	bool early_suspended;
+};
+
+int cdn_dp_fb_register(struct platform_device *pdev, void *dp);
+void hpd_change(struct device *dev, int lanes);
+
+#endif
diff -Nupr a/drivers/video/rockchip/dp/rockchip_dp.h b/drivers/video/rockchip/dp/rockchip_dp.h
--- a/drivers/video/rockchip/dp/rockchip_dp.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/dp/rockchip_dp.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_DP_H__
+#define __ROCKCHIP_DP_H__
+
+#include "../hdmi/rockchip-hdmi.h"
+#include "rockchip_dp_core.h"
+
+int cdn_dp_get_edid(void *dp, u8 *edid, unsigned int block);
+int cdn_dp_encoder_mode_set(void *dp, struct dp_disp_info *disp_info);
+int cdn_dp_encoder_enable(void *dp);
+int cdn_dp_connector_detect(void *dp);
+int cdn_dp_encoder_disable(void *dp);
+int cdn_dp_audio_hw_params(void *dp);
+int cdn_dp_audio_digital_mute(void *dp, bool enable);
+int cdn_dp_fb_resume(void *dp_dev);
+int cdn_dp_fb_suspend(void *dp_dev);
+
+#endif
diff -Nupr a/drivers/video/rockchip/hdmi/Kconfig b/drivers/video/rockchip/hdmi/Kconfig
--- a/drivers/video/rockchip/hdmi/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0
+menuconfig RK_HDMI
+       bool "Rockchip HDMI support"
+       depends on FB_ROCKCHIP || DRM_ROCKCHIP
+       select FB_MODE_HELPERS
+
+source "drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig"
+source "drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig"
+
+config RK_HDMI_DEBUG
+		bool "Rockchip HDMI Debugging"
+        depends on RK_HDMI
+        default n
+		help
+		  Enableds verbose debugging the the HDMI drivers
+
diff -Nupr a/drivers/video/rockchip/hdmi/Makefile b/drivers/video/rockchip/hdmi/Makefile
--- a/drivers/video/rockchip/hdmi/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for HDMI linux kernel module.
+#
+
+ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
+
+obj-$(CONFIG_RK_HDMI) += rockchip-hdmi-core.o rockchip-hdmi-lcdc.o rockchip-hdmi-edid.o rockchip-hdmi-sysfs.o rockchip-hdmi-cec.o
+obj-$(CONFIG_RK_HDMI_V2) += rockchip-hdmiv2/
+obj-$(CONFIG_RK_HDMI_V1) += rockchip-hdmiv1/
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,307 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/firmware.h>
+#include <linux/ioctl.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/workqueue.h>
+#include "rockchip-hdmi-cec.h"
+
+static struct cec_device *cec_dev;
+
+static int cecreadframe(struct cec_framedata *frame)
+{
+	int ret = -1;
+
+	if (frame && cec_dev && cec_dev->readframe && cec_dev->enable) {
+		mutex_lock(&cec_dev->hdmi->pclk_lock);
+		ret = cec_dev->readframe(cec_dev->hdmi, frame);
+		mutex_unlock(&cec_dev->hdmi->pclk_lock);
+	}
+	return ret;
+}
+
+static int cecsendframe(struct cec_framedata *frame)
+{
+	int ret = -1;
+
+	if (frame && cec_dev && cec_dev->sendframe) {
+		mutex_lock(&cec_dev->hdmi->pclk_lock);
+		ret = cec_dev->sendframe(cec_dev->hdmi, frame);
+		mutex_unlock(&cec_dev->hdmi->pclk_lock);
+	}
+	return ret;
+}
+
+static void cecsetlogicaddr(int addr)
+{
+	if (cec_dev && cec_dev->setceclogicaddr) {
+		mutex_lock(&cec_dev->hdmi->pclk_lock);
+		cec_dev->setceclogicaddr(cec_dev->hdmi, addr);
+		mutex_unlock(&cec_dev->hdmi->pclk_lock);
+	}
+}
+
+static void cecworkfunc(struct work_struct *work)
+{
+	struct cec_delayed_work *cec_w =
+		container_of(work, struct cec_delayed_work, work.work);
+	struct cecframelist *list_node;
+
+	switch (cec_w->event) {
+	case EVENT_ENUMERATE:
+		break;
+	case EVENT_RX_FRAME:
+		list_node = kmalloc(sizeof(*list_node), GFP_KERNEL);
+		if (!list_node)
+			return;
+		cecreadframe(&list_node->cecframe);
+		if (cec_dev->enable) {
+			mutex_lock(&cec_dev->cec_lock);
+			list_add_tail(&list_node->framelist,
+				      &cec_dev->ceclist);
+			sysfs_notify(&cec_dev->device.this_device->kobj,
+				     NULL, "stat");
+			mutex_unlock(&cec_dev->cec_lock);
+		} else {
+			kfree(list_node);
+		}
+		break;
+	default:
+		break;
+	}
+
+	kfree(cec_w->data);
+	kfree(cec_w);
+}
+
+void rockchip_hdmi_cec_submit_work(int event, int delay, void *data)
+{
+	struct cec_delayed_work *work;
+
+	HDMIDBG(1, "%s event %04x delay %d\n", __func__, event, delay);
+
+	if (!cec_dev)
+		return;
+
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+
+	if (work) {
+		INIT_DELAYED_WORK(&work->work, cecworkfunc);
+		work->event = event;
+		work->data = data;
+		queue_delayed_work(cec_dev->workqueue,
+				   &work->work,
+				   msecs_to_jiffies(delay));
+	} else {
+		HDMIDBG(1, "CEC: Cannot allocate memory\n");
+	}
+}
+
+void rockchip_hdmi_cec_set_pa(int devpa)
+{
+	struct list_head *pos, *n;
+
+	if (cec_dev) {
+		cec_dev->address_phy = devpa;
+		pr_info("%s %x\n", __func__, devpa);
+		/*when hdmi hpd , ceclist will be reset*/
+		mutex_lock(&cec_dev->cec_lock);
+		if (!list_empty(&cec_dev->ceclist)) {
+			list_for_each_safe(pos, n, &cec_dev->ceclist) {
+				list_del(pos);
+				kfree(pos);
+			}
+		}
+		INIT_LIST_HEAD(&cec_dev->ceclist);
+		sysfs_notify(&cec_dev->device.this_device->kobj, NULL, "stat");
+		mutex_unlock(&cec_dev->cec_lock);
+	}
+}
+
+static ssize_t  cec_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", cec_dev->enable);
+}
+
+static ssize_t cec_enable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtoint(buf, 0, &cec_dev->enable);
+	return count;
+}
+
+static ssize_t  cec_phy_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "0x%x\n", cec_dev->address_phy);
+}
+
+static ssize_t cec_phy_store(struct device *dev,
+			     struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtoint(buf, 0, &cec_dev->address_phy);
+	return count;
+}
+
+static ssize_t  cec_logic_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", cec_dev->address_logic);
+}
+
+static ssize_t cec_logic_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtoint(buf, 0, &cec_dev->address_logic);
+	return count;
+}
+
+static ssize_t  cec_state_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int stat;
+
+	mutex_lock(&cec_dev->cec_lock);
+	if (!cec_dev->address_phy)
+		stat = 0;
+	else if (list_empty(&cec_dev->ceclist))
+		stat = 1;
+	else
+		stat = 2;
+	mutex_unlock(&cec_dev->cec_lock);
+	return snprintf(buf, PAGE_SIZE, "%d\n", stat);
+}
+
+static struct device_attribute cec_attrs[] = {
+	__ATTR(logic, 0644, cec_logic_show, cec_logic_store),
+	__ATTR(phy, 0644, cec_phy_show, cec_phy_store),
+	__ATTR(enable, 0644, cec_enable_show, cec_enable_store),
+	__ATTR(stat, S_IRUGO, cec_state_show, NULL),
+};
+
+static long cec_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	void __user *argp;
+	struct cec_framedata cecsendtemp;
+	struct cecframelist *listemp;
+
+	argp = (void __user *)arg;
+	switch (cmd) {
+	case HDMI_IOCTL_CECSETLA:
+		ret = copy_from_user(&cec_dev->address_logic,
+				     argp, sizeof(int));
+		cecsetlogicaddr(cec_dev->address_logic);
+		break;
+	case HDMI_IOCTL_CECSEND:
+		ret = copy_from_user(&cecsendtemp, argp,
+				     sizeof(struct cec_framedata));
+		ret = cecsendframe(&cecsendtemp);
+		cecsendtemp.returnval = ret;
+		ret = copy_to_user(argp, &cecsendtemp,
+				   sizeof(struct cec_framedata));
+		break;
+	case HDMI_IOCTL_CECENAB:
+		ret = copy_from_user(&cec_dev->enable, argp, sizeof(int));
+		break;
+	case HDMI_IOCTL_CECPHY:
+		ret = copy_to_user(argp, &cec_dev->address_phy, sizeof(int));
+		break;
+	case HDMI_IOCTL_CECLOGIC:
+		ret = copy_to_user(argp, &cec_dev->address_logic,
+				   sizeof(int));
+		break;
+	case HDMI_IOCTL_CECREAD:
+		mutex_lock(&cec_dev->cec_lock);
+		if (!list_empty(&cec_dev->ceclist)) {
+			listemp = list_entry(cec_dev->ceclist.next,
+					     struct cecframelist, framelist);
+			ret = copy_to_user(argp, &listemp->cecframe,
+					   sizeof(struct cec_framedata));
+			list_del(&listemp->framelist);
+			kfree(listemp);
+		}
+		mutex_unlock(&cec_dev->cec_lock);
+		break;
+	case HDMI_IOCTL_CECCLEARLA:
+		break;
+	case HDMI_IOCTL_CECWAKESTATE:
+		ret = copy_to_user(argp, &cec_dev->hdmi->sleep, sizeof(int));
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static const struct file_operations cec_fops = {
+	.owner		= THIS_MODULE,
+	.compat_ioctl	= cec_ioctl,
+	.unlocked_ioctl	= cec_ioctl,
+};
+
+int rockchip_hdmi_cec_init(struct hdmi *hdmi,
+			   int (*sendframe)(struct hdmi *,
+					    struct cec_framedata *),
+			   int (*readframe)(struct hdmi *,
+					    struct cec_framedata *),
+			   void (*setceclogicaddr)(struct hdmi *, int))
+{
+	int ret, i;
+
+	cec_dev = kmalloc(sizeof(*cec_dev), GFP_KERNEL);
+	if (!cec_dev)
+		return -ENOMEM;
+
+	memset(cec_dev, 0, sizeof(struct cec_device));
+	mutex_init(&cec_dev->cec_lock);
+	INIT_LIST_HEAD(&cec_dev->ceclist);
+	cec_dev->hdmi = hdmi;
+	cec_dev->enable = 1;
+	cec_dev->sendframe = sendframe;
+	cec_dev->readframe = readframe;
+	cec_dev->setceclogicaddr = setceclogicaddr;
+	cec_dev->workqueue = create_singlethread_workqueue("hdmi-cec");
+	if (!cec_dev->workqueue) {
+		pr_err("HDMI CEC: create workqueue failed.\n");
+		return -1;
+	}
+	cec_dev->device.minor = MISC_DYNAMIC_MINOR;
+	cec_dev->device.name = "cec";
+	cec_dev->device.mode = 0666;
+	cec_dev->device.fops = &cec_fops;
+	if (misc_register(&cec_dev->device)) {
+		pr_err("CEC: Could not add cec misc driver\n");
+		goto error;
+	}
+	for (i = 0; i < ARRAY_SIZE(cec_attrs); i++) {
+		ret = device_create_file(cec_dev->device.this_device,
+					 &cec_attrs[i]);
+		if (ret) {
+			pr_err("CEC: Could not add sys file\n");
+			goto error1;
+		}
+	}
+	return 0;
+
+error1:
+	misc_deregister(&cec_dev->device);
+error:
+	return -EINVAL;
+}
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.h b/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.h
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,193 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_HDMI_CEC_H__
+#define __ROCKCHIP_HDMI_CEC_H__
+
+#include <linux/input.h>
+#include <linux/miscdevice.h>
+#include "rockchip-hdmi.h"
+
+enum {
+	CEC_LOGADDR_TV          = 0x00,
+	CEC_LOGADDR_RECDEV1     = 0x01,
+	CEC_LOGADDR_RECDEV2     = 0x02,
+	CEC_LOGADDR_TUNER1      = 0x03,     /* STB1 in Spev v1.3 */
+	CEC_LOGADDR_PLAYBACK1   = 0x04,     /* DVD1 in Spev v1.3 */
+	CEC_LOGADDR_AUDSYS      = 0x05,
+	CEC_LOGADDR_TUNER2      = 0x06,     /* STB2 in Spec v1.3 */
+	CEC_LOGADDR_TUNER3      = 0x07,     /* STB3 in Spec v1.3 */
+	CEC_LOGADDR_PLAYBACK2   = 0x08,     /* DVD2 in Spec v1.3 */
+	CEC_LOGADDR_RECDEV3     = 0x09,
+	CEC_LOGADDR_TUNER4      = 0x0A,     /* RES1 in Spec v1.3 */
+	CEC_LOGADDR_PLAYBACK3   = 0x0B,     /* RES2 in Spec v1.3 */
+	CEC_LOGADDR_RES3        = 0x0C,
+	CEC_LOGADDR_RES4        = 0x0D,
+	CEC_LOGADDR_FREEUSE     = 0x0E,
+	CEC_LOGADDR_UNREGORBC   = 0x0F
+
+};
+
+enum {                   /* CEC Messages */
+	CECOP_FEATURE_ABORT			= 0x00,
+	CECOP_IMAGE_VIEW_ON			= 0x04,
+	CECOP_TUNER_STEP_INCREMENT		= 0x05,
+	CECOP_TUNER_STEP_DECREMENT		= 0x06,
+	CECOP_TUNER_DEVICE_STATUS		= 0x07,
+	CECOP_GIVE_TUNER_DEVICE_STATUS		= 0x08,
+	CECOP_RECORD_ON				= 0x09,
+	CECOP_RECORD_STATUS			= 0x0A,
+	CECOP_RECORD_OFF			= 0x0B,
+	CECOP_TEXT_VIEW_ON			= 0x0D,
+	CECOP_RECORD_TV_SCREEN			= 0x0F,
+	CECOP_GIVE_DECK_STATUS			= 0x1A,
+	CECOP_DECK_STATUS			= 0x1B,
+	CECOP_SET_MENU_LANGUAGE			= 0x32,
+	CECOP_CLEAR_ANALOGUE_TIMER		= 0x33,     /* Spec 1.3A */
+	CECOP_SET_ANALOGUE_TIMER		= 0x34,     /* Spec 1.3A */
+	CECOP_TIMER_STATUS			= 0x35,     /* Spec 1.3A */
+	CECOP_STANDBY				= 0x36,
+	CECOP_PLAY				= 0x41,
+	CECOP_DECK_CONTROL			= 0x42,
+	CECOP_TIMER_CLEARED_STATUS		= 0x43,     /* Spec 1.3A */
+	CECOP_USER_CONTROL_PRESSED		= 0x44,
+	CECOP_USER_CONTROL_RELEASED		= 0x45,
+	CECOP_GIVE_OSD_NAME			= 0x46,
+	CECOP_SET_OSD_NAME			= 0x47,
+	CECOP_SET_OSD_STRING			= 0x64,
+	CECOP_SET_TIMER_PROGRAM_TITLE		= 0x67,	/* Spec 1.3A */
+	CECOP_SYSTEM_AUDIO_MODE_REQUEST		= 0x70,	/* Spec 1.3A */
+	CECOP_GIVE_AUDIO_STATUS			= 0x71,	/* Spec 1.3A */
+	CECOP_SET_SYSTEM_AUDIO_MODE		= 0x72,	/* Spec 1.3A */
+	CECOP_REPORT_AUDIO_STATUS		= 0x7A,	/* Spec 1.3A */
+	CECOP_GIVE_SYSTEM_AUDIO_MODE_STATUS	= 0x7D,	/* Spec 1.3A */
+	CECOP_SYSTEM_AUDIO_MODE_STATUS		= 0x7E,	/* Spec 1.3A */
+	CECOP_ROUTING_CHANGE			= 0x80,
+	CECOP_ROUTING_INFORMATION		= 0x81,
+	CECOP_ACTIVE_SOURCE			= 0x82,
+	CECOP_GIVE_PHYSICAL_ADDRESS		= 0x83,
+	CECOP_REPORT_PHYSICAL_ADDRESS		= 0x84,
+	CECOP_REQUEST_ACTIVE_SOURCE		= 0x85,
+	CECOP_SET_STREAM_PATH			= 0x86,
+	CECOP_DEVICE_VENDOR_ID			= 0x87,
+	CECOP_VENDOR_COMMAND			= 0x89,
+	CECOP_VENDOR_REMOTE_BUTTON_DOWN		= 0x8A,
+	CECOP_VENDOR_REMOTE_BUTTON_UP		= 0x8B,
+	CECOP_GIVE_DEVICE_VENDOR_ID		= 0x8C,
+	CECOP_MENU_REQUEST			= 0x8D,
+	CECOP_MENU_STATUS			= 0x8E,
+	CECOP_GIVE_DEVICE_POWER_STATUS		= 0x8F,
+	CECOP_REPORT_POWER_STATUS		= 0x90,
+	CECOP_GET_MENU_LANGUAGE			= 0x91,
+	CECOP_SELECT_ANALOGUE_SERVICE		= 0x92,     /* Spec 1.3A */
+	CECOP_SELECT_DIGITAL_SERVICE		= 0x93,
+	CECOP_SET_DIGITAL_TIMER			= 0x97,     /* Spec 1.3A */
+	CECOP_CLEAR_DIGITAL_TIMER		= 0x99,     /* Spec 1.3A */
+	CECOP_SET_AUDIO_RATE			= 0x9A,     /* Spec 1.3A */
+	CECOP_INACTIVE_SOURCE			= 0x9D,     /* Spec 1.3A */
+	CECOP_CEC_VERSION			= 0x9E,     /* Spec 1.3A */
+	CECOP_GET_CEC_VERSION			= 0x9F,     /* Spec 1.3A */
+	CECOP_VENDOR_COMMAND_WITH_ID		= 0xA0,     /* Spec 1.3A */
+	CECOP_CLEAR_EXTERNAL_TIMER		= 0xA1,     /* Spec 1.3A */
+	CECOP_SET_EXTERNAL_TIMER		= 0xA2,     /* Spec 1.3A */
+	CDCOP_HEADER				= 0xF8,
+	CECOP_ABORT				= 0xFF,
+
+	CECOP_REPORT_SHORT_AUDIO		= 0xA3,     /* Spec 1.4 */
+	CECOP_REQUEST_SHORT_AUDIO		= 0xA4,     /* Spec 1.4 */
+
+	CECOP_ARC_INITIATE			= 0xC0,
+	CECOP_ARC_REPORT_INITIATED		= 0xC1,
+	CECOP_ARC_REPORT_TERMINATED		= 0xC2,
+
+	CECOP_ARC_REQUEST_INITIATION		= 0xC3,
+	CECOP_ARC_REQUEST_TERMINATION		= 0xC4,
+	CECOP_ARC_TERMINATE			= 0xC5,
+
+};
+
+/* Operands for <Feature Abort> Opcode */
+enum {
+	CECAR_UNRECOG_OPCODE            = 0x00,
+	CECAR_NOT_CORRECT_MODE,
+	CECAR_CANT_PROVIDE_SOURCE,
+	CECAR_INVALID_OPERAND,
+	CECAR_REFUSED
+};
+
+/* Operands for <Power Status> Opcode */
+enum {
+	CEC_POWERSTATUS_ON              = 0x00,
+	CEC_POWERSTATUS_STANDBY         = 0x01,
+	CEC_POWERSTATUS_STANDBY_TO_ON   = 0x02,
+	CEC_POWERSTATUS_ON_TO_STANDBY   = 0x03,
+};
+
+enum {
+	EVENT_RX_FRAME,
+	EVENT_ENUMERATE,
+};
+
+enum {
+	CEC_SEND_SUCCESS = 0,
+	CEC_SEND_NACK,
+	CEC_SEND_BUSY
+};
+
+#define MAKE_SRCDEST(src, dest)    ((src << 4) | dest)
+
+#define MAX_CMD_SIZE 16
+
+struct cec_framedata {
+	u8 srcdestaddr; /* Source in upper nybble, dest in lower nybble */
+	u8 opcode;
+	u8 args[MAX_CMD_SIZE];
+	u8 argcount;
+	char returnval;
+};
+
+struct cec_delayed_work {
+	struct delayed_work work;
+	int event;
+	void *data;
+};
+
+struct cecframelist {
+	struct list_head framelist;
+	struct cec_framedata cecframe;
+};
+
+struct cec_device {
+	struct workqueue_struct *workqueue;
+	struct hdmi *hdmi;
+	struct miscdevice device;
+	int address_phy;
+	int address_logic;
+	int powerstatus;
+	int enable;
+	struct list_head ceclist;
+	struct mutex cec_lock;	/* mutex for hdmicec operation*/
+
+	int (*sendframe)(struct hdmi *, struct cec_framedata *);
+	int (*readframe)(struct hdmi *, struct cec_framedata *);
+	void (*setceclogicaddr)(struct hdmi *, int);
+};
+
+#define HDMI_CEC_MAGIC     'N'
+#define HDMI_IOCTL_CECSEND   _IOW(HDMI_CEC_MAGIC, 0, struct cec_framedata)
+#define HDMI_IOCTL_CECENAB   _IOW(HDMI_CEC_MAGIC, 1, int)
+#define HDMI_IOCTL_CECPHY    _IOR(HDMI_CEC_MAGIC, 2, int)
+#define HDMI_IOCTL_CECLOGIC  _IOR(HDMI_CEC_MAGIC, 3, int)
+#define HDMI_IOCTL_CECREAD   _IOR(HDMI_CEC_MAGIC, 4, struct cec_framedata)
+#define HDMI_IOCTL_CECSETLA  _IOW(HDMI_CEC_MAGIC, 5, int)
+#define HDMI_IOCTL_CECCLEARLA  _IOW(HDMI_CEC_MAGIC, 6, int)
+#define HDMI_IOCTL_CECWAKESTATE  _IOR(HDMI_CEC_MAGIC, 7, int)
+/*for HAL ioctl end*/
+
+int rockchip_hdmi_cec_init(struct hdmi *hdmi,
+			   int (*sendframe)(struct hdmi *,
+					    struct cec_framedata *),
+			   int (*readframe)(struct hdmi *,
+					    struct cec_framedata *),
+			   void (*setceclogicaddr)(struct hdmi *, int));
+void rockchip_hdmi_cec_set_pa(int devpa);
+void rockchip_hdmi_cec_submit_work(int event, int delay, void *data);
+#endif /* __HDMI_CEC_H__ */
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,840 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/delay.h>
+#include <sound/pcm_params.h>
+#include "rockchip-hdmi.h"
+#include "rockchip-hdmi-cec.h"
+
+#define HW_PARAMS_FLAG_LPCM 0
+#define HW_PARAMS_FLAG_NLPCM 1
+
+struct hdmi_delayed_work {
+	struct delayed_work work;
+	struct hdmi *hdmi;
+	int event;
+	int sync;
+	void *data;
+};
+
+struct hdmi_id_ref_info {
+	struct hdmi *hdmi;
+	int id;
+	int ref;
+} ref_info[HDMI_MAX_ID];
+
+static int uboot_vic;
+static void hdmi_work_queue(struct work_struct *work);
+
+void hdmi_submit_work(struct hdmi *hdmi,
+		      int event, int delay, int sync)
+{
+	struct hdmi_delayed_work *work;
+
+	HDMIDBG(2, "%s event %04x delay %d sync %d\n",
+		__func__, event, delay, sync);
+
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+
+	if (work) {
+		INIT_DELAYED_WORK(&work->work, hdmi_work_queue);
+		work->hdmi = hdmi;
+		work->event = event;
+		work->data = NULL;
+		work->sync = sync;
+		queue_delayed_work(hdmi->workqueue,
+				   &work->work,
+				   msecs_to_jiffies(delay));
+		if (sync) {
+			flush_delayed_work(&work->work);
+			kfree(work);
+		}
+	} else {
+		pr_warn("HDMI: Cannot allocate memory to create work\n");
+	}
+}
+
+static void hdmi_send_uevent(struct hdmi *hdmi, int uevent)
+{
+	char *envp[3];
+
+	envp[0] = "INTERFACE=HDMI";
+	envp[1] = kmalloc(32, GFP_KERNEL);
+	if (!envp[1])
+		return;
+	sprintf(envp[1], "SCREEN=%d", hdmi->ddev->property);
+	envp[2] = NULL;
+	kobject_uevent_env(&hdmi->ddev->dev->kobj, uevent, envp);
+	kfree(envp[1]);
+}
+
+static inline void hdmi_wq_set_output(struct hdmi *hdmi, int mute)
+{
+	HDMIDBG(2, "%s mute %d\n", __func__, mute);
+	if (hdmi->ops->setmute)
+		hdmi->ops->setmute(hdmi, mute);
+}
+
+static inline void hdmi_wq_set_audio(struct hdmi *hdmi)
+{
+	HDMIDBG(2, "%s\n", __func__);
+	if (hdmi->ops->setaudio)
+		hdmi->ops->setaudio(hdmi, &hdmi->audio);
+}
+
+static int hdmi_check_format(struct hdmi *hdmi, struct hdmi_video *vpara)
+{
+	struct hdmi_video_timing *timing;
+	struct fb_videomode *mode;
+	int tmdsclk;
+
+	if (!vpara)
+		return -ENOENT;
+	timing = (struct hdmi_video_timing *)hdmi_vic2timing(vpara->vic);
+	if (!timing) {
+		pr_err("[%s] not found vic %d\n", __func__, vpara->vic);
+		return -ENOENT;
+	}
+	mode = &timing->mode;
+	if (vpara->color_input == HDMI_COLOR_YCBCR420)
+		tmdsclk = mode->pixclock / 2;
+	else if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
+		tmdsclk = 2 * mode->pixclock;
+	else
+		tmdsclk = mode->pixclock;
+	if (vpara->color_output != HDMI_COLOR_YCBCR422) {
+		switch (vpara->color_output_depth) {
+		case 10:
+			tmdsclk += tmdsclk / 4;
+			break;
+		case 12:
+			tmdsclk += tmdsclk / 2;
+			break;
+		case 16:
+			tmdsclk += tmdsclk;
+			break;
+		case 8:
+		default:
+			break;
+		}
+	} else if (vpara->color_output_depth > 12) {
+		/* YCbCr422 mode only support up to 12bit */
+		vpara->color_output_depth = 12;
+	}
+	if ((tmdsclk > 594000000) ||
+	    (tmdsclk > 340000000 &&
+	     tmdsclk > hdmi->edid.maxtmdsclock)) {
+		if (vpara->format_3d == HDMI_3D_FRAME_PACKING) {
+			pr_err("out of max tmdsclk, disable 3d\n");
+			vpara->format_3d = 0;
+		} else if (vpara->color_output == HDMI_COLOR_YCBCR444 &&
+			   hdmi->edid.ycbcr422) {
+			pr_warn("out of max tmdsclk, down to YCbCr422");
+			vpara->color_output = HDMI_COLOR_YCBCR422;
+		} else {
+			pr_warn("out of max tmds clock, limit to 8bit\n");
+			vpara->color_output_depth = 8;
+		}
+	}
+	return 0;
+}
+
+static void hdmi_wq_set_video(struct hdmi *hdmi)
+{
+	struct hdmi_video *video = &hdmi->video;
+	int	deepcolor;
+
+	HDMIDBG(2, "%s\n", __func__);
+
+	video->sink_hdmi = hdmi->edid.sink_hdmi;
+	video->format_3d = hdmi->mode_3d;
+	video->colorimetry = hdmi->colorimetry;
+	video->color_output_depth = 8;
+	if (hdmi->autoset)
+		hdmi->vic = hdmi_find_best_mode(hdmi, 0);
+	else
+		hdmi->vic = hdmi_find_best_mode(hdmi, hdmi->vic);
+
+	if (hdmi->vic == 0)
+		hdmi->vic = hdmi->property->defaultmode;
+
+	/* For DVI, output RGB */
+	if (video->sink_hdmi == 0) {
+		video->color_output = HDMI_COLOR_RGB_0_255;
+	} else {
+		if (hdmi->colormode == HDMI_COLOR_AUTO) {
+			if (hdmi->edid.ycbcr444)
+				video->color_output = HDMI_COLOR_YCBCR444;
+			else if (hdmi->edid.ycbcr422)
+				video->color_output = HDMI_COLOR_YCBCR422;
+			else
+				video->color_output = HDMI_COLOR_RGB_16_235;
+		} else {
+			video->color_output = hdmi->colormode;
+		}
+		if (hdmi->vic & HDMI_VIDEO_YUV420) {
+			video->color_output = HDMI_COLOR_YCBCR420;
+			deepcolor = hdmi->edid.deepcolor_420;
+		} else {
+			deepcolor = hdmi->edid.deepcolor;
+		}
+		if ((hdmi->property->feature & SUPPORT_DEEP_10BIT) &&
+		    (deepcolor & HDMI_DEEP_COLOR_30BITS) &&
+		     hdmi->colordepth == 10)
+			video->color_output_depth = 10;
+	}
+	pr_info("hdmi output corlor mode is %d\n", video->color_output);
+	if ((hdmi->property->feature & SUPPORT_YCBCR_INPUT) &&
+	    (video->color_output == HDMI_COLOR_YCBCR444 ||
+	     video->color_output == HDMI_COLOR_YCBCR422))
+		video->color_input = HDMI_COLOR_YCBCR444;
+	else if (video->color_output == HDMI_COLOR_YCBCR420)
+		video->color_input = HDMI_COLOR_YCBCR420;
+	else
+		video->color_input = HDMI_COLOR_RGB_0_255;
+
+	if ((hdmi->vic & HDMI_VIDEO_DMT) || (hdmi->vic & HDMI_VIDEO_DISCRETE_VR)) {
+		if (hdmi->edid_auto_support) {
+			if (hdmi->prop.value.vic)
+				video->vic = hdmi->prop.value.vic;
+			else
+				video->vic = hdmi->vic;
+		} else {
+			video->vic = hdmi->vic;
+		}
+		video->color_output_depth = 8;
+		video->eotf = 0;
+	} else {
+		video->vic = hdmi->vic & HDMI_VIC_MASK;
+
+		if (hdmi->eotf & hdmi->edid.hdr.hdrinfo.eotf)
+			video->eotf = hdmi->eotf;
+		else
+			video->eotf = 0;
+		/* ST_2084 must be 10bit and bt2020 */
+		if (video->eotf & EOTF_ST_2084) {
+			if (deepcolor & HDMI_DEEP_COLOR_30BITS)
+				video->color_output_depth = 10;
+			if (video->color_output > HDMI_COLOR_RGB_16_235)
+				video->colorimetry =
+					HDMI_COLORIMETRY_EXTEND_BT_2020_YCC;
+			else
+				video->colorimetry =
+					HDMI_COLORIMETRY_EXTEND_BT_2020_RGB;
+		}
+	}
+	hdmi_check_format(hdmi, video);
+	if (hdmi->uboot) {
+		if ((uboot_vic & HDMI_UBOOT_VIC_MASK) != hdmi->vic)
+			hdmi->uboot = 0;
+	}
+
+	hdmi_set_lcdc(hdmi);
+	if (hdmi->ops->setvideo)
+		hdmi->ops->setvideo(hdmi, video);
+}
+
+static void hdmi_wq_set_hdr(struct hdmi *hdmi)
+{
+	struct hdmi_video *video = &hdmi->video;
+	int deepcolor = 8;
+
+	if (hdmi->vic & HDMI_VIDEO_YUV420)
+		deepcolor = hdmi->edid.deepcolor_420;
+	else
+		deepcolor = hdmi->edid.deepcolor;
+
+	if ((hdmi->property->feature & SUPPORT_DEEP_10BIT) &&
+	    (deepcolor & HDMI_DEEP_COLOR_30BITS) &&
+	     hdmi->colordepth == 10)
+		deepcolor = 10;
+
+	if (deepcolor == video->color_output_depth &&
+	    hdmi->ops->sethdr && hdmi->ops->setavi &&
+	    hdmi->edid.sink_hdmi) {
+		if (hdmi->eotf & hdmi->edid.hdr.hdrinfo.eotf)
+			video->eotf = hdmi->eotf;
+		else
+			video->eotf = 0;
+
+		/* ST_2084 must be 10bit and bt2020 */
+		if (video->eotf & EOTF_ST_2084) {
+			if (video->color_output > HDMI_COLOR_RGB_16_235)
+				video->colorimetry =
+					HDMI_COLORIMETRY_EXTEND_BT_2020_YCC;
+			else
+				video->colorimetry =
+					HDMI_COLORIMETRY_EXTEND_BT_2020_RGB;
+		} else {
+			video->colorimetry = hdmi->colorimetry;
+		}
+		hdmi_set_lcdc(hdmi);
+		hdmi->ops->sethdr(hdmi, hdmi->eotf, &hdmi->hdr);
+		hdmi->ops->setavi(hdmi, video);
+	} else {
+		hdmi_submit_work(hdmi, HDMI_SET_COLOR, 0, 0);
+	}
+}
+
+static void hdmi_wq_parse_edid(struct hdmi *hdmi)
+{
+	struct hdmi_edid *pedid;
+
+	int rc = HDMI_ERROR_SUCCESS, extendblock = 0, i, trytimes;
+
+	if (!hdmi)
+		return;
+
+	HDMIDBG(2, "%s\n", __func__);
+
+	pedid = &hdmi->edid;
+	fb_destroy_modelist(&pedid->modelist);
+	memset(pedid, 0, sizeof(struct hdmi_edid));
+	INIT_LIST_HEAD(&pedid->modelist);
+
+	pedid->raw[0] = kmalloc(HDMI_EDID_BLOCK_SIZE, GFP_KERNEL);
+	if (!pedid->raw[0]) {
+		rc = HDMI_ERROR_FALSE;
+		goto out;
+	}
+
+	if (!hdmi->ops->getedid) {
+		rc = HDMI_ERROR_FALSE;
+		goto out;
+	}
+
+	/* Read base block edid.*/
+	for (trytimes = 0; trytimes < 3; trytimes++) {
+		if (trytimes)
+			msleep(50);
+		memset(pedid->raw[0], 0, HDMI_EDID_BLOCK_SIZE);
+		rc = hdmi->ops->getedid(hdmi, 0, pedid->raw[0]);
+		if (rc) {
+			dev_err(hdmi->dev,
+				"[HDMI] read edid base block error\n");
+			continue;
+		}
+
+		rc = hdmi_edid_parse_base(hdmi,
+					  pedid->raw[0], &extendblock, pedid);
+		if (rc) {
+			dev_err(hdmi->dev,
+				"[HDMI] parse edid base block error\n");
+			continue;
+		}
+		if (!rc)
+			break;
+	}
+	if (rc)
+		goto out;
+
+	for (i = 1; (i < extendblock + 1) && (i < HDMI_MAX_EDID_BLOCK); i++) {
+		pedid->raw[i] = kmalloc(HDMI_EDID_BLOCK_SIZE, GFP_KERNEL);
+		if (!pedid->raw[i]) {
+			dev_err(hdmi->dev,
+				"[%s] can not allocate memory for edid buff.\n",
+				__func__);
+			rc = HDMI_ERROR_FALSE;
+			goto out;
+		}
+		for (trytimes = 0; trytimes < 3; trytimes++) {
+			if (trytimes)
+				msleep(20);
+			memset(pedid->raw[i], 0, HDMI_EDID_BLOCK_SIZE);
+			rc = hdmi->ops->getedid(hdmi, i, pedid->raw[i]);
+			if (rc) {
+				dev_err(hdmi->dev,
+					"[HDMI] read edid block %d error\n",
+					i);
+				continue;
+			}
+
+			rc = hdmi_edid_parse_extensions(pedid->raw[i], pedid);
+			if (rc) {
+				dev_err(hdmi->dev,
+					"[HDMI] parse edid block %d error\n",
+					i);
+				continue;
+			}
+
+			if (!rc)
+				break;
+		}
+	}
+out:
+	rc = hdmi_ouputmode_select(hdmi, rc);
+}
+
+static void hdmi_wq_insert(struct hdmi *hdmi)
+{
+	HDMIDBG(2, "%s\n", __func__);
+	if (hdmi->ops->insert)
+		hdmi->ops->insert(hdmi);
+	hdmi_wq_parse_edid(hdmi);
+	if (hdmi->property->feature & SUPPORT_CEC)
+		rockchip_hdmi_cec_set_pa(hdmi->edid.cecaddress);
+	hdmi_send_uevent(hdmi, KOBJ_ADD);
+	if (hdmi->enable) {
+		/*hdmi->autoset = 0;*/
+		hdmi_wq_set_video(hdmi);
+		#ifdef CONFIG_SWITCH
+		switch_set_state(&hdmi->switchdev, 1);
+		#endif
+		hdmi_wq_set_audio(hdmi);
+		hdmi_wq_set_output(hdmi, hdmi->mute);
+		hdmi_submit_work(hdmi, HDMI_ENABLE_HDCP, 100, 0);
+		if (hdmi->ops->setcec)
+			hdmi->ops->setcec(hdmi);
+	}
+	if (hdmi->uboot)
+		hdmi->uboot = 0;
+}
+
+static void hdmi_wq_remove(struct hdmi *hdmi)
+{
+	struct list_head *pos, *n;
+	struct rk_screen screen;
+	int i;
+
+	HDMIDBG(2, "%s\n", __func__);
+	if (hdmi->ops->remove)
+		hdmi->ops->remove(hdmi);
+	if (hdmi->property->feature & SUPPORT_CEC)
+		rockchip_hdmi_cec_set_pa(0);
+	if (hdmi->hotplug == HDMI_HPD_ACTIVATED) {
+		screen.type = SCREEN_HDMI;
+		rk_fb_switch_screen(&screen, 0, hdmi->lcdc->id);
+	}
+	#ifdef CONFIG_SWITCH
+	switch_set_state(&hdmi->switchdev, 0);
+	#endif
+	list_for_each_safe(pos, n, &hdmi->edid.modelist) {
+		list_del(pos);
+		kfree(pos);
+	}
+	for (i = 0; i < HDMI_MAX_EDID_BLOCK; i++)
+		kfree(hdmi->edid.raw[i]);
+	kfree(hdmi->edid.audio);
+	if (hdmi->edid.specs) {
+		kfree(hdmi->edid.specs->modedb);
+		kfree(hdmi->edid.specs);
+	}
+	memset(&hdmi->edid, 0, sizeof(struct hdmi_edid));
+	hdmi_init_modelist(hdmi);
+	hdmi->mute	= HDMI_AV_UNMUTE;
+	hdmi->mode_3d = HDMI_3D_NONE;
+	hdmi->uboot = 0;
+	hdmi->hotplug = HDMI_HPD_REMOVED;
+	hdmi_send_uevent(hdmi, KOBJ_REMOVE);
+}
+
+static void hdmi_work_queue(struct work_struct *work)
+{
+	struct hdmi_delayed_work *hdmi_w =
+		container_of(work, struct hdmi_delayed_work, work.work);
+	struct hdmi *hdmi = hdmi_w->hdmi;
+	int event = hdmi_w->event;
+	int hpd = HDMI_HPD_REMOVED;
+
+	mutex_lock(&hdmi->ddev->lock);
+
+	HDMIDBG(2, "\nhdmi_work_queue() - evt= %x %d\n",
+		(event & 0xFF00) >> 8, event & 0xFF);
+
+	if ((!hdmi->enable || hdmi->sleep) &&
+	    (event != HDMI_ENABLE_CTL) &&
+	    (event != HDMI_RESUME_CTL) &&
+	    (event != HDMI_DISABLE_CTL) &&
+	    (event != HDMI_SUSPEND_CTL))
+		goto exit;
+
+	switch (event) {
+	case HDMI_ENABLE_CTL:
+		if (!hdmi->enable) {
+			hdmi->enable = 1;
+			if (!hdmi->sleep) {
+				if (hdmi->ops->enable)
+					hdmi->ops->enable(hdmi);
+				if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+					hdmi_wq_insert(hdmi);
+			}
+		}
+		break;
+	case HDMI_RESUME_CTL:
+		if (hdmi->sleep) {
+			if (hdmi->ops->enable)
+				hdmi->ops->enable(hdmi);
+			hdmi->sleep = 0;
+		}
+		break;
+	case HDMI_DISABLE_CTL:
+		if (hdmi->enable) {
+			if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+				hdmi_wq_set_output(hdmi,
+						   HDMI_VIDEO_MUTE |
+						   HDMI_AUDIO_MUTE);
+			if (!hdmi->sleep) {
+				if (hdmi->ops->disable)
+					hdmi->ops->disable(hdmi);
+				hdmi_wq_remove(hdmi);
+			}
+			hdmi->enable = 0;
+		}
+		break;
+	case HDMI_SUSPEND_CTL:
+		if (!hdmi->sleep) {
+			if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+				hdmi_wq_set_output(hdmi,
+						   HDMI_VIDEO_MUTE |
+						   HDMI_AUDIO_MUTE);
+			if (hdmi->ops->disable)
+				hdmi->ops->disable(hdmi);
+			if (hdmi->enable)
+				hdmi_wq_remove(hdmi);
+			hdmi->sleep = 1;
+		}
+		break;
+	case HDMI_HPD_CHANGE:
+		if (hdmi->ops->getstatus)
+			hpd = hdmi->ops->getstatus(hdmi);
+		HDMIDBG(2, "hdmi_work_queue() - hpd is %d hotplug is %d\n",
+			hpd, hdmi->hotplug);
+		if (hpd != hdmi->hotplug) {
+			if (hpd == HDMI_HPD_ACTIVATED) {
+				hdmi->hotplug = hpd;
+				hdmi_wq_insert(hdmi);
+			} else if (hdmi->hotplug == HDMI_HPD_ACTIVATED) {
+				hdmi_wq_remove(hdmi);
+			}
+			hdmi->hotplug = hpd;
+		}
+		break;
+	case HDMI_SET_VIDEO:
+		hdmi_wq_set_output(hdmi,
+				   HDMI_VIDEO_MUTE | HDMI_AUDIO_MUTE);
+		if (rk_fb_get_display_policy() == DISPLAY_POLICY_BOX)
+			msleep(2000);
+		else
+			msleep(1100);
+		hdmi_wq_set_video(hdmi);
+		hdmi_send_uevent(hdmi, KOBJ_CHANGE);
+		hdmi_wq_set_audio(hdmi);
+		hdmi_wq_set_output(hdmi, hdmi->mute);
+		if (hdmi->ops->hdcp_cb)
+			hdmi->ops->hdcp_cb(hdmi);
+		break;
+	case HDMI_SET_AUDIO:
+		if ((hdmi->mute & HDMI_AUDIO_MUTE) == 0) {
+			hdmi_wq_set_output(hdmi, HDMI_AUDIO_MUTE);
+			hdmi_wq_set_audio(hdmi);
+			hdmi_wq_set_output(hdmi, hdmi->mute);
+		}
+		break;
+	case HDMI_MUTE_AUDIO:
+	case HDMI_UNMUTE_AUDIO:
+		if (hdmi->mute & HDMI_AUDIO_MUTE ||
+		    hdmi->hotplug != HDMI_HPD_ACTIVATED)
+			break;
+		if (event == HDMI_MUTE_AUDIO)
+			hdmi_wq_set_output(hdmi, hdmi->mute |
+					   HDMI_AUDIO_MUTE);
+		else
+			hdmi_wq_set_output(hdmi,
+					   hdmi->mute & (~HDMI_AUDIO_MUTE));
+		break;
+	case HDMI_SET_3D:
+		if (hdmi->ops->setvsi && hdmi->edid.sink_hdmi) {
+			if (hdmi->mode_3d == HDMI_3D_FRAME_PACKING ||
+			    hdmi->video.format_3d ==
+			    HDMI_3D_FRAME_PACKING) {
+				hdmi_wq_set_output(hdmi,
+						   HDMI_VIDEO_MUTE |
+						   HDMI_AUDIO_MUTE);
+				msleep(100);
+				hdmi_wq_set_video(hdmi);
+				hdmi_wq_set_audio(hdmi);
+				hdmi_wq_set_output(hdmi, hdmi->mute);
+			} else if (hdmi->mode_3d != HDMI_3D_NONE) {
+				hdmi->ops->setvsi(hdmi, hdmi->mode_3d,
+						  HDMI_VIDEO_FORMAT_3D);
+			} else if ((hdmi->vic & HDMI_TYPE_MASK) == 0) {
+				hdmi->ops->setvsi(hdmi, hdmi->vic,
+						  HDMI_VIDEO_FORMAT_NORMAL);
+			}
+		}
+		break;
+	case HDMI_SET_COLOR:
+		hdmi_wq_set_output(hdmi,
+				   HDMI_VIDEO_MUTE | HDMI_AUDIO_MUTE);
+		msleep(100);
+		hdmi_wq_set_video(hdmi);
+		hdmi_wq_set_audio(hdmi);
+		hdmi_wq_set_output(hdmi, hdmi->mute);
+		break;
+	case HDMI_SET_HDR:
+		hdmi_wq_set_hdr(hdmi);
+		break;
+	case HDMI_ENABLE_HDCP:
+		if (hdmi->hotplug == HDMI_HPD_ACTIVATED && hdmi->ops->hdcp_cb)
+			hdmi->ops->hdcp_cb(hdmi);
+		break;
+	case HDMI_HDCP_AUTH_2ND:
+		if (hdmi->hotplug == HDMI_HPD_ACTIVATED &&
+		    hdmi->ops->hdcp_auth2nd)
+			hdmi->ops->hdcp_auth2nd(hdmi);
+		break;
+	default:
+		break;
+	}
+exit:
+	kfree(hdmi_w->data);
+	if (!hdmi_w->sync)
+		kfree(hdmi_w);
+
+	HDMIDBG(2, "\nhdmi_work_queue() - exit evt= %x %d\n",
+		(event & 0xFF00) >> 8, event & 0xFF);
+	mutex_unlock(&hdmi->ddev->lock);
+}
+
+struct hdmi *rockchip_hdmi_register(struct hdmi_property *property,
+				    struct hdmi_ops *ops)
+{
+	struct hdmi *hdmi;
+	char name[32];
+	int i;
+
+	if (!property || !ops) {
+		pr_err("HDMI: %s invalid parameter\n", __func__);
+		return NULL;
+	}
+
+	for (i = 0; i < HDMI_MAX_ID; i++) {
+		if (ref_info[i].ref == 0)
+			break;
+	}
+	if (i == HDMI_MAX_ID)
+		return NULL;
+
+	HDMIDBG(2, "hdmi_register() - video source %d display %d\n",
+		property->videosrc,  property->display);
+
+	hdmi = kmalloc(sizeof(*hdmi), GFP_KERNEL);
+	if (!hdmi)
+		return NULL;
+
+	memset(hdmi, 0, sizeof(struct hdmi));
+	mutex_init(&hdmi->lock);
+	mutex_init(&hdmi->pclk_lock);
+
+	hdmi->property = property;
+	hdmi->ops = ops;
+	hdmi->enable = false;
+	hdmi->mute = HDMI_AV_UNMUTE;
+	hdmi->hotplug = HDMI_HPD_REMOVED;
+	hdmi->autoset = HDMI_AUTO_CONFIG;
+	if (uboot_vic > 0) {
+		hdmi->vic = uboot_vic & HDMI_UBOOT_VIC_MASK;
+		if (uboot_vic & HDMI_UBOOT_NOT_INIT)
+			hdmi->uboot = 0;
+		else
+			hdmi->uboot = 1;
+		hdmi->autoset = 0;
+	} else if (hdmi->autoset) {
+		hdmi->vic = 0;
+	} else {
+		hdmi->vic = hdmi->property->defaultmode;
+	}
+	hdmi->colormode = HDMI_VIDEO_DEFAULT_COLORMODE;
+	hdmi->colordepth = hdmi->property->defaultdepth;
+	hdmi->colorimetry = HDMI_COLORIMETRY_NO_DATA;
+	hdmi->mode_3d = HDMI_3D_NONE;
+	hdmi->audio.type = HDMI_AUDIO_DEFAULT_TYPE;
+	hdmi->audio.channel = HDMI_AUDIO_DEFAULT_CHANNEL;
+	hdmi->audio.rate = HDMI_AUDIO_DEFAULT_RATE;
+	hdmi->audio.word_length = HDMI_AUDIO_DEFAULT_WORDLENGTH;
+	hdmi->xscale = 100;
+	hdmi->yscale = 100;
+
+	if (hdmi->property->videosrc == DISPLAY_SOURCE_LCDC0)
+		hdmi->lcdc = rk_get_lcdc_drv("lcdc0");
+	else
+		hdmi->lcdc = rk_get_lcdc_drv("lcdc1");
+	if (!hdmi->lcdc)
+		goto err_create_wq;
+	if (hdmi->lcdc->prop == EXTEND)
+		hdmi->property->display = DISPLAY_AUX;
+	else
+		hdmi->property->display = DISPLAY_MAIN;
+	memset(name, 0, 32);
+	sprintf(name, "hdmi-%s", hdmi->property->name);
+	hdmi->workqueue = create_singlethread_workqueue(name);
+	if (!hdmi->workqueue) {
+		pr_err("HDMI,: create workqueue failed.\n");
+		goto err_create_wq;
+	}
+	hdmi->ddev = hdmi_register_display_sysfs(hdmi, NULL);
+	if (!hdmi->ddev) {
+		pr_err("HDMI : register display sysfs failed.\n");
+		goto err_register_display;
+	}
+	hdmi->id = i;
+	hdmi_init_modelist(hdmi);
+	#ifdef CONFIG_SWITCH
+	if (hdmi->id == 0) {
+		hdmi->switchdev.name = "hdmi";
+	} else {
+		hdmi->switchdev.name = kzalloc(32, GFP_KERNEL);
+		memset((char *)hdmi->switchdev.name, 0, 32);
+		sprintf((char *)hdmi->switchdev.name, "hdmi%d", hdmi->id);
+	}
+	switch_dev_register(&hdmi->switchdev);
+	#endif
+
+	ref_info[i].hdmi = hdmi;
+	ref_info[i].ref = 1;
+	return hdmi;
+
+err_register_display:
+	destroy_workqueue(hdmi->workqueue);
+err_create_wq:
+	kfree(hdmi);
+	return NULL;
+}
+
+void rockchip_hdmi_unregister(struct hdmi *hdmi)
+{
+	if (hdmi) {
+		flush_workqueue(hdmi->workqueue);
+		destroy_workqueue(hdmi->workqueue);
+		#ifdef CONFIG_SWITCH
+		switch_dev_unregister(&hdmi->switchdev);
+		#endif
+		hdmi_unregister_display_sysfs(hdmi);
+		fb_destroy_modelist(&hdmi->edid.modelist);
+		kfree(hdmi->edid.audio);
+		if (hdmi->edid.specs) {
+			kfree(hdmi->edid.specs->modedb);
+			kfree(hdmi->edid.specs);
+		}
+		ref_info[hdmi->id].ref = 0;
+		ref_info[hdmi->id].hdmi = NULL;
+		kfree(hdmi);
+
+		hdmi = NULL;
+	}
+}
+
+int hdmi_get_hotplug(void)
+{
+	if (ref_info[0].hdmi)
+		return ref_info[0].hdmi->hotplug;
+	else
+		return HDMI_HPD_REMOVED;
+}
+
+int hdmi_config_audio(struct hdmi_audio	*audio)
+{
+	int i;
+	struct hdmi *hdmi;
+
+	if (!audio)
+		return HDMI_ERROR_FALSE;
+
+	for (i = 0; i < HDMI_MAX_ID; i++) {
+		if (ref_info[i].ref == 0)
+			continue;
+		hdmi = ref_info[i].hdmi;
+		memcpy(&hdmi->audio, audio, sizeof(struct hdmi_audio));
+		if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+			hdmi_submit_work(hdmi, HDMI_SET_AUDIO, 0, 0);
+	}
+	return 0;
+}
+
+int snd_config_hdmi_audio(struct snd_pcm_hw_params *params)
+{
+	struct hdmi_audio audio_cfg;
+	u32	rate;
+
+	switch (params_rate(params)) {
+	case 32000:
+		rate = HDMI_AUDIO_FS_32000;
+		break;
+	case 44100:
+		rate = HDMI_AUDIO_FS_44100;
+		break;
+	case 48000:
+		rate = HDMI_AUDIO_FS_48000;
+		break;
+	case 88200:
+		rate = HDMI_AUDIO_FS_88200;
+		break;
+	case 96000:
+		rate = HDMI_AUDIO_FS_96000;
+		break;
+	case 176400:
+		rate = HDMI_AUDIO_FS_176400;
+		break;
+	case 192000:
+		rate = HDMI_AUDIO_FS_192000;
+		break;
+	default:
+		pr_err("rate %d unsupport.\n", params_rate(params));
+		rate = HDMI_AUDIO_FS_44100;
+	}
+
+	audio_cfg.rate = rate;
+
+	if (params->flags == HW_PARAMS_FLAG_NLPCM)
+		audio_cfg.type = HDMI_AUDIO_NLPCM;
+	else
+		audio_cfg.type = HDMI_AUDIO_LPCM;
+
+	audio_cfg.channel = params_channels(params);
+	audio_cfg.word_length = HDMI_AUDIO_WORD_LENGTH_16bit;
+
+	return hdmi_config_audio(&audio_cfg);
+}
+EXPORT_SYMBOL(snd_config_hdmi_audio);
+
+void hdmi_audio_mute(int mute)
+{
+	int i;
+	struct hdmi *hdmi;
+
+	for (i = 0; i < HDMI_MAX_ID; i++) {
+		if (ref_info[i].ref == 0)
+			continue;
+		hdmi = ref_info[i].hdmi;
+
+		if (mute)
+			hdmi_submit_work(hdmi, HDMI_MUTE_AUDIO, 0, 0);
+		else
+			hdmi_submit_work(hdmi, HDMI_UNMUTE_AUDIO, 0, 0);
+	}
+}
+
+static int __init bootloader_setup(char *str)
+{
+	if (str) {
+		pr_info("hdmi init vic is %s\n", str);
+		if (kstrtoint(str, 0, &uboot_vic) < 0)
+			uboot_vic = 0;
+	}
+	return 0;
+}
+
+early_param("hdmi.vic", bootloader_setup);
+
+static int __init hdmi_class_init(void)
+{
+	int i;
+
+	for (i = 0; i < HDMI_MAX_ID; i++) {
+		ref_info[i].id = i;
+		ref_info[i].ref = 0;
+		ref_info[i].hdmi = NULL;
+	}
+	pr_info("Rockchip hdmi driver version 2.0\n.");
+	return 0;
+}
+
+subsys_initcall(hdmi_class_init);
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,560 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include "rockchip-hdmi.h"
+#include "../../fbdev/edid.h"
+
+#ifdef EDIDDEBUG
+#define EDBG	DBG
+#else
+#define EDBG(format, ...)
+#endif
+
+enum {
+	E_HDMI_EDID_SUCCESS = 0,
+	E_HDMI_EDID_PARAM,
+	E_HDMI_EDID_HEAD,
+	E_HDMI_EDID_CHECKSUM,
+	E_HDMI_EDID_VERSION,
+	E_HDMI_EDID_UNKOWNDATA,
+	E_HDMI_EDID_NOMEMORY
+};
+
+static int hdmi_edid_checksum(unsigned char *buf)
+{
+	int i;
+	int checksum = 0;
+
+	for (i = 0; i < HDMI_EDID_BLOCK_SIZE; i++)
+		checksum += buf[i];
+
+	checksum &= 0xff;
+
+	if (checksum == 0)
+		return E_HDMI_EDID_SUCCESS;
+	else
+		return E_HDMI_EDID_CHECKSUM;
+}
+
+/*
+ *	@Des	Parse Detail Timing Descriptor.
+ *	@Param	buf	:	pointer to DTD data.
+ *	@Param	pvic:	VIC of DTD descripted.
+ */
+static int hdmi_edid_parse_dtd(unsigned char *block, struct fb_videomode *mode)
+{
+	mode->xres = H_ACTIVE;
+	mode->yres = V_ACTIVE;
+	mode->pixclock = PIXEL_CLOCK;
+	mode->right_margin = H_SYNC_OFFSET;
+	mode->left_margin = (H_ACTIVE + H_BLANKING) -
+		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
+	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
+		V_SYNC_WIDTH;
+	mode->lower_margin = V_SYNC_OFFSET;
+	mode->hsync_len = H_SYNC_WIDTH;
+	mode->vsync_len = V_SYNC_WIDTH;
+	if (HSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (VSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
+	mode->refresh = PIXEL_CLOCK / ((H_ACTIVE + H_BLANKING) *
+				       (V_ACTIVE + V_BLANKING));
+	if (INTERLACED) {
+		mode->yres *= 2;
+		mode->upper_margin *= 2;
+		mode->lower_margin *= 2;
+		mode->vsync_len *= 2;
+		mode->vmode |= FB_VMODE_INTERLACED;
+	}
+	mode->flag = FB_MODE_IS_DETAILED;
+
+	EDBG("<<<<<<<<Detailed Time>>>>>>>>>\n");
+	EDBG("%d KHz Refresh %d Hz",
+	     PIXEL_CLOCK / 1000, mode->refresh);
+	EDBG("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
+	     H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
+	EDBG("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
+	     V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
+	EDBG("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
+	     (VSYNC_POSITIVE) ? "+" : "-");
+	return E_HDMI_EDID_SUCCESS;
+}
+
+static int edid_parse_prop_value(unsigned char *buf,
+				 struct hdmi_edid *pedid)
+{
+	unsigned char *block = &buf[0x36];
+
+	pedid->value.vid = ((buf[ID_MANUFACTURER_NAME_END] << 8) |
+				(buf[ID_MANUFACTURER_NAME]));
+	pedid->value.pid = ((buf[ID_MODEL + 1] << 8) |
+				(buf[ID_MODEL]));
+	pedid->value.sn = ((buf[ID_SERIAL_NUMBER + 3] << 24) |
+				(buf[ID_SERIAL_NUMBER + 2] << 16) |
+				(buf[ID_SERIAL_NUMBER + 1] << 8) |
+				buf[ID_SERIAL_NUMBER]);
+	pedid->value.xres = H_ACTIVE;
+	pedid->value.yres = V_ACTIVE;
+
+	pr_info("%s:read:vid=0x%x,pid=0x%x,sn=0x%x,xres=%d,yres=%d\n",
+		__func__, pedid->value.vid, pedid->value.pid,
+		pedid->value.sn, pedid->value.xres, pedid->value.yres);
+
+	return 0;
+}
+
+int hdmi_edid_parse_base(struct hdmi *hdmi, unsigned char *buf,
+			 int *extend_num, struct hdmi_edid *pedid)
+{
+	int rc = E_HDMI_EDID_SUCCESS;
+
+	if (!buf || !extend_num)
+		return E_HDMI_EDID_PARAM;
+
+	*extend_num = buf[0x7e];
+	#ifdef DEBUG
+	EDBG("[EDID] extend block num is %d\n", buf[0x7e]);
+	#endif
+
+	/* Check first 8 byte to ensure it is an edid base block. */
+	if (buf[0] != 0x00 ||
+	    buf[1] != 0xFF ||
+	    buf[2] != 0xFF ||
+	    buf[3] != 0xFF ||
+	    buf[4] != 0xFF ||
+	    buf[5] != 0xFF ||
+	    buf[6] != 0xFF ||
+	    buf[7] != 0x00) {
+		pr_err("[EDID] check header error\n");
+		rc = E_HDMI_EDID_HEAD;
+		goto out;
+	}
+
+	/* Checksum */
+	rc = hdmi_edid_checksum(buf);
+	if (rc != E_HDMI_EDID_SUCCESS) {
+		pr_err("[EDID] base block checksum error\n");
+		rc = E_HDMI_EDID_CHECKSUM;
+		goto out;
+	}
+
+	pedid->specs = kzalloc(sizeof(*pedid->specs), GFP_KERNEL);
+	if (!pedid->specs)
+		return E_HDMI_EDID_NOMEMORY;
+
+	fb_edid_to_monspecs(buf, pedid->specs);
+
+	if (hdmi->edid_auto_support)
+		edid_parse_prop_value(buf, pedid);
+
+out:
+	/* For some sink, edid checksum is failed because several
+	 * byte is wrong. To fix this case, we think it is a good
+	 * edid if 1 <= *extend_num <= 4.
+	 */
+	if ((rc != E_HDMI_EDID_SUCCESS) &&
+	    (*extend_num < 1 || *extend_num > 4))
+		return rc;
+	else
+		return E_HDMI_EDID_SUCCESS;
+}
+
+/* Parse CEA Short Video Descriptor */
+static int hdmi_edid_get_cea_svd(unsigned char *buf, struct hdmi_edid *pedid)
+{
+	int count, i, vic;
+
+	count = buf[0] & 0x1F;
+	for (i = 0; i < count; i++) {
+		EDBG("[CEA] %02x VID %d native %d\n",
+		     buf[1 + i], buf[1 + i] & 0x7f, buf[1 + i] >> 7);
+		vic = buf[1 + i] & 0x7f;
+		hdmi_add_vic(vic, &pedid->modelist);
+	}
+	return 0;
+}
+
+/* Parse CEA Short Audio Descriptor */
+static int hdmi_edid_parse_cea_sad(unsigned char *buf, struct hdmi_edid *pedid)
+{
+	int i, count;
+
+	count = buf[0] & 0x1F;
+	pedid->audio = kmalloc((count / 3) * sizeof(struct hdmi_audio),
+			       GFP_KERNEL);
+	if (!pedid->audio)
+		return E_HDMI_EDID_NOMEMORY;
+
+	pedid->audio_num = count / 3;
+	for (i = 0; i < pedid->audio_num; i++) {
+		pedid->audio[i].type = (buf[1 + i * 3] >> 3) & 0x0F;
+		pedid->audio[i].channel = (buf[1 + i * 3] & 0x07) + 1;
+		pedid->audio[i].rate = buf[1 + i * 3 + 1];
+		if (pedid->audio[i].type == HDMI_AUDIO_LPCM)
+			pedid->audio[i].word_length = buf[1 + i * 3 + 2];
+	}
+	return E_HDMI_EDID_SUCCESS;
+}
+
+static int hdmi_edid_parse_3dinfo(unsigned char *buf, struct list_head *head)
+{
+	int i, j, len = 0, format_3d, vic_mask;
+	unsigned char offset = 2, vic_2d, structure_3d;
+	struct list_head *pos;
+	struct display_modelist *modelist;
+
+	if (buf[1] & 0xe0) {
+		len = (buf[1] & 0xe0) >> 5;
+		for (i = 0; i < len; i++) {
+			if (buf[offset]) {
+				vic_2d = (buf[offset] == 4) ?
+					 98 : (96 - buf[offset]);
+				hdmi_add_vic(vic_2d, head);
+			}
+			offset++;
+		}
+	}
+
+	if (buf[0] & 0x80) {
+		/* 3d supported */
+		len += (buf[1] & 0x1F) + 2;
+		if (((buf[0] & 0x60) == 0x40) || ((buf[0] & 0x60) == 0x20)) {
+			format_3d = buf[offset++] << 8;
+			format_3d |= buf[offset++];
+			if ((buf[0] & 0x60) == 0x20) {
+				vic_mask = 0xFFFF;
+			} else {
+				vic_mask  = buf[offset++] << 8;
+				vic_mask |= buf[offset++];
+			}
+		} else {
+			format_3d = 0;
+			vic_mask = 0;
+		}
+
+		for (i = 0; i < 16; i++) {
+			if (vic_mask & (1 << i)) {
+				j = 0;
+				for (pos = (head)->next; pos != (head);
+					pos = pos->next) {
+					if (j++ == i) {
+						modelist =
+			list_entry(pos, struct display_modelist, list);
+						modelist->format_3d = format_3d;
+						break;
+					}
+				}
+			}
+		}
+		while (offset < len) {
+			vic_2d = (buf[offset] & 0xF0) >> 4;
+			structure_3d = (buf[offset++] & 0x0F);
+			j = 0;
+			for (pos = (head)->next; pos != (head);
+				pos = pos->next) {
+				j++;
+				if (j == vic_2d) {
+					modelist =
+				list_entry(pos, struct display_modelist, list);
+					modelist->format_3d |=
+						(1 << structure_3d);
+					if (structure_3d & 0x08)
+						modelist->detail_3d =
+						(buf[offset++] & 0xF0) >> 4;
+					break;
+				}
+			}
+		}
+		/* mandatory formats */
+		for (pos = (head)->next; pos != (head); pos = pos->next) {
+			modelist = list_entry(pos,
+					      struct display_modelist,
+					      list);
+			if (modelist->vic == HDMI_1920X1080P_24HZ ||
+			    modelist->vic == HDMI_1280X720P_60HZ ||
+			    modelist->vic == HDMI_1280X720P_50HZ) {
+				modelist->format_3d |=
+					(1 << HDMI_3D_FRAME_PACKING) |
+					(1 << HDMI_3D_TOP_BOOTOM);
+			} else if (modelist->vic == HDMI_1920X1080I_60HZ ||
+				   modelist->vic == HDMI_1920X1080I_50HZ) {
+				modelist->format_3d |=
+					(1 << HDMI_3D_SIDE_BY_SIDE_HALF);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int hdmi_edmi_parse_vsdb(unsigned char *buf, struct hdmi_edid *pedid,
+				int cur_offset, int IEEEOUI)
+{
+	int count, buf_offset;
+
+	count = buf[cur_offset] & 0x1F;
+	switch (IEEEOUI) {
+	case 0x0c03:
+		pedid->sink_hdmi = 1;
+		pedid->cecaddress = buf[cur_offset + 5];
+		pedid->cecaddress |= buf[cur_offset + 4] << 8;
+		EDBG("[CEA] CEC Physical address is 0x%08x.\n",
+		     pedid->cecaddress);
+		if (count > 6)
+			pedid->deepcolor = (buf[cur_offset + 6] >> 3) & 0x0F;
+		if (count > 7) {
+			pedid->maxtmdsclock = buf[cur_offset + 7] * 5000000;
+			EDBG("[CEA] maxtmdsclock is %d.\n",
+			     pedid->maxtmdsclock);
+		}
+		if (count > 8) {
+			pedid->fields_present = buf[cur_offset + 8];
+			EDBG("[CEA] fields_present is 0x%02x.\n",
+			     pedid->fields_present);
+		}
+		buf_offset = cur_offset + 9;
+		if (pedid->fields_present & 0x80) {
+			pedid->video_latency = buf[buf_offset++];
+			pedid->audio_latency = buf[buf_offset++];
+		}
+		if (pedid->fields_present & 0x40) {
+			pedid->interlaced_video_latency = buf[buf_offset++];
+			pedid->interlaced_audio_latency = buf[buf_offset++];
+		}
+		if (pedid->fields_present & 0x20) {
+			hdmi_edid_parse_3dinfo(buf + buf_offset,
+					       &pedid->modelist);
+		}
+		break;
+	case 0xc45dd8:
+		pedid->sink_hdmi = 1;
+		pedid->hf_vsdb_version = buf[cur_offset + 4];
+		switch (pedid->hf_vsdb_version) {
+		case 1:/*compliant with HDMI Specification 2.0*/
+			pedid->maxtmdsclock =
+				buf[cur_offset + 5] * 5000000;
+			EDBG("[CEA] maxtmdsclock is %d.\n",
+			     pedid->maxtmdsclock);
+			pedid->scdc_present = buf[cur_offset + 6] >> 7;
+			pedid->rr_capable =
+				(buf[cur_offset + 6] & 0x40) >> 6;
+			pedid->lte_340mcsc_scramble =
+				(buf[cur_offset + 6] & 0x08) >> 3;
+			pedid->independent_view =
+				(buf[cur_offset + 6] & 0x04) >> 2;
+			pedid->dual_view =
+				(buf[cur_offset + 6] & 0x02) >> 1;
+			pedid->osd_disparity_3d =
+				buf[cur_offset + 6] & 0x01;
+			pedid->deepcolor_420 =
+				(buf[cur_offset + 7] & 0x7) << 1;
+			break;
+		default:
+			pr_info("hf_vsdb_version = %d\n",
+				pedid->hf_vsdb_version);
+			break;
+		}
+		break;
+	default:
+		pr_info("IEEOUT = 0x%x\n", IEEEOUI);
+		break;
+	}
+	return 0;
+}
+
+static void hdmi_edid_parse_yuv420cmdb(unsigned char *buf, int count,
+				       struct list_head *head)
+{
+	struct list_head *pos;
+	struct display_modelist *modelist;
+	int i, j, yuv420_mask = 0, vic;
+
+	if (count == 1) {
+		list_for_each(pos, head) {
+			modelist =
+				list_entry(pos, struct display_modelist, list);
+			vic = modelist->vic | HDMI_VIDEO_YUV420;
+			hdmi_add_vic(vic, head);
+		}
+	} else {
+		for (i = 0; i < count - 1; i++) {
+			EDBG("vic which support yuv420 mode is %x\n", buf[i]);
+			yuv420_mask |= buf[i] << (8 * i);
+		}
+		for (i = 0; i < 32; i++) {
+			if (!(yuv420_mask & (1 << i)))
+				continue;
+			j = 0;
+			list_for_each(pos, head) {
+				if (j++ == i) {
+					modelist =
+				list_entry(pos, struct display_modelist, list);
+					vic = modelist->vic |
+					      HDMI_VIDEO_YUV420;
+					hdmi_add_vic(vic, head);
+					break;
+				}
+			}
+		}
+	}
+}
+
+/* Parse CEA 861 Serial Extension. */
+static int hdmi_edid_parse_extensions_cea(unsigned char *buf,
+					  struct hdmi_edid *pedid)
+{
+	unsigned int ddc_offset, native_dtd_num, cur_offset = 4;
+	unsigned int tag, IEEEOUI = 0, count, i;
+	struct fb_videomode *vmode;
+
+	if (!buf)
+		return E_HDMI_EDID_PARAM;
+
+	/* Check ces extension version */
+	if (buf[1] != 3) {
+		pr_err("[CEA] error version.\n");
+		return E_HDMI_EDID_VERSION;
+	}
+
+	ddc_offset = buf[2];
+	pedid->baseaudio_support = (buf[3] >> 6) & 0x01;
+	pedid->ycbcr444 = (buf[3] >> 5) & 0x01;
+	pedid->ycbcr422 = (buf[3] >> 4) & 0x01;
+	native_dtd_num = buf[3] & 0x0F;
+	/* Parse data block */
+	while (cur_offset < ddc_offset) {
+		tag = buf[cur_offset] >> 5;
+		count = buf[cur_offset] & 0x1F;
+		switch (tag) {
+		case 0x02:	/* Video Data Block */
+			EDBG("[CEA] Video Data Block.\n");
+			hdmi_edid_get_cea_svd(buf + cur_offset, pedid);
+			break;
+		case 0x01:	/* Audio Data Block */
+			EDBG("[CEA] Audio Data Block.\n");
+			hdmi_edid_parse_cea_sad(buf + cur_offset, pedid);
+			break;
+		case 0x04:	/* Speaker Allocation Data Block */
+			EDBG("[CEA] Speaker Allocatio Data Block.\n");
+			break;
+		case 0x03:	/* Vendor Specific Data Block */
+			EDBG("[CEA] Vendor Specific Data Block.\n");
+
+			IEEEOUI = buf[cur_offset + 3];
+			IEEEOUI <<= 8;
+			IEEEOUI += buf[cur_offset + 2];
+			IEEEOUI <<= 8;
+			IEEEOUI += buf[cur_offset + 1];
+			EDBG("[CEA] IEEEOUI is 0x%08x.\n", IEEEOUI);
+
+			hdmi_edmi_parse_vsdb(buf, pedid,
+					     cur_offset, IEEEOUI);
+			break;
+		case 0x05:	/* VESA DTC Data Block */
+			EDBG("[CEA] VESA DTC Data Block.\n");
+			break;
+		case 0x07:	/* Use Extended Tag */
+			EDBG("[CEA] Use Extended Tag Data Block %02x.\n",
+			     buf[cur_offset + 1]);
+			switch (buf[cur_offset + 1]) {
+			case 0x00:
+				EDBG("[CEA] Video Capability Data Block\n");
+				EDBG("value is %02x\n", buf[cur_offset + 2]);
+				break;
+			case 0x05:
+				EDBG("[CEA] Colorimetry Data Block\n");
+				EDBG("value is %02x\n", buf[cur_offset + 2]);
+				pedid->colorimetry = buf[cur_offset + 2];
+				break;
+			case 0x06:
+				EDBG("[CEA] HDR Static Metedata data Block\n");
+				for (i = 0; i < count - 1; i++)
+					pedid->hdr.data[i] =
+						buf[cur_offset + 2 + i];
+				break;
+			case 0x0e:
+				EDBG("[CEA] YCBCR 4:2:0 Video Data Block\n");
+				for (i = 0; i < count - 1; i++) {
+					EDBG("mode is %d\n",
+					     buf[cur_offset + 2 + i]);
+					pedid->ycbcr420 = 1;
+					IEEEOUI = buf[cur_offset + 2 + i] |
+						  HDMI_VIDEO_YUV420;
+					hdmi_add_vic(IEEEOUI,
+						     &pedid->modelist);
+				}
+				break;
+			case 0x0f:
+				EDBG("[CEA] YCBCR 4:2:0 Capability Map Data\n");
+				hdmi_edid_parse_yuv420cmdb(&buf[cur_offset + 2],
+							   count,
+							   &pedid->modelist);
+				pedid->ycbcr420 = 1;
+				break;
+			}
+			break;
+		default:
+			pr_err("[CEA] unkowned data block tag.\n");
+			break;
+		}
+		cur_offset += (buf[cur_offset] & 0x1F) + 1;
+	}
+
+	/* Parse DTD */
+	vmode = kmalloc(sizeof(*vmode), GFP_KERNEL);
+
+	if (!vmode)
+		return E_HDMI_EDID_SUCCESS;
+	while (ddc_offset < HDMI_EDID_BLOCK_SIZE - 2) {
+		if (!buf[ddc_offset] && !buf[ddc_offset + 1])
+			break;
+		memset(vmode, 0, sizeof(struct fb_videomode));
+		hdmi_edid_parse_dtd(buf + ddc_offset, vmode);
+		hdmi_add_vic(hdmi_videomode_to_vic(vmode), &pedid->modelist);
+		ddc_offset += 18;
+	}
+	kfree(vmode);
+
+	return E_HDMI_EDID_SUCCESS;
+}
+
+int hdmi_edid_parse_extensions(unsigned char *buf, struct hdmi_edid *pedid)
+{
+	int rc;
+
+	if (!buf || !pedid)
+		return E_HDMI_EDID_PARAM;
+
+	/* Checksum */
+	rc = hdmi_edid_checksum(buf);
+	if (rc != E_HDMI_EDID_SUCCESS) {
+		pr_err("[EDID] extensions block checksum error\n");
+		return E_HDMI_EDID_CHECKSUM;
+	}
+
+	switch (buf[0]) {
+	case 0xF0:
+		EDBG("[EDID-EXTEND] Iextensions block map.\n");
+		break;
+	case 0x02:
+		EDBG("[EDID-EXTEND] CEA 861 Series Extension.\n");
+		hdmi_edid_parse_extensions_cea(buf, pedid);
+		break;
+	case 0x10:
+		EDBG("[EDID-EXTEND] Video Timing Block Extension.\n");
+		break;
+	case 0x40:
+		EDBG("[EDID-EXTEND] Display Information Extension.\n");
+		break;
+	case 0x50:
+		EDBG("[EDID-EXTEND] Localized String Extension.\n");
+		break;
+	case 0x60:
+		EDBG("[EDID-EXTEND] Digital Packet Video Link Extension.\n");
+		break;
+	default:
+		pr_err("[EDID-EXTEND] Unkowned Extension.\n");
+		return E_HDMI_EDID_UNKOWNDATA;
+	}
+
+	return E_HDMI_EDID_SUCCESS;
+}
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmi.h b/drivers/video/rockchip/hdmi/rockchip-hdmi.h
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,613 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_HDMI_H__
+#define __ROCKCHIP_HDMI_H__
+
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#include <linux/display-sys.h>
+#ifdef CONFIG_SWITCH
+#include <linux/switch.h>
+#endif
+#include <sound/pcm_params.h>
+#include <linux/reboot.h>
+
+#define HDMI_VIDEO_NORMAL				0
+#define HDMI_VIDEO_DMT					BIT(9)
+#define HDMI_VIDEO_YUV420				BIT(10)
+#define HDMI_VIDEO_DISCRETE_VR				BIT(11)
+
+#define HDMI_VIC_MASK					(0xFF)
+#define HDMI_TYPE_MASK					(0xFF << 8)
+#define HDMI_MAX_ID					4
+
+#define HDMI_UBOOT_NOT_INIT				BIT(16)
+#define HDMI_UBOOT_VIC_MASK				0xFFFF
+
+/* HDMI video information code according CEA-861-F */
+enum hdmi_video_information_code {
+	HDMI_640X480P_60HZ = 1,
+	HDMI_720X480P_60HZ_4_3,
+	HDMI_720X480P_60HZ_16_9,
+	HDMI_1280X720P_60HZ,
+	HDMI_1920X1080I_60HZ,		/*5*/
+	HDMI_720X480I_60HZ_4_3,
+	HDMI_720X480I_60HZ_16_9,
+	HDMI_720X240P_60HZ_4_3,
+	HDMI_720X240P_60HZ_16_9,
+	HDMI_2880X480I_60HZ_4_3,	/*10*/
+	HDMI_2880X480I_60HZ_16_9,
+	HDMI_2880X240P_60HZ_4_3,
+	HDMI_2880X240P_60HZ_16_9,
+	HDMI_1440X480P_60HZ_4_3,
+	HDMI_1440X480P_60HZ_16_9,	/*15*/
+	HDMI_1920X1080P_60HZ,
+	HDMI_720X576P_50HZ_4_3,
+	HDMI_720X576P_50HZ_16_9,
+	HDMI_1280X720P_50HZ,
+	HDMI_1920X1080I_50HZ,		/*20*/
+	HDMI_720X576I_50HZ_4_3,
+	HDMI_720X576I_50HZ_16_9,
+	HDMI_720X288P_50HZ_4_3,
+	HDMI_720X288P_50HZ_16_9,
+	HDMI_2880X576I_50HZ_4_3,	/*25*/
+	HDMI_2880X576I_50HZ_16_9,
+	HDMI_2880X288P_50HZ_4_3,
+	HDMI_2880X288P_50HZ_16_9,
+	HDMI_1440X576P_50HZ_4_3,
+	HDMI_1440X576P_50HZ_16_9,	/*30*/
+	HDMI_1920X1080P_50HZ,
+	HDMI_1920X1080P_24HZ,
+	HDMI_1920X1080P_25HZ,
+	HDMI_1920X1080P_30HZ,
+	HDMI_2880X480P_60HZ_4_3,	/*35*/
+	HDMI_2880X480P_60HZ_16_9,
+	HDMI_2880X576P_50HZ_4_3,
+	HDMI_2880X576P_50HZ_16_9,
+	HDMI_1920X1080I_50HZ_1250,	/* V Line 1250 total*/
+	HDMI_1920X1080I_100HZ,		/*40*/
+	HDMI_1280X720P_100HZ,
+	HDMI_720X576P_100HZ_4_3,
+	HDMI_720X576P_100HZ_16_9,
+	HDMI_720X576I_100HZ_4_3,
+	HDMI_720X576I_100HZ_16_9,	/*45*/
+	HDMI_1920X1080I_120HZ,
+	HDMI_1280X720P_120HZ,
+	HDMI_720X480P_120HZ_4_3,
+	HDMI_720X480P_120HZ_16_9,
+	HDMI_720X480I_120HZ_4_3,	/*50*/
+	HDMI_720X480I_120HZ_16_9,
+	HDMI_720X576P_200HZ_4_3,
+	HDMI_720X576P_200HZ_16_9,
+	HDMI_720X576I_200HZ_4_3,
+	HDMI_720X576I_200HZ_16_9,	/*55*/
+	HDMI_720X480P_240HZ_4_3,
+	HDMI_720X480P_240HZ_16_9,
+	HDMI_720X480I_240HZ_4_3,
+	HDMI_720X480I_240HZ_16_9,
+	HDMI_1280X720P_24HZ,		/*60*/
+	HDMI_1280X720P_25HZ,
+	HDMI_1280X720P_30HZ,
+	HDMI_1920X1080P_120HZ,
+	HDMI_1920X1080P_100HZ,
+	HDMI_1280X720P_24HZ_21_9,	/*65*/
+	HDMI_1280X720P_25HZ_21_9,
+	HDMI_1280X720P_30HZ_21_9,
+	HDMI_1280X720P_50HZ_21_9,
+	HDMI_1280X720P_60HZ_21_9,
+	HDMI_1280X720P_100HZ_21_9,	/*70*/
+	HDMI_1280X720P_120HZ_21_9,
+	HDMI_1920X1080P_24HZ_21_9,
+	HDMI_1920X1080P_25HZ_21_9,
+	HDMI_1920X1080P_30HZ_21_9,
+	HDMI_1920X1080P_50HZ_21_9,	/*75*/
+	HDMI_1920X1080P_60HZ_21_9,
+	HDMI_1920X1080P_100HZ_21_9,
+	HDMI_1920X1080P_120HZ_21_9,
+	HDMI_1680X720P_24HZ,
+	HDMI_1680X720P_25HZ,		/*80*/
+	HDMI_1680X720P_30HZ,
+	HDMI_1680X720P_50HZ,
+	HDMI_1680X720P_60HZ,
+	HDMI_1680X720P_100HZ,
+	HDMI_1680X720P_120HZ,		/*85*/
+	HDMI_2560X1080P_24HZ,
+	HDMI_2560X1080P_25HZ,
+	HDMI_2560X1080P_30HZ,
+	HDMI_2560X1080P_50HZ,
+	HDMI_2560X1080P_60HZ,		/*90*/
+	HDMI_2560X1080P_100HZ,
+	HDMI_2560X1080P_120HZ,
+	HDMI_3840X2160P_24HZ,
+	HDMI_3840X2160P_25HZ,
+	HDMI_3840X2160P_30HZ,		/*95*/
+	HDMI_3840X2160P_50HZ,
+	HDMI_3840X2160P_60HZ,
+	HDMI_4096X2160P_24HZ,
+	HDMI_4096X2160P_25HZ,
+	HDMI_4096X2160P_30HZ,		/*100*/
+	HDMI_4096X2160P_50HZ,
+	HDMI_4096X2160P_60HZ,
+	HDMI_3840X2160P_24HZ_21_9,
+	HDMI_3840X2160P_25HZ_21_9,
+	HDMI_3840X2160P_30HZ_21_9,	/*105*/
+	HDMI_3840X2160P_50HZ_21_9,
+	HDMI_3840X2160P_60HZ_21_9,
+};
+
+/* HDMI Extended Resolution */
+enum {
+	HDMI_VIC_4KX2K_30HZ = 1,
+	HDMI_VIC_4KX2K_25HZ,
+	HDMI_VIC_4KX2K_24HZ,
+	HDMI_VIC_4KX2K_24HZ_SMPTE
+};
+
+/* HDMI Video Format */
+enum {
+	HDMI_VIDEO_FORMAT_NORMAL = 0,
+	HDMI_VIDEO_FORMAT_4KX2K,
+	HDMI_VIDEO_FORMAT_3D,
+};
+
+/* HDMI 3D type */
+enum {
+	HDMI_3D_NONE = -1,
+	HDMI_3D_FRAME_PACKING = 0,
+	HDMI_3D_TOP_BOOTOM = 6,
+	HDMI_3D_SIDE_BY_SIDE_HALF = 8,
+};
+
+/* HDMI Video Data Color Mode */
+enum hdmi_video_color_mode {
+	HDMI_COLOR_AUTO	= 0,
+	HDMI_COLOR_RGB_0_255,
+	HDMI_COLOR_RGB_16_235,
+	HDMI_COLOR_YCBCR444,
+	HDMI_COLOR_YCBCR422,
+	HDMI_COLOR_YCBCR420
+};
+
+/* HDMI Video Data Color Depth */
+enum hdmi_deep_color {
+	HDMI_DEPP_COLOR_AUTO = 0,
+	HDMI_DEEP_COLOR_Y444 = 0x1,
+	HDMI_DEEP_COLOR_30BITS = 0x2,
+	HDMI_DEEP_COLOR_36BITS = 0x4,
+	HDMI_DEEP_COLOR_48BITS = 0x8,
+};
+
+enum hdmi_colorimetry {
+	HDMI_COLORIMETRY_NO_DATA = 0,
+	HDMI_COLORIMETRY_SMTPE_170M,
+	HDMI_COLORIMETRY_ITU709,
+	HDMI_COLORIMETRY_EXTEND_XVYCC_601,
+	HDMI_COLORIMETRY_EXTEND_XVYCC_709,
+	HDMI_COLORIMETRY_EXTEND_SYCC_601,
+	HDMI_COLORIMETRY_EXTEND_ADOBE_YCC601,
+	HDMI_COLORIMETRY_EXTEND_ADOBE_RGB,
+	HDMI_COLORIMETRY_EXTEND_BT_2020_YCC_C, /*constant luminance*/
+	HDMI_COLORIMETRY_EXTEND_BT_2020_YCC,
+	HDMI_COLORIMETRY_EXTEND_BT_2020_RGB,
+};
+
+/* HDMI Audio source */
+enum {
+	HDMI_AUDIO_SRC_IIS = 0,
+	HDMI_AUDIO_SRC_SPDIF
+};
+
+/* HDMI Audio Type */
+enum hdmi_audio_type {
+	HDMI_AUDIO_NLPCM = 0,
+	HDMI_AUDIO_LPCM = 1,
+	HDMI_AUDIO_AC3,
+	HDMI_AUDIO_MPEG1,
+	HDMI_AUDIO_MP3,
+	HDMI_AUDIO_MPEG2,
+	HDMI_AUDIO_AAC_LC,		/*AAC */
+	HDMI_AUDIO_DTS,
+	HDMI_AUDIO_ATARC,
+	HDMI_AUDIO_DSD,			/* One bit Audio */
+	HDMI_AUDIO_E_AC3,
+	HDMI_AUDIO_DTS_HD,
+	HDMI_AUDIO_MLP,
+	HDMI_AUDIO_DST,
+	HDMI_AUDIO_WMA_PRO
+};
+
+/* HDMI Audio Sample Rate */
+enum hdmi_audio_samplerate {
+	HDMI_AUDIO_FS_32000  = 0x1,
+	HDMI_AUDIO_FS_44100  = 0x2,
+	HDMI_AUDIO_FS_48000  = 0x4,
+	HDMI_AUDIO_FS_88200  = 0x8,
+	HDMI_AUDIO_FS_96000  = 0x10,
+	HDMI_AUDIO_FS_176400 = 0x20,
+	HDMI_AUDIO_FS_192000 = 0x40
+};
+
+/* HDMI Audio Word Length */
+enum hdmi_audio_word_length {
+	HDMI_AUDIO_WORD_LENGTH_16bit = 0x1,
+	HDMI_AUDIO_WORD_LENGTH_20bit = 0x2,
+	HDMI_AUDIO_WORD_LENGTH_24bit = 0x4
+};
+
+/* HDMI Hotplug Status */
+enum hdmi_hotpulg_status {
+	HDMI_HPD_REMOVED = 0,	/* HDMI is disconnected */
+	HDMI_HPD_INSERT,	/* HDMI is connected, but HDP is low
+				 * or TMDS link is not pull up to 3.3V.
+				 */
+	HDMI_HPD_ACTIVATED	/* HDMI is connected, all singnal
+				 * is normal
+				 */
+};
+
+enum hdmi_mute_status {
+	HDMI_AV_UNMUTE = 0,
+	HDMI_VIDEO_MUTE = 0x1,
+	HDMI_AUDIO_MUTE = 0x2,
+};
+
+/* HDMI Error Code */
+enum hdmi_error_code {
+	HDMI_ERROR_SUCCESS = 0,
+	HDMI_ERROR_FALSE,
+	HDMI_ERROR_I2C,
+	HDMI_ERROR_EDID,
+};
+
+/* HDMI Video Timing */
+struct hdmi_video_timing {
+	struct fb_videomode mode;	/* Video timing*/
+	unsigned int vic;		/* Video information code*/
+	unsigned int vic_2nd;
+	unsigned int pixelrepeat;	/* Video pixel repeat rate*/
+	unsigned int interface;		/* Video input interface*/
+};
+
+/* HDMI Video Parameters */
+struct hdmi_video {
+	unsigned int vic;		/* Video information code*/
+	unsigned int color_input;	/* Input video color mode*/
+	unsigned int color_output;	/* Output video color mode*/
+	unsigned int color_output_depth;/* Output video Color Depth*/
+	unsigned int colorimetry;	/* Output Colorimetry */
+	unsigned int sink_hdmi;		/* Output signal is DVI or HDMI*/
+	unsigned int format_3d;		/* Output 3D mode*/
+	unsigned int eotf;		/* EOTF */
+};
+
+/* HDMI Audio Parameters */
+struct hdmi_audio {
+	u32	type;			/*Audio type*/
+	u32	channel;		/*Audio channel number*/
+	u32	rate;			/*Audio sampling rate*/
+	u32	word_length;		/*Audio data word length*/
+};
+
+enum hdmi_hdr_eotf {
+	EOTF_TRADITIONAL_GMMA_SDR = 1,
+	EOFT_TRADITIONAL_GMMA_HDR = 2,
+	EOTF_ST_2084 = 4,
+};
+
+struct hdmi_hdr_metadata {
+	u32	prim_x0;
+	u32	prim_y0;
+	u32	prim_x1;
+	u32	prim_y1;
+	u32	prim_x2;
+	u32	prim_y2;
+	u32	white_px;
+	u32	white_py;
+	u32	max_dml;
+	u32	min_dml;
+	u32	max_cll;		/*max content light level*/
+	u32	max_fall;		/*max frame-average light level*/
+};
+
+struct hdmi_hdr {
+	u8	eotf;
+	u8	metadata;	/*Staic Metadata Descriptor*/
+	u8	maxluminance;
+	u8	max_average_luminance;
+	u8	minluminance;
+};
+
+#define HDMI_MAX_EDID_BLOCK		8
+
+struct edid_prop_value {
+	int vid;
+	int pid;
+	int sn;
+	int xres;
+	int yres;
+	int vic;
+	int width;
+	int height;
+	int x_w;
+	int x_h;
+	int hwrotation;
+	int einit;
+	int vsync;
+	int panel;
+	int scan;
+};
+
+struct edid_prop_data {
+	struct edid_prop_value value;
+
+	int valid;
+	int last_vid;
+	int last_pid;
+	int last_sn;
+	int last_xres;
+	int last_yres;
+};
+
+/* HDMI EDID Information */
+struct hdmi_edid {
+	unsigned char sink_hdmi;	/* HDMI display device flag */
+	unsigned char ycbcr444;		/* Display device support YCbCr444 */
+	unsigned char ycbcr422;		/* Display device support YCbCr422 */
+	unsigned char ycbcr420;		/* Display device support YCbCr420 */
+	unsigned char deepcolor;	/* bit3:DC_48bit; bit2:DC_36bit;
+					 * bit1:DC_30bit; bit0:DC_Y444;
+					 */
+	unsigned char deepcolor_420;
+	unsigned int  cecaddress;	/* CEC physical address */
+	unsigned int  maxtmdsclock;	/* Max supported tmds clock */
+	unsigned char fields_present;	/* bit7: latency
+					 * bit6: i_lantency
+					 * bit5: hdmi_video
+					 */
+	unsigned char video_latency;
+	unsigned char audio_latency;
+	unsigned char interlaced_video_latency;
+	unsigned char interlaced_audio_latency;
+	/* for hdmi 2.0 */
+	unsigned char hf_vsdb_version;
+	unsigned char scdc_present;
+	unsigned char rr_capable;
+	unsigned char lte_340mcsc_scramble;
+	unsigned char independent_view;
+	unsigned char dual_view;
+	unsigned char osd_disparity_3d;
+
+	struct edid_prop_value value;
+
+	unsigned int colorimetry;
+	struct fb_monspecs	*specs;	/*Device spec*/
+	struct list_head modelist;	/*Device supported display mode list*/
+	unsigned char baseaudio_support;
+	struct hdmi_audio *audio;	/*Device supported audio info*/
+	unsigned int  audio_num;	/*Device supported audio type number*/
+
+	unsigned int status;		/*EDID read status, success or failed*/
+	u8 *raw[HDMI_MAX_EDID_BLOCK];	/*Raw EDID Data*/
+	union {
+		u8	data[5];
+		struct hdmi_hdr hdrinfo;
+	} hdr;
+};
+
+struct hdmi;
+
+struct hdmi_ops {
+	int (*enable)(struct hdmi *);
+	int (*disable)(struct hdmi *);
+	int (*getstatus)(struct hdmi *);
+	int (*insert)(struct hdmi *);
+	int (*remove)(struct hdmi *);
+	int (*getedid)(struct hdmi *, int, unsigned char *);
+	int (*setvideo)(struct hdmi *, struct hdmi_video *);
+	int (*setaudio)(struct hdmi *, struct hdmi_audio *);
+	int (*setmute)(struct hdmi *, int);
+	int (*setvsi)(struct hdmi *, unsigned char, unsigned char);
+	int (*setcec)(struct hdmi *);
+	void (*sethdr)(struct hdmi *, int, struct hdmi_hdr_metadata *);
+	void (*setavi)(struct hdmi *, struct hdmi_video *);
+	/* call back for hdcp operatoion */
+	void (*hdcp_cb)(struct hdmi *);
+	void (*hdcp_auth2nd)(struct hdmi *);
+	void (*hdcp_irq_cb)(int);
+	int (*hdcp_power_on_cb)(void);
+	void (*hdcp_power_off_cb)(struct hdmi *);
+};
+
+enum rk_hdmi_feature {
+	SUPPORT_480I_576I	=	(1 << 0),
+	SUPPORT_1080I		=	(1 << 1),
+	SUPPORT_DEEP_10BIT	=	(1 << 2),
+	SUPPORT_DEEP_12BIT	=	(1 << 3),
+	SUPPORT_DEEP_16BIT	=	(1 << 4),
+	SUPPORT_4K		=	(1 << 5),
+	SUPPORT_4K_4096		=	(1 << 6),
+	SUPPORT_TMDS_600M	=	(1 << 7),
+	SUPPORT_YUV420		=	(1 << 8),
+	SUPPORT_CEC		=	(1 << 9),
+	SUPPORT_HDCP		=	(1 << 10),
+	SUPPORT_HDCP2		=	(1 << 11),
+	SUPPORT_YCBCR_INPUT	=	(1 << 12),
+	SUPPORT_VESA_DMT	=	(1 << 13),
+	SUPPORT_RK_DISCRETE_VR	=	(1 << 14)
+};
+
+struct hdmi_property {
+	char *name;
+	int videosrc;
+	int display;
+	int feature;
+	int defaultmode;
+	int defaultdepth;
+	void *priv;
+};
+
+enum {
+	HDMI_SOC_RK3036 = 0,
+	HDMI_SOC_RK312X,
+	HDMI_SOC_RK322X,
+	HDMI_SOC_RK3288,
+	HDMI_SOC_RK3366,
+	HDMI_SOC_RK3368,
+	HDMI_SOC_RK3399,
+};
+
+/* HDMI Information */
+struct hdmi {
+	int id;					/*HDMI id*/
+	int soctype;
+	struct device	*dev;			/*HDMI device*/
+	struct rk_lcdc_driver *lcdc;		/*HDMI linked lcdc*/
+	struct rk_display_device *ddev;		/*Registered display device*/
+	#ifdef CONFIG_SWITCH
+	struct switch_dev	switchdev;	/*Registered switch device*/
+	#endif
+
+	struct hdmi_property *property;
+	struct hdmi_ops *ops;
+
+	struct mutex lock;			/* mutex for hdmi operation */
+	struct mutex pclk_lock;			/* mutex for pclk operation */
+	struct workqueue_struct *workqueue;
+
+	bool uboot;	/* if true, HDMI is initialized in uboot*/
+
+	int hotplug;	/* hot plug status*/
+	int autoset;	/* if true, auto set hdmi output mode according EDID.*/
+	int mute;	/* HDMI display status:
+			 * 2 - mute audio,
+			 * 1 - mute display;
+			 * 0 - unmute
+			 */
+	int colordepth;			/* Output color depth*/
+	int colormode;			/* Output color mode*/
+	int colorimetry;		/* Output colorimetry */
+	struct hdmi_edid edid;		/* EDID information*/
+	struct edid_prop_data prop;	/* Property for dp */
+	struct edid_prop_value *pvalue;
+	int nstates;
+	int edid_auto_support;		/* Auto dp enable flag */
+
+	int enable;			/* Enable flag*/
+	int sleep;			/* Sleep flag*/
+	int vic;			/* HDMI output video information code*/
+	int mode_3d;			/* HDMI output video 3d mode*/
+	int eotf;			/* HDMI HDR EOTF */
+	struct hdmi_hdr_metadata hdr;	/* HDMI HDR MedeData */
+	struct hdmi_audio audio;	/* HDMI output audio information.*/
+	struct hdmi_video video;	/* HDMI output video information.*/
+	int xscale;
+	int yscale;
+};
+
+/* HDMI EDID Block Size */
+#define HDMI_EDID_BLOCK_SIZE	128
+
+/* SCDC Registers */
+#define SCDC_SINK_VER		0x01	/* sink version		*/
+#define SCDC_SOURCE_VER		0x02	/* source version	*/
+#define SCDC_UPDATE_0		0x10	/* Update_0		*/
+#define SCDC_UPDATE_1		0x11	/* Update_1		*/
+#define SCDC_UPDATE_RESERVED	0x12	/* 0x12-0x1f - Reserved */
+#define SCDC_TMDS_CONFIG	0x20	/* TMDS_Config   */
+#define SCDC_SCRAMBLER_STAT	0x21	/* Scrambler_Status   */
+#define SCDC_CONFIG_0		0x30	/* Config_0           */
+#define SCDC_CONFIG_RESERVED	0x31	/* 0x31-0x3f - Reserved */
+#define SCDC_STATUS_FLAG_0	0x40	/* Status_Flag_0        */
+#define SCDC_STATUS_FLAG_1	0x41	/* Status_Flag_1        */
+#define SCDC_STATUS_RESERVED	0x42	/* 0x42-0x4f - Reserved */
+#define SCDC_ERR_DET_0_L	0x50	/* Err_Det_0_L          */
+#define SCDC_ERR_DET_0_H	0x51	/* Err_Det_0_H          */
+#define SCDC_ERR_DET_1_L	0x52	/* Err_Det_1_L          */
+#define SCDC_ERR_DET_1_H	0x53	/* Err_Det_1_H          */
+#define SCDC_ERR_DET_2_L	0x54	/* Err_Det_2_L          */
+#define SCDC_ERR_DET_2_H	0x55	/* Err_Det_2_H          */
+#define SCDC_ERR_DET_CHKSUM	0x56	/* Err_Det_Checksum     */
+#define SCDC_TEST_CFG_0		0xc0	/* Test_config_0        */
+#define SCDC_TEST_RESERVED	0xc1	/* 0xc1-0xcf		*/
+#define SCDC_MAN_OUI_3RD	0xd0	/* Manufacturer IEEE OUI,
+					 * Third Octet
+					 */
+#define SCDC_MAN_OUI_2ND	0xd1	/* Manufacturer IEEE OUI,
+					 * Second Octet
+					 */
+#define SCDC_MAN_OUI_1ST	0xd2	/* Manufacturer IEEE OUI,
+					 * First Octet
+					 */
+#define SCDC_DEVICE_ID		0xd3	/* 0xd3-0xdd - Device ID            */
+#define SCDC_MAN_SPECIFIC	0xde	/* 0xde-0xff - ManufacturerSpecific */
+
+/* Event source */
+#define HDMI_SRC_SHIFT		8
+#define HDMI_SYSFS_SRC		(0x1 << HDMI_SRC_SHIFT)
+#define HDMI_SUSPEND_SRC	(0x2 << HDMI_SRC_SHIFT)
+#define HDMI_IRQ_SRC		(0x4 << HDMI_SRC_SHIFT)
+#define HDMI_WORKQUEUE_SRC	(0x8 << HDMI_SRC_SHIFT)
+
+/* Event */
+#define HDMI_ENABLE_CTL			(HDMI_SYSFS_SRC		| 0)
+#define HDMI_DISABLE_CTL		(HDMI_SYSFS_SRC		| 1)
+#define HDMI_SUSPEND_CTL		(HDMI_SUSPEND_SRC	| 2)
+#define HDMI_RESUME_CTL			(HDMI_SUSPEND_SRC	| 3)
+#define HDMI_HPD_CHANGE			(HDMI_IRQ_SRC		| 4)
+#define HDMI_SET_VIDEO			(HDMI_SYSFS_SRC		| 5)
+#define HDMI_SET_AUDIO			(HDMI_SYSFS_SRC		| 6)
+#define HDMI_SET_3D			(HDMI_SYSFS_SRC		| 7)
+#define HDMI_MUTE_AUDIO			(HDMI_SYSFS_SRC		| 8)
+#define HDMI_UNMUTE_AUDIO		(HDMI_SYSFS_SRC		| 9)
+#define HDMI_SET_COLOR			(HDMI_SYSFS_SRC		| 10)
+#define HDMI_ENABLE_HDCP		(HDMI_SYSFS_SRC		| 11)
+#define HDMI_HDCP_AUTH_2ND		(HDMI_IRQ_SRC		| 12)
+#define HDMI_SET_HDR			(HDMI_SYSFS_SRC		| 13)
+
+#define HDMI_DEFAULT_SCALE		95
+#define HDMI_AUTO_CONFIG		false
+
+/* HDMI default vide mode */
+#define HDMI_VIDEO_DEFAULT_MODE			HDMI_1280X720P_60HZ
+						/*HDMI_1920X1080P_60HZ*/
+#define HDMI_VIDEO_DEFAULT_COLORMODE		HDMI_COLOR_AUTO
+#define HDMI_VIDEO_DEFAULT_COLORDEPTH		8
+
+/* HDMI default audio parameter */
+#define HDMI_AUDIO_DEFAULT_TYPE			HDMI_AUDIO_LPCM
+#define HDMI_AUDIO_DEFAULT_CHANNEL		2
+#define HDMI_AUDIO_DEFAULT_RATE			HDMI_AUDIO_FS_44100
+#define HDMI_AUDIO_DEFAULT_WORDLENGTH	HDMI_AUDIO_WORD_LENGTH_16bit
+
+extern int hdmi_dbg_level;
+#define HDMIDBG(x, format, ...) do {			\
+	if (unlikely(hdmi_dbg_level >= x))	\
+		pr_info(format, ## __VA_ARGS__); \
+			} while (0)
+
+struct hdmi *rockchip_hdmi_register(struct hdmi_property *property,
+				    struct hdmi_ops *ops);
+void rockchip_hdmi_unregister(struct hdmi *hdmi);
+void hdmi_submit_work(struct hdmi *hdmi,
+		      int event, int delay, int sync);
+
+struct rk_display_device *hdmi_register_display_sysfs(struct hdmi *hdmi,
+						      struct device *parent);
+void hdmi_unregister_display_sysfs(struct hdmi *hdmi);
+
+int hdmi_edid_parse_base(struct hdmi *hdmi, unsigned char *buf,
+			 int *extend_num, struct hdmi_edid *pedid);
+int hdmi_edid_parse_extensions(unsigned char *buf,
+			       struct hdmi_edid *pedid);
+
+void hdmi_init_modelist(struct hdmi *hdmi);
+int hdmi_set_lcdc(struct hdmi *hdmi);
+int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok);
+int hdmi_add_vic(int vic, struct list_head *head);
+int hdmi_find_best_mode(struct hdmi *hdmi, int vic);
+int hdmi_videomode_to_vic(struct fb_videomode *vmode);
+const struct fb_videomode *hdmi_vic_to_videomode(int vic);
+const struct hdmi_video_timing *hdmi_vic2timing(int vic);
+int hdmi_config_audio(struct hdmi_audio *audio);
+int hdmi_get_hotplug(void);
+int snd_config_hdmi_audio(struct snd_pcm_hw_params *params);
+#endif
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1597 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include "rockchip-hdmi.h"
+
+static const struct hdmi_video_timing hdmi_mode[] = {
+	{
+		.mode = {
+			.name = "720x480i@60Hz",
+			.refresh = 60,
+			.xres = 720,
+			.yres = 480,
+			.pixclock = 27000000,
+			.left_margin = 57,
+			.right_margin = 19,
+			.upper_margin = 15,
+			.lower_margin = 4,
+			.hsync_len = 62,
+			.vsync_len = 3,
+			.sync = 0,
+			.vmode = FB_VMODE_INTERLACED,
+			.flag = 0,
+		},
+		.vic = HDMI_720X480I_60HZ_4_3,
+		.vic_2nd = HDMI_720X480I_60HZ_16_9,
+		.pixelrepeat = 2,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "720x576i@50Hz",
+			.refresh = 50,
+			.xres = 720,
+			.yres = 576,
+			.pixclock = 27000000,
+			.left_margin = 69,
+			.right_margin = 12,
+			.upper_margin = 19,
+			.lower_margin = 2,
+			.hsync_len = 63,
+			.vsync_len = 3,
+			.sync = 0,
+			.vmode = FB_VMODE_INTERLACED,
+			.flag = 0,
+		},
+		.vic = HDMI_720X576I_50HZ_4_3,
+		.vic_2nd = HDMI_720X576I_50HZ_16_9,
+		.pixelrepeat = 2,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "720x480p@60Hz",
+			.refresh = 60,
+			.xres = 720,
+			.yres = 480,
+			.pixclock = 27000000,
+			.left_margin = 60,
+			.right_margin = 16,
+			.upper_margin = 30,
+			.lower_margin = 9,
+			.hsync_len = 62,
+			.vsync_len = 6,
+			.sync = 0,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_720X480P_60HZ_4_3,
+		.vic_2nd = HDMI_720X480P_60HZ_16_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "720x576p@50Hz",
+			.refresh = 50,
+			.xres = 720,
+			.yres = 576,
+			.pixclock = 27000000,
+			.left_margin = 68,
+			.right_margin = 12,
+			.upper_margin = 39,
+			.lower_margin = 5,
+			.hsync_len = 64,
+			.vsync_len = 5,
+			.sync = 0,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_720X576P_50HZ_4_3,
+		.vic_2nd = HDMI_720X576P_50HZ_16_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1280x720p@24Hz",
+			.refresh = 24,
+			.xres = 1280,
+			.yres = 720,
+			.pixclock = 59400000,
+			.left_margin = 220,
+			.right_margin = 1760,
+			.upper_margin = 20,
+			.lower_margin = 5,
+			.hsync_len = 40,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1280X720P_24HZ,
+		.vic_2nd = HDMI_1280X720P_24HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1280x720p@25Hz",
+			.refresh = 25,
+			.xres = 1280,
+			.yres = 720,
+			.pixclock = 74250000,
+			.left_margin = 220,
+			.right_margin = 2420,
+			.upper_margin = 20,
+			.lower_margin = 5,
+			.hsync_len = 40,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1280X720P_25HZ,
+		.vic_2nd = HDMI_1280X720P_25HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1280x720p@30Hz",
+			.refresh = 30,
+			.xres = 1280,
+			.yres = 720,
+			.pixclock = 74250000,
+			.left_margin = 220,
+			.right_margin = 1760,
+			.upper_margin = 20,
+			.lower_margin = 5,
+			.hsync_len = 40,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1280X720P_30HZ,
+		.vic_2nd = HDMI_1280X720P_30HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1280x720p@50Hz",
+			.refresh = 50,
+			.xres = 1280,
+			.yres = 720,
+			.pixclock = 74250000,
+			.left_margin = 220,
+			.right_margin = 440,
+			.upper_margin = 20,
+			.lower_margin = 5,
+			.hsync_len = 40,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1280X720P_50HZ,
+		.vic_2nd = HDMI_1280X720P_50HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1280x720p@60Hz",
+			.refresh = 60,
+			.xres = 1280,
+			.yres = 720,
+			.pixclock = 74250000,
+			.left_margin = 220,
+			.right_margin = 110,
+			.upper_margin = 20,
+			.lower_margin = 5,
+			.hsync_len = 40,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1280X720P_60HZ,
+		.vic_2nd = HDMI_1280X720P_60HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1920x1080i@50Hz",
+			.refresh = 50,
+			.xres = 1920,
+			.yres = 1080,
+			.pixclock = 74250000,
+			.left_margin = 148,
+			.right_margin = 528,
+			.upper_margin = 15,
+			.lower_margin = 2,
+			.hsync_len = 44,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = FB_VMODE_INTERLACED,
+			.flag = 0,
+		},
+		.vic = HDMI_1920X1080I_50HZ,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1920x1080i@60Hz",
+			.refresh = 60,
+			.xres = 1920,
+			.yres = 1080,
+			.pixclock = 74250000,
+			.left_margin = 148,
+			.right_margin = 88,
+			.upper_margin = 15,
+			.lower_margin = 2,
+			.hsync_len = 44,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = FB_VMODE_INTERLACED,
+			.flag = 0,
+		},
+		.vic = HDMI_1920X1080I_60HZ,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1920x1080p@24Hz",
+			.refresh = 24,
+			.xres = 1920,
+			.yres = 1080,
+			.pixclock = 74250000,
+			.left_margin = 148,
+			.right_margin = 638,
+			.upper_margin = 36,
+			.lower_margin = 4,
+			.hsync_len = 44,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1920X1080P_24HZ,
+		.vic_2nd = HDMI_1920X1080P_24HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1920x1080p@25Hz",
+			.refresh = 25,
+			.xres = 1920,
+			.yres = 1080,
+			.pixclock = 74250000,
+			.left_margin = 148,
+			.right_margin = 528,
+			.upper_margin = 36,
+			.lower_margin = 4,
+			.hsync_len = 44,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1920X1080P_25HZ,
+		.vic_2nd = HDMI_1920X1080P_25HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1920x1080p@30Hz",
+			.refresh = 30,
+			.xres = 1920,
+			.yres = 1080,
+			.pixclock = 74250000,
+			.left_margin = 148,
+			.right_margin = 88,
+			.upper_margin = 36,
+			.lower_margin = 4,
+			.hsync_len = 44,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1920X1080P_30HZ,
+		.vic_2nd = HDMI_1920X1080P_30HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1920x1080p@50Hz",
+			.refresh = 50,
+			.xres = 1920,
+			.yres = 1080,
+			.pixclock = 148500000,
+			.left_margin = 148,
+			.right_margin = 528,
+			.upper_margin = 36,
+			.lower_margin = 4,
+			.hsync_len = 44,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1920X1080P_50HZ,
+		.vic_2nd = HDMI_1920X1080P_50HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1920x1080p@60Hz",
+			.refresh = 60,
+			.xres = 1920,
+			.yres = 1080,
+			.pixclock = 148500000,
+			.left_margin = 148,
+			.right_margin = 88,
+			.upper_margin = 36,
+			.lower_margin = 4,
+			.hsync_len = 44,
+			.vsync_len = 5,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_1920X1080P_60HZ,
+		.vic_2nd = HDMI_1920X1080P_60HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "3840x2160p@24Hz",
+			.refresh = 24,
+			.xres = 3840,
+			.yres = 2160,
+			.pixclock = 297000000,
+			.left_margin = 296,
+			.right_margin = 1276,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_3840X2160P_24HZ,
+		.vic_2nd = HDMI_3840X2160P_24HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "3840x2160p@25Hz",
+			.refresh = 25,
+			.xres = 3840,
+			.yres = 2160,
+			.pixclock = 297000000,
+			.left_margin = 296,
+			.right_margin = 1056,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_3840X2160P_25HZ,
+		.vic_2nd = HDMI_3840X2160P_25HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "3840x2160p@30Hz",
+			.refresh = 30,
+			.xres = 3840,
+			.yres = 2160,
+			.pixclock = 297000000,
+			.left_margin = 296,
+			.right_margin = 176,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_3840X2160P_30HZ,
+		.vic_2nd = HDMI_3840X2160P_30HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "4096x2160p@24Hz",
+			.refresh = 24,
+			.xres = 4096,
+			.yres = 2160,
+			.pixclock = 297000000,
+			.left_margin = 296,
+			.right_margin = 1020,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_4096X2160P_24HZ,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "4096x2160p@25Hz",
+			.refresh = 25,
+			.xres = 4096,
+			.yres = 2160,
+			.pixclock = 297000000,
+			.left_margin = 128,
+			.right_margin = 968,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_4096X2160P_25HZ,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "4096x2160p@30Hz",
+			.refresh = 30,
+			.xres = 4096,
+			.yres = 2160,
+			.pixclock = 297000000,
+			.left_margin = 128,
+			.right_margin = 88,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_4096X2160P_30HZ,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "3840x2160p@50Hz",
+			.refresh = 50,
+			.xres = 3840,
+			.yres = 2160,
+			.pixclock = 594000000,
+			.left_margin = 296,
+			.right_margin = 1056,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_3840X2160P_50HZ,
+		.vic_2nd = HDMI_3840X2160P_50HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "3840x2160p@60Hz",
+			.refresh = 60,
+			.xres = 3840,
+			.yres = 2160,
+			.pixclock = 594000000,
+			.left_margin = 296,
+			.right_margin = 176,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_3840X2160P_60HZ,
+		.vic_2nd = HDMI_3840X2160P_60HZ_21_9,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "4096x2160p@50Hz",
+			.refresh = 50,
+			.xres = 4096,
+			.yres = 2160,
+			.pixclock = 594000000,
+			.left_margin = 128,
+			.right_margin = 968,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_4096X2160P_50HZ,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "4096x2160p@60Hz",
+			.refresh = 60,
+			.xres = 4096,
+			.yres = 2160,
+			.pixclock = 594000000,
+			.left_margin = 128,
+			.right_margin = 88,
+			.upper_margin = 72,
+			.lower_margin = 8,
+			.hsync_len = 88,
+			.vsync_len = 10,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_4096X2160P_60HZ,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "800x600p@60Hz",
+			.refresh = 60,
+			.xres = 800,
+			.yres = 600,
+			.pixclock = 40000000,
+			.left_margin = 88,
+			.right_margin = 40,
+			.upper_margin = 23,
+			.lower_margin = 1,
+			.hsync_len = 128,
+			.vsync_len = 4,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 1,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1024x768p@60Hz",
+			.refresh = 60,
+			.xres = 1024,
+			.yres = 768,
+			.pixclock = 65000000,
+			.left_margin = 160,
+			.right_margin = 24,
+			.upper_margin = 29,
+			.lower_margin = 3,
+			.hsync_len = 136,
+			.vsync_len = 6,
+			.sync = 0,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 2,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1280x960p@60Hz",
+			.refresh = 60,
+			.xres = 1280,
+			.yres = 960,
+			.pixclock = 108000000,
+			.left_margin = 312,
+			.right_margin = 96,
+			.upper_margin = 36,
+			.lower_margin = 1,
+			.hsync_len = 112,
+			.vsync_len = 3,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 3,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1280x1024p@60Hz",
+			.refresh = 60,
+			.xres = 1280,
+			.yres = 1024,
+			.pixclock = 108000000,
+			.left_margin = 248,
+			.right_margin = 48,
+			.upper_margin = 38,
+			.lower_margin = 1,
+			.hsync_len = 112,
+			.vsync_len = 3,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 4,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1360x768p@60Hz",
+			.refresh = 60,
+			.xres = 1360,
+			.yres = 768,
+			.pixclock = 85500000,
+			.left_margin = 256,
+			.right_margin = 64,
+			.upper_margin = 18,
+			.lower_margin = 3,
+			.hsync_len = 112,
+			.vsync_len = 6,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 5,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1366x768p@60Hz",
+			.refresh = 60,
+			.xres = 1366,
+			.yres = 768,
+			.pixclock = 85500000,
+			.left_margin = 213,
+			.right_margin = 70,
+			.upper_margin = 24,
+			.lower_margin = 3,
+			.hsync_len = 143,
+			.vsync_len = 3,
+			.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 6,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1440x900p@60Hz",
+			.refresh = 60,
+			.xres = 1440,
+			.yres = 900,
+			.pixclock = 106500000,
+			.left_margin = 232,
+			.right_margin = 80,
+			.upper_margin = 25,
+			.lower_margin = 3,
+			.hsync_len = 152,
+			.vsync_len = 6,
+			.sync = FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 7,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1600x900p@60Hz",
+			.refresh = 60,
+			.xres = 1600,
+			.yres = 900,
+			.pixclock = 108000000,
+			.left_margin = 96,
+			.right_margin = 24,
+			.upper_margin = 96,
+			.lower_margin = 1,
+			.hsync_len = 80,
+			.vsync_len = 3,
+			.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 8,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1680x1050@60Hz",
+			.refresh = 60,
+			.xres = 1680,
+			.yres = 1050,
+			.pixclock = 146250000,
+			.left_margin = 280,
+			.right_margin = 104,
+			.upper_margin = 30,
+			.lower_margin = 3,
+			.hsync_len = 176,
+			.vsync_len = 6,
+			.sync = FB_SYNC_VERT_HIGH_ACT,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DMT | 9,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		.mode = {
+			.name = "1440x1280@60Hz",
+			.refresh = 60,
+			.xres = 1440,
+			.yres = 1280,
+			.pixclock = 148500000,
+			.left_margin = 84,
+			.right_margin = 360,
+			.upper_margin = 8,
+			.lower_margin = 10,
+			.hsync_len = 20,
+			.vsync_len = 2,
+			.sync = 0,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DISCRETE_VR | 1,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		/* AUO 3.81 */
+		.mode = {
+			.name = "2160x1200@75Hz",
+			.refresh = 75,
+			.xres = 2160,
+			.yres = 1200,
+			.pixclock = 245000000,
+			.left_margin = 100,
+			.right_margin = 420,
+			.upper_margin = 3,
+			.lower_margin = 6,
+			.hsync_len = 32,
+			.vsync_len = 3,
+			.sync = 0,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DISCRETE_VR | 3,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		/* sharp 2.89 */
+		.mode = {
+			.name = "2880x1440@75Hz",
+			.refresh = 75,
+			.xres = 2880,
+			.yres = 1440,
+			.pixclock = 340000000,
+			.left_margin = 100,
+			.right_margin = 50,
+			.upper_margin = 8,
+			.lower_margin = 6,
+			.hsync_len = 50,
+			.vsync_len = 1,
+			.sync = 0,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DISCRETE_VR | 4,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		/* RAYKEN 5.46 */
+		.mode = {
+			.name = "1440x2560@60Hz",
+			.refresh = 60,
+			.xres = 1440,
+			.yres = 2560,
+			.pixclock = 268500000,
+			.left_margin = 50,
+			.right_margin = 200,
+			.upper_margin = 20,
+			.lower_margin = 20,
+			.hsync_len = 20,
+			.vsync_len = 10,
+			.sync = 0,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DISCRETE_VR | 5,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+	{
+		/* samsung */
+		.mode = {
+			.name = "1440x2560@70Hz",
+			.refresh = 70,
+			.xres = 1440,
+			.yres = 2560,
+			.pixclock = 285000000,
+			.left_margin = 40,
+			.right_margin = 80,
+			.upper_margin = 2,
+			.lower_margin = 6,
+			.hsync_len = 20,
+			.vsync_len = 8,
+			.sync = 0,
+			.vmode = 0,
+			.flag = 0,
+		},
+		.vic = HDMI_VIDEO_DISCRETE_VR | 6,
+		.vic_2nd = 0,
+		.pixelrepeat = 1,
+		.interface = OUT_P888,
+	},
+};
+
+static int hdmi_set_info(struct rk_screen *screen, struct hdmi *hdmi)
+{
+	int i, vic, colorimetry;
+	struct fb_videomode *mode;
+
+	if (!screen || !hdmi)
+		return HDMI_ERROR_FALSE;
+
+	if (hdmi->vic == 0)
+		hdmi->vic = hdmi->property->defaultmode;
+
+	if (hdmi->edid_auto_support) {
+		if ((hdmi->vic & HDMI_VIDEO_DMT) ||
+		    (hdmi->vic & HDMI_VIDEO_DISCRETE_VR)) {
+			if (hdmi->prop.value.vic)
+				vic = hdmi->prop.value.vic;
+			else
+				vic = hdmi->vic;
+		} else {
+			vic = hdmi->vic & HDMI_VIC_MASK;
+		}
+	} else {
+		if ((hdmi->vic & HDMI_VIDEO_DMT) ||
+		    (hdmi->vic & HDMI_VIDEO_DISCRETE_VR))
+			vic = hdmi->vic;
+		else
+			vic = hdmi->vic & HDMI_VIC_MASK;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+		if (hdmi_mode[i].vic == vic ||
+		    hdmi_mode[i].vic_2nd == vic)
+			break;
+	}
+	if (i == ARRAY_SIZE(hdmi_mode))
+		return HDMI_ERROR_FALSE;
+
+	memset(screen, 0, sizeof(struct rk_screen));
+
+	/* screen type & face */
+	screen->type = SCREEN_HDMI;
+	colorimetry = hdmi->video.colorimetry;
+	mode = (struct fb_videomode *)&hdmi_mode[i].mode;
+	if (hdmi->video.color_input == HDMI_COLOR_RGB_0_255) {
+		screen->color_mode = COLOR_RGB;
+	} else if (colorimetry > HDMI_COLORIMETRY_EXTEND_ADOBE_RGB) {
+		screen->color_mode = COLOR_YCBCR_BT2020;
+		if (hdmi->video.eotf == EOTF_ST_2084)
+			screen->data_space = 1;
+	} else if (colorimetry == HDMI_COLORIMETRY_NO_DATA) {
+		if (mode->xres > 720 && mode->yres > 576)
+			screen->color_mode = COLOR_YCBCR_BT709;
+		else
+			screen->color_mode = COLOR_YCBCR;
+	} else if (colorimetry == HDMI_COLORIMETRY_SMTPE_170M) {
+		screen->color_mode = COLOR_YCBCR;
+	} else {
+		screen->color_mode = COLOR_YCBCR_BT709;
+	}
+
+	if (hdmi->vic & HDMI_VIDEO_YUV420) {
+		if (hdmi->video.color_output_depth == 10)
+			screen->face = OUT_YUV_420_10BIT;
+		else
+			screen->face = OUT_YUV_420;
+	} else {
+		if (hdmi->video.color_output_depth == 10)
+			screen->face = OUT_P101010;
+		else
+			screen->face = hdmi_mode[i].interface;
+	}
+	screen->pixelrepeat = hdmi_mode[i].pixelrepeat - 1;
+	screen->mode = *mode;
+	if (hdmi->video.format_3d == HDMI_3D_FRAME_PACKING) {
+		screen->mode.pixclock = 2 * mode->pixclock;
+		if (mode->vmode == 0) {
+			screen->mode.yres = 2 * mode->yres +
+					mode->upper_margin +
+					mode->lower_margin +
+					mode->vsync_len;
+		} else {
+			screen->mode.yres = 2 * mode->yres +
+					    3 * (mode->upper_margin +
+						 mode->lower_margin +
+						 mode->vsync_len) + 2;
+			screen->mode.vmode = 0;
+		}
+	}
+	/* Pin polarity */
+	if (FB_SYNC_HOR_HIGH_ACT & mode->sync)
+		screen->pin_hsync = 1;
+	else
+		screen->pin_hsync = 0;
+	if (FB_SYNC_VERT_HIGH_ACT & mode->sync)
+		screen->pin_vsync = 1;
+	else
+		screen->pin_vsync = 0;
+
+	screen->pin_den = 0;
+	screen->pin_dclk = 1;
+
+	/* Swap rule */
+	if (hdmi->soctype > HDMI_SOC_RK312X &&
+	    screen->color_mode > COLOR_RGB &&
+	    (screen->face == OUT_P888 ||
+	     screen->face == OUT_P101010))
+		screen->swap_rb = 1;
+	else
+		screen->swap_rb = 0;
+	screen->swap_rg = 0;
+	screen->swap_gb = 0;
+	screen->swap_delta = 0;
+	screen->swap_dumy = 0;
+
+	/* Operation function*/
+	screen->init = NULL;
+	screen->standby = NULL;
+
+	screen->overscan.left = hdmi->xscale;
+	screen->overscan.top = hdmi->yscale;
+	screen->overscan.right = hdmi->xscale;
+	screen->overscan.bottom = hdmi->yscale;
+
+	screen->width = hdmi->prop.value.width;
+	screen->height = hdmi->prop.value.height;
+	pr_info("%s:line=%d %d %d %d %d %d %d %d %d\n",
+		__func__, __LINE__, screen->mode.xres, screen->mode.yres,
+		screen->mode.left_margin, screen->mode.right_margin,
+		screen->mode.upper_margin, screen->mode.lower_margin,
+		screen->mode.hsync_len, screen->mode.vsync_len);
+
+	return 0;
+}
+
+/**
+ * hdmi_find_best_mode: find the video mode nearest to input vic
+ * @hdmi:
+ * @vic: input vic
+ *
+ * NOTES:
+ * If vic is zero, return the high resolution video mode vic.
+ */
+int hdmi_find_best_mode(struct hdmi *hdmi, int vic)
+{
+	struct list_head *pos, *head = &hdmi->edid.modelist;
+	struct display_modelist *modelist = NULL;
+	int found = 0;
+
+	if (vic) {
+		list_for_each(pos, head) {
+			modelist =
+				list_entry(pos,
+					   struct display_modelist, list);
+			if (modelist->vic == vic) {
+				found = 1;
+				break;
+			}
+		}
+	}
+	if ((!vic || !found) && head->next != head) {
+		/* If parse edid error, we select default mode; */
+		if (hdmi->edid.specs &&
+		    hdmi->edid.specs->modedb_len)
+			modelist = list_entry(head->next,
+					      struct display_modelist, list);
+		else
+			return hdmi->property->defaultmode;
+	}
+
+	if (modelist)
+		return modelist->vic;
+	else
+		return 0;
+}
+
+/**
+ * hdmi_set_lcdc: switch lcdc mode to required video mode
+ * @hdmi:
+ *
+ * NOTES:
+ *
+ */
+int hdmi_set_lcdc(struct hdmi *hdmi)
+{
+	int rc = 0;
+	struct rk_screen screen;
+
+	rc = hdmi_set_info(&screen, hdmi);
+	if (!rc)
+		rk_fb_switch_screen(&screen, 1, hdmi->lcdc->id);
+	return rc;
+}
+
+/**
+ * hdmi_videomode_compare - compare 2 videomodes
+ * @mode1: first videomode
+ * @mode2: second videomode
+ *
+ * RETURNS:
+ * 1 if mode1 > mode2, 0 if mode1 = mode2, -1 mode1 < mode2
+ */
+static int hdmi_videomode_compare(const struct fb_videomode *mode1,
+				  const struct fb_videomode *mode2)
+{
+	if (mode1->xres > mode2->xres)
+		return 1;
+
+	if (mode1->xres == mode2->xres) {
+		if (mode1->yres > mode2->yres)
+			return 1;
+		if (mode1->yres == mode2->yres) {
+			if (mode1->vmode < mode2->vmode)
+				return 1;
+			if (mode1->pixclock > mode2->pixclock)
+				return 1;
+			if (mode1->pixclock == mode2->pixclock) {
+				if (mode1->refresh > mode2->refresh)
+					return 1;
+				if (mode1->refresh == mode2->refresh) {
+					if (mode2->flag > mode1->flag)
+						return 1;
+					if (mode2->flag < mode1->flag)
+						return -1;
+					if (mode2->vmode > mode1->vmode)
+						return 1;
+					if (mode2->vmode == mode1->vmode)
+						return 0;
+				}
+			}
+		}
+	}
+	return -1;
+}
+
+/**
+ * hdmi_add_vic - add entry to modelist according vic
+ * @vic: vic to be added
+ * @head: struct list_head of modelist
+ *
+ * NOTES:
+ * Will only add unmatched mode entries
+ */
+int hdmi_add_vic(int vic, struct list_head *head)
+{
+	struct list_head *pos;
+	struct display_modelist *modelist;
+	int found = 0, v;
+
+	/*pr_info("%s vic %d\n", __FUNCTION__, vic);*/
+	if (vic == 0)
+		return -1;
+
+	if (vic & HDMI_VIDEO_YUV420) {
+		v = vic & 0xff;
+		if (v != HDMI_3840X2160P_50HZ &&
+		    v != HDMI_3840X2160P_60HZ &&
+		    v != HDMI_4096X2160P_50HZ &&
+		    v != HDMI_4096X2160P_60HZ &&
+		    v != HDMI_3840X2160P_50HZ_21_9 &&
+		    v != HDMI_3840X2160P_60HZ_21_9) {
+			return -1;
+		}
+	}
+
+	list_for_each(pos, head) {
+		modelist = list_entry(pos, struct display_modelist, list);
+		v = modelist->vic;
+		if (v == vic) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		modelist = kmalloc(sizeof(*modelist),
+				   GFP_KERNEL);
+
+		if (!modelist)
+			return -ENOMEM;
+		memset(modelist, 0, sizeof(struct display_modelist));
+		modelist->vic = vic;
+		list_add_tail(&modelist->list, head);
+	}
+	return 0;
+}
+
+/**
+ * hdmi_add_videomode: adds videomode entry to modelist
+ * @mode: videomode to be added
+ * @head: struct list_head of modelist
+ *
+ * NOTES:
+ * Will only add unmatched mode entries
+ */
+static int hdmi_add_videomode(const struct fb_videomode *mode,
+			      struct list_head *head)
+{
+	struct list_head *pos;
+	struct display_modelist *modelist, *modelist_new;
+	struct fb_videomode *m;
+	int i, found = 0;
+
+	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+		m = (struct fb_videomode *)&hdmi_mode[i].mode;
+		if (fb_mode_is_equal(m, mode)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (found) {
+		list_for_each(pos, head) {
+			modelist = list_entry(pos,
+					      struct display_modelist, list);
+			m = &modelist->mode;
+			if (fb_mode_is_equal(m, mode))
+				return 0;
+			else if (hdmi_videomode_compare(m, mode) == -1)
+				break;
+		}
+
+		modelist_new = kmalloc(sizeof(*modelist_new), GFP_KERNEL);
+		if (!modelist_new)
+			return -ENOMEM;
+		memset(modelist_new, 0, sizeof(struct display_modelist));
+		modelist_new->mode = hdmi_mode[i].mode;
+		modelist_new->vic = hdmi_mode[i].vic;
+		list_add_tail(&modelist_new->list, pos);
+	}
+
+	return 0;
+}
+
+/**
+ * hdmi_sort_modelist: sort modelist of edid
+ * @edid: edid to be sort
+ */
+static void hdmi_sort_modelist(struct hdmi_edid *edid, int feature)
+{
+	struct list_head *pos, *pos_new;
+	struct list_head head_new, *head = &edid->modelist;
+	struct display_modelist *modelist, *modelist_new, *modelist_n;
+	struct fb_videomode *m, *m_new;
+	int i, compare, vic;
+
+	INIT_LIST_HEAD(&head_new);
+	list_for_each(pos, head) {
+		modelist = list_entry(pos, struct display_modelist, list);
+		/*pr_info("%s vic %d\n", __function__, modelist->vic);*/
+		for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+			if ((modelist->vic & HDMI_VIDEO_DMT) || (modelist->vic & HDMI_VIDEO_DISCRETE_VR)) {
+				if (feature & (SUPPORT_VESA_DMT | SUPPORT_RK_DISCRETE_VR))
+					vic = modelist->vic;
+				else
+					continue;
+			} else {
+				vic = modelist->vic & HDMI_VIC_MASK;
+			}
+			if (vic == hdmi_mode[i].vic ||
+			    vic == hdmi_mode[i].vic_2nd) {
+				if ((feature & SUPPORT_4K) == 0 &&
+				    hdmi_mode[i].mode.xres >= 3840)
+					continue;
+				if ((feature & SUPPORT_4K_4096) == 0 &&
+				    hdmi_mode[i].mode.xres == 4096)
+					continue;
+				if ((feature & SUPPORT_TMDS_600M) == 0 &&
+				    !(modelist->vic & HDMI_VIDEO_YUV420) &&
+				    hdmi_mode[i].mode.pixclock > 340000000)
+					continue;
+				if ((modelist->vic & HDMI_VIDEO_YUV420) &&
+				    (feature & SUPPORT_YUV420) == 0)
+					continue;
+				if ((feature & SUPPORT_1080I) == 0 &&
+				    hdmi_mode[i].mode.xres == 1920 &&
+				    (hdmi_mode[i].mode.vmode &
+				     FB_VMODE_INTERLACED))
+					continue;
+				if ((feature & SUPPORT_480I_576I) == 0 &&
+				    hdmi_mode[i].mode.xres == 720 &&
+				    hdmi_mode[i].mode.vmode &
+				     FB_VMODE_INTERLACED)
+					continue;
+				modelist->mode = hdmi_mode[i].mode;
+				if (modelist->vic & HDMI_VIDEO_YUV420)
+					modelist->mode.flag = 1;
+
+				compare = 1;
+				m = (struct fb_videomode *)&modelist->mode;
+				list_for_each(pos_new, &head_new) {
+					modelist_new =
+					list_entry(pos_new,
+						   struct display_modelist,
+						   list);
+					m_new = &modelist_new->mode;
+					compare =
+					hdmi_videomode_compare(m, m_new);
+					if (compare != -1)
+						break;
+				}
+				if (compare != 0) {
+					modelist_n =
+						kmalloc(sizeof(*modelist_n),
+							GFP_KERNEL);
+					if (!modelist_n)
+						return;
+					*modelist_n = *modelist;
+					list_add_tail(&modelist_n->list,
+						      pos_new);
+				}
+				break;
+			}
+		}
+	}
+	fb_destroy_modelist(head);
+	if (head_new.next == &head_new) {
+		pr_info("There is no available video mode in EDID.\n");
+		INIT_LIST_HEAD(&edid->modelist);
+	} else {
+		edid->modelist = head_new;
+		edid->modelist.prev->next = &edid->modelist;
+		edid->modelist.next->prev = &edid->modelist;
+	}
+}
+
+static int edid_select_prop_value(struct hdmi *hdmi)
+{
+	struct edid_prop_value *prop_value = NULL;
+	int nstates = 0;
+	int i, vid, pid, sn, xres, yres, reboot = 0;
+
+	prop_value = hdmi->pvalue;
+	nstates = hdmi->nstates;
+
+	if (!prop_value) {
+		pr_info("%s:pvalue is NULL\n", __func__);
+		return -1;
+	}
+
+	vid = hdmi->edid.value.vid;
+	pid = hdmi->edid.value.pid;
+	sn = hdmi->edid.value.sn;
+	xres = hdmi->edid.value.xres;
+	yres = hdmi->edid.value.yres;
+
+	for (i = 0; i < nstates; i++) {
+		if ((prop_value[i].vid == vid) &&
+		    (prop_value[i].pid == pid) &&
+		    (prop_value[i].sn == sn) &&
+		    (prop_value[i].xres == xres) &&
+		    (prop_value[i].yres == yres)) {
+			hdmi->edid.value = prop_value[i];
+			hdmi->prop.value = prop_value[i];
+			if ((hdmi->prop.valid) &&
+			    ((hdmi->prop.last_vid != vid) ||
+			    (hdmi->prop.last_pid != pid) ||
+			    (hdmi->prop.last_sn != sn) ||
+			    (hdmi->prop.last_xres != xres) ||
+			    (hdmi->prop.last_yres != yres))) {
+				reboot = 1;
+			} else {
+				reboot = 0;
+			}
+
+			hdmi->prop.last_vid = vid;
+			hdmi->prop.last_pid = pid;
+			hdmi->prop.last_sn = sn;
+			hdmi->prop.last_xres = xres;
+			hdmi->prop.last_yres = yres;
+			hdmi->prop.valid = 1;
+			pr_info("%s:i=%d reboot=%d,valid=%d\n",
+				__func__, i, reboot, hdmi->prop.valid);
+
+			break;
+		}
+	}
+
+	if (reboot) {
+		dev_info(hdmi->dev, "%s:kernel_restart\n", __func__);
+		kernel_restart(NULL);
+	}
+
+	return 0;
+}
+
+/**
+ * hdmi_ouputmode_select - select hdmi transmitter output mode: hdmi or dvi?
+ * @hdmi: handle of hdmi
+ * @edid_ok: get EDID data success or not, HDMI_ERROR_SUCCESS means success.
+ */
+int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok)
+{
+	struct list_head *head = &hdmi->edid.modelist;
+	struct fb_monspecs *specs = hdmi->edid.specs;
+	struct fb_videomode *modedb = NULL, *mode = NULL;
+	int i, pixclock, feature = hdmi->property->feature;
+
+	if (edid_ok != HDMI_ERROR_SUCCESS) {
+		dev_err(hdmi->dev, "warning: EDID error, assume sink as HDMI !!!!");
+		hdmi->edid.status = -1;
+		hdmi->edid.sink_hdmi = 1;
+		hdmi->edid.baseaudio_support = 1;
+		hdmi->edid.ycbcr444 = 0;
+		hdmi->edid.ycbcr422 = 0;
+	}
+
+	if (hdmi->edid_auto_support)
+		edid_select_prop_value(hdmi);
+
+	if (head->next == head) {
+		dev_info(hdmi->dev,
+			 "warning: no CEA video mode parsed from EDID !!!!\n");
+		/* If EDID get error, list all system supported mode.
+		 * If output mode is set to DVI and EDID is ok, check
+		 * the output timing.
+		 */
+		if (hdmi->edid.sink_hdmi == 0 && specs && specs->modedb_len) {
+			/* Get max resolution timing */
+			modedb = &specs->modedb[0];
+			for (i = 0; i < specs->modedb_len; i++) {
+				if (specs->modedb[i].xres > modedb->xres)
+					modedb = &specs->modedb[i];
+				else if (specs->modedb[i].xres ==
+					 modedb->xres &&
+					 specs->modedb[i].yres > modedb->yres)
+					modedb = &specs->modedb[i];
+			}
+			/* For some monitor, the max pixclock read from EDID
+			 * is smaller than the clock of max resolution mode
+			 * supported. We fix it.
+			 */
+			pixclock = PICOS2KHZ(modedb->pixclock);
+			pixclock /= 250;
+			pixclock *= 250;
+			pixclock *= 1000;
+			if (pixclock == 148250000)
+				pixclock = 148500000;
+			if (pixclock > specs->dclkmax)
+				specs->dclkmax = pixclock;
+		}
+
+		for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+			mode = (struct fb_videomode *)&hdmi_mode[i].mode;
+			if (modedb) {
+				if ((mode->pixclock < specs->dclkmin) ||
+				    (mode->pixclock > specs->dclkmax) ||
+				    (mode->refresh < specs->vfmin) ||
+				    (mode->refresh > specs->vfmax) ||
+				    (mode->xres > modedb->xres) ||
+				    (mode->yres > modedb->yres))
+					continue;
+			} else {
+				/* If there is no valid information in EDID,
+				 * just list common hdmi foramt.
+				 */
+				if (mode->xres > 3840 ||
+				    mode->refresh < 50 ||
+				    (mode->vmode & FB_VMODE_INTERLACED) ||
+				    hdmi_mode[i].vic & HDMI_VIDEO_DMT ||
+				    hdmi_mode[i].vic & HDMI_VIDEO_DISCRETE_VR)
+					continue;
+			}
+			if ((feature & SUPPORT_TMDS_600M) == 0 &&
+			    mode->pixclock > 340000000)
+				continue;
+			if ((feature & SUPPORT_4K) == 0 &&
+			    mode->xres >= 3840)
+				continue;
+			if ((feature & SUPPORT_4K_4096) == 0 &&
+			    mode->xres == 4096)
+				continue;
+			if ((feature & SUPPORT_1080I) == 0 &&
+			    mode->xres == 1920 &&
+			    (mode->vmode & FB_VMODE_INTERLACED))
+				continue;
+			if ((feature & SUPPORT_480I_576I) == 0 &&
+			    mode->xres == 720 &&
+			    (mode->vmode & FB_VMODE_INTERLACED))
+				continue;
+			hdmi_add_videomode(mode, head);
+		}
+	} else {
+		/* There are some video mode is not defined in EDID extend
+		 * block, so we need to check first block data.
+		 */
+		if (specs && specs->modedb_len) {
+			for (i = 0; i < specs->modedb_len; i++) {
+				modedb = &specs->modedb[i];
+				pixclock = hdmi_videomode_to_vic(modedb);
+				if (pixclock)
+					hdmi_add_vic(pixclock, head);
+			}
+		}
+		hdmi_sort_modelist(&hdmi->edid, hdmi->property->feature);
+	}
+
+	return HDMI_ERROR_SUCCESS;
+}
+
+/**
+ * hdmi_videomode_to_vic: transverse video mode to vic
+ * @vmode: videomode to transverse
+ *
+ */
+int hdmi_videomode_to_vic(struct fb_videomode *vmode)
+{
+	struct fb_videomode *mode;
+	unsigned int vic = 0;
+	int i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+		mode = (struct fb_videomode *)&hdmi_mode[i].mode;
+		if (vmode->vmode == mode->vmode &&
+		    vmode->refresh == mode->refresh &&
+		    vmode->xres == mode->xres &&
+		    vmode->yres == mode->yres &&
+		    vmode->left_margin == mode->left_margin &&
+		    vmode->right_margin == mode->right_margin &&
+		    vmode->upper_margin == mode->upper_margin &&
+		    vmode->lower_margin == mode->lower_margin &&
+		    vmode->hsync_len == mode->hsync_len &&
+		    vmode->vsync_len == mode->vsync_len) {
+			vic = hdmi_mode[i].vic;
+			break;
+		}
+	}
+	return vic;
+}
+
+/**
+ * hdmi_vic2timing: transverse vic mode to video timing
+ * @vmode: vic to transverse
+ *
+ */
+const struct hdmi_video_timing *hdmi_vic2timing(int vic)
+{
+	int i;
+
+	if (vic == 0)
+		return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+		if (hdmi_mode[i].vic == vic || hdmi_mode[i].vic_2nd == vic)
+			return &hdmi_mode[i];
+	}
+	return NULL;
+}
+
+/**
+ * hdmi_vic_to_videomode: transverse vic mode to video mode
+ * @vmode: vic to transverse
+ *
+ */
+const struct fb_videomode *hdmi_vic_to_videomode(int vic)
+{
+	int i, vid;
+
+	if (vic == 0)
+		return NULL;
+	else if ((vic & HDMI_VIDEO_DMT) || (vic & HDMI_VIDEO_DISCRETE_VR))
+		vid = vic;
+	else
+		vid = vic & HDMI_VIC_MASK;
+	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+		if (hdmi_mode[i].vic == vid ||
+		    hdmi_mode[i].vic_2nd == vid)
+			return &hdmi_mode[i].mode;
+	}
+	return NULL;
+}
+
+/**
+ * hdmi_init_modelist: initial hdmi mode list
+ * @hdmi:
+ *
+ * NOTES:
+ *
+ */
+void hdmi_init_modelist(struct hdmi *hdmi)
+{
+	int i, feature;
+	struct list_head *head = &hdmi->edid.modelist;
+
+	feature = hdmi->property->feature;
+	INIT_LIST_HEAD(&hdmi->edid.modelist);
+	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+		if ((hdmi_mode[i].vic & HDMI_VIDEO_DMT) || (hdmi_mode[i].vic & HDMI_VIDEO_DISCRETE_VR))
+			continue;
+		if ((feature & SUPPORT_TMDS_600M) == 0 &&
+		    hdmi_mode[i].mode.pixclock > 340000000)
+			continue;
+		if ((feature & SUPPORT_4K) == 0 &&
+		    hdmi_mode[i].mode.xres >= 3840)
+			continue;
+		if ((feature & SUPPORT_4K_4096) == 0 &&
+		    hdmi_mode[i].mode.xres == 4096)
+			continue;
+		if ((feature & SUPPORT_1080I) == 0 &&
+		    hdmi_mode[i].mode.xres == 1920 &&
+		    (hdmi_mode[i].mode.vmode & FB_VMODE_INTERLACED))
+			continue;
+		if ((feature & SUPPORT_480I_576I) == 0 &&
+		    hdmi_mode[i].mode.xres == 720 &&
+		    (hdmi_mode[i].mode.vmode & FB_VMODE_INTERLACED))
+			continue;
+		hdmi_add_videomode(&hdmi_mode[i].mode, head);
+	}
+}
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,673 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/display-sys.h>
+#include <linux/interrupt.h>
+#include <linux/moduleparam.h>
+#include "rockchip-hdmi.h"
+
+int hdmi_dbg_level;
+module_param(hdmi_dbg_level, int, S_IRUGO | S_IWUSR);
+
+static int hdmi_get_enable(struct rk_display_device *device)
+{
+	struct hdmi *hdmi = device->priv_data;
+	int enable;
+
+	enable = hdmi->enable;
+	return enable;
+}
+
+static int hdmi_set_enable(struct rk_display_device *device, int enable)
+{
+	struct hdmi *hdmi = device->priv_data;
+
+	if (enable == 0)
+		hdmi_submit_work(hdmi, HDMI_DISABLE_CTL, 0, 0);
+	else
+		hdmi_submit_work(hdmi, HDMI_ENABLE_CTL, 0, 0);
+	return 0;
+}
+
+static int hdmi_get_status(struct rk_display_device *device)
+{
+	struct hdmi *hdmi = device->priv_data;
+
+	if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+		return 1;
+	else
+		return 0;
+}
+
+static int hdmi_get_modelist(struct rk_display_device *device,
+			     struct list_head **modelist)
+{
+	struct hdmi *hdmi = device->priv_data;
+
+	*modelist = &hdmi->edid.modelist;
+	return 0;
+}
+
+static int hdmi_set_mode(struct rk_display_device *device,
+			 struct fb_videomode *mode)
+{
+	struct hdmi *hdmi = device->priv_data;
+	struct display_modelist *display_modelist =
+			container_of(mode, struct display_modelist, mode);
+	int vic = 0;
+
+	if (!mode) {
+		hdmi->autoset = 1;
+		vic = hdmi_find_best_mode(hdmi, 0);
+	} else {
+		hdmi->autoset = 0;
+		vic = display_modelist->vic;
+	}
+
+	if (vic && hdmi->vic != vic) {
+		hdmi->vic = vic;
+		if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+			hdmi_submit_work(hdmi, HDMI_SET_VIDEO, 0, 0);
+	}
+	return 0;
+}
+
+static int hdmi_get_mode(struct rk_display_device *device,
+			 struct fb_videomode *mode)
+{
+	struct hdmi *hdmi = device->priv_data;
+	struct fb_videomode *vmode;
+
+	if (!mode)
+		return -1;
+
+	if (hdmi->vic) {
+		vmode = (struct fb_videomode *)
+			hdmi_vic_to_videomode(hdmi->vic);
+		if (unlikely(!vmode))
+			return -1;
+		*mode = *vmode;
+		if (hdmi->vic & HDMI_VIDEO_YUV420)
+			mode->flag = 1;
+	} else {
+		memset(mode, 0, sizeof(struct fb_videomode));
+	}
+	return 0;
+}
+
+static int hdmi_set_3dmode(struct rk_display_device *device, int mode)
+{
+	struct hdmi *hdmi = device->priv_data;
+	struct list_head *modelist, *pos;
+	struct display_modelist *display_modelist = NULL;
+
+	if (!hdmi)
+		return -1;
+
+	modelist = &hdmi->edid.modelist;
+	list_for_each(pos, modelist) {
+		display_modelist =
+			list_entry(pos, struct display_modelist, list);
+		if (hdmi->vic != display_modelist->vic)
+			display_modelist = NULL;
+		else
+			break;
+	}
+	if (!display_modelist)
+		return -1;
+
+	if ((mode != HDMI_3D_NONE) &&
+	    ((display_modelist->format_3d & (1 << mode)) == 0))
+		pr_warn("warning: sink not support input 3d mode %d", mode);
+
+	if (hdmi->mode_3d != mode) {
+		hdmi->mode_3d = mode;
+		if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+			hdmi_submit_work(hdmi, HDMI_SET_3D, 0, 0);
+	}
+	return 0;
+}
+
+static int hdmi_get_3dmode(struct rk_display_device *device)
+{
+	struct hdmi *hdmi = device->priv_data;
+
+	if (!hdmi)
+		return -1;
+	else
+		return hdmi->mode_3d;
+}
+
+/* CEA 861-E: Audio Coding Type
+ * sync width enum hdmi_audio_type
+ */
+static const char * const audioformatstr[] = {
+	"",
+	"LPCM",		/*HDMI_AUDIO_LPCM = 1,*/
+	"AC3",		/*HDMI_AUDIO_AC3,*/
+	"MPEG1",	/*HDMI_AUDIO_MPEG1,*/
+	"MP3",		/*HDMI_AUDIO_MP3,*/
+	"MPEG2",	/*HDMI_AUDIO_MPEG2,*/
+	"AAC-LC",	/*HDMI_AUDIO_AAC_LC, AAC*/
+	"DTS",		/*HDMI_AUDIO_DTS,*/
+	"ATARC",	/*HDMI_AUDIO_ATARC,*/
+	"DSD",		/*HDMI_AUDIO_DSD, One bit Audio */
+	"E-AC3",	/*HDMI_AUDIO_E_AC3,*/
+	"DTS-HD",	/*HDMI_AUDIO_DTS_HD,*/
+	"MLP",		/*HDMI_AUDIO_MLP,*/
+	"DST",		/*HDMI_AUDIO_DST,*/
+	"WMA-PRO",	/*HDMI_AUDIO_WMA_PRO*/
+};
+
+static int hdmi_get_edidaudioinfo(struct rk_display_device *device,
+				  char *audioinfo, int len)
+{
+	struct hdmi *hdmi = device->priv_data;
+	int i = 0, size = 0;
+	struct hdmi_audio *audio;
+
+	if (!hdmi)
+		return -1;
+
+	memset(audioinfo, 0x00, len);
+	/*printk("hdmi:edid: audio_num: %d\n", hdmi->edid.audio_num);*/
+	for (i = 0; i < hdmi->edid.audio_num; i++) {
+		audio = &hdmi->edid.audio[i];
+		if (audio->type < 1 || audio->type > HDMI_AUDIO_WMA_PRO) {
+			pr_info("audio type: unsupported.");
+			continue;
+		}
+		size = strlen(audioformatstr[audio->type]);
+		memcpy(audioinfo, audioformatstr[audio->type], size);
+		audioinfo[size] = ',';
+		audioinfo += (size + 1);
+	}
+	return 0;
+}
+
+static int hdmi_get_color(struct rk_display_device *device, char *buf)
+{
+	struct hdmi *hdmi = device->priv_data;
+	int i, mode;
+
+	mode = (1 << HDMI_COLOR_RGB_0_255);
+	if (hdmi->edid.sink_hdmi) {
+		mode |= (1 << HDMI_COLOR_RGB_16_235);
+		if (hdmi->edid.ycbcr422)
+			mode |= (1 << HDMI_COLOR_YCBCR422);
+		if (hdmi->edid.ycbcr444)
+			mode |= (1 << HDMI_COLOR_YCBCR444);
+	}
+	i = snprintf(buf, PAGE_SIZE,
+		     "Supported Color Mode: %d\n", mode);
+	i += snprintf(buf + i, PAGE_SIZE - i,
+		      "Current Color Mode: %d\n", hdmi->video.color_output);
+
+	mode = (1 << 1); /* 24 bit*/
+	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_30BITS &&
+	    hdmi->property->feature & SUPPORT_DEEP_10BIT)
+		mode |= (1 << HDMI_DEEP_COLOR_30BITS);
+	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_36BITS &&
+	    hdmi->property->feature & SUPPORT_DEEP_12BIT)
+		mode |= (1 << HDMI_DEEP_COLOR_36BITS);
+	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_48BITS &&
+	    hdmi->property->feature & SUPPORT_DEEP_16BIT)
+		mode |= (1 << HDMI_DEEP_COLOR_48BITS);
+	i += snprintf(buf + i, PAGE_SIZE - i,
+		      "Supported Color Depth: %d\n", mode);
+	i += snprintf(buf + i, PAGE_SIZE - i,
+		      "Current Color Depth: %d\n",
+		      hdmi->video.color_output_depth);
+	i += snprintf(buf + i, PAGE_SIZE - i,
+		      "Supported Colorimetry: %d\n", hdmi->edid.colorimetry);
+	i += snprintf(buf + i, PAGE_SIZE - i,
+		      "Current Colorimetry: %d\n", hdmi->colorimetry);
+	i += snprintf(buf + i, PAGE_SIZE - i,
+		      "Supported EOTF: 0x%x\n", hdmi->edid.hdr.hdrinfo.eotf);
+	i += snprintf(buf + i, PAGE_SIZE - i,
+		      "Current EOTF: 0x%x\n", hdmi->eotf);
+	i += snprintf(buf + i, PAGE_SIZE - i,
+		      "HDR MeteData: %d %d %d %d %d %d %d %d %d %d %d %d\n",
+		      hdmi->hdr.prim_x0, hdmi->hdr.prim_y0,
+		      hdmi->hdr.prim_x1, hdmi->hdr.prim_y1,
+		      hdmi->hdr.prim_x2, hdmi->hdr.prim_y2,
+		      hdmi->hdr.white_px, hdmi->hdr.white_py,
+		      hdmi->hdr.max_dml, hdmi->hdr.min_dml,
+		      hdmi->hdr.max_cll, hdmi->hdr.max_fall);
+	return i;
+}
+
+static int hdmi_set_color(struct rk_display_device *device,
+			  const char *buf, int len)
+{
+	struct hdmi *hdmi = device->priv_data;
+	int value;
+
+	if (!strncmp(buf, "mode", 4)) {
+		if (sscanf(buf, "mode=%d", &value) == -1)
+			return -1;
+		pr_debug("current mode is %d input mode is %x\n",
+			 hdmi->colormode, value);
+		if (hdmi->colormode != (value & 0xff))
+			hdmi->colormode = value & 0xff;
+		if (hdmi->colordepth != ((value >> 8) & 0xff)) {
+			pr_debug("current depth is %d input mode is %d\n",
+				 hdmi->colordepth, ((value >> 8) & 0xff));
+			hdmi->colordepth = ((value >> 8) & 0xff);
+		}
+	} else if (!strncmp(buf, "depth", 5)) {
+		if (sscanf(buf, "depth=%d", &value) == -1)
+			return -1;
+		pr_debug("current depth is %d input mode is %d\n",
+			 hdmi->colordepth, value);
+		if (hdmi->colordepth != value)
+			hdmi->colordepth = value;
+		else
+			return 0;
+	} else if (!strncmp(buf, "colorimetry", 11)) {
+		if (sscanf(buf, "colorimetry=%d", &value) == -1)
+			return -1;
+		pr_debug("current colorimetry is %d input colorimetry is %d\n",
+			 hdmi->colorimetry, value);
+		if (hdmi->colorimetry != value)
+			hdmi->colorimetry = value;
+		else
+			return 0;
+	} else if (!strncmp(buf, "hdr", 3)) {
+		if (sscanf(buf, "hdr=%d", &value) == -1)
+			return -1;
+		pr_info("current hdr eotf is %d input hdr eotf is %d\n",
+			hdmi->eotf, value);
+		if (hdmi->eotf != value &&
+		    (value & hdmi->edid.hdr.hdrinfo.eotf ||
+		     value == 0)) {
+			hdmi->eotf = value;
+			if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+				hdmi_submit_work(hdmi, HDMI_SET_HDR, 0, 0);
+		}
+		return 0;
+	} else if (!strncmp(buf, "hdrmdata", 8)) {
+		value = sscanf(buf,
+			       "hdrmdata=%u %u %u %u %u %u %u %u %u %u %u %u",
+			       &hdmi->hdr.prim_x0, &hdmi->hdr.prim_y0,
+			       &hdmi->hdr.prim_x1, &hdmi->hdr.prim_y1,
+			       &hdmi->hdr.prim_x2, &hdmi->hdr.prim_y2,
+			       &hdmi->hdr.white_px, &hdmi->hdr.white_py,
+			       &hdmi->hdr.max_dml, &hdmi->hdr.min_dml,
+			       &hdmi->hdr.max_cll, &hdmi->hdr.max_fall);
+		if (value == -1)
+			return -1;
+		else
+			return 0;
+	} else {
+		pr_err("%s unknown event\n", __func__);
+		return -1;
+	}
+	if (hdmi->hotplug == HDMI_HPD_ACTIVATED)
+		hdmi_submit_work(hdmi, HDMI_SET_COLOR, 0, 0);
+	return 0;
+}
+
+static int hdmi_set_scale(struct rk_display_device *device, int direction,
+			  int value)
+{
+	struct hdmi *hdmi = device->priv_data;
+
+	if (!hdmi || value < 0 || value > 100)
+		return -1;
+
+	if (!hdmi->hotplug)
+		return 0;
+
+	if (direction == DISPLAY_SCALE_X)
+		hdmi->xscale = value;
+	else if (direction == DISPLAY_SCALE_Y)
+		hdmi->yscale = value;
+	else
+		return -1;
+	rk_fb_disp_scale(hdmi->xscale, hdmi->yscale, hdmi->lcdc->id);
+	return 0;
+}
+
+static int hdmi_get_scale(struct rk_display_device *device, int direction)
+{
+	struct hdmi *hdmi = device->priv_data;
+
+	if (!hdmi)
+		return -1;
+
+	if (direction == DISPLAY_SCALE_X)
+		return hdmi->xscale;
+	else if (direction == DISPLAY_SCALE_Y)
+		return hdmi->yscale;
+	else
+		return -1;
+}
+
+static int hdmi_get_monspecs(struct rk_display_device *device,
+			     struct fb_monspecs *monspecs)
+{
+	struct hdmi *hdmi = device->priv_data;
+
+	if (!hdmi)
+		return -1;
+
+	if (hdmi->edid.specs)
+		*monspecs = *hdmi->edid.specs;
+	return 0;
+}
+
+/**
+ * hdmi_show_sink_info: show hdmi sink device information
+ * @hdmi: handle of hdmi
+ */
+static int hdmi_show_sink_info(struct hdmi *hdmi, char *buf, int len)
+{
+	struct list_head *pos, *head = &hdmi->edid.modelist;
+	struct display_modelist *modelist;
+	struct fb_videomode *m;
+	struct hdmi_audio *audio;
+	int i, lens = len;
+
+	lens += snprintf(buf + lens, PAGE_SIZE - lens,
+			"******** Show Sink Info ********\n");
+	lens += snprintf(buf + lens, PAGE_SIZE - lens,
+			 "Max tmds clk is %u\n",
+			 hdmi->edid.maxtmdsclock);
+	if (hdmi->edid.hf_vsdb_version)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 "Support HFVSDB\n");
+	if (hdmi->edid.scdc_present)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 "Support SCDC\n");
+	lens += snprintf(buf + lens, PAGE_SIZE - lens,
+			 "Support video mode:\n");
+	list_for_each(pos, head) {
+		modelist = list_entry(pos, struct display_modelist, list);
+		m = &modelist->mode;
+		if (m->flag)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 "\t%s(YCbCr420)\n", m->name);
+		else
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 "\t%s\n", m->name);
+	}
+	lens += snprintf(buf + lens, PAGE_SIZE - lens,
+			 "Support video color mode:");
+	lens += snprintf(buf + lens, PAGE_SIZE - lens, " RGB");
+	if (hdmi->edid.ycbcr420)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 " YCbCr420");
+	if (hdmi->edid.ycbcr422)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 " YCbCr422");
+	if (hdmi->edid.ycbcr444)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 " YCbCr444");
+	lens += snprintf(buf + lens, PAGE_SIZE - lens,
+			 "\nSupport video color depth:");
+	lens += snprintf(buf + lens, PAGE_SIZE - lens, " 24bit");
+	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_30BITS)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 30bit");
+	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_36BITS)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 36bit");
+	if (hdmi->edid.deepcolor & HDMI_DEEP_COLOR_48BITS)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 48bit");
+	if (hdmi->edid.ycbcr420)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 420_24bit");
+	if (hdmi->edid.deepcolor_420 & HDMI_DEEP_COLOR_30BITS)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 420_30bit");
+	if (hdmi->edid.deepcolor_420 & HDMI_DEEP_COLOR_36BITS)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 420_36bit");
+	if (hdmi->edid.deepcolor_420 & HDMI_DEEP_COLOR_48BITS)
+		lens += snprintf(buf + lens, PAGE_SIZE - lens, " 420_48bit");
+	if (hdmi->edid.colorimetry) {
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 "\nExtended Colorimetry:");
+		if (hdmi->edid.colorimetry &
+		    (1 << (HDMI_COLORIMETRY_EXTEND_XVYCC_601 - 3)))
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " xvYCC601");
+		if (hdmi->edid.colorimetry &
+		    (1 << (HDMI_COLORIMETRY_EXTEND_XVYCC_709 - 3)))
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " xvYCC709");
+		if (hdmi->edid.colorimetry &
+		    (1 << (HDMI_COLORIMETRY_EXTEND_SYCC_601 - 3)))
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " sYCC601");
+		if (hdmi->edid.colorimetry &
+		    (1 << (HDMI_COLORIMETRY_EXTEND_ADOBE_YCC601 - 3)))
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " AdobeYCC601");
+		if (hdmi->edid.colorimetry &
+		    (1 << (HDMI_COLORIMETRY_EXTEND_ADOBE_RGB - 3)))
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " AdobeRGB");
+		if (hdmi->edid.colorimetry &
+		    (1 << (HDMI_COLORIMETRY_EXTEND_BT_2020_YCC_C - 3)))
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " BT2020cYCC");
+		if (hdmi->edid.colorimetry &
+		    (1 << (HDMI_COLORIMETRY_EXTEND_BT_2020_YCC - 3)))
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " BT2020YCC");
+		if (hdmi->edid.colorimetry &
+		    (1 << (HDMI_COLORIMETRY_EXTEND_BT_2020_RGB - 3)))
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " BT2020RGB");
+	}
+	lens += snprintf(buf + lens, PAGE_SIZE - lens,
+			 "\nSupport audio type:");
+	for (i = 0; i < hdmi->edid.audio_num; i++) {
+		audio = &hdmi->edid.audio[i];
+		switch (audio->type) {
+		case HDMI_AUDIO_LPCM:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				" LPCM\n");
+			break;
+		case HDMI_AUDIO_AC3:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " AC3");
+			break;
+		case HDMI_AUDIO_MPEG1:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " MPEG1");
+			break;
+		case HDMI_AUDIO_MP3:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " MP3");
+			break;
+		case HDMI_AUDIO_MPEG2:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " MPEG2");
+			break;
+		case HDMI_AUDIO_AAC_LC:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " AAC");
+			break;
+		case HDMI_AUDIO_DTS:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " DTS");
+			break;
+		case HDMI_AUDIO_ATARC:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " ATARC");
+			break;
+		case HDMI_AUDIO_DSD:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " DSD");
+			break;
+		case HDMI_AUDIO_E_AC3:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " E-AC3");
+			break;
+		case HDMI_AUDIO_DTS_HD:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " DTS-HD");
+			break;
+		case HDMI_AUDIO_MLP:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " MLP");
+			break;
+		case HDMI_AUDIO_DST:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " DST");
+			break;
+		case HDMI_AUDIO_WMA_PRO:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " WMP-PRO");
+			break;
+		default:
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " Unknown");
+			break;
+		}
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 "Support max audio channel is %d\n",
+				 audio->channel);
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 "Support audio sample rate:");
+		if (audio->rate & HDMI_AUDIO_FS_32000)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 32000");
+		if (audio->rate & HDMI_AUDIO_FS_44100)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 44100");
+		if (audio->rate & HDMI_AUDIO_FS_48000)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 48000");
+		if (audio->rate & HDMI_AUDIO_FS_88200)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 88200");
+		if (audio->rate & HDMI_AUDIO_FS_96000)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 96000");
+		if (audio->rate & HDMI_AUDIO_FS_176400)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 176400");
+		if (audio->rate & HDMI_AUDIO_FS_192000)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 192000");
+		lens += snprintf(buf + lens, PAGE_SIZE - lens,
+				 "\nSupport audio word length:");
+		if (audio->rate & HDMI_AUDIO_WORD_LENGTH_16bit)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 16bit");
+		if (audio->rate & HDMI_AUDIO_WORD_LENGTH_20bit)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 20bit");
+		if (audio->rate & HDMI_AUDIO_WORD_LENGTH_24bit)
+			lens += snprintf(buf + lens, PAGE_SIZE - lens,
+					 " 24bit");
+		lens += snprintf(buf + lens, PAGE_SIZE - lens, "\n");
+	}
+	return lens;
+}
+
+static int hdmi_get_debug(struct rk_display_device *device, char *buf)
+{
+	struct hdmi *hdmi = device->priv_data;
+	u8 *buff;
+	int i, j, len = 0;
+
+	if (!hdmi)
+		return 0;
+	len += snprintf(buf + len, PAGE_SIZE - len, "EDID status:%s\n",
+			hdmi->edid.status ? "False" : "Okay");
+	len += snprintf(buf + len, PAGE_SIZE - len, "Raw Data:");
+	for (i = 0; i < HDMI_MAX_EDID_BLOCK; i++) {
+		if (!hdmi->edid.raw[i])
+			break;
+		buff = hdmi->edid.raw[i];
+		for (j = 0; j < HDMI_EDID_BLOCK_SIZE; j++) {
+			if (j % 16 == 0)
+				len += snprintf(buf + len,
+						PAGE_SIZE - len, "\n");
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x, ",
+					buff[j]);
+		}
+	}
+	len += snprintf(buf + len, PAGE_SIZE, "\n");
+	if (!hdmi->edid.status)
+		len += hdmi_show_sink_info(hdmi, buf, len);
+	return len;
+}
+
+static int vr_get_info(struct rk_display_device *device, char *buf)
+{
+	struct hdmi *hdmi = device->priv_data;
+	int valid, width, height, x_w, x_h, hwr, einit, vsync, panel, scan;
+	int len = 0;
+
+	valid = hdmi->prop.valid;
+	width = hdmi->prop.value.width;
+	height = hdmi->prop.value.height;
+	x_w = hdmi->prop.value.x_w;
+	x_h = hdmi->prop.value.x_h;
+	hwr = hdmi->prop.value.hwrotation;
+	einit = hdmi->prop.value.einit;
+	vsync = hdmi->prop.value.vsync;
+	panel = hdmi->prop.value.panel;
+	scan = hdmi->prop.value.scan;
+
+	len = snprintf(buf, PAGE_SIZE,
+		"valid=%d,width=%d,height=%d,xres=%d,yres=%d,hwrotation=%d,orientation=%d,vsync=%d,panel=%d,scan=%d\n",
+		valid, width, height, x_w, x_h, hwr, einit, vsync, panel, scan);
+
+	return len;
+}
+
+static struct rk_display_ops hdmi_display_ops = {
+	.setenable = hdmi_set_enable,
+	.getenable = hdmi_get_enable,
+	.getstatus = hdmi_get_status,
+	.getmodelist = hdmi_get_modelist,
+	.setmode = hdmi_set_mode,
+	.getmode = hdmi_get_mode,
+	.set3dmode = hdmi_set_3dmode,
+	.get3dmode = hdmi_get_3dmode,
+	.getedidaudioinfo = hdmi_get_edidaudioinfo,
+	.setcolor = hdmi_set_color,
+	.getcolor = hdmi_get_color,
+	.getmonspecs = hdmi_get_monspecs,
+	.setscale = hdmi_set_scale,
+	.getscale = hdmi_get_scale,
+	.getdebug = hdmi_get_debug,
+	.getvrinfo = vr_get_info,
+};
+
+static int hdmi_display_probe(struct rk_display_device *device, void *devdata)
+{
+	struct hdmi *hdmi = devdata;
+
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "HDMI");
+	if (strstr(hdmi->property->name, "dp"))
+		strcpy(device->type, "DP");
+	else
+		strcpy(device->type, "HDMI");
+
+	device->priority = DISPLAY_PRIORITY_HDMI;
+	device->name = hdmi->property->name;
+	device->property = hdmi->property->display;
+	device->priv_data = devdata;
+	device->ops = &hdmi_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_hdmi = {
+	.probe = hdmi_display_probe,
+};
+
+struct rk_display_device *hdmi_register_display_sysfs(struct hdmi *hdmi,
+						      struct device *parent)
+{
+	return rk_display_device_register(&display_hdmi, parent, hdmi);
+}
+
+void hdmi_unregister_display_sysfs(struct hdmi *hdmi)
+{
+	if (hdmi->ddev)
+		rk_display_device_unregister(hdmi->ddev);
+}
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+config  RK_HDMI_V1
+        bool "RockChip HDMI V1 support"
+        depends on RK_HDMI
+        help
+           Support rockchip hdmi version 1 if you say y here.
+
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Makefile b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Makefile
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for HDMI linux kernel module.
+#
+
+ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
+
+obj-$(CONFIG_RK_HDMI_V1) += rockchip_hdmiv1_hw.o rockchip_hdmiv1.o rockchip_hdmiv1_cec.o rockchip_hdmiv1_hdcp.o
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,441 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/uaccess.h>
+
+#include <linux/of_gpio.h>
+#include <linux/rk_fb.h>
+
+#if defined(CONFIG_DEBUG_FS)
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#endif
+
+#include "rockchip_hdmiv1.h"
+#include "rockchip_hdmiv1_hw.h"
+
+static struct hdmi_dev *hdmi_dev;
+
+#if defined(CONFIG_DEBUG_FS)
+static int rockchip_hdmiv1_reg_show(struct seq_file *s, void *v)
+{
+	int i = 0;
+	u32 val = 0;
+
+	seq_puts(s, "\n\n>>>rk3036_ctl reg");
+	for (i = 0; i < 16; i++)
+		seq_printf(s, " %2x", i);
+
+	seq_puts(s,
+		 "\n-----------------------------------------------------------------");
+
+	for (i = 0; i <= PHY_PRE_DIV_RATIO; i++) {
+		hdmi_readl(hdmi_dev, i, &val);
+		if (i % 16 == 0)
+			seq_printf(s, "\n>>>rk3036_ctl %2x:", i);
+		seq_printf(s, " %02x", val);
+	}
+	seq_puts(s,
+		 "\n-----------------------------------------------------------------\n");
+
+	return 0;
+}
+
+static ssize_t rockchip_hdmiv1_reg_write(struct file *file,
+					 const char __user *buf,
+					 size_t count,
+					 loff_t *ppos)
+{
+	u32 reg;
+	u32 val;
+	char kbuf[25];
+	static int ret;
+	struct hdmi *hdmi_drv =  hdmi_dev->hdmi;
+
+	if (copy_from_user(kbuf, buf, count))
+		return -EFAULT;
+	ret = sscanf(kbuf, "%x%x", &reg, &val);
+	if ((reg < 0) || (reg > 0xed)) {
+		dev_info(hdmi_drv->dev, "it is no hdmi reg\n");
+		return count;
+	}
+	dev_info(hdmi_drv->dev, "/**********rk3036 reg config******/");
+	dev_info(hdmi_drv->dev, "\n reg=%x val=%x\n", reg, val);
+	hdmi_writel(hdmi_dev, reg, val);
+
+	return count;
+}
+
+static int rockchip_hdmiv1_reg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rockchip_hdmiv1_reg_show, NULL);
+}
+
+static const struct file_operations rockchip_hdmiv1_reg_fops = {
+	.owner = THIS_MODULE,
+	.open = rockchip_hdmiv1_reg_open,
+	.read = seq_read,
+	.write = rockchip_hdmiv1_reg_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+#endif
+
+static int rockchip_hdmiv1_clk_enable(struct hdmi_dev *hdmi_dev)
+{
+	struct hdmi *hdmi_drv;
+
+	hdmi_drv =  hdmi_dev->hdmi;
+	if (!hdmi_dev->clk_on) {
+		if (hdmi_dev->soctype == HDMI_SOC_RK312X)
+			clk_prepare_enable(hdmi_dev->pd);
+
+		clk_prepare_enable(hdmi_dev->hclk);
+		spin_lock(&hdmi_dev->reg_lock);
+		hdmi_dev->clk_on = 1;
+		spin_unlock(&hdmi_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int rockchip_hdmiv1_clk_disable(struct hdmi_dev *hdmi_dev)
+{
+	struct hdmi *hdmi_drv;
+
+	hdmi_drv =  hdmi_dev->hdmi;
+	if (hdmi_dev->clk_on) {
+		spin_lock(&hdmi_dev->reg_lock);
+		hdmi_dev->clk_on = 0;
+		spin_unlock(&hdmi_dev->reg_lock);
+		if (hdmi_dev->soctype == HDMI_SOC_RK312X)
+			clk_disable_unprepare(hdmi_dev->pd);
+		clk_disable_unprepare(hdmi_dev->hclk);
+	}
+
+	return 0;
+}
+
+static void rockchip_hdmiv1_early_suspend(void)
+{
+	struct hdmi *hdmi_drv =  hdmi_dev->hdmi;
+
+	dev_info(hdmi_drv->dev, "hdmi suspend\n");
+	hdmi_submit_work(hdmi_drv,
+			 HDMI_SUSPEND_CTL, 0, 1);
+	mutex_lock(&hdmi_drv->lock);
+	if (hdmi_dev->irq)
+		disable_irq(hdmi_dev->irq);
+	mutex_unlock(&hdmi_drv->lock);
+	rockchip_hdmiv1_clk_disable(hdmi_dev);
+}
+
+static void rockchip_hdmiv1_early_resume(void)
+{
+	struct hdmi *hdmi_drv =  hdmi_dev->hdmi;
+
+	dev_info(hdmi_drv->dev, "hdmi resume\n");
+	mutex_lock(&hdmi_drv->lock);
+	rockchip_hdmiv1_clk_enable(hdmi_dev);
+	rockchip_hdmiv1_initial(hdmi_drv);
+	if (hdmi_drv->enable && hdmi_dev->irq) {
+		rockchip_hdmiv1_irq(hdmi_drv);
+		enable_irq(hdmi_dev->irq);
+	}
+	mutex_unlock(&hdmi_drv->lock);
+	hdmi_submit_work(hdmi_drv, HDMI_RESUME_CTL, 0, 0);
+}
+
+static int rockchip_hdmiv1_fb_event_notify(struct notifier_block *self,
+					   unsigned long action,
+					   void *data)
+{
+	struct fb_event *event = data;
+
+	if (action == FB_EARLY_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			break;
+		default:
+			if (!hdmi_dev->hdmi->sleep)
+				rockchip_hdmiv1_early_suspend();
+			break;
+		}
+	} else if (action == FB_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			if (hdmi_dev->hdmi->sleep)
+				rockchip_hdmiv1_early_resume();
+			break;
+		default:
+			break;
+		}
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block rockchip_hdmiv1_fb_notifier = {
+	.notifier_call = rockchip_hdmiv1_fb_event_notify,
+};
+
+static irqreturn_t rockchip_hdmiv1_irq_func(int irq, void *dev_id)
+{
+	struct hdmi *hdmi_drv = hdmi_dev->hdmi;
+
+	rockchip_hdmiv1_irq(hdmi_drv);
+
+	return IRQ_HANDLED;
+}
+
+static struct hdmi_property rockchip_hdmiv1_property = {
+	.videosrc = DISPLAY_SOURCE_LCDC0,
+	.display = DISPLAY_MAIN,
+};
+
+static struct hdmi_ops rockchip_hdmiv1_ops;
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rockchip_hdmiv1_dt_ids[] = {
+	{.compatible = "rockchip,rk3036-hdmi"},
+	{.compatible = "rockchip,rk312x-hdmi"},
+	{}
+};
+
+static int rockchip_hdmiv1_parse_dt(struct hdmi_dev *hdmi_dev)
+{
+	int val = 0;
+	struct device_node *np = hdmi_dev->dev->of_node;
+	const struct of_device_id *match;
+
+	match = of_match_node(rockchip_hdmiv1_dt_ids, np);
+	if (!match)
+		return -EINVAL;
+
+	if (!strcmp(match->compatible, "rockchip,rk3036-hdmi")) {
+		hdmi_dev->soctype = HDMI_SOC_RK3036;
+	} else if (!strcmp(match->compatible, "rockchip,rk312x-hdmi")) {
+		hdmi_dev->soctype = HDMI_SOC_RK312X;
+	} else {
+		pr_err("It is not a valid rockchip soc!");
+		return -ENOMEM;
+	}
+
+	if (!of_property_read_u32(np, "rockchip,hdmi_video_source", &val))
+		rockchip_hdmiv1_property.videosrc = val;
+
+	if (!of_property_read_u32(np, "rockchip,hdmi_audio_source", &val))
+		hdmi_dev->audiosrc = val;
+
+	if (!of_property_read_u32(np, "rockchip,cec_enable", &val) &&
+	    (val == 1)) {
+		pr_debug("hdmi support cec\n");
+		rockchip_hdmiv1_property.feature |= SUPPORT_CEC;
+	}
+	if (!of_property_read_u32(np, "rockchip,hdcp_enable", &val) &&
+	    (val == 1)) {
+		pr_debug("hdmi support hdcp\n");
+		rockchip_hdmiv1_property.feature |= SUPPORT_HDCP;
+	}
+	if (!of_property_read_u32(np, "rockchip,defaultmode", &val) &&
+	    (val > 0)) {
+		pr_debug("default mode is %d\n", val);
+		rockchip_hdmiv1_property.defaultmode = val;
+	} else {
+		rockchip_hdmiv1_property.defaultmode =
+						HDMI_VIDEO_DEFAULT_MODE;
+	}
+
+	return 0;
+}
+MODULE_DEVICE_TABLE(of, rockchip_hdmiv1_dt_ids);
+#endif
+
+static int rockchip_hdmiv1_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct resource *res;
+
+	hdmi_dev = devm_kzalloc(&pdev->dev,
+				sizeof(struct hdmi_dev),
+				GFP_KERNEL);
+	if (!hdmi_dev) {
+		dev_err(&pdev->dev, ">>rk_hdmi kmalloc fail!");
+		return -ENOMEM;
+	}
+	hdmi_dev->dev = &pdev->dev;
+	platform_set_drvdata(pdev, hdmi_dev);
+	spin_lock_init(&hdmi_dev->reg_lock);
+	rockchip_hdmiv1_parse_dt(hdmi_dev);
+	/* request and remap iomem */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(hdmi_dev->dev, "Unable to get register resource\n");
+		ret = -ENXIO;
+		goto failed;
+	}
+	hdmi_dev->regbase_phy = res->start;
+	hdmi_dev->regsize_phy = resource_size(res);
+	hdmi_dev->regbase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(hdmi_dev->regbase)) {
+		ret = PTR_ERR(hdmi_dev->regbase);
+		dev_err(hdmi_dev->dev, "cannot ioremap registers,err=%d\n",
+			ret);
+		goto failed;
+	}
+	if (hdmi_dev->soctype == HDMI_SOC_RK312X) {
+		hdmi_dev->pd = devm_clk_get(hdmi_dev->dev, "pd_hdmi");
+		if (IS_ERR(hdmi_dev->pd)) {
+			dev_err(hdmi_dev->hdmi->dev, "Unable to get hdmi pd\n");
+			ret = -ENXIO;
+			goto failed;
+		}
+	}
+	hdmi_dev->hclk = devm_clk_get(hdmi_dev->dev, "pclk_hdmi");
+	if (IS_ERR(hdmi_dev->hclk)) {
+		dev_err(hdmi_dev->hdmi->dev, "Unable to get hdmi hclk\n");
+		ret = -ENXIO;
+		goto failed;
+	}
+	/* enable clk */
+	rockchip_hdmiv1_clk_enable(hdmi_dev);
+	hdmi_dev->hclk_rate = clk_get_rate(hdmi_dev->hclk);
+
+	rockchip_hdmiv1_dev_init_ops(&rockchip_hdmiv1_ops);
+	rockchip_hdmiv1_property.name = (char *)pdev->name;
+	rockchip_hdmiv1_property.priv = hdmi_dev;
+	if (rk_fb_get_display_policy() == DISPLAY_POLICY_BOX)
+		rockchip_hdmiv1_property.feature |= SUPPORT_1080I |
+						    SUPPORT_480I_576I;
+	hdmi_dev->hdmi = rockchip_hdmi_register(&rockchip_hdmiv1_property,
+						&rockchip_hdmiv1_ops);
+	if (!hdmi_dev->hdmi) {
+		dev_err(&pdev->dev, "register hdmi device failed\n");
+		ret = -ENOMEM;
+		goto failed;
+	}
+	hdmi_dev->hdmi->dev = &pdev->dev;
+
+	fb_register_client(&rockchip_hdmiv1_fb_notifier);
+	rockchip_hdmiv1_initial(hdmi_dev->hdmi);
+
+	rk_display_device_enable(hdmi_dev->hdmi->ddev);
+	hdmi_submit_work(hdmi_dev->hdmi, HDMI_HPD_CHANGE, 0, 1);
+
+#if defined(CONFIG_DEBUG_FS)
+	hdmi_dev->debugfs_dir = debugfs_create_dir("rockchip_hdmiv1", NULL);
+	if (IS_ERR(hdmi_dev->debugfs_dir)) {
+		dev_err(hdmi_dev->hdmi->dev,
+			"failed to create debugfs dir for hdmi!\n");
+	} else {
+		debugfs_create_file("hdmi", S_IRUSR,
+				    hdmi_dev->debugfs_dir, hdmi_dev->hdmi,
+				    &rockchip_hdmiv1_reg_fops);
+	}
+#endif
+
+	/* get the IRQ */
+	hdmi_dev->irq = platform_get_irq(pdev, 0);
+	if (hdmi_dev->irq <= 0) {
+		dev_err(hdmi_dev->hdmi->dev, "failed to get hdmi irq resource (%d).\n",
+			hdmi_dev->irq);
+		hdmi_dev->irq = 0;
+	} else {
+		/* request the IRQ */
+		ret = devm_request_irq(hdmi_dev->hdmi->dev,
+				       hdmi_dev->irq,
+				       rockchip_hdmiv1_irq_func,
+				       IRQF_TRIGGER_HIGH,
+				       dev_name(hdmi_dev->hdmi->dev),
+				       hdmi_dev->hdmi);
+		if (ret) {
+			dev_err(hdmi_dev->hdmi->dev, "hdmi request_irq failed (%d)\n",
+				ret);
+			goto failed1;
+		}
+	}
+	dev_info(hdmi_dev->hdmi->dev, "hdmi probe success.\n");
+	return 0;
+
+failed1:
+	rockchip_hdmi_unregister(hdmi_dev->hdmi);
+failed:
+	hdmi_dev = NULL;
+	dev_err(&pdev->dev, "rk3288 hdmi probe error.\n");
+	return ret;
+}
+
+static int rockchip_hdmiv1_remove(struct platform_device *pdev)
+{
+	struct hdmi *hdmi_drv = NULL;
+
+	hdmi_drv = hdmi_dev->hdmi;
+	rockchip_hdmi_unregister(hdmi_drv);
+	return 0;
+}
+
+static void rockchip_hdmiv1_shutdown(struct platform_device *pdev)
+{
+	struct hdmi_dev *hdmi_dev = platform_get_drvdata(pdev);
+	struct hdmi *hdmi_drv = NULL;
+
+	if (hdmi_dev) {
+		hdmi_drv = hdmi_dev->hdmi;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&hdmi_drv->early_suspend);
+#endif
+		mutex_lock(&hdmi_drv->lock);
+		hdmi_drv->sleep = 1;
+		if (!hdmi_drv->enable) {
+			mutex_unlock(&hdmi_drv->lock);
+			return;
+		}
+		if (hdmi_dev->irq)
+			disable_irq(hdmi_dev->irq);
+		mutex_unlock(&hdmi_drv->lock);
+		if (hdmi_drv->hotplug == HDMI_HPD_ACTIVATED)
+			hdmi_drv->ops->setmute(hdmi_drv,
+					       HDMI_VIDEO_MUTE |
+					       HDMI_AUDIO_MUTE);
+		rockchip_hdmiv1_clk_disable(hdmi_dev);
+	}
+	dev_info(hdmi_drv->dev, "rk hdmi shut down.\n");
+}
+
+static struct platform_driver rockchip_hdmiv1_driver = {
+	.probe = rockchip_hdmiv1_probe,
+	.remove = rockchip_hdmiv1_remove,
+	.driver = {
+		.name = "rk-hdmi",
+		.owner = THIS_MODULE,
+		#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(rockchip_hdmiv1_dt_ids),
+		#endif
+	},
+	.shutdown = rockchip_hdmiv1_shutdown,
+};
+
+static int __init rockchip_hdmiv1_init(void)
+{
+	return platform_driver_register(&rockchip_hdmiv1_driver);
+}
+
+static void __exit rockchip_hdmiv1_exit(void)
+{
+	platform_driver_unregister(&rockchip_hdmiv1_driver);
+}
+
+module_init(rockchip_hdmiv1_init);
+module_exit(rockchip_hdmiv1_exit);
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,153 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include "rockchip_hdmiv1.h"
+#include "rockchip_hdmiv1_hw.h"
+#include "../rockchip-hdmi-cec.h"
+
+struct cec_t {
+	wait_queue_head_t wait;
+	int busfree;
+	int tx_done;
+};
+
+static int init = 1;
+static struct cec_t cec;
+
+static int rockchip_hdmiv1_cec_read_frame(struct hdmi *hdmi,
+					  struct cec_framedata *frame)
+{
+	int i, length, val;
+	char *data = (char *)frame;
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	if (!frame)
+		return -1;
+
+	hdmi_readl(hdmi_dev, CEC_RX_LENGTH, &length);
+	hdmi_writel(hdmi_dev, CEC_RX_OFFSET, 0);
+
+	HDMIDBG(1, "CEC: %s length is %d\n", __func__, length);
+	for (i = 0; i < length; i++) {
+		hdmi_readl(hdmi_dev, CEC_DATA, &val);
+		data[i] = val;
+		pr_info("%02x\n", data[i]);
+	}
+	return 0;
+}
+
+static int rockchip_hdmiv1_cec_send_frame(struct hdmi *hdmi,
+					  struct cec_framedata *frame)
+{
+	int i;
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	HDMIDBG(1, "CEC: TX srcdestaddr %x opcode %x ",
+		frame->srcdestaddr, frame->opcode);
+	if (frame->argcount) {
+		HDMIDBG(1, "args:");
+		for (i = 0; i < frame->argcount; i++)
+			HDMIDBG(1, "%02x ", frame->args[i]);
+	}
+	HDMIDBG(1, "\n");
+
+	hdmi_writel(hdmi_dev, CEC_TX_OFFSET, 0);
+	hdmi_writel(hdmi_dev, CEC_DATA, frame->srcdestaddr);
+	hdmi_writel(hdmi_dev, CEC_DATA, frame->opcode);
+
+	for (i = 0; i < frame->argcount; i++)
+		hdmi_writel(hdmi_dev, CEC_DATA, frame->args[i]);
+
+	hdmi_writel(hdmi_dev, CEC_TX_LENGTH, frame->argcount + 2);
+
+	/*Wait for bus free*/
+	cec.busfree = 1;
+	hdmi_writel(hdmi_dev, CEC_CTRL, m_BUSFREETIME_ENABLE);
+	HDMIDBG(1, "start wait bus free\n");
+	if (wait_event_interruptible_timeout(cec.wait,
+					     cec.busfree == 0,
+					     msecs_to_jiffies(17)))
+		return CEC_SEND_BUSY;
+
+	HDMIDBG(1, "end wait bus free,start tx,busfree=%d\n", cec.busfree);
+	/*Start TX*/
+	cec.tx_done = 0;
+	hdmi_writel(hdmi_dev, CEC_CTRL, m_BUSFREETIME_ENABLE | m_START_TX);
+	if (wait_event_interruptible_timeout(cec.wait,
+					     cec.tx_done != 0,
+					     msecs_to_jiffies(100)))
+		hdmi_writel(hdmi_dev, CEC_CTRL, 0);
+	HDMIDBG(1, "end tx,tx_done=%d\n", cec.tx_done);
+
+	if (cec.tx_done == 1) {
+		cec.tx_done = 0;
+		return CEC_SEND_SUCCESS;
+	} else {
+		return CEC_SEND_NACK;
+	}
+}
+
+void rockchip_hdmiv1_cec_setcecla(struct hdmi *hdmi, int ceclgaddr)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	HDMIDBG(1, "CEC: %s\n", __func__);
+	hdmi_writel(hdmi_dev, CEC_LOGICADDR, ceclgaddr);
+}
+
+void rockchip_hdmiv1_cec_isr(struct hdmi_dev *hdmi_dev)
+{
+	int tx_isr = 0, rx_isr = 0;
+
+	hdmi_readl(hdmi_dev, CEC_TX_INT, &tx_isr);
+	hdmi_readl(hdmi_dev, CEC_RX_INT, &rx_isr);
+
+	HDMIDBG(1, "CEC: rockchip_hdmiv1_cec_isr:tx_isr %02x  rx_isr %02x\n\n",
+		tx_isr, rx_isr);
+
+	hdmi_writel(hdmi_dev, CEC_TX_INT, tx_isr);
+	hdmi_writel(hdmi_dev, CEC_RX_INT, rx_isr);
+
+	if (tx_isr & m_TX_BUSNOTFREE) {
+		cec.busfree = 0;
+		HDMIDBG(1, "CEC: m_TX_BUSNOTFREE,busfree=%d\n", cec.busfree);
+	} else if (tx_isr & m_TX_DONE) {
+		cec.tx_done = 1;
+		HDMIDBG(1, "CEC: m_TX_DONE,busfree=%d\n", cec.tx_done);
+	} else {
+		cec.tx_done = -1;
+		HDMIDBG(1, "CEC: else:busfree=%d\n", cec.tx_done);
+	}
+
+	wake_up_interruptible_all(&cec.wait);
+	if (rx_isr & m_RX_DONE)
+		rockchip_hdmi_cec_submit_work(EVENT_RX_FRAME, 0, NULL);
+}
+
+void rockchip_hdmiv1_cec_init(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	if (init) {
+		/*Fref = Fsys / ((register 0xd4 + 1)*(register 0xd5 + 1))*/
+		/*Fref = 0.5M, Fsys = 74.25M*/
+		hdmi_writel(hdmi_dev, CEC_CLK_H, 11);
+		hdmi_writel(hdmi_dev, CEC_CLK_L, 11);
+
+		/*Set bus free time to 16.8ms*/
+		hdmi_writel(hdmi_dev, CEC_BUSFREETIME_L, 0xd0);
+		hdmi_writel(hdmi_dev, CEC_BUSFREETIME_H, 0x20);
+
+		/*Enable TX/RX INT*/
+		hdmi_writel(hdmi_dev, CEC_TX_INT, 0xFF);
+		hdmi_writel(hdmi_dev, CEC_RX_INT, 0xFF);
+
+		HDMIDBG(1, "CEC: rockchip_hdmiv1_cec_init sucess\n");
+		rockchip_hdmi_cec_init(hdmi,
+				       rockchip_hdmiv1_cec_send_frame,
+				       rockchip_hdmiv1_cec_read_frame,
+				       rockchip_hdmiv1_cec_setcecla);
+		init = 0;
+		init_waitqueue_head(&cec.wait);
+	}
+	HDMIDBG(1, "%s", __func__);
+}
+
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_HDMI_V1_H__
+#define __ROCKCHIP_HDMI_V1_H__
+
+#include "../rockchip-hdmi.h"
+
+struct hdmi_dev {
+	void __iomem		*regbase;
+	int			regbase_phy;
+	int			regsize_phy;
+
+	struct clk		*pd;
+	struct clk		*hclk;
+	unsigned int		hclk_rate;
+
+	struct hdmi		*hdmi;
+	struct device		*dev;
+	struct dentry		*debugfs_dir;
+	int			irq;
+
+	struct work_struct	irq_work;
+	struct delayed_work	delay_work;
+	struct workqueue_struct *workqueue;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend	early_suspend;
+#endif
+	int			soctype;
+	int			audiosrc;
+	int			enable;
+	unsigned char		clk_disable;
+	unsigned char		clk_on;
+	spinlock_t		reg_lock;	/* lock for clk */
+
+	unsigned int		tmdsclk;
+	unsigned int		pixelrepeat;
+	int			pwr_mode;
+};
+#endif /* __RK3036_HDMI_H__ */
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,835 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/miscdevice.h>
+#include <linux/workqueue.h>
+#include <linux/firmware.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include "rockchip_hdmiv1.h"
+#include "rockchip_hdmiv1_hdcp.h"
+#include "rockchip_hdmiv1_hw.h"
+
+static struct hdcp *hdcp;
+
+static void hdcp_work_queue(struct work_struct *work);
+
+#define AUTH_TIMEOUT (2 * HZ)
+static struct timer_list auth_timer;
+static int timer_state;
+
+static int is_1b_03_test(struct hdmi_dev *hdmi_dev)
+{
+	int reg_value;
+	int reg_val_1;
+
+	hdmi_readl(hdmi_dev, 0x58, &reg_value);
+	hdmi_readl(hdmi_dev, 0xc3, &reg_val_1);
+
+	if (reg_value != 0) {
+		if ((reg_val_1 & 0x40) == 0)
+			return 1;
+	}
+	return 0;
+}
+
+static void rockchip_hdmiv1_set_colorbar(struct hdmi_dev *hdmi_dev,
+					 int enable)
+{
+	static int display_mask;
+	int reg_value;
+	int tmds_clk;
+
+	tmds_clk = hdmi_dev->tmdsclk;
+	if (enable) {
+		if (!display_mask) {
+			if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2)) {
+				hdmi_readl(hdmi_dev, SYS_CTRL, &reg_value);
+				hdmi_msk_reg(hdmi_dev, SYS_CTRL,
+					     m_REG_CLK_SOURCE,
+					     v_REG_CLK_SOURCE_SYS);
+				hdmi_writel(hdmi_dev, HDMI_COLORBAR, 0x00);
+				hdmi_writel(hdmi_dev, SYS_CTRL, reg_value);
+			} else {
+				hdmi_writel(hdmi_dev, HDMI_COLORBAR, 0x00);
+			}
+			display_mask = 1;
+		}
+	} else {
+		if (display_mask) {
+			if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2)) {
+				hdmi_readl(hdmi_dev, SYS_CTRL, &reg_value);
+				hdmi_msk_reg(hdmi_dev, SYS_CTRL,
+					     m_REG_CLK_SOURCE,
+					     v_REG_CLK_SOURCE_SYS);
+				hdmi_writel(hdmi_dev, HDMI_COLORBAR, 0x10);
+				hdmi_writel(hdmi_dev, SYS_CTRL, reg_value);
+			} else {
+				hdmi_writel(hdmi_dev, HDMI_COLORBAR, 0x10);
+			}
+			display_mask = 0;
+		}
+	}
+}
+
+static void rockchip_hdmiv1_hdcp_disable(struct hdmi_dev *hdmi_dev)
+{
+	int reg_value;
+	int tmds_clk;
+
+	tmds_clk = hdmi_dev->tmdsclk;
+	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2)) {
+		hdmi_readl(hdmi_dev, SYS_CTRL, &reg_value);
+		hdmi_msk_reg(hdmi_dev, SYS_CTRL,
+			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
+	}
+
+	/* Disable HDCP Interrupt */
+	hdmi_writel(hdmi_dev, HDCP_INT_MASK1, 0x00);
+	/* Stop and Reset HDCP*/
+	hdmi_msk_reg(hdmi_dev, HDCP_CTRL1,
+		     m_AUTH_START | m_AUTH_STOP | m_HDCP_RESET,
+		     v_AUTH_START(0) | v_AUTH_STOP(1) | v_HDCP_RESET(1));
+
+	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2))
+		hdmi_writel(hdmi_dev, SYS_CTRL, reg_value);
+}
+
+static int rockchip_hdmiv1_hdcp_key_check(struct hdcp_keys *key)
+{
+	int i = 0;
+
+	HDMIDBG(3, "HDCP: check hdcp key\n");
+	/*check 40 private key */
+	for (i = 0; i < HDCP_PRIVATE_KEY_SIZE; i++) {
+		if (key->devicekey[i] != 0x00)
+			return HDCP_KEY_VALID;
+	}
+	/*check aksv*/
+	for (i = 0; i < 5; i++) {
+		if (key->ksv[i] != 0x00)
+			return HDCP_KEY_VALID;
+	}
+
+	return HDCP_KEY_INVALID;
+}
+
+static int rockchip_hdmiv1_hdcp_load_key2mem(void)
+{
+	int i;
+	struct hdmi_dev *hdmi_dev;
+	struct hdcp_keys *key;
+
+	if (!hdcp)
+		return -1;
+	hdmi_dev = hdcp->hdmi_dev;
+	key = hdcp->keys;
+	HDMIDBG(3, "HDCP: rockchip_hdmiv1_hdcp_load_key2mem start\n");
+	/* Write 40 private key*/
+	for (i = 0; i < HDCP_PRIVATE_KEY_SIZE; i++)
+		hdmi_writel(hdmi_dev, HDCP_KEY_FIFO, key->devicekey[i]);
+	/* Write 1st aksv*/
+	for (i = 0; i < 5; i++)
+		hdmi_writel(hdmi_dev, HDCP_KEY_FIFO, key->ksv[i]);
+	/* Write 2nd aksv*/
+	for (i = 0; i < 5; i++)
+		hdmi_writel(hdmi_dev, HDCP_KEY_FIFO, key->ksv[i]);
+	HDMIDBG(3, "HDCP: rockchip_hdmiv1_hdcp_load_key2mem end\n");
+	return HDCP_OK;
+}
+
+static int rockchip_hdmiv1_hdcp_start_authentication(struct hdmi_dev *hdmi_dev)
+{
+	int temp;
+	int retry = 0;
+	int tmds_clk;
+
+	tmds_clk = hdmi_dev->tmdsclk;
+	if (!hdcp->keys) {
+		HDCP_WARN("HDCP: key is not loaded\n");
+		return HDCP_KEY_ERR;
+	}
+	if (rockchip_hdmiv1_hdcp_key_check(hdcp->keys) == HDCP_KEY_INVALID) {
+		HDCP_WARN("loaded HDCP key is incorrect\n");
+		return HDCP_KEY_ERR;
+	}
+	if (tmds_clk > (HDMI_SYS_FREG_CLK << 2)) {
+		/*Select TMDS CLK to configure regs*/
+		hdmi_msk_reg(hdmi_dev, SYS_CTRL,
+			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_TMDS);
+	} else {
+		hdmi_msk_reg(hdmi_dev, SYS_CTRL,
+			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
+	}
+	hdmi_writel(hdmi_dev, HDCP_TIMER_100MS, 0x28);
+	hdmi_readl(hdmi_dev, HDCP_KEY_STATUS, &temp);
+	while ((temp & m_KEY_READY) == 0) {
+		if (retry > 1000) {
+			HDCP_WARN("HDCP: loaded key error\n");
+			return HDCP_KEY_ERR;
+		}
+		rockchip_hdmiv1_hdcp_load_key2mem();
+		usleep_range(900, 1000);
+		hdmi_readl(hdmi_dev, HDCP_KEY_STATUS, &temp);
+		retry++;
+	}
+	/*Config DDC bus clock: ddc_clk = reg_clk/4*(reg 0x4c 0x4b)*/
+	retry = hdmi_dev->hclk_rate / (HDCP_DDC_CLK << 2);
+	hdmi_writel(hdmi_dev, DDC_CLK_L, retry & 0xFF);
+	hdmi_writel(hdmi_dev, DDC_CLK_H, (retry >> 8) & 0xFF);
+	hdmi_writel(hdmi_dev, HDCP_CTRL2, 0x67);
+	/*Enable interrupt*/
+	hdmi_writel(hdmi_dev, HDCP_INT_MASK1,
+		    m_INT_HDCP_ERR | m_INT_BKSV_READY | m_INT_BKSV_UPDATE |
+		    m_INT_AUTH_SUCCESS | m_INT_AUTH_READY);
+	hdmi_writel(hdmi_dev, HDCP_INT_MASK2, 0x00);
+	/*Start authentication*/
+	hdmi_msk_reg(hdmi_dev, HDCP_CTRL1,
+		     m_AUTH_START | m_ENCRYPT_ENABLE | m_ADVANED_ENABLE |
+		     m_AUTH_STOP | m_HDCP_RESET,
+		     v_AUTH_START(1) | v_ENCRYPT_ENABLE(1) |
+		     v_ADVANED_ENABLE(0) | v_AUTH_STOP(0) | v_HDCP_RESET(0));
+
+	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2)) {
+		hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_REG_CLK_SOURCE,
+			     v_REG_CLK_SOURCE_TMDS);
+	}
+	return HDCP_OK;
+}
+
+static int rockchip_hdmiv1_hdcp_stop_authentication(struct hdmi_dev *hdmi_dev)
+{
+	hdmi_msk_reg(hdmi_dev, SYS_CTRL,
+		     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
+	hdmi_writel(hdmi_dev, DDC_CLK_L, 0x1c);
+	hdmi_writel(hdmi_dev, DDC_CLK_H, 0x00);
+	hdmi_writel(hdmi_dev, HDCP_CTRL2, 0x08);
+	hdmi_writel(hdmi_dev, HDCP_INT_MASK2, 0x06);
+	hdmi_writel(hdmi_dev, HDCP_CTRL1, 0x02);
+	return 0;
+	/*hdmi_writel(HDCP_CTRL1, 0x0a);*/
+}
+
+static int rockchip_hdmiv1_hdcp_error(int value)
+{
+	if (value & 0x80)
+		HDCP_WARN("Timed out waiting for downstream repeater\n");
+	else if (value & 0x40)
+		HDCP_WARN("Too many devices connected to repeater tree\n");
+	else if (value & 0x20)
+		HDCP_WARN("SHA-1 hash check of BKSV list failed\n");
+	else if (value & 0x10)
+		HDCP_WARN("SHA-1 hash check of BKSV list failed\n");
+	else if (value & 0x08)
+		HDCP_WARN("DDC channels no acknowledge\n");
+	else if (value & 0x04)
+		HDCP_WARN("Pj mismatch\n");
+	else if (value & 0x02)
+		HDCP_WARN("Ri mismatch\n");
+	else if (value & 0x01)
+		HDCP_WARN("Bksv is wrong\n");
+	else
+		return 0;
+	return 1;
+}
+
+static void rockchip_hdmiv1_hdcp_interrupt(struct hdmi_dev *hdmi_dev,
+					   char *status1, char *status2)
+{
+	int interrupt1 = 0;
+	int interrupt2 = 0;
+	int temp = 0;
+	int tmds_clk;
+
+	tmds_clk = hdmi_dev->tmdsclk;
+	hdmi_readl(hdmi_dev, HDCP_INT_STATUS1, &interrupt1);
+	hdmi_readl(hdmi_dev, HDCP_INT_STATUS2, &interrupt2);
+
+	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2))
+		hdmi_msk_reg(hdmi_dev, SYS_CTRL,
+			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
+
+	if (interrupt1) {
+		hdmi_writel(hdmi_dev, HDCP_INT_STATUS1, interrupt1);
+		if (interrupt1 & m_INT_HDCP_ERR) {
+			hdmi_readl(hdmi_dev, HDCP_ERROR, &temp);
+			HDCP_WARN("HDCP: Error reg 0x65 = 0x%02x\n", temp);
+			rockchip_hdmiv1_hdcp_error(temp);
+			hdmi_writel(hdmi_dev, HDCP_ERROR, temp);
+		}
+	}
+	if (interrupt2)
+		hdmi_writel(hdmi_dev, HDCP_INT_STATUS2, interrupt2);
+
+	*status1 = interrupt1;
+	*status2 = interrupt2;
+
+	if (tmds_clk <= (HDMI_SYS_FREG_CLK << 2))
+		hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_REG_CLK_SOURCE,
+			     v_REG_CLK_SOURCE_TMDS);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_submit_work
+ *-----------------------------------------------------------------------------
+ */
+static struct delayed_work *hdcp_submit_work(int event, int delay)
+{
+	struct hdcp_delayed_work *work;
+
+	HDMIDBG(3, "%s event %04x delay %d\n", __func__, event, delay);
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+
+	if (work) {
+		INIT_DELAYED_WORK(&work->work, hdcp_work_queue);
+		work->event = event;
+		queue_delayed_work(hdcp->workqueue,
+				   &work->work,
+				   msecs_to_jiffies(delay));
+	} else {
+		HDCP_WARN("HDCP:Cannot allocate memory to create work\n");
+		return 0;
+	}
+
+	return &work->work;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_cancel_work
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_cancel_work(struct delayed_work **work)
+{
+	int ret = 0;
+
+	if (*work) {
+		ret = cancel_delayed_work(*work);
+		if (ret != 1) {
+			ret = cancel_work_sync(&((*work)->work));
+			HDCP_WARN("Canceling sync work failed %d\n", ret);
+		}
+		kfree(*work);
+		*work = 0;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: auth_timer_func
+ *-----------------------------------------------------------------------------
+ */
+static void auth_timer_func(unsigned long data)
+{
+	HDCP_WARN("hdcp auth 2 second timeout\n");
+	if (hdcp->auth_state == 0) {
+		mod_timer(&auth_timer, jiffies + AUTH_TIMEOUT);
+		if ((hdcp->hdcp_state != HDCP_DISABLED) &&
+		    (hdcp->hdcp_state != HDCP_ENABLE_PENDING)) {
+			if (is_1b_03_test(hdcp->hdmi_dev))
+				return;
+			hdcp_submit_work(HDCP_FAIL_EVENT, 0);
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_authentication_failure
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_authentication_failure(void)
+{
+	if (hdcp->hdmi_state == HDMI_STOPPED)
+		return;
+
+	rockchip_hdmiv1_hdcp_disable(hdcp->hdmi_dev);
+
+	/* rockchip_hdmiv1_hdmi_control_output(false); */
+
+	rockchip_hdmiv1_set_colorbar(hdcp->hdmi_dev, 1);
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+	if (hdcp->retry_cnt && (hdcp->hdmi_state != HDMI_STOPPED)) {
+		if (hdcp->retry_cnt <= HDCP_INFINITE_REAUTH) {
+			hdcp->retry_cnt--;
+			HDCP_WARN("authentication failed attempts=%d\n",
+				  hdcp->retry_cnt);
+		} else {
+			HDCP_WARN("authentication failed retrying\n");
+		}
+		hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
+
+		if (hdcp->auth_state == 1 && timer_state == 0) {
+			HDMIDBG(3, "add auth timer\n");
+			hdcp->auth_state = 0;
+			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+			auth_timer.expires = jiffies + AUTH_TIMEOUT;
+			add_timer(&auth_timer);
+			timer_state = 1;
+		}
+
+		hdcp->pending_wq_event = hdcp_submit_work(HDCP_AUTH_REATT_EVENT,
+							 HDCP_REAUTH_DELAY);
+	} else {
+		HDCP_WARN("authentication failed HDCP disabled\n");
+		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+
+		if (timer_state == 1) {
+			HDMIDBG(3, "delete auth timer\n");
+			del_timer_sync(&auth_timer);
+			timer_state = 0;
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_start_authentication
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_start_authentication(void)
+{
+	int status = HDCP_OK;
+
+	hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
+	HDMIDBG(3, "HDCP: authentication start\n");
+	status = rockchip_hdmiv1_hdcp_start_authentication(hdcp->hdmi_dev);
+	if (status != HDCP_OK) {
+		HDMIDBG(3, "HDCP: authentication failed\n");
+		hdcp_wq_authentication_failure();
+	} else {
+		/*hdcp->hdcp_state = HDCP_WAIT_KSV_LIST;*/
+		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
+	}
+}
+
+#if 0
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_check_bksv
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_check_bksv(void)
+{
+	int status = HDCP_OK;
+
+	DBG("Check BKSV start");
+	status = rockchip_hdmiv1_hdcp_check_bksv();
+	if (status != HDCP_OK) {
+		HDCP_WARN("HDCP: Check BKSV failed");
+		hdcp->retry_cnt = 0;
+		hdcp_wq_authentication_failure();
+	} else {
+		DBG("HDCP: Check BKSV successful");
+		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
+		/* Restore retry counter */
+		if (hdcp->retry_times == 0)
+			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+		else
+			hdcp->retry_cnt = hdcp->retry_times;
+	}
+}
+#endif
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_authentication_success
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_authentication_success(void)
+{
+	hdcp->auth_state = 1;
+	if (timer_state == 1) {
+		HDMIDBG(3, "delete auth timer\n");
+		timer_state = 0;
+		del_timer_sync(&auth_timer);
+	}
+
+	rockchip_hdmiv1_set_colorbar(hdcp->hdmi_dev, 0);
+	HDCP_WARN("HDCP: authentication pass\n");
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_disable
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_disable(int event)
+{
+	HDCP_WARN("HDCP: disabled\n");
+
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+	rockchip_hdmiv1_hdcp_disable(hdcp->hdmi_dev);
+	if (event == HDCP_DISABLE_CTL) {
+		hdcp->hdcp_state = HDCP_DISABLED;
+		if (hdcp->hdmi_state == HDMI_STARTED)
+			rockchip_hdmiv1_set_colorbar(hdcp->hdmi_dev, 0);
+	} else if (event == HDCP_STOP_FRAME_EVENT) {
+		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_work_queue
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_work_queue(struct work_struct *work)
+{
+	struct hdcp_delayed_work *hdcp_w =
+		container_of(work, struct hdcp_delayed_work, work.work);
+	int event = hdcp_w->event;
+
+	mutex_lock(&hdcp->lock);
+	HDMIDBG(3, "%s - START - %u hdmi=%d hdcp=%d evt= %x %d\n",
+		__func__,
+		jiffies_to_msecs(jiffies),
+		hdcp->hdmi_state,
+		hdcp->hdcp_state,
+		(event & 0xFF00) >> 8,
+		event & 0xFF);
+
+	if (event == HDCP_STOP_FRAME_EVENT)
+		hdcp->hdmi_state = HDMI_STOPPED;
+	if (event == HDCP_DISABLE_CTL || event == HDCP_STOP_FRAME_EVENT)
+		hdcp_wq_disable(event);
+	if (event & HDCP_WORKQUEUE_SRC)
+		hdcp->pending_wq_event = 0;
+	/* First handle HDMI state */
+	if (event == HDCP_START_FRAME_EVENT) {
+		hdcp->pending_start = 0;
+		hdcp->hdmi_state = HDMI_STARTED;
+	}
+
+	/**********************/
+	/* HDCP state machine */
+	/**********************/
+	switch (hdcp->hdcp_state) {
+	case HDCP_DISABLED:
+		/* HDCP enable control or re-authentication event */
+		if (event == HDCP_ENABLE_CTL) {
+			#if 0
+			if (hdcp->retry_times == 0)
+				hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+			else
+				hdcp->retry_cnt = hdcp->retry_times;
+			#endif
+			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+			if (hdcp->hdmi_state == HDMI_STARTED)
+				hdcp_wq_start_authentication();
+			else
+				hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+		}
+		break;
+	case HDCP_ENABLE_PENDING:
+		/* HDMI start frame event */
+		if (event == HDCP_START_FRAME_EVENT)
+			hdcp_wq_start_authentication();
+		break;
+	case HDCP_AUTHENTICATION_START:
+		/* Re-authentication */
+		if (event == HDCP_AUTH_REATT_EVENT)
+			hdcp_wq_start_authentication();
+		break;
+#if 0
+	case HDCP_WAIT_KSV_LIST:
+		/* KSV failure */
+		if (event == HDCP_FAIL_EVENT) {
+			HDCP_WARN("HDCP: KSV switch failure\n");
+			hdcp_wq_authentication_failure();
+		}
+		/* KSV list ready event */
+		else if (event == HDCP_KSV_LIST_RDY_EVENT)
+			hdcp_wq_check_bksv();
+		break;
+#endif
+	case HDCP_LINK_INTEGRITY_CHECK:
+		/* authentication failure */
+		if (event == HDCP_FAIL_EVENT) {
+			HDCP_WARN("HDCP: Ri check failure\n");
+			hdcp_wq_authentication_failure();
+		} else if (event == HDCP_AUTH_PASS_EVENT) {
+			hdcp_wq_authentication_success();
+		}
+		break;
+	default:
+		HDCP_WARN("HDCP: error - unknown HDCP state\n");
+		break;
+	}
+	kfree(hdcp_w);
+	if (event == HDCP_STOP_FRAME_EVENT)
+		complete(&hdcp->complete);
+	mutex_unlock(&hdcp->lock);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_start_frame_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_start_frame_cb(struct hdmi *hdmi)
+{
+	HDMIDBG(3, "hdcp_start_frame_cb()\n");
+
+	/* Cancel any pending work */
+	if (hdcp->pending_start)
+		hdcp_cancel_work(&hdcp->pending_start);
+	if (hdcp->pending_wq_event)
+		hdcp_cancel_work(&hdcp->pending_wq_event);
+
+	if (timer_state == 0) {
+		HDMIDBG(3, "add auth timer\n");
+		auth_timer.expires = jiffies + AUTH_TIMEOUT;
+		add_timer(&auth_timer);
+		timer_state = 1;
+	}
+
+	hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+	hdcp->pending_start = hdcp_submit_work(HDCP_START_FRAME_EVENT,
+					       HDCP_ENABLE_DELAY);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_irq_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_irq_cb(int status)
+{
+	char interrupt1;
+	char interrupt2;
+
+	rockchip_hdmiv1_hdcp_interrupt(hdcp->hdmi_dev,
+				       &interrupt1,
+				       &interrupt2);
+	HDMIDBG(3, "%s 0x%02x 0x%02x\n", __func__, interrupt1, interrupt2);
+	if (interrupt1 & m_INT_HDCP_ERR) {
+		if ((hdcp->hdcp_state != HDCP_DISABLED) &&
+		    (hdcp->hdcp_state != HDCP_ENABLE_PENDING))
+			hdcp_submit_work(HDCP_FAIL_EVENT, 0);
+	}
+	#if 0
+	else if (interrupt1 & (m_INT_BKSV_READY | m_INT_BKSV_UPDATE))
+		hdcp_submit_work(HDCP_KSV_LIST_RDY_EVENT, 0);
+	#endif
+	else if (interrupt1 & m_INT_AUTH_SUCCESS)
+		hdcp_submit_work(HDCP_AUTH_PASS_EVENT, 0);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_power_on_cb
+ *-----------------------------------------------------------------------------
+ */
+static int hdcp_power_on_cb(void)
+{
+	HDMIDBG(3, "%s", __func__);
+	return rockchip_hdmiv1_hdcp_load_key2mem();
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_power_off_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_power_off_cb(struct hdmi *hdmi)
+{
+	unsigned int time;
+
+	HDMIDBG(3, "%s\n", __func__);
+	if (timer_state == 1) {
+		HDMIDBG(3, "delete auth timer\n");
+		timer_state = 0;
+		del_timer_sync(&auth_timer);
+	}
+	hdcp->auth_state = 0;
+
+	if (!hdcp->enable)
+		return;
+	rockchip_hdmiv1_hdcp_stop_authentication(hdcp->hdmi_dev);
+	hdcp_cancel_work(&hdcp->pending_start);
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+	init_completion(&hdcp->complete);
+	/* Post event to workqueue */
+	time = msecs_to_jiffies(5000);
+	if (hdcp_submit_work(HDCP_STOP_FRAME_EVENT, 0))
+		wait_for_completion_interruptible_timeout(&hdcp->complete,
+							  time);
+}
+
+/*
+ * Load HDCP key to external HDCP memory
+ */
+static void hdcp_load_keys_cb(const struct firmware *fw, void *context)
+{
+	if (!fw) {
+		pr_err("HDCP: failed to load keys\n");
+		return;
+	}
+	if (fw->size < HDCP_KEY_SIZE) {
+		pr_err("HDCP: firmware wrong size %d\n", (int)fw->size);
+		return;
+	}
+	hdcp->keys =  kmalloc(HDCP_KEY_SIZE, GFP_KERNEL);
+	if (!hdcp->keys)
+		return;
+	memcpy(hdcp->keys, fw->data, HDCP_KEY_SIZE);
+	HDCP_WARN("HDCP: load hdcp key success\n");
+
+	if (fw->size > HDCP_KEY_SIZE) {
+		HDMIDBG(3, "%s invalid key size %d\n", __func__,
+			(int)fw->size - HDCP_KEY_SIZE);
+		if ((fw->size - HDCP_KEY_SIZE) % 5) {
+			pr_err("HDCP: failed to load invalid keys\n");
+			return;
+		}
+		hdcp->invalidkeys =
+			kmalloc(fw->size - HDCP_KEY_SIZE, GFP_KERNEL);
+		if (!hdcp->invalidkeys) {
+			pr_err("HDCP: can't allocated space for invalid keys\n");
+			return;
+		}
+		memcpy(hdcp->invalidkeys, fw->data +
+		       HDCP_KEY_SIZE, fw->size - HDCP_KEY_SIZE);
+		hdcp->invalidkey = (fw->size - HDCP_KEY_SIZE) / 5;
+		HDCP_WARN("HDCP: loaded hdcp invalid key success\n");
+	}
+}
+
+static ssize_t hdcp_enable_read(struct device *device,
+				struct device_attribute *attr,
+				char *buf)
+{
+	int enable = 0;
+
+	if (hdcp)
+		enable = hdcp->enable;
+	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
+}
+
+static ssize_t hdcp_enable_write(struct device *device,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	int enable;
+
+	if (!hdcp)
+		return -EINVAL;
+	if (kstrtoint(buf, 0, &enable))
+		return -EINVAL;
+	if (hdcp->enable != enable) {
+		/* Post event to workqueue */
+		if (enable) {
+			if (hdcp_submit_work(HDCP_ENABLE_CTL, 0) == 0)
+				return -EFAULT;
+		} else {
+			hdcp_cancel_work(&hdcp->pending_start);
+			hdcp_cancel_work(&hdcp->pending_wq_event);
+
+			/* Post event to workqueue */
+			if (hdcp_submit_work(HDCP_DISABLE_CTL, 0) == 0)
+				return -EFAULT;
+		}
+		hdcp->enable = enable;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR,
+			 hdcp_enable_read, hdcp_enable_write);
+
+static ssize_t hdcp_trytimes_read(struct device *device,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	int trytimes = 0;
+
+	if (hdcp)
+		trytimes = hdcp->retry_times;
+	return snprintf(buf, PAGE_SIZE, "%d\n", trytimes);
+}
+
+static ssize_t hdcp_trytimes_wrtie(struct device *device,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	int trytimes;
+
+	if (!hdcp)
+		return -EINVAL;
+	if (kstrtoint(buf, 0, &trytimes))
+		return -EINVAL;
+	if (hdcp->retry_times != trytimes)
+		hdcp->retry_times = trytimes;
+	return count;
+}
+
+static DEVICE_ATTR(trytimes, S_IRUGO | S_IWUSR,
+			 hdcp_trytimes_read, hdcp_trytimes_wrtie);
+static struct miscdevice mdev;
+
+int rockchip_hdmiv1_hdcp_init(struct hdmi *hdmi)
+{
+	int ret;
+
+	HDMIDBG(3, "[%s]\n", __func__);
+	if (hdcp)
+		return 0;
+
+	hdcp = kmalloc(sizeof(*hdcp), GFP_KERNEL);
+	if (!hdcp) {
+		HDCP_WARN(">>HDCP: kmalloc fail!\n");
+		ret = -ENOMEM;
+		goto error0;
+	}
+	memset(hdcp, 0, sizeof(struct hdcp));
+	mutex_init(&hdcp->lock);
+	mdev.minor = MISC_DYNAMIC_MINOR;
+	mdev.name = "hdcp";
+	mdev.mode = 0666;
+	if (misc_register(&mdev)) {
+		HDCP_WARN("HDCP: Could not add character driver\n");
+		ret = HDMI_ERROR_FALSE;
+		goto error1;
+	}
+	ret = device_create_file(mdev.this_device, &dev_attr_enable);
+	if (ret) {
+		HDCP_WARN("HDCP: Could not add sys file enable\n");
+		ret = -EINVAL;
+		goto error2;
+	}
+	ret = device_create_file(mdev.this_device, &dev_attr_trytimes);
+	if (ret) {
+		HDCP_WARN("HDCP: Could not add sys file trytimes\n");
+		ret = -EINVAL;
+			goto error3;
+	}
+	hdcp->workqueue = create_singlethread_workqueue("hdcp");
+	if (!hdcp->workqueue) {
+		HDCP_WARN("HDCP,: create workqueue failed.\n");
+		goto error4;
+	}
+	ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG,
+				      "hdcp", mdev.this_device,
+				      GFP_KERNEL, hdcp,
+				      hdcp_load_keys_cb);
+	if (ret < 0) {
+		HDCP_WARN("HDCP: request_firmware_nowait failed: %d\n", ret);
+		goto error5;
+	}
+	hdcp->hdmi_dev = hdmi->property->priv;
+	hdmi->ops->hdcp_cb = hdcp_start_frame_cb;
+	hdmi->ops->hdcp_irq_cb = hdcp_irq_cb;
+	hdmi->ops->hdcp_power_on_cb = hdcp_power_on_cb;
+	hdmi->ops->hdcp_power_off_cb = hdcp_power_off_cb;
+
+	init_timer(&auth_timer);
+	auth_timer.data = 0;
+	auth_timer.function = auth_timer_func;
+	HDMIDBG(3, "%s success\n", __func__);
+	return 0;
+error5:
+	destroy_workqueue(hdcp->workqueue);
+error4:
+	device_remove_file(mdev.this_device, &dev_attr_trytimes);
+error3:
+	device_remove_file(mdev.this_device, &dev_attr_enable);
+error2:
+	misc_deregister(&mdev);
+error1:
+	kfree(hdcp->keys);
+	kfree(hdcp->invalidkeys);
+	kfree(hdcp);
+error0:
+	return ret;
+}
+
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,187 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_HDMIV1_HDCP_H__
+#define __ROCKCHIP_HDMIV1_HDCP_H__
+
+/***************************/
+/* Definitions             */
+/***************************/
+
+/* Status / error codes */
+#define HDCP_OK			0
+#define HDCP_KEY_ERR		1
+#define HDCP_KSV_ERR		2
+#define HDCP_KEY_VALID		3
+#define HDCP_KEY_INVALID	4
+
+/* Delays */
+#define HDCP_ENABLE_DELAY	300
+#define HDCP_REAUTH_DELAY	100
+
+/* Event source */
+#define HDCP_SRC_SHIFT		8
+#define HDCP_IOCTL_SRC		(0x1 << HDCP_SRC_SHIFT)
+#define HDCP_HDMI_SRC		(0x2 << HDCP_SRC_SHIFT)
+#define HDCP_IRQ_SRC		(0x4 << HDCP_SRC_SHIFT)
+#define HDCP_WORKQUEUE_SRC	(0x8 << HDCP_SRC_SHIFT)
+
+/* Event */
+#define HDCP_ENABLE_CTL		(HDCP_IOCTL_SRC	| 0)
+#define HDCP_DISABLE_CTL	(HDCP_IOCTL_SRC	| 1)
+#define HDCP_START_FRAME_EVENT	(HDCP_HDMI_SRC	| 2)
+#define HDCP_STOP_FRAME_EVENT	(HDCP_HDMI_SRC	| 3)
+#define HDCP_KSV_LIST_RDY_EVENT	(HDCP_IRQ_SRC	| 4)
+#define HDCP_FAIL_EVENT		(HDCP_IRQ_SRC	| 5)
+#define HDCP_AUTH_PASS_EVENT	(HDCP_IRQ_SRC	| 6)
+#define HDCP_AUTH_REATT_EVENT	(HDCP_WORKQUEUE_SRC | 7)
+
+/* Key size */
+#define HDCP_KEY_SIZE			308
+
+/* HDCP DDC Clock */
+#define HDCP_DDC_CLK			100000
+
+/* Authentication retry times */
+#define HDCP_INFINITE_REAUTH	0x100
+
+/* HDCP Regs */
+#define HDCP_CTRL1				0x52
+	#define m_AUTH_START		BIT(7)
+	#define m_BKSV_VALID		BIT(6)
+	#define m_BKSV_INVALID		BIT(5)
+	#define m_ENCRYPT_ENABLE	BIT(4)
+	#define m_AUTH_STOP		BIT(3)
+	#define m_ADVANED_ENABLE	BIT(2)
+	#define m_HDMI_DVI		BIT(1)
+	#define m_HDCP_RESET		BIT(0)
+
+	#define v_AUTH_START(n)		(n << 7)
+	#define v_BKSV_VALID(n)		(n << 6)
+	#define v_BKSV_INVALID(n)	(n << 5)
+	#define v_ENCRYPT_ENABLE(n)	(n << 4)
+	#define v_AUTH_STOP(n)		(n << 3)
+	#define v_ADVANED_ENABLE(n)	(n << 2)
+	#define v_HDMI_DVI(n)		(n << 1)
+	#define v_HDCP_RESET(n)		(n << 0)
+
+#define HDCP_CTRL2				0x53
+	#define m_DISABLE_127_CHECK			BIT(7)
+	#define m_SKIP_BKSV_CHECK			BIT(6)
+	#define m_ENABLE_PJ_CHECK			BIT(5)
+	#define m_DISABLE_DEVICE_NUMBER_CHECK		BIT(4)
+	#define m_DELAY_RI_1_CLK			BIT(3)
+	#define m_USE_PRESET_AN				BIT(2)
+	#define m_KEY_COMBINATION			(BIT(1) | BIT(0))
+
+	#define v_DISABLE_127_CHECK(n)			(n << 7)
+	#define v_SKIP_BKSV_CHECK(n)			(n << 6)
+	#define v_ENABLE_PJ_CHECK(n)			(n << 5)
+	#define v_DISABLE_DEVICE_NUMBER_CHECK(n)(n << 4)
+	#define v_DELAY_RI_1_CLK(n)				(n << 3)
+	#define v_USE_PRESET_AN(n)				(n << 2)
+	#define v_KEY_COMBINATION(n)			(n << 0)
+
+#define HDCP_KEY_STATUS			0x54
+	#define m_KEY_READY			BIT(0)
+
+#define HDCP_CTRL_SOFT			0x57
+	#define m_DISABLE_127_CHECK			BIT(7)
+	#define m_SKIP_BKSV_CHECK			BIT(6)
+	#define m_NOT_AUTHENTICATED			BIT(5)
+	#define m_ENCRYPTED				BIT(4)
+	#define m_ADVANCED_CIPHER			BIT(3)
+
+#define HDCP_BCAPS_RX			0x58
+#define HDCP_TIMER_100MS		0x63
+#define HDCP_TIMER_5S			0x64
+#define HDCP_ERROR				0x65
+	#define m_DDC_NO_ACK		BIT(3)
+	#define m_PJ_MISMACH		BIT(2)
+	#define m_RI_MISMACH		BIT(1)
+	#define m_BKSV_WRONG		BIT(0)
+
+#define HDCP_KSV_BYTE0			0x66
+#define HDCP_KSV_BYTE1			0x67
+#define HDCP_KSV_BYTE2			0x68
+#define HDCP_KSV_BYTE3			0x69
+#define HDCP_KSV_BYTE4			0x6a
+
+#define HDCP_AN_SEED			0x6c
+
+#define HDCP_BCAPS_TX			0x80
+#define HDCP_BSTATE_0			0x81
+#define HDCP_BSTATE_1			0x82
+
+#define HDCP_KEY_FIFO			0x98
+
+#define HDCP_INT_MASK1			0xc2
+#define HDCP_INT_STATUS1		0xc3
+	#define m_INT_HDCP_ERR		BIT(7)
+	#define m_INT_BKSV_READY	BIT(6)
+	#define m_INT_BKSV_UPDATE	BIT(5)
+	#define m_INT_AUTH_SUCCESS	BIT(4)
+	#define m_INT_AUTH_READY	BIT(3)
+
+#define HDCP_INT_MASK2			0xc4
+#define HDCP_INT_STATUS2		0xc5
+	#define m_INT_SOFT_MODE_READY			BIT(7)
+	#define m_INT_AUTH_M0_REDAY			BIT(6)
+	#define m_INT_1st_FRAME_ARRIVE			BIT(5)
+	#define m_INT_AN_READY				BIT(4)
+	#define m_INT_ENCRYPTED				BIT(2)
+	#define m_INT_NOT_ENCRYPTED_AVMUTE		BIT(1)
+	#define m_INT_NOT_ENCRYPTED_AVUNMUTE	BIT(0)
+
+enum hdcp_states {
+	HDCP_DISABLED,
+	HDCP_ENABLE_PENDING,
+	HDCP_AUTHENTICATION_START,
+	HDCP_WAIT_KSV_LIST,
+	HDCP_LINK_INTEGRITY_CHECK,
+};
+
+enum hdmi_states {
+	HDMI_STOPPED,
+	HDMI_STARTED
+};
+
+#define HDCP_PRIVATE_KEY_SIZE	280
+#define HDCP_KEY_SHA_SIZE		20
+
+struct hdcp_keys {
+	u8 ksv[8];
+	u8 devicekey[HDCP_PRIVATE_KEY_SIZE];
+	u8 sha1[HDCP_KEY_SHA_SIZE];
+};
+
+struct hdcp_delayed_work {
+	struct delayed_work work;
+	int event;
+};
+
+struct hdcp {
+	int	enable;
+	int retry_times;
+	struct hdcp_keys *keys;
+	int invalidkey;
+	char *invalidkeys;
+	struct mutex lock;	/* use for workqueue */
+	struct completion	complete;
+	struct workqueue_struct *workqueue;
+
+	enum hdmi_states hdmi_state;
+	enum hdcp_states hdcp_state;
+
+	struct delayed_work *pending_start;
+	struct delayed_work *pending_wq_event;
+	int retry_cnt;
+	int auth_state;
+	struct hdmi_dev *hdmi_dev;
+};
+
+#if 1
+#define HDCP_WARN(x...) pr_warn(x)
+#else
+#define I2S_DBG(x...) do { } while (0)
+#endif
+int	rockchip_hdmiv1_hdcp_init(struct hdmi *hdmi);
+#endif /* __ROCKCHIP_HDMIV1_HDCP_H__ */
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,995 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/of_irq.h>
+#include "rockchip_hdmiv1.h"
+#include "rockchip_hdmiv1_hw.h"
+#include "rockchip_hdmiv1_hdcp.h"
+
+static inline void delay100us(void)
+{
+	usleep_range(99, 100);
+}
+
+static void rockchip_hdmiv1_av_mute(struct hdmi *hdmi_drv, bool enable)
+{
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	if (enable) {
+		hdmi_msk_reg(hdmi_dev, AV_MUTE,
+			     m_AVMUTE_CLEAR | m_AVMUTE_ENABLE,
+			     v_AVMUTE_CLEAR(0) | v_AVMUTE_ENABLE(1));
+	} else {
+		hdmi_msk_reg(hdmi_dev, AV_MUTE,
+			     m_AVMUTE_CLEAR | m_AVMUTE_ENABLE,
+			     v_AVMUTE_CLEAR(1) | v_AVMUTE_ENABLE(0));
+	}
+	hdmi_msk_reg(hdmi_dev, PACKET_SEND_AUTO,
+		     m_PACKET_GCP_EN, v_PACKET_GCP_EN(1));
+}
+
+static void rockchip_hdmiv1_sys_power(struct hdmi *hdmi_drv, bool enable)
+{
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	if (enable)
+		hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_POWER, v_PWR_ON);
+	else
+		hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_POWER, v_PWR_OFF);
+}
+
+static void rockchip_hdmiv1_set_pwr_mode(struct hdmi *hdmi_drv, int mode)
+{
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	if (hdmi_dev->pwr_mode == mode)
+		return;
+
+	dev_info(hdmi_drv->dev, "%s change pwr_mode %d --> %d\n", __func__,
+		 hdmi_dev->pwr_mode, mode);
+
+	switch (mode) {
+	case NORMAL:
+		dev_info(hdmi_drv->dev,
+			 "%s change pwr_mode NORMAL\n",
+			 __func__);
+		rockchip_hdmiv1_sys_power(hdmi_drv, false);
+		if (hdmi_dev->soctype == HDMI_SOC_RK3036) {
+			hdmi_writel(hdmi_dev, PHY_PRE_EMPHASIS, 0x6f);
+			hdmi_writel(hdmi_dev, PHY_DRIVER, 0xbb);
+		} else if (hdmi_dev->soctype == HDMI_SOC_RK312X) {
+			hdmi_writel(hdmi_dev, PHY_PRE_EMPHASIS, 0x5f);
+			hdmi_writel(hdmi_dev, PHY_DRIVER, 0xaa);
+		}
+
+		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x15);
+		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x14);
+		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x10);
+		hdmi_writel(hdmi_dev, PHY_CHG_PWR, 0x0f);
+		hdmi_writel(hdmi_dev, 0xce, 0x00);
+		hdmi_writel(hdmi_dev, 0xce, 0x01);
+		rockchip_hdmiv1_sys_power(hdmi_drv, true);
+		break;
+	case LOWER_PWR:
+		dev_info(hdmi_drv->dev,
+			 "%s change pwr_mode LOWER_PWR\n",
+			 __func__);
+		rockchip_hdmiv1_sys_power(hdmi_drv, false);
+		hdmi_writel(hdmi_dev, PHY_DRIVER, 0x00);
+		hdmi_writel(hdmi_dev, PHY_PRE_EMPHASIS, 0x00);
+		hdmi_writel(hdmi_dev, PHY_CHG_PWR, 0x00);
+		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x17);
+		break;
+	default:
+		dev_info(hdmi_drv->dev, "unknown rk3036 hdmi pwr mode %d\n",
+			 mode);
+	}
+
+	hdmi_dev->pwr_mode = mode;
+}
+
+int rockchip_hdmiv1_detect_hotplug(struct hdmi *hdmi_drv)
+{
+	int value = 0;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	hdmi_readl(hdmi_dev, HDMI_STATUS, &value);
+	value &= m_HOTPLUG;
+	if (value == m_HOTPLUG)
+		return HDMI_HPD_ACTIVATED;
+	else if (value)
+		return HDMI_HPD_INSERT;
+	else
+		return HDMI_HPD_REMOVED;
+}
+
+int rockchip_hdmiv1_insert(struct hdmi *hdmi_drv)
+{
+	rockchip_hdmiv1_set_pwr_mode(hdmi_drv, NORMAL);
+	return 0;
+}
+
+int rockchip_hdmiv1_read_edid(struct hdmi *hdmi_drv, int block, u8 *buf)
+{
+	u32 c = 0;
+	u8 segment = 0;
+	u8 offset = 0;
+	int ret = -1;
+	int i, j;
+	int ddc_bus_freq;
+	int trytime;
+	int checksum = 0;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	if (block % 2)
+		offset = HDMI_EDID_BLOCK_SIZE;
+
+	if (block / 2)
+		segment = 1;
+	ddc_bus_freq = (hdmi_dev->hclk_rate >> 2) / HDMI_SCL_RATE;
+	hdmi_writel(hdmi_dev, DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);
+	hdmi_writel(hdmi_dev, DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);
+
+	dev_info(hdmi_drv->dev,
+		 "EDID DATA (Segment = %d Block = %d Offset = %d):\n",
+		 (int)segment, (int)block, (int)offset);
+	disable_irq(hdmi_dev->irq);
+
+	/* Enable edid interrupt */
+	hdmi_writel(hdmi_dev, INTERRUPT_MASK1, m_INT_EDID_READY);
+
+	for (trytime = 0; trytime < 10; trytime++) {
+		checksum = 0;
+		hdmi_writel(hdmi_dev, INTERRUPT_STATUS1, 0x04);
+
+		/* Set edid fifo first addr */
+		hdmi_writel(hdmi_dev, EDID_FIFO_OFFSET, 0x00);
+
+		/* Set edid word address 0x00/0x80 */
+		hdmi_writel(hdmi_dev, EDID_WORD_ADDR, offset);
+
+		/* Set edid segment pointer */
+		hdmi_writel(hdmi_dev, EDID_SEGMENT_POINTER, segment);
+
+		for (i = 0; i < 200; i++) {
+			/* Wait edid interrupt */
+			usleep_range(900, 1000);
+			c = 0x00;
+			hdmi_readl(hdmi_dev, INTERRUPT_STATUS1, &c);
+
+			if (c & m_INT_EDID_READY)
+				break;
+		}
+
+		if (c & m_INT_EDID_READY) {
+			for (j = 0; j < HDMI_EDID_BLOCK_SIZE; j++) {
+				c = 0;
+				hdmi_readl(hdmi_dev, 0x50, &c);
+				buf[j] = c;
+				checksum += c;
+			}
+
+			if ((checksum & 0xff) == 0) {
+				ret = 0;
+				dev_info(hdmi_drv->dev,
+					 "[%s] edid read success\n", __func__);
+				break;
+			}
+		}
+	}
+	/*close edid irq*/
+	hdmi_writel(hdmi_dev, INTERRUPT_MASK1, 0);
+	/* clear EDID interrupt reg */
+	hdmi_writel(hdmi_dev, INTERRUPT_STATUS1,
+		    m_INT_EDID_READY);
+
+	enable_irq(hdmi_dev->irq);
+
+	return ret;
+}
+
+static const char coeff_csc[][24] = {
+	/* YUV2RGB:601 SD mode(Y[16:235],UV[16:240],RGB[0:255]):
+	 *  R = 1.164*Y +1.596*V - 204
+	 *  G = 1.164*Y - 0.391*U - 0.813*V + 154
+	 *  B = 1.164*Y + 2.018*U - 258
+	 */
+	{
+	0x04, 0xa7, 0x00, 0x00, 0x06, 0x62, 0x02, 0xcc,
+	0x04, 0xa7, 0x11, 0x90, 0x13, 0x40, 0x00, 0x9a,
+	0x04, 0xa7, 0x08, 0x12, 0x00, 0x00, 0x03, 0x02},
+
+	/* YUV2RGB:601 SD mode(YUV[0:255],RGB[0:255]):
+	 *  R = Y + 1.402*V - 248
+	 *  G = Y - 0.344*U - 0.714*V + 135
+	 *  B = Y + 1.772*U - 227
+	 */
+	{
+	0x04, 0x00, 0x00, 0x00, 0x05, 0x9b, 0x02, 0xf8,
+	0x04, 0x00, 0x11, 0x60, 0x12, 0xdb, 0x00, 0x87,
+	0x04, 0x00, 0x07, 0x16, 0x00, 0x00, 0x02, 0xe3},
+	/* YUV2RGB:709 HD mode(Y[16:235],UV[16:240],RGB[0:255]):
+	 *  R = 1.164*Y +1.793*V - 248
+	 *  G = 1.164*Y - 0.213*U - 0.534*V + 77
+	 *  B = 1.164*Y + 2.115*U - 289
+	 */
+	{
+	0x04, 0xa7, 0x00, 0x00, 0x07, 0x2c, 0x02, 0xf8,
+	0x04, 0xa7, 0x10, 0xda, 0x12, 0x22, 0x00, 0x4d,
+	0x04, 0xa7, 0x08, 0x74, 0x00, 0x00, 0x03, 0x21},
+	/* RGB2YUV:601 SD mode:
+	 *  Cb = -0.291G  - 0.148R + 0.439B + 128
+	 *  Y   = 0.504G   + 0.257R + 0.098B + 16
+	 *  Cr  = -0.368G + 0.439R - 0.071B + 128
+	 */
+	{
+	0x11, 0x5f, 0x01, 0x82, 0x10, 0x23, 0x00, 0x80,
+	0x02, 0x1c, 0x00, 0xa1, 0x00, 0x36, 0x00, 0x1e,
+	0x11, 0x29, 0x10, 0x59, 0x01, 0x82, 0x00, 0x80
+	},
+
+	/* RGB2YUV:709 HD mode:
+	 *  Cb = - 0.338G - 0.101R +  0.439B + 128
+	 *  Y  =    0.614G + 0.183R +  0.062B + 16
+	 *  Cr = - 0.399G + 0.439R  -  0.040B + 128
+	 */
+	{
+	0x11, 0x98, 0x01, 0xc1, 0x10, 0x28, 0x00, 0x80,
+	0x02, 0x74, 0x00, 0xbb, 0x00, 0x3f, 0x00, 0x10,
+	0x11, 0x5a, 0x10, 0x67, 0x01, 0xc1, 0x00, 0x80
+	},
+	/* RGB[0:255]2RGB[16:235]:
+	 * R' = R x (235-16)/255 + 16;
+	 * G' = G x (235-16)/255 + 16;
+	 * B' = B x (235-16)/255 + 16;
+	 */
+	{
+	0x00, 0x00, 0x03, 0x6F, 0x00, 0x00, 0x00, 0x10,
+	0x03, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
+	0x00, 0x00, 0x00, 0x00, 0x03, 0x6F, 0x00, 0x10},
+};
+
+static int rockchip_hdmiv1_video_csc(struct hdmi *hdmi_drv,
+				     struct hdmi_video *vpara)
+{
+	int value, i, csc_mode, c0_c2_change, auto_csc, csc_enable;
+	const char *coeff = NULL;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	/* Enable or disalbe color space convert */
+	dev_info(hdmi_drv->dev, "[%s] input_color=%d,output_color=%d\n",
+		 __func__, vpara->color_input, vpara->color_output);
+	if (vpara->color_input == vpara->color_output) {
+		if ((vpara->color_input >= HDMI_COLOR_YCBCR444) ||
+		    (vpara->color_input == HDMI_COLOR_RGB_0_255)) {
+			value = v_SOF_DISABLE | v_COLOR_DEPTH_NOT_INDICATED(1);
+			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
+			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
+				     m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_SWAP,
+				     v_VIDEO_AUTO_CSC(AUTO_CSC_DISABLE) |
+				     v_VIDEO_C0_C2_SWAP(C0_C2_CHANGE_DISABLE));
+			return 0;
+		} else if (vpara->color_input == HDMI_COLOR_RGB_16_235) {
+			csc_mode = CSC_RGB_0_255_TO_RGB_16_235_8BIT;
+			auto_csc = AUTO_CSC_DISABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_ENABLE;
+		}
+	}
+
+	switch (vpara->vic) {
+	case HDMI_720X480I_60HZ_4_3:
+	case HDMI_720X576I_50HZ_4_3:
+	case HDMI_720X480P_60HZ_4_3:
+	case HDMI_720X576P_50HZ_4_3:
+	case HDMI_720X480I_60HZ_16_9:
+	case HDMI_720X576I_50HZ_16_9:
+	case HDMI_720X480P_60HZ_16_9:
+	case HDMI_720X576P_50HZ_16_9:
+		if (((vpara->color_input == HDMI_COLOR_RGB_0_255) ||
+		     (vpara->color_input == HDMI_COLOR_RGB_16_235)) &&
+		    vpara->color_output >= HDMI_COLOR_YCBCR444) {
+			csc_mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;
+			auto_csc = AUTO_CSC_DISABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_ENABLE;
+		} else if (vpara->color_input >= HDMI_COLOR_YCBCR444 &&
+			   ((vpara->color_output == HDMI_COLOR_RGB_0_255) ||
+			   (vpara->color_output == HDMI_COLOR_RGB_16_235))) {
+#ifdef AUTO_DEFINE_CSC
+			csc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
+			auto_csc = AUTO_CSC_ENABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_DISABLE;
+#else
+			csc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
+			auto_csc = AUTO_CSC_DISABLE;
+			c0_c2_change = C0_C2_CHANGE_ENABLE;
+			csc_enable = v_CSC_ENABLE;
+#endif
+		}
+		break;
+	default:
+		if (((vpara->color_input == HDMI_COLOR_RGB_0_255) ||
+		     (vpara->color_input == HDMI_COLOR_RGB_16_235)) &&
+		    vpara->color_output >= HDMI_COLOR_YCBCR444) {
+			csc_mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;
+			auto_csc = AUTO_CSC_DISABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_ENABLE;
+		} else if (vpara->color_input >= HDMI_COLOR_YCBCR444 &&
+			   ((vpara->color_output == HDMI_COLOR_RGB_0_255) ||
+			   (vpara->color_output == HDMI_COLOR_RGB_16_235))) {
+#ifdef AUTO_DEFINE_CSC
+			csc_mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;
+			auto_csc = AUTO_CSC_ENABLE;
+			c0_c2_change = C0_C2_CHANGE_DISABLE;
+			csc_enable = v_CSC_DISABLE;
+#else
+			/*CSC_ITU709_16_235_TO_RGB_0_255_8BIT;*/
+			csc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
+			auto_csc = AUTO_CSC_DISABLE;
+			c0_c2_change = C0_C2_CHANGE_ENABLE;
+			csc_enable = v_CSC_ENABLE;
+#endif
+		}
+		break;
+	}
+
+	coeff = coeff_csc[csc_mode];
+	for (i = 0; i < 24; i++)
+		hdmi_writel(hdmi_dev, VIDEO_CSC_COEF + i, coeff[i]);
+
+	value = v_SOF_DISABLE | csc_enable | v_COLOR_DEPTH_NOT_INDICATED(1);
+	hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
+	hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
+		     m_VIDEO_AUTO_CSC |
+		     m_VIDEO_C0_C2_SWAP,
+		     v_VIDEO_AUTO_CSC(auto_csc) |
+		     v_VIDEO_C0_C2_SWAP(c0_c2_change));
+
+#if 0
+	if (vpara->input_color != vpara->output_color) {
+		if (vpara->input_color == VIDEO_INPUT_COLOR_RGB) {/*rgb2yuv*/
+			coeff = coeff_csc[3];
+			for (i = 0; i < 24; i++)
+				hdmi_writel(hdmi_dev,
+					    VIDEO_CSC_COEF + i, coeff[i]);
+
+			value = v_SOF_DISABLE | v_CSC_ENABLE;
+			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
+			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
+				     m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_EXCHANGE,
+				     v_VIDEO_AUTO_CSC(0) |
+				     v_VIDEO_C0_C2_EXCHANGE(1));
+		} else {/*yuv2rgb*/
+#ifdef AUTO_DEFINE_CSC
+			value = v_SOF_DISABLE | v_CSC_DISABLE;
+			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
+			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
+				     m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_EXCHANGE,
+				     v_VIDEO_AUTO_CSC(1) |
+				     v_VIDEO_C0_C2_EXCHANGE(1));
+#else
+			if (hdmi_drv->lcdc->cur_screen->mode.xres <= 576) {
+				/*x <= 576,REC-601*/
+				coeff = coeff_csc[0];
+				pr_info("xres<=576,xres=%d\n",
+					hdmi_drv->lcdc->cur_screen->mode.xres);
+			} else/*x > 576,REC-709*/{
+				coeff = coeff_csc[2];
+				pr_info("xres>576,xres=%d\n",
+					hdmi_drv->lcdc->cur_screen->mode.xres);
+			}
+			for (i = 0; i < 24; i++)
+				hdmi_writel(hdmi_dev,
+					    VIDEO_CSC_COEF + i, coeff[i]);
+
+			value = v_SOF_DISABLE | v_CSC_ENABLE;
+			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
+			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
+				     m_VIDEO_AUTO_CSC |
+				     m_VIDEO_C0_C2_EXCHANGE,
+				     v_VIDEO_AUTO_CSC(0) |
+				     v_VIDEO_C0_C2_EXCHANGE(0));
+#endif
+		}
+	} else {
+		if (vpara->input_color == VIDEO_INPUT_COLOR_RGB) {
+			/*rgb[0:255]->rbg[16:235]*/
+			coeff = coeff_csc[5];
+			for (i = 0; i < 24; i++)
+				hdmi_writel(hdmi_dev,
+					    VIDEO_CSC_COEF + i, coeff[i]);
+
+			value = v_SOF_DISABLE | v_CSC_ENABLE;
+			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
+			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
+				     m_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_EXCHANGE,
+				     v_VIDEO_AUTO_CSC(0) |
+				     v_VIDEO_C0_C2_EXCHANGE(1));
+		} else {
+			value = v_SOF_DISABLE;
+			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
+			hdmi_msk_reg(hdmi_dev, VIDEO_CONTRL,
+				     m_VIDEO_AUTO_CSC |
+				     m_VIDEO_C0_C2_EXCHANGE,
+				     v_VIDEO_AUTO_CSC(0) |
+				     v_VIDEO_C0_C2_EXCHANGE(1));
+		}
+	}
+#endif
+	return 0;
+}
+
+static int rockchip_hdmiv1_config_vsi(struct hdmi *hdmi,
+				      unsigned char vic_3d,
+				      unsigned char format)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	u8 info[SIZE_VSI_INFOFRAME];
+	int i;
+
+	HDMIDBG(2, "[%s] vic_3d %d format %d.\n", __func__, vic_3d, format);
+	memset(info, 0, SIZE_VSI_INFOFRAME);
+	hdmi_msk_reg(hdmi_dev, PACKET_SEND_AUTO,
+		     m_PACKET_VSI_EN, v_PACKET_VSI_EN(0));
+	hdmi_writel(hdmi_dev, CONTROL_PACKET_BUF_INDEX, INFOFRAME_VSI);
+	/* Header Bytes */
+	info[0] = 0x81;
+	info[1] = 0x01;
+	/* PB1 - PB3 contain the 24bit IEEE Registration Identifier */
+	info[4] = 0x03;
+	info[5] = 0x0c;
+	info[6] = 0x00;
+	/* PB4 - HDMI_Video_Format into bits 7:5 */
+	info[7] = format << 5;
+	/* PB5 - Depending on the video format, this byte will contain either
+	 * the HDMI_VIC code in buts 7:0, OR the 3D_Structure in bits 7:4.
+	 */
+	switch (format) {
+	case HDMI_VIDEO_FORMAT_4KX2K:
+		/* This is a 2x4K mode, set the HDMI_VIC in buts 7:0.  Values
+		 * are from HDMI 1.4 Spec, 8.2.3.1 (Table 8-13).
+		 */
+		info[2] = 0x06 - 1;
+		info[8] = vic_3d;
+		info[9] = 0;
+		break;
+	case HDMI_VIDEO_FORMAT_3D:
+		/* This is a 3D mode, set the 3D_Structure in buts 7:4
+		 * Bits 3:0 are reseved so set to 0.  Values are from HDMI 1.4
+		 * Spec, Appendix H (Table H-2).
+		 */
+		info[8] = vic_3d << 4;
+		/* Add the Extended data field when the 3D format is
+		 * Side-by-Side(Half). See Spec Table H-3 for details.
+		 */
+		if ((info[8] >> 4) == HDMI_3D_SIDE_BY_SIDE_HALF) {
+			info[2] = 0x06;
+			info[9] = 0x00;
+		} else {
+			info[2] = 0x06 - 1;
+		}
+		break;
+	default:
+		info[2] = 0x06 - 2;
+		info[8] = 0;
+		info[9] = 0;
+		break;
+	}
+	info[3] = info[0] + info[1] + info[2];
+	/* Calculate InfoFrame ChecKsum */
+	for (i = 4; i < SIZE_VSI_INFOFRAME; i++)
+		info[3] += info[i];
+	info[3] = 0x100 - info[3];
+
+	for (i = 0; i < SIZE_VSI_INFOFRAME; i++)
+		hdmi_writel(hdmi_dev, CONTROL_PACKET_ADDR + i, info[i]);
+	hdmi_msk_reg(hdmi_dev, PACKET_SEND_AUTO,
+		     m_PACKET_VSI_EN, v_PACKET_VSI_EN(1));
+	return 0;
+}
+
+static void rockchip_hdmiv1_config_avi(struct hdmi *hdmi_drv,
+				       unsigned char vic,
+				       unsigned char output_color)
+{
+	int i;
+	int avi_color_mode;
+	u8 info[SIZE_AVI_INFOFRAME];
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	memset(info, 0, SIZE_AVI_INFOFRAME);
+	hdmi_writel(hdmi_dev, CONTROL_PACKET_BUF_INDEX, INFOFRAME_AVI);
+	info[0] = 0x82;
+	info[1] = 0x02;
+	info[2] = 0x0D;
+	info[3] = info[0] + info[1] + info[2];
+
+	if ((output_color == HDMI_COLOR_RGB_0_255) ||
+	    (output_color == HDMI_COLOR_RGB_16_235))
+		avi_color_mode = AVI_COLOR_MODE_RGB;
+	else if (output_color == HDMI_COLOR_YCBCR444)
+		avi_color_mode = AVI_COLOR_MODE_YCBCR444;
+	else if (output_color == HDMI_COLOR_YCBCR422)
+		avi_color_mode = AVI_COLOR_MODE_YCBCR422;
+	else
+		avi_color_mode = HDMI_COLOR_RGB_0_255;
+	info[4] = (avi_color_mode << 5);
+	info[5] =
+	    (AVI_COLORIMETRY_NO_DATA << 6) |
+	    (AVI_CODED_FRAME_ASPECT_NO_DATA << 4) |
+	    ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME;
+	info[6] = 0;
+	info[7] = vic;
+	if ((vic == HDMI_720X480I_60HZ_4_3) ||
+	    (vic == HDMI_720X576I_50HZ_4_3) ||
+	    (vic == HDMI_720X480I_60HZ_16_9) ||
+	    (vic == HDMI_720X576I_50HZ_16_9))
+		info[8] = 1;
+	else
+		info[8] = 0;
+
+	/* Calculate AVI InfoFrame ChecKsum */
+	for (i = 4; i < SIZE_AVI_INFOFRAME; i++)
+		info[3] += info[i];
+
+	info[3] = 0x100 - info[3];
+
+	for (i = 0; i < SIZE_AVI_INFOFRAME; i++)
+		hdmi_writel(hdmi_dev, CONTROL_PACKET_ADDR + i, info[i]);
+}
+
+static int rockchip_hdmiv1_config_video(struct hdmi *hdmi_drv,
+					struct hdmi_video *vpara)
+{
+	struct fb_videomode *mode;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+	int value;
+
+	dev_dbg(hdmi_drv->dev, "[%s]\n", __func__);
+
+	if (!vpara) {
+		dev_err(hdmi_drv->dev, "[%s] input parameter error\n",
+			__func__);
+		return -1;
+	}
+
+	if (hdmi_dev->soctype == HDMI_SOC_RK3036) {
+		/*rk3036 vop only can output rgb fmt*/
+		vpara->color_input = HDMI_COLOR_RGB_0_255;
+	}
+
+	mode = (struct fb_videomode *)hdmi_vic_to_videomode(vpara->vic);
+	if (!mode) {
+		dev_err(hdmi_drv->dev, "[%s] not found vic %d\n", __func__,
+			vpara->vic);
+		return -ENOENT;
+	}
+	hdmi_dev->tmdsclk = mode->pixclock;
+	if (hdmi_drv->uboot)
+		return 0;
+	/* Disable video and audio output */
+	hdmi_msk_reg(hdmi_dev, AV_MUTE,
+		     m_AUDIO_MUTE | m_AUDIO_PD | m_VIDEO_BLACK,
+		     v_AUDIO_MUTE(1) | v_AUDIO_PD(1) | v_VIDEO_MUTE(1));
+
+	/* Input video mode is SDR RGB24bit,
+	 * Data enable signal from external
+	 */
+	hdmi_writel(hdmi_dev, VIDEO_CONTRL1,
+		    v_VIDEO_INPUT_FORMAT(VIDEO_INPUT_SDR_RGB444) |
+		    v_DE_EXTERNAL);
+
+	value = v_VIDEO_INPUT_BITS(VIDEO_INPUT_8BITS);
+	if (vpara->color_output <= HDMI_COLOR_RGB_16_235)
+		value |= v_VIDEO_OUTPUT_COLOR(0);
+	else
+		value |= v_VIDEO_OUTPUT_COLOR((vpara->color_output - 2) & 0x3);
+	if (vpara->color_input <= HDMI_COLOR_RGB_16_235)
+		value |= v_VIDEO_INPUT_CSP(0);
+	else
+		value |= v_VIDEO_INPUT_CSP((vpara->color_input - 2) & 0x1);
+
+	hdmi_writel(hdmi_dev, VIDEO_CONTRL2, value);
+	/* Set HDMI Mode */
+	hdmi_writel(hdmi_dev, HDCP_CTRL, v_HDMI_DVI(vpara->sink_hdmi));
+
+	/* Enable or disalbe color space convert */
+	rockchip_hdmiv1_video_csc(hdmi_drv, vpara);
+
+	/* Set ext video timing */
+	if ((mode->vmode || mode->pixclock <= 27000000) &&
+	    vpara->format_3d != HDMI_3D_FRAME_PACKING) {
+		hdmi_writel(hdmi_dev, VIDEO_TIMING_CTL, 0);
+	} else {
+		if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
+			value = v_EXTERANL_VIDEO(1) |
+				v_INETLACE(0);
+		else
+			value = v_EXTERANL_VIDEO(1) |
+				v_INETLACE(mode->vmode);
+		if (mode->sync & FB_SYNC_HOR_HIGH_ACT)
+			value |= v_HSYNC_POLARITY(1);
+		if (mode->sync & FB_SYNC_VERT_HIGH_ACT)
+			value |= v_VSYNC_POLARITY(1);
+		hdmi_writel(hdmi_dev, VIDEO_TIMING_CTL, value);
+
+		value = mode->left_margin +
+			mode->xres + mode->right_margin +
+			mode->hsync_len;
+		hdmi_writel(hdmi_dev, VIDEO_EXT_HTOTAL_L, value & 0xFF);
+		hdmi_writel(hdmi_dev, VIDEO_EXT_HTOTAL_H, (value >> 8) & 0xFF);
+
+		value = mode->left_margin +
+			mode->right_margin +
+			mode->hsync_len;
+		hdmi_writel(hdmi_dev, VIDEO_EXT_HBLANK_L, value & 0xFF);
+		hdmi_writel(hdmi_dev, VIDEO_EXT_HBLANK_H, (value >> 8) & 0xFF);
+
+		value = mode->left_margin + mode->hsync_len;
+		hdmi_writel(hdmi_dev, VIDEO_EXT_HDELAY_L, value & 0xFF);
+		hdmi_writel(hdmi_dev, VIDEO_EXT_HDELAY_H, (value >> 8) & 0xFF);
+
+		value = mode->hsync_len;
+		hdmi_writel(hdmi_dev, VIDEO_EXT_HDURATION_L,
+			    value & 0xFF);
+		hdmi_writel(hdmi_dev, VIDEO_EXT_HDURATION_H,
+			    (value >> 8) & 0xFF);
+
+		if (vpara->format_3d == HDMI_3D_FRAME_PACKING) {
+			if (mode->vmode == 0)
+				value = mode->upper_margin +
+					mode->lower_margin +
+					mode->vsync_len +
+					2 * mode->yres;
+			else
+				value = 4 * (mode->upper_margin +
+					     mode->lower_margin +
+					     mode->vsync_len) +
+					2 * mode->yres + 2;
+		} else {
+			value = mode->upper_margin +
+				mode->lower_margin +
+				mode->vsync_len +
+				mode->yres;
+		}
+		hdmi_writel(hdmi_dev, VIDEO_EXT_VTOTAL_L, value & 0xFF);
+		hdmi_writel(hdmi_dev, VIDEO_EXT_VTOTAL_H, (value >> 8) & 0xFF);
+
+		value = mode->upper_margin +
+			mode->vsync_len +
+			mode->lower_margin;
+		hdmi_writel(hdmi_dev, VIDEO_EXT_VBLANK, value & 0xFF);
+
+		if (vpara->vic == HDMI_720X480P_60HZ_4_3 ||
+		    vpara->vic == HDMI_720X480P_60HZ_16_9)
+			value = 42;
+		else
+			value = mode->upper_margin + mode->vsync_len;
+
+		hdmi_writel(hdmi_dev, VIDEO_EXT_VDELAY, value & 0xFF);
+
+		value = mode->vsync_len;
+		hdmi_writel(hdmi_dev, VIDEO_EXT_VDURATION, value & 0xFF);
+	}
+	if (vpara->sink_hdmi == OUTPUT_HDMI) {
+		rockchip_hdmiv1_config_avi(hdmi_drv, vpara->vic,
+					   vpara->color_output);
+		if (vpara->format_3d != HDMI_3D_NONE) {
+			rockchip_hdmiv1_config_vsi(hdmi_drv,
+						   vpara->format_3d,
+						   HDMI_VIDEO_FORMAT_3D);
+		} else if ((vpara->vic > 92 && vpara->vic < 96) ||
+			 (vpara->vic == 98)) {
+			vpara->vic = (vpara->vic == 98) ?
+				     4 : (96 - vpara->vic);
+			rockchip_hdmiv1_config_vsi(hdmi_drv,
+						   vpara->vic,
+						   HDMI_VIDEO_FORMAT_4KX2K);
+		} else {
+			rockchip_hdmiv1_config_vsi(hdmi_drv,
+						   vpara->vic,
+						   HDMI_VIDEO_FORMAT_NORMAL);
+		}
+		dev_info(hdmi_drv->dev,
+			 "[%s] success output HDMI.\n", __func__);
+	} else {
+		dev_info(hdmi_drv->dev,
+			 "[%s] success output DVI.\n", __func__);
+	}
+
+	/* rk3028a */
+	hdmi_writel(hdmi_dev, PHY_PRE_DIV_RATIO, 0x1e);
+	hdmi_writel(hdmi_dev, PHY_FEEDBACK_DIV_RATIO_LOW, 0x2c);
+	hdmi_writel(hdmi_dev, PHY_FEEDBACK_DIV_RATIO_HIGH, 0x01);
+
+	return 0;
+}
+
+static void rockchip_hdmiv1_config_aai(struct hdmi *hdmi_drv)
+{
+	int i;
+	u8 info[SIZE_AUDIO_INFOFRAME];
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	memset(info, 0, SIZE_AUDIO_INFOFRAME);
+
+	info[0] = 0x84;
+	info[1] = 0x01;
+	info[2] = 0x0A;
+
+	info[3] = info[0] + info[1] + info[2];
+	for (i = 4; i < SIZE_AUDIO_INFOFRAME; i++)
+		info[3] += info[i];
+
+	info[3] = 0x100 - info[3];
+
+	hdmi_writel(hdmi_dev, CONTROL_PACKET_BUF_INDEX, INFOFRAME_AAI);
+	for (i = 0; i < SIZE_AUDIO_INFOFRAME; i++)
+		hdmi_writel(hdmi_dev, CONTROL_PACKET_ADDR + i, info[i]);
+}
+
+static int rockchip_hdmiv1_config_audio(struct hdmi *hdmi_drv,
+					struct hdmi_audio *audio)
+{
+	int rate, N, channel, mclk_fs;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	if (audio->channel < 3)
+		channel = I2S_CHANNEL_1_2;
+	else if (audio->channel < 5)
+		channel = I2S_CHANNEL_3_4;
+	else if (audio->channel < 7)
+		channel = I2S_CHANNEL_5_6;
+	else
+		channel = I2S_CHANNEL_7_8;
+
+	switch (audio->rate) {
+	case HDMI_AUDIO_FS_32000:
+		rate = AUDIO_32K;
+		N = N_32K;
+		mclk_fs = MCLK_384FS;
+		break;
+	case HDMI_AUDIO_FS_44100:
+		rate = AUDIO_441K;
+		N = N_441K;
+		mclk_fs = MCLK_256FS;
+		break;
+	case HDMI_AUDIO_FS_48000:
+		rate = AUDIO_48K;
+		N = N_48K;
+		mclk_fs = MCLK_256FS;
+		break;
+	case HDMI_AUDIO_FS_88200:
+		rate = AUDIO_882K;
+		N = N_882K;
+		mclk_fs = MCLK_128FS;
+		break;
+	case HDMI_AUDIO_FS_96000:
+		rate = AUDIO_96K;
+		N = N_96K;
+		mclk_fs = MCLK_128FS;
+		break;
+	case HDMI_AUDIO_FS_176400:
+		rate = AUDIO_1764K;
+		N = N_1764K;
+		mclk_fs = MCLK_128FS;
+		break;
+	case HDMI_AUDIO_FS_192000:
+		rate = AUDIO_192K;
+		N = N_192K;
+		mclk_fs = MCLK_128FS;
+		break;
+	default:
+		dev_err(hdmi_drv->dev,
+			"[%s] not support such sample rate %d\n",
+			__func__, audio->rate);
+		return -ENOENT;
+	}
+
+	/* set_audio source I2S */
+	if (hdmi_dev->audiosrc == HDMI_AUDIO_SRC_IIS) {
+		hdmi_writel(hdmi_dev, AUDIO_CTRL1, 0x01);
+		hdmi_writel(hdmi_dev, AUDIO_SAMPLE_RATE, rate);
+		hdmi_writel(hdmi_dev, AUDIO_I2S_MODE,
+			    v_I2S_MODE(I2S_STANDARD) |
+			    v_I2S_CHANNEL(channel));
+		hdmi_writel(hdmi_dev, AUDIO_I2S_MAP, 0x00);
+		/* no swap */
+		hdmi_writel(hdmi_dev, AUDIO_I2S_SWAPS_SPDIF, 0);
+	} else {
+		hdmi_writel(hdmi_dev, AUDIO_CTRL1, 0x08);
+		/* no swap */
+		hdmi_writel(hdmi_dev, AUDIO_I2S_SWAPS_SPDIF, 0);
+	}
+
+	/* Set N value */
+	hdmi_writel(hdmi_dev, AUDIO_N_H, (N >> 16) & 0x0F);
+	hdmi_writel(hdmi_dev, AUDIO_N_M, (N >> 8) & 0xFF);
+	hdmi_writel(hdmi_dev, AUDIO_N_L, N & 0xFF);
+
+	/*Set hdmi nlpcm mode to support hdmi bitstream*/
+	if (audio->type == HDMI_AUDIO_NLPCM)
+		hdmi_writel(hdmi_dev, AUDIO_CHANNEL_STATUS,
+			    v_AUDIO_STATUS_NLPCM(1));
+	else
+		hdmi_writel(hdmi_dev, AUDIO_CHANNEL_STATUS,
+			    v_AUDIO_STATUS_NLPCM(0));
+
+	rockchip_hdmiv1_config_aai(hdmi_drv);
+
+	return 0;
+}
+
+int rockchip_hdmiv1_control_output(struct hdmi *hdmi_drv, int enable)
+{
+	int mutestatus = 0;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	if (hdmi_drv->uboot) {
+		hdmi_drv->uboot = 0;
+		return 0;
+	}
+
+	if (enable == HDMI_AV_UNMUTE) {
+		if (hdmi_dev->pwr_mode == LOWER_PWR)
+			rockchip_hdmiv1_set_pwr_mode(hdmi_drv, NORMAL);
+		hdmi_readl(hdmi_dev, AV_MUTE, &mutestatus);
+		if (mutestatus & m_VIDEO_BLACK) {
+			rockchip_hdmiv1_sys_power(hdmi_drv, true);
+			rockchip_hdmiv1_sys_power(hdmi_drv, false);
+			delay100us();
+			rockchip_hdmiv1_sys_power(hdmi_drv, true);
+			hdmi_writel(hdmi_dev, 0xce, 0x00);
+			delay100us();
+			hdmi_writel(hdmi_dev, 0xce, 0x01);
+		}
+
+		if (mutestatus == (m_AUDIO_MUTE | m_VIDEO_BLACK)) {
+			hdmi_msk_reg(hdmi_dev, AV_MUTE,
+				     m_AUDIO_MUTE |
+				     m_AUDIO_PD |
+				     m_VIDEO_BLACK,
+				     v_AUDIO_MUTE(0) |
+				     v_AUDIO_PD(0) |
+				     v_VIDEO_MUTE(0));
+		}
+		rockchip_hdmiv1_av_mute(hdmi_drv, 0);
+	} else {
+		mutestatus = 0;
+		if (enable & HDMI_VIDEO_MUTE)
+			mutestatus |= v_VIDEO_MUTE(1);
+		if (enable & HDMI_AUDIO_MUTE)
+			mutestatus |= (v_AUDIO_MUTE(1) | v_AUDIO_PD(1));
+		hdmi_msk_reg(hdmi_dev, AV_MUTE,
+			     m_AUDIO_MUTE | m_AUDIO_PD | m_VIDEO_BLACK,
+			     mutestatus);
+
+		if (enable == (HDMI_VIDEO_MUTE | HDMI_AUDIO_MUTE)) {
+			rockchip_hdmiv1_av_mute(hdmi_drv, 1);
+			msleep(100);
+			rockchip_hdmiv1_set_pwr_mode(hdmi_drv, LOWER_PWR);
+		}
+	}
+	return 0;
+}
+
+int rockchip_hdmiv1_removed(struct hdmi *hdmi_drv)
+{
+	dev_info(hdmi_drv->dev, "Removed.\n");
+	if (hdmi_drv->ops->hdcp_power_off_cb)
+		hdmi_drv->ops->hdcp_power_off_cb(hdmi_drv);
+
+	rockchip_hdmiv1_control_output(hdmi_drv, -1);
+	rockchip_hdmiv1_set_pwr_mode(hdmi_drv, LOWER_PWR);
+
+	return HDMI_ERROR_SUCCESS;
+}
+
+static int rockchip_hdmiv1_enable(struct hdmi *hdmi_drv)
+{
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	if (!hdmi_dev->enable) {
+		hdmi_dev->enable = 1;
+		hdmi_msk_reg(hdmi_dev, HDMI_STATUS,
+			     m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(1));
+	}
+	hdmi_submit_work(hdmi_drv, HDMI_HPD_CHANGE, 10, 0);
+	return 0;
+}
+
+static int rockchip_hdmiv1_disable(struct hdmi *hdmi_drv)
+{
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	if (hdmi_dev->enable) {
+		hdmi_dev->enable = 0;
+		hdmi_msk_reg(hdmi_dev, HDMI_STATUS,
+			     m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(0));
+	}
+	return 0;
+}
+
+void rockchip_hdmiv1_irq(struct hdmi *hdmi_drv)
+{
+	u32 interrupt = 0;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	hdmi_readl(hdmi_dev, INTERRUPT_STATUS1, &interrupt);
+	if (interrupt) {
+		hdmi_writel(hdmi_dev, INTERRUPT_STATUS1, interrupt);
+		dev_info(hdmi_drv->dev, "Clear edid irq.\n");
+	}
+
+	hdmi_readl(hdmi_dev, HDMI_STATUS, &interrupt);
+	if (interrupt)
+		hdmi_writel(hdmi_dev, HDMI_STATUS, interrupt);
+	if (interrupt & m_INT_HOTPLUG)
+		hdmi_submit_work(hdmi_drv, HDMI_HPD_CHANGE, 20, 0);
+
+	if (hdmi_drv->ops->hdcp_irq_cb)
+		hdmi_drv->ops->hdcp_irq_cb(0);
+	if (hdmi_drv->property->feature & SUPPORT_CEC)
+		rockchip_hdmiv1_cec_isr(hdmi_dev);
+}
+
+static void rockchip_hdmiv1_reset(struct hdmi *hdmi_drv)
+{
+	u32 val = 0;
+	u32 msk = 0;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_RST_DIGITAL, v_NOT_RST_DIGITAL);
+	delay100us();
+	hdmi_msk_reg(hdmi_dev, SYS_CTRL, m_RST_ANALOG, v_NOT_RST_ANALOG);
+	delay100us();
+	msk = m_REG_CLK_INV | m_REG_CLK_SOURCE | m_POWER | m_INT_POL;
+	val = v_REG_CLK_INV | v_REG_CLK_SOURCE_SYS | v_PWR_ON | v_INT_POL_HIGH;
+	hdmi_msk_reg(hdmi_dev, SYS_CTRL, msk, val);
+
+	rockchip_hdmiv1_set_pwr_mode(hdmi_drv, LOWER_PWR);
+}
+
+void rockchip_hdmiv1_dev_init_ops(struct hdmi_ops *ops)
+{
+	if (ops) {
+		ops->disable = rockchip_hdmiv1_disable;
+		ops->enable = rockchip_hdmiv1_enable;
+		ops->remove = rockchip_hdmiv1_removed;
+		ops->setmute = rockchip_hdmiv1_control_output;
+		ops->setvideo = rockchip_hdmiv1_config_video;
+		ops->setaudio = rockchip_hdmiv1_config_audio;
+		ops->getstatus = rockchip_hdmiv1_detect_hotplug;
+		ops->getedid = rockchip_hdmiv1_read_edid;
+		ops->insert	= rockchip_hdmiv1_insert;
+		ops->setvsi = rockchip_hdmiv1_config_vsi;
+	}
+}
+
+int rockchip_hdmiv1_initial(struct hdmi *hdmi_drv)
+{
+	int rc = HDMI_ERROR_SUCCESS;
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+
+	hdmi_dev->pwr_mode = NORMAL;
+
+	if (!hdmi_drv->uboot) {
+		rockchip_hdmiv1_reset_pclk();
+		rockchip_hdmiv1_reset(hdmi_drv);
+		hdmi_msk_reg(hdmi_dev, HDMI_STATUS,
+			     m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(0));
+	} else if (hdmi_drv->ops->getstatus(hdmi_drv) == HDMI_HPD_REMOVED) {
+		rockchip_hdmiv1_removed(hdmi_drv);
+		hdmi_drv->lcdc->uboot_logo = 0;
+		hdmi_drv->uboot = 0;
+	}
+	if (hdmi_drv->property->feature & SUPPORT_CEC)
+		rockchip_hdmiv1_cec_init(hdmi_drv);
+	if (hdmi_drv->property->feature & SUPPORT_HDCP)
+		rockchip_hdmiv1_hdcp_init(hdmi_drv);
+	return rc;
+}
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,472 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ROCKCHIP_HDMI_V1_HW_H__
+#define __ROCKCHIP_HDMI_V1_HW_H__
+
+#include <linux/rockchip/iomap.h>
+#include <linux/delay.h>
+
+enum PWR_MODE {
+	NORMAL,
+	LOWER_PWR,
+};
+
+enum {
+	OUTPUT_DVI = 0,
+	OUTPUT_HDMI
+};
+
+/* C0 C2 Change */
+enum {
+	C0_C2_CHANGE_ENABLE,	/* enable c0 c2 change*/
+	C0_C2_CHANGE_DISABLE	/* disable c0 c2 change*/
+};
+
+/* Auto CSC mode enable */
+enum {
+	AUTO_CSC_DISABLE,	/* disable auto csc*/
+	AUTO_CSC_ENABLE	/* enable auto csc*/
+};
+
+/* Color Limit Range */
+enum {
+	COLOR_LIMIT_RANGE_0_255,	/* Color Limit Range 0 To 255*/
+	COLOR_LIMIT_RANGE_16_235,	/* Color Limit Range 16 To 235*/
+};
+
+/* Color Space Conversion Mode */
+enum {
+	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,/* YCbCr 16-235 input to RGB
+					     * 0-255 output according BT601
+					     * that is 8bit clolor depth
+					     */
+	CSC_ITU601_0_255_TO_RGB_0_255_8BIT, /* YCbCr 0-255 input to RGB
+					     * 0-255 output according BT601
+					     * that is 8bit clolor depth
+					     */
+	CSC_ITU709_16_235_TO_RGB_0_255_8BIT,/* YCbCr 16-235 input to RGB
+					     * 0-255 output according BT709
+					     * that is 8bit clolor depth
+					     */
+	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,/* RGB 0-255 input to YCbCr
+					     * 16-235 output according BT601
+					     * that is 8bit clolor depth
+					     */
+	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,/* RGB 0-255 input to YCbCr 16-235
+					     * output accroding BT709 that is
+					     * 8bit clolor depth
+					     */
+	CSC_RGB_0_255_TO_RGB_16_235_8BIT,   /* RGB 0-255 input to RGB 16-235
+					     * output that is 8bit clolor depth
+					     */
+};
+
+#define AUTO_DEFINE_CSC
+#ifdef RK616_USE_MCLK_12M
+#define HDMI_SYS_FREG_CLK        12000000
+#else
+#define HDMI_SYS_FREG_CLK        11289600
+#endif
+
+#define HDMI_SCL_RATE            (100 * 1000)
+#define DDC_BUS_FREQ_L			0x4b
+#define DDC_BUS_FREQ_H			0x4c
+
+#define SYS_CTRL			0x00
+#define m_RST_ANALOG		BIT(6)
+#define v_RST_ANALOG		(0 << 6)
+#define v_NOT_RST_ANALOG	BIT(6)
+
+#define m_RST_DIGITAL		BIT(5)
+#define v_RST_DIGITAL		(0 << 5)
+#define v_NOT_RST_DIGITAL	BIT(5)
+
+#define m_REG_CLK_INV		BIT(4)
+#define v_REG_CLK_NOT_INV	(0 << 4)
+#define v_REG_CLK_INV		BIT(4)
+#define m_VCLK_INV		BIT(3)
+#define v_VCLK_NOT_INV		(0 << 3)
+#define v_VCLK_INV		BIT(3)
+#define m_REG_CLK_SOURCE	BIT(2)
+#define v_REG_CLK_SOURCE_TMDS	(0 << 2)
+#define v_REG_CLK_SOURCE_SYS	BIT(2)
+#define m_POWER			BIT(1)
+#define v_PWR_ON		(0 << 1)
+#define v_PWR_OFF		BIT(1)
+#define m_INT_POL		BIT(0)
+#define v_INT_POL_HIGH		1
+#define v_INT_POL_LOW		0
+
+#define VIDEO_CONTRL1			0x01
+#define m_VIDEO_INPUT_FORMAT	(7 << 1)
+#define m_DE_SOURCE		BIT(0)
+enum {
+	VIDEO_INPUT_SDR_RGB444 = 0,
+	VIDEO_INPUT_DDR_RGB444 = 5,
+	VIDEO_INPUT_DDR_YCBCR422 = 6
+};
+
+#define v_VIDEO_INPUT_FORMAT(n)	(n << 1)
+#define v_DE_EXTERNAL		1
+#define v_DE_INTERNAL		0
+
+#define VIDEO_CONTRL2			0x02
+#define m_VIDEO_OUTPUT_COLOR	(3 << 6)
+#define m_VIDEO_INPUT_BITS	(3 << 4)
+#define m_VIDEO_INPUT_CSP	BIT(0)
+#define v_VIDEO_OUTPUT_COLOR(n) (((n) & 0x3) << 6)
+#define v_VIDEO_INPUT_BITS(n)	(n << 4)
+#define v_VIDEO_INPUT_CSP(n)	(n << 0)
+
+enum {
+	VIDEO_INPUT_12BITS = 0,
+	VIDEO_INPUT_10BITS,
+	VIDEO_INPUT_REVERT,
+	VIDEO_INPUT_8BITS
+};
+
+#define VIDEO_CONTRL			0x03
+#define m_VIDEO_AUTO_CSC		BIT(7)
+#define v_VIDEO_AUTO_CSC(n)		(n << 7)
+#define m_VIDEO_C0_C2_SWAP		BIT(0)
+#define v_VIDEO_C0_C2_SWAP(n)		(n << 0)
+
+#define VIDEO_CONTRL3			0x04
+#define m_COLOR_DEPTH_NOT_INDICATED BIT(4)
+#define m_SOF			BIT(3)
+#define m_COLOR_RANGE		BIT(2)
+#define m_CSC			BIT(0)
+#define v_COLOR_DEPTH_NOT_INDICATED(n) ((n) << 4) /* 1: Force GCP CD[3:0] zero
+						   * 0: GCP CD[3:0] according
+						   *    color depth
+						   */
+#define v_SOF_ENABLE		(0 << 3)
+#define v_SOF_DISABLE		BIT(3)
+#define v_COLOR_RANGE_FULL	BIT(2)
+#define v_COLOR_RANGE_LIMITED	(0 << 2)
+#define v_CSC_ENABLE		1
+#define v_CSC_DISABLE		0
+
+#define AV_MUTE				0x05
+#define m_AVMUTE_CLEAR		BIT(7)
+#define m_AVMUTE_ENABLE		BIT(6)
+#define m_AUDIO_PD		BIT(2)
+#define m_AUDIO_MUTE		BIT(1)
+#define m_VIDEO_BLACK		BIT(0)
+#define v_AVMUTE_CLEAR(n)	(n << 7)
+#define v_AVMUTE_ENABLE(n)	(n << 6)
+#define v_AUDIO_PD(n)		(n << 2)
+#define v_AUDIO_MUTE(n)		(n << 1)
+#define v_VIDEO_MUTE(n)		(n << 0)
+
+#define VIDEO_TIMING_CTL		0x08
+#define v_HSYNC_POLARITY(n)	(n << 3)
+#define v_VSYNC_POLARITY(n)	(n << 2)
+#define v_INETLACE(n)		(n << 1)
+#define v_EXTERANL_VIDEO(n)	(n << 0)
+
+#define VIDEO_EXT_HTOTAL_L		0x09
+#define VIDEO_EXT_HTOTAL_H		0x0a
+#define VIDEO_EXT_HBLANK_L		0x0b
+#define VIDEO_EXT_HBLANK_H		0x0c
+#define VIDEO_EXT_HDELAY_L		0x0d
+#define VIDEO_EXT_HDELAY_H		0x0e
+#define VIDEO_EXT_HDURATION_L		0x0f
+#define VIDEO_EXT_HDURATION_H		0x10
+#define VIDEO_EXT_VTOTAL_L		0x11
+#define VIDEO_EXT_VTOTAL_H		0x12
+#define VIDEO_EXT_VBLANK		0x13
+#define VIDEO_EXT_VDELAY		0x14
+#define VIDEO_EXT_VDURATION		0x15
+
+#define VIDEO_CSC_COEF			0x18
+
+#define AUDIO_CTRL1			0x35
+enum {
+	CTS_SOURCE_INTERNAL = 0,
+	CTS_SOURCE_EXTERNAL
+};
+
+#define v_CTS_SOURCE(n)		(n << 7)
+enum {
+	DOWNSAMPLE_DISABLE = 0,
+	DOWNSAMPLE_1_2,
+	DOWNSAMPLE_1_4
+};
+
+#define v_DOWN_SAMPLE(n)	(n << 5)
+enum {
+	AUDIO_SOURCE_IIS = 0,
+	AUDIO_SOURCE_SPDIF
+};
+
+#define v_AUDIO_SOURCE(n)	(n << 3)
+#define v_MCLK_ENABLE(n)	(n << 2)
+enum {
+	MCLK_128FS = 0,
+	MCLK_256FS,
+	MCLK_384FS,
+	MCLK_512FS
+};
+
+#define v_MCLK_RATIO(n)		(n)
+
+#define AUDIO_SAMPLE_RATE		0x37
+enum {
+	AUDIO_32K = 0x3,
+	AUDIO_441K = 0x0,
+	AUDIO_48K = 0x2,
+	AUDIO_882K = 0x8,
+	AUDIO_96K = 0xa,
+	AUDIO_1764K = 0xc,
+	AUDIO_192K = 0xe,
+};
+
+#define AUDIO_I2S_MODE			0x38
+enum {
+	I2S_CHANNEL_1_2 = 1,
+	I2S_CHANNEL_3_4 = 3,
+	I2S_CHANNEL_5_6 = 7,
+	I2S_CHANNEL_7_8 = 0xf
+};
+
+#define v_I2S_CHANNEL(n)	((n) << 2)
+enum {
+	I2S_STANDARD = 0,
+	I2S_LEFT_JUSTIFIED,
+	I2S_RIGHT_JUSTIFIED
+};
+
+#define v_I2S_MODE(n)		(n)
+
+#define AUDIO_I2S_MAP			0x39
+#define AUDIO_I2S_SWAPS_SPDIF		0x3a
+#define v_SPIDF_FREQ(n)		(n)
+
+#define N_32K		0x1000
+#define N_441K		0x1880
+#define N_882K		0x3100
+#define N_1764K		0x6200
+#define N_48K		0x1800
+#define N_96K		0x3000
+#define N_192K		0x6000
+
+#define AUDIO_CHANNEL_STATUS		0x3e
+	#define m_AUDIO_STATUS_NLPCM		BIT(7)
+	#define m_AUDIO_STATUS_USE		BIT(6)
+	#define m_AUDIO_STATUS_COPYRIGHT	BIT(5)
+	#define m_AUDIO_STATUS_ADDITION		(3 << 2)
+	#define m_AUDIO_STATUS_CLK_ACCURACY	(2 << 0)
+
+	#define v_AUDIO_STATUS_NLPCM(n)		((n & 1) << 7)
+#define AUDIO_N_H			0x3f
+#define AUDIO_N_M			0x40
+#define AUDIO_N_L			0x41
+
+#define AUDIO_CTS_H			0x45
+#define AUDIO_CTS_M			0x46
+#define AUDIO_CTS_L			0x47
+
+#define DDC_CLK_L			0x4b
+#define DDC_CLK_H			0x4c
+
+#define EDID_SEGMENT_POINTER		0x4d
+#define EDID_WORD_ADDR			0x4e
+#define EDID_FIFO_OFFSET		0x4f
+#define EDID_FIFO_ADDR			0x50
+
+#define PACKET_SEND_MANUAL		0x9c
+#define PACKET_SEND_AUTO		0x9d
+	#define m_PACKET_GCP_EN		BIT(7)
+	#define m_PACKET_MSI_EN		BIT(6) /* MPEG Source InfoFrame */
+	#define m_PACKET_SDI_EN		BIT(5) /* Source product descriptor */
+	#define m_PACKET_VSI_EN		BIT(4) /* HDMI Vendor Specific
+						  * InfoFrame
+						  */
+	#define v_PACKET_GCP_EN(n)	((n & 1) << 7)
+	#define v_PACKET_MSI_EN(n)	((n & 1) << 6)
+	#define v_PACKET_SDI_EN(n)	((n & 1) << 5)
+	#define v_PACKET_VSI_EN(n)	((n & 1) << 4)
+
+/* CONTROL_PACKET_BUF_INDEX */
+#define CONTROL_PACKET_BUF_INDEX	0x9f
+enum {
+	INFOFRAME_VSI = 0x05,
+	INFOFRAME_AVI = 0x06,
+	INFOFRAME_AAI = 0x08,
+};
+
+#define CONTROL_PACKET_ADDR		0xa0
+#define SIZE_VSI_INFOFRAME		0x0A	/* 10 bytes */
+#define SIZE_AVI_INFOFRAME		0x11	/* 14 bytes */
+#define SIZE_AUDIO_INFOFRAME		0x0F	/* 15 bytes */
+enum {
+	AVI_COLOR_MODE_RGB = 0,
+	AVI_COLOR_MODE_YCBCR422,
+	AVI_COLOR_MODE_YCBCR444
+};
+
+enum {
+	AVI_COLORIMETRY_NO_DATA = 0,
+	AVI_COLORIMETRY_SMPTE_170M,
+	AVI_COLORIMETRY_ITU709,
+	AVI_COLORIMETRY_EXTENDED
+};
+
+enum {
+	AVI_CODED_FRAME_ASPECT_NO_DATA,
+	AVI_CODED_FRAME_ASPECT_4_3,
+	AVI_CODED_FRAME_ASPECT_16_9
+};
+
+enum {
+	ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME = 0x08,
+	ACTIVE_ASPECT_RATE_4_3,
+	ACTIVE_ASPECT_RATE_16_9,
+	ACTIVE_ASPECT_RATE_14_9
+};
+
+#define HDCP_CTRL			0x52
+#define m_HDMI_DVI		BIT(1)
+#define v_HDMI_DVI(n)		(n << 1)
+
+#define INTERRUPT_MASK1			0xc0
+#define INTERRUPT_STATUS1		0xc1
+#define	m_INT_ACTIVE_VSYNC	BIT(5)
+#define m_INT_EDID_READY	BIT(2)
+
+#define INTERRUPT_MASK2			0xc2
+#define INTERRUPT_STATUS2		0xc3
+#define m_INT_HDCP_ERR		BIT(7)
+#define m_INT_BKSV_FLAG		BIT(6)
+#define m_INT_HDCP_OK		BIT(4)
+
+#define HDMI_STATUS			0xc8
+	#define m_HOTPLUG	BIT(7)
+	#define m_MASK_INT_HOTPLUG	BIT(5)
+	#define m_INT_HOTPLUG		BIT(1)
+	#define v_MASK_INT_HOTPLUG(n)	((n & 0x1) << 5)
+
+#define HDMI_COLORBAR                   0xc9
+
+#define PHY_SYNC			0xce	/* sync phy parameter */
+#define PHY_SYS_CTL			0xe0
+#define m_TMDS_CLK_SOURCE	BIT(5)
+#define v_TMDS_FROM_PLL		(0 << 5)
+#define v_TMDS_FROM_GEN		BIT(5)
+#define m_PHASE_CLK		BIT(4)
+#define v_DEFAULT_PHASE		(0 << 4)
+#define v_SYNC_PHASE		BIT(4)
+#define m_TMDS_CURRENT_PWR	BIT(3)
+#define v_TURN_ON_CURRENT	(0 << 3)
+#define v_CAT_OFF_CURRENT	BIT(3)
+#define m_BANDGAP_PWR		BIT(2)
+#define v_BANDGAP_PWR_UP	(0 << 2)
+#define v_BANDGAP_PWR_DOWN	BIT(2)
+#define m_PLL_PWR		BIT(1)
+#define v_PLL_PWR_UP		(0 << 1)
+#define v_PLL_PWR_DOWN		BIT(1)
+#define m_TMDS_CHG_PWR		BIT(0)
+#define v_TMDS_CHG_PWR_UP	(0 << 0)
+#define v_TMDS_CHG_PWR_DOWN	BIT(0)
+
+#define PHY_CHG_PWR			0xe1
+#define v_CLK_CHG_PWR(n)	((n & 1) << 3)
+#define v_DATA_CHG_PWR(n)	((n & 7) << 0)
+
+#define PHY_DRIVER			0xe2
+#define v_CLK_MAIN_DRIVER(n)	(n << 4)
+#define v_DATA_MAIN_DRIVER(n)	(n << 0)
+
+#define PHY_PRE_EMPHASIS		0xe3
+#define v_PRE_EMPHASIS(n)	((n & 7) << 4)
+#define v_CLK_PRE_DRIVER(n)	((n & 3) << 2)
+#define v_DATA_PRE_DRIVER(n)	((n & 3) << 0)
+
+#define PHY_FEEDBACK_DIV_RATIO_LOW	0xe7
+#define v_FEEDBACK_DIV_LOW(n)	(n & 0xff)
+#define PHY_FEEDBACK_DIV_RATIO_HIGH	0xe8
+#define v_FEEDBACK_DIV_HIGH(n)	(n & 1)
+
+#define PHY_PRE_DIV_RATIO		0xed
+#define v_PRE_DIV_RATIO(n)	(n & 0x1f)
+
+/*-----START----- HDMI CEC CTRL------START------*/
+#define CEC_CTRL		0xd0
+	#define m_ADJUST_FOR_HISENSE	BIT(6)
+	#define m_REJECT_RX_BROADCAST	BIT(5)
+	#define m_BUSFREETIME_ENABLE	BIT(2)
+	#define m_REJECT_RX				BIT(1)
+	#define m_START_TX				BIT(0)
+
+#define CEC_DATA		0xd1
+#define CEC_TX_OFFSET	0xd2
+#define CEC_RX_OFFSET	0xd3
+#define CEC_CLK_H		0xd4
+#define CEC_CLK_L		0xd5
+#define CEC_TX_LENGTH	0xd6
+#define CEC_RX_LENGTH	0xd7
+#define CEC_TX_INT_MASK	0xd8
+	#define m_TX_DONE			BIT(3)
+	#define m_TX_NOACK			BIT(2)
+	#define m_TX_BROADCAST_REJ		BIT(1)
+	#define m_TX_BUSNOTFREE			BIT(0)
+
+#define CEC_RX_INT_MASK 0xd9
+	#define m_RX_LA_ERR			BIT(4)
+	#define m_RX_GLITCH			BIT(3)
+	#define m_RX_DONE			BIT(0)
+
+#define CEC_TX_INT		0xda
+#define CEC_RX_INT		0xdb
+#define CEC_BUSFREETIME_L	0xdc
+#define CEC_BUSFREETIME_H	0xdd
+#define CEC_LOGICADDR		0xde
+/*------END------ HDMI CEC CTRL------END-------*/
+
+static inline int hdmi_readl(struct hdmi_dev *hdmi_dev,
+			     u16 offset,
+			     u32 *val)
+{
+	int ret = 0;
+
+	*val = readl_relaxed(hdmi_dev->regbase + (offset) * 0x04);
+	return ret;
+}
+
+static inline int hdmi_writel(struct hdmi_dev *hdmi_dev,
+			      u16 offset,
+			      u32 val)
+{
+	int ret = 0;
+
+	writel_relaxed(val, hdmi_dev->regbase + (offset) * 0x04);
+	return ret;
+}
+
+static inline int hdmi_msk_reg(struct hdmi_dev *hdmi_dev,
+			       u16 offset, u32 msk, u32 val)
+{
+	int ret = 0;
+	u32 temp;
+
+	temp = readl_relaxed(hdmi_dev->regbase +
+			     (offset) * 0x04) & (0xFF - (msk));
+	writel_relaxed(temp | ((val) & (msk)),
+		       hdmi_dev->regbase + (offset) * 0x04);
+	return ret;
+}
+
+static inline void rockchip_hdmiv1_reset_pclk(void)
+{
+	writel_relaxed(0x00010001, RK_CRU_VIRT + 0x128);
+	msleep(100);
+	writel_relaxed(0x00010000, RK_CRU_VIRT + 0x128);
+}
+
+void rockchip_hdmiv1_dev_init_ops(struct hdmi_ops *ops);
+int rockchip_hdmiv1_initial(struct hdmi *hdmi);
+void rockchip_hdmiv1_irq(struct hdmi *hdmi);
+void rockchip_hdmiv1_cec_init(struct hdmi *hdmi);
+void rockchip_hdmiv1_cec_isr(struct hdmi_dev *hdmi_dev);
+
+#endif
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+config  RK_HDMI_V2
+        bool "RockChip HDMI V2 support"
+        depends on RK_HDMI
+        default y
+        help
+		Rockchip hdmi version 2 which support hdmi 2.0.
+
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Makefile b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Makefile
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for HDMI linux kernel module.
+#
+
+ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
+
+obj-$(CONFIG_RK_HDMI_V2) += rockchip_hdmiv2.o rockchip_hdmiv2_hw.o rockchip_hdmiv2_cec.o rockchip_hdmiv2_hdcp.o
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,841 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/of_gpio.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/grf.h>
+#include <linux/mfd/syscon.h>
+#if defined(CONFIG_DEBUG_FS)
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#endif
+
+#include "rockchip_hdmiv2.h"
+#include "rockchip_hdmiv2_hw.h"
+
+static struct hdmi_dev *hdmi_dev;
+
+static struct hdmi_property rk_hdmi_property = {
+	.videosrc = DISPLAY_SOURCE_LCDC0,
+	.display = DISPLAY_MAIN,
+};
+
+#if defined(CONFIG_DEBUG_FS)
+static const struct rockchip_hdmiv2_reg_table hdmi_reg_table[] = {
+	{IDENTIFICATION_BASE, CONFIG3_ID},
+	{INTERRUPT_BASE, IH_MUTE},
+	{VIDEO_SAMPLER_BASE, TX_BCBDATA1},
+	{VIDEO_PACKETIZER_BASE, VP_MASK},
+	{FRAME_COMPOSER_BASE, FC_DBGTMDS2},
+	{HDMI_SOURCE_PHY_BASE, PHY_PLLCFGFREQ2},
+	{I2C_MASTER_PHY_BASE, PHY_I2CM_SDA_HOLD},
+	{AUDIO_SAMPLER_BASE, AHB_DMA_STPADDR_SET1_0},
+	{MAIN_CONTROLLER_BASE, MC_SWRSTZREQ_2},
+	{COLOR_SPACE_CONVERTER_BASE, CSC_SPARE_2},
+	{HDCP_ENCRYPTION_ENGINE_BASE, HDCP_REVOC_LIST},
+	{HDCP_BKSV_BASE, HDCPREG_BKSV4},
+	{HDCP_AN_BASE, HDCPREG_AN7},
+	{HDCP2REG_BASE, HDCP2REG_MUTE},
+	{ENCRYPTED_DPK_EMBEDDED_BASE, HDCPREG_DPK6},
+	{CEC_ENGINE_BASE, CEC_WKUPCTRL},
+	{I2C_MASTER_BASE, I2CM_SCDC_UPDATE1},
+};
+
+static int hdmi_regs_ctrl_show(struct seq_file *s, void *v)
+{
+	u32 i = 0, j = 0, val = 0;
+
+	seq_puts(s, "\n>>>hdmi_ctl reg ");
+	for (i = 0; i < 16; i++)
+		seq_printf(s, " %2x", i);
+	seq_puts(s, "\n-----------------------------------------------------------------");
+
+	for (i = 0; i < ARRAY_SIZE(hdmi_reg_table); i++) {
+		for (j = hdmi_reg_table[i].reg_base;
+		     j <= hdmi_reg_table[i].reg_end; j++) {
+			val = hdmi_readl(hdmi_dev, j);
+			if ((j - hdmi_reg_table[i].reg_base) % 16 == 0)
+				seq_printf(s, "\n>>>hdmi_ctl %04x:", j);
+			seq_printf(s, " %02x", val);
+		}
+	}
+	seq_puts(s, "\n-----------------------------------------------------------------\n");
+
+	return 0;
+}
+
+static ssize_t hdmi_regs_ctrl_write(struct file *file,
+				    const char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	u32 reg, val;
+	char kbuf[25];
+
+	if (copy_from_user(kbuf, buf, count))
+		return -EFAULT;
+	if (sscanf(kbuf, "%x%x", &reg, &val) == -1)
+		return -EFAULT;
+	if ((reg < 0) || (reg > I2CM_SCDC_UPDATE1)) {
+		dev_info(hdmi_dev->hdmi->dev, "it is no hdmi reg\n");
+		return count;
+	}
+	dev_info(hdmi_dev->hdmi->dev,
+		 "/**********hdmi reg config******/");
+	dev_info(hdmi_dev->hdmi->dev, "\n reg=%x val=%x\n", reg, val);
+	hdmi_writel(hdmi_dev, reg, val);
+
+	return count;
+}
+
+static int hdmi_regs_phy_show(struct seq_file *s, void *v)
+{
+	u32 i, count;
+
+	if (hdmi_dev->soctype == HDMI_SOC_RK322X)
+		count = 0xff;
+	else
+		count = 0x28;
+	seq_puts(s, "\n>>>hdmi_phy reg ");
+	for (i = 0; i < count; i++)
+		seq_printf(s, "regs %02x val %04x\n",
+			   i, rockchip_hdmiv2_read_phy(hdmi_dev, i));
+	return 0;
+}
+
+static ssize_t hdmi_regs_phy_write(struct file *file,
+				   const char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	u32 reg, val;
+	char kbuf[25];
+
+	if (copy_from_user(kbuf, buf, count))
+		return -EFAULT;
+	if (sscanf(kbuf, "%x%x", &reg, &val) == -1)
+		return -EFAULT;
+	dev_info(hdmi_dev->hdmi->dev,
+		 "/**********hdmi reg phy config******/");
+	dev_info(hdmi_dev->hdmi->dev, "\n reg=%x val=%x\n", reg, val);
+	rockchip_hdmiv2_write_phy(hdmi_dev, reg, val);
+	return count;
+}
+
+#define HDMI_DEBUG_ENTRY(name) \
+static int hdmi_##name##_open(struct inode *inode, struct file *file) \
+{ \
+	return single_open(file, hdmi_##name##_show, inode->i_private); \
+} \
+\
+static const struct file_operations hdmi_##name##_fops = { \
+	.owner = THIS_MODULE, \
+	.open = hdmi_##name##_open, \
+	.read = seq_read, \
+	.write = hdmi_##name##_write,	\
+	.llseek = seq_lseek, \
+	.release = single_release, \
+}
+
+HDMI_DEBUG_ENTRY(regs_phy);
+HDMI_DEBUG_ENTRY(regs_ctrl);
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void rockchip_hdmiv2_early_suspend(struct early_suspend *h)
+{
+	struct hdmi *hdmi = hdmi_dev->hdmi;
+	struct pinctrl_state *gpio_state;
+
+	HDMIDBG(2, "hdmi enter early suspend\n");
+	hdmi_submit_work(hdmi, HDMI_SUSPEND_CTL, 0, 1);
+	/* iomux to gpio and pull down when suspend */
+	gpio_state = pinctrl_lookup_state(hdmi_dev->dev->pins->p, "gpio");
+	pinctrl_select_state(hdmi_dev->dev->pins->p, gpio_state);
+	rockchip_hdmiv2_clk_disable(hdmi_dev);
+}
+
+static void rockchip_hdmiv2_early_resume(struct early_suspend *h)
+{
+	struct hdmi *hdmi = hdmi_dev->hdmi;
+
+	HDMIDBG(2, "hdmi exit early resume\n");
+	/* iomux to default state for hdmi use when resume */
+	pinctrl_select_state(hdmi_dev->dev->pins->p,
+			     hdmi_dev->dev->pins->default_state);
+	rockchip_hdmiv2_clk_enable(hdmi_dev);
+	hdmi_dev_initial(hdmi_dev);
+	if (hdmi->ops->hdcp_power_on_cb)
+		hdmi->ops->hdcp_power_on_cb();
+	hdmi_submit_work(hdmi, HDMI_RESUME_CTL, 0, 0);
+}
+#endif
+
+void ext_pll_set_27m_out(void)
+{
+	if (!hdmi_dev || hdmi_dev->soctype != HDMI_SOC_RK322X)
+		return;
+	/* PHY PLL VCO is 1080MHz, output pclk is 27MHz */
+	rockchip_hdmiv2_write_phy(hdmi_dev,
+				  EXT_PHY_PLL_PRE_DIVIDER,
+				  1);
+	rockchip_hdmiv2_write_phy(hdmi_dev,
+				  EXT_PHY_PLL_FB_DIVIDER,
+				  45);
+	rockchip_hdmiv2_write_phy(hdmi_dev,
+				  EXT_PHY_PCLK_DIVIDER1,
+				  0x61);
+	rockchip_hdmiv2_write_phy(hdmi_dev,
+				  EXT_PHY_PCLK_DIVIDER2,
+				  0x64);
+	rockchip_hdmiv2_write_phy(hdmi_dev,
+				  EXT_PHY_TMDSCLK_DIVIDER,
+				  0x1d);
+}
+
+static int rockchip_hdmiv2_clk_enable(struct hdmi_dev *hdmi_dev)
+{
+	if ((hdmi_dev->clk_on & HDMI_PD_ON) == 0) {
+		pm_runtime_get_sync(hdmi_dev->dev);
+		hdmi_dev->clk_on |= HDMI_PD_ON;
+	}
+
+	if (hdmi_dev->soctype == HDMI_SOC_RK322X ||
+	    hdmi_dev->soctype == HDMI_SOC_RK3366 ||
+	    hdmi_dev->soctype == HDMI_SOC_RK3399) {
+		if ((hdmi_dev->clk_on & HDMI_EXT_PHY_CLK_ON) == 0) {
+			if (!hdmi_dev->pclk_phy) {
+				if (hdmi_dev->soctype == HDMI_SOC_RK322X)
+					hdmi_dev->pclk_phy =
+						devm_clk_get(hdmi_dev->dev,
+							     "pclk_hdmi_phy");
+				else
+					hdmi_dev->pclk_phy =
+						devm_clk_get(hdmi_dev->dev,
+							     "dclk_hdmi_phy");
+				if (IS_ERR(hdmi_dev->pclk_phy)) {
+					dev_err(hdmi_dev->dev,
+						"get hdmi phy pclk error\n");
+					return -1;
+				}
+			}
+			clk_prepare_enable(hdmi_dev->pclk_phy);
+			hdmi_dev->clk_on |= HDMI_EXT_PHY_CLK_ON;
+		}
+	}
+	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0) {
+		if (!hdmi_dev->pclk) {
+			hdmi_dev->pclk =
+				devm_clk_get(hdmi_dev->dev, "pclk_hdmi");
+			if (IS_ERR(hdmi_dev->pclk)) {
+				dev_err(hdmi_dev->dev,
+					"Unable to get hdmi pclk\n");
+				return -1;
+			}
+		}
+		clk_prepare_enable(hdmi_dev->pclk);
+		hdmi_dev->clk_on |= HDMI_PCLK_ON;
+	}
+
+	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON) == 0) {
+		if (!hdmi_dev->hdcp_clk) {
+			hdmi_dev->hdcp_clk =
+				devm_clk_get(hdmi_dev->dev, "hdcp_clk_hdmi");
+			if (IS_ERR(hdmi_dev->hdcp_clk)) {
+				dev_err(hdmi_dev->dev,
+					"Unable to get hdmi hdcp_clk\n");
+				return -1;
+			}
+		}
+		clk_prepare_enable(hdmi_dev->hdcp_clk);
+		hdmi_dev->clk_on |= HDMI_HDCPCLK_ON;
+	}
+
+	if ((rk_hdmi_property.feature & SUPPORT_CEC) &&
+	    (hdmi_dev->clk_on & HDMI_CECCLK_ON) == 0) {
+		if (!hdmi_dev->cec_clk) {
+			hdmi_dev->cec_clk =
+				devm_clk_get(hdmi_dev->dev, "cec_clk_hdmi");
+			if (IS_ERR(hdmi_dev->cec_clk)) {
+				dev_err(hdmi_dev->dev,
+					"Unable to get hdmi cec_clk\n");
+				return -1;
+			}
+		}
+		clk_prepare_enable(hdmi_dev->cec_clk);
+		hdmi_dev->clk_on |= HDMI_CECCLK_ON;
+	}
+
+	if ((hdmi_dev->clk_on & HDMI_SFRCLK_ON) == 0) {
+		if (!hdmi_dev->sfr_clk) {
+			hdmi_dev->sfr_clk =
+				devm_clk_get(hdmi_dev->dev, "sclk_hdmi_sfr");
+			if (IS_ERR(hdmi_dev->sfr_clk)) {
+				dev_err(hdmi_dev->dev,
+					"Unable to get hdmi sfr_clk\n");
+				return -1;
+			}
+		}
+		clk_prepare_enable(hdmi_dev->sfr_clk);
+		hdmi_dev->clk_on |= HDMI_SFRCLK_ON;
+	}
+
+	return 0;
+}
+
+static int rockchip_hdmiv2_clk_disable(struct hdmi_dev *hdmi_dev)
+{
+	if (hdmi_dev->clk_on == 0)
+		return 0;
+
+	if ((hdmi_dev->clk_on & HDMI_PD_ON)) {
+		pm_runtime_put(hdmi_dev->dev);
+		hdmi_dev->clk_on &= ~HDMI_PD_ON;
+	}
+
+	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) &&
+	    hdmi_dev->pclk) {
+		clk_disable_unprepare(hdmi_dev->pclk);
+		hdmi_dev->clk_on &= ~HDMI_PCLK_ON;
+	}
+
+	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON) &&
+	    hdmi_dev->hdcp_clk) {
+		clk_disable_unprepare(hdmi_dev->hdcp_clk);
+		hdmi_dev->clk_on &= ~HDMI_HDCPCLK_ON;
+	}
+
+	if ((hdmi_dev->clk_on & HDMI_EXT_PHY_CLK_ON) &&
+	    hdmi_dev->pclk_phy) {
+		clk_disable_unprepare(hdmi_dev->pclk_phy);
+		hdmi_dev->clk_on &= ~HDMI_EXT_PHY_CLK_ON;
+	}
+
+	if ((hdmi_dev->clk_on & HDMI_SFRCLK_ON) &&
+	    (hdmi_dev->sfr_clk)) {
+		clk_disable_unprepare(hdmi_dev->sfr_clk);
+		hdmi_dev->clk_on &= ~HDMI_SFRCLK_ON;
+	}
+
+
+	return 0;
+}
+
+static int rockchip_hdmiv2_fb_event_notify(struct notifier_block *self,
+					   unsigned long action, void *data)
+{
+	struct fb_event *event = data;
+	struct hdmi *hdmi = hdmi_dev->hdmi;
+	struct pinctrl_state *gpio_state;
+#ifdef CONFIG_PINCTRL
+	struct dev_pin_info *pins = hdmi_dev->dev->pins;
+#endif
+
+	if (action == FB_EARLY_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			break;
+		default:
+			HDMIDBG(2, "suspend hdmi\n");
+			if (!hdmi->sleep) {
+				hdmi_submit_work(hdmi,
+						 HDMI_SUSPEND_CTL,
+						 0, 1);
+				if (hdmi_dev->hdcp2_en)
+					hdmi_dev->hdcp2_en(0);
+				mutex_lock(&hdmi->pclk_lock);
+				rockchip_hdmiv2_clk_disable(hdmi_dev);
+				mutex_unlock(&hdmi->pclk_lock);
+				#ifdef CONFIG_PINCTRL
+				if (hdmi_dev->soctype == HDMI_SOC_RK3288)
+					gpio_state =
+					pinctrl_lookup_state(pins->p,
+							     "sleep");
+				else
+					gpio_state =
+					pinctrl_lookup_state(pins->p,
+							     "gpio");
+				pinctrl_select_state(pins->p,
+						     gpio_state);
+				#endif
+			}
+			break;
+		}
+	} else if (action == FB_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			HDMIDBG(2, "resume hdmi\n");
+			if (hdmi->sleep) {
+				#ifdef CONFIG_PINCTRL
+				pinctrl_select_state(pins->p,
+						     pins->default_state);
+				#endif
+				mutex_lock(&hdmi->pclk_lock);
+				rockchip_hdmiv2_clk_enable(hdmi_dev);
+				mutex_unlock(&hdmi->pclk_lock);
+				rockchip_hdmiv2_dev_initial(hdmi_dev);
+				if (hdmi->ops->hdcp_power_on_cb)
+					hdmi->ops->hdcp_power_on_cb();
+				if (hdmi_dev->hdcp2_reset)
+					hdmi_dev->hdcp2_reset();
+				if (hdmi_dev->hdcp2_en)
+					hdmi_dev->hdcp2_en(1);
+				hdmi_submit_work(hdmi, HDMI_RESUME_CTL,
+						 0, 0);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block rockchip_hdmiv2_fb_notifier = {
+	.notifier_call = rockchip_hdmiv2_fb_event_notify,
+};
+
+#ifdef HDMI_INT_USE_POLL
+static void rockchip_hdmiv2_irq_work_func(struct work_struct *work)
+{
+	if (hdmi_dev->enable) {
+		rockchip_hdmiv2_dev_irq(0, hdmi_dev);
+		queue_delayed_work(hdmi_dev->workqueue,
+				   &hdmi_dev->delay_work,
+				   msecs_to_jiffies(50));
+	}
+}
+#endif
+
+static struct hdmi_ops rk_hdmi_ops;
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk_hdmi_dt_ids[] = {
+	{.compatible = "rockchip,rk322x-hdmi",},
+	{.compatible = "rockchip,rk3288-hdmi",},
+	{.compatible = "rockchip,rk3366-hdmi",},
+	{.compatible = "rockchip,rk3368-hdmi",},
+	{.compatible = "rockchip,rk3399-hdmi",},
+	{}
+};
+
+static int hdmi_get_prop_dts(struct hdmi *hdmi, struct device_node *np)
+{
+	const struct property *prop;
+	int i = 0, nstates = 0;
+	const __be32 *val;
+	int value;
+	struct edid_prop_value *pval = NULL;
+
+	if (!hdmi || !np) {
+		pr_info("%s:line=%d hdmi or np is null\n", __func__, __LINE__);
+		return -1;
+	}
+
+	if (!of_property_read_u32(np, "hdmi_edid_auto_support", &value))
+		hdmi->edid_auto_support = value;
+
+	prop = of_find_property(np, "hdmi_edid_prop_value", NULL);
+	if (!prop || !prop->value) {
+		pr_info("%s:No edid-prop-value, %d\n", __func__, !prop);
+		return -1;
+	}
+
+	nstates = (prop->length / sizeof(struct edid_prop_value));
+	pval = kcalloc(nstates, sizeof(struct edid_prop_value), GFP_NOWAIT);
+
+	for (i = 0, val = prop->value; i < nstates; i++) {
+		pval[i].vid = be32_to_cpup(val++);
+		pval[i].pid = be32_to_cpup(val++);
+		pval[i].sn = be32_to_cpup(val++);
+		pval[i].xres = be32_to_cpup(val++);
+		pval[i].yres = be32_to_cpup(val++);
+		pval[i].vic = be32_to_cpup(val++);
+		pval[i].width = be32_to_cpup(val++);
+		pval[i].height = be32_to_cpup(val++);
+		pval[i].x_w = be32_to_cpup(val++);
+		pval[i].x_h = be32_to_cpup(val++);
+		pval[i].hwrotation = be32_to_cpup(val++);
+		pval[i].einit = be32_to_cpup(val++);
+		pval[i].vsync = be32_to_cpup(val++);
+		pval[i].panel = be32_to_cpup(val++);
+		pval[i].scan = be32_to_cpup(val++);
+
+		pr_info("%s: 0x%x 0x%x 0x%x %d %d %d %d %d %d %d %d %d %d %d %d\n",
+			__func__, pval[i].vid, pval[i].pid, pval[i].sn,
+			pval[i].width, pval[i].height, pval[i].xres,
+			pval[i].yres, pval[i].vic, pval[i].x_w,
+			pval[i].x_h, pval[i].hwrotation, pval[i].einit,
+			pval[i].vsync, pval[i].panel, pval[i].scan);
+	}
+
+	hdmi->pvalue = pval;
+	hdmi->nstates = nstates;
+
+	return 0;
+}
+
+static int rockchip_hdmiv2_parse_dt(struct hdmi_dev *hdmi_dev)
+{
+	int val = 0;
+	struct device_node *np = hdmi_dev->dev->of_node;
+	const struct of_device_id *match;
+
+	match = of_match_node(rk_hdmi_dt_ids, np);
+	if (!match)
+		return -EINVAL;
+
+	if (!strcmp(match->compatible, "rockchip,rk3288-hdmi")) {
+		hdmi_dev->soctype = HDMI_SOC_RK3288;
+	} else if (!strcmp(match->compatible, "rockchip,rk3368-hdmi")) {
+		hdmi_dev->soctype = HDMI_SOC_RK3368;
+	} else if (!strcmp(match->compatible, "rockchip,rk322x-hdmi")) {
+		hdmi_dev->soctype = HDMI_SOC_RK322X;
+	} else if (!strcmp(match->compatible, "rockchip,rk3366-hdmi")) {
+		hdmi_dev->soctype = HDMI_SOC_RK3366;
+	} else if (!strcmp(match->compatible, "rockchip,rk3399-hdmi")) {
+		hdmi_dev->soctype = HDMI_SOC_RK3399;
+	} else {
+		pr_err("It is not a valid rockchip soc!");
+		return -ENOMEM;
+	}
+
+	if (!of_property_read_u32(np, "rockchip,hdmi_video_source", &val))
+		rk_hdmi_property.videosrc = val;
+
+	if (!of_property_read_u32(np, "rockchip,hdmi_audio_source", &val))
+		hdmi_dev->audiosrc = val;
+
+	if (!of_property_read_u32(np, "rockchip,cec_enable", &val) &&
+	    (val == 1)) {
+		pr_debug("hdmi support cec\n");
+		rk_hdmi_property.feature |= SUPPORT_CEC;
+	}
+	if (!of_property_read_u32(np, "rockchip,hdcp_enable", &val) &&
+	    (val == 1)) {
+		pr_debug("hdmi support hdcp\n");
+		rk_hdmi_property.feature |= SUPPORT_HDCP;
+	}
+	if (!of_property_read_u32(np, "rockchip,defaultmode", &val) &&
+	    (val > 0)) {
+		pr_debug("default mode is %d\n", val);
+		rk_hdmi_property.defaultmode = val;
+	} else {
+		rk_hdmi_property.defaultmode = HDMI_VIDEO_DEFAULT_MODE;
+	}
+	if (!of_property_read_u32(np, "rockchip,defaultdepth", &val) &&
+	    (val > 0)) {
+		pr_info("default depth is %d\n", val);
+		rk_hdmi_property.defaultdepth = val;
+	} else {
+		rk_hdmi_property.defaultdepth = HDMI_VIDEO_DEFAULT_COLORDEPTH;
+	}
+	if (of_get_property(np, "rockchip,phy_table", &val)) {
+		hdmi_dev->phy_table = kmalloc(val, GFP_KERNEL);
+		if (!hdmi_dev->phy_table) {
+			pr_err("kmalloc phy table %d error\n", val);
+			return -ENOMEM;
+		}
+		hdmi_dev->phy_table_size =
+				val / sizeof(struct hdmi_dev_phy_para);
+		of_property_read_u32_array(np, "rockchip,phy_table",
+					   (u32 *)hdmi_dev->phy_table,
+					   val / sizeof(u32));
+	} else {
+		pr_info("hdmi phy_table not exist\n");
+	}
+
+	of_property_read_string(np, "rockchip,vendor",
+				&hdmi_dev->vendor_name);
+	of_property_read_string(np, "rockchip,product",
+				&hdmi_dev->product_name);
+	if (!of_property_read_u32(np, "rockchip,deviceinfo", &val))
+		hdmi_dev->deviceinfo = val & 0xff;
+
+	#ifdef CONFIG_MFD_SYSCON
+	hdmi_dev->grf_base =
+		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(hdmi_dev->grf_base))
+		hdmi_dev->grf_base = NULL;
+	#endif
+	return 0;
+}
+#endif
+
+static int rockchip_hdmiv2_probe(struct platform_device *pdev)
+{
+	int ret = -1;
+	struct resource *res;
+
+	HDMIDBG(2, "%s\n", __func__);
+	hdmi_dev = kmalloc(sizeof(*hdmi_dev), GFP_KERNEL);
+	if (!hdmi_dev) {
+		dev_err(&pdev->dev, ">>rockchip hdmiv2 kmalloc fail!");
+		return -ENOMEM;
+	}
+	memset(hdmi_dev, 0, sizeof(struct hdmi_dev));
+	platform_set_drvdata(pdev, hdmi_dev);
+	hdmi_dev->dev = &pdev->dev;
+
+	if (rockchip_hdmiv2_parse_dt(hdmi_dev))
+		goto failed;
+
+	/*request and remap iomem*/
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Unable to get register resource\n");
+		ret = -ENXIO;
+		goto failed;
+	}
+	hdmi_dev->regbase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(hdmi_dev->regbase)) {
+		ret = PTR_ERR(hdmi_dev->regbase);
+		dev_err(&pdev->dev,
+			"cannot ioremap registers,err=%d\n", ret);
+		goto failed;
+	}
+	if (hdmi_dev->soctype == HDMI_SOC_RK322X) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		if (!res) {
+			dev_err(&pdev->dev,
+				"Unable to get phy register resource\n");
+			ret = -ENXIO;
+			goto failed;
+		}
+		hdmi_dev->phybase = devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(hdmi_dev->phybase)) {
+			ret = PTR_ERR(hdmi_dev->phybase);
+			dev_err(&pdev->dev,
+				"cannot ioremap registers,err=%d\n", ret);
+			goto failed;
+		}
+	}
+
+	hdmi_dev->reset = devm_reset_control_get(&pdev->dev, "hdmi");
+	if (IS_ERR(hdmi_dev->reset) &&
+	    hdmi_dev->soctype != HDMI_SOC_RK3288) {
+		ret = PTR_ERR(hdmi_dev->reset);
+		dev_err(&pdev->dev, "failed to get hdmi reset: %d\n", ret);
+		goto failed;
+	}
+	pm_runtime_enable(hdmi_dev->dev);
+	/*enable pd and clk*/
+	if (rockchip_hdmiv2_clk_enable(hdmi_dev) < 0) {
+		dev_err(&pdev->dev, "failed to enable hdmi clk\n");
+		ret = -ENXIO;
+		goto failed1;
+	}
+	rockchip_hdmiv2_dev_init_ops(&rk_hdmi_ops);
+	/* Register HDMI device */
+	rk_hdmi_property.name = (char *)pdev->name;
+	rk_hdmi_property.priv = hdmi_dev;
+	if (hdmi_dev->soctype == HDMI_SOC_RK3288) {
+		rk_hdmi_property.feature |= SUPPORT_DEEP_10BIT;
+		if (rk_hdmi_property.videosrc == DISPLAY_SOURCE_LCDC0)
+			rk_hdmi_property.feature |=
+						SUPPORT_4K |
+						SUPPORT_TMDS_600M;
+	} else if (hdmi_dev->soctype == HDMI_SOC_RK3368) {
+		rk_hdmi_property.feature |=
+				SUPPORT_4K |
+				SUPPORT_4K_4096 |
+				SUPPORT_YUV420 |
+				SUPPORT_YCBCR_INPUT |
+				SUPPORT_VESA_DMT;
+	} else if (hdmi_dev->soctype == HDMI_SOC_RK322X) {
+		rk_hdmi_property.feature |=
+				SUPPORT_4K |
+				SUPPORT_4K_4096 |
+				SUPPORT_YCBCR_INPUT |
+				SUPPORT_1080I |
+				SUPPORT_480I_576I;
+		/*
+		 *if (rockchip_get_cpu_version())
+		 *	rk_hdmi_property.feature |=
+		 *		SUPPORT_YUV420 |
+		 *		SUPPORT_DEEP_10BIT;
+		 */
+	} else if (hdmi_dev->soctype == HDMI_SOC_RK3366) {
+		rk_hdmi_property.feature |=
+				SUPPORT_YCBCR_INPUT |
+				SUPPORT_1080I |
+				SUPPORT_480I_576I;
+		if (rk_hdmi_property.videosrc == DISPLAY_SOURCE_LCDC0)
+			rk_hdmi_property.feature |=
+						SUPPORT_4K |
+						SUPPORT_4K_4096 |
+						SUPPORT_YUV420 |
+						SUPPORT_YCBCR_INPUT |
+						SUPPORT_TMDS_600M;
+	} else if (hdmi_dev->soctype == HDMI_SOC_RK3399) {
+		rk_hdmi_property.feature |=
+				SUPPORT_DEEP_10BIT |
+				SUPPORT_YCBCR_INPUT |
+				SUPPORT_1080I |
+				SUPPORT_480I_576I |
+				SUPPORT_VESA_DMT |
+				SUPPORT_RK_DISCRETE_VR;
+		if (rk_hdmi_property.videosrc == DISPLAY_SOURCE_LCDC0)
+			rk_hdmi_property.feature |=
+						SUPPORT_4K |
+						SUPPORT_4K_4096 |
+						SUPPORT_YUV420 |
+						SUPPORT_YCBCR_INPUT |
+						SUPPORT_TMDS_600M;
+	} else {
+		ret = -ENXIO;
+		goto failed1;
+	}
+	hdmi_dev->hdmi =
+		rockchip_hdmi_register(&rk_hdmi_property, &rk_hdmi_ops);
+	if (!hdmi_dev->hdmi) {
+		dev_err(&pdev->dev, "register hdmi device failed\n");
+		ret = -ENOMEM;
+		goto failed1;
+	}
+
+	hdmi_get_prop_dts(hdmi_dev->hdmi, hdmi_dev->dev->of_node);
+	mutex_init(&hdmi_dev->ddc_lock);
+	hdmi_dev->hdmi->dev = &pdev->dev;
+	hdmi_dev->hdmi->soctype = hdmi_dev->soctype;
+	fb_register_client(&rockchip_hdmiv2_fb_notifier);
+	rockchip_hdmiv2_dev_initial(hdmi_dev);
+	pinctrl_select_state(hdmi_dev->dev->pins->p,
+			     hdmi_dev->dev->pins->default_state);
+#if defined(CONFIG_DEBUG_FS)
+	hdmi_dev->debugfs_dir = debugfs_create_dir("rockchip_hdmiv2", NULL);
+	if (IS_ERR(hdmi_dev->debugfs_dir))
+		dev_err(hdmi_dev->hdmi->dev,
+			"failed to create debugfs dir for rockchip hdmiv2!\n");
+	else {
+		debugfs_create_file("regs_ctrl", S_IRUSR,
+				    hdmi_dev->debugfs_dir,
+				    hdmi_dev, &hdmi_regs_ctrl_fops);
+		debugfs_create_file("regs_phy", S_IRUSR,
+				    hdmi_dev->debugfs_dir,
+				    hdmi_dev, &hdmi_regs_phy_fops);
+	}
+#endif
+
+#ifndef HDMI_INT_USE_POLL
+	/* get and request the IRQ */
+	hdmi_dev->irq = platform_get_irq(pdev, 0);
+	if (hdmi_dev->irq <= 0) {
+		dev_err(hdmi_dev->dev,
+			"failed to get hdmi irq resource (%d).\n",
+			hdmi_dev->irq);
+		ret = -ENXIO;
+		goto failed1;
+	}
+
+	ret = devm_request_irq(hdmi_dev->dev, hdmi_dev->irq,
+			       rockchip_hdmiv2_dev_irq,
+			       IRQF_TRIGGER_HIGH,
+			       dev_name(hdmi_dev->dev), hdmi_dev);
+	if (ret) {
+		dev_err(hdmi_dev->dev,
+			"hdmi request_irq failed (%d).\n",
+			ret);
+		goto failed1;
+	}
+#else
+	hdmi_dev->workqueue =
+		create_singlethread_workqueue("rockchip hdmiv2 irq");
+	INIT_DELAYED_WORK(&hdmi_dev->delay_work,
+			  rockchip_hdmiv2_irq_work_func);
+	rockchip_hdmiv2_irq_work_func(NULL);
+
+#endif
+	rk_display_device_enable(hdmi_dev->hdmi->ddev);
+	dev_info(&pdev->dev, "rockchip hdmiv2 probe success.\n");
+	return 0;
+
+failed1:
+	rockchip_hdmi_unregister(hdmi_dev->hdmi);
+failed:
+	kfree(hdmi_dev->phy_table);
+	kfree(hdmi_dev);
+	hdmi_dev = NULL;
+	dev_err(&pdev->dev, "rockchip hdmiv2 probe error.\n");
+	return ret;
+}
+
+static int rockchip_hdmiv2_suspend(struct platform_device *pdev,
+				   pm_message_t state)
+{
+	if (hdmi_dev &&
+	    hdmi_dev->grf_base &&
+	    hdmi_dev->soctype == HDMI_SOC_RK322X) {
+		regmap_write(hdmi_dev->grf_base,
+			     RK322X_GRF_SOC_CON2,
+			     RK322X_PLL_POWER_DOWN);
+	}
+	return 0;
+}
+
+static int rockchip_hdmiv2_resume(struct platform_device *pdev)
+{
+	if (hdmi_dev &&
+	    hdmi_dev->grf_base &&
+	    hdmi_dev->soctype == HDMI_SOC_RK322X) {
+		regmap_write(hdmi_dev->grf_base,
+			     RK322X_GRF_SOC_CON2,
+			     RK322X_PLL_POWER_UP);
+	}
+	return 0;
+}
+
+static int rockchip_hdmiv2_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "rk3288 hdmi driver removed.\n");
+	return 0;
+}
+
+static void rockchip_hdmiv2_shutdown(struct platform_device *pdev)
+{
+	struct hdmi *hdmi;
+
+	if (hdmi_dev) {
+		#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&hdmi_dev->early_suspend);
+		#endif
+		hdmi = hdmi_dev->hdmi;
+		if (hdmi->hotplug == HDMI_HPD_ACTIVATED &&
+		    hdmi->ops->setmute)
+			hdmi->ops->setmute(hdmi, HDMI_VIDEO_MUTE);
+		pm_runtime_disable(hdmi_dev->dev);
+	}
+}
+
+static struct platform_driver rockchip_hdmiv2_driver = {
+	.probe		= rockchip_hdmiv2_probe,
+	.remove		= rockchip_hdmiv2_remove,
+	.driver		= {
+		.name	= "rockchip-hdmiv2",
+		.owner	= THIS_MODULE,
+		#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(rk_hdmi_dt_ids),
+		#endif
+	},
+	.suspend	= rockchip_hdmiv2_suspend,
+	.resume		= rockchip_hdmiv2_resume,
+	.shutdown	= rockchip_hdmiv2_shutdown,
+};
+
+static int __init rockchip_hdmiv2_init(void)
+{
+	return platform_driver_register(&rockchip_hdmiv2_driver);
+}
+
+static void __exit rockchip_hdmiv2_exit(void)
+{
+	platform_driver_unregister(&rockchip_hdmiv2_driver);
+}
+
+module_init(rockchip_hdmiv2_init);
+module_exit(rockchip_hdmiv2_exit);
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/delay.h>
+#include "../rockchip-hdmi-cec.h"
+#include "rockchip_hdmiv2.h"
+#include "rockchip_hdmiv2_hw.h"
+
+/* static wait_queue_head_t	wait;*/
+static int init = 1;
+void rockchip_hdmiv2_cec_isr(struct hdmi_dev *hdmi_dev, char cec_int)
+{
+	HDMIDBG(1, "%s cec 0x%x\n", __func__, cec_int);
+	if (cec_int & m_EOM)
+		rockchip_hdmi_cec_submit_work(EVENT_RX_FRAME, 0, NULL);
+	if (cec_int & m_DONE)
+		HDMIDBG(1, "send frame success\n");
+}
+
+static int rockchip_hdmiv2_cec_readframe(struct hdmi *hdmi,
+					 struct cec_framedata *frame)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	int i, count;
+	u8 *data = (u8 *)frame;
+
+	if (((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0) || !frame)
+		return -1;
+	count = hdmi_readl(hdmi_dev, CEC_RX_CNT);
+	HDMIDBG(1, "%s count %d\n", __func__, count);
+	for (i = 0; i < count; i++) {
+		data[i] = hdmi_readl(hdmi_dev, CEC_RX_DATA0 + i);
+		HDMIDBG(1, "%02x\n", data[i]);
+	}
+	frame->argcount = count - 2;
+	hdmi_writel(hdmi_dev, CEC_LOCK, 0x0);
+	return 0;
+}
+
+void rockchip_hdmiv2_cec_setcecla(struct hdmi *hdmi, int ceclgaddr)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	short val;
+
+	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0)
+		return;
+	if (ceclgaddr < 0 || ceclgaddr > 16)
+		return;
+	val = 1 << ceclgaddr;
+	hdmi_writel(hdmi_dev, CEC_ADDR_L, val & 0xff);
+	hdmi_writel(hdmi_dev, CEC_ADDR_H, val >> 8);
+}
+
+static int rockchip_hdmiv2_cec_sendframe(struct hdmi *hdmi,
+					 struct cec_framedata *frame)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	int i, interrupt;
+
+	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0)
+		return CEC_SEND_NACK;
+	HDMIDBG(1, "TX srcdestaddr %02x opcode %02x ",
+		frame->srcdestaddr, frame->opcode);
+	if (frame->argcount) {
+		HDMIDBG(1, "args:");
+		for (i = 0; i < frame->argcount; i++)
+			HDMIDBG(1, "%02x ", frame->args[i]);
+	}
+	HDMIDBG(1, "\n");
+	if ((frame->srcdestaddr & 0x0f) == ((frame->srcdestaddr >> 4) & 0x0f)) {
+		/*it is a ping command*/
+		hdmi_writel(hdmi_dev, CEC_TX_DATA0, frame->srcdestaddr);
+		hdmi_writel(hdmi_dev, CEC_TX_CNT, 1);
+	} else {
+		hdmi_writel(hdmi_dev, CEC_TX_DATA0, frame->srcdestaddr);
+		hdmi_writel(hdmi_dev, CEC_TX_DATA0 + 1, frame->opcode);
+		for (i = 0; i < frame->argcount; i++)
+			hdmi_writel(hdmi_dev,
+				    CEC_TX_DATA0 + 2 + i, frame->args[i]);
+		hdmi_writel(hdmi_dev, CEC_TX_CNT, frame->argcount + 2);
+	}
+	/*Start TX*/
+	hdmi_msk_reg(hdmi_dev, CEC_CTRL, m_CEC_SEND, v_CEC_SEND(1));
+	i = 400;
+	/* time = 2.4(ms)*(1 + 16)(head + param)*11(bit)*/
+	/*11bit =  start bit(4.5ms) + data bit(2.4ms) */
+	while (i--) {
+		usleep_range(900, 1000);
+		interrupt = hdmi_readl(hdmi_dev, IH_CEC_STAT0);
+		if (interrupt & (m_ERR_INITIATOR | m_ARB_LOST |
+					m_NACK | m_DONE)) {
+			hdmi_writel(hdmi_dev, IH_CEC_STAT0,
+				    interrupt & (m_ERR_INITIATOR |
+				    m_ARB_LOST | m_NACK | m_DONE));
+			break;
+		}
+	}
+	HDMIDBG(1, "%s interrupt 0x%02x\n", __func__, interrupt);
+	if (interrupt & m_DONE)
+		return CEC_SEND_SUCCESS;
+	else if (interrupt & m_NACK)
+		return CEC_SEND_NACK;
+	else
+		return CEC_SEND_BUSY;
+}
+
+void rockchip_hdmiv2_cec_init(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	if (init) {
+		rockchip_hdmi_cec_init(hdmi,
+				       rockchip_hdmiv2_cec_sendframe,
+				       rockchip_hdmiv2_cec_readframe,
+				       rockchip_hdmiv2_cec_setcecla);
+		init = 0;
+		/* init_waitqueue_head(&wait); */
+	}
+
+	hdmi_writel(hdmi_dev, IH_MUTE_CEC_STAT0, m_ERR_INITIATOR |
+			m_ARB_LOST | m_NACK | m_DONE);
+	HDMIDBG(1, "%s", __func__);
+}
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RK32_HDMI_H__
+#define __RK32_HDMI_H__
+#include <linux/gpio.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include "../rockchip-hdmi.h"
+
+#define HDMI_PD_ON		BIT(0)
+#define HDMI_PCLK_ON		BIT(1)
+#define HDMI_HDCPCLK_ON		BIT(2)
+#define HDMI_CECCLK_ON		BIT(3)
+#define HDMI_EXT_PHY_CLK_ON	BIT(4)
+#define HDMI_SFRCLK_ON		BIT(5)
+
+struct hdmi_dev_phy_para {
+	u32 maxfreq;
+	int pre_emphasis;
+	int slopeboost;
+	int clk_level;
+	int data0_level;
+	int data1_level;
+	int data2_level;
+};
+
+struct hdmi_dev {
+	void __iomem		*regbase;
+	void __iomem		*phybase;
+	struct regmap		*grf_base;
+	struct reset_control	*reset;
+	struct clk		*pd;
+	struct clk		*pclk;
+	struct clk		*hdcp_clk;
+	struct clk		*cec_clk;
+	struct clk		*pclk_phy;
+	struct clk		*sfr_clk;
+	struct hdmi		*hdmi;
+	struct device		*dev;
+	struct dentry		*debugfs_dir;
+	int			irq;
+
+	struct work_struct	irq_work;
+	struct delayed_work	delay_work;
+	struct workqueue_struct *workqueue;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend	early_suspend;
+#endif
+	int			soctype;
+	int			audiosrc;
+	int			enable;
+	int			hdcp2_enable;
+	unsigned char		clk_disable;
+	unsigned char		clk_on;
+
+	unsigned long		pixelclk;
+	unsigned int		tmdsclk;
+	unsigned int		pixelrepeat;
+	unsigned char		colordepth;
+
+	bool			tmdsclk_ratio_change;
+	struct mutex		ddc_lock;	/*mutex for ddc operation */
+
+	void			(*hdcp2_en)(int);
+	void			(*hdcp2_reset)(void);
+	void			(*hdcp2_start)(void);
+
+	struct hdmi_dev_phy_para *phy_table;
+	int			phy_table_size;
+	const char		*vendor_name;
+	const char		*product_name;
+	unsigned char		deviceinfo;
+};
+
+void ext_pll_set_27m_out(void);
+
+#endif /*__RK32_HDMI_H__*/
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,678 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/miscdevice.h>
+#include <linux/workqueue.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include "rockchip_hdmiv2.h"
+#include "rockchip_hdmiv2_hw.h"
+
+#define	HDCP_KEY_SIZE		308
+#define HDCP_PRIVATE_KEY_SIZE	280
+#define HDCP_KEY_SHA_SIZE	20
+#define HDCP_KEY_SEED_SIZE	2
+
+#define KSV_LEN			5
+#define HEADER			10
+#define SHAMAX			20
+
+#define MAX_DOWNSTREAM_DEVICE_NUM	5
+
+struct hdcp_keys {
+	u8 KSV[8];
+	u8 devicekey[HDCP_PRIVATE_KEY_SIZE];
+	u8 sha1[HDCP_KEY_SHA_SIZE];
+};
+
+struct hdcp {
+	struct hdmi		*hdmi;
+	int			enable;
+	int			retry_times;
+	struct hdcp_keys	*keys;
+	char			*seeds;
+	int			invalidkey;
+	char			*invalidkeys;
+};
+
+struct sha_t {
+	u8 mlength[8];
+	u8 mblock[64];
+	int mindex;
+	int mcomputed;
+	int mcorrupted;
+	unsigned int mdigest[5];
+};
+
+static struct miscdevice mdev;
+static struct hdcp *hdcp;
+
+static void sha_reset(struct sha_t *sha)
+{
+	u32 i = 0;
+
+	sha->mindex = 0;
+	sha->mcomputed = false;
+	sha->mcorrupted = false;
+	for (i = 0; i < sizeof(sha->mlength); i++)
+		sha->mlength[i] = 0;
+
+	sha->mdigest[0] = 0x67452301;
+	sha->mdigest[1] = 0xEFCDAB89;
+	sha->mdigest[2] = 0x98BADCFE;
+	sha->mdigest[3] = 0x10325476;
+	sha->mdigest[4] = 0xC3D2E1F0;
+}
+
+#define shacircularshift(bits, word) ((((word) << (bits)) & 0xFFFFFFFF) | \
+				     ((word) >> (32 - (bits))))
+void sha_processblock(struct sha_t *sha)
+{
+	const unsigned int K[] = {
+	/* constants defined in SHA-1 */
+	0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6 };
+	unsigned int W[80]; /* word sequence */
+	unsigned int A, B, C, D, E; /* word buffers */
+	unsigned int temp = 0;
+	int t = 0;
+
+	/* Initialize the first 16 words in the array W */
+	for (t = 0; t < 80; t++) {
+		if (t < 16) {
+			W[t] = ((unsigned int)sha->mblock[t * 4 + 0]) << 24;
+			W[t] |= ((unsigned int)sha->mblock[t * 4 + 1]) << 16;
+			W[t] |= ((unsigned int)sha->mblock[t * 4 + 2]) << 8;
+			W[t] |= ((unsigned int)sha->mblock[t * 4 + 3]) << 0;
+		} else {
+			A = W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16];
+			W[t] = shacircularshift(1, A);
+		}
+	}
+
+	A = sha->mdigest[0];
+	B = sha->mdigest[1];
+	C = sha->mdigest[2];
+	D = sha->mdigest[3];
+	E = sha->mdigest[4];
+
+	for (t = 0; t < 80; t++) {
+		temp = shacircularshift(5, A);
+		if (t < 20)
+			temp += ((B & C) | ((~B) & D)) + E + W[t] + K[0];
+		else if (t < 40)
+			temp += (B ^ C ^ D) + E + W[t] + K[1];
+		else if (t < 60)
+			temp += ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
+		else
+			temp += (B ^ C ^ D) + E + W[t] + K[3];
+
+		E = D;
+		D = C;
+		C = shacircularshift(30, B);
+		B = A;
+		A = (temp & 0xFFFFFFFF);
+	}
+
+	sha->mdigest[0] = (sha->mdigest[0] + A) & 0xFFFFFFFF;
+	sha->mdigest[1] = (sha->mdigest[1] + B) & 0xFFFFFFFF;
+	sha->mdigest[2] = (sha->mdigest[2] + C) & 0xFFFFFFFF;
+	sha->mdigest[3] = (sha->mdigest[3] + D) & 0xFFFFFFFF;
+	sha->mdigest[4] = (sha->mdigest[4] + E) & 0xFFFFFFFF;
+
+	sha->mindex = 0;
+}
+
+static void sha_padmessage(struct sha_t *sha)
+{
+	/*
+	 *  Check to see if the current message block is too small to hold
+	 *  the initial padding bits and length.  If so, we will pad the
+	 *  block, process it, and then continue padding into a second
+	 *  block.
+	 */
+	if (sha->mindex > 55) {
+		sha->mblock[sha->mindex++] = 0x80;
+		while (sha->mindex < 64)
+			sha->mblock[sha->mindex++] = 0;
+
+		sha_processblock(sha);
+		while (sha->mindex < 56)
+			sha->mblock[sha->mindex++] = 0;
+	} else {
+		sha->mblock[sha->mindex++] = 0x80;
+		while (sha->mindex < 56)
+			sha->mblock[sha->mindex++] = 0;
+	}
+
+	/* Store the message length as the last 8 octets */
+	sha->mblock[56] = sha->mlength[7];
+	sha->mblock[57] = sha->mlength[6];
+	sha->mblock[58] = sha->mlength[5];
+	sha->mblock[59] = sha->mlength[4];
+	sha->mblock[60] = sha->mlength[3];
+	sha->mblock[61] = sha->mlength[2];
+	sha->mblock[62] = sha->mlength[1];
+	sha->mblock[63] = sha->mlength[0];
+
+	sha_processblock(sha);
+}
+
+static int sha_result(struct sha_t *sha)
+{
+	if (sha->mcorrupted)
+		return false;
+
+	if (sha->mcomputed == 0) {
+		sha_padmessage(sha);
+		sha->mcomputed = true;
+	}
+	return true;
+}
+
+static void sha_input(struct sha_t *sha, const u8 *data, u32 size)
+{
+	int i = 0;
+	unsigned j = 0;
+	int rc = true;
+
+	if (data == 0 || size == 0) {
+		pr_err("invalid input data");
+		return;
+	}
+	if (sha->mcomputed || sha->mcorrupted) {
+		sha->mcorrupted = true;
+		return;
+	}
+	while (size-- && !sha->mcorrupted) {
+		sha->mblock[sha->mindex++] = *data;
+
+		for (i = 0; i < 8; i++) {
+			rc = true;
+			for (j = 0; j < sizeof(sha->mlength); j++) {
+				sha->mlength[j]++;
+				if (sha->mlength[j] != 0) {
+					rc = false;
+					break;
+				}
+			}
+			sha->mcorrupted = (sha->mcorrupted  ||
+					   rc) ? true : false;
+		}
+		/* if corrupted then message is too long */
+		if (sha->mindex == 64)
+			sha_processblock(sha);
+		data++;
+	}
+}
+
+static int hdcpverify_ksv(const u8 *data, u32 size)
+{
+	u32 i = 0;
+	struct sha_t sha;
+
+	if ((!data) || (size < (HEADER + SHAMAX))) {
+		pr_err("invalid input data");
+		return false;
+	}
+
+	sha_reset(&sha);
+	sha_input(&sha, data, size - SHAMAX);
+	if (sha_result(&sha) == false) {
+		pr_err("cannot process SHA digest");
+		return false;
+	}
+
+	for (i = 0; i < SHAMAX; i++) {
+		if (data[size - SHAMAX + i] != (u8)(sha.mdigest[i / 4]
+				>> ((i % 4) * 8))) {
+			pr_err("SHA digest does not match");
+			return false;
+		}
+	}
+	return true;
+}
+
+static int rockchip_hdmiv2_hdcp_ksvsha1(struct hdmi_dev *hdmi_dev)
+{
+	int rc = 0, value, list, i;
+	char bstaus0, bstaus1;
+	char *ksvlistbuf;
+
+	hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL, m_KSV_MEM_REQ, v_KSV_MEM_REQ(1));
+	list = 20;
+	do {
+		value = hdmi_readl(hdmi_dev, A_KSVMEMCTRL);
+		usleep_range(500, 1000);
+	} while ((value & m_KSV_MEM_ACCESS) == 0 && --list);
+
+	if ((value & m_KSV_MEM_ACCESS) == 0) {
+		pr_err("KSV memory can not access\n");
+		rc = -1;
+		goto out;
+	}
+
+	hdmi_readl(hdmi_dev, HDCP_BSTATUS_0);
+	bstaus0 = hdmi_readl(hdmi_dev, HDCP_BSTATUS_0 + 1);
+	bstaus1 = hdmi_readl(hdmi_dev, HDCP_BSTATUS_1 + 1);
+
+	if (bstaus0 & m_MAX_DEVS_EXCEEDED) {
+		pr_err("m_MAX_DEVS_EXCEEDED\n");
+		rc = -1;
+		goto out;
+	}
+	list = bstaus0 & m_DEVICE_COUNT;
+	if (list > MAX_DOWNSTREAM_DEVICE_NUM) {
+		pr_err("MAX_DOWNSTREAM_DEVICE_NUM\n");
+		rc = -1;
+		goto out;
+	}
+	if (bstaus1 & (1 << 3)) {
+		pr_err("MAX_CASCADE_EXCEEDED\n");
+		rc = -1;
+		goto out;
+	}
+	value = (list * KSV_LEN) + HEADER + SHAMAX;
+	ksvlistbuf = kmalloc(value, GFP_KERNEL);
+	if (!ksvlistbuf) {
+		pr_err("HDCP: kmalloc ksvlistbuf fail!\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+	ksvlistbuf[(list * KSV_LEN)] = bstaus0;
+	ksvlistbuf[(list * KSV_LEN) + 1] = bstaus1;
+	for (i = 2; i < value; i++) {
+		if (i < HEADER)	/* BSTATUS & M0 */
+			ksvlistbuf[(list * KSV_LEN) + i] =
+				hdmi_readl(hdmi_dev, HDCP_BSTATUS_0 + i + 1);
+		else if (i < (HEADER + (list * KSV_LEN))) /* KSV list */
+			ksvlistbuf[i - HEADER] =
+				hdmi_readl(hdmi_dev, HDCP_BSTATUS_0 + i + 1);
+		else /* SHA */
+			ksvlistbuf[i] =
+				hdmi_readl(hdmi_dev, HDCP_BSTATUS_0 + i + 1);
+	}
+	if (hdcpverify_ksv(ksvlistbuf, value) == true) {
+		rc = 0;
+		pr_info("ksv check valid\n");
+	} else {
+		pr_info("ksv check invalid\n");
+		rc = -1;
+	}
+	kfree(ksvlistbuf);
+out:
+	hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL, m_KSV_MEM_REQ, v_KSV_MEM_REQ(0));
+	return rc;
+}
+
+static void rockchip_hdmiv2_hdcp_2nd_auth(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	if (rockchip_hdmiv2_hdcp_ksvsha1(hdmi_dev))
+		hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL,
+			     m_SHA1_FAIL | m_KSV_UPDATE,
+			     v_SHA1_FAIL(1) | v_KSV_UPDATE(1));
+	else
+		hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL,
+			     m_SHA1_FAIL | m_KSV_UPDATE,
+			     v_SHA1_FAIL(0) | v_KSV_UPDATE(1));
+}
+
+static void hdcp_load_key(struct hdmi *hdmi, struct hdcp_keys *key)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	int i, value;
+
+	/* Disable decryption logic */
+	hdmi_writel(hdmi_dev, HDCPREG_RMCTL, 0);
+	/* Poll untile DPK write is allowed */
+	do {
+		value = hdmi_readl(hdmi_dev, HDCPREG_RMSTS);
+	} while ((value & m_DPK_WR_OK_STS) == 0);
+
+	/* write unencryped AKSV */
+	hdmi_writel(hdmi_dev, HDCPREG_DPK6, 0);
+	hdmi_writel(hdmi_dev, HDCPREG_DPK5, 0);
+	hdmi_writel(hdmi_dev, HDCPREG_DPK4, key->KSV[4]);
+	hdmi_writel(hdmi_dev, HDCPREG_DPK3, key->KSV[3]);
+	hdmi_writel(hdmi_dev, HDCPREG_DPK2, key->KSV[2]);
+	hdmi_writel(hdmi_dev, HDCPREG_DPK1, key->KSV[1]);
+	hdmi_writel(hdmi_dev, HDCPREG_DPK0, key->KSV[0]);
+	/* Poll untile DPK write is allowed */
+	do {
+		value = hdmi_readl(hdmi_dev, HDCPREG_RMSTS);
+	} while ((value & m_DPK_WR_OK_STS) == 0);
+
+	if (hdcp->seeds) {
+		hdmi_writel(hdmi_dev, HDCPREG_RMCTL, 1);
+		hdmi_writel(hdmi_dev, HDCPREG_SEED1, hdcp->seeds[0]);
+		hdmi_writel(hdmi_dev, HDCPREG_SEED0, hdcp->seeds[1]);
+	} else {
+		hdmi_writel(hdmi_dev, HDCPREG_RMCTL, 0);
+	}
+
+	/* write private key */
+	for (i = 0; i < HDCP_PRIVATE_KEY_SIZE; i += 7) {
+		hdmi_writel(hdmi_dev, HDCPREG_DPK6, key->devicekey[i + 6]);
+		hdmi_writel(hdmi_dev, HDCPREG_DPK5, key->devicekey[i + 5]);
+		hdmi_writel(hdmi_dev, HDCPREG_DPK4, key->devicekey[i + 4]);
+		hdmi_writel(hdmi_dev, HDCPREG_DPK3, key->devicekey[i + 3]);
+		hdmi_writel(hdmi_dev, HDCPREG_DPK2, key->devicekey[i + 2]);
+		hdmi_writel(hdmi_dev, HDCPREG_DPK1, key->devicekey[i + 1]);
+		hdmi_writel(hdmi_dev, HDCPREG_DPK0, key->devicekey[i]);
+
+		do {
+			value = hdmi_readl(hdmi_dev, HDCPREG_RMSTS);
+		} while ((value & m_DPK_WR_OK_STS) == 0);
+	}
+
+	pr_info("%s success\n", __func__);
+}
+
+static void hdcp_load_keys_cb(const struct firmware *fw,
+			      void *context)
+{
+	struct hdmi *hdmi = (struct hdmi *)context;
+
+	if (!fw) {
+		pr_info("HDCP: firmware is not loaded\n");
+		return;
+	}
+	if (fw->size < HDCP_KEY_SIZE) {
+		pr_err("HDCP: firmware wrong size %d\n", (int)fw->size);
+		return;
+	}
+	hdcp->keys = kmalloc(HDCP_KEY_SIZE, GFP_KERNEL);
+	memcpy(hdcp->keys, fw->data, HDCP_KEY_SIZE);
+
+	if (fw->size > HDCP_KEY_SIZE) {
+		if ((fw->size - HDCP_KEY_SIZE) < HDCP_KEY_SEED_SIZE) {
+			pr_err("HDCP: invalid seed key size\n");
+			return;
+		}
+		hdcp->seeds = kmalloc(HDCP_KEY_SEED_SIZE, GFP_KERNEL);
+		if (!hdcp->seeds)
+			return;
+
+		memcpy(hdcp->seeds, fw->data + HDCP_KEY_SIZE,
+		       HDCP_KEY_SEED_SIZE);
+	}
+	hdcp_load_key(hdmi, hdcp->keys);
+}
+
+void rockchip_hdmiv2_hdcp2_enable(int enable)
+{
+	struct hdmi_dev *hdmi_dev;
+
+	if (!hdcp) {
+		pr_err("rockchip hdmiv2 hdcp is not exist\n");
+		return;
+	}
+	hdmi_dev = hdcp->hdmi->property->priv;
+	if ((hdmi_readl(hdmi_dev, CONFIG1_ID) & m_HDCP22) == 0) {
+		pr_err("Don't support hdcp22\n");
+		return;
+	}
+	if (hdmi_dev->hdcp2_enable != enable) {
+		hdmi_dev->hdcp2_enable = enable;
+		if (hdmi_dev->hdcp2_enable == 0) {
+			hdmi_msk_reg(hdmi_dev, HDCP2REG_CTRL,
+				     m_HDCP2_OVR_EN | m_HDCP2_FORCE,
+				     v_HDCP2_OVR_EN(1) | v_HDCP2_FORCE(0));
+			hdmi_writel(hdmi_dev, HDCP2REG_MASK, 0xff);
+			hdmi_writel(hdmi_dev, HDCP2REG_MUTE, 0xff);
+		} else {
+			hdmi_msk_reg(hdmi_dev, HDCP2REG_CTRL,
+				     m_HDCP2_OVR_EN | m_HDCP2_FORCE,
+				     v_HDCP2_OVR_EN(0) | v_HDCP2_FORCE(0));
+			hdmi_writel(hdmi_dev, HDCP2REG_MASK, 0x00);
+			hdmi_writel(hdmi_dev, HDCP2REG_MUTE, 0x00);
+		}
+	}
+}
+EXPORT_SYMBOL(rockchip_hdmiv2_hdcp2_enable);
+
+void rockchip_hdmiv2_hdcp2_init(void (*hdcp2_enble)(int),
+				void (*hdcp2_reset)(void),
+				void (*hdcp2_start)(void))
+{
+	struct hdmi_dev *hdmi_dev;
+
+	if (!hdcp) {
+		pr_err("rockchip hdmiv2 hdcp is not exist\n");
+		return;
+	}
+	hdmi_dev = hdcp->hdmi->property->priv;
+	hdmi_dev->hdcp2_en = hdcp2_enble;
+	hdmi_dev->hdcp2_reset = hdcp2_reset;
+	hdmi_dev->hdcp2_start = hdcp2_start;
+}
+EXPORT_SYMBOL(rockchip_hdmiv2_hdcp2_init);
+
+static void rockchip_hdmiv2_hdcp_start(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	if (!hdcp->enable)
+		return;
+	if (hdmi_readl(hdmi_dev, CONFIG1_ID) & m_HDCP22) {
+		if (hdmi_dev->hdcp2_enable == 0) {
+			hdmi_msk_reg(hdmi_dev, HDCP2REG_CTRL,
+				     m_HDCP2_OVR_EN | m_HDCP2_FORCE,
+				     v_HDCP2_OVR_EN(1) | v_HDCP2_FORCE(0));
+			hdmi_writel(hdmi_dev, HDCP2REG_MASK, 0xff);
+			hdmi_writel(hdmi_dev, HDCP2REG_MUTE, 0xff);
+		} else {
+			hdmi_msk_reg(hdmi_dev, HDCP2REG_CTRL,
+				     m_HDCP2_OVR_EN | m_HDCP2_FORCE,
+				     v_HDCP2_OVR_EN(0) | v_HDCP2_FORCE(0));
+			hdmi_writel(hdmi_dev, HDCP2REG_MASK, 0x00);
+			hdmi_writel(hdmi_dev, HDCP2REG_MUTE, 0x00);
+		}
+	}
+
+	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
+		     m_FC_HDCP_KEEPOUT, v_FC_HDCP_KEEPOUT(1));
+	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0,
+		     m_HDMI_DVI, v_HDMI_DVI(hdmi->edid.sink_hdmi));
+	hdmi_writel(hdmi_dev, A_OESSWCFG, 0x40);
+	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0,
+		     m_ENCRYPT_BYPASS | m_FEATURE11_EN | m_SYNC_RI_CHECK,
+		     v_ENCRYPT_BYPASS(0) | v_FEATURE11_EN(0) |
+		     v_SYNC_RI_CHECK(1));
+	hdmi_msk_reg(hdmi_dev, A_HDCPCFG1,
+		     m_ENCRYPT_DISBALE | m_PH2UPSHFTENC,
+		     v_ENCRYPT_DISBALE(0) | v_PH2UPSHFTENC(1));
+	/* Reset HDCP Engine */
+	if (hdmi_readl(hdmi_dev, MC_CLKDIS) & m_HDCPCLK_DISABLE)
+		hdmi_msk_reg(hdmi_dev, A_HDCPCFG1,
+			     m_HDCP_SW_RST, v_HDCP_SW_RST(0));
+
+	hdmi_writel(hdmi_dev, A_APIINTMSK, 0x00);
+	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0, m_RX_DETECT, v_RX_DETECT(1));
+
+	hdmi_msk_reg(hdmi_dev, MC_CLKDIS,
+		     m_HDCPCLK_DISABLE, v_HDCPCLK_DISABLE(0));
+	if (hdmi_dev->hdcp2_start)
+		hdmi_dev->hdcp2_start();
+	pr_info("%s success\n", __func__);
+}
+
+static void rockchip_hdmiv2_hdcp_stop(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	if (!hdcp->enable)
+		return;
+
+	hdmi_msk_reg(hdmi_dev, MC_CLKDIS,
+		     m_HDCPCLK_DISABLE, v_HDCPCLK_DISABLE(1));
+	hdmi_writel(hdmi_dev, A_APIINTMSK, 0xff);
+	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0, m_RX_DETECT, v_RX_DETECT(0));
+	hdmi_msk_reg(hdmi_dev, A_KSVMEMCTRL,
+		     m_SHA1_FAIL | m_KSV_UPDATE,
+		     v_SHA1_FAIL(0) | v_KSV_UPDATE(0));
+	rockchip_hdmiv2_hdcp2_enable(0);
+}
+
+void rockchip_hdmiv2_hdcp_isr(struct hdmi_dev *hdmi_dev, int hdcp_int)
+{
+	pr_info("hdcp_int is 0x%02x\n", hdcp_int);
+
+	if (hdcp_int & m_KSVSHA1_CALC_INT) {
+		pr_info("hdcp sink is a repeater\n");
+		hdmi_submit_work(hdcp->hdmi, HDMI_HDCP_AUTH_2ND, 0, 0);
+	}
+	if (hdcp_int & 0x40) {
+		pr_info("hdcp check failed\n");
+		rockchip_hdmiv2_hdcp_stop(hdmi_dev->hdmi);
+		hdmi_submit_work(hdcp->hdmi, HDMI_ENABLE_HDCP, 0, 0);
+	}
+}
+
+static ssize_t hdcp_enable_read(struct device *device,
+				struct device_attribute *attr, char *buf)
+{
+	int enable = 0;
+
+	if (hdcp)
+		enable = hdcp->enable;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
+}
+
+static ssize_t hdcp_enable_write(struct device *device,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	int enable;
+
+	if (!hdcp)
+		return -EINVAL;
+	if (!hdcp->keys) {
+		pr_err("HDCP: key is not loaded\n");
+		return -EINVAL;
+	}
+	if (kstrtoint(buf, 0, &enable))
+		return -EINVAL;
+
+	if (hdcp->enable != enable) {
+		if (!hdcp->enable)
+			hdmi_submit_work(hdcp->hdmi, HDMI_ENABLE_HDCP, 0, 0);
+		else
+			rockchip_hdmiv2_hdcp_stop(hdcp->hdmi);
+		hdcp->enable =	enable;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(enable, 0644, hdcp_enable_read, hdcp_enable_write);
+
+static ssize_t hdcp_trytimes_read(struct device *device,
+				  struct device_attribute *attr, char *buf)
+{
+	int trytimes = 0;
+
+	if (hdcp)
+		trytimes = hdcp->retry_times;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", trytimes);
+}
+
+static ssize_t hdcp_trytimes_wrtie(struct device *device,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	int trytimes;
+
+	if (!hdcp)
+		return -EINVAL;
+
+	if (kstrtoint(buf, 0, &trytimes))
+		return -EINVAL;
+
+	if (hdcp->retry_times != trytimes)
+		hdcp->retry_times = trytimes;
+
+	return count;
+}
+
+static DEVICE_ATTR(trytimes, 0644, hdcp_trytimes_read, hdcp_trytimes_wrtie);
+
+static int hdcp_init(struct hdmi *hdmi)
+{
+	int ret;
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	mdev.minor = MISC_DYNAMIC_MINOR;
+	mdev.name = "hdcp";
+	mdev.mode = 0666;
+	hdcp = kmalloc(sizeof(*hdcp), GFP_KERNEL);
+	if (!hdcp) {
+		pr_err("HDCP: kmalloc fail!\n");
+		ret = -ENOMEM;
+		goto error0;
+	}
+	memset(hdcp, 0, sizeof(struct hdcp));
+	hdcp->hdmi = hdmi;
+	if (misc_register(&mdev)) {
+		pr_err("HDCP: Could not add character driver\n");
+		ret = HDMI_ERROR_FALSE;
+		goto error1;
+	}
+	ret = device_create_file(mdev.this_device, &dev_attr_enable);
+	if (ret) {
+		pr_err("HDCP: Could not add sys file enable\n");
+		ret = -EINVAL;
+		goto error2;
+	}
+	ret = device_create_file(mdev.this_device, &dev_attr_trytimes);
+	if (ret) {
+		pr_err("HDCP: Could not add sys file enable\n");
+		ret = -EINVAL;
+		goto error3;
+	}
+
+	ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG,
+				      "hdcp", mdev.this_device, GFP_KERNEL,
+				      hdmi, hdcp_load_keys_cb);
+
+	if (ret < 0) {
+		pr_err("HDCP: request_firmware_nowait failed: %d\n", ret);
+		goto error4;
+	}
+	if ((hdmi_readl(hdmi_dev, MC_CLKDIS) & m_HDCPCLK_DISABLE) == 0)
+		hdcp->enable = 1;
+	hdmi->ops->hdcp_cb = rockchip_hdmiv2_hdcp_start;
+	hdmi->ops->hdcp_auth2nd = rockchip_hdmiv2_hdcp_2nd_auth;
+	hdmi->ops->hdcp_power_off_cb = rockchip_hdmiv2_hdcp_stop;
+	return 0;
+
+error4:
+	device_remove_file(mdev.this_device, &dev_attr_trytimes);
+error3:
+	device_remove_file(mdev.this_device, &dev_attr_enable);
+error2:
+	misc_deregister(&mdev);
+error1:
+	kfree(hdcp);
+error0:
+	return ret;
+}
+
+void rockchip_hdmiv2_hdcp_init(struct hdmi *hdmi)
+{
+	pr_info("%s", __func__);
+
+	if (!hdcp) {
+		hdcp_init(hdmi);
+	} else {
+		if (hdcp->keys)
+			hdcp_load_key(hdmi, hdcp->keys);
+		else
+			pr_info("hdcpkeys is no load\n");
+	}
+}
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2310 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/rockchip/grf.h>
+#include "rockchip_hdmiv2.h"
+#include "rockchip_hdmiv2_hw.h"
+
+#define HDMI_SEL_LCDC(x, bit)	((((x) & 1) << bit) | (1 << (16 + bit)))
+#define RK3399_GRF_SOC_CON20 0x6250
+
+static const struct phy_mpll_config_tab PHY_MPLL_TABLE[] = {
+/*	tmdsclk = (pixclk / ref_cntrl ) * (fbdiv2 * fbdiv1) / nctrl / tmdsmhl
+ *	opmode: 0:HDMI1.4	1:HDMI2.0
+ *
+ *	|pixclock|	tmdsclock|pixrepet|colordepth|prepdiv|tmdsmhl|opmode|
+ *		fbdiv2|fbdiv1|ref_cntrl|nctrl|propctrl|intctrl|gmpctrl|
+ */
+	{27000000,	27000000,	0,	8,	0,	0,	0,
+		2,	3,	0,	3,	3,	0,	0},
+	{27000000,	27000000,	1,	8,	0,	0,	0,
+		2,	3,	0,	3,	3,	0,	0},
+	{27000000,	33750000,	0,	10,	1,	0,	0,
+		5,	1,	0,	3,	3,	0,	0},
+	{27000000,	33750000,	1,	10,	1,	0,	0,
+		5,	1,	0,	3,	3,	0,	0},
+	{27000000,	40500000,	0,	12,	2,	0,	0,
+		3,	3,	0,	3,	3,	0,	0},
+	{27000000,	54000000,	0,	16,	3,	0,	0,
+		2,	3,	0,	2,	5,	0,	1},
+	{59400000,	59400000,	0,	8,	0,	0,	0,
+		1,	3,	0,	2,	5,	0,	1},
+	{59400000,	74250000,	0,	10,	1,	0,	0,
+		5,	0,	0,	2,	5,	0,	1},
+	{59400000,	89100000,	0,	12,	2,	0,	0,
+		2,	2,	0,	2,	5,	0,	1},
+	{59400000,	118800000,	0,	16,	3,	0,	0,
+		1,	3,	0,	1,	7,	0,	2},
+	{65000000,	65000000,	0,	8,	0,	0,	0,
+		1,	3,	0,	2,	5,	0,	1},
+	{74250000,      74250000,	0,      8,      0,      0,      0,
+		4,      3,      3,      2,      7,      0,      3},
+	{74250000,	92812500,	0,	10,	1,	0,	0,
+		5,	0,	1,	1,	7,	0,	2},
+	{74250000,	111375000,	0,	12,	2,	0,	0,
+		1,	2,	0,	1,	7,	0,	2},
+	{74250000,	148500000,	0,	16,	3,	0,	0,
+		1,	3,	0,	1,	7,	0,	2},
+	{83500000,	83500000,	0,	8,	0,	0,	0,
+		1,	3,	0,	2,	5,	0,	1},
+	{85500000,	85500000,	0,	8,	0,	0,	0,
+		1,	3,	0,	2,	5,	0,	1},
+	{106500000,	106500000,	0,	8,	0,	0,	0,
+		1,	1,	0,	1,	7,	0,	2},
+	{108000000,	108000000,	0,	8,	0,	0,	0,
+		1,	1,	0,	1,	7,	0,	2},
+	{146250000,	146250000,	0,	8,	0,	0,	0,
+		1,	1,	0,	1,	7,	0,	2},
+	{148500000,	74250000,	0,	8,	0,	0,	0,
+		1,	1,	1,	1,	0,	0,	3},
+	{148500000,	148500000,	0,	8,	0,	0,	0,
+		1,	1,	0,	1,	0,	0,	3},
+	{148500000,	185625000,	0,	10,	1,	0,	0,
+		5,	0,	3,	0,	7,	0,	3},
+	{148500000,	222750000,	0,	12,	2,	0,	0,
+		1,	2,	1,	0,	7,	0,	3},
+	{148500000,	297000000,	0,	16,	3,	0,	0,
+		1,	1,	0,	0,	7,	0,	3},
+	{148500000,	297000000,	0,	8,	0,	0,	0,
+		1,	1,	0,	0,	0,	0,	3},
+	{148500000,	594000000,	0,	8,	0,	3,	1,
+		1,	3,	0,	0,	0,	0,	3},
+	{269390000,	269390000,	0,	8,	0,	0,	0,
+		1,	0,	0,	0,	0,	0,	3},
+	{285000000,	285000000,	0,	8,	0,	0,	0,
+		1,	0,	0,	0,	0,	0,	3},
+	{297000000,	148500000,	0,	8,	0,	0,	0,
+		1,	0,	1,	0,	0,	0,	3},
+	{297000000,	297000000,	0,	8,	0,	0,	0,
+		1,	0,	0,	0,	0,	0,	3},
+	{297000000,	371250000,	0,	10,	1,	3,	1,
+		5,	1,	3,	1,	7,	0,	3},
+	{297000000,	445500000,	0,	12,	2,	3,	1,
+		1,	2,	0,	1,	7,	0,	3},
+	{297000000,	594000000,	0,	16,	3,	3,	1,
+		1,	3,	1,	0,	0,	0,	3},
+	{340000000,	340000000,	0,	8,	0,	0,	0,
+		1,	0,	0,	0,	0,	0,	3},
+	{403000000,	403000000,	0,	8,	0,	3,	1,
+		1,	3,	3,	0,	0,	0,	3},
+	{594000000,	297000000,	0,	8,	0,	0,	0,
+		1,	0,	1,	0,	0,	0,	3},
+	{594000000,	371250000,	0,	10,	1,	3,	1,
+		5,	0,	3,	1,	7,	0,	3},
+	{594000000,	445500000,	0,	12,	2,	3,	1,
+		1,	2,	1,	1,	7,	0,	3},
+	{594000000,	594000000,	0,	16,	3,	3,	1,
+		1,	3,	3,	0,	0,	0,	3},
+	{594000000,	594000000,	0,	8,	0,	3,	1,
+		1,	3,	3,	0,	0,	0,	3},
+};
+
+static const struct ext_pll_config_tab EXT_PLL_TABLE[] = {
+	{27000000,	27000000,	8,	1,	90,	3,	2,
+		2,	10,	3,	3,	4,	0,	1,	40,
+		8},
+	{27000000,	33750000,	10,	1,	90,	1,	3,
+		3,	10,	3,	3,	4,	0,	1,	40,
+		8},
+	{59400000,	59400000,	8,	1,	99,	3,	2,
+		2,	1,	3,	3,	4,	0,	1,	40,
+		8},
+	{59400000,	74250000,	10,	1,	99,	1,	2,
+		2,	1,	3,	3,	4,	0,	1,	40,
+		8},
+	{74250000,	74250000,	8,	1,	99,	1,	2,
+		2,	1,	2,	3,	4,	0,	1,	40,
+		8},
+	{74250000,	92812500,	10,	4,	495,	1,	2,
+		2,	1,	3,	3,	4,	0,	2,	40,
+		4},
+	{148500000,	148500000,	8,	1,	99,	1,	1,
+		1,	1,	2,	2,	2,	0,	2,	40,
+		4},
+	{148500000,	185625000,	10,	4,	495,	0,	2,
+		2,	1,	3,	2,	2,	0,	4,	40,
+		2},
+	{297000000,	297000000,	8,	1,	99,	0,	1,
+		1,	1,	0,	2,	2,	0,	4,	40,
+		2},
+	{297000000,	371250000,	10,	4,	495,	1,	2,
+		0,	1,	3,	1,	1,	0,	8,	40,
+		1},
+	{594000000,	297000000,	8,	1,	99,	0,	1,
+		1,	1,	0,	2,	1,	0,	4,	40,
+		2},
+	{594000000,	371250000,	10,	4,	495,	1,	2,
+		0,	1,	3,	1,	1,	1,	8,	40,
+		1},
+	{594000000,	594000000,	8,	1,	99,	0,	2,
+		0,	1,	0,	1,	1,	0,	8,	40,
+		1},
+};
+
+/* ddc i2c master reset */
+static void rockchip_hdmiv2_i2cm_reset(struct hdmi_dev *hdmi_dev)
+{
+	hdmi_msk_reg(hdmi_dev, I2CM_SOFTRSTZ,
+		     m_I2CM_SOFTRST, v_I2CM_SOFTRST(0));
+	usleep_range(90, 100);
+}
+
+/*set read/write offset,set read/write mode*/
+static void rockchip_hdmiv2_i2cm_write_request(struct hdmi_dev *hdmi_dev,
+					       u8 offset, u8 data)
+{
+	hdmi_writel(hdmi_dev, I2CM_ADDRESS, offset);
+	hdmi_writel(hdmi_dev, I2CM_DATAO, data);
+	hdmi_msk_reg(hdmi_dev, I2CM_OPERATION, m_I2CM_WR, v_I2CM_WR(1));
+}
+
+static void rockchip_hdmiv2_i2cm_read_request(struct hdmi_dev *hdmi_dev,
+					      u8 offset)
+{
+	hdmi_writel(hdmi_dev, I2CM_ADDRESS, offset);
+	hdmi_msk_reg(hdmi_dev, I2CM_OPERATION, m_I2CM_RD, v_I2CM_RD(1));
+}
+
+static void rockchip_hdmiv2_i2cm_write_data(struct hdmi_dev *hdmi_dev,
+					    u8 data, u8 offset)
+{
+	u8 interrupt = 0;
+	int trytime = 2;
+	int i = 20;
+
+	while (trytime-- > 0) {
+		rockchip_hdmiv2_i2cm_write_request(hdmi_dev, offset, data);
+		while (i--) {
+			usleep_range(900, 1000);
+			interrupt = hdmi_readl(hdmi_dev, IH_I2CM_STAT0);
+			if (interrupt)
+				hdmi_writel(hdmi_dev,
+					    IH_I2CM_STAT0, interrupt);
+
+			if (interrupt & (m_SCDC_READREQ |
+					 m_I2CM_DONE | m_I2CM_ERROR))
+				break;
+		}
+
+		if (interrupt & m_I2CM_DONE) {
+			dev_dbg(hdmi_dev->hdmi->dev,
+				"[%s] write offset %02x data %02x success\n",
+				__func__, offset, data);
+			trytime = 0;
+		} else if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
+			dev_err(hdmi_dev->hdmi->dev,
+				"[%s] write data error\n", __func__);
+			rockchip_hdmiv2_i2cm_reset(hdmi_dev);
+		}
+	}
+}
+
+static int rockchip_hdmiv2_i2cm_read_data(struct hdmi_dev *hdmi_dev, u8 offset)
+{
+	u8 interrupt = 0, val;
+	int trytime = 2;
+	int i = 20;
+
+	while (trytime-- > 0) {
+		rockchip_hdmiv2_i2cm_read_request(hdmi_dev, offset);
+		while (i--) {
+			usleep_range(900, 1000);
+			interrupt = hdmi_readl(hdmi_dev, IH_I2CM_STAT0);
+			if (interrupt)
+				hdmi_writel(hdmi_dev, IH_I2CM_STAT0, interrupt);
+
+			if (interrupt & (m_SCDC_READREQ |
+				m_I2CM_DONE | m_I2CM_ERROR))
+				break;
+		}
+
+		if (interrupt & m_I2CM_DONE) {
+			val = hdmi_readl(hdmi_dev, I2CM_DATAI);
+			trytime = 0;
+		} else if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
+			pr_err("[%s] read data error\n", __func__);
+			rockchip_hdmiv2_i2cm_reset(hdmi_dev);
+		}
+	}
+	return val;
+}
+
+static void rockchip_hdmiv2_i2cm_mask_int(struct hdmi_dev *hdmi_dev, int mask)
+{
+	if (!mask) {
+		hdmi_msk_reg(hdmi_dev, I2CM_INT,
+			     m_I2CM_DONE_MASK, v_I2CM_DONE_MASK(0));
+		hdmi_msk_reg(hdmi_dev, I2CM_CTLINT,
+			     m_I2CM_NACK_MASK | m_I2CM_ARB_MASK,
+			     v_I2CM_NACK_MASK(0) | v_I2CM_ARB_MASK(0));
+	} else {
+		hdmi_msk_reg(hdmi_dev, I2CM_INT,
+			     m_I2CM_DONE_MASK, v_I2CM_DONE_MASK(1));
+		hdmi_msk_reg(hdmi_dev, I2CM_CTLINT,
+			     m_I2CM_NACK_MASK | m_I2CM_ARB_MASK,
+			     v_I2CM_NACK_MASK(1) | v_I2CM_ARB_MASK(1));
+	}
+}
+
+#define I2C_DIV_FACTOR 1000000
+static u16 i2c_count(u16 sfrclock, u16 sclmintime)
+{
+	unsigned long tmp_scl_period = 0;
+
+	if (((sfrclock * sclmintime) % I2C_DIV_FACTOR) != 0)
+		tmp_scl_period = (unsigned long)((sfrclock * sclmintime) +
+				(I2C_DIV_FACTOR - ((sfrclock * sclmintime) %
+				I2C_DIV_FACTOR))) / I2C_DIV_FACTOR;
+	else
+		tmp_scl_period = (unsigned long)(sfrclock * sclmintime) /
+				I2C_DIV_FACTOR;
+
+	return (u16)(tmp_scl_period);
+}
+
+#define EDID_I2C_MIN_SS_SCL_HIGH_TIME	9625
+#define EDID_I2C_MIN_SS_SCL_LOW_TIME	10000
+
+static void rockchip_hdmiv2_i2cm_clk_init(struct hdmi_dev *hdmi_dev)
+{
+	int value;
+
+	/* Set DDC I2C CLK which divided from DDC_CLK. */
+	value = i2c_count(24000, EDID_I2C_MIN_SS_SCL_HIGH_TIME);
+	hdmi_writel(hdmi_dev, I2CM_SS_SCL_HCNT_0_ADDR,
+		    value & 0xff);
+	hdmi_writel(hdmi_dev, I2CM_SS_SCL_HCNT_1_ADDR,
+		    (value >> 8) & 0xff);
+	value = i2c_count(24000, EDID_I2C_MIN_SS_SCL_LOW_TIME);
+	hdmi_writel(hdmi_dev, I2CM_SS_SCL_LCNT_0_ADDR,
+		    value & 0xff);
+	hdmi_writel(hdmi_dev, I2CM_SS_SCL_LCNT_1_ADDR,
+		    (value >> 8) & 0xff);
+	hdmi_msk_reg(hdmi_dev, I2CM_DIV, m_I2CM_FAST_STD_MODE,
+		     v_I2CM_FAST_STD_MODE(STANDARD_MODE));
+}
+
+static int rockchip_hdmiv2_scdc_get_sink_version(struct hdmi_dev *hdmi_dev)
+{
+	return rockchip_hdmiv2_i2cm_read_data(hdmi_dev, SCDC_SINK_VER);
+}
+
+static void rockchip_hdmiv2_scdc_set_source_version(struct hdmi_dev *hdmi_dev,
+						    u8 version)
+{
+	rockchip_hdmiv2_i2cm_write_data(hdmi_dev, version, SCDC_SOURCE_VER);
+}
+
+static void rockchip_hdmiv2_scdc_read_request(struct hdmi_dev *hdmi_dev,
+					      int enable)
+{
+	hdmi_msk_reg(hdmi_dev, I2CM_SCDC_READ_UPDATE,
+		     m_I2CM_READ_REQ_EN, v_I2CM_READ_REQ_EN(enable));
+	rockchip_hdmiv2_i2cm_write_data(hdmi_dev, enable, SCDC_CONFIG_0);
+}
+
+#ifdef HDMI_20_SCDC
+static void rockchip_hdmiv2_scdc_update_read(struct hdmi_dev *hdmi_dev)
+{
+	hdmi_msk_reg(hdmi_dev, I2CM_SCDC_READ_UPDATE,
+		     m_I2CM_READ_UPDATE, v_I2CM_READ_UPDATE(1));
+}
+
+static int rockchip_hdmiv2_scdc_get_scambling_status(struct hdmi_dev *hdmi_dev)
+{
+	int val;
+
+	val = rockchip_hdmiv2_i2cm_read_data(hdmi_dev, SCDC_SCRAMBLER_STAT);
+	return val;
+}
+
+static void rockchip_hdmiv2_scdc_enable_polling(struct hdmi_dev *hdmi_dev,
+						int enable)
+{
+	rockchip_hdmiv2_scdc_read_request(hdmi_dev, enable);
+	hdmi_msk_reg(hdmi_dev, I2CM_SCDC_READ_UPDATE,
+		     m_I2CM_UPRD_VSYNC_EN, v_I2CM_UPRD_VSYNC_EN(enable));
+}
+
+static int rockchip_hdmiv2_scdc_get_status_reg0(struct hdmi_dev *hdmi_dev)
+{
+	rockchip_hdmiv2_scdc_read_request(hdmi_dev, 1);
+	rockchip_hdmiv2_scdc_update_read(hdmi_dev);
+	return hdmi_readl(hdmi_dev, I2CM_SCDC_UPDATE0);
+}
+
+static int rockchip_hdmiv2_scdc_get_status_reg1(struct hdmi_dev *hdmi_dev)
+{
+	rockchip_hdmiv2_scdc_read_request(hdmi_dev, 1);
+	rockchip_hdmiv2_scdc_update_read(hdmi_dev);
+	return hdmi_readl(hdmi_dev, I2CM_SCDC_UPDATE1);
+}
+#endif
+
+static void rockchip_hdmiv2_scdc_init(struct hdmi_dev *hdmi_dev)
+{
+	rockchip_hdmiv2_i2cm_reset(hdmi_dev);
+	rockchip_hdmiv2_i2cm_mask_int(hdmi_dev, 1);
+	rockchip_hdmiv2_i2cm_clk_init(hdmi_dev);
+	/* set scdc i2c addr */
+	hdmi_writel(hdmi_dev, I2CM_SLAVE, DDC_I2C_SCDC_ADDR);
+	rockchip_hdmiv2_i2cm_mask_int(hdmi_dev, 0);/*enable interrupt*/
+}
+
+static void rockchip_hdmiv2_scdc_set_tmds_rate(struct hdmi_dev *hdmi_dev)
+{
+	int stat;
+
+	mutex_lock(&hdmi_dev->ddc_lock);
+	rockchip_hdmiv2_scdc_init(hdmi_dev);
+	stat = rockchip_hdmiv2_i2cm_read_data(hdmi_dev,
+					      SCDC_TMDS_CONFIG);
+	if (hdmi_dev->tmdsclk > 340000000)
+		stat |= 2;
+	else
+		stat &= 0x1;
+	rockchip_hdmiv2_i2cm_write_data(hdmi_dev,
+					stat, SCDC_TMDS_CONFIG);
+	mutex_unlock(&hdmi_dev->ddc_lock);
+}
+
+static int rockchip_hdmiv2_scrambling_enable(struct hdmi_dev *hdmi_dev,
+					     int enable)
+{
+	HDMIDBG(2, "%s enable %d\n", __func__, enable);
+	if (enable == 1) {
+		/* Write on Rx the bit Scrambling_Enable, register 0x20 */
+		rockchip_hdmiv2_i2cm_write_data(hdmi_dev, 1, SCDC_TMDS_CONFIG);
+		/* TMDS software reset request */
+		hdmi_msk_reg(hdmi_dev, MC_SWRSTZREQ,
+			     m_TMDS_SWRST, v_TMDS_SWRST(0));
+		/* Enable/Disable Scrambling */
+		hdmi_msk_reg(hdmi_dev, FC_SCRAMBLER_CTRL,
+			     m_FC_SCRAMBLE_EN, v_FC_SCRAMBLE_EN(1));
+	} else {
+		/* Enable/Disable Scrambling */
+		hdmi_msk_reg(hdmi_dev, FC_SCRAMBLER_CTRL,
+			     m_FC_SCRAMBLE_EN, v_FC_SCRAMBLE_EN(0));
+		/* TMDS software reset request */
+		hdmi_msk_reg(hdmi_dev, MC_SWRSTZREQ,
+			     m_TMDS_SWRST, v_TMDS_SWRST(0));
+		/* Write on Rx the bit Scrambling_Enable, register 0x20 */
+		rockchip_hdmiv2_i2cm_write_data(hdmi_dev, 0, SCDC_TMDS_CONFIG);
+	}
+	return 0;
+}
+
+static const struct ext_pll_config_tab *get_phy_ext_tab(
+		unsigned int pixclock, unsigned int tmdsclk,
+		char colordepth)
+{
+	int i;
+
+	if (pixclock == 0)
+		return NULL;
+	HDMIDBG(2, "%s pixClock %u tmdsclk %u colorDepth %d\n",
+		__func__, pixclock, tmdsclk, colordepth);
+	for (i = 0; i < ARRAY_SIZE(EXT_PLL_TABLE); i++) {
+		if ((EXT_PLL_TABLE[i].pix_clock == pixclock) &&
+		    (EXT_PLL_TABLE[i].tmdsclock == tmdsclk) &&
+		    (EXT_PLL_TABLE[i].color_depth == colordepth))
+			return &EXT_PLL_TABLE[i];
+	}
+	return NULL;
+}
+
+static const struct phy_mpll_config_tab *get_phy_mpll_tab(
+		unsigned int pixclock, unsigned int tmdsclk,
+		char pixrepet, char colordepth)
+{
+	int i;
+
+	if (pixclock == 0)
+		return NULL;
+	HDMIDBG(2, "%s pixClock %u tmdsclk %u pixRepet %d colorDepth %d\n",
+		__func__, pixclock, tmdsclk, pixrepet, colordepth);
+	for (i = 0; i < ARRAY_SIZE(PHY_MPLL_TABLE); i++) {
+		if ((PHY_MPLL_TABLE[i].pix_clock == pixclock) &&
+		    (PHY_MPLL_TABLE[i].tmdsclock == tmdsclk) &&
+		    (PHY_MPLL_TABLE[i].pix_repet == pixrepet) &&
+		    (PHY_MPLL_TABLE[i].color_depth == colordepth))
+			return &PHY_MPLL_TABLE[i];
+	}
+	return NULL;
+}
+
+static void rockchip_hdmiv2_powerdown(struct hdmi_dev *hdmi_dev)
+{
+	hdmi_msk_reg(hdmi_dev, PHY_MASK, m_PHY_LOCK, v_PHY_LOCK(1));
+
+	if (hdmi_dev->soctype != HDMI_SOC_RK322X) {
+		hdmi_msk_reg(hdmi_dev, PHY_CONF0,
+			     m_PDDQ_SIG | m_TXPWRON_SIG |
+			     m_ENHPD_RXSENSE_SIG | m_SVSRET_SIG,
+			     v_PDDQ_SIG(1) | v_TXPWRON_SIG(0) |
+			     v_ENHPD_RXSENSE_SIG(1)) | v_SVSRET_SIG(0);
+	} else {
+		hdmi_msk_reg(hdmi_dev, PHY_CONF0,
+			     m_TXPWRON_SIG | m_ENHPD_RXSENSE_SIG,
+			     v_TXPWRON_SIG(0) | v_ENHPD_RXSENSE_SIG(0));
+		regmap_write(hdmi_dev->grf_base,
+			     RK322X_GRF_SOC_CON2,
+			     RK322X_PLL_PDATA_DEN);
+	}
+	hdmi_writel(hdmi_dev, MC_CLKDIS, 0x7f);
+}
+
+int rockchip_hdmiv2_write_phy(struct hdmi_dev *hdmi_dev,
+			      int reg_addr, int val)
+{
+	int trytime = 2, i = 0, op_status = 0;
+
+	if (hdmi_dev->phybase) {
+		writel_relaxed(val, hdmi_dev->phybase + (reg_addr) * 0x04);
+		return 0;
+	}
+	while (trytime--) {
+		hdmi_writel(hdmi_dev, PHY_I2CM_ADDRESS, reg_addr);
+		hdmi_writel(hdmi_dev, PHY_I2CM_DATAO_1, (val >> 8) & 0xff);
+		hdmi_writel(hdmi_dev, PHY_I2CM_DATAO_0, val & 0xff);
+		hdmi_writel(hdmi_dev, PHY_I2CM_OPERATION, m_PHY_I2CM_WRITE);
+
+		i = 20;
+		while (i--) {
+			usleep_range(900, 1000);
+			op_status = hdmi_readl(hdmi_dev, IH_I2CMPHY_STAT0);
+			if (op_status)
+				hdmi_writel(hdmi_dev,
+					    IH_I2CMPHY_STAT0,
+					    op_status);
+
+			if (op_status & (m_I2CMPHY_DONE | m_I2CMPHY_ERR))
+				break;
+		}
+
+		if (!(op_status & m_I2CMPHY_DONE))
+			dev_err(hdmi_dev->hdmi->dev,
+				"[%s] operation error,trytime=%d\n",
+				__func__, trytime);
+		else
+			return 0;
+		msleep(100);
+	}
+
+	return -1;
+}
+
+int rockchip_hdmiv2_read_phy(struct hdmi_dev *hdmi_dev,
+			     int reg_addr)
+{
+	int trytime = 2, i = 0, op_status = 0;
+	int val = 0;
+
+	if (hdmi_dev->phybase)
+		return readl_relaxed(hdmi_dev->phybase + (reg_addr) * 0x04);
+
+	while (trytime--) {
+		hdmi_writel(hdmi_dev, PHY_I2CM_ADDRESS, reg_addr);
+		hdmi_writel(hdmi_dev, PHY_I2CM_DATAI_1, 0x00);
+		hdmi_writel(hdmi_dev, PHY_I2CM_DATAI_0, 0x00);
+		hdmi_writel(hdmi_dev, PHY_I2CM_OPERATION, m_PHY_I2CM_READ);
+
+		i = 20;
+		while (i--) {
+			usleep_range(900, 1000);
+			op_status = hdmi_readl(hdmi_dev, IH_I2CMPHY_STAT0);
+			if (op_status)
+				hdmi_writel(hdmi_dev, IH_I2CMPHY_STAT0,
+					    op_status);
+
+			if (op_status & (m_I2CMPHY_DONE | m_I2CMPHY_ERR))
+				break;
+		}
+
+		if (!(op_status & m_I2CMPHY_DONE)) {
+			pr_err("[%s] operation error,trytime=%d\n",
+			       __func__, trytime);
+		} else {
+			val = hdmi_readl(hdmi_dev, PHY_I2CM_DATAI_1);
+			val = (val & 0xff) << 8;
+			val += (hdmi_readl(hdmi_dev, PHY_I2CM_DATAI_0) & 0xff);
+			pr_debug("phy_reg0x%02x: 0x%04x",
+				 reg_addr, val);
+			return val;
+		}
+		msleep(100);
+	}
+
+	return -1;
+}
+
+#define PHY_TIMEOUT	10000
+
+static int ext_phy_config(struct hdmi_dev *hdmi_dev)
+{
+	int stat = 0, i = 0, temp;
+	const struct ext_pll_config_tab *phy_ext = NULL;
+
+	if (hdmi_dev->grf_base)
+		regmap_write(hdmi_dev->grf_base,
+			     RK322X_GRF_SOC_CON2,
+			     RK322X_PLL_POWER_DOWN |
+			     RK322X_PLL_PDATA_DEN);
+	if (hdmi_dev->tmdsclk_ratio_change &&
+	    hdmi_dev->hdmi->edid.scdc_present == 1)
+		rockchip_hdmiv2_scdc_set_tmds_rate(hdmi_dev);
+
+	/* config the required PHY I2C register */
+	phy_ext = get_phy_ext_tab(hdmi_dev->pixelclk,
+				  hdmi_dev->tmdsclk,
+				  hdmi_dev->colordepth);
+	if (phy_ext) {
+		stat = ((phy_ext->pll_nf >> 1) & EXT_PHY_PLL_FB_BIT8_MASK) |
+		       ((phy_ext->vco_div_5 & 1) << 5) |
+		       (phy_ext->pll_nd & EXT_PHY_PLL_PRE_DIVIDER_MASK);
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_PLL_PRE_DIVIDER, stat);
+		stat = phy_ext->pll_nf & 0xff;
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_PLL_FB_DIVIDER, stat);
+		stat = (phy_ext->pclk_divider_a & EXT_PHY_PCLK_DIVIDERA_MASK) |
+		       ((phy_ext->pclk_divider_b & 3) << 5);
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_PCLK_DIVIDER1, stat);
+		stat = (phy_ext->pclk_divider_d & EXT_PHY_PCLK_DIVIDERD_MASK) |
+		       ((phy_ext->pclk_divider_c & 3) << 5);
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_PCLK_DIVIDER2, stat);
+		stat = ((phy_ext->tmsd_divider_c & 3) << 4) |
+		       ((phy_ext->tmsd_divider_a & 3) << 2) |
+		       (phy_ext->tmsd_divider_b & 3);
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_TMDSCLK_DIVIDER, stat);
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_PPLL_FB_DIVIDER,
+					  phy_ext->ppll_nf);
+
+		if (phy_ext->ppll_no == 1) {
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  EXT_PHY_PPLL_POST_DIVIDER,
+						  0);
+			stat = 0x20 | phy_ext->ppll_nd;
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  EXT_PHY_PPLL_PRE_DIVIDER,
+						  stat);
+		} else {
+			stat = ((phy_ext->ppll_no / 2) - 1) << 4;
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  EXT_PHY_PPLL_POST_DIVIDER,
+						  stat);
+			stat = 0xe0 | phy_ext->ppll_nd;
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  EXT_PHY_PPLL_PRE_DIVIDER,
+						  stat);
+		}
+	} else {
+		pr_err("%s no supported phy configuration.\n", __func__);
+		return -1;
+	}
+
+	if (hdmi_dev->phy_table) {
+		for (i = 0; i < hdmi_dev->phy_table_size; i++) {
+			temp = hdmi_dev->phy_table[i].maxfreq;
+			if (hdmi_dev->tmdsclk <= temp)
+				break;
+		}
+	}
+
+	if (i != hdmi_dev->phy_table_size && hdmi_dev->phy_table) {
+		if (hdmi_dev->phy_table[i].slopeboost) {
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  EXT_PHY_SIGNAL_CTRL, 0xff);
+			temp = hdmi_dev->phy_table[i].slopeboost - 1;
+			stat = ((temp & 3) << 6) | ((temp & 3) << 4) |
+			       ((temp & 3) << 2) | (temp & 3);
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  EXT_PHY_SLOPEBOOST, stat);
+		} else {
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  EXT_PHY_SIGNAL_CTRL, 0x0f);
+		}
+		stat = ((hdmi_dev->phy_table[i].pre_emphasis & 3) << 4) |
+		       ((hdmi_dev->phy_table[i].pre_emphasis & 3) << 2) |
+		       (hdmi_dev->phy_table[i].pre_emphasis & 3);
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_PREEMPHASIS, stat);
+		stat = ((hdmi_dev->phy_table[i].clk_level & 0xf) << 4) |
+		       (hdmi_dev->phy_table[i].data2_level & 0xf);
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_LEVEL1, stat);
+		stat = ((hdmi_dev->phy_table[i].data1_level & 0xf) << 4) |
+		       (hdmi_dev->phy_table[i].data0_level & 0xf);
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_LEVEL2, stat);
+	} else {
+		rockchip_hdmiv2_write_phy(hdmi_dev,
+					  EXT_PHY_SIGNAL_CTRL, 0x0f);
+	}
+	rockchip_hdmiv2_write_phy(hdmi_dev, 0xf3, 0x22);
+
+	stat = clk_get_rate(hdmi_dev->pclk_phy) / 100000;
+	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_TERM_CAL,
+				  ((stat >> 8) & 0xff) | 0x80);
+	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_TERM_CAL_DIV_L,
+				  stat & 0xff);
+	if (hdmi_dev->tmdsclk > 340000000)
+		stat = EXT_PHY_AUTO_R100_OHMS;
+	else if (hdmi_dev->tmdsclk > 200000000)
+		stat = EXT_PHY_AUTO_R50_OHMS;
+	else
+		stat = EXT_PHY_AUTO_ROPEN_CIRCUIT;
+	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_TERM_RESIS_AUTO,
+				  stat | 0x20);
+	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_TERM_CAL,
+				  (stat >> 8) & 0xff);
+	if (hdmi_dev->tmdsclk > 200000000)
+		stat = 0;
+	else
+		stat = 0x11;
+	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_PLL_BW, stat);
+	rockchip_hdmiv2_write_phy(hdmi_dev, EXT_PHY_PPLL_BW, 0x27);
+	if (hdmi_dev->grf_base)
+		regmap_write(hdmi_dev->grf_base,
+			     RK322X_GRF_SOC_CON2,
+			     RK322X_PLL_POWER_UP);
+	if (hdmi_dev->tmdsclk_ratio_change)
+		msleep(100);
+	else
+		usleep_range(900, 1000);
+	hdmi_msk_reg(hdmi_dev, PHY_CONF0,
+		     m_TXPWRON_SIG, v_TXPWRON_SIG(1));
+	i = 0;
+	while (i++ < PHY_TIMEOUT) {
+		if ((i % 10) == 0) {
+			temp = EXT_PHY_PPLL_POST_DIVIDER;
+			stat = rockchip_hdmiv2_read_phy(hdmi_dev, temp);
+			if (stat & EXT_PHY_PPLL_LOCK_STATUS_MASK)
+				break;
+			usleep_range(1000, 2000);
+		}
+	}
+	if ((stat & EXT_PHY_PPLL_LOCK_STATUS_MASK) == 0) {
+		stat = hdmi_readl(hdmi_dev, MC_LOCKONCLOCK);
+		dev_err(hdmi_dev->hdmi->dev,
+			"PHY PLL not locked: PCLK_ON=%ld,TMDSCLK_ON=%ld\n",
+			(stat & m_PCLK_ON) >> 6, (stat & m_TMDSCLK_ON) >> 5);
+		return -1;
+	}
+
+	if (hdmi_dev->grf_base)
+		regmap_write(hdmi_dev->grf_base,
+			     RK322X_GRF_SOC_CON2,
+			     RK322X_PLL_PDATA_EN);
+
+	return 0;
+}
+
+static int rockchip_hdmiv2_config_phy(struct hdmi_dev *hdmi_dev)
+{
+	int stat = 0, i = 0;
+	const struct phy_mpll_config_tab *phy_mpll = NULL;
+
+	if (hdmi_dev->soctype == HDMI_SOC_RK322X) {
+		return ext_phy_config(hdmi_dev);
+	} else if (hdmi_dev->soctype == HDMI_SOC_RK3366) {
+		if (hdmi_dev->pixelclk > 148500000)
+			clk_set_rate(hdmi_dev->pclk_phy, 148500000);
+		else
+			clk_set_rate(hdmi_dev->pclk_phy, hdmi_dev->pixelclk);
+	} else if (hdmi_dev->soctype == HDMI_SOC_RK3399) {
+		clk_set_rate(hdmi_dev->pclk_phy, hdmi_dev->pixelclk);
+	}
+
+	hdmi_msk_reg(hdmi_dev, PHY_I2CM_DIV,
+		     m_PHY_I2CM_FAST_STD, v_PHY_I2CM_FAST_STD(0));
+	hdmi_msk_reg(hdmi_dev, PHY_MASK, m_PHY_LOCK, v_PHY_LOCK(1));
+	/* power off PHY */
+	hdmi_msk_reg(hdmi_dev, PHY_CONF0,
+		     m_PDDQ_SIG | m_TXPWRON_SIG | m_SVSRET_SIG,
+		     v_PDDQ_SIG(1) | v_TXPWRON_SIG(0) | v_SVSRET_SIG(1));
+
+	if (hdmi_dev->tmdsclk_ratio_change &&
+	    hdmi_dev->hdmi->edid.scdc_present == 1)
+		rockchip_hdmiv2_scdc_set_tmds_rate(hdmi_dev);
+
+	/* reset PHY */
+	hdmi_writel(hdmi_dev, MC_PHYRSTZ, v_PHY_RSTZ(1));
+	usleep_range(1000, 2000);
+	hdmi_writel(hdmi_dev, MC_PHYRSTZ, v_PHY_RSTZ(0));
+
+	/* Set slave address as PHY GEN2 address */
+	hdmi_writel(hdmi_dev, PHY_I2CM_SLAVE, PHY_GEN2_ADDR);
+
+	/* config the required PHY I2C register */
+	if (hdmi_dev->soctype == HDMI_SOC_RK3366 &&
+	    hdmi_dev->pixelclk > 148500000)
+		phy_mpll = get_phy_mpll_tab(148500000,
+					    hdmi_dev->tmdsclk,
+					    hdmi_dev->pixelrepeat - 1,
+					    hdmi_dev->colordepth);
+	else
+		phy_mpll = get_phy_mpll_tab(hdmi_dev->pixelclk,
+					    hdmi_dev->tmdsclk,
+					    hdmi_dev->pixelrepeat - 1,
+					    hdmi_dev->colordepth);
+	if (phy_mpll) {
+		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_OPMODE_PLLCFG,
+					  v_PREP_DIV(phy_mpll->prep_div) |
+					  v_TMDS_CNTRL(
+					  phy_mpll->tmdsmhl_cntrl) |
+					  v_OPMODE(phy_mpll->opmode) |
+					  v_FBDIV2_CNTRL(
+					  phy_mpll->fbdiv2_cntrl) |
+					  v_FBDIV1_CNTRL(
+					  phy_mpll->fbdiv1_cntrl) |
+					  v_REF_CNTRL(phy_mpll->ref_cntrl) |
+					  v_MPLL_N_CNTRL(phy_mpll->n_cntrl));
+		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_PLLCURRCTRL,
+					  v_MPLL_PROP_CNTRL(
+					  phy_mpll->prop_cntrl) |
+					  v_MPLL_INT_CNTRL(
+					  phy_mpll->int_cntrl));
+		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_PLLGMPCTRL,
+					  v_MPLL_GMP_CNTRL(
+					  phy_mpll->gmp_cntrl));
+	}
+
+	if (hdmi_dev->phy_table) {
+		for (i = 0; i < hdmi_dev->phy_table_size; i++)
+			if (hdmi_dev->tmdsclk <= hdmi_dev->phy_table[i].maxfreq)
+				break;
+	}
+	if (i != hdmi_dev->phy_table_size && hdmi_dev->phy_table) {
+		stat = v_OVERRIDE(1) | v_TX_SYMON(1) | v_CLK_SYMON(1) |
+		       v_PREEMPHASIS(hdmi_dev->phy_table[i].pre_emphasis) |
+		       v_SLOPEBOOST(hdmi_dev->phy_table[i].slopeboost);
+		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL, stat);
+
+		stat = v_SUP_CLKLVL(hdmi_dev->phy_table[i].clk_level) |
+		       v_SUP_TXLVL(hdmi_dev->phy_table[i].data0_level);
+		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_VLEVCTRL, stat);
+	} else {
+		pr_info("%s use default phy settings\n", __func__);
+		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL,
+					  v_OVERRIDE(1) | v_SLOPEBOOST(0) |
+					  v_TX_SYMON(1) | v_CLK_SYMON(1) |
+					  v_PREEMPHASIS(0));
+		if (hdmi_dev->tmdsclk > 340000000)
+			rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_VLEVCTRL,
+						  v_SUP_TXLVL(9) |
+						  v_SUP_CLKLVL(17));
+		else if (hdmi_dev->tmdsclk > 165000000)
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  PHYTX_VLEVCTRL,
+						  v_SUP_TXLVL(14) |
+						  v_SUP_CLKLVL(17));
+		else
+			rockchip_hdmiv2_write_phy(hdmi_dev,
+						  PHYTX_VLEVCTRL,
+						  v_SUP_TXLVL(18) |
+						  v_SUP_CLKLVL(17));
+	}
+
+	if (hdmi_dev->tmdsclk > 340000000)
+		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_TERM_RESIS,
+					  v_TX_TERM(R50_OHMS));
+	else
+		rockchip_hdmiv2_write_phy(hdmi_dev, PHYTX_TERM_RESIS,
+					  v_TX_TERM(R100_OHMS));
+	/* rockchip_hdmiv2_write_phy(hdmi_dev, 0x05, 0x8000); */
+	if (hdmi_dev->tmdsclk_ratio_change)
+		msleep(100);
+	/* power on PHY */
+	hdmi_writel(hdmi_dev, PHY_CONF0, 0x2e);
+
+	/* check if the PHY PLL is locked */
+
+	i = 0;
+	while (i++ < PHY_TIMEOUT) {
+		if ((i % 10) == 0) {
+			stat = hdmi_readl(hdmi_dev, PHY_STAT0);
+			if (stat & m_PHY_LOCK)
+				break;
+			usleep_range(1000, 2000);
+		}
+	}
+	if ((stat & m_PHY_LOCK) == 0) {
+		stat = hdmi_readl(hdmi_dev, MC_LOCKONCLOCK);
+		dev_err(hdmi_dev->hdmi->dev,
+			"PHY PLL not locked: PCLK_ON=%ld,TMDSCLK_ON=%ld\n",
+			(stat & m_PCLK_ON) >> 6, (stat & m_TMDSCLK_ON) >> 5);
+		return -1;
+	}
+	hdmi_msk_reg(hdmi_dev, PHY_MASK, m_PHY_LOCK, v_PHY_LOCK(0));
+	return 0;
+}
+
+static int rockchip_hdmiv2_video_framecomposer(struct hdmi *hdmi_drv,
+					       struct hdmi_video *vpara)
+{
+	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
+	int value, vsync_pol, hsync_pol, de_pol;
+	struct hdmi_video_timing *timing = NULL;
+	struct fb_videomode *mode = NULL;
+	u32 sink_version, tmdsclk;
+
+	vsync_pol = hdmi_drv->lcdc->cur_screen->pin_vsync;
+	hsync_pol = hdmi_drv->lcdc->cur_screen->pin_hsync;
+	de_pol = (hdmi_drv->lcdc->cur_screen->pin_den == 0) ? 1 : 0;
+
+	hdmi_msk_reg(hdmi_dev, A_VIDPOLCFG,
+		     m_DATAEN_POL | m_VSYNC_POL | m_HSYNC_POL,
+		     v_DATAEN_POL(de_pol) |
+		     v_VSYNC_POL(vsync_pol) |
+		     v_HSYNC_POL(hsync_pol));
+
+	timing = (struct hdmi_video_timing *)hdmi_vic2timing(vpara->vic);
+	if (!timing) {
+		dev_err(hdmi_drv->dev,
+			"[%s] not found vic %d\n", __func__, vpara->vic);
+		return -ENOENT;
+	}
+	mode = &timing->mode;
+	if (vpara->color_input == HDMI_COLOR_YCBCR420)
+		tmdsclk = mode->pixclock / 2;
+	else if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
+		tmdsclk = 2 * mode->pixclock;
+	else
+		tmdsclk = mode->pixclock;
+	if (vpara->color_output != HDMI_COLOR_YCBCR422) {
+		switch (vpara->color_output_depth) {
+		case 10:
+			tmdsclk += tmdsclk / 4;
+			break;
+		case 12:
+			tmdsclk += tmdsclk / 2;
+			break;
+		case 16:
+			tmdsclk += tmdsclk;
+			break;
+		case 8:
+		default:
+			break;
+		}
+	} else if (vpara->color_output_depth > 12) {
+		/* YCbCr422 mode only support up to 12bit */
+		vpara->color_output_depth = 12;
+	}
+	if ((tmdsclk > 594000000) ||
+	    (tmdsclk > 340000000 &&
+	     tmdsclk > hdmi_drv->edid.maxtmdsclock)) {
+		if (vpara->format_3d == HDMI_3D_FRAME_PACKING) {
+			pr_err("3d frame packing mode out of max tmdsclk\n");
+			return -1;
+		} else if (vpara->color_output == HDMI_COLOR_YCBCR444 &&
+			   hdmi_drv->edid.ycbcr422) {
+			pr_warn("out of max tmdsclk, down to YCbCr422");
+			vpara->color_output = HDMI_COLOR_YCBCR422;
+			tmdsclk = mode->pixclock;
+		} else {
+			pr_warn("out of max tmds clock, limit to 8bit\n");
+			vpara->color_output_depth = 8;
+			if (vpara->color_input == HDMI_COLOR_YCBCR420)
+				tmdsclk = mode->pixclock / 2;
+			else
+				tmdsclk = mode->pixclock;
+		}
+	}
+
+	if ((tmdsclk > 340000000) ||
+	    (tmdsclk < 340000000 && hdmi_dev->tmdsclk > 340000000))
+		hdmi_dev->tmdsclk_ratio_change = true;
+	else
+		hdmi_dev->tmdsclk_ratio_change = false;
+
+	hdmi_dev->tmdsclk = tmdsclk;
+	if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
+		hdmi_dev->pixelclk = 2 * mode->pixclock;
+	else
+		hdmi_dev->pixelclk = mode->pixclock;
+	hdmi_dev->pixelrepeat = timing->pixelrepeat;
+	/* hdmi_dev->colordepth is used for find pll config.
+	 * For YCbCr422, tmdsclk is same on all color depth.
+	 */
+	if (vpara->color_output == HDMI_COLOR_YCBCR422)
+		hdmi_dev->colordepth = 8;
+	else
+		hdmi_dev->colordepth = vpara->color_output_depth;
+	pr_info("pixel clk is %lu tmds clk is %u\n",
+		hdmi_dev->pixelclk, hdmi_dev->tmdsclk);
+	/* Start/stop HDCP keepout window generation */
+	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
+		     m_FC_HDCP_KEEPOUT, v_FC_HDCP_KEEPOUT(1));
+	if (hdmi_drv->edid.scdc_present == 1 && !hdmi_drv->uboot) {
+		if (tmdsclk > 340000000 ||
+		    hdmi_drv->edid.lte_340mcsc_scramble) {
+			/* used for HDMI 2.0 TX */
+			mutex_lock(&hdmi_dev->ddc_lock);
+			rockchip_hdmiv2_scdc_init(hdmi_dev);
+			sink_version =
+			rockchip_hdmiv2_scdc_get_sink_version(hdmi_dev);
+			pr_info("sink scdc version is %d\n", sink_version);
+			sink_version = hdmi_drv->edid.hf_vsdb_version;
+			rockchip_hdmiv2_scdc_set_source_version(hdmi_dev,
+								sink_version);
+			if (hdmi_drv->edid.rr_capable == 1)
+				rockchip_hdmiv2_scdc_read_request(hdmi_dev, 1);
+			rockchip_hdmiv2_scrambling_enable(hdmi_dev, 1);
+			mutex_unlock(&hdmi_dev->ddc_lock);
+		} else {
+			mutex_lock(&hdmi_dev->ddc_lock);
+			rockchip_hdmiv2_scdc_init(hdmi_dev);
+			rockchip_hdmiv2_scrambling_enable(hdmi_dev, 0);
+			mutex_unlock(&hdmi_dev->ddc_lock);
+		}
+	} else {
+		hdmi_msk_reg(hdmi_dev, FC_SCRAMBLER_CTRL,
+			     m_FC_SCRAMBLE_EN, v_FC_SCRAMBLE_EN(0));
+	}
+
+	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
+		     m_FC_VSYNC_POL | m_FC_HSYNC_POL | m_FC_DE_POL |
+		     m_FC_HDMI_DVI | m_FC_INTERLACE_MODE,
+		     v_FC_VSYNC_POL(vsync_pol) | v_FC_HSYNC_POL(hsync_pol) |
+		     v_FC_DE_POL(de_pol) | v_FC_HDMI_DVI(vpara->sink_hdmi) |
+		     v_FC_INTERLACE_MODE(mode->vmode));
+	if ((mode->vmode & FB_VMODE_INTERLACED) &&
+	    vpara->format_3d != HDMI_3D_FRAME_PACKING)
+		hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
+			     m_FC_VBLANK, v_FC_VBLANK(1));
+	else
+		hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
+			     m_FC_VBLANK, v_FC_VBLANK(0));
+
+	value = mode->xres;
+	if (vpara->color_input == HDMI_COLOR_YCBCR420)
+		value = value / 2;
+	hdmi_writel(hdmi_dev, FC_INHACTIV1, v_FC_HACTIVE1(value >> 8));
+	hdmi_writel(hdmi_dev, FC_INHACTIV0, (value & 0xff));
+
+	if (vpara->format_3d == HDMI_3D_FRAME_PACKING) {
+		if (mode->vmode == 0)
+			value = 2 * mode->yres +
+				mode->upper_margin +
+				mode->lower_margin +
+				mode->vsync_len;
+		else
+			value = 2 * mode->yres +
+				3 * (mode->upper_margin +
+				     mode->lower_margin +
+				     mode->vsync_len) + 2;
+	} else {
+		value = mode->yres;
+	}
+	hdmi_writel(hdmi_dev, FC_INVACTIV1, v_FC_VACTIVE1(value >> 8));
+	hdmi_writel(hdmi_dev, FC_INVACTIV0, (value & 0xff));
+
+	value = mode->hsync_len + mode->left_margin + mode->right_margin;
+	if (vpara->color_input == HDMI_COLOR_YCBCR420)
+		value = value / 2;
+	hdmi_writel(hdmi_dev, FC_INHBLANK1, v_FC_HBLANK1(value >> 8));
+	hdmi_writel(hdmi_dev, FC_INHBLANK0, (value & 0xff));
+
+	value = mode->vsync_len + mode->upper_margin + mode->lower_margin;
+	hdmi_writel(hdmi_dev, FC_INVBLANK, (value & 0xff));
+
+	value = mode->right_margin;
+	if (vpara->color_input == HDMI_COLOR_YCBCR420)
+		value = value / 2;
+	hdmi_writel(hdmi_dev, FC_HSYNCINDELAY1, v_FC_HSYNCINDEAY1(value >> 8));
+	hdmi_writel(hdmi_dev, FC_HSYNCINDELAY0, (value & 0xff));
+
+	value = mode->lower_margin;
+	hdmi_writel(hdmi_dev, FC_VSYNCINDELAY, (value & 0xff));
+
+	value = mode->hsync_len;
+	if (vpara->color_input == HDMI_COLOR_YCBCR420)
+		value = value / 2;
+	hdmi_writel(hdmi_dev, FC_HSYNCINWIDTH1, v_FC_HSYNCWIDTH1(value >> 8));
+	hdmi_writel(hdmi_dev, FC_HSYNCINWIDTH0, (value & 0xff));
+
+	value = mode->vsync_len;
+	hdmi_writel(hdmi_dev, FC_VSYNCINWIDTH, (value & 0xff));
+
+	/* Set the control period minimum duration (min. of 12 pixel
+	 * clock cycles, refer to HDMI 1.4b specification)
+	 */
+	hdmi_writel(hdmi_dev, FC_CTRLDUR, 12);
+	hdmi_writel(hdmi_dev, FC_EXCTRLDUR, 32);
+
+	/* spacing < 256^2 * config / tmdsClock, spacing <= 50ms
+	 * worst case: tmdsClock == 25MHz => config <= 19
+	 */
+	hdmi_writel(hdmi_dev, FC_EXCTRLSPAC,
+		    (hdmi_dev->tmdsclk / 1000) * 50 / (256 * 512));
+
+	hdmi_writel(hdmi_dev, FC_PRCONF,
+		    v_FC_PR_FACTOR(timing->pixelrepeat) |
+		    v_FC_PR_FACTOR_OUT(timing->pixelrepeat - 1));
+
+	return 0;
+}
+
+static int rockchip_hdmiv2_video_packetizer(struct hdmi_dev *hdmi_dev,
+					    struct hdmi_video *vpara)
+{
+	unsigned char color_depth = COLOR_DEPTH_24BIT_DEFAULT;
+	unsigned char output_select = 0;
+	unsigned char remap_size = 0;
+
+	if (vpara->color_output == HDMI_COLOR_YCBCR422) {
+		switch (vpara->color_output_depth) {
+		case 8:
+			remap_size = YCC422_16BIT;
+			break;
+		case 10:
+			remap_size = YCC422_20BIT;
+			break;
+		case 12:
+			remap_size = YCC422_24BIT;
+			break;
+		default:
+			remap_size = YCC422_16BIT;
+			break;
+		}
+
+		output_select = OUT_FROM_YCC422_REMAP;
+		/*Config remap size for the different color Depth*/
+		hdmi_msk_reg(hdmi_dev, VP_REMAP,
+			     m_YCC422_SIZE, v_YCC422_SIZE(remap_size));
+	} else {
+		switch (vpara->color_output_depth) {
+		case 10:
+			color_depth = COLOR_DEPTH_30BIT;
+			output_select = OUT_FROM_PIXEL_PACKING;
+			break;
+		case 12:
+			color_depth = COLOR_DEPTH_36BIT;
+			output_select = OUT_FROM_PIXEL_PACKING;
+			break;
+		case 16:
+			color_depth = COLOR_DEPTH_48BIT;
+			output_select = OUT_FROM_PIXEL_PACKING;
+			break;
+		case 8:
+		default:
+			color_depth = COLOR_DEPTH_24BIT_DEFAULT;
+			output_select = OUT_FROM_8BIT_BYPASS;
+			break;
+		}
+	}
+	/*Config Color Depth*/
+	hdmi_msk_reg(hdmi_dev, VP_PR_CD,
+		     m_COLOR_DEPTH, v_COLOR_DEPTH(color_depth));
+	/*Config pixel repettion*/
+	hdmi_msk_reg(hdmi_dev, VP_PR_CD, m_DESIRED_PR_FACTOR,
+		     v_DESIRED_PR_FACTOR(hdmi_dev->pixelrepeat - 1));
+	if (hdmi_dev->pixelrepeat > 1)
+		hdmi_msk_reg(hdmi_dev, VP_CONF,
+			     m_PIXEL_REPET_EN | m_BYPASS_SEL,
+			     v_PIXEL_REPET_EN(1) | v_BYPASS_SEL(0));
+	else
+		hdmi_msk_reg(hdmi_dev, VP_CONF,
+			     m_PIXEL_REPET_EN | m_BYPASS_SEL,
+			     v_PIXEL_REPET_EN(0) | v_BYPASS_SEL(1));
+
+	/*config output select*/
+	if (output_select == OUT_FROM_PIXEL_PACKING) { /* pixel packing */
+		hdmi_msk_reg(hdmi_dev, VP_CONF,
+			     m_BYPASS_EN | m_PIXEL_PACK_EN |
+			     m_YCC422_EN | m_OUTPUT_SEL,
+			     v_BYPASS_EN(0) | v_PIXEL_PACK_EN(1) |
+			     v_YCC422_EN(0) | v_OUTPUT_SEL(output_select));
+	} else if (output_select == OUT_FROM_YCC422_REMAP) { /* YCC422 */
+		hdmi_msk_reg(hdmi_dev, VP_CONF,
+			     m_BYPASS_EN | m_PIXEL_PACK_EN |
+			     m_YCC422_EN | m_OUTPUT_SEL,
+			     v_BYPASS_EN(0) | v_PIXEL_PACK_EN(0) |
+			     v_YCC422_EN(1) | v_OUTPUT_SEL(output_select));
+	} else if (output_select == OUT_FROM_8BIT_BYPASS ||
+		   output_select == 3) { /* bypass */
+		hdmi_msk_reg(hdmi_dev, VP_CONF,
+			     m_BYPASS_EN | m_PIXEL_PACK_EN |
+			     m_YCC422_EN | m_OUTPUT_SEL,
+			     v_BYPASS_EN(1) | v_PIXEL_PACK_EN(0) |
+			     v_YCC422_EN(0) | v_OUTPUT_SEL(output_select));
+	}
+
+#if defined(HDMI_VIDEO_STUFFING)
+	/* YCC422 and pixel packing stuffing*/
+	hdmi_msk_reg(hdmi_dev, VP_STUFF, m_PR_STUFFING, v_PR_STUFFING(1));
+	hdmi_msk_reg(hdmi_dev, VP_STUFF,
+		     m_YCC422_STUFFING | m_PP_STUFFING,
+		     v_YCC422_STUFFING(1) | v_PP_STUFFING(1));
+#endif
+	return 0;
+}
+
+static int rockchip_hdmiv2_video_sampler(struct hdmi_dev *hdmi_dev,
+					 struct hdmi_video *vpara)
+{
+	int map_code = 0;
+
+	if (vpara->color_input == HDMI_COLOR_YCBCR422) {
+		/* YCC422 mapping is discontinued - only map 1 is supported */
+		switch (vpara->color_output_depth) {
+		case 8:
+			map_code = VIDEO_YCBCR422_8BIT;
+			break;
+		case 10:
+			map_code = VIDEO_YCBCR422_10BIT;
+			break;
+		case 12:
+			map_code = VIDEO_YCBCR422_12BIT;
+			break;
+		default:
+			map_code = VIDEO_YCBCR422_8BIT;
+			break;
+		}
+	} else if (vpara->color_input == HDMI_COLOR_YCBCR420 ||
+		   vpara->color_input == HDMI_COLOR_YCBCR444) {
+		switch (vpara->color_output_depth) {
+		case 10:
+			map_code = VIDEO_YCBCR444_10BIT;
+			break;
+		case 12:
+			map_code = VIDEO_YCBCR444_12BIT;
+			break;
+		case 16:
+			map_code = VIDEO_YCBCR444_16BIT;
+			break;
+		case 8:
+		default:
+			map_code = VIDEO_YCBCR444_8BIT;
+			break;
+		}
+	} else {
+		switch (vpara->color_output_depth) {
+		case 10:
+			map_code = VIDEO_RGB444_10BIT;
+			break;
+		case 12:
+			map_code = VIDEO_RGB444_12BIT;
+			break;
+		case 16:
+			map_code = VIDEO_RGB444_16BIT;
+			break;
+		case 8:
+		default:
+			map_code = VIDEO_RGB444_8BIT;
+			break;
+		}
+	}
+
+	/* Set Data enable signal from external
+	 * and set video sample input mapping
+	 */
+	hdmi_msk_reg(hdmi_dev, TX_INVID0,
+		     m_INTERNAL_DE_GEN | m_VIDEO_MAPPING,
+		     v_INTERNAL_DE_GEN(0) | v_VIDEO_MAPPING(map_code));
+
+#if defined(HDMI_VIDEO_STUFFING)
+	hdmi_writel(hdmi_dev, TX_GYDATA0, 0x00);
+	hdmi_writel(hdmi_dev, TX_GYDATA1, 0x00);
+	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING,
+		     m_GYDATA_STUFF, v_GYDATA_STUFF(1));
+	hdmi_writel(hdmi_dev, TX_RCRDATA0, 0x00);
+	hdmi_writel(hdmi_dev, TX_RCRDATA1, 0x00);
+	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING,
+		     m_RCRDATA_STUFF, v_RCRDATA_STUFF(1));
+	hdmi_writel(hdmi_dev, TX_BCBDATA0, 0x00);
+	hdmi_writel(hdmi_dev, TX_BCBDATA1, 0x00);
+	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING,
+		     m_BCBDATA_STUFF, v_BCBDATA_STUFF(1));
+#endif
+	return 0;
+}
+
+static const char coeff_csc[][24] = {
+		/*   G		R	    B		Bias
+		 *   A1    |	A2     |    A3     |	A4    |
+		 *   B1    |    B2     |    B3     |    B4    |
+		 *   C1    |    C2     |    C3     |    C4    |
+		 */
+	{	/* CSC_BYPASS */
+		0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00,
+		0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00,
+		0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00,
+	},
+	{	/* CSC_RGB_0_255_TO_RGB_16_235_8BIT */
+		0x36, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,		/*G*/
+		0x00, 0x00, 0x36, 0xf7, 0x00, 0x00, 0x00, 0x40,		/*R*/
+		0x00, 0x00, 0x00, 0x00, 0x36, 0xf7, 0x00, 0x40,		/*B*/
+	},
+	{	/* CSC_RGB_0_255_TO_RGB_16_235_10BIT */
+		0x36, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,		/*G*/
+		0x00, 0x00, 0x36, 0xf7, 0x00, 0x00, 0x01, 0x00,		/*R*/
+		0x00, 0x00, 0x00, 0x00, 0x36, 0xf7, 0x01, 0x00,		/*B*/
+	},
+	{	/* CSC_RGB_0_255_TO_ITU601_16_235_8BIT */
+		0x20, 0x40, 0x10, 0x80, 0x06, 0x40, 0x00, 0x40,		/*Y*/
+		0xe8, 0x80, 0x1c, 0x00, 0xfb, 0x80, 0x02, 0x00,		/*Cr*/
+		0xed, 0x80, 0xf6, 0x80, 0x1c, 0x00, 0x02, 0x00,		/*Cb*/
+	},
+	{	/* CSC_RGB_0_255_TO_ITU601_16_235_10BIT */
+		0x20, 0x40, 0x10, 0x80, 0x06, 0x40, 0x01, 0x00,		/*Y*/
+		0xe8, 0x80, 0x1c, 0x00, 0xfb, 0x80, 0x08, 0x00,		/*Cr*/
+		0xed, 0x80, 0xf6, 0x80, 0x1c, 0x00, 0x08, 0x00,		/*Cb*/
+	},
+	{	/* CSC_RGB_0_255_TO_ITU709_16_235_8BIT */
+		0x27, 0x40, 0x0b, 0xc0, 0x04, 0x00, 0x00, 0x40,		/*Y*/
+		0xe6, 0x80, 0x1c, 0x00, 0xfd, 0x80, 0x02, 0x00,		/*Cr*/
+		0xea, 0x40, 0xf9, 0x80, 0x1c, 0x00, 0x02, 0x00,		/*Cb*/
+	},
+	{	/* CSC_RGB_0_255_TO_ITU709_16_235_10BIT */
+		0x27, 0x40, 0x0b, 0xc0, 0x04, 0x00, 0x01, 0x00,		/*Y*/
+		0xe6, 0x80, 0x1c, 0x00, 0xfd, 0x80, 0x08, 0x00,		/*Cr*/
+		0xea, 0x40, 0xf9, 0x80, 0x1c, 0x00, 0x08, 0x00,		/*Cb*/
+	},
+		/* Y		Cr	    Cb		Bias */
+	{	/* CSC_ITU601_16_235_TO_RGB_0_255_8BIT */
+		0x20, 0x00, 0x69, 0x26, 0x74, 0xfd, 0x01, 0x0e,		/*G*/
+		0x20, 0x00, 0x2c, 0xdd, 0x00, 0x00, 0x7e, 0x9a,		/*R*/
+		0x20, 0x00, 0x00, 0x00, 0x38, 0xb4, 0x7e, 0x3b,		/*B*/
+	},
+	{	/* CSC_ITU709_16_235_TO_RGB_0_255_8BIT */
+		0x20, 0x00, 0x71, 0x06, 0x7a, 0x02, 0x00, 0xa7,		/*G*/
+		0x20, 0x00, 0x32, 0x64, 0x00, 0x00, 0x7e, 0x6d,		/*R*/
+		0x20, 0x00, 0x00, 0x00, 0x3b, 0x61, 0x7e, 0x25,		/*B*/
+	},
+};
+
+static int rockchip_hdmiv2_video_csc(struct hdmi_dev *hdmi_dev,
+				     struct hdmi_video *vpara)
+{
+	int i, mode, interpolation, decimation, csc_scale = 0;
+	const char *coeff = NULL;
+	unsigned char color_depth = 0;
+
+	if (vpara->color_input == vpara->color_output) {
+		hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL,
+			     m_FEED_THROUGH_OFF, v_FEED_THROUGH_OFF(0));
+		return 0;
+	}
+
+	if (vpara->color_input == HDMI_COLOR_YCBCR422 &&
+	    vpara->color_output != HDMI_COLOR_YCBCR422 &&
+	    vpara->color_output != HDMI_COLOR_YCBCR420) {
+		interpolation = 1;
+		hdmi_msk_reg(hdmi_dev, CSC_CFG,
+			     m_CSC_INTPMODE, v_CSC_INTPMODE(interpolation));
+	}
+
+	if ((vpara->color_input == HDMI_COLOR_RGB_0_255 ||
+	     vpara->color_input == HDMI_COLOR_YCBCR444) &&
+	     vpara->color_output == HDMI_COLOR_YCBCR422) {
+		decimation = 1;
+		hdmi_msk_reg(hdmi_dev, CSC_CFG,
+			     m_CSC_DECIMODE, v_CSC_DECIMODE(decimation));
+	}
+
+	mode = CSC_BYPASS;
+	csc_scale = 0;
+
+	switch (vpara->vic) {
+	case HDMI_720X480I_60HZ_4_3:
+	case HDMI_720X576I_50HZ_4_3:
+	case HDMI_720X480P_60HZ_4_3:
+	case HDMI_720X576P_50HZ_4_3:
+	case HDMI_720X480I_60HZ_16_9:
+	case HDMI_720X576I_50HZ_16_9:
+	case HDMI_720X480P_60HZ_16_9:
+	case HDMI_720X576P_50HZ_16_9:
+		if (vpara->color_input == HDMI_COLOR_RGB_0_255 &&
+		    vpara->color_output >= HDMI_COLOR_YCBCR444) {
+			mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;
+			csc_scale = 0;
+		} else if (vpara->color_input >= HDMI_COLOR_YCBCR444 &&
+			   vpara->color_output == HDMI_COLOR_RGB_0_255) {
+			mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
+			csc_scale = 1;
+		}
+		break;
+	default:
+		if (vpara->color_input == HDMI_COLOR_RGB_0_255 &&
+		    vpara->color_output >= HDMI_COLOR_YCBCR444) {
+			mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;
+			csc_scale = 0;
+		} else if (vpara->color_input >= HDMI_COLOR_YCBCR444 &&
+			   vpara->color_output == HDMI_COLOR_RGB_0_255) {
+			mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;
+			csc_scale = 1;
+		}
+		break;
+	}
+
+	if ((vpara->color_input == HDMI_COLOR_RGB_0_255) &&
+	    (vpara->color_output == HDMI_COLOR_RGB_16_235)) {
+		mode = CSC_RGB_0_255_TO_RGB_16_235_8BIT;
+		csc_scale = 0;
+	}
+	if (mode != CSC_BYPASS) {
+		switch (vpara->color_output_depth) {
+		case 10:
+			color_depth = COLOR_DEPTH_30BIT;
+			mode += 1;
+			break;
+		case 12:
+			color_depth = COLOR_DEPTH_36BIT;
+			mode += 2;
+			break;
+		case 16:
+			color_depth = COLOR_DEPTH_48BIT;
+			mode += 3;
+			break;
+		case 8:
+		default:
+			color_depth = COLOR_DEPTH_24BIT;
+			break;
+		}
+	}
+	coeff = coeff_csc[mode];
+	for (i = 0; i < 24; i++)
+		hdmi_writel(hdmi_dev, CSC_COEF_A1_MSB + i, coeff[i]);
+
+	hdmi_msk_reg(hdmi_dev, CSC_SCALE,
+		     m_CSC_SCALE, v_CSC_SCALE(csc_scale));
+	/*config CSC_COLOR_DEPTH*/
+	hdmi_msk_reg(hdmi_dev, CSC_SCALE,
+		     m_CSC_COLOR_DEPTH, v_CSC_COLOR_DEPTH(color_depth));
+
+	/* enable CSC */
+	if (mode == CSC_BYPASS)
+		hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL,
+			     m_FEED_THROUGH_OFF, v_FEED_THROUGH_OFF(0));
+	else
+		hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL,
+			     m_FEED_THROUGH_OFF, v_FEED_THROUGH_OFF(1));
+	return 0;
+}
+
+static int hdmi_dev_detect_hotplug(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	u32 value;
+
+	value = hdmi_readl(hdmi_dev, PHY_STAT0);
+	HDMIDBG(2, "[%s] reg%x value %02x\n", __func__, PHY_STAT0, value);
+	if (value & m_PHY_HPD)
+		return HDMI_HPD_ACTIVATED;
+
+	return HDMI_HPD_REMOVED;
+}
+
+static int hdmi_dev_read_edid(struct hdmi *hdmi, int block, unsigned char *buff)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	int i = 0, n = 0, index = 0, ret = -1, trytime = 5;
+	int offset = (block % 2) * 0x80;
+	int interrupt = 0;
+
+	HDMIDBG(2, "[%s] block %d\n", __func__, block);
+
+	rockchip_hdmiv2_i2cm_reset(hdmi_dev);
+
+	/* Set DDC I2C CLK which divided from DDC_CLK to 100KHz. */
+	rockchip_hdmiv2_i2cm_clk_init(hdmi_dev);
+
+	/* Enable I2C interrupt for reading edid */
+	rockchip_hdmiv2_i2cm_mask_int(hdmi_dev, 0);
+
+	hdmi_writel(hdmi_dev, I2CM_SLAVE, DDC_I2C_EDID_ADDR);
+	hdmi_writel(hdmi_dev, I2CM_SEGADDR, DDC_I2C_SEG_ADDR);
+	hdmi_writel(hdmi_dev, I2CM_SEGPTR, block / 2);
+	for (n = 0; n < HDMI_EDID_BLOCK_SIZE / 8; n++) {
+		for (trytime = 0; trytime < 5; trytime++) {
+			hdmi_writel(hdmi_dev, I2CM_ADDRESS, offset + 8 * n);
+			/* enable extend sequential read operation */
+			if (block == 0)
+				hdmi_msk_reg(hdmi_dev, I2CM_OPERATION,
+					     m_I2CM_RD8, v_I2CM_RD8(1));
+			else
+				hdmi_msk_reg(hdmi_dev, I2CM_OPERATION,
+					     m_I2CM_RD8_EXT,
+					     v_I2CM_RD8_EXT(1));
+
+			i = 20;
+			while (i--) {
+				usleep_range(900, 1000);
+				interrupt = hdmi_readl(hdmi_dev,
+						       IH_I2CM_STAT0);
+				if (interrupt)
+					hdmi_writel(hdmi_dev,
+						    IH_I2CM_STAT0, interrupt);
+
+				if (interrupt &
+				    (m_SCDC_READREQ | m_I2CM_DONE |
+				     m_I2CM_ERROR))
+					break;
+			}
+
+			if (interrupt & m_I2CM_DONE) {
+				for (index = 0; index < 8; index++)
+					buff[8 * n + index] =
+						hdmi_readl(hdmi_dev,
+							   I2CM_READ_BUFF0 +
+							   index);
+
+				if (n == HDMI_EDID_BLOCK_SIZE / 8 - 1) {
+					ret = 0;
+					goto exit;
+				}
+				break;
+			} else if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
+				dev_err(hdmi->dev,
+					"[%s] edid read %d error\n",
+					__func__, offset + 8 * n);
+			}
+		}
+		if (trytime == 5) {
+			dev_err(hdmi->dev,
+				"[%s] edid read error\n", __func__);
+			break;
+		}
+	}
+
+exit:
+	/* Disable I2C interrupt */
+	rockchip_hdmiv2_i2cm_mask_int(hdmi_dev, 1);
+	return ret;
+}
+
+static void hdmi_dev_config_avi(struct hdmi *hdmi,
+				struct hdmi_video *vpara)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	unsigned char colorimetry, ext_colorimetry = 0, aspect_ratio, y1y0;
+	unsigned char rgb_quan_range = AVI_QUANTIZATION_RANGE_DEFAULT;
+
+	hdmi_msk_reg(hdmi_dev, FC_DATAUTO3, m_AVI_AUTO, v_AVI_AUTO(0));
+	hdmi_msk_reg(hdmi_dev, IH_FC_STAT1,
+		     m_AVI_INFOFRAME, v_AVI_INFOFRAME(1));
+	/* Set AVI infoFrame Data byte1 */
+	if (vpara->color_output == HDMI_COLOR_YCBCR444)
+		y1y0 = AVI_COLOR_MODE_YCBCR444;
+	else if (vpara->color_output == HDMI_COLOR_YCBCR422)
+		y1y0 = AVI_COLOR_MODE_YCBCR422;
+	else if (vpara->color_output == HDMI_COLOR_YCBCR420)
+		y1y0 = AVI_COLOR_MODE_YCBCR420;
+	else
+		y1y0 = AVI_COLOR_MODE_RGB;
+
+	hdmi_msk_reg(hdmi_dev, FC_AVICONF0,
+		     m_FC_ACTIV_FORMAT | m_FC_RGC_YCC,
+		     v_FC_RGC_YCC(y1y0) | v_FC_ACTIV_FORMAT(1));
+
+	/* Set AVI infoFrame Data byte2 */
+	switch (vpara->vic) {
+	case HDMI_720X480I_60HZ_4_3:
+	case HDMI_720X576I_50HZ_4_3:
+	case HDMI_720X480P_60HZ_4_3:
+	case HDMI_720X576P_50HZ_4_3:
+		aspect_ratio = AVI_CODED_FRAME_ASPECT_4_3;
+		if (vpara->colorimetry == HDMI_COLORIMETRY_NO_DATA)
+			colorimetry = AVI_COLORIMETRY_SMPTE_170M;
+		break;
+	case HDMI_720X480I_60HZ_16_9:
+	case HDMI_720X576I_50HZ_16_9:
+	case HDMI_720X480P_60HZ_16_9:
+	case HDMI_720X576P_50HZ_16_9:
+		aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
+		if (vpara->colorimetry == HDMI_COLORIMETRY_NO_DATA)
+			colorimetry = AVI_COLORIMETRY_SMPTE_170M;
+		break;
+	default:
+		aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
+		if (vpara->colorimetry == HDMI_COLORIMETRY_NO_DATA)
+			colorimetry = AVI_COLORIMETRY_ITU709;
+	}
+
+	if (vpara->colorimetry > HDMI_COLORIMETRY_ITU709) {
+		colorimetry = AVI_COLORIMETRY_EXTENDED;
+		ext_colorimetry = vpara->colorimetry -
+				HDMI_COLORIMETRY_EXTEND_XVYCC_601;
+	} else if (vpara->color_output == HDMI_COLOR_RGB_16_235 ||
+		 vpara->color_output == HDMI_COLOR_RGB_0_255) {
+		colorimetry = AVI_COLORIMETRY_NO_DATA;
+	} else if (vpara->colorimetry != HDMI_COLORIMETRY_NO_DATA) {
+		colorimetry = vpara->colorimetry;
+	}
+
+	hdmi_writel(hdmi_dev, FC_AVICONF1,
+		    v_FC_COLORIMETRY(colorimetry) |
+		    v_FC_PIC_ASPEC_RATIO(aspect_ratio) |
+		    v_FC_ACT_ASPEC_RATIO(ACTIVE_ASPECT_RATE_DEFAULT));
+
+	/* Set AVI infoFrame Data byte3 */
+	hdmi_msk_reg(hdmi_dev, FC_AVICONF2,
+		     m_FC_EXT_COLORIMETRY | m_FC_QUAN_RANGE,
+		     v_FC_EXT_COLORIMETRY(ext_colorimetry) |
+		     v_FC_QUAN_RANGE(rgb_quan_range));
+
+	/* Set AVI infoFrame Data byte4 */
+	if ((vpara->vic > 92 && vpara->vic < 96) ||
+	    (vpara->vic == 98) ||
+	    (vpara->vic & HDMI_VIDEO_DMT) ||
+	    (vpara->vic & HDMI_VIDEO_DISCRETE_VR))
+		hdmi_writel(hdmi_dev, FC_AVIVID, 0);
+	else
+		hdmi_writel(hdmi_dev, FC_AVIVID, vpara->vic & 0xff);
+	/* Set AVI infoFrame Data byte5 */
+	hdmi_msk_reg(hdmi_dev, FC_AVICONF3, m_FC_YQ | m_FC_CN,
+		     v_FC_YQ(YQ_LIMITED_RANGE) | v_FC_CN(CN_GRAPHICS));
+	hdmi_msk_reg(hdmi_dev, FC_DATAUTO3, m_AVI_AUTO, v_AVI_AUTO(1));
+}
+
+static int hdmi_dev_config_vsi(struct hdmi *hdmi,
+			       unsigned char vic_3d, unsigned char format)
+{
+	int i = 0, id = 0x000c03;
+	unsigned char data[3] = {0};
+
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	HDMIDBG(2, "[%s] vic %d format %d.\n", __func__, vic_3d, format);
+
+	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_VSD_AUTO, v_VSD_AUTO(0));
+	hdmi_writel(hdmi_dev, FC_VSDIEEEID2, id & 0xff);
+	hdmi_writel(hdmi_dev, FC_VSDIEEEID1, (id >> 8) & 0xff);
+	hdmi_writel(hdmi_dev, FC_VSDIEEEID0, (id >> 16) & 0xff);
+
+	data[0] = format << 5;	/* PB4 --HDMI_Video_Format */
+	switch (format) {
+	case HDMI_VIDEO_FORMAT_4KX2K:
+		data[1] = vic_3d;	/* PB5--HDMI_VIC */
+		data[2] = 0;
+		break;
+	case HDMI_VIDEO_FORMAT_3D:
+		data[1] = vic_3d << 4;	/* PB5--3D_Structure field */
+		data[2] = 0;		/* PB6--3D_Ext_Data field */
+		break;
+	default:
+		data[1] = 0;
+		data[2] = 0;
+		break;
+	}
+
+	for (i = 0; i < 3; i++)
+		hdmi_writel(hdmi_dev, FC_VSDPAYLOAD0 + i, data[i]);
+	hdmi_writel(hdmi_dev, FC_VSDSIZE, 0x6);
+
+	hdmi_writel(hdmi_dev, FC_DATAUTO1, 0);
+	hdmi_writel(hdmi_dev, FC_DATAUTO2, 0x11);
+	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_VSD_AUTO, v_VSD_AUTO(1));
+	return 0;
+}
+
+#define HDR_LSB(n) ((n) & 0xff)
+#define HDR_MSB(n) (((n) & 0xff00) >> 8)
+
+static void hdmi_dev_config_hdr(struct hdmi *hdmi,
+				int eotf,
+				struct hdmi_hdr_metadata *hdr)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	/* hdr is supportted after disignid = 0x21 */
+	if (!hdmi_dev || hdmi_readl(hdmi_dev, DESIGN_ID) < 0x21)
+		return;
+
+	hdmi_writel(hdmi_dev, FC_DRM_HB, 1);/*verion = 0x1*/
+	hdmi_writel(hdmi_dev, (FC_DRM_HB + 1), 26);/*length of following data*/
+	hdmi_writel(hdmi_dev, FC_DRM_PB, eotf / 2);
+	hdmi_writel(hdmi_dev, FC_DRM_PB + 1, 0);
+
+	if (hdr) {
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 2, HDR_LSB(hdr->prim_x0));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 3, HDR_MSB(hdr->prim_x0));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 4, HDR_LSB(hdr->prim_y0));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 5, HDR_MSB(hdr->prim_y0));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 6, HDR_LSB(hdr->prim_x1));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 7, HDR_MSB(hdr->prim_x1));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 8, HDR_LSB(hdr->prim_y1));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 9, HDR_MSB(hdr->prim_y1));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 10, HDR_LSB(hdr->prim_x2));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 11, HDR_MSB(hdr->prim_x2));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 12, HDR_LSB(hdr->prim_y2));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 13, HDR_MSB(hdr->prim_y2));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 14, HDR_LSB(hdr->white_px));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 15, HDR_MSB(hdr->white_px));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 16, HDR_LSB(hdr->white_py));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 17, HDR_MSB(hdr->white_py));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 18, HDR_LSB(hdr->max_dml));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 19, HDR_MSB(hdr->max_dml));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 20, HDR_LSB(hdr->min_dml));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 21, HDR_MSB(hdr->min_dml));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 22, HDR_LSB(hdr->max_cll));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 23, HDR_MSB(hdr->max_cll));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 24, HDR_LSB(hdr->max_fall));
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 25, HDR_MSB(hdr->max_fall));
+	} else {
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 1, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 2, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 3, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 4, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 5, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 6, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 7, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 8, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 9, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 10, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 11, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 12, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 13, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 14, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 15, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 16, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 17, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 18, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 19, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 20, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 21, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 22, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 23, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 24, 0);
+		hdmi_writel(hdmi_dev, FC_DRM_PB + 25, 0);
+	}
+	if (eotf) {
+		hdmi_msk_reg(hdmi_dev, FC_PACK_TXE, m_DRM_TXEN, v_DRM_TXEN(1));
+		hdmi_msk_reg(hdmi_dev, FC_MASK2, m_DRM_MASK, v_DRM_MASK(0));
+		hdmi_msk_reg(hdmi_dev, FC_DRM_UP, m_DRM_PUPD, v_DRM_PUPD(1));
+	} else {
+		hdmi_msk_reg(hdmi_dev, FC_PACK_TXE, m_DRM_TXEN, v_DRM_TXEN(0));
+		hdmi_msk_reg(hdmi_dev, FC_MASK2, m_DRM_MASK, v_DRM_MASK(1));
+		hdmi_msk_reg(hdmi_dev, FC_DRM_UP, m_DRM_PUPD, v_DRM_PUPD(1));
+	}
+}
+
+static int hdmi_dev_config_spd(struct hdmi *hdmi, const char *vendor,
+			       const char *product, char deviceinfo)
+{
+	struct hdmi_dev *hdmi_dev;
+	int i, len;
+
+	if (!hdmi || !vendor || !product)
+		return -1;
+	hdmi_dev = hdmi->property->priv;
+
+	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_SPD_AUTO, v_SPD_AUTO(0));
+	len = strlen(vendor);
+	for (i = 0; i < 8; i++) {
+		if (i < len)
+			hdmi_writel(hdmi_dev, FC_SPDVENDORNAME0 + i,
+				    vendor[i]);
+		else
+			hdmi_writel(hdmi_dev, FC_SPDVENDORNAME0 + i,
+				    0);
+	}
+	len = strlen(product);
+	for (i = 0; i < 16; i++) {
+		if (i < len)
+			hdmi_writel(hdmi_dev, FC_SPDPRODUCTNAME0 + i,
+				    product[i]);
+		else
+			hdmi_writel(hdmi_dev, FC_SPDPRODUCTNAME0 + i,
+				    0);
+	}
+	hdmi_writel(hdmi_dev, FC_SPDDEVICEINF, deviceinfo);
+	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_SPD_AUTO, v_SPD_AUTO(1));
+	return 0;
+}
+
+static int hdmi_dev_config_video(struct hdmi *hdmi, struct hdmi_video *vpara)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	HDMIDBG(2, "%s vic %d 3dformat %d color mode %d color depth %d\n",
+		__func__, vpara->vic, vpara->format_3d,
+		vpara->color_output, vpara->color_output_depth);
+
+	if (hdmi_dev->soctype == HDMI_SOC_RK3288)
+		vpara->color_input = HDMI_COLOR_RGB_0_255;
+
+	if (!hdmi->uboot) {
+		/* before configure video, we power off phy */
+		if (hdmi_dev->soctype != HDMI_SOC_RK322X) {
+			hdmi_msk_reg(hdmi_dev, PHY_CONF0,
+				     m_PDDQ_SIG | m_TXPWRON_SIG,
+				     v_PDDQ_SIG(1) | v_TXPWRON_SIG(0));
+		} else {
+			hdmi_msk_reg(hdmi_dev, PHY_CONF0,
+				     m_ENHPD_RXSENSE_SIG,
+				     v_ENHPD_RXSENSE_SIG(1));
+			regmap_write(hdmi_dev->grf_base,
+				     RK322X_GRF_SOC_CON2,
+				     RK322X_PLL_POWER_DOWN);
+		}
+		/* force output blue */
+		if (vpara->color_output == HDMI_COLOR_RGB_0_255) {
+			hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x00);	/*R*/
+			hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x00);	/*G*/
+			hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0x00);	/*B*/
+		} else if (vpara->color_output == HDMI_COLOR_RGB_16_235) {
+			hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x10);	/*R*/
+			hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x10);	/*G*/
+			hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0x10);	/*B*/
+		} else {
+			hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x80);	/*Cr*/
+			hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x10);	/*Y*/
+			hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0x80);	/*Cb*/
+		}
+		hdmi_msk_reg(hdmi_dev, FC_DBGFORCE,
+			     m_FC_FORCEVIDEO, v_FC_FORCEVIDEO(1));
+		hdmi_writel(hdmi_dev, MC_CLKDIS, m_HDCPCLK_DISABLE);
+	}
+
+	if (rockchip_hdmiv2_video_framecomposer(hdmi, vpara) < 0)
+		return -1;
+
+	if (rockchip_hdmiv2_video_packetizer(hdmi_dev, vpara) < 0)
+		return -1;
+	/* Color space convert */
+	if (rockchip_hdmiv2_video_csc(hdmi_dev, vpara) < 0)
+		return -1;
+	if (rockchip_hdmiv2_video_sampler(hdmi_dev, vpara) < 0)
+		return -1;
+
+	if (vpara->sink_hdmi == OUTPUT_HDMI) {
+		hdmi_dev_config_avi(hdmi, vpara);
+		hdmi_dev_config_spd(hdmi, hdmi_dev->vendor_name,
+				    hdmi_dev->product_name,
+				    hdmi_dev->deviceinfo);
+		if (vpara->format_3d != HDMI_3D_NONE) {
+			hdmi_dev_config_vsi(hdmi,
+					    vpara->format_3d,
+					    HDMI_VIDEO_FORMAT_3D);
+		} else if ((vpara->vic > 92 && vpara->vic < 96) ||
+			 (vpara->vic == 98)) {
+			vpara->vic = (vpara->vic == 98) ?
+				     4 : (96 - vpara->vic);
+			hdmi_dev_config_vsi(hdmi,
+					    vpara->vic,
+					    HDMI_VIDEO_FORMAT_4KX2K);
+		} else {
+			hdmi_dev_config_vsi(hdmi,
+					    vpara->vic,
+					    HDMI_VIDEO_FORMAT_NORMAL);
+		}
+		hdmi_dev_config_hdr(hdmi, vpara->eotf, &hdmi->hdr);
+		dev_info(hdmi->dev, "[%s] success output HDMI.\n", __func__);
+	} else {
+		dev_info(hdmi->dev, "[%s] success output DVI.\n", __func__);
+	}
+
+	if (!hdmi->uboot)
+		rockchip_hdmiv2_config_phy(hdmi_dev);
+	else
+		hdmi_msk_reg(hdmi_dev, PHY_MASK, m_PHY_LOCK, v_PHY_LOCK(0));
+	return 0;
+}
+
+static void hdmi_dev_config_aai(struct hdmi_dev *hdmi_dev,
+				struct hdmi_audio *audio)
+{
+	/* Refer to CEA861-E Audio infoFrame
+	 * Set both Audio Channel Count and Audio Coding
+	 * Type Refer to Stream Head for HDMI
+	 */
+	hdmi_msk_reg(hdmi_dev, FC_AUDICONF0,
+		     m_FC_CHN_CNT | m_FC_CODING_TYPE,
+		     v_FC_CHN_CNT(audio->channel - 1) | v_FC_CODING_TYPE(0));
+
+	/* Set both Audio Sample Size and Sample Frequency
+	 * Refer to Stream Head for HDMI
+	 */
+	hdmi_msk_reg(hdmi_dev, FC_AUDICONF1,
+		     m_FC_SAMPLE_SIZE | m_FC_SAMPLE_FREQ,
+		     v_FC_SAMPLE_SIZE(0) | v_FC_SAMPLE_FREQ(0));
+
+	/* Set Channel Allocation */
+	hdmi_writel(hdmi_dev, FC_AUDICONF2, 0x00);
+
+	/* Set LFEPBLDOWN-MIX INH and LSV */
+	hdmi_writel(hdmi_dev, FC_AUDICONF3, 0x00);
+}
+
+static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	int word_length = 0, channel = 0, mclk_fs;
+	unsigned int N = 0, CTS = 0;
+	int rate = 0;
+	char design_id;
+
+	HDMIDBG(2, "%s\n", __func__);
+
+	if (audio->channel < 3)
+		channel = I2S_CHANNEL_1_2;
+	else if (audio->channel < 5)
+		channel = I2S_CHANNEL_3_4;
+	else if (audio->channel < 7)
+		channel = I2S_CHANNEL_5_6;
+	else
+		channel = I2S_CHANNEL_7_8;
+
+	switch (audio->rate) {
+	case HDMI_AUDIO_FS_32000:
+		mclk_fs = FS_128;
+		rate = AUDIO_32K;
+		if (hdmi_dev->tmdsclk >= 594000000)
+			N = N_32K_HIGHCLK;
+		else if (hdmi_dev->tmdsclk >= 297000000)
+			N = N_32K_MIDCLK;
+		else
+			N = N_32K_LOWCLK;
+		/*div a num to avoid the value is exceed 2^32(int)*/
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 32);
+		break;
+	case HDMI_AUDIO_FS_44100:
+		mclk_fs = FS_128;
+		rate = AUDIO_441K;
+		if (hdmi_dev->tmdsclk >= 594000000)
+			N = N_441K_HIGHCLK;
+		else if (hdmi_dev->tmdsclk >= 297000000)
+			N = N_441K_MIDCLK;
+		else
+			N = N_441K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 441);
+		break;
+	case HDMI_AUDIO_FS_48000:
+		mclk_fs = FS_128;
+		rate = AUDIO_48K;
+		if (hdmi_dev->tmdsclk >= 594000000)	/*FS_153.6*/
+			N = N_48K_HIGHCLK;
+		else if (hdmi_dev->tmdsclk >= 297000000)
+			N = N_48K_MIDCLK;
+		else
+			N = N_48K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 48);
+		break;
+	case HDMI_AUDIO_FS_88200:
+		mclk_fs = FS_128;
+		rate = AUDIO_882K;
+		if (hdmi_dev->tmdsclk >= 594000000)
+			N = N_882K_HIGHCLK;
+		else if (hdmi_dev->tmdsclk >= 297000000)
+			N = N_882K_MIDCLK;
+		else
+			N = N_882K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 882);
+		break;
+	case HDMI_AUDIO_FS_96000:
+		mclk_fs = FS_128;
+		rate = AUDIO_96K;
+		if (hdmi_dev->tmdsclk >= 594000000)	/*FS_153.6*/
+			N = N_96K_HIGHCLK;
+		else if (hdmi_dev->tmdsclk >= 297000000)
+			N = N_96K_MIDCLK;
+		else
+			N = N_96K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 96);
+		break;
+	case HDMI_AUDIO_FS_176400:
+		mclk_fs = FS_128;
+		rate = AUDIO_1764K;
+		if (hdmi_dev->tmdsclk >= 594000000)
+			N = N_1764K_HIGHCLK;
+		else if (hdmi_dev->tmdsclk >= 297000000)
+			N = N_1764K_MIDCLK;
+		else
+			N = N_1764K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 1764);
+		break;
+	case HDMI_AUDIO_FS_192000:
+		mclk_fs = FS_128;
+		rate = AUDIO_192K;
+		if (hdmi_dev->tmdsclk >= 594000000)	/*FS_153.6*/
+			N = N_192K_HIGHCLK;
+		else if (hdmi_dev->tmdsclk >= 297000000)
+			N = N_192K_MIDCLK;
+		else
+			N = N_192K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 192);
+		break;
+	default:
+		dev_err(hdmi_dev->hdmi->dev,
+			"[%s] not support such sample rate %d\n",
+			__func__, audio->rate);
+		return -ENOENT;
+	}
+
+	switch (audio->word_length) {
+	case HDMI_AUDIO_WORD_LENGTH_16bit:
+		word_length = I2S_16BIT_SAMPLE;
+		break;
+	case HDMI_AUDIO_WORD_LENGTH_20bit:
+		word_length = I2S_20BIT_SAMPLE;
+		break;
+	case HDMI_AUDIO_WORD_LENGTH_24bit:
+		word_length = I2S_24BIT_SAMPLE;
+		break;
+	default:
+		word_length = I2S_16BIT_SAMPLE;
+	}
+
+	HDMIDBG(2, "rate = %d, tmdsclk = %u, N = %d, CTS = %d\n",
+		audio->rate, hdmi_dev->tmdsclk, N, CTS);
+	/* more than 2 channels => layout 1 else layout 0 */
+	hdmi_msk_reg(hdmi_dev, FC_AUDSCONF,
+		     m_AUD_PACK_LAYOUT,
+		     v_AUD_PACK_LAYOUT((audio->channel > 2) ? 1 : 0));
+
+	if (hdmi_dev->audiosrc == HDMI_AUDIO_SRC_SPDIF) {
+		mclk_fs = FS_128;
+		hdmi_msk_reg(hdmi_dev, AUD_CONF0,
+			     m_I2S_SEL, v_I2S_SEL(AUDIO_SPDIF_GPA));
+		hdmi_msk_reg(hdmi_dev, AUD_SPDIF1,
+			     m_SET_NLPCM | m_SPDIF_WIDTH,
+			     v_SET_NLPCM(PCM_LINEAR) |
+			     v_SPDIF_WIDTH(word_length));
+		/*Mask fifo empty and full int and reset fifo*/
+		hdmi_msk_reg(hdmi_dev, AUD_SPDIFINT,
+			     m_FIFO_EMPTY_MASK | m_FIFO_FULL_MASK,
+			     v_FIFO_EMPTY_MASK(1) | v_FIFO_FULL_MASK(1));
+		hdmi_msk_reg(hdmi_dev, AUD_SPDIF0,
+			     m_SW_SAUD_FIFO_RST, v_SW_SAUD_FIFO_RST(1));
+	} else {
+		/*Mask fifo empty and full int and reset fifo*/
+		hdmi_msk_reg(hdmi_dev, AUD_INT,
+			     m_FIFO_EMPTY_MASK | m_FIFO_FULL_MASK,
+			     v_FIFO_EMPTY_MASK(1) | v_FIFO_FULL_MASK(1));
+		hdmi_msk_reg(hdmi_dev, AUD_CONF0,
+			     m_SW_AUD_FIFO_RST, v_SW_AUD_FIFO_RST(1));
+		hdmi_writel(hdmi_dev, MC_SWRSTZREQ, 0xF7);
+		design_id = hdmi_readl(hdmi_dev, DESIGN_ID);
+		if (design_id >= 0x21)
+			hdmi_writel(hdmi_dev, AUD_CONF2, 0x4);
+		else
+			hdmi_writel(hdmi_dev, AUD_CONF2, 0x0);
+		usleep_range(90, 100);
+		/*
+		 * when we try to use hdmi nlpcm mode
+		 * we should use set AUD_CONF2 to open this route and set
+		 * word_length to 24bit for b.p.c.u.v with 16bit raw data
+		 * when the bitstream data  up to 8 channel, we should use
+		 * the hdmi hbr mode
+		 * HBR Mode : Dolby TrueHD
+		 *            Dolby Atmos
+		 *            DTS-HDMA
+		 * NLPCM Mode :
+		 * FS_32000 FS_44100 FS_48000 : Dolby Digital &  DTS
+		 * FS_176400 FS_192000        : Dolby Digital Plus
+		 */
+		if (audio->type == HDMI_AUDIO_NLPCM) {
+			if (channel == I2S_CHANNEL_7_8) {
+				HDMIDBG(2, "hbr mode.\n");
+				hdmi_writel(hdmi_dev, AUD_CONF2, 0x1);
+				word_length = I2S_24BIT_SAMPLE;
+			} else if ((audio->rate == HDMI_AUDIO_FS_32000) ||
+				   (audio->rate == HDMI_AUDIO_FS_44100) ||
+				   (audio->rate == HDMI_AUDIO_FS_48000) ||
+				   (audio->rate == HDMI_AUDIO_FS_176400) ||
+				   (audio->rate == HDMI_AUDIO_FS_192000)) {
+				HDMIDBG(2, "nlpcm mode.\n");
+				hdmi_writel(hdmi_dev, AUD_CONF2, 0x2);
+				word_length = I2S_24BIT_SAMPLE;
+			} else {
+				hdmi_writel(hdmi_dev, AUD_CONF2, 0x0);
+			}
+		} else {
+			if (design_id >= 0x21)
+				hdmi_writel(hdmi_dev, AUD_CONF2, 0x4);
+			else
+				hdmi_writel(hdmi_dev, AUD_CONF2, 0x0);
+		}
+		hdmi_msk_reg(hdmi_dev, AUD_CONF0,
+			     m_I2S_SEL | m_I2S_IN_EN,
+			     v_I2S_SEL(AUDIO_I2S) | v_I2S_IN_EN(channel));
+		hdmi_writel(hdmi_dev, AUD_CONF1,
+			    v_I2S_MODE(I2S_STANDARD_MODE) |
+			    v_I2S_WIDTH(word_length));
+	}
+
+	hdmi_msk_reg(hdmi_dev, AUD_INPUTCLKFS,
+		     m_LFS_FACTOR, v_LFS_FACTOR(mclk_fs));
+
+	/*Set N value*/
+	hdmi_msk_reg(hdmi_dev, AUD_N3, m_NCTS_ATOMIC_WR, v_NCTS_ATOMIC_WR(1));
+	/*Set CTS by manual*/
+	hdmi_msk_reg(hdmi_dev, AUD_CTS3,
+		     m_N_SHIFT | m_CTS_MANUAL | m_AUD_CTS3,
+		     v_N_SHIFT(N_SHIFT_1) |
+		     v_CTS_MANUAL(1) |
+		     v_AUD_CTS3(CTS >> 16));
+	hdmi_writel(hdmi_dev, AUD_CTS2, (CTS >> 8) & 0xff);
+	hdmi_writel(hdmi_dev, AUD_CTS1, CTS & 0xff);
+
+	hdmi_msk_reg(hdmi_dev, AUD_N3, m_AUD_N3, v_AUD_N3(N >> 16));
+	hdmi_writel(hdmi_dev, AUD_N2, (N >> 8) & 0xff);
+	hdmi_writel(hdmi_dev, AUD_N1, N & 0xff);
+
+	/* set channel status register */
+	hdmi_msk_reg(hdmi_dev, FC_AUDSCHNLS7,
+		     m_AUDIO_SAMPLE_RATE, v_AUDIO_SAMPLE_RATE(rate));
+	hdmi_writel(hdmi_dev, FC_AUDSCHNLS8, ((~rate) << 4) | 0x2);
+
+	hdmi_msk_reg(hdmi_dev, AUD_CONF0,
+		     m_SW_AUD_FIFO_RST, v_SW_AUD_FIFO_RST(1));
+
+	hdmi_dev_config_aai(hdmi_dev, audio);
+
+	return 0;
+}
+
+static int hdmi_dev_control_output(struct hdmi *hdmi, int enable)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+	struct hdmi_video vpara;
+
+	HDMIDBG(2, "[%s] %d\n", __func__, enable);
+	if (enable == HDMI_AV_UNMUTE) {
+		hdmi_writel(hdmi_dev, FC_DBGFORCE, 0x00);
+		if (hdmi->edid.sink_hdmi == OUTPUT_HDMI)
+			hdmi_msk_reg(hdmi_dev, FC_GCP,
+				     m_FC_SET_AVMUTE | m_FC_CLR_AVMUTE,
+				     v_FC_SET_AVMUTE(0) | v_FC_CLR_AVMUTE(1));
+	} else {
+		if (enable & HDMI_VIDEO_MUTE) {
+			hdmi_msk_reg(hdmi_dev, FC_DBGFORCE,
+				     m_FC_FORCEVIDEO, v_FC_FORCEVIDEO(1));
+			if (hdmi->edid.sink_hdmi == OUTPUT_HDMI) {
+				hdmi_msk_reg(hdmi_dev, FC_GCP,
+					     m_FC_SET_AVMUTE |
+					     m_FC_CLR_AVMUTE,
+					     v_FC_SET_AVMUTE(1) |
+					     v_FC_CLR_AVMUTE(0));
+				vpara.vic = hdmi->vic;
+				vpara.color_output = HDMI_COLOR_RGB_0_255;
+				hdmi_dev_config_avi(hdmi, &vpara);
+				while ((!hdmi_readl(hdmi_dev, IH_FC_STAT1)) &
+				       m_AVI_INFOFRAME) {
+					usleep_range(900, 1000);
+				}
+			}
+		}
+/*		if (enable & HDMI_AUDIO_MUTE) {
+ *			hdmi_msk_reg(hdmi_dev, FC_AUDSCONF,
+ *				     m_AUD_PACK_SAMPFIT,
+ *				     v_AUD_PACK_SAMPFIT(0x0F));
+ *		}
+ */
+		if (enable == (HDMI_VIDEO_MUTE | HDMI_AUDIO_MUTE)) {
+			if (hdmi->ops->hdcp_power_off_cb)
+				hdmi->ops->hdcp_power_off_cb(hdmi);
+			rockchip_hdmiv2_powerdown(hdmi_dev);
+		}
+	}
+	return 0;
+}
+
+static int hdmi_dev_insert(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	HDMIDBG(2, "%s\n", __func__);
+	if (!hdmi->uboot)
+		hdmi_writel(hdmi_dev, MC_CLKDIS, m_HDCPCLK_DISABLE);
+
+	return HDMI_ERROR_SUCCESS;
+}
+
+static int hdmi_dev_remove(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	HDMIDBG(2, "%s\n", __func__);
+	if (hdmi->ops->hdcp_power_off_cb)
+		hdmi->ops->hdcp_power_off_cb(hdmi);
+	rockchip_hdmiv2_powerdown(hdmi_dev);
+	hdmi_dev->tmdsclk = 0;
+	return HDMI_ERROR_SUCCESS;
+}
+
+static int hdmi_dev_enable(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	HDMIDBG(2, "%s\n", __func__);
+	if (!hdmi_dev->enable) {
+		hdmi_writel(hdmi_dev, IH_MUTE, 0x00);
+		hdmi_dev->enable = 1;
+	}
+	hdmi_submit_work(hdmi, HDMI_HPD_CHANGE, 10, 0);
+	return 0;
+}
+
+static int hdmi_dev_disable(struct hdmi *hdmi)
+{
+	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
+
+	HDMIDBG(2, "%s\n", __func__);
+	if (hdmi_dev->enable) {
+		hdmi_dev->enable = 0;
+		hdmi_writel(hdmi_dev, IH_MUTE, 0x1);
+	}
+	return 0;
+}
+
+void rockchip_hdmiv2_dev_init_ops(struct hdmi_ops *ops)
+{
+	if (ops) {
+		ops->enable	= hdmi_dev_enable;
+		ops->disable	= hdmi_dev_disable;
+		ops->getstatus	= hdmi_dev_detect_hotplug;
+		ops->insert	= hdmi_dev_insert;
+		ops->remove	= hdmi_dev_remove;
+		ops->getedid	= hdmi_dev_read_edid;
+		ops->setvideo	= hdmi_dev_config_video;
+		ops->setaudio	= hdmi_dev_config_audio;
+		ops->setmute	= hdmi_dev_control_output;
+		ops->setavi	= hdmi_dev_config_avi;
+		ops->setvsi	= hdmi_dev_config_vsi;
+		ops->sethdr	= hdmi_dev_config_hdr;
+	}
+}
+
+void rockchip_hdmiv2_dev_initial(struct hdmi_dev *hdmi_dev)
+{
+	struct hdmi *hdmi = hdmi_dev->hdmi;
+
+	/*lcdc source select*/
+	if (hdmi_dev->soctype == HDMI_SOC_RK3288) {
+		regmap_write(hdmi_dev->grf_base,
+			     RK3288_GRF_SOC_CON6,
+			     HDMI_SEL_LCDC(hdmi->property->videosrc, 4));
+		/* select GPIO7_C0 as cec pin */
+		regmap_write(hdmi_dev->grf_base, RK3288_GRF_SOC_CON8,
+			     BIT(12) | BIT(28));
+	} else if (hdmi_dev->soctype == HDMI_SOC_RK3399) {
+		regmap_write(hdmi_dev->grf_base,
+			     RK3399_GRF_SOC_CON20,
+			     HDMI_SEL_LCDC(hdmi->property->videosrc, 6));
+	}
+
+	if (!hdmi->uboot) {
+		pr_info("reset hdmi\n");
+		if (hdmi_dev->soctype == HDMI_SOC_RK322X) {
+			regmap_write(hdmi_dev->grf_base,
+				     RK322X_GRF_SOC_CON2,
+				     RK322X_DDC_MASK_EN);
+			regmap_write(hdmi_dev->grf_base,
+				     RK322X_GRF_SOC_CON6,
+				     RK322X_IO_3V_DOMAIN);
+		}
+		reset_control_assert(hdmi_dev->reset);
+		usleep_range(10, 20);
+		reset_control_deassert(hdmi_dev->reset);
+		rockchip_hdmiv2_powerdown(hdmi_dev);
+	} else {
+		hdmi->hotplug = hdmi_dev_detect_hotplug(hdmi);
+		if (hdmi->hotplug != HDMI_HPD_ACTIVATED)
+			hdmi->uboot = 0;
+	}
+	/*mute unnecessary interrupt, only enable hpd*/
+	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT0, 0xff);
+	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT1, 0xff);
+	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT2, 0xff);
+	hdmi_writel(hdmi_dev, IH_MUTE_AS_STAT0, 0xff);
+	hdmi_writel(hdmi_dev, IH_MUTE_PHY_STAT0, 0xfc);
+	hdmi_writel(hdmi_dev, IH_MUTE_I2CM_STAT0, 0xff);
+	hdmi_writel(hdmi_dev, IH_MUTE_CEC_STAT0, 0xff);
+	hdmi_writel(hdmi_dev, IH_MUTE_VP_STAT0, 0xff);
+	hdmi_writel(hdmi_dev, IH_MUTE_I2CMPHY_STAT0, 0xff);
+	hdmi_writel(hdmi_dev, IH_MUTE_AHBDMAAUD_STAT0, 0xff);
+
+	/* disable hdcp interrupt */
+	hdmi_writel(hdmi_dev, A_APIINTMSK, 0xff);
+	hdmi_writel(hdmi_dev, PHY_MASK, 0xf1);
+
+	if (hdmi->property->feature & SUPPORT_CEC)
+		rockchip_hdmiv2_cec_init(hdmi);
+	if (hdmi->property->feature & SUPPORT_HDCP)
+		rockchip_hdmiv2_hdcp_init(hdmi);
+}
+
+irqreturn_t rockchip_hdmiv2_dev_irq(int irq, void *priv)
+{
+	struct hdmi_dev *hdmi_dev = priv;
+	struct hdmi *hdmi = hdmi_dev->hdmi;
+	char phy_pol = hdmi_readl(hdmi_dev, PHY_POL0);
+	char phy_status = hdmi_readl(hdmi_dev, PHY_STAT0);
+	char phy_int0 = hdmi_readl(hdmi_dev, PHY_INI0);
+	/*read interrupt*/
+	char fc_stat0 = hdmi_readl(hdmi_dev, IH_FC_STAT0);
+	char fc_stat1 = hdmi_readl(hdmi_dev, IH_FC_STAT1);
+	char fc_stat2 = hdmi_readl(hdmi_dev, IH_FC_STAT2);
+	char aud_int = hdmi_readl(hdmi_dev, IH_AS_SATA0);
+	char phy_int = hdmi_readl(hdmi_dev, IH_PHY_STAT0);
+	char vp_stat0 = hdmi_readl(hdmi_dev, IH_VP_STAT0);
+	char cec_int = hdmi_readl(hdmi_dev, IH_CEC_STAT0);
+	char hdcp_int = hdmi_readl(hdmi_dev, A_APIINTSTAT);
+	u8 hdcp2_int = hdmi_readl(hdmi_dev, HDCP2REG_STAT);
+
+	/*clear interrupt*/
+	hdmi_writel(hdmi_dev, IH_FC_STAT0, fc_stat0);
+	hdmi_writel(hdmi_dev, IH_FC_STAT1, fc_stat1);
+	hdmi_writel(hdmi_dev, IH_FC_STAT2, fc_stat2);
+	hdmi_writel(hdmi_dev, IH_VP_STAT0, vp_stat0);
+
+	if (phy_int0 || phy_int) {
+		if ((phy_int0 & m_PHY_LOCK) &&
+		    (phy_pol & m_PHY_LOCK) == 0) {
+			pr_info("hdmi phy pll unlock\n");
+			hdmi_submit_work(hdmi, HDMI_SET_VIDEO, 0, 0);
+		}
+		phy_pol = (phy_int0 & (~phy_status)) | ((~phy_int0) & phy_pol);
+		hdmi_writel(hdmi_dev, PHY_POL0, phy_pol);
+		hdmi_writel(hdmi_dev, IH_PHY_STAT0, phy_int);
+		if ((phy_int & m_HPD) || ((phy_int & 0x3c) == 0x3c))
+			hdmi_submit_work(hdmi, HDMI_HPD_CHANGE, 20, 0);
+	}
+
+	/* Audio error */
+	if (aud_int) {
+		hdmi_writel(hdmi_dev, IH_AS_SATA0, aud_int);
+		hdmi_msk_reg(hdmi_dev, AUD_CONF0,
+			     m_SW_AUD_FIFO_RST, v_SW_AUD_FIFO_RST(1));
+		hdmi_writel(hdmi_dev, MC_SWRSTZREQ, 0xF7);
+	}
+	/* CEC */
+	if (cec_int) {
+		hdmi_writel(hdmi_dev, IH_CEC_STAT0, cec_int);
+		if (hdmi_dev->hdmi->property->feature & SUPPORT_CEC)
+			rockchip_hdmiv2_cec_isr(hdmi_dev, cec_int);
+	}
+	/* HDCP */
+	if (hdcp_int) {
+		hdmi_writel(hdmi_dev, A_APIINTCLR, hdcp_int);
+		rockchip_hdmiv2_hdcp_isr(hdmi_dev, hdcp_int);
+	}
+
+	/* HDCP2 */
+	if (hdcp2_int) {
+		hdmi_writel(hdmi_dev, HDCP2REG_STAT, hdcp2_int);
+		pr_info("hdcp2_int is 0x%02x\n", hdcp2_int);
+		if ((hdcp2_int & m_HDCP2_AUTH_FAIL ||
+		     hdcp2_int & m_HDCP2_AUTH_LOST) &&
+		    hdmi_dev->hdcp2_start) {
+			pr_info("hdcp2 failed or lost\n");
+			hdmi_dev->hdcp2_start();
+		}
+	}
+	return IRQ_HANDLED;
+}
diff -Nupr a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1756 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RK3288_HDMI_HW_H
+#define _RK3288_HDMI_HW_H
+#include <linux/interrupt.h>
+#include "../rockchip-hdmi.h"
+
+/*#define HDMI_INT_USE_POLL 1*/
+
+enum PWR_MODE {
+	NORMAL,
+	LOWER_PWR,
+};
+
+enum {
+	OUTPUT_DVI = 0,
+	OUTPUT_HDMI,
+};
+
+/* Color Space Conversion Mode */
+enum {
+	CSC_BYPASS,
+	CSC_RGB_0_255_TO_RGB_16_235_8BIT,	/* RGB 0-255 input to RGB
+						 * 16-235 output that is 8bit
+						 * clolor depth
+						 */
+	CSC_RGB_0_255_TO_RGB_16_235_10BIT,	/* RGB 0-255 input to RGB
+						 * 16-235 output that is 8bit
+						 * clolor depth
+						 */
+	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,	/* RGB 0-255 input to YCbCr
+						 * 16-235 output according
+						 * BT601 that is 8bit clolor
+						 * depth
+						 */
+	CSC_RGB_0_255_TO_ITU601_16_235_10BIT,	/* RGB 0-255 input to YCbCr
+						 * 16-235 output according
+						 * BT601 that is 10bit clolor
+						 * depth
+						 */
+	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,	/* RGB 0-255 input to YCbCr
+						 * 16-235 output accroding
+						 * BT709 that is 8bit clolor
+						 * depth
+						 */
+	CSC_RGB_0_255_TO_ITU709_16_235_10BIT,	/* RGB 0-255 input to YCbCr
+						 * 16-235 output accroding
+						 * BT709 that is 10bit clolor
+						 * depth
+						 */
+	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,	/* YCbCr 16-235 input to RGB
+						 * 0-255 output according
+						 * BT601 that is 8bit clolor
+						 * depth
+						 */
+	CSC_ITU709_16_235_TO_RGB_0_255_8BIT,	/* YCbCr 16-235 input to RGB
+						 * 0-255 output according
+						 * BT709 that is 8bit clolor
+						 * depth
+						 */
+	CSC_ITU601_16_235_TO_RGB_16_235_8BIT,	/* YCbCr 16-235 input to RGB
+						 * 16-235 output according
+						 * BT601 that is 8bit clolor
+						 * depth
+						 */
+	CSC_ITU709_16_235_TO_RGB_16_235_8BIT	/* YCbCr 16-235 input to RGB
+						 * 16-235 output according
+						 * BT709 that is 8bit clolor
+						 * depth
+						 */
+};
+
+#define HDMI_SCL_RATE		(100 * 1000)
+#define DDC_I2C_EDID_ADDR	0x50	/* 0xA0/2 = 0x50 */
+#define DDC_I2C_SEG_ADDR	0x30	/* 0x60/2 = 0x30 */
+#define DDC_I2C_SCDC_ADDR	0x54	/* 0xa8/2 = 0x54 */
+
+/* Register and Field Descriptions */
+/* Identification Registers */
+#define IDENTIFICATION_BASE		0x0000
+
+#define DESIGN_ID			0x0000
+#define REVISION_ID			0x0001
+#define PRODUCT_ID0			0x0002
+#define PRODUCT_ID1			0x0003
+
+#define CONFIG0_ID			0x0004
+#define m_PREPEN		BIT(7)
+#define m_AUDSPDIF		BIT(5)
+#define m_AUDI2S		BIT(4)
+#define m_HDMI14		BIT(3)
+#define m_CSC			BIT(2)
+#define m_CEC			BIT(1)
+#define m_HDCP			BIT(0)
+
+#define CONFIG1_ID			0x0005
+#define m_HDCP22		BIT(6)
+#define m_HDMI20		BIT(5)
+#define m_CONFAPB		BIT(1)
+
+#define CONFIG2_ID			0x0006
+enum PHYTYPE {
+	HDMI_TX_PHY = 0x00,
+	HDMI_MHL_WITH_HEAC_PHY = 0xb2,
+	HDMI_MHL_PHY = 0xc2,
+	HDMI_3D_TX_WITH_HEAC_PHY = 0xe2,
+	HDMI_3D_TX_PHY = 0xf2,
+	HDMI2_TX_PHY = 0xf3
+};
+
+#define CONFIG3_ID			0x0007
+#define m_AHB_AUD_DMA		BIT(1)
+#define m_GP_AUD		BIT(0)
+
+/* Interrupt Registers */
+#define INTERRUPT_BASE                  0x0100
+
+#define IH_FC_STAT0			0x0100
+#define m_AUD_INFOFRAME		BIT(7)
+#define m_AUD_CONTENT_PROTECT	BIT(6)
+#define m_AUD_HBR		BIT(5)
+#define m_AUD_SAMPLE		BIT(2)
+#define m_AUD_CLK_REGEN		BIT(1)
+#define m_NULL_PACKET		BIT(0)
+
+#define IH_FC_STAT1			0x0101
+#define m_GMD			BIT(7)
+#define m_ISCR1			BIT(6)
+#define m_ISCR2			BIT(5)
+#define m_VSD			BIT(4)
+#define m_SPD			BIT(3)
+#define m_AVI_INFOFRAME		BIT(1)
+#define m_GCP			BIT(0)
+
+#define v_AVI_INFOFRAME(n)	(((n) & 0x01) << 1)
+
+#define IH_FC_STAT2			0x0102
+#define m_LOWPRIO_OVERFLOW	BIT(1)
+#define m_HIGHPRIO_OVERFLOW	BIT(0)
+
+#define IH_AS_SATA0			0x0103
+#define m_FIFO_UNDERRUN		BIT(4)
+#define m_FIFO_OVERRUN		BIT(3)
+#define m_AUD_FIFO_UDFLOW_THR	BIT(2)
+#define m_AUD_FIFO_UDFLOW	BIT(1)
+#define m_AUD_FIFO_OVERFLOW	BIT(0)
+
+#define IH_PHY_STAT0			0x0104
+#define m_RX_SENSE3		BIT(5)
+#define m_RX_SENSE2		BIT(4)
+#define m_RX_SENSE1		BIT(3)
+#define m_RX_SENSE0		BIT(2)
+#define m_TX_PHY_LOCK		BIT(1)
+#define m_HPD			BIT(0)
+
+#define IH_I2CM_STAT0			0x0105
+#define m_SCDC_READREQ		BIT(2)
+#define m_I2CM_DONE		BIT(1)
+#define m_I2CM_ERROR		BIT(0)
+
+#define IH_CEC_STAT0			0x0106
+#define m_WAKEUP		BIT(6)
+#define m_ERR_FOLLOW		BIT(5)
+#define m_ERR_INITIATOR		BIT(4)
+#define m_ARB_LOST		BIT(3)
+#define m_NACK			BIT(2)
+#define m_EOM			BIT(1)
+#define m_DONE			BIT(0)
+
+#define IH_VP_STAT0			0x0107
+#define m_FIFOFULL_REPET	BIT(7)
+#define m_FIFOEMPTY_REPET	BIT(6)
+#define m_FIFOFULL_PACK		BIT(5)
+#define m_FIFOEMPTY_PACK	BIT(4)
+#define m_FIFOFULL_REMAP	BIT(3)
+#define m_FIFOEMPTY_REMAP	BIT(2)
+#define m_FIFOFULL_BYPASS	BIT(1)
+#define m_FIFOEMPTY_BYPASS	BIT(0)
+
+#define IH_I2CMPHY_STAT0		0x0108
+#define m_I2CMPHY_DONE		BIT(1)
+#define m_I2CMPHY_ERR		BIT(0)
+
+#define IH_AHBDMAAUD_STAT0		0x0109
+#define m_AUDDMA_INT_BUFOVERRUN	BIT(6)
+#define m_AUDDMA_INT_ERR	BIT(5)
+#define m_AUDDMA_INT_LOST	BIT(4)
+#define m_AUDDMA_INT_RETRYSPLIT BIT(3)
+#define m_AUDDMA_INT_DONE	BIT(2)
+#define m_AUDDMA_INT_BUFFULL	BIT(1)
+#define m_AUDDMA_INT_BUFEMPTY	BIT(0)
+
+#define IH_DECODE			0x0170
+#define m_IH_FC_STAT0		BIT(7)
+#define m_IH_FC_STAT1		BIT(6)
+#define m_IH_FC_STAT2_VP	BIT(5)
+#define m_IH_AS_STAT0		BIT(4)
+#define m_IH_PHY		BIT(3)
+#define m_IH_I2CM_STAT0		BIT(2)
+#define m_IH_CEC_STAT0		BIT(1)
+#define m_IH_AHBDMAAUD_STAT0	BIT(0)
+
+#define IH_MUTE_FC_STAT0		0x0180
+#define m_AUDI_MUTE		BIT(7)
+#define m_ACP_MUTE		BIT(6)
+#define m_DST_MUTE		BIT(4)
+#define m_OBA_MUTE		BIT(3)
+#define m_AUDS_MUTE		BIT(2)
+#define m_ACR_MUTE		BIT(1)
+#define m_NULL_MUTE		BIT(0)
+
+#define IH_MUTE_FC_STAT1		0x0181
+#define m_GMD_MUTE		BIT(7)
+#define m_ISCR1_MUTE		BIT(6)
+#define m_ISCR2_MUTE		BIT(5)
+#define m_VSD_MUTE		BIT(4)
+#define m_SPD_MUTE		BIT(3)
+#define m_AVI_MUTE		BIT(1)
+#define m_GCP_MUTE		BIT(0)
+
+#define IH_MUTE_FC_STAT2		0x0182
+#define m_LPRIO_OVERFLOW_MUTE	BIT(1)
+#define m_HPRIO_OVERFLOW_MUTE	BIT(0)
+
+#define IH_MUTE_AS_STAT0		0x0183
+#define m_FIFO_UNDERRUN_MUTE	BIT(4)
+#define m_FIFO_OVERRUN_MUTE	BIT(3)
+#define m_AUD_FIFO_UDF_THR_MUTE	BIT(2)
+#define m_AUD_FIFO_UDF_MUTE	BIT(1)
+#define m_AUD_FIFO_OVF_MUTE	BIT(0)
+
+#define IH_MUTE_PHY_STAT0		0x0184
+#define m_RX_SENSE3_MUTE	BIT(5)
+#define m_RX_SENSE2_MUTE	BIT(4)
+#define m_RX_SENSE1_MUTE	BIT(3)
+#define m_RX_SENSE0_MUTE	BIT(2)
+#define m_TX_PHY_LOCK_MUTE	BIT(1)
+#define m_HPD_MUTE		BIT(0)
+
+#define IH_MUTE_I2CM_STAT0		0x0185
+#define m_SCDC_READREQ_MUTE	BIT(2)
+#define v_SCDC_READREQ_MUTE(n)	(((n) & 0x01) << 2)
+#define m_I2CM_DONE_MUTE	BIT(1)
+#define v_I2CM_DONE_MUTE(n)	(((n) & 0x01) << 1)
+#define m_I2CM_ERR_MUTE		BIT(0)
+#define v_I2CM_ERR_MUTE(n)	(((n) & 0x01) << 0)
+
+#define IH_MUTE_CEC_STAT0		0x0186
+#define m_WAKEUP_MUTE		BIT(6)
+#define m_ERR_FOLLOW_MUTE	BIT(5)
+#define m_ERR_INITIATOR_MUTE	BIT(4)
+#define m_ARB_LOST_MUTE		BIT(3)
+#define m_NACK_MUTE		BIT(2)
+#define m_EOM_MUTE		BIT(1)
+#define m_DONE_MUTE		BIT(0)
+
+#define IH_MUTE_VP_STAT0		0x0187
+#define m_FIFOFULL_REP_MUTE	BIT(7)
+#define m_FIFOEMPTY_REP_MUTE	BIT(6)
+#define m_FIFOFULL_PACK_MUTE	BIT(5)
+#define m_FIFOEMPTY_PACK_MUTE	BIT(4)
+#define m_FIFOFULL_REMAP_MUTE	BIT(3)
+#define m_FIFOEMPTY_REMAP_MUTE	BIT(2)
+#define m_FIFOFULL_BYP_MUTE	BIT(1)
+#define m_FIFOEMPTY_BYP_MUTE	BIT(0)
+
+#define IH_MUTE_I2CMPHY_STAT0		0x0188
+#define m_I2CMPHY_DONE_MUTE	BIT(1)
+#define m_I2CMPHY_ERR_MUTE	BIT(0)
+
+#define IH_MUTE_AHBDMAAUD_STAT0		0x0189
+#define IH_MUTE				0x01ff
+
+/* Video Sampler Registers */
+#define VIDEO_SAMPLER_BASE		0x0200
+
+#define TX_INVID0			0x0200
+#define m_INTERNAL_DE_GEN	BIT(7)
+#define v_INTERNAL_DE_GEN(n)	(((n) & 0x01) << 7)
+enum VIDEO_MODE {
+	VIDEO_RGB444_8BIT = 0x01,
+	VIDEO_RGB444_10BIT = 0x03,
+	VIDEO_RGB444_12BIT = 0x05,
+	VIDEO_RGB444_16BIT = 0x07,
+	VIDEO_YCBCR444_8BIT = 0x09,	/* or YCbCr420 */
+	VIDEO_YCBCR444_10BIT = 0x0b,	/* or YCbCr420 */
+	VIDEO_YCBCR444_12BIT = 0x0d,	/* or YCbCr420 */
+	VIDEO_YCBCR444_16BIT = 0x0f,	/* or YCbCr420 */
+	VIDEO_YCBCR422_12BIT = 0x12,
+	VIDEO_YCBCR422_10BIT = 0x14,
+	VIDEO_YCBCR422_8BIT = 0x16
+};
+
+#define m_VIDEO_MAPPING		(0x1f << 0)
+#define v_VIDEO_MAPPING(n)	((n) & 0x1f)
+
+#define TX_INSTUFFING			0x0201
+#define m_BCBDATA_STUFF		BIT(2)
+#define v_BCBDATA_STUFF(n)	(((n) & 0x01) << 2)
+#define m_RCRDATA_STUFF		BIT(1)
+#define v_RCRDATA_STUFF(n)	(((n) & 0x01) << 1)
+#define m_GYDATA_STUFF		BIT(0)
+#define v_GYDATA_STUFF(n)	(((n) & 0x01) << 0)
+
+#define TX_GYDATA0			0x0202
+#define TX_GYDATA1			0x0203
+#define TX_RCRDATA0			0x0204
+#define TX_RCRDATA1			0x0205
+#define TX_BCBDATA0			0x0206
+#define TX_BCBDATA1			0x0207
+
+/* Video Packetizer Registers */
+#define VIDEO_PACKETIZER_BASE		0x0800
+
+#define VP_STATUS			0x0800
+#define m_PACKING_PHASE		(0x0f << 0)
+
+#define VP_PR_CD			0x0801
+enum COLOR_DEPTH {
+	COLOR_DEPTH_24BIT_DEFAULT = 0,
+	COLOR_DEPTH_24BIT = 0x04,
+	COLOR_DEPTH_30BIT,
+	COLOR_DEPTH_36BIT,
+	COLOR_DEPTH_48BIT
+};
+
+#define m_COLOR_DEPTH		(0x0f << 4)
+#define v_COLOR_DEPTH(n)	(((n) & 0x0f) << 4)
+enum PIXEL_REPET {
+	NO_PIXEL_REPET = 0,
+	PIXEL_SENT_2TIMES,
+	PIXEL_SENT_3TIMES,
+	PIXEL_SENT_4TIMES,
+	PIXEL_SENT_5TIMES,
+	PIXEL_SENT_6TIMES,
+	PIXEL_SENT_7TIMES,
+	PIXEL_SENT_8TIMES,
+	PIXEL_SENT_9TIMES,
+	PIXEL_SENT_10TIMES
+};
+
+#define m_DESIRED_PR_FACTOR	(0x0f << 0)
+#define v_DESIRED_PR_FACTOR(n)	(((n) & 0x0f) << 0)
+
+#define VP_STUFF			0x0802
+#define m_IDEFAULT_PHASE	BIT(5)
+#define v_IDEFAULT_PHASE(n)	(((n) & 0x01) << 5)
+#define m_IFIX_PP_TO_LAST	BIT(4)
+#define m_ICX_GOTO_P0_ST	BIT(3)
+enum {
+	DIRECT_MODE = 0,
+	STUFFING_MODE
+};
+
+#define m_YCC422_STUFFING	BIT(2)
+#define v_YCC422_STUFFING(n)	(((n) & 0x01) << 2)
+#define m_PP_STUFFING		BIT(1)
+#define v_PP_STUFFING(n)	(((n) & 0x01) << 1)
+#define m_PR_STUFFING		BIT(0)
+#define v_PR_STUFFING(n)	(((n) & 0x01) << 0)
+
+#define VP_REMAP			0x0803
+enum YCC422_SIZE {
+	YCC422_16BIT = 0,
+	YCC422_20BIT,
+	YCC422_24BIT
+};
+
+#define m_YCC422_SIZE		(0x03 << 0)
+#define v_YCC422_SIZE(n)	(((n) & 0x03) << 0)
+
+#define VP_CONF				0x0804
+#define m_BYPASS_EN		BIT(6)
+#define v_BYPASS_EN(n)		(((n) & 0x01) << 6)
+#define m_PIXEL_PACK_EN		BIT(5)
+#define v_PIXEL_PACK_EN(n)	(((n) & 0x01) << 5)
+#define m_PIXEL_REPET_EN	BIT(4)
+#define v_PIXEL_REPET_EN(n)	(((n) & 0x01) << 4)
+#define m_YCC422_EN		BIT(3)
+#define v_YCC422_EN(n)		(((n) & 0x01) << 3)
+#define m_BYPASS_SEL		BIT(2)
+#define v_BYPASS_SEL(n)		(((n) & 0x01) << 2)
+enum {
+	OUT_FROM_PIXEL_PACKING = 0,
+	OUT_FROM_YCC422_REMAP,
+	OUT_FROM_8BIT_BYPASS
+};
+
+#define m_OUTPUT_SEL		(0x03 << 0)
+#define v_OUTPUT_SEL(n)		(((n) & 0x03) << 0)
+
+#define VP_MASK				0x0807
+#define m_OINTFULL_REPET	BIT(7)
+#define m_OINTEMPTY_REPET	BIT(6)
+#define m_OINTFULL_PACK		BIT(5)
+#define m_OINTEMPTY_PACK	BIT(4)
+#define m_OINTFULL_REMAP	BIT(3)
+#define m_OINTEMPTY_REMAP	BIT(2)
+#define m_OINTFULL_BYPASS	BIT(1)
+#define m_OINTEMPTY_BYPASS	BIT(0)
+
+/* Frame Composer Registers */
+#define FRAME_COMPOSER_BASE		0x1000
+
+#define	FC_INVIDCONF			0x1000
+#define m_FC_HDCP_KEEPOUT	BIT(7)
+#define v_FC_HDCP_KEEPOUT(n)	(((n) & 0x01) << 7)
+#define m_FC_VSYNC_POL		BIT(6)
+#define v_FC_VSYNC_POL(n)	(((n) & 0x01) << 6)
+#define m_FC_HSYNC_POL		BIT(5)
+#define v_FC_HSYNC_POL(n)	(((n) & 0x01) << 5)
+#define m_FC_DE_POL		BIT(4)
+#define v_FC_DE_POL(n)		(((n) & 0x01) << 4)
+#define m_FC_HDMI_DVI		BIT(3)
+#define v_FC_HDMI_DVI(n)	(((n) & 0x01) << 3)
+#define m_FC_VBLANK		BIT(1)
+#define v_FC_VBLANK(n)		(((n) & 0x01) << 1)
+#define m_FC_INTERLACE_MODE	BIT(0)
+#define v_FC_INTERLACE_MODE(n)	(((n) & 0x01) << 0)
+
+#define	FC_INHACTIV0			0x1001
+
+#define	FC_INHACTIV1			0x1002
+#define v_FC_HACTIVE1(n)	((n) & 0x3f)
+#define m_FC_H_ACTIVE_13	BIT(5)
+#define v_FC_H_ACTIVE_13(n)	(((n) & 0x01) << 5)
+#define m_FC_H_ACTIVE_12	BIT(4)
+#define v_FC_H_ACTIVE_12(n)	(((n) & 0x01) << 4)
+#define m_FC_H_ACTIVE		(0x0f << 0)
+#define v_FC_H_ACTIVE(n)	(((n) & 0x0f) << 0)
+
+#define	FC_INHBLANK0			0x1003
+
+#define	FC_INHBLANK1			0x1004
+#define v_FC_HBLANK1(n)		((n) & 0x1f)
+#define m_FC_H_BLANK_12_11	(0x07 << 2)
+#define v_FC_H_BLANK_12_11(n)	(((n) & 0x07) << 2)
+#define m_FC_H_BLANK		(0x03 << 0)
+#define v_FC_H_BLANK(n)		(((n) & 0x03) << 0)
+
+#define	FC_INVACTIV0			0x1005
+
+#define	FC_INVACTIV1			0x1006
+#define v_FC_VACTIVE1(n)	((n) & 0x1f)
+#define m_FC_V_ACTIVE_12_11	(0x03 << 3)
+#define v_FC_V_ACTIVE_12_11(n)	(((n) & 0x03) << 3)
+#define m_FC_V_ACTIVE		(0x07 << 0)
+#define v_FC_V_ACTIVE(n)	(((n) & 0x07) << 0)
+
+#define	FC_INVBLANK			0x1007
+#define	FC_HSYNCINDELAY0		0x1008
+
+#define	FC_HSYNCINDELAY1		0x1009
+#define v_FC_HSYNCINDEAY1(n)	((n) & 0x1f)
+#define m_FC_H_SYNCFP_12_11	(0x03 << 3)
+#define v_FC_H_SYNCFP_12_11(n)	(((n) & 0x03) << 3)
+#define m_FC_H_SYNCFP		(0x07 << 0)
+#define v_FC_H_SYNCFP(n)	(((n) & 0x07) << 0)
+
+#define	FC_HSYNCINWIDTH0		0x100a
+
+#define	FC_HSYNCINWIDTH1		0x100b
+#define v_FC_HSYNCWIDTH1(n)	((n) & 0x03)
+#define m_FC_HSYNC_9		BIT(1)
+#define v_FC_HSYNC_9(n)		(((n) & 0x01) << 1)
+#define m_FC_HSYNC		BIT(0)
+#define v_FC_HSYNC(n)		(((n) & 0x01) << 0)
+
+#define	FC_VSYNCINDELAY			0x100c
+#define	FC_VSYNCINWIDTH			0x100d
+#define	FC_INFREQ0			0x100e
+#define	FC_INFREQ1			0x100f
+#define	FC_INFREQ2			0x1010
+#define	FC_CTRLDUR			0x1011
+#define	FC_EXCTRLDUR			0x1012
+#define	FC_EXCTRLSPAC			0x1013
+#define	FC_CH0PREAM			0x1014
+#define	FC_CH1PREAM			0x1015
+#define	FC_CH2PREAM			0x1016
+
+#define	FC_AVICONF3			0x1017
+enum YCC_QUAN_RANGE {
+	YQ_LIMITED_RANGE = 0,
+	YQ_FULL_RANGE,
+	RESERVED,
+};
+
+#define m_FC_YQ			(0x03 << 2)
+#define v_FC_YQ(n)		(((n) & 0x03) << 2)
+enum IT_CONTENT_TYPE {
+	CN_GRAPHICS = 0,
+	CN_PHOTO,
+	CN_CINEMA,
+	CN_GAME,
+};
+
+#define m_FC_CN			(0x03 << 0)
+#define v_FC_CN(n)		(((n) & 0x03) << 0)
+
+#define	FC_GCP				0x1018
+#define m_FC_DEFAULT_PHASE	BIT(2)
+#define v_FC_DEFAULT_PHASE(n)	(((n) & 0x01) << 2)
+#define m_FC_SET_AVMUTE		BIT(1)
+#define v_FC_SET_AVMUTE(n)	(((n) & 0x01) << 1)
+#define m_FC_CLR_AVMUTE		BIT(0)
+#define v_FC_CLR_AVMUTE(n)	(((n) & 0x01) << 0)
+
+enum {
+	AVI_COLOR_MODE_RGB = 0,
+	AVI_COLOR_MODE_YCBCR422,
+	AVI_COLOR_MODE_YCBCR444,
+	AVI_COLOR_MODE_YCBCR420
+};
+
+enum {
+	AVI_COLORIMETRY_NO_DATA = 0,
+	AVI_COLORIMETRY_SMPTE_170M,
+	AVI_COLORIMETRY_ITU709,
+	AVI_COLORIMETRY_EXTENDED
+};
+
+enum {
+	AVI_CODED_FRAME_ASPECT_NO_DATA,
+	AVI_CODED_FRAME_ASPECT_4_3,
+	AVI_CODED_FRAME_ASPECT_16_9
+};
+
+enum {
+	ACTIVE_ASPECT_RATE_DEFAULT = 0x08,
+	ACTIVE_ASPECT_RATE_4_3,
+	ACTIVE_ASPECT_RATE_16_9,
+	ACTIVE_ASPECT_RATE_14_9
+};
+
+enum {
+	AVI_QUANTIZATION_RANGE_DEFAULT = 0,
+	AVI_QUANTIZATION_RANGE_LIMITED,
+	AVI_QUANTIZATION_RANGE_FULL
+};
+
+#define	FC_AVICONF0			0x1019
+#define m_FC_RGC_YCC_2		BIT(7)	/* use for HDMI2.0 TX */
+#define v_FC_RGC_YCC_2(n)	(((n) & 0x01) << 7)
+#define m_FC_ACTIV_FORMAT	BIT(6)
+#define v_FC_ACTIV_FORMAT(n)	(((n) & 0x01) << 6)
+#define m_FC_SCAN_INFO		(0x03 << 4)
+#define v_FC_SCAN_INFO(n)	(((n) & 0x03) << 4)
+#define m_FC_BAR_FORMAT		(0x03 << 2)
+#define v_FC_BAR_FORMAT(n)	(((n) & 0x03) << 2)
+#define m_FC_RGC_YCC		(0x03 << 0)
+#define v_FC_RGC_YCC(n)		(((n) & 0x03) << 0)
+
+#define	FC_AVICONF1			0x101a
+#define m_FC_COLORIMETRY	(0x03 << 6)
+#define v_FC_COLORIMETRY(n)	(((n) & 0x03) << 6)
+#define m_FC_PIC_ASPEC_RATIO	(0x03 << 4)
+#define v_FC_PIC_ASPEC_RATIO(n)	(((n) & 0x03) << 4)
+#define m_FC_ACT_ASPEC_RATIO	(0x0f << 0)
+#define v_FC_ACT_ASPEC_RATIO(n)	(((n) & 0x0f) << 0)
+
+#define	FC_AVICONF2			0x101b
+#define m_FC_IT_CONTENT		BIT(7)
+#define v_FC_IT_CONTENT(n)	(((n) & 0x01) << 7)
+#define m_FC_EXT_COLORIMETRY	(0x07 << 4)
+#define v_FC_EXT_COLORIMETRY(n)	(((n) & 0x07) << 4)
+#define m_FC_QUAN_RANGE		(0x03 << 2)
+#define v_FC_QUAN_RANGE(n)	(((n) & 0x03) << 2)
+#define m_FC_NUN_PIC_SCALE	(0x03 << 0)
+#define v_FC_NUN_PIC_SCALE(n)	(((n) & 0x03) << 0)
+
+#define	FC_AVIVID			0x101c
+#define m_FC_AVIVID_H		BIT(7)	/* use for HDMI2.0 TX */
+#define v_FC_AVIVID_H(n)	(((n) & 0x01) << 7)
+#define m_FC_AVIVID		(0x7f << 0)
+#define v_FC_AVIVID(n)		(((n) & 0x7f) << 0)
+
+#define	FC_AVIETB0			0x101d
+#define	FC_AVIETB1			0x101e
+#define	FC_AVISBB0			0x101f
+#define	FC_AVISBB1			0x1020
+#define	FC_AVIELB0			0x1021
+#define	FC_AVIELB1			0x1022
+#define	FC_AVISRB0			0x1023
+#define	FC_AVISRB1			0x1024
+
+#define	FC_AUDICONF0			0x1025
+#define m_FC_CHN_CNT		(0x07 << 4)
+#define v_FC_CHN_CNT(n)		(((n) & 0x07) << 4)
+#define m_FC_CODING_TYPE	(0x0f << 0)
+#define v_FC_CODING_TYPE(n)	(((n) & 0x0f) << 0)
+
+#define	FC_AUDICONF1			0x1026
+#define m_FC_SAMPLE_SIZE	(0x03 << 4)
+#define v_FC_SAMPLE_SIZE(n)	(((n) & 0x03) << 4)
+#define m_FC_SAMPLE_FREQ	(0x07 << 0)
+#define v_FC_SAMPLE_FREQ(n)	(((n) & 0x07) << 0)
+
+#define	FC_AUDICONF2			0x1027
+
+#define	FC_AUDICONF3			0x1028
+#define m_FC_LFE_PBL		(0x03 << 5)	/*only use for HDMI1.4 TX*/
+#define v_FC_LFE_PBL(n)		(((n) & 0x03) << 5)
+#define m_FC_DM_INH		BIT(4)
+#define v_FC_DM_INH(n)		(((n) & 0x01) << 4)
+#define m_FC_LSV		(0x0f << 0)
+#define v_FC_LSV(n)		(((n) & 0x0f) << 0)
+
+#define	FC_VSDIEEEID2			0x1029
+#define	FC_VSDSIZE			0x102a
+#define	FC_VSDIEEEID1			0x1030
+#define	FC_VSDIEEEID0			0x1031
+#define	FC_VSDPAYLOAD0			0x1032	/* 0~23 */
+#define	FC_SPDVENDORNAME0		0x104a	/* 0~7 */
+#define	FC_SPDPRODUCTNAME0		0x1052	/* 0~15 */
+#define	FC_SPDDEVICEINF			0x1062
+
+#define	FC_AUDSCONF			0x1063
+#define m_AUD_PACK_SAMPFIT	(0x0f << 4)
+#define v_AUD_PACK_SAMPFIT(n)	(((n) & 0x0f) << 4)
+#define m_AUD_PACK_LAYOUT	BIT(0)
+#define v_AUD_PACK_LAYOUT(n)	(((n) & 0x01) << 0)
+
+#define	FC_AUDSSTAT			0x1064
+#define	FC_AUDSV			0x1065
+#define	FC_AUDSU			0x1066
+#define	FC_AUDSCHNLS0			0x1067	/*0~8*/
+#define	FC_AUDSCHNLS1			0x1068
+#define	FC_AUDSCHNLS2			0x1069
+#define	FC_AUDSCHNLS3			0x106a
+#define	FC_AUDSCHNLS4			0x106b
+#define	FC_AUDSCHNLS5			0x106c
+#define	FC_AUDSCHNLS6			0x106d
+#define	FC_AUDSCHNLS7			0x106e
+#define	FC_AUDSCHNLS8			0x106f
+
+enum {
+	AUDIO_32K	= 0x3,
+	AUDIO_441K	= 0x0,
+	AUDIO_48K	= 0x2,
+	AUDIO_882K	= 0x8,
+	AUDIO_96K	= 0xa,
+	AUDIO_1764K	= 0xc,
+	AUDIO_192K	= 0xe,
+	AUDIO_768K	= 0x9,
+};
+
+#define m_AUDIO_SAMPLE_RATE		(0x0f << 0)
+#define v_AUDIO_SAMPLE_RATE(n)	(((n) & 0x0f) << 0)
+#define m_AUDIO_ORI_SAMPLE_RATE		(0x0f << 4)
+#define v_AUDIO_ORI_SAMPLE_RATE(n)	(((~(n)) & 0x0f) << 4)
+
+#define m_AUDIO_WORD_LENGTH		(0x0f << 0)
+#define v_AUDIO_WORD_LENGTH(n)	(((n) & 0x0f) << 0)
+
+#define	FC_CTRLQHIGH			0x1073
+#define	FC_CTRLQLOW			0x1074
+#define	FC_ACP0				0x1075
+#define	FC_ACP16			0x1082	/* 16~1 */
+#define	FC_ISCR1_0			0x1092
+#define	FC_ISCR1_16			0x1093	/* 16~1 */
+#define	FC_ISCR2_15			0x10a3	/* 15~0 */
+
+#define	FC_DATAUTO0			0x10b3
+#define m_SPD_AUTO		BIT(4)
+#define v_SPD_AUTO(n)		(((n) & 0x01) << 4)
+#define m_VSD_AUTO		BIT(3)
+#define v_VSD_AUTO(n)		(((n) & 0x01) << 3)
+#define m_ISCR2_AUTO		BIT(2)
+#define v_ISCR2_AUTO(n)		(((n) & 0x01) << 2)
+#define m_ISCR1_AUTO		BIT(1)
+#define v_ISCR1_AUTO(n)		(((n) & 0x01) << 1)
+#define m_ACP_AUTO		BIT(0)
+#define v_ACP_AUTO(n)		(((n) & 0x01) << 0)
+
+#define	FC_DATAUTO1			0x10b4
+#define	FC_DATAUTO2			0x10b5
+
+#define	FC_DATMAN			0x10b6
+#define m_SPD_MAN		BIT(4)
+#define v_SPD_MAN(n)		(((n) & 0x01) << 4)
+#define m_VSD_MAN		BIT(3)
+#define v_VSD_MAN(n)		(((n) & 0x01) << 3)
+#define m_ISCR2_MAN		BIT(2)
+#define v_ISCR2_MAN(n)		(((n) & 0x01) << 2)
+#define m_ISCR1_MAN		BIT(1)
+#define v_ISCR1_MAN(n)		(((n) & 0x01) << 1)
+#define m_ACP_MAN		BIT(0)
+#define v_ACP_MAN(n)		(((n) & 0x01) << 0)
+
+#define	FC_DATAUTO3			0x10b7
+	#define m_AVI_AUTO		BIT(3)
+	#define v_AVI_AUTO(n)		(((n) & 0x01) << 3)
+	#define m_GCP_AUTO		BIT(2)
+	#define v_GCP_AUTO(n)		(((n) & 0x01) << 2)
+	#define m_AAI_AUTO		BIT(1)
+	#define v_AAI_AUTO(n)		(((n) & 0x01) << 1)
+	#define m_ACR_AUTO		BIT(0)
+	#define v_ACR_AUTO(n)		(((n) & 0x01) << 0)
+#define	FC_RDRB0			0x10b8
+#define	FC_RDRB1			0x10b9
+#define	FC_RDRB2			0x10ba
+#define	FC_RDRB3			0x10bb
+#define	FC_RDRB4			0x10bc
+#define	FC_RDRB5			0x10bd
+#define	FC_RDRB6			0x10be
+#define	FC_RDRB7			0x10bf
+	#define m_AVI_PACKETS_PER_FRAME		(0xf << 4)
+	#define m_AVI_PACKERS_LINE_SPACING	(0xf)
+	#define v_AVI_PACKETS_PER_FRAME(n)	(((n) & 0x0f) << 4)
+	#define v_AVI_PACKERS_LINE_SPACING(n)	(((n) & 0x0f) << 0)
+#define	FC_MASK0			0x10d2
+#define	FC_MASK1			0x10d6
+#define	FC_MASK2			0x10da
+
+#define	FC_PRCONF			0x10e0
+#define m_FC_PR_FACTOR		(0x0f << 4)
+#define v_FC_PR_FACTOR(n)	(((n) & 0x0f) << 4)
+#define m_FC_PR_FACTOR_OUT	(0x0f)
+#define v_FC_PR_FACTOR_OUT(n)	((n) & 0x0f)
+
+#define	FC_SCRAMBLER_CTRL		0x10e1
+#define m_FC_SCRAMBLE_UCP	BIT(4)
+#define v_FC_SCRAMBLE_UCP(n)	(((n) & 0x01) << 4)
+#define m_FC_SCRAMBLE_EN	BIT(0)
+#define v_FC_SCRAMBLE_EN(n)	(((n) & 0x01) << 0)
+
+#define	FC_GMD_STAT			0x1100
+#define	FC_GMD_EN			0x1101
+#define	FC_GMD_UP			0x1102
+#define	FC_GMD_CONF			0x1103
+#define	FC_GMD_HB			0x1104
+#define	FC_GMD_PB0			0x1105	/*0~27*/
+
+#define	FC_PACK_TXE			0x10e3
+	#define m_DRM_TXEN		BIT(7)
+	#define v_DRM_TXEN(n)		(((n) & 0x01) << 7)
+#define FC_DRM_UP			0x1167
+	#define m_DRM_PUPD		BIT(0)
+	#define v_DRM_PUPD(n)		(((n) & 0x01) << 0)
+#define FC_DRM_HB			0x1168
+#define FC_DRM_PB			0x116a
+#define m_DRM_MASK			BIT(4)
+#define v_DRM_MASK(n)			(((n) & 0x01) << 4)
+
+#define FC_DBGFORCE			0x1200
+#define m_FC_FORCEAUDIO		BIT(4)
+#define v_FC_FORCEAUDIO(n)	(((n) & 0x01) << 4)
+#define m_FC_FORCEVIDEO		BIT(0)
+#define v_FC_FORCEVIDEO(n)	(((n) & 0x01) << 0)
+
+#define	FC_DBGAUD0CH0			0x1201	/* aud0~aud2 ch0 */
+#define	FC_DBGAUD0CH1			0x1204	/* aud0~aud2 ch1 */
+#define	FC_DBGAUD0CH2			0x1207	/* aud0~aud2 ch2 */
+#define	FC_DBGAUD0CH3			0x120a	/* aud0~aud2 ch3 */
+#define	FC_DBGAUD0CH4			0x120d	/* aud0~aud2 ch4 */
+#define	FC_DBGAUD0CH5			0x1210	/* aud0~aud2 ch5 */
+#define	FC_DBGAUD0CH6			0x1213	/* aud0~aud2 ch6 */
+#define	FC_DBGAUD0CH7			0x1216	/* aud0~aud2 ch7 */
+#define	FC_DBGTMDS0			0x1219
+#define	FC_DBGTMDS1			0x121a
+#define	FC_DBGTMDS2			0x121b
+
+/* HDMI Source PHY Registers */
+#define HDMI_SOURCE_PHY_BASE		0x3000
+
+#define PHY_CONF0			0x3000
+#define m_POWER_DOWN_EN		BIT(7)/* no use */
+#define v_POWER_DOWN_EN(n)	(((n) & 0x01) << 7)
+#define m_TMDS_EN		BIT(6)/* no use */
+#define v_TMDS_EN(n)		(((n) & 0x01) << 6)
+#define	m_SVSRET_SIG		BIT(5)/* depend on PHY_MHL_COMB0=1 */
+#define v_SVSRET_SIG(n)		(((n) & 0x01) << 5)
+#define m_PDDQ_SIG		BIT(4)
+/*1: power down phy; 0: power on phy */
+#define v_PDDQ_SIG(n)		(((n) & 0x01) << 4)
+#define m_TXPWRON_SIG		BIT(3)
+/*1: power on transmitter; 0: power down transmitter */
+#define v_TXPWRON_SIG(n)	(((n) & 0x01) << 3)
+#define m_ENHPD_RXSENSE_SIG	BIT(2)
+/*1: enable detect hdp & rx sense */
+#define v_ENHPD_RXSENSE_SIG(n)	(((n) & 0x01) << 2)
+#define m_SEL_DATAEN_POL	BIT(1)
+#define v_SEL_DATAEN_POL(n)	(((n) & 0x01) << 1)
+#define m_SEL_INTERFACE		BIT(0)
+#define v_SEL_INTERFACE(n)	(((n) & 0x01) << 0)
+
+#define PHY_TST0			0x3001
+#define m_TEST_CLR_SIG		BIT(5)
+#define m_TEST_EN_SIG		BIT(4)
+#define m_TEST_CLK_SIG		BIT(0)
+
+#define PHY_TST1			0x3002
+#define PHY_TST2			0x3003
+#define PHY_STAT0			0x3004
+#define PHY_INI0			0x3005
+#define PHY_MASK			0x3006
+#define PHY_POL0			0x3007
+#define m_PHY_RX_SENSE3		BIT(7)
+#define v_PHY_TX_SENSE3(n)	(((n) & 0x01) << 7)
+#define m_PHY_RX_SENSE2		BIT(6)
+#define v_PHY_TX_SENSE2(n)      (((n) & 0x01) << 6)
+#define m_PHY_RX_SENSE1		BIT(5)
+#define v_PHY_TX_SENSE1(n)      (((n) & 0x01) << 5)
+#define m_PHY_RX_SENSE0		BIT(4)
+#define v_PHY_TX_SENSE0(n)      (((n) & 0x01) << 4)
+#define m_PHY_HPD		BIT(1)
+#define v_PHY_HPD		(((n) & 0x01) << 1)
+#define m_PHY_LOCK		BIT(0)
+#define v_PHY_LOCK(n)		(((n) & 0x01) << 0)
+
+#define PHY_PCLFREQ0			0x3008
+#define PHY_PCLFREQ1			0x3009
+#define PHY_PLLCFGFREQ0			0x300a
+#define PHY_PLLCFGFREQ1			0x300b
+#define PHY_PLLCFGFREQ2			0x300c
+
+/* I2C Master PHY Registers */
+#define I2C_MASTER_PHY_BASE		0x3020
+
+#define	PHY_I2CM_SLAVE			0x3020
+#define PHY_GEN2_ADDR		0x69
+#define PHY_HEAC_ADDR		0x49
+#define PHY_I2C_SLAVE_ADDR	0x54
+
+#define	PHY_I2CM_ADDRESS		0x3021
+#define	PHY_I2CM_DATAO_1		0x3022
+#define	PHY_I2CM_DATAO_0		0x3023
+#define	PHY_I2CM_DATAI_1		0x3024
+#define	PHY_I2CM_DATAI_0		0x3025
+
+#define	PHY_I2CM_OPERATION		0x3026
+#define m_PHY_I2CM_WRITE	BIT(4)
+#define m_PHY_I2CM_READ		BIT(0)
+
+#define	PHY_I2CM_INT			0x3027
+#define m_PHY_I2CM_DONE_INT_POL	BIT(3)
+#define v_PHY_I2CM_DONE_INT_POL(n) (((n) & 0x01) << 3)
+#define m_PHY_I2CM_DONE_MASK	BIT(2)
+#define v_PHY_I2CM_DONE_MASK(n)	(((n) & 0x01) << 2)
+#define m_PHY_I2CM_DONE_INT	BIT(1)
+#define m_PHY_I2CM_DONE_STATUS	BIT(0)
+
+#define	PHY_I2CM_CTLINT			0x3028
+#define m_PHY_I2CM_NACK_POL	BIT(7)
+#define v_PHY_I2CM_NACK_POL(n)	(((n) & 0x01) << 7)
+#define m_PHY_I2CM_NACK_MASK	BIT(6)
+#define v_PHY_I2CM_NACK_MASK(n)	(((n) & 0x01) << 6)
+#define m_PHY_I2CM_NACK_INT	BIT(5)
+#define m_PHY_I2CM_NACK_STATUS	BIT(4)
+#define m_PHY_I2CM_ARB_POL	BIT(3)
+#define v_PHY_I2CM_ARB_POL(n)	(((n) & 0x01) << 3)
+#define m_PHY_I2CM_ARB_MASK	BIT(2)
+#define v_PHY_I2CM_ARB_MASK(n)	(((n) & 0x01) << 2)
+#define m_PHY_I2CM_ARB_INT	BIT(1)
+#define m_PHY_I2CM_ARB_STATUS	BIT(0)
+
+#define	PHY_I2CM_DIV			0x3029
+#define m_PHY_I2CM_FAST_STD	BIT(3)
+#define v_PHY_I2CM_FAST_STD(n)	(((n) & 0x01) << 3)
+
+#define	PHY_I2CM_SOFTRSTZ		0x302a
+#define m_PHY_I2CM_SOFTRST	BIT(0)
+#define v_PHY_I2CM_SOFTRST(n)	(((n) & 0x01) << 0)
+
+#define	PHY_I2CM_SS_SCL_HCNT_1_ADDR	0x302b
+#define	PHY_I2CM_SS_SCL_HCNT_0_ADDR	0x302c
+#define	PHY_I2CM_SS_SCL_LCNT_1_ADDR	0x302d
+#define	PHY_I2CM_SS_SCL_LCNT_0_ADDR	0x302e
+#define	PHY_I2CM_FS_SCL_HCNT_1_ADDR	0x302f
+#define	PHY_I2CM_FS_SCL_HCNT_0_ADDR	0x3030
+#define	PHY_I2CM_FS_SCL_LCNT_1_ADDR	0x3031
+#define	PHY_I2CM_FS_SCL_LCNT_0_ADDR	0x3032
+#define	PHY_I2CM_SDA_HOLD		0x3033
+
+/* Audio Sampler Registers */
+#define AUDIO_SAMPLER_BASE		0x3100
+
+#define AUD_CONF0			0x3100
+#define m_SW_AUD_FIFO_RST	BIT(7)
+#define v_SW_AUD_FIFO_RST(n)	(((n) & 0x01) << 7)
+enum {
+	AUDIO_SPDIF_GPA = 0,
+	AUDIO_I2S
+};
+
+#define m_I2S_SEL		BIT(5)
+#define v_I2S_SEL(n)		(((n) & 0x01) << 5)
+enum {
+	I2S_CHANNEL_1_2 = 1,
+	I2S_CHANNEL_3_4 = 3,
+	I2S_CHANNEL_5_6 = 7,
+	I2S_CHANNEL_7_8 = 0xf
+};
+
+#define m_I2S_IN_EN		(0x0f << 0)
+#define v_I2S_IN_EN(n)		(((n) & 0x0f) << 0)
+
+#define AUD_CONF1			0x3101
+enum I2S_MODE {
+	I2S_STANDARD_MODE = 0,
+	I2S_RIGHT_JUSTIFIED_MODE,
+	I2S_LEFT_JUSTIFIED_MODE,
+	I2S_BURST_1_MODE,
+	I2S_BURST_2_MODE
+};
+
+#define m_I2S_MODE		(0x07 << 5)
+#define v_I2S_MODE(n)		(((n) & 0x07) << 5)
+enum I2S_WIDTH {
+	I2S_16BIT_SAMPLE = 16,
+	I2S_17BIT_SAMPLE,
+	I2S_18BIT_SAMPLE,
+	I2S_19BIT_SAMPLE,
+	I2S_20BIT_SAMPLE,
+	I2S_21BIT_SAMPLE,
+	I2S_22BIT_SAMPLE,
+	I2S_23BIT_SAMPLE,
+	I2S_24BIT_SAMPLE,
+};
+
+#define m_I2S_WIDTH		(0x1f << 0)
+#define v_I2S_WIDTH(n)		(((n) & 0x1f) << 0)
+
+#define AUD_INT				0x3102
+#define AUD_SPDIFINT			0x3302
+#define m_FIFO_EMPTY_MASK	BIT(3)
+#define v_FIFO_EMPTY_MASK(n)	(((n) & 0x01) << 3)
+#define m_FIFO_FULL_MASK	BIT(2)
+#define v_FIFO_FULL_MASK(n)	(((n) & 0x01) << 2)
+
+#define AUD_CONF2			0x3103
+#define m_NLPCM_EN		BIT(1)
+#define v_NLPCM_EN(n)		(((n) & 0x01) << 1)
+#define m_HBR_EN		BIT(0)
+#define v_HBR_EN(n)		(((n) & 0x01) << 0)
+
+#define AUD_INT1			0x3104
+#define AUD_SPDIFINT1			0x3303
+#define m_FIFO_OVERRUN_MASK	BIT(4)
+#define v_FIFO_OVERRUN_MASK(n)	(((n) & 0x01) << 4)
+
+/***************N-CTS Table**************/
+/*	TMDS LOWCLK:	<=148.5M	*/
+/*	TMDS MIDCLK:	297M		*/
+/*	TMDS HIGHCLK:	594M		*/
+#define N_32K_LOWCLK		0x1000
+#define N_32K_MIDCLK		0x0c00
+#define N_32K_HIGHCLK		0x0c00
+#define N_441K_LOWCLK		0x1880
+#define N_441K_MIDCLK		0x1260
+#define N_441K_HIGHCLK		0x24c0
+#define N_48K_LOWCLK		0x1800
+#define N_48K_MIDCLK		0x1400
+#define N_48K_HIGHCLK		0x1800
+#define N_882K_LOWCLK		0x3100
+#define N_882K_MIDCLK		0x24c0
+#define N_882K_HIGHCLK		0x4980
+#define N_96K_LOWCLK		0x3000
+#define N_96K_MIDCLK		0x2800
+#define N_96K_HIGHCLK		0x3000
+#define N_1764K_LOWCLK		0x6200
+#define N_1764K_MIDCLK		0x4980
+#define N_1764K_HIGHCLK		0x9300
+#define N_192K_LOWCLK		0x6000
+#define N_192K_MIDCLK		0x5000
+#define N_192K_HIGHCLK		0x6000
+
+#define CALC_CTS(N, TMDSCLK, FS)	(((N) / 32) * (TMDSCLK) / ((FS) * 4))
+/****************************************/
+
+#define AUD_N1				0x3200
+#define AUD_N2				0x3201
+
+#define AUD_N3				0x3202
+#define m_NCTS_ATOMIC_WR	BIT(7)
+#define v_NCTS_ATOMIC_WR(n)	(((n) & 0x01) << 7)
+#define m_AUD_N3		(0x0f << 0)
+#define v_AUD_N3(n)		(((n) & 0x0f) << 0)
+
+#define AUD_CTS1			0x3203
+#define AUD_CTS2			0x3204
+
+#define AUD_CTS3			0x3205
+enum {
+	N_SHIFT_1 = 0,
+	N_SHIFT_16,
+	N_SHIFT_32,
+	N_SHIFT_64,
+	N_SHIFT_128,
+	N_SHIFT_256,
+	N_SHIFT_OTHERS_128
+};
+
+#define m_N_SHIFT		(0x07 << 5)
+#define v_N_SHIFT(n)		(((n) & 0x07) << 5)
+#define m_CTS_MANUAL		BIT(4)
+#define v_CTS_MANUAL(n)		(((n) & 0x01) << 4)
+#define m_AUD_CTS3		(0x0f << 0)
+#define v_AUD_CTS3(n)		(((n) & 0x0f) << 0)
+
+#define AUD_INPUTCLKFS			0x3206
+enum {
+	FS_128 = 0,
+	FS_256,
+	FS_512,
+	FS_64 = 4,
+	FS_OTHERS_128
+};
+
+#define m_LFS_FACTOR		(0x07 << 0)
+#define v_LFS_FACTOR(n)		(((n) & 0x07) << 0)
+
+#define AUD_SPDIF0			0x3300
+#define m_SW_SAUD_FIFO_RST	BIT(7)
+#define v_SW_SAUD_FIFO_RST(n)	(((n) & 0x01) << 7)
+
+#define AUD_SPDIF1			0x3301
+enum {
+	PCM_LINEAR = 0,
+	PCM_NONLINEAR
+};
+
+#define m_SET_NLPCM		BIT(7)
+#define v_SET_NLPCM(n)		(((n) & 0x01) << 7)
+#define m_SPDIF_HBR_MODE	BIT(6)
+#define v_SPDIF_HBR_MODE(n)	(((n) & 0x01) << 6)
+#define m_SPDIF_WIDTH		(0x1f << 0)
+#define v_SPDIF_WIDTH(n)	(((n) & 0x1f) << 0)
+
+/* Generic Parallel Audio Interface Registers */
+#define GP_AUDIO_INTERFACE_BASE		0x3500
+
+#define	GP_CONF0			0x3500
+#define	GP_CONF1			0x3501
+#define	GP_CONF2			0x3502
+#define	GP_MASK				0x3506
+
+/* Audio DMA Registers */
+#define AUDIO_DMA_BASE			0x3600
+
+#define	AHB_DMA_CONF0			0x3600
+#define	AHB_DMA_START			0x3601
+#define	AHB_DMA_STOP			0x3602
+#define	AHB_DMA_THRSLD			0x3603
+#define	AHB_DMA_STRADDR_SET0_0		0x3604	/* 0~3 */
+#define	AHB_DMA_STPADDR_SET0_0		0x3608	/* 0~3 */
+#define	AHB_DMA_BSTADDR0		0x360c	/* 0~3 */
+#define	AHB_DMA_MBLENGTH0		0x3610	/* 0~3 */
+#define	AHB_DMA_MASK			0x3614
+#define	AHB_DMA_CONF1			0x3616
+#define	AHB_DMA_BUFFMASK		0x3619
+#define	AHB_DMA_MASK1			0x361b
+#define	AHB_DMA_STATUS			0x361c
+#define	AHB_DMA_CONF2			0x361d
+#define	AHB_DMA_STRADDR_SET1_0		0x3620	/* 0~3 */
+#define	AHB_DMA_STPADDR_SET1_0		0x3624	/* 0~3 */
+
+/* Main Controller Registers */
+#define MAIN_CONTROLLER_BASE		0x4000
+
+#define MC_CLKDIS			0x4001
+#define m_HDCPCLK_DISABLE	BIT(6)
+#define v_HDCPCLK_DISABLE(n)	(((n) & 0x01) << 6)
+#define m_CECCLK_DISABLE	BIT(5)
+#define v_CECCLK_DISABLE(n)	(((n) & 0x01) << 5)
+#define m_CSCCLK_DISABLE	BIT(4)
+#define v_CSCCLK_DISABLE(n)	(((n) & 0x01) << 4)
+#define m_AUDCLK_DISABLE        BIT(3)
+#define v_AUDCLK_DISABLE(n)     (((n) & 0x01) << 3)
+#define m_PREPCLK_DISABLE	BIT(2)
+#define v_PREPCLK_DISABLE(n)	(((n) & 0x01) << 2)
+#define m_TMDSCLK_DISABLE	BIT(1)
+#define v_TMDSCLK_DISABLE(n)	(((n) & 0x01) << 1)
+#define m_PIXELCLK_DISABLE	BIT(0)
+#define v_PIXELCLK_DISABLE(n)	(((n) & 0x01) << 0)
+
+#define MC_SWRSTZREQ			0x4002
+#define m_IGPA_SWRST		BIT(7)
+#define v_IGPA_SWRST(n)		(((n) & 0x01) << 7)
+#define m_CEC_SWRST		BIT(6)
+#define v_CEC_SWRST(n)		(((n) & 0x01) << 6)
+#define m_ISPDIF_SWRST          BIT(4)
+#define v_ISPDIF_SWRST(n)       (((n) & 0x01) << 4)
+#define m_II2S_SWRST            BIT(3)
+#define v_II2S_SWRST(n)         (((n) & 0x01) << 3)
+#define m_PREP_SWRST            BIT(2)
+#define v_PREP_SWRST(n)         (((n) & 0x01) << 2)
+#define m_TMDS_SWRST		BIT(1)
+#define v_TMDS_SWRST(n)		(((n) & 0x01) << 1)
+#define m_PIXEL_SWRST           BIT(0)
+#define v_PIXEL_SWRST(n)        (((n) & 0x01) << 0)
+
+#define MC_OPCTRL			0x4003
+#define m_HDCP_BLOCK_BYP	BIT(0)
+#define v_HDCP_BLOCK_BYP(n)	(((n) & 0x01) << 0)
+
+#define MC_FLOWCTRL			0x4004
+#define m_FEED_THROUGH_OFF      BIT(0)
+#define v_FEED_THROUGH_OFF(n)   (((n) & 0x01) << 0)
+
+#define MC_PHYRSTZ			0x4005
+#define m_PHY_RSTZ		BIT(0)
+#define v_PHY_RSTZ(n)		(((n) & 0x01) << 0)
+
+#define MC_LOCKONCLOCK			0x4006
+#define m_IGPACLK_ON		BIT(7)
+#define v_IGPACLK_ON(n)		(((n) & 0x01) << 7)
+#define m_PCLK_ON		BIT(6)
+#define v_PCLK_ON(n)		(((n) & 0x01) << 6)
+#define m_TMDSCLK_ON            BIT(5)
+#define v_TMDSCLK_ON(n)         (((n) & 0x01) << 5)
+#define m_PREPCLK_ON            BIT(4)
+#define v_PREPCLK_ON(n)         (((n) & 0x01) << 4)
+#define m_I2SCLK_ON		BIT(3)
+#define v_I2SCLK_ON(n)		(((n) & 0x01) << 3)
+#define m_SPDIFCLK_ON           BIT(2)
+#define v_SPDIFCLK_ON(n)	(((n) & 0x01) << 2)
+#define m_CECCLK_ON		BIT(0)
+#define v_CECCLK_ON(n)		(((n) & 0x01) << 0)
+
+#define MC_HEACPHY_RST			0x4007
+#define m_HEAC_PHY_RST		BIT(0)
+#define v_HEAC_PHY_RST(n)	(((n) & 0x01) << 0)
+
+#define MC_LOCKONCLOCK_2		0x4009
+#define m_AHB_AUD_DMA_CLK       BIT(0)
+#define v_AHB_AUD_DMA_CLK(n)    (((n) & 0x01) << 0)
+
+#define MC_SWRSTZREQ_2			0x400a
+#define m_AHB_AUD_DMA_RST       BIT(7)
+#define v_AHB_AUD_DMA_RST(n)    (((n) & 0x01) << 7)
+
+/* Color Space Converter Registers */
+#define COLOR_SPACE_CONVERTER_BASE	0x4100
+
+#define	CSC_CFG				0x4100
+#define m_CSC_INTPMODE		(0x03 << 4)
+#define v_CSC_INTPMODE(n)	(((n) & 0x03) << 4)
+#define m_CSC_DECIMODE		(0x03 << 0)
+#define v_CSC_DECIMODE(n)	(((n) & 0x03) << 0)
+
+#define	CSC_SCALE			0x4101
+#define m_CSC_COLOR_DEPTH	(0x0f << 4)
+#define v_CSC_COLOR_DEPTH(n)	(((n) & 0x0f) << 4)
+#define m_CSC_SCALE		(0x03 << 0)
+#define v_CSC_SCALE(n)		(((n) & 0x03) << 0)
+
+#define	CSC_COEF_A1_MSB			0x4102
+#define	CSC_COEF_A1_LSB			0x4103
+#define	CSC_COEF_A2_MSB			0x4104
+#define	CSC_COEF_A2_LSB			0x4105
+#define	CSC_COEF_A3_MSB			0x4106
+#define	CSC_COEF_A3_LSB			0x4107
+#define	CSC_COEF_A4_MSB			0x4108
+#define	CSC_COEF_A4_LSB			0x4109
+#define	CSC_COEF_B1_MSB			0x410a
+#define	CSC_COEF_B1_LSB			0x410b
+#define	CSC_COEF_B2_MSB			0x410c
+#define	CSC_COEF_B2_LSB			0x410d
+#define	CSC_COEF_B3_MSB			0x410e
+#define	CSC_COEF_B3_LSB			0x410f
+#define	CSC_COEF_B4_MSB			0x4110
+#define	CSC_COEF_B4_LSB			0x4111
+#define	CSC_COEF_C1_MSB			0x4112
+#define	CSC_COEF_C1_LSB			0x4113
+#define	CSC_COEF_C2_MSB			0x4114
+#define	CSC_COEF_C2_LSB			0x4115
+#define	CSC_COEF_C3_MSB			0x4116
+#define	CSC_COEF_C3_LSB			0x4117
+#define	CSC_COEF_C4_MSB			0x4118
+#define	CSC_COEF_C4_LSB			0x4119
+#define	CSC_SPARE_1			0x411a
+#define	CSC_SPARE_2			0x411b
+
+/* HDCP Encryption Engine Registers */
+#define HDCP_ENCRYPTION_ENGINE_BASE	0x5000
+
+#define	A_HDCPCFG0			0x5000
+#define m_HDCP_ENHANCE_LIKE	BIT(7)
+#define v_HDCP_ENHANCE_LIKE(n)	(((n) & 0x01) << 7)
+#define m_I2C_FAST_MODE		BIT(6)
+#define v_I2C_FAST_MODE(n)	(((n) & 0x01) << 6)
+#define m_ENCRYPT_BYPASS	BIT(5)
+#define v_ENCRYPT_BYPASS(n)	(((n) & 0x01) << 5)
+#define m_SYNC_RI_CHECK		BIT(4)
+#define v_SYNC_RI_CHECK(n)	(((n) & 0x01) << 4)
+#define m_AVMUTE		BIT(3)
+#define m_RX_DETECT		BIT(2)
+#define v_RX_DETECT(n)		(((n) & 0x01) << 2)
+#define m_FEATURE11_EN		BIT(1)
+#define v_FEATURE11_EN(n)	(((n) & 0x01) << 1)
+#define m_HDMI_DVI		BIT(0)
+#define v_HDMI_DVI(n)		(((n) & 0x01) << 0)
+
+#define	A_HDCPCFG1			0x5001
+#define m_HDCP_LOCK		BIT(4)
+#define v_HDCP_LOCK(n)		(((n) & 0x01) << 4)
+#define m_SHA1_CHECK_DISABLE	BIT(3)
+#define v_SHA1_CHECK_DISBALE(n)	(((n) & 0x01) << 3)
+#define m_PH2UPSHFTENC		BIT(2)
+#define v_PH2UPSHFTENC(n)	(((n) & 0x01) << 2)
+#define m_ENCRYPT_DISBALE	BIT(1)
+#define v_ENCRYPT_DISBALE(n)	(((n) & 0x01) << 1)
+#define m_HDCP_SW_RST		BIT(0)
+#define v_HDCP_SW_RST(n)	(((n) & 0x01) << 0)
+
+#define	A_HDCPOBS0			0x5002
+#define m_STATE_AUTH		(0x0f << 4)
+#define m_SUB_STATE_AUTH	(0x07 << 1)
+#define m_STATE_HDCP_ENGAGED	BIT(0)
+
+#define	A_HDCPOBS1			0x5003
+#define m_STATE_OESS		(0x07 << 3)
+#define m_STATE_REVO		(0x07 << 0)
+
+#define	A_HDCPOBS2			0x5004
+#define m_STATE_CIPHER		(0x07 << 3)
+#define m_STATE_EESS		(0x07 << 0)
+
+#define	A_HDCPOBS3			0x5005
+#define m_BCAP_REPEATER		BIT(6)
+#define m_BCAP_KSVFIFO_READY	BIT(5)
+#define m_BCAP_FAST_I2C		BIT(4)
+#define m_BCAP_HDMI_MODE	BIT(2)
+#define m_BCAP_FEATURES11	BIT(1)
+#define m_BCAP_FAST_REAUTH	BIT(0)
+
+#define	A_APIINTCLR			0x5006
+#define	A_APIINTSTAT			0x5007
+#define	A_APIINTMSK			0x5008
+#define m_HDCP_ENGAGED		BIT(7)
+#define m_HDCP_FAILED		BIT(6)
+#define m_HDCP_I2C_NOACK	BIT(4)
+#define m_HDCP_LOST_ARBI	BIT(3)
+#define m_KEEP_ERR_INT		BIT(2)
+#define m_KSVSHA1_CALC_INT	BIT(1)
+#define m_KSV_ACCESS_INT	BIT(0)
+#define v_HDCP_ENGAGED(n)	(((n) & 0x01) << 7)
+#define v_HDCP_FAILED(n)	(((n) & 0x01) << 6)
+#define v_HDCP_I2C_NOACK(n)	(((n) & 0x01) << 4)
+#define v_HDCP_LOST_ARBI(n)	(((n) & 0x01) << 3)
+#define v_KEEP_ERR_INT(n)	(((n) & 0x01) << 1)
+#define v_KSVSHA1_CALC_INT(n)	(((n) & 0x01) << 1)
+#define v_KSV_ACCESS_INT(n)	(((n) & 0x01) << 0)
+
+#define	A_VIDPOLCFG			0x5009
+#define m_UNENCRYT_CONF		(0x03 << 5)
+#define v_UNENCRYT_CONF(n)	(((n) & 0x03) << 5)
+#define m_DATAEN_POL		BIT(4)
+#define v_DATAEN_POL(n)		(((n) & 0x01) << 4)
+#define m_VSYNC_POL		BIT(3)
+#define v_VSYNC_POL(n)		(((n) & 0x01) << 3)
+#define m_HSYNC_POL		BIT(1)
+#define v_HSYNC_POL(n)		(((n) & 0x01) << 1)
+
+#define	A_OESSWCFG			0x500a
+#define	A_COREVERLSB			0x5014
+#define	A_COREVERMSB			0x5015
+
+#define	A_KSVMEMCTRL			0x5016
+#define m_SHA1_FAIL		BIT(3)
+#define v_SHA1_FAIL(n)		(((n) & 0x01) << 3)
+#define m_KSV_UPDATE		BIT(2)
+#define v_KSV_UPDATE(n)		(((n) & 0x01) << 2)
+#define m_KSV_MEM_ACCESS	BIT(1)
+#define m_KSV_MEM_REQ		BIT(0)
+#define v_KSV_MEM_REQ(n)	(((n) & 0x01) << 0)
+
+#define	HDCP_BSTATUS_0			0x5020
+#define m_MAX_DEVS_EXCEEDED	BIT(7)
+#define m_DEVICE_COUNT		(0x7f << 0)
+
+#define	HDCP_BSTATUS_1			0x5021
+#define	HDCP_M0_0			0x5022
+#define	HDCP_M0_1			0x5023
+#define	HDCP_M0_2			0x5024
+#define	HDCP_M0_3			0x5025
+#define	HDCP_M0_4			0x5026
+#define	HDCP_M0_5			0x5027
+#define	HDCP_M0_6			0x5028
+#define	HDCP_M0_7			0x5029
+#define	HDCP_KSV			0x502a	/* 0~634 */
+#define	HDCP_VH				0x52a5	/* 0~19 */
+#define	HDCP_REVOC_SIZE_0		0x52b9
+#define	HDCP_REVOC_SIZE_1		0x52ba
+#define	HDCP_REVOC_LIST			0x52bb	/* 0~5059 */
+
+/* HDCP BKSV Registers */
+#define HDCP_BKSV_BASE			0x7800
+
+#define	HDCPREG_BKSV0			0x7800
+#define	HDCPREG_BKSV1			0x7801
+#define	HDCPREG_BKSV2			0x7802
+#define	HDCPREG_BKSV3			0x7803
+#define	HDCPREG_BKSV4			0x7804
+
+/* HDCP AN Registers */
+#define HDCP_AN_BASE			0x7805
+
+#define	HDCPREG_ANCONF			0x7805
+#define m_OAN_BYPASS		BIT(0)
+#define v_OAN_BYPASS(n)		(((n) & 0x01) << 0)
+
+#define	HDCPREG_AN0			0x7806
+#define	HDCPREG_AN1			0x7807
+#define	HDCPREG_AN2			0x7808
+#define	HDCPREG_AN3			0x7809
+#define	HDCPREG_AN4			0x780a
+#define	HDCPREG_AN5			0x780b
+#define	HDCPREG_AN6			0x780c
+#define	HDCPREG_AN7			0x780d
+
+/* Encrypted DPK Embedded Storage Registers */
+#define ENCRYPTED_DPK_EMBEDDED_BASE	0x780e
+
+#define	HDCPREG_RMCTL			0x780e
+#define m_DPK_DECRYPT_EN	BIT(0)
+#define v_DPK_DECRYPT_EN(n)	(((n) & 0x01) << 0)
+
+#define	HDCPREG_RMSTS			0x780f
+#define m_DPK_WR_OK_STS		BIT(6)
+#define m_DPK_DATA_INDEX	(0x3f << 6)
+
+#define	HDCPREG_SEED0			0x7810
+#define	HDCPREG_SEED1			0x7811
+#define	HDCPREG_DPK0			0x7812
+#define	HDCPREG_DPK1			0x7813
+#define	HDCPREG_DPK2			0x7814
+#define	HDCPREG_DPK3			0x7815
+#define	HDCPREG_DPK4			0x7816
+#define	HDCPREG_DPK5			0x7817
+#define	HDCPREG_DPK6			0x7818
+
+#define HDCP2REG_BASE			0x7900
+#define HDCP2REG_ID			0x7900
+#define HDCP2REG_CTRL			0x7904
+	#define m_HDCP2_HDP_OVR_VAL	BIT(5)
+	#define m_HDCP2_HDP_OVR_EN	BIT(4)
+	#define m_HDCP2_FORCE		BIT(2)
+	#define m_HDCP2_OVR_EN		BIT(1)
+	#define m_HDCP2_SWITCH_EN	BIT(0)
+
+	#define v_HDCP2_HDP_OVR_VAL(n)	(((n) & 0x01) << 5)
+	#define v_HDCP2_HDP_OVR_EN(n)	(((n) & 0x01) << 4)
+	#define v_HDCP2_FORCE(n)	(((n) & 0x01) << 2)
+	#define v_HDCP2_OVR_EN(n)	(((n) & 0x01) << 1)
+	#define v_HDCP2_SWITCH_EN(n)	(((n) & 0x01) << 0)
+#define HDCP2REG_CTRL1			0x7905
+	#define m_HDCP2_CD_VAL		(0xf << 4)
+	#define m_HDCP2_CD_EN		BIT(3)
+	#define m_HDCP2_AVMUTE_OVR_VAL	BIT(1)
+	#define m_HDCP2_AVMUTE_OVR_EN	BIT(0)
+
+	#define v_HDCP2_CD_VAL(n)		(((n) & 0x0f) << 4)
+	#define v_HDCP2_CD_EN(n)		(((n) & 0x01) << 3)
+	#define v_HDCP2_AVMUTE_OVR_VAL(n)	(((n) & 0x01) << 1)
+	#define v_HDCP2_AVMUTE_OVR_EN(n)	(((n) & 0x01) << 0)
+#define HDCP2REG_STAS			0x7908
+#define HDCP2REG_MASK			0x790c
+#define HDCP2REG_STAT			0x790d
+#define HDCP2REG_MUTE			0x790e
+	#define m_HDCP2_CAPABLE		BIT(0)
+	#define m_HDCP2_NOTCAPABLE	BIT(1)
+	#define m_HDCP2_AUTH_LOST	BIT(2)
+	#define m_HDCP2_AUTH_OK		BIT(3)
+	#define m_HDCP2_AUTH_FAIL	BIT(4)
+	#define m_HDCP2_DECRYPTED_CHG	BIT(5)
+
+/* CEC Engine Registers */
+#define CEC_ENGINE_BASE			0x7d00
+
+#define	CEC_CTRL			0x7d00
+	#define m_CEC_BC_S_NCK		BIT(5)	 /* Ignore ack of sending
+						  * broadcast message.
+						  */
+	#define m_CEC_STANBY		BIT(4)
+	#define m_CEC_BC_NCK		BIT(3)
+	#define m_CEC_FRAME_TYPE	(3 << 1)
+	#define m_CEC_SEND		BIT(0)
+	#define v_CEC_BC_S_NCK(n)	(((n) & 0x1) << 4)
+	#define v_CEC_STANBY(n)		((n & 0x1) << 4)
+	#define v_CEC_BC_NCK(n)		((n & 0x1) << 3)
+	#define v_CEC_FRAME_TYPE(n)	((n & 0x3) << 1)
+	#define v_CEC_SEND(n)		(n & 0x1)
+#define	CEC_MASK			0x7d02
+#define	CEC_ADDR_L			0x7d05
+#define	CEC_ADDR_H			0x7d06
+#define	CEC_TX_CNT			0x7d07
+#define	CEC_RX_CNT			0x7d08
+#define	CEC_TX_DATA0			0x7d10	/* txdata0~txdata15 */
+#define	CEC_RX_DATA0			0x7d20	/* rxdata0~rxdata15 */
+#define CEC_LOCK			0x7d30
+#define	CEC_WKUPCTRL			0x7d31
+
+/* I2C Master Registers */
+#define I2C_MASTER_BASE			0x7e00
+
+#define	I2CM_SLAVE			0x7e00
+#define	I2CM_ADDRESS			0x7e01
+#define	I2CM_DATAO			0x7e02
+#define	I2CM_DATAI			0x7e03
+
+#define I2CM_OPERATION			0x7e04
+#define m_I2CM_WR		BIT(4)
+#define v_I2CM_WR(n)		(((n) & 0x01) << 4)
+#define m_I2CM_RD8_EXT		BIT(3)
+#define v_I2CM_RD8_EXT(n)	(((n) & 0x01) << 3)
+#define m_I2CM_RD8		BIT(2)
+#define v_I2CM_RD8(n)		(((n) & 0x01) << 2)
+#define m_I2CM_RD_EXT		BIT(1)
+#define v_I2CM_RD_EXT(n)	(((n) & 0x01) << 1)
+#define m_I2CM_RD		BIT(0)
+#define v_I2CM_RD(n)		(((n) & 0x01) << 0)
+
+#define	I2CM_INT			0x7e05
+#define m_I2CM_RD_REQ_MASK	BIT(6)
+#define v_I2CM_RD_REQ_MASK(n)	(((n) & 0x01) << 6)
+#define m_I2CM_DONE_MASK	BIT(2)
+#define v_I2CM_DONE_MASK(n)	(((n) & 0x01) << 2)
+
+#define	I2CM_CTLINT			0x7e06
+#define m_I2CM_NACK_MASK	BIT(6)
+#define v_I2CM_NACK_MASK(n)	(((n) & 0x01) << 6)
+#define m_I2CM_ARB_MASK		BIT(2)
+#define v_I2CM_ARB_MASK(n)	(((n) & 0x01) << 2)
+
+#define	I2CM_DIV			0x7e07
+enum {
+	STANDARD_MODE = 0,
+	FAST_MODE
+};
+
+#define m_I2CM_FAST_STD_MODE	BIT(3)
+#define v_I2CM_FAST_STD_MODE(n)	(((n) & 0x01) << 3)
+
+#define	I2CM_SEGADDR			0x7e08
+#define m_I2CM_SEG_ADDR		(0x7f << 0)
+#define v_I2CM_SEG_ADDR(n)	(((n) & 0x7f) << 0)
+
+#define	I2CM_SOFTRSTZ			0x7e09
+#define m_I2CM_SOFTRST		BIT(0)
+#define v_I2CM_SOFTRST(n)	(((n) & 0x01) << 0)
+
+#define	I2CM_SEGPTR			0x7e0a
+#define	I2CM_SS_SCL_HCNT_1_ADDR		0x7e0b
+#define	I2CM_SS_SCL_HCNT_0_ADDR		0x7e0c
+#define	I2CM_SS_SCL_LCNT_1_ADDR		0x7e0d
+#define	I2CM_SS_SCL_LCNT_0_ADDR		0x7e0e
+#define	I2CM_FS_SCL_HCNT_1_ADDR		0x7e0f
+#define	I2CM_FS_SCL_HCNT_0_ADDR		0x7e10
+#define	I2CM_FS_SCL_LCNT_1_ADDR		0x7e11
+#define	I2CM_FS_SCL_LCNT_0_ADDR		0x7e12
+#define	I2CM_SDA_HOLD			0x7e13
+
+#define	I2CM_SCDC_READ_UPDATE		0x7e14
+#define m_I2CM_UPRD_VSYNC_EN	BIT(5)
+#define v_I2CM_UPRD_VSYNC_EN(n) (((n) & 0x01) << 5)
+#define m_I2CM_READ_REQ_EN	BIT(4)
+#define v_I2CM_READ_REQ_EN(n)	(((n) & 0x01) << 4)
+#define m_I2CM_READ_UPDATE	BIT(0)
+#define v_I2CM_READ_UPDATE(n)	(((n) & 0x01) << 0)
+
+#define	I2CM_READ_BUFF0			0x7e20	/* buff0~buff7 */
+#define	I2CM_SCDC_UPDATE0		0x7e30
+#define	I2CM_SCDC_UPDATE1		0x7e31
+
+/*
+* HDMI TX PHY Define Start
+*/
+#define PHYTX_OPMODE_PLLCFG		0x06
+enum {
+	PREP_DIV_BY_2 = 0,	/* 16 bits */
+	PREP_DIV_BY_15,		/* 12 bits */
+	PREP_DIV_BY_125,	/* 10 bits */
+	PREP_DIV_BY_1,		/* 8 bits */
+};
+
+#define m_PREP_DIV		(0x03 << 13)
+#define v_PREP_DIV(n)		(((n) & 0x03) << 13)
+enum {
+	TMDS_DIV_BY_1 = 0,
+	TMDS_DIV_NOT_USED,
+	TMDS_DIV_BY_3,
+	TMDS_DIV_BY_4,
+};
+
+#define m_TMDS_CNTRL		(0x03 << 11)
+#define v_TMDS_CNTRL(n)		(((n) & 0x03) << 11)
+enum OPMODE {
+	OP_HDMI_14 = 0,
+	OP_HDMI_20,
+};
+
+#define m_OPMODE		(0x03 << 9)
+#define v_OPMODE(n)		(((n) & 0x03) << 9)
+enum {
+	FBDIV2_BY_1 = 1,
+	FBDIV2_BY_2,
+	FBDIV2_BY_3,
+	FBDIV2_BY_4,
+	FBDIV2_BY_5,
+	FBDIV2_BY_6,
+};
+
+#define m_FBDIV2_CNTRL		(0x07 << 6)
+#define v_FBDIV2_CNTRL(n)	(((n) & 0x07) << 6)
+enum {
+	FBDIV1_BY_1 = 0,
+	FBDIV1_BY_2,
+	FBDIV1_BY_3,
+	FBDIV1_BY_4,
+};
+
+#define m_FBDIV1_CNTRL		(0x03 << 4)
+#define v_FBDIV1_CNTRL(n)	(((n) & 0x03) << 4)
+enum {
+	REF_DIV_BY_1 = 0,
+	REF_DIV_BY_2,
+	REF_DIV_NOT_USED,
+	REF_DIV_BY_4,
+};
+
+#define m_REF_CNTRL		(0x03 << 2)
+#define v_REF_CNTRL(n)		(((n) & 0x03) << 2)
+#define m_MPLL_N_CNTRL		(0x03 << 0)
+#define v_MPLL_N_CNTRL(n)	(((n) & 0x03) << 0)
+
+#define PHYTX_CLKSYMCTRL		0x09
+#define v_OVERRIDE(n)		(0x01 << 15)
+#define m_SLOPEBOOST		(0x03 << 4)
+#define v_SLOPEBOOST(n)		(((n) & 0x03) << 4)
+#define m_TX_SYMON		(0x01 << 3)
+#define v_TX_SYMON(n)		(((n) & 0x01) << 3)
+#define m_PREEMPHASIS		(0x03 << 1)
+#define v_PREEMPHASIS(n)	(((n) & 0x03) << 1)
+#define m_CLK_SYMON		(0x01 << 0)
+#define v_CLK_SYMON(n)		(((n) & 0x01) << 0)
+
+#define PHYTX_VLEVCTRL			0x0e
+#define m_SUP_TXLVL		(0x1f << 5)
+#define v_SUP_TXLVL(n)		(((n) & 0x1f) << 5)
+#define m_SUP_CLKLVL		(0x1f << 0)
+#define v_SUP_CLKLVL(n)		(((n) & 0x1f) << 0)
+
+#define PHYTX_PLLCURRCTRL		0x10
+#define m_MPLL_PROP_CNTRL	(0x07 << 3)
+#define v_MPLL_PROP_CNTRL(n)	(((n) & 0x07) << 3)
+#define m_MPLL_INT_CNTRL	(0x07 << 0)
+#define v_MPLL_INT_CNTRL(n)	(((n) & 0x07) << 0)
+
+#define PHYTX_PLLGMPCTRL		0x15
+#define m_MPLL_GMP_CNTRL	(0x03 << 0)
+#define v_MPLL_GMP_CNTRL(n)	(((n) & 0x03) << 0)
+
+enum TERM_RESIS {
+	R50_OHMS = 0,
+	R5714_OHMS,
+	R6667_OHMS,
+	R80_OHMS,
+	R100_OHMS,
+	R13333_OHMS,
+	R200_OHMS,
+	ROPEN_CIRCUIT,
+};
+
+#define PHYTX_TERM_RESIS		0x19
+#define m_TX_TERM		(0x07 << 0)
+#define v_TX_TERM(n)		(((n) & 0x07) << 0)
+
+struct phy_mpll_config_tab {
+	u32 pix_clock;
+	u32 tmdsclock;
+	u8 pix_repet;
+	u8 color_depth;
+	u16 prep_div;
+	u16 tmdsmhl_cntrl;
+	u16 opmode;
+	u32 fbdiv2_cntrl;
+	u16 fbdiv1_cntrl;
+	u16 ref_cntrl;
+	u16 n_cntrl;
+	u32 prop_cntrl;
+	u32 int_cntrl;
+	u16 gmp_cntrl;
+};
+
+/* PHY Defined for RK322X */
+#define EXT_PHY_CONTROL		0
+	#define EXT_PHY_ANALOG_RESET_MASK		0x80
+	#define EXT_PHY_DIGITAL_RESET_MASK		0x40
+	#define EXT_PHY_PCLK_INVERT_MASK		0x08
+	#define EXT_PHY_PREPCLK_INVERT_MASK		0x04
+	#define EXT_PHY_TMDSCLK_INVERT_MASK		0x02
+	#define EXT_PHY_SRC_SELECT_MASK			0x01
+
+#define EXT_PHY_TERM_CAL		0x03
+	#define EXT_PHY_TERM_CAL_EN_MASK		0x80
+	#define EXT_PHY_TERM_CAL_DIV_H_MASK		0x7f
+
+#define EXT_PHY_TERM_CAL_DIV_L		0x04
+
+#define EXT_PHY_PLL_PRE_DIVIDER		0xe2
+	#define EXT_PHY_PLL_FB_BIT8_MASK		0x80
+	#define EXT_PHY_PLL_PCLK_DIV5_EN_MASK		0x20
+	#define EXT_PHY_PLL_PRE_DIVIDER_MASK		0x1f
+
+#define EXT_PHY_PLL_FB_DIVIDER		0xe3
+
+#define EXT_PHY_PCLK_DIVIDER1		0xe4
+	#define EXT_PHY_PCLK_DIVIDERB_MASK		0x60
+	#define EXT_PHY_PCLK_DIVIDERA_MASK		0x1f
+
+#define EXT_PHY_PCLK_DIVIDER2		0xe5
+	#define EXT_PHY_PCLK_DIVIDERC_MASK		0x60
+	#define EXT_PHY_PCLK_DIVIDERD_MASK		0x1f
+
+#define EXT_PHY_TMDSCLK_DIVIDER		0xe6
+	#define EXT_PHY_TMDSCLK_DIVIDERC_MASK		0x30
+	#define EXT_PHY_TMDSCLK_DIVIDERA_MASK		0x0c
+	#define EXT_PHY_TMDSCLK_DIVIDERB_MASK		0x03
+
+#define EXT_PHY_PLL_BW			0xe7
+
+#define EXT_PHY_PPLL_PRE_DIVIDER	0xe9
+	#define EXT_PHY_PPLL_ENABLE_MASK		0xc0
+	#define EXT_PHY_PPLL_PRE_DIVIDER_MASK		0x1f
+
+#define EXT_PHY_PPLL_FB_DIVIDER		0xea
+
+#define EXT_PHY_PPLL_POST_DIVIDER	0xeb
+	#define EXT_PHY_PPLL_FB_DIVIDER_BIT8_MASK	0x80
+	#define EXT_PHY_PPLL_POST_DIVIDER_MASK		0x30
+	#define EXT_PHY_PPLL_LOCK_STATUS_MASK		0x01
+
+#define EXT_PHY_PPLL_BW			0xec
+
+#define EXT_PHY_SIGNAL_CTRL		0xee
+	#define EXT_PHY_TRANSITION_CLK_EN_MASK		0x80
+	#define EXT_PHY_TRANSITION_D0_EN_MASK		0x40
+	#define EXT_PHY_TRANSITION_D1_EN_MASK		0x20
+	#define EXT_PHY_TRANSITION_D2_EN_MASK		0x10
+	#define EXT_PHY_LEVEL_CLK_EN_MASK		0x08
+	#define EXT_PHY_LEVEL_D0_EN_MASK		0x04
+	#define EXT_PHY_LEVEL_D1_EN_MASK		0x02
+	#define EXT_PHY_LEVEL_D2_EN_MASK		0x01
+
+#define EXT_PHY_SLOPEBOOST		0xef
+	#define EXT_PHY_SLOPEBOOST_CLK_MASK		0x03
+	#define EXT_PHY_SLOPEBOOST_D0_MASK		0x0c
+	#define EXT_PHY_SLOPEBOOST_D1_MASK		0x30
+	#define EXT_PHY_SLOPEBOOST_D2_MASK		0xc0
+
+#define EXT_PHY_PREEMPHASIS		0xf0
+	#define EXT_PHY_PREEMPHASIS_D0_MASK		0x03
+	#define EXT_PHY_PREEMPHASIS_D1_MASK		0x0c
+	#define EXT_PHY_PREEMPHASIS_D2_MASK		0x30
+
+#define EXT_PHY_LEVEL1			0xf1
+	#define EXT_PHY_LEVEL_CLK_MASK			0xf0
+	#define EXT_PHY_LEVEL_D2_MASK			0x0f
+
+#define EXT_PHY_LEVEL2			0xf2
+	#define EXT_PHY_LEVEL_D1_MASK			0xf0
+	#define EXT_PHY_LEVEL_D0_MASK			0x0f
+
+#define EXT_PHY_TERM_RESIS_AUTO		0xf4
+	#define EXT_PHY_AUTO_R50_OHMS			0
+	#define EXT_PHY_AUTO_R75_OHMS			BIT(2)
+	#define EXT_PHY_AUTO_R100_OHMS			(2 << 2)
+	#define EXT_PHY_AUTO_ROPEN_CIRCUIT		(3 << 2)
+
+#define EXT_PHY_TERM_RESIS_MANUAL_CLK	0xfb
+#define EXT_PHY_TERM_RESIS_MANUAL_D2	0xfc
+#define EXT_PHY_TERM_RESIS_MANUAL_D1	0xfd
+#define EXT_PHY_TERM_RESIS_MANUAL_D0	0xfe
+
+#define RK322X_DDC_MASK_EN	((3 << 13) | (3 << (13 + 16)))
+#define RK322X_IO_3V_DOMAIN	((7 << 4) | (7 << (4 + 16)))
+#define RK322X_PLL_POWER_DOWN	(BIT(12) | BIT(12 + 16))
+#define RK322X_PLL_POWER_UP	BIT(12 + 16)
+#define RK322X_PLL_PDATA_DEN	BIT(11 + 16)
+#define RK322X_PLL_PDATA_EN	(BIT(11) | BIT(11 + 16))
+
+#ifndef RK322X_GRF_SOC_CON2
+#define RK322X_GRF_SOC_CON2	RK3228_GRF_SOC_CON2
+#endif
+#ifndef RK322X_GRF_SOC_CON6
+#define RK322X_GRF_SOC_CON6	RK3228_GRF_SOC_CON6
+#endif
+
+struct ext_pll_config_tab {
+	u32	pix_clock;
+	u32	tmdsclock;
+	u8	color_depth;
+	u8	pll_nd;
+	u16	pll_nf;
+	u8	tmsd_divider_a;
+	u8	tmsd_divider_b;
+	u8	tmsd_divider_c;
+	u8	pclk_divider_a;
+	u8	pclk_divider_b;
+	u8	pclk_divider_c;
+	u8	pclk_divider_d;
+	u8	vco_div_5;
+	u8	ppll_nd;
+	u16	ppll_nf;
+	u8	ppll_no;
+};
+
+/*
+* HDMI TX PHY Define End
+*/
+
+struct rockchip_hdmiv2_reg_table {
+	int reg_base;
+	int reg_end;
+};
+
+static inline u32 hdmi_readl(struct hdmi_dev *hdmi_dev, u16 offset)
+{
+	return readl_relaxed(hdmi_dev->regbase + (offset) * 0x04);
+}
+
+static inline int hdmi_writel(struct hdmi_dev *hdmi_dev, u16 offset, u32 val)
+{
+	int ret = 0;
+
+	writel_relaxed(val, hdmi_dev->regbase + (offset) * 0x04);
+	return ret;
+}
+
+static inline int hdmi_msk_reg(struct hdmi_dev *hdmi_dev,
+			       u16 offset, u32 msk, u32 val)
+{
+	int ret = 0;
+	u32 temp;
+
+	temp = readl_relaxed(hdmi_dev->regbase +
+			     (offset) * 0x04) & (0xFF - (msk));
+	writel_relaxed(temp | ((val) & (msk)),
+		       hdmi_dev->regbase + (offset) * 0x04);
+	return ret;
+}
+
+irqreturn_t rockchip_hdmiv2_dev_irq(int irq, void *priv);
+void rockchip_hdmiv2_dev_init_ops(struct hdmi_ops *ops);
+void rockchip_hdmiv2_dev_initial(struct hdmi_dev *hdmi_dev);
+void rockchip_hdmiv2_cec_init(struct hdmi *hdmi);
+void rockchip_hdmiv2_cec_isr(struct hdmi_dev *hdmi_dev, char cec_int);
+void rockchip_hdmiv2_hdcp_init(struct hdmi *hdmi);
+void rockchip_hdmiv2_hdcp2_enable(int enable);
+void rockchip_hdmiv2_hdcp_isr(struct hdmi_dev *hdmi_dev, int hdcp_int);
+int rockchip_hdmiv2_write_phy(struct hdmi_dev *hdmi_dev,
+			      int reg_addr, int val);
+int rockchip_hdmiv2_read_phy(struct hdmi_dev *hdmi_dev,
+			     int reg_addr);
+#endif
diff -Nupr a/drivers/video/rockchip/iep/hw_iep_config_addr.h b/drivers/video/rockchip/iep/hw_iep_config_addr.h
--- a/drivers/video/rockchip/iep/hw_iep_config_addr.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/hw_iep_config_addr.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef HW_IEP_CONFIG_ADDR_H_
+#define HW_IEP_CONFIG_ADDR_H_
+
+#include <asm/io.h>
+
+/*ignore the IEP_BASE when program running in linux kernel */
+#define      IEP_BASE                      0x0
+
+#define      IEP_CONFIG0      		       0x0000
+#define      IEP_CONFIG1      		       0x0004
+
+#define      IEP_STATUS              	   0x0008
+#define      IEP_INT                 	   0x000C
+#define      IEP_FRM_START         		   0x0010
+#define      IEP_SOFT_RST           	   0x0014
+#define      IEP_CONF_DONE                 0x0018
+
+#define      IEP_VIR_IMG_WIDTH        	   0x0020
+
+#define      IEP_IMG_SCL_FCT         	   0x0024
+
+#define      IEP_SRC_IMG_SIZE         	   0x0028
+#define      IEP_DST_IMG_SIZE         	   0x002C
+
+#define      IEP_DST_IMG_WIDTH_TILE0  	   0x0030
+#define      IEP_DST_IMG_WIDTH_TILE1  	   0x0034
+#define      IEP_DST_IMG_WIDTH_TILE2  	   0x0038
+#define      IEP_DST_IMG_WIDTH_TILE3  	   0x003C
+
+#define      IEP_ENH_YUV_CNFG_0       	   0x0040
+#define      IEP_ENH_YUV_CNFG_1       	   0x0044
+#define      IEP_ENH_YUV_CNFG_2       	   0x0048
+#define      IEP_ENH_RGB_CNFG        	   0x004C
+#define      IEP_ENH_C_COE            	   0x0050
+
+#define      IEP_SRC_ADDR_YRGB        	   0x0080
+#define      IEP_SRC_ADDR_CBCR             0x0084
+#define      IEP_SRC_ADDR_CR               0x0088
+#define      IEP_SRC_ADDR_Y1               0x008C
+#define      IEP_SRC_ADDR_CBCR1            0x0090
+#define      IEP_SRC_ADDR_CR1              0x0094
+#define      IEP_SRC_ADDR_Y_ITEMP          0x0098
+#define      IEP_SRC_ADDR_CBCR_ITEMP       0x009C
+#define      IEP_SRC_ADDR_CR_ITEMP         0x00A0
+#define      IEP_SRC_ADDR_Y_FTEMP          0x00A4
+#define      IEP_SRC_ADDR_CBCR_FTEMP       0x00A8
+#define      IEP_SRC_ADDR_CR_FTEMP         0x00AC
+
+#define      IEP_DST_ADDR_YRGB        	   0x00B0
+#define      IEP_DST_ADDR_CBCR             0x00B4
+#define      IEP_DST_ADDR_CR               0x00B8
+#define      IEP_DST_ADDR_Y1               0x00BC
+#define      IEP_DST_ADDR_CBCR1            0x00C0
+#define      IEP_DST_ADDR_CR1              0x00C4
+#define      IEP_DST_ADDR_Y_ITEMP          0x00C8
+#define      IEP_DST_ADDR_CBCR_ITEMP       0x00CC
+#define      IEP_DST_ADDR_CR_ITEMP         0x00D0
+#define      IEP_DST_ADDR_Y_FTEMP          0x00D4
+#define      IEP_DST_ADDR_CBCR_FTEMP       0x00D8
+#define      IEP_DST_ADDR_CR_FTEMP         0x00DC
+
+#define      IEP_DIL_MTN_TAB0              0x00E0
+#define      IEP_DIL_MTN_TAB1              0x00E4
+#define      IEP_DIL_MTN_TAB2              0x00E8
+#define      IEP_DIL_MTN_TAB3              0x00EC
+#define      IEP_DIL_MTN_TAB4              0x00F0
+#define      IEP_DIL_MTN_TAB5              0x00F4
+#define      IEP_DIL_MTN_TAB6              0x00F8
+#define      IEP_DIL_MTN_TAB7              0x00FC
+
+#define      IEP_ENH_CG_TAB                0x0100
+
+#define      IEP_YUV_DNS_CRCT_TEMP         0x0400
+#define      IEP_YUV_DNS_CRCT_SPAT         0x0800
+
+#define      IEP_ENH_DDE_COE0              0x0C00
+#define      IEP_ENH_DDE_COE1              0x0E00
+
+#define      RAW_IEP_CONFIG0               0x0058
+#define      RAW_IEP_CONFIG1      		   0x005C
+#define      RAW_IEP_VIR_IMG_WIDTH         0x0060
+
+#define      RAW_IEP_IMG_SCL_FCT      	   0x0064
+
+#define      RAW_IEP_SRC_IMG_SIZE      	   0x0068
+#define      RAW_IEP_DST_IMG_SIZE      	   0x006C
+
+#define      RAW_IEP_ENH_YUV_CNFG_0        0x0070
+#define      RAW_IEP_ENH_YUV_CNFG_1        0x0074
+#define      RAW_IEP_ENH_YUV_CNFG_2        0x0078
+#define      RAW_IEP_ENH_RGB_CNFG          0x007C
+
+#define ReadReg32(base, raddr)	        (__raw_readl(base + raddr))
+#define WriteReg32(base, waddr, value)	(__raw_writel(value, base + waddr))
+#define ConfRegBits32(base, raddr, waddr, position, value)           WriteReg32(base, waddr, (ReadReg32(base, waddr)&~(position))|(value))
+#define MaskRegBits32(base, waddr, position, value)                  WriteReg32(base, waddr, (ReadReg32(base, waddr)&~(position))|(value))
+
+#endif
diff -Nupr a/drivers/video/rockchip/iep/hw_iep_reg.c b/drivers/video/rockchip/iep/hw_iep_reg.c
--- a/drivers/video/rockchip/iep/hw_iep_reg.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/hw_iep_reg.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1530 @@
+/* 
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include "iep_iommu_ops.h"
+#include "hw_iep_reg.h"
+#include "iep.h"
+#include "hw_iep_config_addr.h"
+
+extern iep_service_info iep_service;
+static void iep_config_src_size(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_SRC_IMG_WIDTH(iep_msg->base, iep_msg->src.act_w - 1);
+	IEP_REGB_SRC_IMG_HEIGHT(iep_msg->base, iep_msg->src.act_h - 1);
+#ifdef IEP_PRINT_INFO
+	IEP_DBG(" //==source image size config===================//\n\n");
+	IEP_DBG("sw_src_img_height          = %d;//source image height \n",
+		iep_msg->src.act_h - 1);
+	IEP_DBG("sw_src_img_width           = %d;//source image width \n\n",
+		iep_msg->src.act_w - 1);
+#endif
+}
+
+static void iep_config_dst_size(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_DST_IMG_WIDTH(iep_msg->base, iep_msg->dst.act_w - 1);
+	IEP_REGB_DST_IMG_HEIGHT(iep_msg->base, iep_msg->dst.act_h - 1);
+#ifdef IEP_PRINT_INFO
+	IEP_DBG(" //==destination image size config===================//\n\n");
+	IEP_DBG("sw_dst_img_height          = %d;//source image height \n",
+		iep_msg->dst.act_h - 1);
+	IEP_DBG("sw_dst_img_width           = %d;//source image width \n",
+		iep_msg->dst.act_w - 1);
+#endif
+}
+
+static void iep_config_dst_width_tile(struct IEP_MSG *iep_msg)
+{
+	/*IEP_REGB_DST_IMG_WIDTH_TILE0();
+	IEP_REGB_DST_IMG_WIDTH_TILE1();
+	IEP_REGB_DST_IMG_WIDTH_TILE2();
+	IEP_REGB_DST_IMG_WIDTH_TILE3();*/
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("sw_dst_width_tile0         = 0;\n");
+	IEP_DBG("sw_dst_width_tile1         = 0;\n");
+	IEP_DBG("sw_dst_width_tile2         = 0;\n");
+	IEP_DBG("sw_dst_width_tile3         = 0;\n\n");
+#endif
+}
+
+static void iep_config_dst_fmt(struct IEP_MSG *iep_msg)
+{
+	unsigned int dst_fmt = 0;
+	unsigned int dst_rgb_swap = 0;
+	unsigned int dst_yuv_swap = 0;
+	switch (iep_msg->dst.format) {
+	case IEP_FORMAT_ARGB_8888 :
+		IEP_REGB_DST_FMT(iep_msg->base, 0);
+		IEP_REGB_DST_RGB_SWAP(iep_msg->base, 0);
+		dst_fmt = 0;
+		dst_rgb_swap = 0;
+		dst_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_ABGR_8888 :
+		IEP_REGB_DST_FMT(iep_msg->base, 0);
+		IEP_REGB_DST_RGB_SWAP(iep_msg->base, 1);
+		dst_fmt = 0;
+		dst_rgb_swap = 1;
+		dst_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_RGBA_8888 :
+		IEP_REGB_DST_FMT(iep_msg->base, 0);
+		IEP_REGB_DST_RGB_SWAP(iep_msg->base, 2);
+		dst_fmt = 0;
+		dst_rgb_swap = 2;
+		dst_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_BGRA_8888 :
+		IEP_REGB_DST_FMT(iep_msg->base, 0);
+		IEP_REGB_DST_RGB_SWAP(iep_msg->base, 3);
+		dst_fmt = 0;
+		dst_rgb_swap = 3;
+		dst_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_RGB_565 :
+		IEP_REGB_DST_FMT(iep_msg->base, 1);
+		IEP_REGB_DST_RGB_SWAP(iep_msg->base, 0);
+		dst_fmt = 1;
+		dst_rgb_swap = 0;
+		dst_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_BGR_565 :
+		IEP_REGB_DST_FMT(iep_msg->base, 1);
+		IEP_REGB_DST_RGB_SWAP(iep_msg->base, 1);
+		dst_fmt = 1;
+		dst_rgb_swap = 1;
+		dst_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_YCbCr_422_SP :
+		IEP_REGB_DST_FMT(iep_msg->base, 2);
+		IEP_REGB_DST_YUV_SWAP(iep_msg->base, 0);
+		dst_fmt = 2;
+		dst_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_YCbCr_422_P :
+		IEP_REGB_DST_FMT(iep_msg->base, 2);
+		IEP_REGB_DST_YUV_SWAP(iep_msg->base, 2);
+		dst_fmt = 2;
+		dst_yuv_swap = 2;
+		break;
+	case IEP_FORMAT_YCbCr_420_SP :
+		IEP_REGB_DST_FMT(iep_msg->base, 3);
+		IEP_REGB_DST_YUV_SWAP(iep_msg->base, 0);
+		dst_fmt = 3;
+		dst_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_YCbCr_420_P :
+		IEP_REGB_DST_FMT(iep_msg->base, 3);
+		IEP_REGB_DST_YUV_SWAP(iep_msg->base, 2);
+		dst_fmt = 3;
+		dst_yuv_swap = 2;
+		break;
+	case IEP_FORMAT_YCrCb_422_SP :
+		IEP_REGB_DST_FMT(iep_msg->base, 2);
+		IEP_REGB_DST_YUV_SWAP(iep_msg->base, 1);
+		dst_fmt = 2;
+		dst_yuv_swap = 1;
+		break;
+	case IEP_FORMAT_YCrCb_422_P :
+		IEP_REGB_DST_FMT(iep_msg->base, 2);
+		IEP_REGB_DST_YUV_SWAP(iep_msg->base, 2);
+		dst_fmt = 2;
+		dst_yuv_swap = 2;
+		break;
+	case IEP_FORMAT_YCrCb_420_SP :
+		IEP_REGB_DST_FMT(iep_msg->base, 3);
+		IEP_REGB_DST_YUV_SWAP(iep_msg->base, 1);
+		dst_fmt = 3;
+		dst_yuv_swap = 1;
+		break;
+	case IEP_FORMAT_YCrCb_420_P :
+		IEP_REGB_DST_FMT(iep_msg->base, 3);
+		IEP_REGB_DST_YUV_SWAP(iep_msg->base, 2);
+		dst_fmt = 3;
+		dst_yuv_swap = 2;
+		break;
+	default:
+		break;
+	}
+#ifdef IEP_PRINT_INFO
+	IEP_DBG(" //==destination data format config============//\n\n");
+	IEP_DBG("sw_dst_yuv_swap            = %d;//0:sp uv; 1:sp vu; 2:p ;"
+		" 3:p;\n",
+		dst_yuv_swap);
+	IEP_DBG("sw_dst_rgb_swap            = %d;//if ARGB 0:argb; "
+		"1,abgr; 2:rgba; 3:bgra; if rgb565: 0,2:rgb; 1,3:bgr;\n",
+		dst_rgb_swap);
+	IEP_DBG("sw_dst_fmt                 = %d;//0:argb; 1:rgb565; 2:yuv422;"
+		" 3:yuv420;\n\n", dst_fmt);
+#endif
+}
+
+static void iep_config_src_fmt(struct IEP_MSG *iep_msg)
+{
+	unsigned int src_fmt = 0;
+	unsigned int src_rgb_swap = 0;
+	unsigned int src_yuv_swap = 0;
+	switch (iep_msg->src.format) {
+	case IEP_FORMAT_ARGB_8888 :
+		IEP_REGB_SRC_FMT(iep_msg->base, 0);
+		IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 0);
+		src_fmt = 0;
+		src_rgb_swap = 0;
+		break;
+	case IEP_FORMAT_ABGR_8888 :
+		IEP_REGB_SRC_FMT(iep_msg->base, 0);
+		IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 1);
+		src_fmt = 0;
+		src_rgb_swap = 1;
+		break;
+	case IEP_FORMAT_RGBA_8888 :
+		IEP_REGB_SRC_FMT(iep_msg->base, 0);
+		IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 2);
+		src_fmt = 0;
+		src_rgb_swap = 2;
+		break;
+	case IEP_FORMAT_BGRA_8888 :
+		IEP_REGB_SRC_FMT(iep_msg->base, 0);
+		IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 3);
+		src_fmt = 0;
+		src_rgb_swap = 3;
+		break;
+	case IEP_FORMAT_RGB_565 :
+		IEP_REGB_SRC_FMT(iep_msg->base, 1);
+		IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 0);
+		src_fmt = 1;
+		src_rgb_swap = 0;
+		break;
+	case IEP_FORMAT_BGR_565 :
+		IEP_REGB_SRC_FMT(iep_msg->base, 1);
+		IEP_REGB_SRC_RGB_SWAP(iep_msg->base, 1);
+		src_fmt = 1;
+		src_rgb_swap = 1;
+		break;
+	case IEP_FORMAT_YCbCr_422_SP :
+		IEP_REGB_SRC_FMT(iep_msg->base, 2);
+		IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 0);
+		src_fmt = 2;
+		src_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_YCbCr_422_P :
+		IEP_REGB_SRC_FMT(iep_msg->base, 2);
+		IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 2);
+		src_fmt = 2;
+		src_yuv_swap = 2;
+		break;
+	case IEP_FORMAT_YCbCr_420_SP :
+		IEP_REGB_SRC_FMT(iep_msg->base, 3);
+		IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 0);
+		src_fmt = 3;
+		src_yuv_swap = 0;
+		break;
+	case IEP_FORMAT_YCbCr_420_P :
+		IEP_REGB_SRC_FMT(iep_msg->base, 3);
+		IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 2);
+		src_fmt = 3;
+		src_yuv_swap = 2;
+		break;
+	case IEP_FORMAT_YCrCb_422_SP :
+		IEP_REGB_SRC_FMT(iep_msg->base, 2);
+		IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 1);
+		src_fmt = 2;
+		src_yuv_swap = 1;
+		break;
+	case IEP_FORMAT_YCrCb_422_P :
+		IEP_REGB_SRC_FMT(iep_msg->base, 2);
+		IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 2);
+		src_fmt = 2;
+		src_yuv_swap = 2;
+		break;
+	case IEP_FORMAT_YCrCb_420_SP :
+		IEP_REGB_SRC_FMT(iep_msg->base, 3);
+		IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 1);
+		src_fmt = 3;
+		src_yuv_swap = 1;
+		break;
+	case IEP_FORMAT_YCrCb_420_P :
+		IEP_REGB_SRC_FMT(iep_msg->base, 3);
+		IEP_REGB_SRC_YUV_SWAP(iep_msg->base, 2);
+		src_fmt = 3;
+		src_yuv_swap = 2;
+		break;
+	default:
+		break;
+	}
+#ifdef IEP_PRINT_INFO
+	IEP_DBG(" //==source data format config=================//\n\n");
+	IEP_DBG("sw_src_yuv_swap            = %d;//0:sp uv; 1:sp vu;"
+		" 2:p ; 3:p;\n", src_yuv_swap);
+	IEP_DBG("sw_src_rgb_swap            = %d;//if ARGB 0:argb; 1,abgr;"
+		" 2:rgba; 3:bgra; if rgb565: 0,2:rgb; 1,3:bgr;\n",
+		src_rgb_swap);
+	IEP_DBG("sw_src_fmt                 = %d;//0:argb; 1:rgb565;"
+		" 2:yuv422; 3:yuv420;\n\n", src_fmt);
+#endif
+}
+
+static void iep_config_scl(struct IEP_MSG *iep_msg)
+{
+	int scl_en;
+	int scl_sel;
+	//int vrt_fct;
+	//int hrz_fct;
+
+	unsigned int src_height, src_width, dst_height, dst_width;
+
+	int div_height_dst_src;
+	int div_width_dst_src;
+
+	src_height = iep_msg->src.act_h - 1;
+	src_width = iep_msg->src.act_w - 1;
+	dst_height = iep_msg->dst.act_h - 1;
+	dst_width = iep_msg->dst.act_w - 1;
+
+	if ((iep_msg->src.act_w == iep_msg->dst.act_w) &&
+	    (iep_msg->src.act_h == iep_msg->dst.act_h))
+		scl_en = 0;
+	else
+		scl_en = 1;
+
+	if ((iep_msg->src.act_w >= iep_msg->dst.act_w) &&
+	    (iep_msg->src.act_h >= iep_msg->dst.act_h))
+		scl_sel = 0;
+	else if ((iep_msg->src.act_w >= iep_msg->dst.act_w) &&
+		 (iep_msg->src.act_h <= iep_msg->dst.act_h))
+		scl_sel = 1;
+	else if ((iep_msg->src.act_w <= iep_msg->dst.act_w) &&
+		 (iep_msg->src.act_h >= iep_msg->dst.act_h))
+		scl_sel = 2;
+	else
+		scl_sel = 3;
+
+	//for vrt_fct
+	if ((scl_sel == 1) || (scl_sel == 3)) {
+		div_height_dst_src = src_height * 65536 / dst_height;
+	} else {
+		div_height_dst_src = (dst_height + 1) * 65536 /
+			(src_height + 1);
+		if ((div_height_dst_src * (src_height + 1)) <
+		    ((dst_height + 1) * 65536))
+			div_height_dst_src = div_height_dst_src + 1;
+	}
+
+	if (div_height_dst_src == 65536)
+		div_height_dst_src = 0;
+
+	//for hrz_fct
+	if ((scl_sel == 2) || (scl_sel == 3)) {
+		div_width_dst_src = src_width * 65536 / dst_width;
+	} else {
+		div_width_dst_src = (dst_width + 1) * 65536 / (src_width + 1);
+		if ((div_width_dst_src * (src_width + 1)) <
+		    ((dst_width + 1) * 65536))
+			div_width_dst_src = div_width_dst_src + 1;
+	}
+
+	if (div_width_dst_src == 65536)
+		div_width_dst_src = 0;
+
+
+	IEP_REGB_SCL_EN(iep_msg->base, scl_en);
+
+	if (scl_en == 1) {
+		IEP_REGB_SCL_SEL(iep_msg->base, scl_sel);
+		IEP_REGB_SCL_UP_COE_SEL(iep_msg->base, iep_msg->scale_up_mode);
+		IEP_REGB_SCL_VRT_FCT(iep_msg->base, div_height_dst_src);
+		IEP_REGB_SCL_HRZ_FCT(iep_msg->base, div_width_dst_src);
+	}
+#ifdef IEP_PRINT_INFO
+	IEP_DBG(" //==scaling config============================//\n\n");
+	IEP_DBG("sw_scl_en                  = %d;//0:disable; 1:enable;\n",
+		scl_en);
+	IEP_DBG("sw_scl_sel                 = %d;//0:hrz down & vrt down;"
+		"  1:hrz down & vrt up; 2:hrz up & vrt down;  3:hrz up &"
+		" vrt up;\n", scl_sel);
+	IEP_DBG("sw_scl_up_coe_sel          = %d;//select four groups of"
+		" up scaling coefficient\n", iep_msg->scale_up_mode);
+	IEP_DBG("sw_scl_vrt_fct             = %d;//if up-scaling,equal"
+		" to floor(src_img_height/dst_image_height)*2^16;"
+		" if down-scaling,equal to ceiling(dst_image_height/"
+		"src_image_height)*2^16;\n", div_height_dst_src);
+	IEP_DBG("sw_scl_hrz_fct             = %d;//if up-scaling,equal"
+		" to floor(src_img_widht/dst_image_width)*2^16;   if"
+		" down-scaling,equal to ceiling(dst_image_width/"
+		"src_image_width)*2^16  ; \n\n", div_width_dst_src);
+#endif
+}
+
+static void iep_config_cg_order(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_CON_GAM_ORDER(iep_msg->base,
+		iep_msg->rgb_contrast_enhance_mode);
+#ifdef IEP_PRINT_INFO
+	IEP_DBG(" //==rgb enhancement & denoise config==========//\n\n");
+	IEP_DBG("sw_con_gam_order           = %d;//0:CG(contrast/gamma"
+		" operation)prior to DDE(de-noise/detail/edge enhance);"
+		"  1:DDE prior to CG;\n",
+		iep_msg->rgb_contrast_enhance_mode);
+#endif
+}
+
+static void iep_config_cg(struct IEP_MSG *iep_msg)
+{
+	unsigned i;
+	unsigned int cg_conf_addr;
+
+	IEP_REGB_RGB_CON_GAM_EN(iep_msg->base, iep_msg->rgb_cg_en);
+
+	if (iep_msg->rgb_cg_en) {
+		cg_conf_addr = rIEP_CG_TAB_ADDR;
+
+		for (i = 0; i < 192; i++) {
+			WriteReg32(iep_msg->base, cg_conf_addr,
+				iep_msg->cg_tab[i]);
+			cg_conf_addr += 0x04;
+		}
+	}
+
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("sw_rgb_con_gam_en = 0;//0:contrast"
+		" & gamma disable; 1:enable;\n",
+		iep_msg->rgb_cg_en);
+#endif
+}
+
+static void iep_config_dde(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_RGB_ENH_SEL(iep_msg->base, iep_msg->rgb_enhance_mode);
+	IEP_REGB_ENH_THRESHOLD(iep_msg->base, iep_msg->enh_threshold);
+	IEP_REGB_ENH_ALPHA(iep_msg->base, iep_msg->enh_alpha);
+	IEP_REGB_ENH_RADIUS(iep_msg->base, iep_msg->enh_radius);
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("sw_rgb_enh_sel = %d;//0:no operation;"
+		" 1:de-noise; 2:detail enhance; 3:edge enhance;\n",
+		iep_msg->rgb_enhance_mode);
+#endif
+
+}
+
+static void iep_config_color_enh(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_RGB_COLOR_ENH_EN(iep_msg->base, iep_msg->rgb_color_enhance_en);
+	IEP_REGB_ENH_C_COE(iep_msg->base, iep_msg->rgb_enh_coe);
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("sw_rgb_color_enh_en = %d;//0:color enhance disable;"
+		" 1:enable;\n\n",
+		iep_msg->rgb_color_enhance_en);
+#endif
+}
+
+static void iep_config_yuv_dns(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_YUV_DNS_EN(iep_msg->base, iep_msg->yuv_3D_denoise_en);
+	IEP_REGB_YUV_DNS_LUMA_SPAT_SEL(iep_msg->base, 0);
+	IEP_REGB_YUV_DNS_LUMA_TEMP_SEL(iep_msg->base, 1);
+	IEP_REGB_YUV_DNS_CHROMA_SPAT_SEL(iep_msg->base, 2);
+	IEP_REGB_YUV_DNS_CHROMA_TEMP_SEL(iep_msg->base, 3);
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("//==yuv denoise config========================// \n\n");
+	IEP_DBG("sw_yuv_dns_en              = %d;//0:yuv 3d denoise disable;"
+		" 1:enable\n\n", iep_msg->yuv_3D_denoise_en);
+#endif
+}
+
+
+static void iep_config_dil(struct IEP_MSG *iep_msg)
+{
+    int dein_mode;
+    switch (iep_msg->dein_mode) {
+    case IEP_DEINTERLACE_MODE_DISABLE:
+        dein_mode = dein_mode_bypass_dis;
+        break;
+    case IEP_DEINTERLACE_MODE_I2O1:
+        dein_mode = iep_msg->field_order == FIELD_ORDER_TOP_FIRST ? dein_mode_I2O1T : dein_mode_I2O1B;
+        break;
+    case IEP_DEINTERLACE_MODE_I4O1:
+#if 1
+        dein_mode = iep_msg->field_order == FIELD_ORDER_TOP_FIRST ? dein_mode_I4O1B : dein_mode_I4O1T;
+#else
+        dein_mode = iep_msg->field_order == FIELD_ORDER_TOP_FIRST ? dein_mode_I4O1T : dein_mode_I4O1B;
+#endif
+        break;
+    case IEP_DEINTERLACE_MODE_I4O2:
+        dein_mode = dein_mode_I4O2;
+        break;
+    case IEP_DEINTERLACE_MODE_BYPASS:
+        dein_mode = dein_mode_bypass;
+        break;
+    default:
+        IEP_ERR("unknown deinterlace mode, set deinterlace mode (bypass)\n");
+        dein_mode = dein_mode_bypass;
+    }
+
+    IEP_REGB_DIL_MODE(iep_msg->base, dein_mode);
+    //hf
+    IEP_REGB_DIL_HF_EN(iep_msg->base, iep_msg->dein_high_fre_en);
+    if (iep_msg->dein_high_fre_en == 1) IEP_REGB_DIL_HF_FCT(iep_msg->base, iep_msg->dein_high_fre_fct);
+    //ei
+    IEP_REGB_DIL_EI_MODE(iep_msg->base, iep_msg->dein_ei_mode);
+    IEP_REGB_DIL_EI_SMOOTH(iep_msg->base, iep_msg->dein_ei_smooth);
+    IEP_REGB_DIL_EI_SEL(iep_msg->base, iep_msg->dein_ei_sel);
+    if (iep_msg->dein_ei_sel == 0) IEP_REGB_DIL_EI_RADIUS(iep_msg->base, iep_msg->dein_ei_radius);
+	IEP_REGB_DIL_MTN_TAB0(iep_msg->base, 0x40404040);
+	IEP_REGB_DIL_MTN_TAB1(iep_msg->base, 0x3c3e3f3f);
+	IEP_REGB_DIL_MTN_TAB2(iep_msg->base, 0x3336393b);
+	IEP_REGB_DIL_MTN_TAB3(iep_msg->base, 0x272a2d31);
+	IEP_REGB_DIL_MTN_TAB4(iep_msg->base, 0x181c2023);
+	IEP_REGB_DIL_MTN_TAB5(iep_msg->base, 0x0c0e1215);
+	IEP_REGB_DIL_MTN_TAB6(iep_msg->base, 0x03040609);
+	IEP_REGB_DIL_MTN_TAB7(iep_msg->base, 0x00000001);
+}
+
+static void iep_config_yuv_enh(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_YUV_ENH_EN(iep_msg->base, iep_msg->yuv_enhance_en);
+	if (iep_msg->yuv_enhance_en == 1) {
+		IEP_REGB_VIDEO_MODE(iep_msg->base, iep_msg->video_mode);
+		if (iep_msg->video_mode == normal_mode) {
+			IEP_REGB_SAT_CON(iep_msg->base, iep_msg->sat_con_int);
+			IEP_REGB_CONTRAST(iep_msg->base,
+				iep_msg->contrast_int);
+			IEP_REGB_BRIGHTNESS(iep_msg->base,
+				iep_msg->yuv_enh_brightness);
+			IEP_REGB_COS_HUE(iep_msg->base, iep_msg->cos_hue_int);
+			IEP_REGB_SIN_HUE(iep_msg->base, iep_msg->sin_hue_int);
+		} else if (iep_msg->video_mode == color_bar) { //color bar
+			IEP_REGB_COLOR_BAR_Y(iep_msg->base,
+				iep_msg->color_bar_y);
+			IEP_REGB_COLOR_BAR_U(iep_msg->base,
+				iep_msg->color_bar_u);
+			IEP_REGB_COLOR_BAR_V(iep_msg->base,
+				iep_msg->color_bar_v);
+		}
+
+	}
+}
+
+static void iep_config_rgb2yuv(struct IEP_MSG *iep_msg)
+{
+	unsigned char cond1, cond2;
+	unsigned int rgb2yuv_en = 0;
+
+	//rgb in,yuv out
+	cond1 = ((iep_msg->src.format <= 5) && (iep_msg->dst.format > 5)) ?
+		1 : 0;
+
+	//rgb process,yuv out
+	cond2 = (((iep_msg->rgb_color_enhance_en == 1) ||
+		  (iep_msg->rgb_cg_en == 1) ||
+		  (iep_msg->rgb_enhance_mode != rgb_enhance_bypass)) &&
+		 (iep_msg->dst.format > 5)) ? 1 : 0;
+
+
+	if ((cond1 == 1) || (cond2 == 1)) {
+		IEP_REGB_RGB_TO_YUV_EN(iep_msg->base, 1);
+		rgb2yuv_en = 1;
+		IEP_REGB_RGB2YUV_COE_SEL(iep_msg->base, iep_msg->rgb2yuv_mode);
+		IEP_REGB_RGB2YUV_INPUT_CLIP(iep_msg->base,
+			iep_msg->rgb2yuv_clip_en);
+	} else
+		IEP_REGB_RGB_TO_YUV_EN(iep_msg->base, 0);
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("//==color space conversion config============//\n\n");
+	IEP_DBG("sw_rgb_to_yuv_en = %d;\n", rgb2yuv_en);
+	IEP_DBG("sw_rgb2yuv_coe_sel = %d;\n", iep_msg->rgb2yuv_mode);
+	IEP_DBG("sw_rgb2yuv_input_clip = %d;\n\n", iep_msg->rgb2yuv_clip_en);
+#endif
+
+}
+
+static void iep_config_yuv2rgb(struct IEP_MSG *iep_msg)
+{
+	unsigned char cond1, cond2;
+	unsigned int yuv2rgb_en = 0;
+
+	//yuv in,rgb out
+	cond1 = ((iep_msg->src.format > 5) &&
+		 (iep_msg->dst.format <= 5)) ? 1 : 0;
+
+	//yuv in,rgb process
+	cond2 = (((iep_msg->rgb_color_enhance_en == 1) ||
+		  (iep_msg->rgb_cg_en == 1) ||
+		  (iep_msg->rgb_enhance_mode != rgb_enhance_bypass)) &&
+		 (iep_msg->src.format > 5)) ? 1 : 0;
+
+	if ((cond1 == 1) || (cond2 == 1)) {
+		IEP_REGB_YUV_TO_RGB_EN(iep_msg->base, 1);
+		yuv2rgb_en = 1;
+		IEP_REGB_YUV2RGB_COE_SEL(iep_msg->base,
+			iep_msg->yuv2rgb_mode);
+		IEP_REGB_YUV2RGB_INPUT_CLIP(iep_msg->base,
+			iep_msg->yuv2rgb_clip_en);
+	} else {
+		IEP_REGB_YUV_TO_RGB_EN(iep_msg->base, 0);
+	}
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("sw_yuv_to_rgb_en           = %d;\n", yuv2rgb_en);
+	IEP_DBG("sw_yuv2rgb_coe_sel         = %d;\n", iep_msg->yuv2rgb_mode);
+	IEP_DBG("sw_yuv2rgb_input_clip = %d;\n\n", iep_msg->yuv2rgb_clip_en);
+#endif
+}
+
+static void iep_config_dither_up(struct IEP_MSG *iep_msg)
+{
+	unsigned int dither_up = 0;
+	if ((iep_msg->src.format == IEP_FORMAT_RGB_565) ||
+	    (iep_msg->src.format == IEP_FORMAT_BGR_565)) {
+		IEP_REGB_DITHER_UP_EN(iep_msg->base, iep_msg->dither_up_en);
+		dither_up = iep_msg->dither_up_en;
+	} else {
+		IEP_REGB_DITHER_UP_EN(iep_msg->base, 0);
+	}
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("//==dither config=============================//\n\n");
+	IEP_DBG("sw_dither_up_en            = %d;\n", dither_up);
+#endif
+}
+
+static void iep_config_dither_down(struct IEP_MSG *iep_msg)
+{
+	unsigned int dither_down = 0;
+	if ((iep_msg->dst.format == IEP_FORMAT_RGB_565) ||
+	    (iep_msg->dst.format == IEP_FORMAT_BGR_565)) {
+		IEP_REGB_DITHER_DOWN_EN(iep_msg->base, 1);
+		dither_down = 1;
+	} else {
+		IEP_REGB_DITHER_DOWN_EN(iep_msg->base, 0);
+	}
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("sw_dither_down_en = %d;\n\n", dither_down);
+#endif
+}
+
+static void iep_config_glb_alpha(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_GLB_ALPHA(iep_msg->base, iep_msg->global_alpha_value);
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("//==global alpha for ARGB config=============//\n\n");
+	IEP_DBG("sw_glb_alpha = %d;//global alpha value for output ARGB\n\n",
+		iep_msg->global_alpha_value);
+#endif
+}
+
+static void iep_config_vir_line(struct IEP_MSG *iep_msg)
+{
+	unsigned int src_vir_w;
+	unsigned int dst_vir_w;
+
+	switch (iep_msg->src.format) {
+	case IEP_FORMAT_ARGB_8888 :
+		src_vir_w = iep_msg->src.vir_w;
+		break;
+	case IEP_FORMAT_ABGR_8888 :
+		src_vir_w = iep_msg->src.vir_w;
+		break;
+	case IEP_FORMAT_RGBA_8888 :
+		src_vir_w = iep_msg->src.vir_w;
+		break;
+	case IEP_FORMAT_BGRA_8888 :
+		src_vir_w = iep_msg->src.vir_w;
+		break;
+	case IEP_FORMAT_RGB_565 :
+		if (iep_msg->src.vir_w % 2 == 1)
+			src_vir_w = (iep_msg->src.vir_w + 1) / 2;
+		else
+			src_vir_w = iep_msg->src.vir_w / 2;
+		break;
+	case IEP_FORMAT_BGR_565 :
+		if (iep_msg->src.vir_w % 2 == 1)
+			src_vir_w = iep_msg->src.vir_w / 2 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 2;
+		break;
+	case IEP_FORMAT_YCbCr_422_SP :
+		if (iep_msg->src.vir_w % 4 != 0)
+			src_vir_w = iep_msg->src.vir_w / 4 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCbCr_422_P :
+		if (iep_msg->src.vir_w % 4 != 0)
+			src_vir_w = iep_msg->src.vir_w / 4 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCbCr_420_SP :
+		if (iep_msg->src.vir_w % 4 != 0)
+			src_vir_w = iep_msg->src.vir_w / 4 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCbCr_420_P :
+		if (iep_msg->src.vir_w % 4 != 0)
+			src_vir_w = iep_msg->src.vir_w / 4 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCrCb_422_SP :
+		if (iep_msg->src.vir_w % 4 != 0)
+			src_vir_w = iep_msg->src.vir_w / 4 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCrCb_422_P :
+		if (iep_msg->src.vir_w % 4 != 0)
+			src_vir_w = iep_msg->src.vir_w / 4 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCrCb_420_SP :
+		if (iep_msg->src.vir_w % 4 != 0)
+			src_vir_w = iep_msg->src.vir_w / 4 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCrCb_420_P :
+		if (iep_msg->src.vir_w % 4 != 0)
+			src_vir_w = iep_msg->src.vir_w / 4 + 1;
+		else
+			src_vir_w = iep_msg->src.vir_w / 4;
+		break;
+	default:
+		IEP_ERR("Unkown format,"
+			"set the source image virtual width 0\n");
+		src_vir_w = 0;
+		break;
+	}
+
+	switch (iep_msg->dst.format) {
+	case IEP_FORMAT_ARGB_8888 :
+		dst_vir_w = iep_msg->dst.vir_w;
+		break;
+	case IEP_FORMAT_ABGR_8888 :
+		dst_vir_w = iep_msg->dst.vir_w;
+		break;
+	case IEP_FORMAT_RGBA_8888 :
+		dst_vir_w = iep_msg->dst.vir_w;
+		break;
+	case IEP_FORMAT_BGRA_8888 :
+		dst_vir_w = iep_msg->dst.vir_w;
+		break;
+	case IEP_FORMAT_RGB_565 :
+		if (iep_msg->dst.vir_w % 2 == 1)
+			dst_vir_w = (iep_msg->dst.vir_w + 1) / 2;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 2;
+		break;
+	case IEP_FORMAT_BGR_565 :
+		if (iep_msg->dst.vir_w % 2 == 1)
+			dst_vir_w = iep_msg->dst.vir_w / 2 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 2;
+		break;
+	case IEP_FORMAT_YCbCr_422_SP :
+		if (iep_msg->dst.vir_w % 4 != 0)
+			dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCbCr_422_P :
+		if (iep_msg->dst.vir_w % 4 != 0)
+			dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCbCr_420_SP :
+		if (iep_msg->dst.vir_w % 4 != 0)
+			dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCbCr_420_P :
+		if (iep_msg->dst.vir_w % 4 != 0)
+			dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCrCb_422_SP :
+		if (iep_msg->dst.vir_w % 4 != 0)
+			dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCrCb_422_P :
+		if (iep_msg->dst.vir_w % 4 != 0)
+			dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCrCb_420_SP :
+		if (iep_msg->dst.vir_w % 4 != 0)
+			dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 4;
+		break;
+	case IEP_FORMAT_YCrCb_420_P :
+		if (iep_msg->dst.vir_w % 4 != 0)
+			dst_vir_w = iep_msg->dst.vir_w / 4 + 1;
+		else
+			dst_vir_w = iep_msg->dst.vir_w / 4;
+		break;
+	default:
+		IEP_ERR("Unkown format, set the destination"
+			" image virtual width 0\n");
+		dst_vir_w = 0;
+		break;
+	}
+	IEP_REGB_DST_VIR_LINE_WIDTH(iep_msg->base, dst_vir_w);
+	IEP_REGB_SRC_VIR_LINE_WIDTH(iep_msg->base, src_vir_w);
+}
+
+static void iep_config_src_addr(struct IEP_MSG *iep_msg)
+{
+	u32 src_addr_yrgb;
+	u32 src_addr_cbcr;
+	u32 src_addr_cr;
+	u32 src_addr_y1;
+	u32 src_addr_cbcr1;
+	u32 src_addr_cr1;
+	u32 src_addr_y_itemp;
+	u32 src_addr_cbcr_itemp;
+	u32 src_addr_cr_itemp;
+	u32 src_addr_y_ftemp;
+	u32 src_addr_cbcr_ftemp;
+	u32 src_addr_cr_ftemp;
+	unsigned int offset_addr_y = 0;
+	unsigned int offset_addr_uv = 0;
+	unsigned int offset_addr_v = 0;
+	//unsigned int offset_addr_y_w = 0;
+	unsigned int offset_addr_uv_w = 0;
+	unsigned int offset_addr_v_w = 0;
+	//unsigned int offset_addr_y_h = 0;
+	unsigned int offset_addr_uv_h = 0;
+	unsigned int offset_addr_v_h = 0;
+
+	unsigned int offset_x_equ_uv;
+	unsigned int offset_x_u_byte;
+	unsigned int offset_x_v_byte;
+	unsigned int vir_w_euq_uv;
+	unsigned int line_u_byte;
+	unsigned int line_v_byte;
+	unsigned int offset_y_equ_420_uv = 0;
+
+	//**********************************************//
+	//***********y addr offset**********************//
+	//**********************************************//
+	if (iep_msg->src.format <= 3) {
+		offset_addr_y = iep_msg->src.y_off * 4 *
+			iep_msg->src.vir_w + iep_msg->src.x_off * 4;
+	} else if (iep_msg->src.format <= 5) {
+		offset_addr_y = iep_msg->src.y_off * 2 *
+			iep_msg->src.vir_w + iep_msg->src.x_off * 2;
+	} else {
+		offset_addr_y = iep_msg->src.y_off *
+			iep_msg->src.vir_w + iep_msg->src.x_off;
+	}
+
+	//**********************************************//
+	//***********uv addr offset*********************//
+	//**********************************************//
+	// note: image size align to even when image format is yuv
+
+	//----------offset_w--------//
+	if (iep_msg->src.x_off % 2 == 1)
+		offset_x_equ_uv = iep_msg->src.x_off + 1;
+	else
+		offset_x_equ_uv = iep_msg->src.x_off;
+
+	offset_x_u_byte = offset_x_equ_uv / 2;
+	offset_x_v_byte = offset_x_equ_uv / 2;
+
+	if ((iep_msg->src.format == IEP_FORMAT_YCbCr_422_SP) ||
+	    (iep_msg->src.format == IEP_FORMAT_YCbCr_420_SP)
+		|| (iep_msg->src.format == IEP_FORMAT_YCrCb_422_SP) ||
+	    (iep_msg->src.format == IEP_FORMAT_YCrCb_420_SP))
+		offset_addr_uv_w = offset_x_u_byte + offset_x_v_byte;
+	else {
+		offset_addr_uv_w = offset_x_u_byte;
+		offset_addr_v_w = offset_x_v_byte;
+	}
+
+	//----------offset_h--------//
+	if (iep_msg->src.vir_w % 2 == 1)
+		vir_w_euq_uv = iep_msg->src.vir_w + 1;
+	else
+		vir_w_euq_uv = iep_msg->src.vir_w;
+
+	line_u_byte = vir_w_euq_uv / 2;
+	line_v_byte = vir_w_euq_uv / 2;
+
+	if (iep_msg->src.y_off % 2 == 1)
+		offset_y_equ_420_uv = iep_msg->src.y_off + 1;
+	else
+		offset_y_equ_420_uv = iep_msg->src.y_off;
+
+	switch (iep_msg->src.format) {
+	case IEP_FORMAT_YCbCr_422_SP :
+		offset_addr_uv_h = (line_u_byte + line_v_byte) *
+			iep_msg->src.y_off;
+		break;
+	case IEP_FORMAT_YCbCr_422_P :
+		offset_addr_uv_h = line_u_byte * iep_msg->src.y_off;
+		offset_addr_v_h = line_v_byte * iep_msg->src.y_off;
+		break;
+	case IEP_FORMAT_YCbCr_420_SP :
+		offset_addr_uv_h = (line_u_byte + line_v_byte) *
+			offset_y_equ_420_uv / 2;
+		break;
+	case IEP_FORMAT_YCbCr_420_P :
+		offset_addr_uv_h = line_u_byte * offset_y_equ_420_uv / 2;
+		offset_addr_v_h = line_v_byte * offset_y_equ_420_uv / 2;
+		break;
+	case IEP_FORMAT_YCrCb_422_SP :
+		offset_addr_uv_h = (line_u_byte + line_v_byte) *
+			iep_msg->src.y_off;
+		break;
+	case IEP_FORMAT_YCrCb_422_P :
+		offset_addr_uv_h = line_u_byte * iep_msg->src.y_off;
+		offset_addr_v_h = line_v_byte * iep_msg->src.y_off;
+		break;
+	case IEP_FORMAT_YCrCb_420_SP :
+		offset_addr_uv_h = (line_u_byte + line_v_byte) *
+			offset_y_equ_420_uv / 2;
+		break;
+	case IEP_FORMAT_YCrCb_420_P :
+		offset_addr_uv_h = line_u_byte * offset_y_equ_420_uv / 2;
+		offset_addr_v_h = line_v_byte * offset_y_equ_420_uv / 2;
+		break;
+	default:
+		break;
+	}
+	//----------offset u/v addr--------//
+
+	offset_addr_uv = offset_addr_uv_w + offset_addr_uv_h;
+	offset_addr_v  = offset_addr_v_w + offset_addr_v_h;
+	//**********************************************//
+	//***********yuv address   *********************//
+	//**********************************************//
+	if (iep_service.iommu_dev == NULL) {
+		src_addr_yrgb = ((u32)iep_msg->src.mem_addr) + offset_addr_y;
+		src_addr_cbcr = ((u32)iep_msg->src.uv_addr) + offset_addr_uv;
+		src_addr_cr = ((u32)iep_msg->src.v_addr) + offset_addr_v;
+
+		src_addr_y1 = ((u32)iep_msg->src1.mem_addr) + offset_addr_y;
+		src_addr_cbcr1 = ((u32)iep_msg->src1.uv_addr) + offset_addr_uv;
+		src_addr_cr1 = ((u32)iep_msg->src1.v_addr) + offset_addr_v;
+
+		src_addr_y_itemp = ((u32)iep_msg->src_itemp.mem_addr) +
+			offset_addr_y;
+		src_addr_cbcr_itemp = ((u32)iep_msg->src_itemp.uv_addr) +
+			offset_addr_uv;
+		src_addr_cr_itemp = ((u32)iep_msg->src_itemp.v_addr) +
+			offset_addr_v;
+
+		src_addr_y_ftemp = ((u32)iep_msg->src_ftemp.mem_addr) +
+			offset_addr_y;
+		src_addr_cbcr_ftemp = ((u32)iep_msg->src_ftemp.uv_addr) +
+			offset_addr_uv;
+		src_addr_cr_ftemp = ((u32)iep_msg->src_ftemp.v_addr) +
+			offset_addr_v;
+	} else {
+		src_addr_yrgb = ((u32)iep_msg->src.mem_addr) + (offset_addr_y << 10);
+		src_addr_cbcr = ((u32)iep_msg->src.uv_addr) + (offset_addr_uv << 10);
+		src_addr_cr = ((u32)iep_msg->src.v_addr) + (offset_addr_v << 10);
+
+		src_addr_y1 = ((u32)iep_msg->src1.mem_addr) + (offset_addr_y << 10);
+		src_addr_cbcr1 = ((u32)iep_msg->src1.uv_addr) + (offset_addr_uv  << 10);
+		src_addr_cr1 = ((u32)iep_msg->src1.v_addr) + (offset_addr_v << 10);
+
+		src_addr_y_itemp = ((u32)iep_msg->src_itemp.mem_addr) +
+			(offset_addr_y << 10);
+		src_addr_cbcr_itemp = ((u32)iep_msg->src_itemp.uv_addr) +
+			(offset_addr_uv << 10);
+		src_addr_cr_itemp = ((u32)iep_msg->src_itemp.v_addr) +
+			(offset_addr_v << 10);
+
+		src_addr_y_ftemp = ((u32)iep_msg->src_ftemp.mem_addr) +
+			(offset_addr_y << 10);
+		src_addr_cbcr_ftemp = ((u32)iep_msg->src_ftemp.uv_addr) +
+			(offset_addr_uv << 10);
+		src_addr_cr_ftemp = ((u32)iep_msg->src_ftemp.v_addr) +
+			(offset_addr_v << 10);
+	}
+
+	if ((iep_msg->dein_mode == IEP_DEINTERLACE_MODE_I4O1 ||
+	     iep_msg->dein_mode == IEP_DEINTERLACE_MODE_I4O2) &&
+#if 1
+		iep_msg->field_order == FIELD_ORDER_BOTTOM_FIRST
+#else
+		iep_msg->field_order == FIELD_ORDER_TOP_FIRST
+#endif
+		) {
+		IEP_REGB_SRC_ADDR_YRGB(iep_msg->base, src_addr_y1);
+		IEP_REGB_SRC_ADDR_CBCR(iep_msg->base, src_addr_cbcr1);
+		IEP_REGB_SRC_ADDR_CR(iep_msg->base, src_addr_cr1);
+		IEP_REGB_SRC_ADDR_Y1(iep_msg->base, src_addr_yrgb);
+		IEP_REGB_SRC_ADDR_CBCR1(iep_msg->base, src_addr_cbcr);
+		IEP_REGB_SRC_ADDR_CR1(iep_msg->base, src_addr_cr);
+	} else {
+		IEP_REGB_SRC_ADDR_YRGB(iep_msg->base, src_addr_yrgb);
+		IEP_REGB_SRC_ADDR_CBCR(iep_msg->base, src_addr_cbcr);
+		IEP_REGB_SRC_ADDR_CR(iep_msg->base, src_addr_cr);
+		IEP_REGB_SRC_ADDR_Y1(iep_msg->base, src_addr_y1);
+		IEP_REGB_SRC_ADDR_CBCR1(iep_msg->base, src_addr_cbcr1);
+		IEP_REGB_SRC_ADDR_CR1(iep_msg->base, src_addr_cr1);
+	}
+
+	if (iep_msg->yuv_3D_denoise_en) {
+		IEP_REGB_SRC_ADDR_Y_ITEMP(iep_msg->base,
+			src_addr_y_itemp);
+		IEP_REGB_SRC_ADDR_CBCR_ITEMP(iep_msg->base,
+			src_addr_cbcr_itemp);
+		IEP_REGB_SRC_ADDR_Y_FTEMP(iep_msg->base,
+			src_addr_y_ftemp);
+		IEP_REGB_SRC_ADDR_CBCR_FTEMP(iep_msg->base,
+			src_addr_cbcr_ftemp);
+		if ((iep_msg->src.format == IEP_FORMAT_YCbCr_422_P) ||
+		    (iep_msg->src.format == IEP_FORMAT_YCbCr_420_P)
+			|| (iep_msg->src.format == IEP_FORMAT_YCrCb_422_P) ||
+		    (iep_msg->src.format == IEP_FORMAT_YCrCb_420_P)) {
+			IEP_REGB_SRC_ADDR_CR_ITEMP(iep_msg->base,
+				src_addr_cr_itemp);
+			IEP_REGB_SRC_ADDR_CR_FTEMP(iep_msg->base,
+				src_addr_cr_ftemp);
+		}
+	}
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("//-------source address for image-------// \n\n");
+	IEP_DBG("sw_src_addr_yrgb           = 32'h%x;\n", src_addr_yrgb);
+	IEP_DBG("sw_src_addr_cbcr           = 32'h%x;\n", src_addr_cbcr);
+	IEP_DBG("sw_src_addr_cr             = 32'h%x;\n", src_addr_cr);
+	IEP_DBG("sw_src_addr_y1             = 32'h%x;\n", src_addr_y1);
+	IEP_DBG("sw_src_addr_cbcr0          = 32'h%x;\n", src_addr_cbcr1);
+	IEP_DBG("sw_src_addr_cr0            = 32'h%x;\n", src_addr_cr1);
+	IEP_DBG("sw_src_addr_y_itemp        = 32'h%x;\n", src_addr_y_itemp);
+	IEP_DBG("sw_src_addr_cbcr_itemp     = 32'h%x;\n", src_addr_cbcr_itemp);
+	IEP_DBG("sw_src_addr_cr_itemp       = 32'h%x;\n", src_addr_cr_itemp);
+	IEP_DBG("sw_src_addr_y_ftemp        = 32'h%x;\n", src_addr_y_ftemp);
+	IEP_DBG("sw_src_addr_cbcr_ftemp     = 32'h%x;\n", src_addr_cbcr_ftemp);
+	IEP_DBG("sw_src_addr_cr_ftemp       = 32'h%x;\n\n", src_addr_cr_ftemp);
+#endif
+}
+
+static void iep_config_dst_addr(struct IEP_MSG *iep_msg)
+{
+	u32 dst_addr_yrgb;
+	u32 dst_addr_cbcr;
+	u32 dst_addr_cr;
+	u32 dst_addr_y1;
+	u32 dst_addr_cbcr1;
+	u32 dst_addr_cr1;
+	u32 dst_addr_y_itemp;
+	u32 dst_addr_cbcr_itemp;
+	u32 dst_addr_cr_itemp;
+	u32 dst_addr_y_ftemp;
+	u32 dst_addr_cbcr_ftemp;
+	u32 dst_addr_cr_ftemp;
+	unsigned int offset_addr_y = 0;
+	unsigned int offset_addr_uv = 0;
+	unsigned int offset_addr_v = 0;
+	//unsigned int offset_addr_y_w = 0;
+	unsigned int offset_addr_uv_w = 0;
+	unsigned int offset_addr_v_w = 0;
+	//unsigned int offset_addr_y_h = 0;
+	unsigned int offset_addr_uv_h = 0;
+	unsigned int offset_addr_v_h = 0;
+
+	unsigned int offset_x_equ_uv;
+	unsigned int offset_x_u_byte;
+	unsigned int offset_x_v_byte;
+	unsigned int vir_w_euq_uv;
+	unsigned int line_u_byte;
+	unsigned int line_v_byte;
+	unsigned int offset_y_equ_420_uv = 0;
+
+	//**********************************************//
+	//***********y addr offset**********************//
+	//**********************************************//
+	if (iep_msg->dst.format <= 3) {
+		offset_addr_y = iep_msg->dst.y_off * 4 *
+			iep_msg->dst.vir_w + iep_msg->dst.x_off * 4;
+	} else if (iep_msg->dst.format <= 5) {
+		offset_addr_y = iep_msg->dst.y_off * 2 *
+			iep_msg->dst.vir_w + iep_msg->dst.x_off * 2;
+	} else {
+		offset_addr_y = iep_msg->dst.y_off *
+			iep_msg->dst.vir_w + iep_msg->dst.x_off;
+	}
+
+	//**********************************************//
+	//***********uv addr offset*********************//
+	//**********************************************//
+	// note: image size align to even when image format is yuv
+
+	//----------offset_w--------//
+	if (iep_msg->dst.x_off % 2 == 1)
+		offset_x_equ_uv = iep_msg->dst.x_off + 1;
+	else
+		offset_x_equ_uv = iep_msg->dst.x_off;
+
+	offset_x_u_byte = offset_x_equ_uv / 2;
+	offset_x_v_byte = offset_x_equ_uv / 2;
+
+	if ((iep_msg->dst.format == IEP_FORMAT_YCbCr_422_SP) ||
+	    (iep_msg->dst.format == IEP_FORMAT_YCbCr_420_SP)
+		|| (iep_msg->dst.format == IEP_FORMAT_YCrCb_422_SP) ||
+	    (iep_msg->dst.format == IEP_FORMAT_YCrCb_420_SP))
+		offset_addr_uv_w = offset_x_u_byte + offset_x_v_byte;
+	else {
+		offset_addr_uv_w = offset_x_u_byte;
+		offset_addr_v_w = offset_x_v_byte;
+	}
+
+	//----------offset_h--------//
+	if (iep_msg->dst.vir_w % 2 == 1)
+		vir_w_euq_uv = iep_msg->dst.vir_w + 1;
+	else
+		vir_w_euq_uv = iep_msg->dst.vir_w;
+
+	line_u_byte = vir_w_euq_uv / 2;
+	line_v_byte = vir_w_euq_uv / 2;
+
+	if (iep_msg->dst.y_off % 2 == 1)
+		offset_y_equ_420_uv = iep_msg->dst.y_off + 1;
+	else
+		offset_y_equ_420_uv = iep_msg->dst.y_off;
+
+	switch (iep_msg->dst.format) {
+	case IEP_FORMAT_YCbCr_422_SP :
+		offset_addr_uv_h = (line_u_byte + line_v_byte) *
+			iep_msg->dst.y_off;
+		break;
+	case IEP_FORMAT_YCbCr_422_P :
+		offset_addr_uv_h = line_u_byte * iep_msg->dst.y_off;
+		offset_addr_v_h = line_v_byte * iep_msg->dst.y_off;
+		break;
+	case IEP_FORMAT_YCbCr_420_SP :
+		offset_addr_uv_h = (line_u_byte + line_v_byte) *
+			offset_y_equ_420_uv / 2;
+		break;
+	case IEP_FORMAT_YCbCr_420_P :
+		offset_addr_uv_h = line_u_byte * offset_y_equ_420_uv / 2;
+		offset_addr_v_h = line_v_byte * offset_y_equ_420_uv / 2;
+		break;
+	case IEP_FORMAT_YCrCb_422_SP :
+		offset_addr_uv_h = (line_u_byte + line_v_byte) *
+			iep_msg->dst.y_off;
+		break;
+	case IEP_FORMAT_YCrCb_422_P :
+		offset_addr_uv_h = line_u_byte * iep_msg->dst.y_off;
+		offset_addr_v_h = line_v_byte * iep_msg->dst.y_off;
+		break;
+	case IEP_FORMAT_YCrCb_420_SP :
+		offset_addr_uv_h = (line_u_byte + line_v_byte) *
+			offset_y_equ_420_uv / 2;
+		break;
+	case IEP_FORMAT_YCrCb_420_P :
+		offset_addr_uv_h = line_u_byte * offset_y_equ_420_uv / 2;
+		offset_addr_v_h = line_v_byte * offset_y_equ_420_uv / 2;
+		break;
+	default:
+		break;
+	}
+	//----------offset u/v addr--------//
+
+	offset_addr_uv = offset_addr_uv_w + offset_addr_uv_h;
+	offset_addr_v  = offset_addr_v_w + offset_addr_v_h;
+	//**********************************************//
+	//***********yuv address   *********************//
+	//**********************************************//
+
+	if (iep_service.iommu_dev == NULL) {
+		dst_addr_yrgb = ((u32)iep_msg->dst.mem_addr) + offset_addr_y;
+		dst_addr_cbcr = ((u32)iep_msg->dst.uv_addr) + offset_addr_uv;
+		dst_addr_cr = ((u32)iep_msg->dst.v_addr) + offset_addr_v;
+
+		// former frame when processing deinterlace
+		dst_addr_y1 = ((u32)iep_msg->dst1.mem_addr) + offset_addr_y;
+		dst_addr_cbcr1 = ((u32)iep_msg->dst1.uv_addr) + offset_addr_uv;
+		dst_addr_cr1 = ((u32)iep_msg->dst1.v_addr) + offset_addr_v;
+
+		dst_addr_y_itemp = ((u32)iep_msg->dst_itemp.mem_addr) +
+			offset_addr_y;
+		dst_addr_cbcr_itemp = ((u32)iep_msg->dst_itemp.uv_addr) +
+			offset_addr_uv;
+		dst_addr_cr_itemp = ((u32)iep_msg->dst_itemp.v_addr) +
+			offset_addr_v;
+
+		dst_addr_y_ftemp = ((u32)iep_msg->dst_ftemp.mem_addr) +
+			offset_addr_y;
+		dst_addr_cbcr_ftemp = ((u32)iep_msg->dst_ftemp.uv_addr) +
+			offset_addr_uv;
+		dst_addr_cr_ftemp = ((u32)iep_msg->dst_ftemp.v_addr) +
+			offset_addr_v;
+	} else {
+		dst_addr_yrgb = ((u32)iep_msg->dst.mem_addr) + (offset_addr_y << 10);
+		dst_addr_cbcr = ((u32)iep_msg->dst.uv_addr) + (offset_addr_uv << 10);
+		dst_addr_cr = ((u32)iep_msg->dst.v_addr) + (offset_addr_v << 10);
+
+		// former frame when processing deinterlace
+		dst_addr_y1 = ((u32)iep_msg->dst1.mem_addr) + (offset_addr_y << 10);
+		dst_addr_cbcr1 = ((u32)iep_msg->dst1.uv_addr) + (offset_addr_uv << 10);
+		dst_addr_cr1 = ((u32)iep_msg->dst1.v_addr) + (offset_addr_v << 10);
+
+		dst_addr_y_itemp = ((u32)iep_msg->dst_itemp.mem_addr) +
+			(offset_addr_y << 10);
+		dst_addr_cbcr_itemp = ((u32)iep_msg->dst_itemp.uv_addr) +
+			(offset_addr_uv << 10);
+		dst_addr_cr_itemp = ((u32)iep_msg->dst_itemp.v_addr) +
+			(offset_addr_v << 10);
+
+		dst_addr_y_ftemp = ((u32)iep_msg->dst_ftemp.mem_addr) +
+			(offset_addr_y << 10);
+		dst_addr_cbcr_ftemp = ((u32)iep_msg->dst_ftemp.uv_addr) +
+			(offset_addr_uv << 10);
+		dst_addr_cr_ftemp = ((u32)iep_msg->dst_ftemp.v_addr) +
+			(offset_addr_v << 10);
+	}
+
+	IEP_REGB_DST_ADDR_YRGB(iep_msg->base, dst_addr_yrgb);
+	IEP_REGB_DST_ADDR_CBCR(iep_msg->base, dst_addr_cbcr);
+	IEP_REGB_DST_ADDR_Y1(iep_msg->base, dst_addr_y1);
+	IEP_REGB_DST_ADDR_CBCR1(iep_msg->base, dst_addr_cbcr1);
+	IEP_REGB_DST_ADDR_CR(iep_msg->base, dst_addr_cr);
+	IEP_REGB_DST_ADDR_CR1(iep_msg->base, dst_addr_cr1);
+
+	if (iep_msg->yuv_3D_denoise_en) {
+		IEP_REGB_DST_ADDR_Y_ITEMP(iep_msg->base,
+			dst_addr_y_itemp);
+		IEP_REGB_DST_ADDR_CBCR_ITEMP(iep_msg->base,
+			dst_addr_cbcr_itemp);
+		IEP_REGB_DST_ADDR_Y_FTEMP(iep_msg->base,
+			dst_addr_y_ftemp);
+		IEP_REGB_DST_ADDR_CBCR_FTEMP(iep_msg->base,
+			dst_addr_cbcr_ftemp);
+		if ((iep_msg->dst.format == IEP_FORMAT_YCbCr_422_P) ||
+		    (iep_msg->dst.format == IEP_FORMAT_YCbCr_420_P) ||
+		    (iep_msg->dst.format == IEP_FORMAT_YCrCb_422_P) ||
+		    (iep_msg->dst.format == IEP_FORMAT_YCrCb_420_P)) {
+			IEP_REGB_DST_ADDR_CR_ITEMP(iep_msg->base,
+				dst_addr_cr_itemp);
+			IEP_REGB_DST_ADDR_CR_FTEMP(iep_msg->base,
+				dst_addr_cr_ftemp);
+		}
+	}
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("//-------destination address for image-------// \n\n");
+	IEP_DBG("sw_dst_addr_yrgb           = 32'h%x;\n",
+		(u32)iep_msg->dst.mem_addr);
+	IEP_DBG("sw_dst_addr_cbcr           = 32'h%x;\n",
+		(u32)iep_msg->dst.uv_addr);
+	IEP_DBG("sw_dst_addr_cr             = 32'h%x;\n",
+		(u32)iep_msg->dst.v_addr);
+	IEP_DBG("sw_dst_addr_y1             = 32'h%x;\n",
+		(u32)iep_msg->dst1.mem_addr);
+	IEP_DBG("sw_dst_addr_cbcr0          = 32'h%x;\n",
+		(u32)iep_msg->dst1.uv_addr);
+	IEP_DBG("sw_dst_addr_cr0            = 32'h%x;\n",
+		(u32)iep_msg->dst1.v_addr);
+	IEP_DBG("sw_dst_addr_y_itemp        = 32'h%x;\n",
+		(u32)iep_msg->dst_itemp.mem_addr);
+	IEP_DBG("sw_dst_addr_cbcr_itemp     = 32'h%x;\n",
+		(u32)iep_msg->dst_itemp.uv_addr);
+	IEP_DBG("sw_dst_addr_cr_itemp       = 32'h%x;\n",
+		(u32)iep_msg->dst_itemp.v_addr);
+	IEP_DBG("sw_dst_addr_y_ftemp        = 32'h%x;\n",
+		(u32)iep_msg->dst_ftemp.mem_addr);
+	IEP_DBG("sw_dst_addr_cbcr_ftemp     = 32'h%x;\n",
+		(u32)iep_msg->dst_ftemp.uv_addr);
+	IEP_DBG("sw_dst_addr_cr_ftemp       = 32'h%x;\n\n",
+		(u32)iep_msg->dst_ftemp.v_addr);
+#endif
+}
+
+void iep_config_lcdc_path(struct IEP_MSG *iep_msg)
+{
+	IEP_REGB_LCDC_PATH_EN(iep_msg->base, iep_msg->lcdc_path_en);
+
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("//==write back or lcdc direct path config=====// \n\n");
+	IEP_DBG("sw_lcdc_path_en = %d;//lcdc direct path enable,c"
+		" model don't care this value\n\n", iep_msg->lcdc_path_en);
+#endif
+}
+
+int iep_probe_int(void *base)
+{
+	return ReadReg32(base, rIEP_INT) & 1;
+}
+
+void iep_config_frame_end_int_clr(void *base)
+{
+	IEP_REGB_FRAME_END_INT_CLR(base, 1);
+}
+
+void iep_config_frame_end_int_en(void *base)
+{
+	IEP_REGB_FRAME_END_INT_CLR(base, 1);
+	IEP_REGB_FRAME_END_INT_EN(base, 1);
+}
+
+static void iep_config_misc(struct IEP_MSG *iep_msg)
+{
+//	IEP_REGB_V_REVERSE_DISP();
+//	IEP_REGB_H_REVERSE_DISP();
+#ifdef IEP_PRINT_INFO
+	IEP_DBG("//==misc config==========================//\n\n");
+	IEP_DBG("sw_v_reverse_disp          = 0;\n");
+	IEP_DBG("sw_u_reverse_disp          = 0;\n\n");
+#endif
+}
+
+#define IEP_RESET_TIMEOUT   1000
+void iep_soft_rst(void *base)
+{
+	unsigned int rst_state = 0;
+	int i = 0;
+	WriteReg32(base, rIEP_SOFT_RST, 2);
+	WriteReg32(base, rIEP_SOFT_RST, 1);
+	while (i++ < IEP_RESET_TIMEOUT) {
+		rst_state = ReadReg32(base, IEP_STATUS);
+		if ((rst_state & 0x200) == 0x200) {
+			break;
+		}
+
+		udelay(1);
+	}
+	WriteReg32(base, IEP_SOFT_RST, 2);
+
+	if (i == IEP_RESET_TIMEOUT)
+		IEP_DBG("soft reset timeout.\n");
+}
+
+void iep_config_done(void *base)
+{
+	WriteReg32(base, rIEP_CONF_DONE, 1);
+}
+
+void iep_config_frm_start(void *base)
+{
+	IEP_REGB_FRM_START(base, 1);
+}
+
+struct iep_status iep_get_status(void *base)
+{
+	uint32_t sts_int = IEP_REGB_STATUS(base);
+	struct iep_status sts;
+
+	memcpy(&sts, &sts_int, 4);
+
+	return sts;
+}
+
+int iep_get_deinterlace_mode(void *base)
+{
+	int cfg = ReadReg32(base, IEP_CONFIG0);
+	return (cfg >> 8) & 0x7;
+}
+
+void iep_set_deinterlace_mode(int mode, void *base)
+{
+	int cfg;
+
+	if (mode > dein_mode_bypass) {
+		IEP_ERR("invalid deinterlace mode\n");
+		return;
+	}
+
+	cfg = ReadReg32(base, RAW_IEP_CONFIG0);
+	cfg = (cfg & (~(7 << 8))) | (mode << 8);
+	WriteReg32(base, IEP_CONFIG0, cfg);
+
+	//IEP_REGB_DIL_MODE(base, mode);
+}
+
+void iep_switch_input_address(void *base)
+{
+	u32 src_addr_yrgb  = ReadReg32(base, IEP_SRC_ADDR_YRGB);
+	u32 src_addr_cbcr  = ReadReg32(base, IEP_SRC_ADDR_CBCR);
+	u32 src_addr_cr    = ReadReg32(base, IEP_SRC_ADDR_CR);
+
+	u32 src_addr_y1    = ReadReg32(base, IEP_SRC_ADDR_Y1);
+	u32 src_addr_cbcr1 = ReadReg32(base, IEP_SRC_ADDR_CBCR1);
+	u32 src_addr_cr1   = ReadReg32(base, IEP_SRC_ADDR_CR1);
+
+	IEP_REGB_SRC_ADDR_YRGB(base, src_addr_y1);
+	IEP_REGB_SRC_ADDR_CBCR(base, src_addr_cbcr1);
+	IEP_REGB_SRC_ADDR_CR(base, src_addr_cr1);
+	IEP_REGB_SRC_ADDR_Y1(base, src_addr_yrgb);
+	IEP_REGB_SRC_ADDR_CBCR1(base, src_addr_cbcr);
+	IEP_REGB_SRC_ADDR_CR1(base, src_addr_cr);
+}
+
+static int iep_bufid_to_iova(iep_service_info *pservice, u8 *tbl,
+	int size, struct iep_reg *reg)
+{
+	int i;
+	int usr_fd = 0;
+	int offset = 0;
+
+	if (tbl == NULL || size <= 0) {
+		dev_err(pservice->iommu_dev, "input arguments invalidate\n");
+		return -1;
+	}
+
+	for (i = 0; i < size; i++) {
+		usr_fd = reg->reg[tbl[i]] & 0x3FF;
+		offset = reg->reg[tbl[i]] >> 10;
+		if (usr_fd != 0) {
+			int hdl;
+			int ret;
+			struct iep_mem_region *mem_region;
+
+			hdl = iep_iommu_import(pservice->iommu_info,
+					       reg->session, usr_fd);
+
+			mem_region = kzalloc(sizeof(struct iep_mem_region),
+				GFP_KERNEL);
+
+			if (mem_region == NULL) {
+				dev_err(pservice->iommu_dev,
+					"allocate memory for"
+					" iommu memory region failed\n");
+				iep_iommu_free(pservice->iommu_info,
+					       reg->session, hdl);
+				return -ENOMEM;
+			}
+
+			mem_region->hdl = hdl;
+
+			ret = iep_iommu_map_iommu(pservice->iommu_info,
+				reg->session, mem_region->hdl,
+				&mem_region->iova, &mem_region->len);
+			if (ret < 0) {
+				dev_err(pservice->iommu_dev,
+					"ion map iommu failed\n");
+				kfree(mem_region);
+				iep_iommu_free(pservice->iommu_info,
+					       reg->session, hdl);
+				return ret;
+			}
+
+			reg->reg[tbl[i]] = mem_region->iova + offset;
+			INIT_LIST_HEAD(&mem_region->reg_lnk);
+			list_add_tail(&mem_region->reg_lnk,
+				&reg->mem_region_list);
+		}
+	}
+
+	return 0;
+}
+
+static u8 addr_tbl_iep[] = {
+	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55
+};
+
+static int iep_reg_address_translate(iep_service_info *pservice, struct iep_reg *reg)
+{
+	return iep_bufid_to_iova(pservice, addr_tbl_iep, sizeof(addr_tbl_iep), reg);
+}
+
+/**
+ * generating a series of registers copy from iep message
+ */
+void iep_config(iep_session *session, struct IEP_MSG *iep_msg)
+{
+	struct iep_reg *reg = NULL;
+	int w;
+	int h;
+
+	reg = kzalloc(sizeof(*reg), GFP_KERNEL);
+	if (!reg)
+		return;
+	reg->session = session;
+	iep_msg->base = reg->reg;
+	atomic_set(&reg->session->done, 0);
+
+	INIT_LIST_HEAD(&reg->session_link);
+	INIT_LIST_HEAD(&reg->status_link);
+
+	INIT_LIST_HEAD(&reg->mem_region_list);
+
+	//write config
+	iep_config_src_size(iep_msg);
+	iep_config_dst_size(iep_msg);
+	iep_config_dst_width_tile(iep_msg); //not implement
+	iep_config_dst_fmt(iep_msg);
+	iep_config_src_fmt(iep_msg);
+	iep_config_scl(iep_msg);
+	iep_config_cg_order(iep_msg);
+
+	iep_config_cg(iep_msg);
+	iep_config_dde(iep_msg);            //not implement
+	iep_config_color_enh(iep_msg);      //not implement
+	iep_config_yuv_dns(iep_msg);
+	iep_config_dil(iep_msg);
+	iep_config_yuv_enh(iep_msg);
+	iep_config_rgb2yuv(iep_msg);
+	iep_config_yuv2rgb(iep_msg);
+	iep_config_dither_up(iep_msg);
+	iep_config_dither_down(iep_msg);
+	iep_config_glb_alpha(iep_msg);
+	iep_config_vir_line(iep_msg);
+	iep_config_src_addr(iep_msg);
+	iep_config_dst_addr(iep_msg);
+	iep_config_lcdc_path(iep_msg);
+	iep_config_misc(iep_msg);           //not implement
+
+	if (iep_msg->lcdc_path_en) {
+		reg->dpi_en     = true;
+		reg->act_width  = iep_msg->dst.act_w;
+		reg->act_height = iep_msg->dst.act_h;
+		reg->off_x      = iep_msg->off_x;
+		reg->off_y      = iep_msg->off_y;
+		reg->vir_width  = iep_msg->width;
+		reg->vir_height = iep_msg->height;
+		reg->layer      = iep_msg->layer;
+		reg->format     = iep_msg->dst.format;
+	} else {
+		reg->dpi_en     = false;
+	}
+
+	if (iep_service.iommu_dev) {
+		if (0 > iep_reg_address_translate(&iep_service, reg)) {
+			IEP_ERR("error: translate reg address failed\n");
+			kfree(reg);
+			return;
+		}
+	}
+
+	/* workaround for iommu enable case when 4k video input */
+	w = (iep_msg->src.act_w + 15) & (0xfffffff0);
+	h = (iep_msg->src.act_h + 15) & (0xfffffff0);
+	if (w > 1920 && iep_msg->src.format == IEP_FORMAT_YCbCr_420_SP)
+		reg->reg[33] = reg->reg[32] + w * h;
+
+	w = (iep_msg->dst.act_w + 15) & (0xfffffff0);
+	h = (iep_msg->dst.act_h + 15) & (0xfffffff0);
+	if (w > 1920 && iep_msg->dst.format == IEP_FORMAT_YCbCr_420_SP)
+		reg->reg[45] = reg->reg[44] + w * h;
+
+	mutex_lock(&iep_service.lock);
+
+	list_add_tail(&reg->status_link, &iep_service.waiting);
+	list_add_tail(&reg->session_link, &session->waiting);
+	mutex_unlock(&iep_service.lock);
+}
+
diff -Nupr a/drivers/video/rockchip/iep/hw_iep_reg.h b/drivers/video/rockchip/iep/hw_iep_reg.h
--- a/drivers/video/rockchip/iep/hw_iep_reg.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/hw_iep_reg.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,525 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef IEP_REGS_H
+#define IEP_REGS_H
+#include "hw_iep_config_addr.h"
+#include "iep.h"
+#include "iep_drv.h"
+
+struct iep_status {
+	uint32_t reserved0   : 1;
+	uint32_t scl_sts     : 1;
+	uint32_t dil_sts     : 1;
+	uint32_t reserved1   : 1;
+	uint32_t wyuv_sts    : 1;
+	uint32_t ryuv_sts    : 1;
+	uint32_t wrgb_sts    : 1;
+	uint32_t rrgb_sts    : 1;
+	uint32_t voi_sts     : 1;
+};
+
+#define      rIEP_CONFIG0      		         (IEP_BASE+IEP_CONFIG0)
+#define      rIEP_CONFIG1      		         (IEP_BASE+IEP_CONFIG1)
+
+#define      rIEP_STATUS              	     (IEP_BASE+IEP_STATUS)
+#define      rIEP_INT                 	     (IEP_BASE+IEP_INT)
+#define      rIEP_FRM_START         	     (IEP_BASE+IEP_FRM_START)
+#define      rIEP_SOFT_RST           	     (IEP_BASE+IEP_SOFT_RST)
+#define      rIEP_CONF_DONE                  (IEP_BASE+IEP_CONF_DONE)
+
+#define      rIEP_VIR_IMG_WIDTH        	     (IEP_BASE+IEP_VIR_IMG_WIDTH)
+
+#define      rIEP_IMG_SCL_FCT         	     (IEP_BASE+IEP_IMG_SCL_FCT)
+
+#define      rIEP_SRC_IMG_SIZE         	     (IEP_BASE+IEP_SRC_IMG_SIZE)
+#define      rIEP_DST_IMG_SIZE         	     (IEP_BASE+IEP_DST_IMG_SIZE)
+
+#define      rIEP_DST_IMG_WIDTH_TILE0  	     (IEP_BASE+IEP_DST_IMG_WIDTH_TILE0)
+#define      rIEP_DST_IMG_WIDTH_TILE1  	     (IEP_BASE+IEP_DST_IMG_WIDTH_TILE1)
+#define      rIEP_DST_IMG_WIDTH_TILE2  	     (IEP_BASE+IEP_DST_IMG_WIDTH_TILE2)
+#define      rIEP_DST_IMG_WIDTH_TILE3  	     (IEP_BASE+IEP_DST_IMG_WIDTH_TILE3)
+
+#define      rIEP_ENH_YUV_CNFG_0       	     (IEP_BASE+IEP_ENH_YUV_CNFG_0)
+#define      rIEP_ENH_YUV_CNFG_1       	     (IEP_BASE+IEP_ENH_YUV_CNFG_1)
+#define      rIEP_ENH_YUV_CNFG_2       	     (IEP_BASE+IEP_ENH_YUV_CNFG_2)
+#define      rIEP_ENH_RGB_CNFG        	     (IEP_BASE+IEP_ENH_RGB_CNFG)
+#define      rIEP_ENH_C_COE            	     (IEP_BASE+IEP_ENH_C_COE)
+
+#define      rIEP_SRC_ADDR_YRGB        	     (IEP_BASE+IEP_SRC_ADDR_YRGB)
+#define      rIEP_SRC_ADDR_CBCR              (IEP_BASE+IEP_SRC_ADDR_CBCR)
+#define      rIEP_SRC_ADDR_CR                (IEP_BASE+IEP_SRC_ADDR_CR)
+#define      rIEP_SRC_ADDR_Y1                (IEP_BASE+IEP_SRC_ADDR_Y1)
+#define      rIEP_SRC_ADDR_CBCR1             (IEP_BASE+IEP_SRC_ADDR_CBCR1)
+#define      rIEP_SRC_ADDR_CR1               (IEP_BASE+IEP_SRC_ADDR_CR1)
+#define      rIEP_SRC_ADDR_Y_ITEMP           (IEP_BASE+IEP_SRC_ADDR_Y_ITEMP)
+#define      rIEP_SRC_ADDR_CBCR_ITEMP        (IEP_BASE+IEP_SRC_ADDR_CBCR_ITEMP)
+#define      rIEP_SRC_ADDR_CR_ITEMP          (IEP_BASE+IEP_SRC_ADDR_CR_ITEMP)
+#define      rIEP_SRC_ADDR_Y_FTEMP           (IEP_BASE+IEP_SRC_ADDR_Y_FTEMP)
+#define      rIEP_SRC_ADDR_CBCR_FTEMP        (IEP_BASE+IEP_SRC_ADDR_CBCR_FTEMP)
+#define      rIEP_SRC_ADDR_CR_FTEMP          (IEP_BASE+IEP_SRC_ADDR_CR_FTEMP)
+
+#define      rIEP_DST_ADDR_YRGB        	     (IEP_BASE+IEP_DST_ADDR_YRGB)
+#define      rIEP_DST_ADDR_CBCR              (IEP_BASE+IEP_DST_ADDR_CBCR)
+#define      rIEP_DST_ADDR_CR                (IEP_BASE+IEP_DST_ADDR_CR)
+#define      rIEP_DST_ADDR_Y1                (IEP_BASE+IEP_DST_ADDR_Y1)
+#define      rIEP_DST_ADDR_CBCR1             (IEP_BASE+IEP_DST_ADDR_CBCR1)
+#define      rIEP_DST_ADDR_CR1               (IEP_BASE+IEP_DST_ADDR_CR1)
+#define      rIEP_DST_ADDR_Y_ITEMP           (IEP_BASE+IEP_DST_ADDR_Y_ITEMP)
+#define      rIEP_DST_ADDR_CBCR_ITEMP        (IEP_BASE+IEP_DST_ADDR_CBCR_ITEMP)
+#define      rIEP_DST_ADDR_CR_ITEMP          (IEP_BASE+IEP_DST_ADDR_CR_ITEMP)
+#define      rIEP_DST_ADDR_Y_FTEMP           (IEP_BASE+IEP_DST_ADDR_Y_FTEMP)
+#define      rIEP_DST_ADDR_CBCR_FTEMP        (IEP_BASE+IEP_DST_ADDR_CBCR_FTEMP)
+#define      rIEP_DST_ADDR_CR_FTEMP          (IEP_BASE+IEP_DST_ADDR_CR_FTEMP)
+
+#define      rIEP_DIL_MTN_TAB0               (IEP_BASE+IEP_DIL_MTN_TAB0)
+#define      rIEP_DIL_MTN_TAB1               (IEP_BASE+IEP_DIL_MTN_TAB1)
+#define      rIEP_DIL_MTN_TAB2               (IEP_BASE+IEP_DIL_MTN_TAB2)
+#define      rIEP_DIL_MTN_TAB3               (IEP_BASE+IEP_DIL_MTN_TAB3)
+#define      rIEP_DIL_MTN_TAB4               (IEP_BASE+IEP_DIL_MTN_TAB4)
+#define      rIEP_DIL_MTN_TAB5               (IEP_BASE+IEP_DIL_MTN_TAB5)
+#define      rIEP_DIL_MTN_TAB6               (IEP_BASE+IEP_DIL_MTN_TAB6)
+#define      rIEP_DIL_MTN_TAB7               (IEP_BASE+IEP_DIL_MTN_TAB7)
+
+#define      rIEP_ENH_CG_TAB                 (IEP_BASE+IEP_ENH_CG_TAB)
+
+#define      rIEP_YUV_DNS_CRCT_TEMP          (IEP_BASE+IEP_YUV_DNS_CRCT_TEMP)
+#define      rIEP_YUV_DNS_CRCT_SPAT          (IEP_BASE+IEP_YUV_DNS_CRCT_SPAT)
+
+#define      rIEP_ENH_DDE_COE0               (IEP_BASE+IEP_ENH_DDE_COE0)
+#define      rIEP_ENH_DDE_COE1               (IEP_BASE+IEP_ENH_DDE_COE1)
+
+#define      RAW_rIEP_CONFIG0                (IEP_BASE+RAW_IEP_CONFIG0)
+#define      RAW_rIEP_CONFIG1      		     (IEP_BASE+RAW_IEP_CONFIG1)
+#define      RAW_rIEP_VIR_IMG_WIDTH          (IEP_BASE+RAW_IEP_VIR_IMG_WIDTH)
+
+#define      RAW_rIEP_IMG_SCL_FCT      	     (IEP_BASE+RAW_IEP_IMG_SCL_FCT)
+
+#define      RAW_rIEP_SRC_IMG_SIZE      	 (IEP_BASE+RAW_IEP_SRC_IMG_SIZE)
+#define      RAW_rIEP_DST_IMG_SIZE      	 (IEP_BASE+RAW_IEP_DST_IMG_SIZE)
+
+#define      RAW_rIEP_ENH_YUV_CNFG_0         (IEP_BASE+RAW_IEP_ENH_YUV_CNFG_0)
+#define      RAW_rIEP_ENH_YUV_CNFG_1         (IEP_BASE+RAW_IEP_ENH_YUV_CNFG_1)
+#define      RAW_rIEP_ENH_YUV_CNFG_2         (IEP_BASE+RAW_IEP_ENH_YUV_CNFG_2)
+#define      RAW_rIEP_ENH_RGB_CNFG           (IEP_BASE+RAW_IEP_ENH_RGB_CNFG)
+
+#define      rIEP_CG_TAB_ADDR                 (IEP_BASE+0x0100)
+
+/*-----------------------------------------------------------------
+//reg bit operation definition
+-----------------------------------------------------------------*/
+/*iep_config0*/
+#define     IEP_REGB_V_REVERSE_DISP_Z(x)      (((x)&0x1 ) << 31 )
+#define     IEP_REGB_H_REVERSE_DISP_Z(x)      (((x)&0x1 ) << 30 )
+#define     IEP_REGB_SCL_EN_Z(x)              (((x)&0x1 ) << 28 )
+#define     IEP_REGB_SCL_SEL_Z(x)             (((x)&0x3 ) << 26 )
+#define     IEP_REGB_SCL_UP_COE_SEL_Z(x)      (((x)&0x3 ) << 24 )
+#define     IEP_REGB_DIL_EI_SEL_Z(x)          (((x)&0x1 ) << 23 )
+#define     IEP_REGB_DIL_EI_RADIUS_Z(x)       (((x)&0x3 ) << 21 )
+#define     IEP_REGB_CON_GAM_ORDER_Z(x)       (((x)&0x1 ) << 20 )
+#define     IEP_REGB_RGB_ENH_SEL_Z(x)         (((x)&0x3 ) << 18 )
+#define     IEP_REGB_RGB_CON_GAM_EN_Z(x)      (((x)&0x1 ) << 17 )
+#define     IEP_REGB_RGB_COLOR_ENH_EN_Z(x)    (((x)&0x1 ) << 16 )
+#define     IEP_REGB_DIL_EI_SMOOTH_Z(x)       (((x)&0x1 ) << 15 )
+#define     IEP_REGB_YUV_ENH_EN_Z(x)          (((x)&0x1 ) << 14 )
+#define     IEP_REGB_YUV_DNS_EN_Z(x)          (((x)&0x1 ) << 13 )
+#define     IEP_REGB_DIL_EI_MODE_Z(x)         (((x)&0x1 ) << 12 )
+#define     IEP_REGB_DIL_HF_EN_Z(x)           (((x)&0x1 ) << 11 )
+#define     IEP_REGB_DIL_MODE_Z(x)            (((x)&0x7 ) << 8  )
+#define     IEP_REGB_DIL_HF_FCT_Z(x)          (((x)&0x7F) << 1  )
+#define     IEP_REGB_LCDC_PATH_EN_Z(x)        (((x)&0x1 ) << 0  )
+
+/*iep_conig1*/
+#define     IEP_REGB_GLB_ALPHA_Z(x)           (((x)&0xff) << 24 )
+#define     IEP_REGB_RGB2YUV_INPUT_CLIP_Z(x)  (((x)&0x1 ) << 23 )
+#define     IEP_REGB_YUV2RGB_INPUT_CLIP_Z(x)  (((x)&0x1 ) << 22 )
+#define     IEP_REGB_RGB_TO_YUV_EN_Z(x)       (((x)&0x1 ) << 21 )
+#define     IEP_REGB_YUV_TO_RGB_EN_Z(x)       (((x)&0x1 ) << 20 )
+#define     IEP_REGB_RGB2YUV_COE_SEL_Z(x)     (((x)&0x3 ) << 18 )
+#define     IEP_REGB_YUV2RGB_COE_SEL_Z(x)     (((x)&0x3 ) << 16 )
+#define     IEP_REGB_DITHER_DOWN_EN_Z(x)      (((x)&0x1 ) << 15 )
+#define     IEP_REGB_DITHER_UP_EN_Z(x)        (((x)&0x1 ) << 14 )
+#define     IEP_REGB_DST_YUV_SWAP_Z(x)        (((x)&0x3 ) << 12 )
+#define     IEP_REGB_DST_RGB_SWAP_Z(x)        (((x)&0x3 ) << 10 )
+#define     IEP_REGB_DST_FMT_Z(x)             (((x)&0x3 ) << 8  )
+#define     IEP_REGB_SRC_YUV_SWAP_Z(x)        (((x)&0x3 ) << 4  )
+#define     IEP_REGB_SRC_RGB_SWAP_Z(x)        (((x)&0x3 ) << 2  )
+#define     IEP_REGB_SRC_FMT_Z(x)             (((x)&0x3 ) << 0  )
+
+/*iep_int*/
+#define     IEP_REGB_FRAME_END_INT_CLR_Z(x)   (((x)&0x1 ) << 16 )
+#define     IEP_REGB_FRAME_END_INT_EN_Z(x)    (((x)&0x1 ) << 8  )
+
+/*frm_start*/
+#define     IEP_REGB_FRM_START_Z(x)           (((x)&0x01 ) << 0 )
+
+/*soft_rst*/
+#define     IEP_REGB_SOFT_RST_Z(x)            (((x)&0x01 ) << 0 )
+
+/*iep_vir_img_width*/
+#define     IEP_REGB_DST_VIR_LINE_WIDTH_Z(x)  (((x)&0xffff) << 16 )
+#define     IEP_REGB_SRC_VIR_LINE_WIDTH_Z(x)  (((x)&0xffff) << 0  )
+
+/*iep_img_scl_fct*/
+#define     IEP_REGB_SCL_VRT_FCT_Z(x)         (((x)&0xffff) << 16 )
+#define     IEP_REGB_SCL_HRZ_FCT_Z(x)         (((x)&0xffff) << 0  )
+
+/*iep_src_img_size*/
+#define     IEP_REGB_SRC_IMG_HEIGHT_Z(x)      (((x)&0x1fff) << 16 )
+#define     IEP_REGB_SRC_IMG_WIDTH_Z(x)       (((x)&0x1fff) << 0  )
+/*iep_dst_img_size*/
+#define     IEP_REGB_DST_IMG_HEIGHT_Z(x)      (((x)&0x1fff) << 16 )
+#define     IEP_REGB_DST_IMG_WIDTH_Z(x)       (((x)&0x1fff) << 0  )
+
+/*dst_img_width_tile0/1/2/3*/
+#define     IEP_REGB_DST_IMG_WIDTH_TILE0_Z(x) (((x)&0x3ff ) << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE1_Z(x) (((x)&0x3ff ) << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE2_Z(x) (((x)&0x3ff ) << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE3_Z(x) (((x)&0x3ff ) << 0  )
+
+/*iep_enh_yuv_cnfg0*/
+#define     IEP_REGB_SAT_CON_Z(x)             (((x)&0x1ff ) << 16 )
+#define     IEP_REGB_CONTRAST_Z(x)            (((x)&0xff ) <<  8  )
+#define     IEP_REGB_BRIGHTNESS_Z(x)          (((x)&0x3f ) <<  0  )
+/*iep_enh_yuv_cnfg1*/
+#define     IEP_REGB_COS_HUE_Z(x)             (((x)&0xff ) <<  8  )
+#define     IEP_REGB_SIN_HUE_Z(x)             (((x)&0xff ) <<  0  )
+/*iep_enh_yuv_cnfg2*/
+#define     IEP_REGB_VIDEO_MODE_Z(x)          (((x)&0x3  ) <<  24 )
+#define     IEP_REGB_COLOR_BAR_V_Z(x)         (((x)&0xff ) <<  16 )
+#define     IEP_REGB_COLOR_BAR_U_Z(x)         (((x)&0xff ) <<  8  )
+#define     IEP_REGB_COLOR_BAR_Y_Z(x)         (((x)&0xff ) <<  0  )
+/*iep_enh_rgb_cnfg*/
+#define     IEP_REGB_YUV_DNS_LUMA_SPAT_SEL_Z(x)   (((x)&0x3  ) <<  30 )
+#define     IEP_REGB_YUV_DNS_LUMA_TEMP_SEL_Z(x)   (((x)&0x3  ) <<  28 )
+#define     IEP_REGB_YUV_DNS_CHROMA_SPAT_SEL_Z(x) (((x)&0x3  ) <<  26 )
+#define     IEP_REGB_YUV_DNS_CHROMA_TEMP_SEL_Z(x) (((x)&0x3  ) <<  24 )
+#define     IEP_REGB_ENH_THRESHOLD_Z(x)       (((x)&0xff ) <<  16 )
+#define     IEP_REGB_ENH_ALPHA_Z(x)           (((x)&0x3f ) <<  8  )
+#define     IEP_REGB_ENH_RADIUS_Z(x)          (((x)&0x3  ) <<  0  )
+/*iep_enh_c_coe*/
+#define     IEP_REGB_ENH_C_COE_Z(x)           (((x)&0x7f ) <<  0  )
+/*dil_mtn_tab*/
+#define     IEP_REGB_DIL_MTN_TAB0_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB0_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB0_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB0_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB1_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB1_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB1_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB1_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB2_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB2_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB2_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB2_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB3_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB3_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB3_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB3_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB4_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB4_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB4_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB4_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB5_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB5_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB5_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB5_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB6_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB6_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB6_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB6_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB7_0_Z(x)      (((x)&0x7f ) <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB7_1_Z(x)      (((x)&0x7f ) <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB7_2_Z(x)      (((x)&0x7f ) <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB7_3_Z(x)      (((x)&0x7f ) <<  24 )
+
+/*iep_config0*/
+#define     IEP_REGB_V_REVERSE_DISP_Y      (0x1  << 31 )
+#define     IEP_REGB_H_REVERSE_DISP_Y      (0x1  << 30 )
+#define     IEP_REGB_SCL_EN_Y              (0x1  << 28 )
+#define     IEP_REGB_SCL_SEL_Y             (0x3  << 26 )
+#define     IEP_REGB_SCL_UP_COE_SEL_Y      (0x3  << 24 )
+#define     IEP_REGB_DIL_EI_SEL_Y          (0x1  << 23 )
+#define     IEP_REGB_DIL_EI_RADIUS_Y       (0x3  << 21 )
+#define     IEP_REGB_CON_GAM_ORDER_Y       (0x1  << 20 )
+#define     IEP_REGB_RGB_ENH_SEL_Y         (0x3  << 18 )
+#define     IEP_REGB_RGB_CON_GAM_EN_Y      (0x1  << 17 )
+#define     IEP_REGB_RGB_COLOR_ENH_EN_Y    (0x1  << 16 )
+#define     IEP_REGB_DIL_EI_SMOOTH_Y       (0x1  << 15 )
+#define     IEP_REGB_YUV_ENH_EN_Y          (0x1  << 14 )
+#define     IEP_REGB_YUV_DNS_EN_Y          (0x1  << 13 )
+#define     IEP_REGB_DIL_EI_MODE_Y         (0x1  << 12 )
+#define     IEP_REGB_DIL_HF_EN_Y           (0x1  << 11 )
+#define     IEP_REGB_DIL_MODE_Y            (0x7  << 8  )
+#define     IEP_REGB_DIL_HF_FCT_Y          (0x7F << 1  )
+#define     IEP_REGB_LCDC_PATH_EN_Y        (0x1  << 0  )
+
+/*iep_conig1*/
+#define     IEP_REGB_GLB_ALPHA_Y           (0xff << 24 )
+#define     IEP_REGB_RGB2YUV_INPUT_CLIP_Y  (0x1  << 23 )
+#define     IEP_REGB_YUV2RGB_INPUT_CLIP_Y  (0x1  << 22 )
+#define     IEP_REGB_RGB_TO_YUV_EN_Y       (0x1  << 21 )
+#define     IEP_REGB_YUV_TO_RGB_EN_Y       (0x1  << 20 )
+#define     IEP_REGB_RGB2YUV_COE_SEL_Y     (0x3  << 18 )
+#define     IEP_REGB_YUV2RGB_COE_SEL_Y     (0x3  << 16 )
+#define     IEP_REGB_DITHER_DOWN_EN_Y      (0x1  << 15 )
+#define     IEP_REGB_DITHER_UP_EN_Y        (0x1  << 14 )
+#define     IEP_REGB_DST_YUV_SWAP_Y        (0x3  << 12 )
+#define     IEP_REGB_DST_RGB_SWAP_Y        (0x3  << 10 )
+#define     IEP_REGB_DST_FMT_Y             (0x3  << 8  )
+#define     IEP_REGB_SRC_YUV_SWAP_Y        (0x3  << 4  )
+#define     IEP_REGB_SRC_RGB_SWAP_Y        (0x3  << 2  )
+#define     IEP_REGB_SRC_FMT_Y             (0x3  << 0  )
+
+/*iep_int*/
+#define     IEP_REGB_FRAME_END_INT_CLR_Y   (0x1  << 16 )
+#define     IEP_REGB_FRAME_END_INT_EN_Y    (0x1  << 8  )
+
+/*frm_start*/
+#define     IEP_REGB_FRM_START_Y           (0x1  << 0  )
+
+/*soft_rst*/
+#define     IEP_REGB_SOFT_RST_Y            (0x1  << 0  )
+
+/*iep_vir_img_width*/
+#define     IEP_REGB_DST_VIR_LINE_WIDTH_Y  (0xffff << 16 )
+#define     IEP_REGB_SRC_VIR_LINE_WIDTH_Y  (0xffff << 0  )
+
+/*iep_img_scl_fct*/
+#define     IEP_REGB_SCL_VRT_FCT_Y         (0xffff << 16 )
+#define     IEP_REGB_SCL_HRZ_FCT_Y         (0xffff << 0  )
+
+/*iep_src_img_size*/
+#define     IEP_REGB_SRC_IMG_HEIGHT_Y      (0x1fff << 16 )
+#define     IEP_REGB_SRC_IMG_WIDTH_Y       (0x1fff << 0  )
+/*iep_dst_img_size*/
+#define     IEP_REGB_DST_IMG_HEIGHT_Y      (0x1fff << 16 )
+#define     IEP_REGB_DST_IMG_WIDTH_Y       (0x1fff << 0  )
+
+/*dst_img_width_tile0/1/2/3*/
+#define     IEP_REGB_DST_IMG_WIDTH_TILE0_Y (0x3ff  << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE1_Y (0x3ff  << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE2_Y (0x3ff  << 0  )
+#define     IEP_REGB_DST_IMG_WIDTH_TILE3_Y (0x3ff  << 0  )
+
+/*iep_enh_yuv_cnfg0*/
+#define     IEP_REGB_SAT_CON_Y             (0x1ff  <<  16)
+#define     IEP_REGB_CONTRAST_Y            (0xff  <<  8 )
+#define     IEP_REGB_BRIGHTNESS_Y          (0x3f  <<  0 )
+/*iep_enh_yuv_cnfg1*/
+#define     IEP_REGB_COS_HUE_Y             (0xff  <<  8 )
+#define     IEP_REGB_SIN_HUE_Y             (0xff  <<  0 )
+/*iep_enh_yuv_cnfg2*/
+#define     IEP_REGB_VIDEO_MODE_Y          (0x3   <<  24)
+#define     IEP_REGB_COLOR_BAR_V_Y         (0xff  <<  16)
+#define     IEP_REGB_COLOR_BAR_U_Y         (0xff  <<  8 )
+#define     IEP_REGB_COLOR_BAR_Y_Y         (0xff  <<  0 )
+/*iep_enh_rgb_cnfg*/
+#define     IEP_REGB_YUV_DNS_LUMA_SPAT_SEL_Y (0x3   <<  30)
+#define     IEP_REGB_YUV_DNS_LUMA_TEMP_SEL_Y (0x3   <<  28)
+#define     IEP_REGB_YUV_DNS_CHROMA_SPAT_SEL_Y (0x3  <<  26)
+#define     IEP_REGB_YUV_DNS_CHROMA_TEMP_SEL_Y (0x3  <<  24)
+#define     IEP_REGB_ENH_THRESHOLD_Y       (0xff  <<  16)
+#define     IEP_REGB_ENH_ALPHA_Y           (0x3f  <<  8 )
+#define     IEP_REGB_ENH_RADIUS_Y          (0x3   <<  0 )
+/*iep_enh_c_coe*/
+#define     IEP_REGB_ENH_C_COE_Y           (0x7f  <<  0 )
+/*dil_mtn_tab*/
+#define     IEP_REGB_DIL_MTN_TAB0_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB0_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB0_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB0_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB1_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB1_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB1_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB1_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB2_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB2_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB2_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB2_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB3_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB3_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB3_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB3_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB4_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB4_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB4_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB4_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB5_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB5_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB5_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB5_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB6_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB6_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB6_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB6_3_Y      (0x7f  <<  24 )
+
+#define     IEP_REGB_DIL_MTN_TAB7_0_Y      (0x7f  <<  0  )
+#define     IEP_REGB_DIL_MTN_TAB7_1_Y      (0x7f  <<  8  )
+#define     IEP_REGB_DIL_MTN_TAB7_2_Y      (0x7f  <<  16 )
+#define     IEP_REGB_DIL_MTN_TAB7_3_Y      (0x7f  <<  24 )
+
+/*-----------------------------------------------------------------
+MaskRegBits32(addr, y, z),Register configure
+-----------------------------------------------------------------*/
+/*iep_config0*/
+#define     IEP_REGB_V_REVERSE_DISP(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_V_REVERSE_DISP_Y,IEP_REGB_V_REVERSE_DISP_Z(x))
+#define     IEP_REGB_H_REVERSE_DISP(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_H_REVERSE_DISP_Y,IEP_REGB_H_REVERSE_DISP_Z(x))
+#define     IEP_REGB_SCL_EN(base, x)              ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_SCL_EN_Y,IEP_REGB_SCL_EN_Z(x))
+#define     IEP_REGB_SCL_SEL(base, x)             ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_SCL_SEL_Y,IEP_REGB_SCL_SEL_Z(x))
+#define     IEP_REGB_SCL_UP_COE_SEL(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_SCL_UP_COE_SEL_Y,IEP_REGB_SCL_UP_COE_SEL_Z(x))
+#define     IEP_REGB_DIL_EI_SEL(base, x)          ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_EI_SEL_Y,IEP_REGB_DIL_EI_SEL_Z(x))
+#define     IEP_REGB_DIL_EI_RADIUS(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_EI_RADIUS_Y,IEP_REGB_DIL_EI_RADIUS_Z(x))
+#define     IEP_REGB_CON_GAM_ORDER(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_CON_GAM_ORDER_Y,IEP_REGB_CON_GAM_ORDER_Z(x))
+#define     IEP_REGB_RGB_ENH_SEL(base, x)         ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_RGB_ENH_SEL_Y,IEP_REGB_RGB_ENH_SEL_Z(x))
+#define     IEP_REGB_RGB_CON_GAM_EN(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_RGB_CON_GAM_EN_Y,IEP_REGB_RGB_CON_GAM_EN_Z(x))
+#define     IEP_REGB_RGB_COLOR_ENH_EN(base, x)    ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_RGB_COLOR_ENH_EN_Y,IEP_REGB_RGB_COLOR_ENH_EN_Z(x))
+#define     IEP_REGB_DIL_EI_SMOOTH(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_EI_SMOOTH_Y,IEP_REGB_DIL_EI_SMOOTH_Z(x))
+#define     IEP_REGB_YUV_ENH_EN(base, x)          ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_YUV_ENH_EN_Y,IEP_REGB_YUV_ENH_EN_Z(x))
+#define     IEP_REGB_YUV_DNS_EN(base, x)          ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_YUV_DNS_EN_Y,IEP_REGB_YUV_DNS_EN_Z(x))
+#define     IEP_REGB_DIL_EI_MODE(base, x)         ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_EI_MODE_Y,IEP_REGB_DIL_EI_MODE_Z(x))
+#define     IEP_REGB_DIL_HF_EN(base, x)           ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_HF_EN_Y,IEP_REGB_DIL_HF_EN_Z(x))
+#define     IEP_REGB_DIL_MODE(base, x)            ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_MODE_Y,IEP_REGB_DIL_MODE_Z(x))
+#define     IEP_REGB_DIL_HF_FCT(base, x)          ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_DIL_HF_FCT_Y,IEP_REGB_DIL_HF_FCT_Z(x))
+#define     IEP_REGB_LCDC_PATH_EN(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG0,rIEP_CONFIG0,IEP_REGB_LCDC_PATH_EN_Y,IEP_REGB_LCDC_PATH_EN_Z(x))
+
+/*iep_conig1*/
+#define     IEP_REGB_GLB_ALPHA(base, x)           ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_GLB_ALPHA_Y,IEP_REGB_GLB_ALPHA_Z(x))
+#define     IEP_REGB_RGB2YUV_INPUT_CLIP(base, x)  ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_RGB2YUV_INPUT_CLIP_Y,IEP_REGB_RGB2YUV_INPUT_CLIP_Z(x))
+#define     IEP_REGB_YUV2RGB_INPUT_CLIP(base, x)  ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_YUV2RGB_INPUT_CLIP_Y,IEP_REGB_YUV2RGB_INPUT_CLIP_Z(x))
+#define     IEP_REGB_RGB_TO_YUV_EN(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_RGB_TO_YUV_EN_Y,IEP_REGB_RGB_TO_YUV_EN_Z(x))
+#define     IEP_REGB_YUV_TO_RGB_EN(base, x)       ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_YUV_TO_RGB_EN_Y,IEP_REGB_YUV_TO_RGB_EN_Z(x))
+#define     IEP_REGB_RGB2YUV_COE_SEL(base, x)     ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_RGB2YUV_COE_SEL_Y,IEP_REGB_RGB2YUV_COE_SEL_Z(x))
+#define     IEP_REGB_YUV2RGB_COE_SEL(base, x)     ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_YUV2RGB_COE_SEL_Y,IEP_REGB_YUV2RGB_COE_SEL_Z(x))
+#define     IEP_REGB_DITHER_DOWN_EN(base, x)      ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DITHER_DOWN_EN_Y,IEP_REGB_DITHER_DOWN_EN_Z(x))
+#define     IEP_REGB_DITHER_UP_EN(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DITHER_UP_EN_Y,IEP_REGB_DITHER_UP_EN_Z(x))
+#define     IEP_REGB_DST_YUV_SWAP(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DST_YUV_SWAP_Y,IEP_REGB_DST_YUV_SWAP_Z(x))
+#define     IEP_REGB_DST_RGB_SWAP(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DST_RGB_SWAP_Y,IEP_REGB_DST_RGB_SWAP_Z(x))
+#define     IEP_REGB_DST_FMT(base, x)             ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_DST_FMT_Y,IEP_REGB_DST_FMT_Z(x))
+#define     IEP_REGB_SRC_YUV_SWAP(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_SRC_YUV_SWAP_Y,IEP_REGB_SRC_YUV_SWAP_Z(x))
+#define     IEP_REGB_SRC_RGB_SWAP(base, x)        ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_SRC_RGB_SWAP_Y,IEP_REGB_SRC_RGB_SWAP_Z(x))
+#define     IEP_REGB_SRC_FMT(base, x)             ConfRegBits32(base, RAW_rIEP_CONFIG1,rIEP_CONFIG1,IEP_REGB_SRC_FMT_Y,IEP_REGB_SRC_FMT_Z(x))
+
+/*iep_int*/
+#define     IEP_REGB_FRAME_END_INT_CLR(base, x)   MaskRegBits32(base, rIEP_INT,IEP_REGB_FRAME_END_INT_CLR_Y,IEP_REGB_FRAME_END_INT_CLR_Z(x))
+#define     IEP_REGB_FRAME_END_INT_EN(base, x)    MaskRegBits32(base, rIEP_INT,IEP_REGB_FRAME_END_INT_EN_Y,IEP_REGB_FRAME_END_INT_EN_Z(x))
+
+/*frm_start*/
+#define     IEP_REGB_FRM_START(base, x)           WriteReg32(base, rIEP_FRM_START,x)
+
+/*soft_rst*/
+#define     IEP_REGB_SOFT_RST(base, x)            WriteReg32(base, rIEP_SOFT_RST,x)
+
+/*iep_vir_img_width*/
+#define     IEP_REGB_DST_VIR_LINE_WIDTH(base, x)  ConfRegBits32(base, RAW_rIEP_VIR_IMG_WIDTH,rIEP_VIR_IMG_WIDTH,IEP_REGB_DST_VIR_LINE_WIDTH_Y,IEP_REGB_DST_VIR_LINE_WIDTH_Z(x))
+#define     IEP_REGB_SRC_VIR_LINE_WIDTH(base, x)  ConfRegBits32(base, RAW_rIEP_VIR_IMG_WIDTH,rIEP_VIR_IMG_WIDTH,IEP_REGB_SRC_VIR_LINE_WIDTH_Y,IEP_REGB_SRC_VIR_LINE_WIDTH_Z(x))
+
+/*iep_img_scl_fct*/
+#define     IEP_REGB_SCL_VRT_FCT(base, x)         ConfRegBits32(base, RAW_rIEP_IMG_SCL_FCT,rIEP_IMG_SCL_FCT,IEP_REGB_SCL_VRT_FCT_Y,IEP_REGB_SCL_VRT_FCT_Z(x))
+#define     IEP_REGB_SCL_HRZ_FCT(base, x)         ConfRegBits32(base, RAW_rIEP_IMG_SCL_FCT,rIEP_IMG_SCL_FCT,IEP_REGB_SCL_HRZ_FCT_Y,IEP_REGB_SCL_HRZ_FCT_Z(x))
+
+/*iep_src_img_size*/
+#define     IEP_REGB_SRC_IMG_HEIGHT(base, x)      ConfRegBits32(base, RAW_rIEP_SRC_IMG_SIZE,rIEP_SRC_IMG_SIZE,IEP_REGB_SRC_IMG_HEIGHT_Y,IEP_REGB_SRC_IMG_HEIGHT_Z(x))
+#define     IEP_REGB_SRC_IMG_WIDTH(base, x)       ConfRegBits32(base, RAW_rIEP_SRC_IMG_SIZE,rIEP_SRC_IMG_SIZE,IEP_REGB_SRC_IMG_WIDTH_Y,IEP_REGB_SRC_IMG_WIDTH_Z(x))
+//iep_dst_img_size
+#define     IEP_REGB_DST_IMG_HEIGHT(base, x)      ConfRegBits32(base, RAW_rIEP_DST_IMG_SIZE,rIEP_DST_IMG_SIZE,IEP_REGB_DST_IMG_HEIGHT_Y,IEP_REGB_DST_IMG_HEIGHT_Z(x))
+#define     IEP_REGB_DST_IMG_WIDTH(base, x)       ConfRegBits32(base, RAW_rIEP_DST_IMG_SIZE,rIEP_DST_IMG_SIZE,IEP_REGB_DST_IMG_WIDTH_Y,IEP_REGB_DST_IMG_WIDTH_Z(x))
+
+/*dst_img_width_tile0/1/2/3*/
+#define     IEP_REGB_DST_IMG_WIDTH_TILE0(base, x) WriteReg32(base, rIEP_DST_IMG_WIDTH_TILE0,x)
+#define     IEP_REGB_DST_IMG_WIDTH_TILE1(base, x) WriteReg32(base, rIEP_DST_IMG_WIDTH_TILE1,x)
+#define     IEP_REGB_DST_IMG_WIDTH_TILE2(base, x) WriteReg32(base, rIEP_DST_IMG_WIDTH_TILE2,x)
+#define     IEP_REGB_DST_IMG_WIDTH_TILE3(base, x) WriteReg32(base, rIEP_DST_IMG_WIDTH_TILE3,x)
+
+/*iep_enh_yuv_cnfg0*/
+#define     IEP_REGB_SAT_CON(base, x)             ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_0,rIEP_ENH_YUV_CNFG_0,IEP_REGB_SAT_CON_Y,IEP_REGB_SAT_CON_Z(x))
+#define     IEP_REGB_CONTRAST(base, x)            ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_0,rIEP_ENH_YUV_CNFG_0,IEP_REGB_CONTRAST_Y,IEP_REGB_CONTRAST_Z(x))
+#define     IEP_REGB_BRIGHTNESS(base, x)          ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_0,rIEP_ENH_YUV_CNFG_0,IEP_REGB_BRIGHTNESS_Y,IEP_REGB_BRIGHTNESS_Z(x))
+/*iep_enh_yuv_cnfg1*/
+#define     IEP_REGB_COS_HUE(base, x)             ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_1,rIEP_ENH_YUV_CNFG_1,IEP_REGB_COS_HUE_Y,IEP_REGB_COS_HUE_Z(x))
+#define     IEP_REGB_SIN_HUE(base, x)             ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_1,rIEP_ENH_YUV_CNFG_1,IEP_REGB_SIN_HUE_Y,IEP_REGB_SIN_HUE_Z(x))
+/*iep_enh_yuv_cnfg2*/
+#define     IEP_REGB_VIDEO_MODE(base, x)          ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_2,rIEP_ENH_YUV_CNFG_2,IEP_REGB_VIDEO_MODE_Y,IEP_REGB_VIDEO_MODE_Z(x))
+#define     IEP_REGB_COLOR_BAR_V(base, x)         ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_2,rIEP_ENH_YUV_CNFG_2,IEP_REGB_COLOR_BAR_V_Y,IEP_REGB_COLOR_BAR_V_Z(x))
+#define     IEP_REGB_COLOR_BAR_U(base, x)         ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_2,rIEP_ENH_YUV_CNFG_2,IEP_REGB_COLOR_BAR_U_Y,IEP_REGB_COLOR_BAR_U_Z(x))
+#define     IEP_REGB_COLOR_BAR_Y(base, x)         ConfRegBits32(base, RAW_rIEP_ENH_YUV_CNFG_2,rIEP_ENH_YUV_CNFG_2,IEP_REGB_COLOR_BAR_Y_Y,IEP_REGB_COLOR_BAR_Y_Z(x))
+/*iep_enh_rgb_cnfg*/
+#define     IEP_REGB_YUV_DNS_LUMA_SPAT_SEL(base, x) ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_YUV_DNS_LUMA_SPAT_SEL_Y,IEP_REGB_YUV_DNS_LUMA_SPAT_SEL_Z(x))
+#define     IEP_REGB_YUV_DNS_LUMA_TEMP_SEL(base, x) ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_YUV_DNS_LUMA_TEMP_SEL_Y,IEP_REGB_YUV_DNS_LUMA_TEMP_SEL_Z(x))
+#define     IEP_REGB_YUV_DNS_CHROMA_SPAT_SEL(base, x) ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_YUV_DNS_CHROMA_SPAT_SEL_Y,IEP_REGB_YUV_DNS_CHROMA_SPAT_SEL_Z(x))
+#define     IEP_REGB_YUV_DNS_CHROMA_TEMP_SEL(base, x) ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_YUV_DNS_CHROMA_TEMP_SEL_Y,IEP_REGB_YUV_DNS_CHROMA_TEMP_SEL_Z(x))
+#define     IEP_REGB_ENH_THRESHOLD(base, x)       ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_ENH_THRESHOLD_Y,IEP_REGB_ENH_THRESHOLD_Z(x))
+#define     IEP_REGB_ENH_ALPHA(base, x)           ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_ENH_ALPHA_Y,IEP_REGB_ENH_ALPHA_Z(x))
+#define     IEP_REGB_ENH_RADIUS(base, x)          ConfRegBits32(base, RAW_rIEP_ENH_RGB_CNFG,rIEP_ENH_RGB_CNFG,IEP_REGB_ENH_RADIUS_Y,IEP_REGB_ENH_RADIUS_Z(x))
+/*iep_enh_c_coe*/
+#define     IEP_REGB_ENH_C_COE(base, x)           WriteReg32(base, rIEP_ENH_C_COE,x)
+/*src_addr*/
+#define     IEP_REGB_SRC_ADDR_YRGB(base, x)       WriteReg32(base, rIEP_SRC_ADDR_YRGB, x)
+#define     IEP_REGB_SRC_ADDR_CBCR(base, x)       WriteReg32(base, rIEP_SRC_ADDR_CBCR, x)
+#define     IEP_REGB_SRC_ADDR_CR(base, x)         WriteReg32(base, rIEP_SRC_ADDR_CR, x)
+#define     IEP_REGB_SRC_ADDR_Y1(base, x)         WriteReg32(base, rIEP_SRC_ADDR_Y1, x)
+#define     IEP_REGB_SRC_ADDR_CBCR1(base, x)      WriteReg32(base, rIEP_SRC_ADDR_CBCR1, x)
+#define     IEP_REGB_SRC_ADDR_CR1(base, x)        WriteReg32(base, rIEP_SRC_ADDR_CR1, x)
+#define     IEP_REGB_SRC_ADDR_Y_ITEMP(base, x)    WriteReg32(base, rIEP_SRC_ADDR_Y_ITEMP, x)
+#define     IEP_REGB_SRC_ADDR_CBCR_ITEMP(base, x) WriteReg32(base, rIEP_SRC_ADDR_CBCR_ITEMP, x)
+#define     IEP_REGB_SRC_ADDR_CR_ITEMP(base, x)   WriteReg32(base, rIEP_SRC_ADDR_CR_ITEMP, x)
+#define     IEP_REGB_SRC_ADDR_Y_FTEMP(base, x)    WriteReg32(base, rIEP_SRC_ADDR_Y_FTEMP, x)
+#define     IEP_REGB_SRC_ADDR_CBCR_FTEMP(base, x) WriteReg32(base, rIEP_SRC_ADDR_CBCR_FTEMP, x)
+#define     IEP_REGB_SRC_ADDR_CR_FTEMP(base, x)   WriteReg32(base, rIEP_SRC_ADDR_CR_FTEMP, x)
+/*dst_addr*/
+#define     IEP_REGB_DST_ADDR_YRGB(base, x)       WriteReg32(base, rIEP_DST_ADDR_YRGB,x)
+#define     IEP_REGB_DST_ADDR_CBCR(base, x)       WriteReg32(base, rIEP_DST_ADDR_CBCR, x)
+#define     IEP_REGB_DST_ADDR_CR(base, x)         WriteReg32(base, rIEP_DST_ADDR_CR, x)
+#define     IEP_REGB_DST_ADDR_Y1(base, x)         WriteReg32(base, rIEP_DST_ADDR_Y1, x)
+#define     IEP_REGB_DST_ADDR_CBCR1(base, x)      WriteReg32(base, rIEP_DST_ADDR_CBCR1, x)
+#define     IEP_REGB_DST_ADDR_CR1(base, x)        WriteReg32(base, rIEP_DST_ADDR_CR1, x)
+#define     IEP_REGB_DST_ADDR_Y_ITEMP(base, x)    WriteReg32(base, rIEP_DST_ADDR_Y_ITEMP, x)
+#define     IEP_REGB_DST_ADDR_CBCR_ITEMP(base, x) WriteReg32(base, rIEP_DST_ADDR_CBCR_ITEMP, x)
+#define     IEP_REGB_DST_ADDR_CR_ITEMP(base, x)   WriteReg32(base, rIEP_DST_ADDR_CR_ITEMP, x)
+#define     IEP_REGB_DST_ADDR_Y_FTEMP(base, x)    WriteReg32(base, rIEP_DST_ADDR_Y_FTEMP, x)
+#define     IEP_REGB_DST_ADDR_CBCR_FTEMP(base, x) WriteReg32(base, rIEP_DST_ADDR_CBCR_FTEMP, x)
+#define     IEP_REGB_DST_ADDR_CR_FTEMP(base, x)   WriteReg32(base, rIEP_DST_ADDR_CR_FTEMP, x)
+
+/*dil_mtn_tab*/
+#define     IEP_REGB_DIL_MTN_TAB0(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB0,x)
+#define     IEP_REGB_DIL_MTN_TAB1(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB1,x)
+#define     IEP_REGB_DIL_MTN_TAB2(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB2,x)
+#define     IEP_REGB_DIL_MTN_TAB3(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB3,x)
+#define     IEP_REGB_DIL_MTN_TAB4(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB4,x)
+#define     IEP_REGB_DIL_MTN_TAB5(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB5,x)
+#define     IEP_REGB_DIL_MTN_TAB6(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB6,x)
+#define     IEP_REGB_DIL_MTN_TAB7(base, x)      WriteReg32(base, rIEP_DIL_MTN_TAB7,x)
+
+#define     IEP_REGB_STATUS(base)               ReadReg32(base, rIEP_STATUS)
+
+void iep_config_lcdc_path(struct IEP_MSG *iep_msg);
+
+/* system control, directly operating the device registers.*/
+/* parameter @base need to be set to device base address. */
+void iep_soft_rst(void *base);
+void iep_config_done(void *base);
+void iep_config_frm_start(void *base);
+int iep_probe_int(void *base);
+void iep_config_frame_end_int_clr(void *base);
+void iep_config_frame_end_int_en(void *base);
+struct iep_status iep_get_status(void *base);
+int iep_get_deinterlace_mode(void *base);
+void iep_set_deinterlace_mode(int mode, void *base);
+void iep_switch_input_address(void *base);
+
+/* generating a series of iep registers copy to the session private buffer */
+void iep_config(iep_session *session, struct IEP_MSG *iep_msg);
+
+/*#define IEP_PRINT_INFO*/
+#endif
diff -Nupr a/drivers/video/rockchip/iep/iep_drv.c b/drivers/video/rockchip/iep/iep_drv.c
--- a/drivers/video/rockchip/iep/iep_drv.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep_drv.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1384 @@
+/*
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/uaccess.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/poll.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#include <linux/wakelock.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/rockchip/cpu.h>
+#include <asm/cacheflush.h>
+#include "iep_drv.h"
+#include "hw_iep_reg.h"
+#include "iep_iommu_ops.h"
+
+#define IEP_MAJOR		255
+#define IEP_CLK_ENABLE
+/*#define IEP_TEST_CASE*/
+
+static int debug;
+module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug,
+		 "Debug level - higher value produces more verbose messages");
+
+#define RK_IEP_SIZE		0x1000
+#define IEP_TIMEOUT_DELAY	2*HZ
+#define IEP_POWER_OFF_DELAY	4*HZ
+
+struct iep_drvdata {
+	struct miscdevice miscdev;
+	void *iep_base;
+	int irq0;
+
+	struct clk *aclk_iep;
+	struct clk *hclk_iep;
+	struct clk *pd_iep;
+	struct clk *aclk_vio1;
+
+	struct mutex mutex;
+
+	/* direct path interface mode. true: enable, false: disable */
+	bool dpi_mode;
+
+	struct delayed_work power_off_work;
+
+	/* clk enable or disable */
+	bool enable;
+	struct wake_lock wake_lock;
+
+	atomic_t iep_int;
+	atomic_t mmu_page_fault;
+	atomic_t mmu_bus_error;
+
+	/* capability for this iep device */
+	struct IEP_CAP cap;
+	struct device *dev;
+};
+
+struct iep_drvdata *iep_drvdata1 = NULL;
+iep_service_info iep_service;
+
+static void iep_reg_deinit(struct iep_reg *reg)
+{
+	struct iep_mem_region *mem_region = NULL, *n;
+	/* release memory region attach to this registers table.*/
+	if (iep_service.iommu_dev) {
+		list_for_each_entry_safe(mem_region, n, &reg->mem_region_list,
+					 reg_lnk) {
+			iep_iommu_unmap_iommu(iep_service.iommu_info,
+					      reg->session, mem_region->hdl);
+			iep_iommu_free(iep_service.iommu_info,
+				       reg->session, mem_region->hdl);
+			list_del_init(&mem_region->reg_lnk);
+			kfree(mem_region);
+		}
+	}
+
+	list_del_init(&reg->session_link);
+	list_del_init(&reg->status_link);
+	kfree(reg);
+}
+
+static void iep_reg_from_wait_to_ready(struct iep_reg *reg)
+{
+	list_del_init(&reg->status_link);
+	list_add_tail(&reg->status_link, &iep_service.ready);
+
+	list_del_init(&reg->session_link);
+	list_add_tail(&reg->session_link, &reg->session->ready);
+}
+
+static void iep_reg_from_ready_to_running(struct iep_reg *reg)
+{
+	list_del_init(&reg->status_link);
+	list_add_tail(&reg->status_link, &iep_service.running);
+
+	list_del_init(&reg->session_link);
+	list_add_tail(&reg->session_link, &reg->session->running);
+}
+
+static void iep_del_running_list(void)
+{
+	struct iep_reg *reg;
+	int cnt = 0;
+
+	mutex_lock(&iep_service.lock);
+
+	while (!list_empty(&iep_service.running)) {
+		BUG_ON(cnt != 0);
+		reg = list_entry(iep_service.running.next,
+				 struct iep_reg, status_link);
+
+		atomic_dec(&reg->session->task_running);
+		atomic_dec(&iep_service.total_running);
+
+		if (list_empty(&reg->session->waiting)) {
+			atomic_set(&reg->session->done, 1);
+			atomic_inc(&reg->session->num_done);
+			wake_up(&reg->session->wait);
+		}
+
+		iep_reg_deinit(reg);
+		cnt++;
+	}
+
+	mutex_unlock(&iep_service.lock);
+}
+
+static void iep_dump(void)
+{
+	struct iep_status sts;
+
+	sts = iep_get_status(iep_drvdata1->iep_base);
+
+	IEP_INFO("scl_sts: %u, dil_sts %u, wyuv_sts %u, ryuv_sts %u, wrgb_sts %u, rrgb_sts %u, voi_sts %u\n",
+		sts.scl_sts, sts.dil_sts, sts.wyuv_sts, sts.ryuv_sts, sts.wrgb_sts, sts.rrgb_sts, sts.voi_sts); {
+		int *reg = (int *)iep_drvdata1->iep_base;
+		int i;
+
+		/* could not read validate data from address after base+0x40 */
+		for (i = 0; i < 0x40; i++) {
+			IEP_INFO("%08x ", reg[i]);
+
+			if ((i + 1) % 4 == 0) {
+				IEP_INFO("\n");
+			}
+		}
+
+		IEP_INFO("\n");
+	}
+}
+
+/* Caller must hold iep_service.lock */
+static void iep_del_running_list_timeout(void)
+{
+	struct iep_reg *reg;
+
+	mutex_lock(&iep_service.lock);
+
+	while (!list_empty(&iep_service.running)) {
+		reg = list_entry(iep_service.running.next, struct iep_reg, status_link);
+
+		atomic_dec(&reg->session->task_running);
+		atomic_dec(&iep_service.total_running);
+
+		/* iep_soft_rst(iep_drvdata1->iep_base); */
+
+		iep_dump();
+
+		if (list_empty(&reg->session->waiting)) {
+			atomic_set(&reg->session->done, 1);
+			wake_up(&reg->session->wait);
+		}
+
+		iep_reg_deinit(reg);
+	}
+
+	mutex_unlock(&iep_service.lock);
+}
+
+static inline void iep_queue_power_off_work(void)
+{
+	queue_delayed_work(system_wq, &iep_drvdata1->power_off_work, IEP_POWER_OFF_DELAY);
+}
+
+static void iep_power_on(void)
+{
+	static ktime_t last;
+	ktime_t now = ktime_get();
+	if (ktime_to_ns(ktime_sub(now, last)) > NSEC_PER_SEC) {
+		cancel_delayed_work_sync(&iep_drvdata1->power_off_work);
+		iep_queue_power_off_work();
+		last = now;
+	}
+
+	if (iep_service.enable)
+		return;
+
+	IEP_INFO("IEP Power ON\n");
+
+	/* iep_soft_rst(iep_drvdata1->iep_base); */
+
+#ifdef IEP_CLK_ENABLE
+	pm_runtime_get_sync(iep_drvdata1->dev);
+	if (iep_drvdata1->pd_iep)
+		clk_prepare_enable(iep_drvdata1->pd_iep);
+	clk_prepare_enable(iep_drvdata1->aclk_iep);
+	clk_prepare_enable(iep_drvdata1->hclk_iep);
+#endif
+
+	wake_lock(&iep_drvdata1->wake_lock);
+
+	iep_iommu_attach(iep_service.iommu_info);
+
+	iep_service.enable = true;
+}
+
+static void iep_power_off(void)
+{
+	int total_running;
+
+	if (!iep_service.enable) {
+		return;
+	}
+
+	IEP_INFO("IEP Power OFF\n");
+
+	total_running = atomic_read(&iep_service.total_running);
+	if (total_running) {
+		IEP_WARNING("power off when %d task running!!\n", total_running);
+		mdelay(50);
+		IEP_WARNING("delay 50 ms for running task\n");
+		iep_dump();
+	}
+
+	if (iep_service.iommu_dev) {
+		iep_iommu_detach(iep_service.iommu_info);
+	}
+
+#ifdef IEP_CLK_ENABLE
+	clk_disable_unprepare(iep_drvdata1->aclk_iep);
+	clk_disable_unprepare(iep_drvdata1->hclk_iep);
+	if (iep_drvdata1->pd_iep)
+		clk_disable_unprepare(iep_drvdata1->pd_iep);
+	pm_runtime_put(iep_drvdata1->dev);
+#endif
+
+	wake_unlock(&iep_drvdata1->wake_lock);
+	iep_service.enable = false;
+}
+
+static void iep_power_off_work(struct work_struct *work)
+{
+	if (mutex_trylock(&iep_service.lock)) {
+		if (!iep_drvdata1->dpi_mode) {
+			IEP_INFO("iep dpi mode inactivity\n");
+			iep_power_off();
+		}
+		mutex_unlock(&iep_service.lock);
+	} else {
+		/* Come back later if the device is busy... */
+		iep_queue_power_off_work();
+	}
+}
+
+#ifdef CONFIG_FB_ROCKCHIP
+extern void rk_direct_fb_show(struct fb_info *fbi);
+extern struct fb_info* rk_get_fb(int fb_id);
+extern bool rk_fb_poll_wait_frame_complete(void);
+extern int rk_fb_dpi_open(bool open);
+extern int rk_fb_dpi_win_sel(int layer_id);
+
+static void iep_config_lcdc(struct iep_reg *reg)
+{
+	struct fb_info *fb;
+	int fbi = 0;
+	int fmt = 0;
+
+	fbi = reg->layer == 0 ? 0 : 1;
+
+	rk_fb_dpi_win_sel(fbi);
+
+	fb = rk_get_fb(fbi);
+#if 1
+	switch (reg->format) {
+	case IEP_FORMAT_ARGB_8888:
+	case IEP_FORMAT_ABGR_8888:
+		fmt = HAL_PIXEL_FORMAT_RGBA_8888;
+		fb->var.bits_per_pixel = 32;
+
+		fb->var.red.length = 8;
+		fb->var.red.offset = 16;
+		fb->var.red.msb_right = 0;
+
+		fb->var.green.length = 8;
+		fb->var.green.offset = 8;
+		fb->var.green.msb_right = 0;
+
+		fb->var.blue.length = 8;
+		fb->var.blue.offset = 0;
+		fb->var.blue.msb_right = 0;
+
+		fb->var.transp.length = 8;
+		fb->var.transp.offset = 24;
+		fb->var.transp.msb_right = 0;
+
+		break;
+	case IEP_FORMAT_BGRA_8888:
+		fmt = HAL_PIXEL_FORMAT_BGRA_8888;
+		fb->var.bits_per_pixel = 32;
+		break;
+	case IEP_FORMAT_RGB_565:
+		fmt = HAL_PIXEL_FORMAT_RGB_565;
+		fb->var.bits_per_pixel = 16;
+
+		fb->var.red.length = 5;
+		fb->var.red.offset = 11;
+		fb->var.red.msb_right = 0;
+
+		fb->var.green.length = 6;
+		fb->var.green.offset = 5;
+		fb->var.green.msb_right = 0;
+
+		fb->var.blue.length = 5;
+		fb->var.blue.offset = 0;
+		fb->var.blue.msb_right = 0;
+
+		break;
+	case IEP_FORMAT_YCbCr_422_SP:
+		fmt = HAL_PIXEL_FORMAT_YCbCr_422_SP;
+		fb->var.bits_per_pixel = 16;
+		break;
+	case IEP_FORMAT_YCbCr_420_SP:
+		fmt = HAL_PIXEL_FORMAT_YCrCb_NV12;
+		fb->var.bits_per_pixel = 16;
+		break;
+	case IEP_FORMAT_YCbCr_422_P:
+	case IEP_FORMAT_YCrCb_422_SP:
+	case IEP_FORMAT_YCrCb_422_P:
+	case IEP_FORMAT_YCrCb_420_SP:
+	case IEP_FORMAT_YCbCr_420_P:
+	case IEP_FORMAT_YCrCb_420_P:
+	case IEP_FORMAT_RGBA_8888:
+	case IEP_FORMAT_BGR_565:
+		/* unsupported format */
+		IEP_ERR("unsupported format %d\n", reg->format);
+		break;
+	default:
+		;
+	}
+
+	fb->var.xoffset = 0;
+	fb->var.yoffset = 0;
+	fb->var.xres = reg->act_width;
+	fb->var.yres = reg->act_height;
+	fb->var.xres_virtual = reg->act_width;
+	fb->var.yres_virtual = reg->act_height;
+	fb->var.nonstd = ((reg->off_y & 0xFFF) << 20) +
+		((reg->off_x & 0xFFF) << 8) + (fmt & 0xFF);
+	fb->var.grayscale =
+		((reg->vir_height & 0xFFF) << 20) +
+		((reg->vir_width & 0xFFF) << 8) + 0;/*win0 xsize & ysize*/
+#endif
+	rk_direct_fb_show(fb);
+}
+
+static int iep_switch_dpi(struct iep_reg *reg)
+{
+	if (reg->dpi_en) {
+		if (!iep_drvdata1->dpi_mode) {
+			/* Turn on dpi */
+			rk_fb_dpi_open(true);
+			iep_drvdata1->dpi_mode = true;
+		}
+		iep_config_lcdc(reg);
+	} else {
+		if (iep_drvdata1->dpi_mode) {
+			/* Turn off dpi */
+			/* wait_lcdc_dpi_close(); */
+			bool status;
+			rk_fb_dpi_open(false);
+			status = rk_fb_poll_wait_frame_complete();
+			iep_drvdata1->dpi_mode = false;
+			IEP_INFO("%s %d, iep dpi inactivated\n",
+				 __func__, __LINE__);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static void iep_reg_copy_to_hw(struct iep_reg *reg)
+{
+	int i;
+
+	u32 *pbase = (u32 *)iep_drvdata1->iep_base;
+
+	/* config registers */
+	for (i = 0; i < IEP_CNF_REG_LEN; i++)
+		pbase[IEP_CNF_REG_BASE + i] = reg->reg[IEP_CNF_REG_BASE + i];
+
+	/* command registers */
+	for (i = 0; i < IEP_CMD_REG_LEN; i++)
+		pbase[IEP_CMD_REG_BASE + i] = reg->reg[IEP_CMD_REG_BASE + i];
+
+	/* address registers */
+	for (i = 0; i < IEP_ADD_REG_LEN; i++)
+		pbase[IEP_ADD_REG_BASE + i] = reg->reg[IEP_ADD_REG_BASE + i];
+
+	/* dmac_flush_range(&pbase[0], &pbase[IEP_REG_LEN]); */
+	/* outer_flush_range(virt_to_phys(&pbase[0]),virt_to_phys(&pbase[IEP_REG_LEN])); */
+
+	dsb(sy);
+}
+
+/** switch fields order before the next lcdc frame start
+ *  coming */
+static void iep_switch_fields_order(void)
+{
+	void *pbase = (void *)iep_drvdata1->iep_base;
+	int mode = iep_get_deinterlace_mode(pbase);
+#ifdef CONFIG_FB_ROCKCHIP
+	struct fb_info *fb;
+#endif
+	switch (mode) {
+	case dein_mode_I4O1B:
+		iep_set_deinterlace_mode(dein_mode_I4O1T, pbase);
+		break;
+	case dein_mode_I4O1T:
+		iep_set_deinterlace_mode(dein_mode_I4O1B, pbase);
+		break;
+	case dein_mode_I2O1B:
+		iep_set_deinterlace_mode(dein_mode_I2O1T, pbase);
+		break;
+	case dein_mode_I2O1T:
+		iep_set_deinterlace_mode(dein_mode_I2O1B, pbase);
+		break;
+	default:
+		;
+	}
+#ifdef CONFIG_FB_ROCKCHIP
+	fb = rk_get_fb(1);
+	rk_direct_fb_show(fb);
+#endif
+	/*iep_switch_input_address(pbase);*/
+}
+
+/* Caller must hold iep_service.lock */
+static void iep_try_set_reg(void)
+{
+	struct iep_reg *reg;
+
+	mutex_lock(&iep_service.lock);
+
+	if (list_empty(&iep_service.ready)) {
+		if (!list_empty(&iep_service.waiting)) {
+			reg = list_entry(iep_service.waiting.next, struct iep_reg, status_link);
+
+			iep_power_on();
+			udelay(1);
+
+			iep_reg_from_wait_to_ready(reg);
+			atomic_dec(&iep_service.waitcnt);
+
+			/*iep_soft_rst(iep_drvdata1->iep_base);*/
+
+			iep_reg_copy_to_hw(reg);
+		}
+	} else {
+		if (iep_drvdata1->dpi_mode)
+			iep_switch_fields_order();
+	}
+
+	mutex_unlock(&iep_service.lock);
+}
+
+static void iep_try_start_frm(void)
+{
+	struct iep_reg *reg;
+
+	mutex_lock(&iep_service.lock);
+
+	if (list_empty(&iep_service.running)) {
+		if (!list_empty(&iep_service.ready)) {
+			reg = list_entry(iep_service.ready.next, struct iep_reg, status_link);
+#ifdef CONFIG_FB_ROCKCHIP
+			iep_switch_dpi(reg);
+#endif
+			iep_reg_from_ready_to_running(reg);
+			iep_config_frame_end_int_en(iep_drvdata1->iep_base);
+			iep_config_done(iep_drvdata1->iep_base);
+
+			/* Start proc */
+			atomic_inc(&reg->session->task_running);
+			atomic_inc(&iep_service.total_running);
+			iep_config_frm_start(iep_drvdata1->iep_base);
+		}
+	}
+
+	mutex_unlock(&iep_service.lock);
+}
+
+static irqreturn_t iep_isr(int irq, void *dev_id)
+{
+	if (atomic_read(&iep_drvdata1->iep_int) > 0) {
+		if (iep_service.enable) {
+			if (list_empty(&iep_service.waiting)) {
+				if (iep_drvdata1->dpi_mode) {
+					iep_switch_fields_order();
+				}
+			}
+			iep_del_running_list();
+		}
+
+		iep_try_set_reg();
+		iep_try_start_frm();
+
+		atomic_dec(&iep_drvdata1->iep_int);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t iep_irq(int irq,  void *dev_id)
+{
+	/*clear INT */
+	void *pbase = (void *)iep_drvdata1->iep_base;
+
+	if (iep_probe_int(pbase)) {
+		iep_config_frame_end_int_clr(pbase);
+		atomic_inc(&iep_drvdata1->iep_int);
+	}
+
+	return IRQ_WAKE_THREAD;
+}
+
+static void iep_service_session_clear(iep_session *session)
+{
+	struct iep_reg *reg, *n;
+
+	list_for_each_entry_safe(reg, n, &session->waiting, session_link) {
+		iep_reg_deinit(reg);
+	}
+
+	list_for_each_entry_safe(reg, n, &session->ready, session_link) {
+		iep_reg_deinit(reg);
+	}
+
+	list_for_each_entry_safe(reg, n, &session->running, session_link) {
+		iep_reg_deinit(reg);
+	}
+}
+
+static int iep_open(struct inode *inode, struct file *filp)
+{
+	//DECLARE_WAITQUEUE(wait, current);
+	iep_session *session = (iep_session *)kzalloc(sizeof(iep_session),
+		GFP_KERNEL);
+	if (NULL == session) {
+		IEP_ERR("unable to allocate memory for iep_session.\n");
+		return -ENOMEM;
+	}
+
+	session->pid = current->pid;
+	INIT_LIST_HEAD(&session->waiting);
+	INIT_LIST_HEAD(&session->ready);
+	INIT_LIST_HEAD(&session->running);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	/*add_wait_queue(&session->wait, wait);*/
+	/* no need to protect */
+	mutex_lock(&iep_service.lock);
+	list_add_tail(&session->list_session, &iep_service.session);
+	mutex_unlock(&iep_service.lock);
+	atomic_set(&session->task_running, 0);
+	atomic_set(&session->num_done, 0);
+
+	filp->private_data = (void *)session;
+
+	return nonseekable_open(inode, filp);
+}
+
+static int iep_release(struct inode *inode, struct file *filp)
+{
+	int task_running;
+	iep_session *session = (iep_session *)filp->private_data;
+
+	if (NULL == session)
+		return -EINVAL;
+
+	task_running = atomic_read(&session->task_running);
+
+	if (task_running) {
+		IEP_ERR("iep_service session %d still "
+			"has %d task running when closing\n",
+			session->pid, task_running);
+		msleep(100);
+		/*synchronization*/
+	}
+
+	wake_up(&session->wait);
+	iep_power_on();
+	mutex_lock(&iep_service.lock);
+	list_del(&session->list_session);
+	iep_service_session_clear(session);
+	iep_iommu_clear(iep_service.iommu_info, session);
+	kfree(session);
+	mutex_unlock(&iep_service.lock);
+
+	return 0;
+}
+
+static unsigned int iep_poll(struct file *filp, poll_table *wait)
+{
+	int mask = 0;
+	iep_session *session = (iep_session *)filp->private_data;
+	if (NULL == session)
+		return POLL_ERR;
+	poll_wait(filp, &session->wait, wait);
+	if (atomic_read(&session->done))
+		mask |= POLL_IN | POLLRDNORM;
+
+	return mask;
+}
+
+static int iep_get_result_sync(iep_session *session)
+{
+	int ret = 0;
+
+	iep_try_start_frm();
+
+	ret = wait_event_timeout(session->wait,
+		atomic_read(&session->done), IEP_TIMEOUT_DELAY);
+
+	if (unlikely(ret < 0)) {
+		IEP_ERR("sync pid %d wait task ret %d\n", session->pid, ret);
+		iep_del_running_list();
+		ret = ret;
+	} else if (0 == ret) {
+		IEP_ERR("sync pid %d wait %d task done timeout\n",
+			session->pid, atomic_read(&session->task_running));
+		iep_del_running_list_timeout();
+		iep_try_set_reg();
+		iep_try_start_frm();
+		ret = -ETIMEDOUT;
+	}
+
+	return ret;
+}
+
+static void iep_get_result_async(iep_session *session)
+{
+	iep_try_start_frm();
+	return;
+}
+
+static long iep_ioctl(struct file *filp, uint32_t cmd, unsigned long arg)
+{
+	int ret = 0;
+	iep_session *session = (iep_session *)filp->private_data;
+
+	if (NULL == session) {
+		IEP_ERR("%s [%d] iep thread session is null\n",
+			__FUNCTION__, __LINE__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&iep_service.mutex);
+
+	switch (cmd) {
+	case IEP_SET_PARAMETER:
+		{
+			struct IEP_MSG *msg;
+			msg = (struct IEP_MSG *)kzalloc(sizeof(struct IEP_MSG),
+				GFP_KERNEL);
+			if (msg) {
+				if (copy_from_user(msg, (struct IEP_MSG *)arg,
+						sizeof(struct IEP_MSG))) {
+					IEP_ERR("copy_from_user failure\n");
+					ret = -EFAULT;
+				}
+			}
+
+			if (ret == 0) {
+				if (atomic_read(&iep_service.waitcnt) < 10) {
+					iep_power_on();
+					iep_config(session, msg);
+					atomic_inc(&iep_service.waitcnt);
+				} else {
+					IEP_ERR("iep task queue full\n");
+					ret = -EFAULT;
+				}
+			}
+
+			/** REGISTER CONFIG must accord to Timing When DPI mode
+			 *  enable */
+			if (!iep_drvdata1->dpi_mode)
+				iep_try_set_reg();
+			kfree(msg);
+		}
+		break;
+	case IEP_GET_RESULT_SYNC:
+		if (0 > iep_get_result_sync(session)) {
+			ret = -ETIMEDOUT;
+		}
+		break;
+	case IEP_GET_RESULT_ASYNC:
+		iep_get_result_async(session);
+		break;
+	case IEP_RELEASE_CURRENT_TASK:
+		iep_del_running_list_timeout();
+		iep_try_set_reg();
+		iep_try_start_frm();
+		break;
+	case IEP_GET_IOMMU_STATE:
+		{
+			int iommu_enable = 0;
+
+			iommu_enable = iep_service.iommu_dev ? 1 : 0;
+
+			if (copy_to_user((void __user *)arg, &iommu_enable,
+				sizeof(int))) {
+				IEP_ERR("error: copy_to_user failed\n");
+				ret = -EFAULT;
+			}
+		}
+		break;
+	case IEP_QUERY_CAP:
+		if (copy_to_user((void __user *)arg, &iep_drvdata1->cap,
+			sizeof(struct IEP_CAP))) {
+			IEP_ERR("error: copy_to_user failed\n");
+			ret = -EFAULT;
+		}
+		break;
+	default:
+		IEP_ERR("unknown ioctl cmd!\n");
+		ret = -EINVAL;
+	}
+	mutex_unlock(&iep_service.mutex);
+
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long compat_iep_ioctl(struct file *filp, uint32_t cmd,
+			     unsigned long arg)
+{
+	int ret = 0;
+	iep_session *session = (iep_session *)filp->private_data;
+
+	if (NULL == session) {
+		IEP_ERR("%s [%d] iep thread session is null\n",
+			__func__, __LINE__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&iep_service.mutex);
+
+	switch (cmd) {
+	case COMPAT_IEP_SET_PARAMETER:
+		{
+			struct IEP_MSG *msg;
+
+			msg = kzalloc(sizeof(*msg), GFP_KERNEL);
+
+			if (msg) {
+				if (copy_from_user
+				    (msg, compat_ptr((compat_uptr_t)arg),
+				     sizeof(struct IEP_MSG))) {
+					IEP_ERR("copy_from_user failure\n");
+					ret = -EFAULT;
+				}
+			}
+
+			if (ret == 0) {
+				if (atomic_read(&iep_service.waitcnt) < 10) {
+					iep_power_on();
+					iep_config(session, msg);
+					atomic_inc(&iep_service.waitcnt);
+				} else {
+					IEP_ERR("iep task queue full\n");
+					ret = -EFAULT;
+				}
+			}
+
+			/** REGISTER CONFIG must accord to Timing When DPI mode
+			 *  enable */
+			if (!iep_drvdata1->dpi_mode)
+				iep_try_set_reg();
+			kfree(msg);
+		}
+		break;
+	case COMPAT_IEP_GET_RESULT_SYNC:
+		if (0 > iep_get_result_sync(session))
+			ret = -ETIMEDOUT;
+		break;
+	case COMPAT_IEP_GET_RESULT_ASYNC:
+		iep_get_result_async(session);
+		break;
+	case COMPAT_IEP_RELEASE_CURRENT_TASK:
+		iep_del_running_list_timeout();
+		iep_try_set_reg();
+		iep_try_start_frm();
+		break;
+	case COMPAT_IEP_GET_IOMMU_STATE:
+		{
+			int iommu_enable = 0;
+
+			iommu_enable = iep_service.iommu_dev ? 1 : 0;
+
+			if (copy_to_user((void __user *)arg, &iommu_enable,
+				sizeof(int))) {
+				IEP_ERR("error: copy_to_user failed\n");
+				ret = -EFAULT;
+			}
+		}
+		break;
+	case COMPAT_IEP_QUERY_CAP:
+		if (copy_to_user((void __user *)arg, &iep_drvdata1->cap,
+			sizeof(struct IEP_CAP))) {
+			IEP_ERR("error: copy_to_user failed\n");
+			ret = -EFAULT;
+		}
+		break;
+	default:
+		IEP_ERR("unknown ioctl cmd!\n");
+		ret = -EINVAL;
+	}
+	mutex_unlock(&iep_service.mutex);
+
+	return ret;
+}
+#endif
+
+struct file_operations iep_fops = {
+	.owner		= THIS_MODULE,
+	.open		= iep_open,
+	.release	= iep_release,
+	.poll		= iep_poll,
+	.unlocked_ioctl	= iep_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= compat_iep_ioctl,
+#endif
+};
+
+static struct miscdevice iep_dev = {
+	.minor = IEP_MAJOR,
+	.name  = "iep",
+	.fops  = &iep_fops,
+};
+
+static struct device* rockchip_get_sysmmu_device_by_compatible(
+	const char *compt)
+{
+	struct device_node *dn = NULL;
+	struct platform_device *pd = NULL;
+	struct device *ret = NULL;
+
+	dn = of_find_compatible_node(NULL, NULL, compt);
+	if (!dn) {
+		printk("can't find device node %s \r\n", compt);
+		return NULL;
+	}
+
+	pd = of_find_device_by_node(dn);
+	if (!pd) {
+		printk("can't find platform device in device node %s \r\n",
+			compt);
+		return  NULL;
+	}
+	ret = &pd->dev;
+
+	return ret;
+
+}
+#ifdef CONFIG_IOMMU_API
+static inline void platform_set_sysmmu(struct device *iommu,
+	struct device *dev)
+{
+	dev->archdata.iommu = iommu;
+}
+#else
+static inline void platform_set_sysmmu(struct device *iommu,
+	struct device *dev)
+{
+}
+#endif
+
+static int iep_sysmmu_fault_handler(struct device *dev,
+	enum rk_iommu_inttype itype,
+	unsigned long pgtable_base,
+	unsigned long fault_addr, unsigned int status)
+{
+	struct iep_reg *reg = list_entry(iep_service.running.next,
+		struct iep_reg, status_link);
+	if (reg != NULL) {
+		struct iep_mem_region *mem, *n;
+		int i = 0;
+		pr_info("iep, fault addr 0x%08x\n", (u32)fault_addr);
+		list_for_each_entry_safe(mem, n,
+			&reg->mem_region_list,
+			reg_lnk) {
+			pr_info("iep, mem region [%02d] 0x%08x %ld\n",
+				i, (u32)mem->iova, mem->len);
+			i++;
+		}
+
+		pr_alert("iep, page fault occur\n");
+
+		iep_del_running_list();
+	}
+
+	return 0;
+}
+
+static int iep_drv_probe(struct platform_device *pdev)
+{
+	struct iep_drvdata *data;
+	int ret = 0;
+	struct resource *res = NULL;
+	u32 version;
+	struct device_node *np = pdev->dev.of_node;
+	struct platform_device *sub_dev = NULL;
+	struct device_node *sub_np = NULL;
+	u32 iommu_en = 0;
+	struct device *mmu_dev = NULL;
+	of_property_read_u32(np, "iommu_enabled", &iommu_en);
+
+	data = (struct iep_drvdata *)devm_kzalloc(&pdev->dev,
+		sizeof(struct iep_drvdata), GFP_KERNEL);
+	if (NULL == data) {
+		IEP_ERR("failed to allocate driver data.\n");
+		return  -ENOMEM;
+	}
+
+	iep_drvdata1 = data;
+
+	INIT_LIST_HEAD(&iep_service.waiting);
+	INIT_LIST_HEAD(&iep_service.ready);
+	INIT_LIST_HEAD(&iep_service.running);
+	INIT_LIST_HEAD(&iep_service.done);
+	INIT_LIST_HEAD(&iep_service.session);
+	atomic_set(&iep_service.waitcnt, 0);
+	mutex_init(&iep_service.lock);
+	atomic_set(&iep_service.total_running, 0);
+	iep_service.enable = false;
+
+#ifdef IEP_CLK_ENABLE
+	data->pd_iep = devm_clk_get(&pdev->dev, "pd_iep");
+	if (IS_ERR(data->pd_iep)) {
+		IEP_ERR("failed to find iep power down clock source.\n");
+		data->pd_iep = NULL;
+	}
+
+	data->aclk_iep = devm_clk_get(&pdev->dev, "aclk_iep");
+	if (IS_ERR(data->aclk_iep)) {
+		IEP_ERR("failed to find iep axi clock source.\n");
+		ret = -ENOENT;
+		goto err_clock;
+	}
+
+	data->hclk_iep = devm_clk_get(&pdev->dev, "hclk_iep");
+	if (IS_ERR(data->hclk_iep)) {
+		IEP_ERR("failed to find iep ahb clock source.\n");
+		ret = -ENOENT;
+		goto err_clock;
+	}
+#endif
+
+	iep_service.enable = false;
+	INIT_DELAYED_WORK(&data->power_off_work, iep_power_off_work);
+	wake_lock_init(&data->wake_lock, WAKE_LOCK_SUSPEND, "iep");
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	data->iep_base = (void *)devm_ioremap_resource(&pdev->dev, res);
+	if (data->iep_base == NULL) {
+		IEP_ERR("iep ioremap failed\n");
+		ret = -ENOENT;
+		goto err_ioremap;
+	}
+
+	atomic_set(&data->iep_int, 0);
+	atomic_set(&data->mmu_page_fault, 0);
+	atomic_set(&data->mmu_bus_error, 0);
+
+	/* get the IRQ */
+	data->irq0 = platform_get_irq(pdev, 0);
+	if (data->irq0 <= 0) {
+		IEP_ERR("failed to get iep irq resource (%d).\n", data->irq0);
+		ret = data->irq0;
+		goto err_irq;
+	}
+
+	/* request the IRQ */
+	ret = devm_request_threaded_irq(&pdev->dev, data->irq0, iep_irq,
+		iep_isr, IRQF_SHARED, dev_name(&pdev->dev), pdev);
+	if (ret) {
+		IEP_ERR("iep request_irq failed (%d).\n", ret);
+		goto err_irq;
+	}
+
+	mutex_init(&iep_service.mutex);
+
+	if (of_property_read_u32(np, "version", &version)) {
+		version = 0;
+	}
+
+	data->cap.scaling_supported = 0;
+	data->cap.i4_deinterlace_supported = 1;
+	data->cap.i2_deinterlace_supported = 1;
+	data->cap.compression_noise_reduction_supported = 1;
+	data->cap.sampling_noise_reduction_supported = 1;
+	data->cap.hsb_enhancement_supported = 1;
+	data->cap.cg_enhancement_supported = 1;
+	data->cap.direct_path_supported = 1;
+	data->cap.max_dynamic_width = 1920;
+	data->cap.max_dynamic_height = 1088;
+	data->cap.max_static_width = 8192;
+	data->cap.max_static_height = 8192;
+	data->cap.max_enhance_radius = 3;
+
+	switch (version) {
+	case 0:
+		data->cap.scaling_supported = 1;
+		break;
+	case 1:
+		data->cap.compression_noise_reduction_supported = 0;
+		data->cap.sampling_noise_reduction_supported = 0;
+		if (soc_is_rk3126b() || soc_is_rk3126c()) {
+			data->cap.i4_deinterlace_supported = 0;
+			data->cap.hsb_enhancement_supported = 0;
+			data->cap.cg_enhancement_supported = 0;
+		}
+		break;
+	case 2:
+		data->cap.max_dynamic_width = 4096;
+		data->cap.max_dynamic_height = 2340;
+		data->cap.max_enhance_radius = 2;
+		break;
+	default:
+		;
+	}
+
+	platform_set_drvdata(pdev, data);
+
+	ret = misc_register(&iep_dev);
+	if (ret) {
+		IEP_ERR("cannot register miscdev (%d)\n", ret);
+		goto err_misc_register;
+	}
+
+	data->dev = &pdev->dev;
+#ifdef IEP_CLK_ENABLE
+	pm_runtime_enable(data->dev);
+#endif
+
+	iep_service.iommu_dev = NULL;
+	sub_np = of_parse_phandle(np, "iommus", 0);
+	if (sub_np) {
+		sub_dev = of_find_device_by_node(sub_np);
+		iep_service.iommu_dev = &sub_dev->dev;
+	}
+
+	if (!iep_service.iommu_dev) {
+		mmu_dev = rockchip_get_sysmmu_device_by_compatible(
+			IEP_IOMMU_COMPATIBLE_NAME);
+
+		if (mmu_dev) {
+			platform_set_sysmmu(mmu_dev, &pdev->dev);
+		}
+
+		rockchip_iovmm_set_fault_handler(&pdev->dev,
+						 iep_sysmmu_fault_handler);
+
+		iep_service.iommu_dev = mmu_dev;
+	}
+	of_property_read_u32(np, "allocator", (u32 *)&iep_service.alloc_type);
+	iep_power_on();
+	iep_service.iommu_info = iep_iommu_info_create(data->dev,
+						       iep_service.iommu_dev,
+						       iep_service.alloc_type);
+	iep_power_off();
+
+	IEP_INFO("IEP Driver loaded succesfully\n");
+
+	return 0;
+
+err_misc_register:
+	free_irq(data->irq0, pdev);
+err_irq:
+	if (res) {
+		if (data->iep_base) {
+			devm_ioremap_release(&pdev->dev, res);
+		}
+		devm_release_mem_region(&pdev->dev, res->start, resource_size(res));
+	}
+err_ioremap:
+	wake_lock_destroy(&data->wake_lock);
+#ifdef IEP_CLK_ENABLE
+err_clock:
+#endif
+	return ret;
+}
+
+static int iep_drv_remove(struct platform_device *pdev)
+{
+	struct iep_drvdata *data = platform_get_drvdata(pdev);
+	struct resource *res;
+
+	iep_iommu_info_destroy(iep_service.iommu_info);
+	iep_service.iommu_info = NULL;
+
+	wake_lock_destroy(&data->wake_lock);
+
+	misc_deregister(&(data->miscdev));
+	free_irq(data->irq0, &data->miscdev);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	devm_ioremap_release(&pdev->dev, res);
+	devm_release_mem_region(&pdev->dev, res->start, resource_size(res));
+
+#ifdef IEP_CLK_ENABLE
+	if (data->aclk_iep)
+		devm_clk_put(&pdev->dev, data->aclk_iep);
+
+	if (data->hclk_iep)
+		devm_clk_put(&pdev->dev, data->hclk_iep);
+
+	if (data->pd_iep)
+		devm_clk_put(&pdev->dev, data->pd_iep);
+
+	pm_runtime_disable(data->dev);
+#endif
+
+	return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id iep_dt_ids[] = {
+	{ .compatible = "rockchip,iep", },
+	{ },
+};
+#endif
+
+static struct platform_driver iep_driver = {
+	.probe		= iep_drv_probe,
+	.remove		= iep_drv_remove,
+	.driver		= {
+		.owner  = THIS_MODULE,
+		.name	= "iep",
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(iep_dt_ids),
+#endif
+	},
+};
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+static int proc_iep_show(struct seq_file *s, void *v)
+{
+	struct iep_status sts;
+	//mutex_lock(&iep_service.mutex);
+	iep_power_on();
+	seq_printf(s, "\nIEP Modules Status:\n");
+	sts = iep_get_status(iep_drvdata1->iep_base);
+	seq_printf(s, "scl_sts: %u, dil_sts %u, wyuv_sts %u, "
+		      "ryuv_sts %u, wrgb_sts %u, rrgb_sts %u, voi_sts %u\n",
+		sts.scl_sts, sts.dil_sts, sts.wyuv_sts, sts.ryuv_sts,
+		sts.wrgb_sts, sts.rrgb_sts, sts.voi_sts); {
+		int *reg = (int *)iep_drvdata1->iep_base;
+		int i;
+
+		/* could not read validate data from address after base+0x40 */
+		for (i = 0; i < 0x40; i++) {
+			seq_printf(s, "%08x ", reg[i]);
+
+			if ((i + 1) % 4 == 0)
+				seq_printf(s, "\n");
+		}
+
+		seq_printf(s, "\n");
+	}
+
+	//mutex_unlock(&iep_service.mutex);
+
+	return 0;
+}
+
+static int proc_iep_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_iep_show, NULL);
+}
+
+static const struct file_operations proc_iep_fops = {
+	.open		= proc_iep_open,
+	.read		= seq_read,
+	.llseek 	= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init iep_proc_init(void)
+{
+	proc_create("iep", 0, NULL, &proc_iep_fops);
+	return 0;
+}
+
+static void __exit iep_proc_release(void)
+{
+	remove_proc_entry("iep", NULL);
+}
+#endif
+
+#ifdef IEP_TEST_CASE
+void iep_test_case0(void);
+#endif
+
+static int __init iep_init(void)
+{
+	int ret;
+
+	if ((ret = platform_driver_register(&iep_driver)) != 0) {
+		IEP_ERR("Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+#ifdef CONFIG_PROC_FS
+	iep_proc_init();
+#endif
+
+	IEP_INFO("Module initialized.\n");
+
+#ifdef IEP_TEST_CASE
+	iep_test_case0();
+#endif
+
+	return 0;
+}
+
+static void __exit iep_exit(void)
+{
+	IEP_ERR("%s IN\n", __func__);
+#ifdef CONFIG_PROC_FS
+	iep_proc_release();
+#endif
+
+	iep_power_off();
+	platform_driver_unregister(&iep_driver);
+}
+
+module_init(iep_init);
+module_exit(iep_exit);
+
+/* Module information */
+MODULE_AUTHOR("ljf@rock-chips.com");
+MODULE_DESCRIPTION("Driver for iep device");
+MODULE_LICENSE("GPL");
+
+#ifdef IEP_TEST_CASE
+
+#include "yuv420sp_480x480_interlaced.h"
+#include "yuv420sp_480x480_deinterlaced_i2o1.h"
+
+//unsigned char tmp_buf[480*480*3/2];
+
+void iep_test_case0(void)
+{
+	struct IEP_MSG msg;
+	iep_session session;
+	unsigned int phy_src, phy_dst, phy_tmp;
+	int i;
+	int ret = 0;
+	unsigned char *tmp_buf;
+
+	tmp_buf = kmalloc(480 * 480 * 3 / 2, GFP_KERNEL);
+
+	session.pid	= current->pid;
+	INIT_LIST_HEAD(&session.waiting);
+	INIT_LIST_HEAD(&session.ready);
+	INIT_LIST_HEAD(&session.running);
+	INIT_LIST_HEAD(&session.list_session);
+	init_waitqueue_head(&session.wait);
+	list_add_tail(&session.list_session, &iep_service.session);
+	atomic_set(&session.task_running, 0);
+	atomic_set(&session.num_done, 0);
+
+	memset(&msg, 0, sizeof(struct IEP_MSG));
+	memset(tmp_buf, 0xCC, 480 * 480 * 3 / 2);
+
+	dmac_flush_range(&tmp_buf[0], &tmp_buf[480 * 480 * 3 / 2]);
+	outer_flush_range(virt_to_phys(&tmp_buf[0]), virt_to_phys(&tmp_buf[480 * 480 * 3 / 2]));
+
+	phy_src = virt_to_phys(&yuv420sp_480x480_interlaced[0]);
+	phy_tmp = virt_to_phys(&tmp_buf[0]);
+	phy_dst = virt_to_phys(&yuv420sp_480x480_deinterlaced_i2o1[0]);
+
+	dmac_flush_range(&yuv420sp_480x480_interlaced[0], &yuv420sp_480x480_interlaced[480 * 480 * 3 / 2]);
+	outer_flush_range(virt_to_phys(&yuv420sp_480x480_interlaced[0]), virt_to_phys(&yuv420sp_480x480_interlaced[480 * 480 * 3 / 2]));
+
+	IEP_INFO("*********** IEP MSG GENARATE ************\n");
+
+	msg.src.act_w = 480;
+	msg.src.act_h = 480;
+	msg.src.x_off = 0;
+	msg.src.y_off = 0;
+	msg.src.vir_w = 480;
+	msg.src.vir_h = 480;
+	msg.src.format = IEP_FORMAT_YCbCr_420_SP;
+	msg.src.mem_addr = (uint32_t *)phy_src;
+	msg.src.uv_addr  = (uint32_t *)(phy_src + 480 * 480);
+	msg.src.v_addr = 0;
+
+	msg.dst.act_w = 480;
+	msg.dst.act_h = 480;
+	msg.dst.x_off = 0;
+	msg.dst.y_off = 0;
+	msg.dst.vir_w = 480;
+	msg.dst.vir_h = 480;
+	msg.dst.format = IEP_FORMAT_YCbCr_420_SP;
+	msg.dst.mem_addr = (uint32_t *)phy_tmp;
+	msg.dst.uv_addr = (uint32_t *)(phy_tmp + 480 * 480);
+	msg.dst.v_addr = 0;
+
+	msg.dein_mode = IEP_DEINTERLACE_MODE_I2O1;
+	msg.field_order = FIELD_ORDER_BOTTOM_FIRST;
+
+	IEP_INFO("*********** IEP TEST CASE 0  ************\n");
+
+	iep_config(&session, &msg);
+	iep_try_set_reg();
+	if (0 > iep_get_result_sync(&session)) {
+		IEP_INFO("%s failed, timeout\n", __func__);
+		ret = -ETIMEDOUT;
+	}
+
+	mdelay(10);
+
+	dmac_flush_range(&tmp_buf[0], &tmp_buf[480 * 480 * 3 / 2]);
+	outer_flush_range(virt_to_phys(&tmp_buf[0]), virt_to_phys(&tmp_buf[480 * 480 * 3 / 2]));
+
+	IEP_INFO("*********** RESULT CHECKING  ************\n");
+
+	for (i = 0; i < 480 * 480 * 3 / 2; i++) {
+		if (tmp_buf[i] != yuv420sp_480x480_deinterlaced_i2o1[i]) {
+			IEP_INFO("diff occur position %d, 0x%02x 0x%02x\n", i, tmp_buf[i], yuv420sp_480x480_deinterlaced_i2o1[i]);
+
+			if (i > 10) {
+				iep_dump();
+				break;
+			}
+		}
+	}
+
+	if (i == 480 * 480 * 3 / 2)
+		IEP_INFO("IEP pass the checking\n");
+}
+
+#endif
diff -Nupr a/drivers/video/rockchip/iep/iep_drv.h b/drivers/video/rockchip/iep/iep_drv.h
--- a/drivers/video/rockchip/iep/iep_drv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep_drv.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,163 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef IEP_DRV_H_
+#define IEP_DRV_H_
+
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+
+#if defined(CONFIG_RK_IOMMU)
+#include <linux/rockchip-iovmm.h>
+#include <linux/dma-buf.h>
+#endif
+#include "iep.h"
+
+#define IEP_REG_LEN         0x100
+#define IEP_CMD_REG_LEN     0xE
+#define IEP_ADD_REG_LEN     0xE0
+#define IEP_RAW_REG_LEN     0xA
+#define IEP_SYS_REG_LEN     0x6
+#define IEP_CNF_REG_LEN     0x2
+
+#define IEP_CNF_REG_BASE    0x0
+#define IEP_SYS_REG_BASE    0x2
+#define IEP_CMD_REG_BASE    0x8
+#define IEP_ADD_REG_BASE    0x20
+#define IEP_RAW_REG_BASE    0x16
+
+struct iep_parameter_req {
+	struct iep_img src;
+	struct iep_img dst;
+};
+
+struct iep_parameter_deinterlace {
+	struct iep_img src1;
+	struct iep_img dst1;
+
+	struct iep_img src_itemp;
+	struct iep_img src_ftemp;
+
+	struct iep_img dst_itemp;
+	struct iep_img dst_ftemp;
+
+	u8 dein_mode;
+
+	// deinterlace high frequency
+	u8 dein_high_fre_en;
+	u8 dein_high_fre_fct;
+
+	// deinterlace edge interpolation
+	u8 dein_ei_mode;
+	u8 dein_ei_smooth;
+	u8 dein_ei_sel;
+	u8 dein_ei_radius;
+};
+
+struct iep_parameter_enhance {
+	u8 yuv_3D_denoise_en;
+
+	u8 yuv_enhance_en;
+	float yuv_enh_saturation; //0-1.992
+	float yuv_enh_contrast; //0-1.992
+	s8 yuv_enh_brightness; //-32<brightness<31
+	s8 yuv_enh_hue_angle; //0-30,value is 0 - 30
+
+	u8 video_mode; //0-3
+	u8 color_bar_y; //0-127
+	u8 color_bar_u; //0-127
+	u8 color_bar_v; //0-127
+
+	u8 rgb_enhance_en;
+
+	u8 rgb_cg_en; //sw_rgb_con_gam_en
+	double cg_rr;
+	double cg_rg;
+	double cg_rb;
+	u8 rgb_color_enhance_en; //sw_rgb_color_enh_en
+	float rgb_enh_coe; //0-3.96875
+};
+
+struct iep_parameter_scale {
+	u8 scale_up_mode;
+};
+
+struct iep_parameter_convert {
+	u8 dither_up_en;
+	u8 dither_down_en; //not to be used
+
+	u8 yuv2rgb_mode;
+	u8 rgb2yuv_mode;
+
+	u8 global_alpha_value;
+
+	u8 rgb2yuv_clip_en;
+	u8 yuv2rgb_clip_en;
+};
+
+typedef struct iep_session {
+	/* a linked list of data so we can access them for debugging */
+	struct list_head    list_session;
+	/* a linked list of register data waiting for process */
+	struct list_head    waiting;
+	/* a linked list of register data in ready */
+	struct list_head    ready;
+	/* a linked list of register data in processing */
+	struct list_head    running;
+	/* all coommand this thread done */
+	atomic_t            done;
+	wait_queue_head_t   wait;
+	pid_t               pid;
+	atomic_t            task_running;
+	atomic_t            num_done;
+} iep_session;
+
+typedef struct iep_service_info {
+	struct mutex        lock;
+	struct timer_list	timer;          /* timer for power off */
+	struct list_head	waiting;        /* link to link_reg in struct iep_reg */
+	atomic_t            waitcnt;
+	struct list_head    ready;          /* link to link_reg in struct iep_reg */
+	struct list_head	running;        /* link to link_reg in struct iep_reg */
+	struct list_head	done;           /* link to link_reg in struct iep_reg */
+	struct list_head	session;        /* link to list_session in struct vpu_session */
+	atomic_t		    total_running;
+
+	struct iep_reg      *reg;
+	bool                enable;
+
+	struct mutex	    mutex;  // mutex
+
+	struct iep_iommu_info *iommu_info;
+
+	struct device *iommu_dev;
+	u32 alloc_type;
+} iep_service_info;
+
+struct iep_reg {
+	iep_session *session;
+	struct list_head 	session_link;      /* link to rga service session */
+	struct list_head 	status_link;       /* link to register set list */
+	uint32_t 			reg[0x300];
+	bool                dpi_en;
+	int                 off_x;
+	int                 off_y;
+	int                 act_width;
+	int                 act_height;
+	int                 vir_width;
+	int                 vir_height;
+	int                 layer;
+	unsigned int        format;
+	struct list_head    mem_region_list;
+};
+
+struct iep_mem_region {
+	struct list_head srv_lnk;
+	struct list_head reg_lnk;
+	struct list_head session_lnk;
+	unsigned long iova;              /* virtual address for iommu */
+	unsigned long len;
+	int hdl;
+};
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/iep/iep.h b/drivers/video/rockchip/iep/iep.h
--- a/drivers/video/rockchip/iep/iep.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,275 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _IEP_H_
+#define _IEP_H_
+
+/* Capability for current iep version
+using by userspace to determine iep features */
+struct IEP_CAP {
+	u8 scaling_supported;
+	u8 i4_deinterlace_supported;
+	u8 i2_deinterlace_supported;
+	u8 compression_noise_reduction_supported;
+	u8 sampling_noise_reduction_supported;
+	u8 hsb_enhancement_supported;
+	u8 cg_enhancement_supported;
+	u8 direct_path_supported;
+	u16 max_dynamic_width;
+	u16 max_dynamic_height;
+	u16 max_static_width;
+	u16 max_static_height;
+	u8 max_enhance_radius;
+};
+
+#define IEP_IOC_MAGIC 'i'
+
+#define IEP_SET_PARAMETER_REQ		_IOW(IEP_IOC_MAGIC, 1, unsigned long)
+#define IEP_SET_PARAMETER_DEINTERLACE	_IOW(IEP_IOC_MAGIC, 2, unsigned long)
+#define IEP_SET_PARAMETER_ENHANCE	_IOW(IEP_IOC_MAGIC, 3, unsigned long)
+#define IEP_SET_PARAMETER_CONVERT	_IOW(IEP_IOC_MAGIC, 4, unsigned long)
+#define IEP_SET_PARAMETER_SCALE		_IOW(IEP_IOC_MAGIC, 5, unsigned long)
+#define IEP_GET_RESULT_SYNC		_IOW(IEP_IOC_MAGIC, 6, unsigned long)
+#define IEP_GET_RESULT_ASYNC		_IOW(IEP_IOC_MAGIC, 7, unsigned long)
+#define IEP_SET_PARAMETER		_IOW(IEP_IOC_MAGIC, 8, unsigned long)
+#define IEP_RELEASE_CURRENT_TASK	_IOW(IEP_IOC_MAGIC, 9, unsigned long)
+#define IEP_GET_IOMMU_STATE		_IOR(IEP_IOC_MAGIC,10, unsigned long)
+#define IEP_QUERY_CAP			_IOR(IEP_IOC_MAGIC,11, struct IEP_CAP)
+
+#ifdef CONFIG_COMPAT
+#define COMPAT_IEP_SET_PARAMETER_REQ		_IOW(IEP_IOC_MAGIC, 1, u32)
+#define COMPAT_IEP_SET_PARAMETER_DEINTERLACE	_IOW(IEP_IOC_MAGIC, 2, u32)
+#define COMPAT_IEP_SET_PARAMETER_ENHANCE	_IOW(IEP_IOC_MAGIC, 3, u32)
+#define COMPAT_IEP_SET_PARAMETER_CONVERT	_IOW(IEP_IOC_MAGIC, 4, u32)
+#define COMPAT_IEP_SET_PARAMETER_SCALE		_IOW(IEP_IOC_MAGIC, 5, u32)
+#define COMPAT_IEP_GET_RESULT_SYNC		_IOW(IEP_IOC_MAGIC, 6, u32)
+#define COMPAT_IEP_GET_RESULT_ASYNC		_IOW(IEP_IOC_MAGIC, 7, u32)
+#define COMPAT_IEP_SET_PARAMETER		_IOW(IEP_IOC_MAGIC, 8, u32)
+#define COMPAT_IEP_RELEASE_CURRENT_TASK		_IOW(IEP_IOC_MAGIC, 9, u32)
+#define COMPAT_IEP_GET_IOMMU_STATE		_IOR(IEP_IOC_MAGIC,10, u32)
+#define COMPAT_IEP_QUERY_CAP			_IOR(IEP_IOC_MAGIC,11, struct IEP_CAP)
+#endif
+
+/* Driver information */
+#define DRIVER_DESC		"IEP Device Driver"
+#define DRIVER_NAME		"iep"
+
+#define DEBUG
+#ifdef DEBUG
+#define iep_debug(level, fmt, args...)				\
+	do {							\
+		if (debug >= level)				\
+			pr_info("%s:%d: " fmt,			\
+				 __func__, __LINE__, ##args);	\
+	} while (0)
+#else
+#define iep_debug(level, fmt, args...)
+#endif
+
+#define iep_debug_enter() vpu_debug(4, "enter\n")
+#define iep_debug_leave() vpu_debug(4, "leave\n")
+
+#define iep_err(fmt, args...)				\
+		pr_err("%s:%d: " fmt, __func__, __LINE__, ##args)
+
+/* Logging */
+#define IEP_DEBUG 0
+#if IEP_DEBUG
+#define IEP_DBG(format, args...)	printk("%s: " format, DRIVER_NAME, ## args)
+#else
+#define IEP_DBG(format, args...)
+#endif
+
+#define IEP_INFORMATION 1
+#if IEP_INFORMATION
+#define IEP_INFO(format, args...)	printk(format, ## args)
+#else
+#define IEP_INFO(format, args...)
+#endif
+
+#define IEP_ERR(format, args...)	printk(KERN_ERR "%s: " format, DRIVER_NAME, ## args)
+#define IEP_WARNING(format, args...)	printk(KERN_WARNING "%s: " format, DRIVER_NAME, ## args)
+
+enum {
+	yuv2rgb_BT_601_l = 0x0,     /* BT.601_1 */
+	yuv2rgb_BT_601_f = 0x1,     /* BT.601_f */
+	yuv2rgb_BT_709_l = 0x2,     /* BT.709_1 */
+	yuv2rgb_BT_709_f = 0x3,     /* BT.709_f */
+};
+
+enum {
+	rgb2yuv_BT_601_l = 0x0,     /* BT.601_1 */
+	rgb2yuv_BT_601_f = 0x1,     /* BT.601_f */
+	rgb2yuv_BT_709_l = 0x2,     /* BT.709_1 */
+	rgb2yuv_BT_709_f = 0x3,     /* BT.709_f */
+};
+
+enum {
+	dein_mode_bypass_dis         = 0x0,
+	dein_mode_I4O2               = 0x1,
+	dein_mode_I4O1B              = 0x2,
+	dein_mode_I4O1T              = 0x3,
+	dein_mode_I2O1B              = 0x4,
+	dein_mode_I2O1T              = 0x5,
+	dein_mode_bypass             = 0x6,
+};
+
+enum IEP_FIELD_ORDER {
+	FIELD_ORDER_TOP_FIRST,
+	FIELD_ORDER_BOTTOM_FIRST
+};
+
+enum IEP_YUV_DEINTERLACE_MODE {
+	IEP_DEINTERLACE_MODE_DISABLE,
+	IEP_DEINTERLACE_MODE_I2O1,
+	IEP_DEINTERLACE_MODE_I4O1,
+	IEP_DEINTERLACE_MODE_I4O2,
+	IEP_DEINTERLACE_MODE_BYPASS
+};
+
+enum {
+	rgb_enhance_bypass          = 0x0,
+	rgb_enhance_denoise         = 0x1,
+	rgb_enhance_detail          = 0x2,
+	rgb_enhance_edge            = 0x3,
+};/* for rgb_enhance_mode */
+
+enum {
+	rgb_contrast_CC_P_DDE          = 0x0, /* cg prior to dde */
+	rgb_contrast_DDE_P_CC          = 0x1, /* dde prior to cg */
+}; /* for rgb_contrast_enhance_mode */
+
+enum {
+	black_screen                   = 0x0,
+	blue_screen                    = 0x1,
+	color_bar                      = 0x2,
+	normal_mode                    = 0x3,
+}; /* for video mode */
+
+/*
+          Alpha    Red     Green   Blue  
+{  4, 32, {{32,24,   24,16,  16, 8,  8, 0 }}, GGL_RGBA },    IEP_FORMAT_ARGB_8888
+{  4, 32, {{32,24,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },    IEP_FORMAT_ABGR_8888
+{  4, 32, {{ 8, 0,  32,24,  24,16,  16, 8 }}, GGL_RGB  },    IEP_FORMAT_RGBA_8888
+{  4, 32, {{ 8, 0,  16, 8,  24,16,  32,24 }}, GGL_BGRA },    IEP_FORMAT_BGRA_8888
+{  2, 16, {{ 0, 0,  16,11,  11, 5,   5, 0 }}, GGL_RGB  },    IEP_FORMAT_RGB_565
+{  2, 16, {{ 0, 0,   5, 0,  11, 5,  16,11 }}, GGL_RGB  },    IEP_FORMAT_RGB_565
+*/
+enum {
+	IEP_FORMAT_ARGB_8888    = 0x0,
+	IEP_FORMAT_ABGR_8888    = 0x1,
+	IEP_FORMAT_RGBA_8888    = 0x2,
+	IEP_FORMAT_BGRA_8888    = 0x3,
+	IEP_FORMAT_RGB_565      = 0x4,
+	IEP_FORMAT_BGR_565      = 0x5,
+
+	IEP_FORMAT_YCbCr_422_SP = 0x10,
+	IEP_FORMAT_YCbCr_422_P  = 0x11,
+	IEP_FORMAT_YCbCr_420_SP = 0x12,
+	IEP_FORMAT_YCbCr_420_P  = 0x13,
+	IEP_FORMAT_YCrCb_422_SP = 0x14,
+	IEP_FORMAT_YCrCb_422_P  = 0x15,/* same as IEP_FORMAT_YCbCr_422_P */
+	IEP_FORMAT_YCrCb_420_SP = 0x16,
+	IEP_FORMAT_YCrCb_420_P  = 0x17,/* same as IEP_FORMAT_YCbCr_420_P */
+}; /* for format */
+
+struct iep_img
+{
+	u16 act_w;	/* act_width */
+	u16 act_h;	/* act_height */
+	s16 x_off;	/* x offset for the vir,word unit */
+	s16 y_off;	/* y offset for the vir,word unit */
+
+	u16 vir_w;	/* unit :pix */
+	u16 vir_h;	/* unit :pix */
+	u32 format;
+	u32 mem_addr;
+	u32 uv_addr;
+	u32 v_addr;
+
+	u8 rb_swap;	/* not be used */
+	u8 uv_swap;	/* not be used */
+
+	u8 alpha_swap;	/* not be used */
+};
+
+struct IEP_MSG {
+	struct iep_img src;
+	struct iep_img dst;
+
+	struct iep_img src1;
+	struct iep_img dst1;
+
+	struct iep_img src_itemp;
+	struct iep_img src_ftemp;
+
+	struct iep_img dst_itemp;
+	struct iep_img dst_ftemp;
+
+	u8 dither_up_en;
+	u8 dither_down_en;/* not to be used */
+
+	u8 yuv2rgb_mode;
+	u8 rgb2yuv_mode;
+
+	u8 global_alpha_value;
+
+	u8 rgb2yuv_clip_en;
+	u8 yuv2rgb_clip_en;
+
+	u8 lcdc_path_en;
+	s32 off_x;
+	s32 off_y;
+	s32 width;
+	s32 height;
+	s32 layer;
+
+	u8 yuv_3D_denoise_en;
+
+	/* yuv color enhance */
+	u8 yuv_enhance_en;
+	s32 sat_con_int;
+	s32 contrast_int;
+	s32 cos_hue_int;
+	s32 sin_hue_int;
+	s8 yuv_enh_brightness;	/*-32<brightness<31*/
+	u8 video_mode;		/*0-3*/
+	u8 color_bar_y;	/*0-127*/
+	u8 color_bar_u;	/*0-127*/
+	u8 color_bar_v;	/*0-127*/
+
+
+	u8 rgb_enhance_en;/*i don't konw what is used*/
+
+	u8 rgb_color_enhance_en;/*sw_rgb_color_enh_en*/
+	u32 rgb_enh_coe;
+
+	u8 rgb_enhance_mode;/*sw_rgb_enh_sel,dde sel*/
+
+	u8 rgb_cg_en;/*sw_rgb_con_gam_en*/
+	u32 cg_tab[192];
+
+	/*sw_con_gam_order;0 cg prior to dde,1 dde prior to cg*/
+	u8 rgb_contrast_enhance_mode;
+
+	s32 enh_threshold;
+	s32 enh_alpha;
+	s32 enh_radius;
+
+	u8 scale_up_mode;
+
+	u8 field_order;
+	u8 dein_mode;
+	/*DIL HF*/
+	u8 dein_high_fre_en;
+	u8 dein_high_fre_fct;
+	/*DIL EI*/
+	u8 dein_ei_mode;
+	u8 dein_ei_smooth;
+	u8 dein_ei_sel;
+	u8 dein_ei_radius;/*when dein_ei_sel=0 will be used*/
+
+	u8 vir_addr_enable;
+
+	void *base;
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/iep/iep_iommu_drm.c b/drivers/video/rockchip/iep/iep_iommu_drm.c
--- a/drivers/video/rockchip/iep/iep_iommu_drm.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep_iommu_drm.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,491 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <drm/drmP.h>
+#include <linux/dma-iommu.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+#include <linux/kref.h>
+
+#include "iep_iommu_ops.h"
+
+struct iep_drm_buffer {
+	struct list_head list;
+	struct dma_buf *dma_buf;
+	union {
+		unsigned long iova;
+		unsigned long phys;
+	};
+	unsigned long size;
+	int index;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct page **pages;
+	struct kref ref;
+	struct iep_iommu_session_info *session_info;
+};
+
+struct iep_iommu_drm_info {
+	struct iommu_domain *domain;
+	bool attached;
+};
+
+static struct iep_drm_buffer *
+iep_drm_get_buffer_no_lock(struct iep_iommu_session_info *session_info,
+			   int idx)
+{
+	struct iep_drm_buffer *drm_buffer = NULL, *n;
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		if (drm_buffer->index == idx)
+			return drm_buffer;
+	}
+
+	return NULL;
+}
+
+static struct iep_drm_buffer *
+iep_drm_get_buffer_fd_no_lock(struct iep_iommu_session_info *session_info,
+			      int fd)
+{
+	struct iep_drm_buffer *drm_buffer = NULL, *n;
+	struct dma_buf *dma_buf = NULL;
+
+	dma_buf = dma_buf_get(fd);
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		if (drm_buffer->dma_buf == dma_buf) {
+			dma_buf_put(dma_buf);
+			return drm_buffer;
+		}
+	}
+
+	dma_buf_put(dma_buf);
+
+	return NULL;
+}
+
+static void iep_drm_detach(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = iommu_info->dev;
+	struct iommu_domain *domain = drm_info->domain;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (!drm_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return;
+	}
+
+	iommu_detach_device(domain, dev);
+	drm_info->attached = false;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static int iep_drm_attach_unlock(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = iommu_info->dev;
+	struct iommu_domain *domain = drm_info->domain;
+	int ret = 0;
+
+	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
+	ret = iommu_attach_device(domain, dev);
+	if (ret) {
+		dev_err(dev, "Failed to attach iommu device\n");
+		return ret;
+	}
+
+	if (!common_iommu_setup_dma_ops(dev, 0x10000000, SZ_2G, domain->ops)) {
+		dev_err(dev, "Failed to set dma_ops\n");
+		iommu_detach_device(domain, dev);
+		ret = -ENODEV;
+	}
+
+	return ret;
+}
+
+static int iep_drm_attach(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_drm_info *drm_info = iommu_info->private;
+	int ret;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (drm_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return 0;
+	}
+
+	ret = iep_drm_attach_unlock(iommu_info);
+	if (ret) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return ret;
+	}
+
+	drm_info->attached = true;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return ret;
+}
+
+static void iep_drm_clear_map(struct kref *ref)
+{
+	struct iep_drm_buffer *drm_buffer =
+		container_of(ref, struct iep_drm_buffer, ref);
+	struct iep_iommu_session_info *session_info =
+		drm_buffer->session_info;
+	struct iep_iommu_info *iommu_info = session_info->iommu_info;
+	struct iep_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = session_info->dev;
+	struct iommu_domain *domain = drm_info->domain;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+	drm_info = session_info->iommu_info->private;
+	if (!drm_info->attached) {
+		if (iep_drm_attach_unlock(session_info->iommu_info))
+			dev_err(dev, "can't clea map, attach iommu failed.\n");
+	}
+
+	if (drm_buffer->attach) {
+		dma_buf_unmap_attachment(drm_buffer->attach, drm_buffer->sgt,
+					 DMA_BIDIRECTIONAL);
+		dma_buf_detach(drm_buffer->dma_buf, drm_buffer->attach);
+		dma_buf_put(drm_buffer->dma_buf);
+		drm_buffer->attach = NULL;
+	}
+
+	if (!drm_info->attached)
+		iommu_detach_device(domain, dev);
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static void vcdoec_drm_dump_info(struct iep_iommu_session_info *session_info)
+{
+	struct iep_drm_buffer *drm_buffer = NULL, *n;
+
+	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_OPS_DUMP,
+			"still there are below buffers stored in list\n");
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_OPS_DUMP,
+				"index %d drm_buffer dma_buf %p\n",
+				drm_buffer->index,
+				drm_buffer->dma_buf);
+	}
+}
+
+static int iep_drm_free(struct iep_iommu_session_info *session_info,
+			int idx)
+{
+	struct device *dev = session_info->dev;
+	/* please double-check all maps have been release */
+	struct iep_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = iep_drm_get_buffer_no_lock(session_info, idx);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		mutex_unlock(&session_info->list_mutex);
+
+		return -EINVAL;
+	}
+
+	if (atomic_read(&drm_buffer->ref.refcount) == 0) {
+		dma_buf_put(drm_buffer->dma_buf);
+		list_del_init(&drm_buffer->list);
+		kfree(drm_buffer);
+		session_info->buffer_nums--;
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+			"buffer nums %d\n", session_info->buffer_nums);
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	return 0;
+}
+
+static int
+iep_drm_unmap_iommu(struct iep_iommu_session_info *session_info,
+		    int idx)
+{
+	struct device *dev = session_info->dev;
+	struct iep_drm_buffer *drm_buffer;
+
+	/* Force to flush iommu table */
+	if (of_machine_is_compatible("rockchip,rk3288"))
+		rockchip_iovmm_invalidate_tlb(session_info->mmu_dev);
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = iep_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return -EINVAL;
+	}
+
+	kref_put(&drm_buffer->ref, iep_drm_clear_map);
+
+	return 0;
+}
+
+static int iep_drm_map_iommu(struct iep_iommu_session_info *session_info,
+			     int idx,
+			     unsigned long *iova,
+			     unsigned long *size)
+{
+	struct device *dev = session_info->dev;
+	struct iep_drm_buffer *drm_buffer;
+
+	/* Force to flush iommu table */
+	if (of_machine_is_compatible("rockchip,rk3288"))
+		rockchip_iovmm_invalidate_tlb(session_info->mmu_dev);
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = iep_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return -EINVAL;
+	}
+
+	kref_get(&drm_buffer->ref);
+	if (iova)
+		*iova = drm_buffer->iova;
+	if (size)
+		*size = drm_buffer->size;
+	return 0;
+}
+
+static int
+iep_drm_free_fd(struct iep_iommu_session_info *session_info, int fd)
+{
+	/* please double-check all maps have been release */
+	struct iep_drm_buffer *drm_buffer = NULL;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = iep_drm_get_buffer_fd_no_lock(session_info, fd);
+
+	if (!drm_buffer) {
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+				"can not find %d buffer in list\n", fd);
+		mutex_unlock(&session_info->list_mutex);
+
+		return -EINVAL;
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	iep_drm_unmap_iommu(session_info, drm_buffer->index);
+
+	mutex_lock(&session_info->list_mutex);
+	if (atomic_read(&drm_buffer->ref.refcount) == 0) {
+		dma_buf_put(drm_buffer->dma_buf);
+		list_del_init(&drm_buffer->list);
+		kfree(drm_buffer);
+		session_info->buffer_nums--;
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+				"buffer nums %d\n", session_info->buffer_nums);
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	return 0;
+}
+
+static void
+iep_drm_clear_session(struct iep_iommu_session_info *session_info)
+{
+	struct iep_drm_buffer *drm_buffer = NULL, *n;
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		kref_put(&drm_buffer->ref, iep_drm_clear_map);
+		iep_drm_free(session_info, drm_buffer->index);
+	}
+}
+
+static int iep_drm_import(struct iep_iommu_session_info *session_info,
+			  int fd)
+{
+	struct iep_drm_buffer *drm_buffer = NULL, *n;
+	struct iep_iommu_info *iommu_info = session_info->iommu_info;
+	struct iep_iommu_drm_info *drm_info = iommu_info->private;
+	struct iommu_domain *domain = drm_info->domain;
+	struct device *dev = session_info->dev;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct dma_buf *dma_buf;
+	int ret = 0;
+
+	dma_buf = dma_buf_get(fd);
+	if (IS_ERR(dma_buf)) {
+		ret = PTR_ERR(dma_buf);
+		return ret;
+	}
+
+	list_for_each_entry_safe(drm_buffer, n,
+				 &session_info->buffer_list, list) {
+		if (drm_buffer->dma_buf == dma_buf) {
+			dma_buf_put(dma_buf);
+			return drm_buffer->index;
+		}
+	}
+
+	drm_buffer = kzalloc(sizeof(*drm_buffer), GFP_KERNEL);
+	if (!drm_buffer) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	drm_buffer->dma_buf = dma_buf;
+	drm_buffer->session_info = session_info;
+
+	kref_init(&drm_buffer->ref);
+
+	mutex_lock(&iommu_info->iommu_mutex);
+	drm_info = session_info->iommu_info->private;
+	if (!drm_info->attached) {
+		ret = iep_drm_attach_unlock(session_info->iommu_info);
+		if (ret)
+			goto fail_out;
+	}
+
+	attach = dma_buf_attach(drm_buffer->dma_buf, dev);
+	if (IS_ERR(attach)) {
+		ret = PTR_ERR(attach);
+		goto fail_out;
+	}
+
+	get_dma_buf(drm_buffer->dma_buf);
+
+	sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+	if (IS_ERR(sgt)) {
+		ret = PTR_ERR(sgt);
+		goto fail_detach;
+	}
+
+	drm_buffer->iova = sg_dma_address(sgt->sgl);
+	drm_buffer->size = drm_buffer->dma_buf->size;
+
+	drm_buffer->attach = attach;
+	drm_buffer->sgt = sgt;
+
+	if (!drm_info->attached)
+		iommu_detach_device(domain, dev);
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	INIT_LIST_HEAD(&drm_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	session_info->buffer_nums++;
+	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+			"buffer nums %d\n", session_info->buffer_nums);
+	drm_buffer->index = session_info->max_idx;
+	list_add_tail(&drm_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return drm_buffer->index;
+
+fail_detach:
+	dev_err(dev, "dmabuf map attach failed\n");
+	dma_buf_detach(drm_buffer->dma_buf, attach);
+	dma_buf_put(drm_buffer->dma_buf);
+fail_out:
+	kfree(drm_buffer);
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return ret;
+}
+
+static int iep_drm_create(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_drm_info *drm_info;
+	int ret;
+
+	iommu_info->private = kzalloc(sizeof(*drm_info),
+				      GFP_KERNEL);
+	drm_info = iommu_info->private;
+	if (!drm_info)
+		return -ENOMEM;
+
+	drm_info->domain = iommu_domain_alloc(&platform_bus_type);
+	drm_info->attached = false;
+	if (!drm_info->domain) {
+		kfree(iommu_info->private);
+		return -ENOMEM;
+	}
+
+	ret = iommu_get_dma_cookie(drm_info->domain);
+	if (ret)
+		goto err_free_domain;
+
+	iep_drm_attach(iommu_info);
+
+	return 0;
+
+err_free_domain:
+	iommu_domain_free(drm_info->domain);
+
+	return ret;
+}
+
+static int iep_drm_destroy(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_drm_info *drm_info = iommu_info->private;
+
+	iep_drm_detach(iommu_info);
+	iommu_put_dma_cookie(drm_info->domain);
+	iommu_domain_free(drm_info->domain);
+
+	kfree(drm_info);
+	iommu_info->private = NULL;
+
+	return 0;
+}
+
+static struct iep_iommu_ops drm_ops = {
+	.create = iep_drm_create,
+	.import = iep_drm_import,
+	.free = iep_drm_free,
+	.free_fd = iep_drm_free_fd,
+	.map_iommu = iep_drm_map_iommu,
+	.unmap_iommu = iep_drm_unmap_iommu,
+	.destroy = iep_drm_destroy,
+	.dump = vcdoec_drm_dump_info,
+	.attach = iep_drm_attach,
+	.detach = iep_drm_detach,
+	.clear = iep_drm_clear_session,
+};
+
+void iep_iommu_drm_set_ops(struct iep_iommu_info *iommu_info)
+{
+	if (!iommu_info)
+		return;
+	iommu_info->ops = &drm_ops;
+}
diff -Nupr a/drivers/video/rockchip/iep/iep_iommu_ion.c b/drivers/video/rockchip/iep/iep_iommu_ion.c
--- a/drivers/video/rockchip/iep/iep_iommu_ion.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep_iommu_ion.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/rockchip_ion.h>
+#include <linux/rockchip-iovmm.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/memblock.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_graph.h>
+#include <linux/component.h>
+#include <linux/fence.h>
+#include <linux/console.h>
+#include <linux/kref.h>
+#include <linux/fdtable.h>
+
+#include "iep_iommu_ops.h"
+
+struct iep_ion_buffer {
+	struct list_head list;
+	struct ion_handle *handle;
+	int index;
+};
+
+struct iep_iommu_ion_info {
+	struct ion_client *ion_client;
+	bool attached;
+};
+
+static struct iep_ion_buffer *
+iep_ion_get_buffer_no_lock(struct iep_iommu_session_info *session_info,
+			   int idx)
+{
+	struct iep_ion_buffer *ion_buffer = NULL, *n;
+
+	list_for_each_entry_safe(ion_buffer, n,
+				 &session_info->buffer_list, list) {
+		if (ion_buffer->index == idx)
+			return ion_buffer;
+	}
+
+	return NULL;
+}
+
+static void
+iep_ion_clear_session(struct iep_iommu_session_info *session_info)
+{
+	/* do nothing */
+}
+
+static int iep_ion_attach(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_ion_info *ion_info = iommu_info->private;
+	int ret;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (ion_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return 0;
+	}
+
+	rockchip_iovmm_activate(iommu_info->dev);
+
+	ion_info->attached = true;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return ret;
+}
+
+static void iep_ion_detach(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_ion_info *ion_info = iommu_info->private;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (!ion_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return;
+	}
+
+	rockchip_iovmm_deactivate(iommu_info->dev);
+	ion_info->attached = false;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static int iep_ion_destroy(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_ion_info *ion_info = iommu_info->private;
+
+	iep_ion_detach(iommu_info);
+	kfree(ion_info);
+	iommu_info->private = NULL;
+
+	return 0;
+}
+
+static int
+iep_ion_free(struct iep_iommu_session_info *session_info, int idx)
+{
+	struct iep_ion_buffer *ion_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = iep_ion_get_buffer_no_lock(session_info, idx);
+
+	if (!ion_buffer) {
+		mutex_unlock(&session_info->list_mutex);
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	list_del_init(&ion_buffer->list);
+	mutex_unlock(&session_info->list_mutex);
+	kfree(ion_buffer);
+
+	return 0;
+}
+
+static int
+iep_ion_unmap_iommu(struct iep_iommu_session_info *session_info, int idx)
+{
+	struct iep_ion_buffer *ion_buffer;
+	struct iep_iommu_info *iommu_info = session_info->iommu_info;
+	struct iep_iommu_ion_info *ion_info = iommu_info->private;
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = iep_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	ion_free(ion_info->ion_client, ion_buffer->handle);
+
+	return 0;
+}
+
+static int
+iep_ion_map_iommu(struct iep_iommu_session_info *session_info, int idx,
+		  unsigned long *iova, unsigned long *size)
+{
+	struct iep_ion_buffer *ion_buffer;
+	struct device *dev = session_info->dev;
+	struct iep_iommu_info *iommu_info = session_info->iommu_info;
+	struct iep_iommu_ion_info *ion_info = iommu_info->private;
+	int ret = 0;
+
+	/* Force to flush iommu table */
+	rockchip_iovmm_invalidate_tlb(session_info->dev);
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = iep_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	if (session_info->mmu_dev)
+		ret = ion_map_iommu(dev, ion_info->ion_client,
+				    ion_buffer->handle, iova, size);
+	else
+		ret = ion_phys(ion_info->ion_client, ion_buffer->handle,
+			       iova, (size_t *)size);
+
+	return ret;
+}
+
+static int
+iep_ion_import(struct iep_iommu_session_info *session_info, int fd)
+{
+	struct iep_ion_buffer *ion_buffer = NULL;
+	struct iep_iommu_info *iommu_info = session_info->iommu_info;
+	struct iep_iommu_ion_info *ion_info = iommu_info->private;
+
+	ion_buffer = kzalloc(sizeof(*ion_buffer), GFP_KERNEL);
+	if (!ion_buffer)
+		return -ENOMEM;
+
+	ion_buffer->handle = ion_import_dma_buf(ion_info->ion_client, fd);
+
+	INIT_LIST_HEAD(&ion_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer->index = session_info->max_idx;
+	list_add_tail(&ion_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return ion_buffer->index;
+}
+
+static int iep_ion_create(struct iep_iommu_info *iommu_info)
+{
+	struct iep_iommu_ion_info *ion_info;
+
+	iommu_info->private = kmalloc(sizeof(*ion_info), GFP_KERNEL);
+
+	ion_info = iommu_info->private;
+	if (!ion_info)
+		return -ENOMEM;
+
+	ion_info->ion_client = rockchip_ion_client_create("vpu");
+	ion_info->attached = false;
+
+	iep_ion_attach(iommu_info);
+
+	return IS_ERR(ion_info->ion_client) ? -1 : 0;
+}
+
+static struct iep_iommu_ops ion_ops = {
+	.create = iep_ion_create,
+	.destroy = iep_ion_destroy,
+	.import = iep_ion_import,
+	.free = iep_ion_free,
+	.free_fd = NULL,
+	.map_iommu = iep_ion_map_iommu,
+	.unmap_iommu = iep_ion_unmap_iommu,
+	.dump = NULL,
+	.attach = iep_ion_attach,
+	.detach = iep_ion_detach,
+	.clear = iep_ion_clear_session,
+};
+
+/*
+ * we do not manage the ref number ourselves,
+ * since ion will help us to do that. what we
+ * need to do is just map/unmap and import/free
+ * every time
+ */
+void iep_iommu_ion_set_ops(struct iep_iommu_info *iommu_info)
+{
+	if (!iommu_info)
+		return;
+	iommu_info->ops = &ion_ops;
+}
diff -Nupr a/drivers/video/rockchip/iep/iep_iommu_ops.c b/drivers/video/rockchip/iep/iep_iommu_ops.c
--- a/drivers/video/rockchip/iep/iep_iommu_ops.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep_iommu_ops.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,248 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/slab.h>
+
+#include "iep_iommu_ops.h"
+
+static
+struct iep_iommu_session_info *iep_iommu_get_session_info
+	(struct iep_iommu_info *iommu_info, struct iep_session *session)
+{
+	struct iep_iommu_session_info *session_info = NULL, *n;
+
+	list_for_each_entry_safe(session_info, n, &iommu_info->session_list,
+				 head) {
+		if (session_info->session == session)
+			return session_info;
+	}
+
+	return NULL;
+}
+
+int iep_iommu_create(struct iep_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->create)
+		return -EINVAL;
+
+	return iommu_info->ops->create(iommu_info);
+}
+
+int iep_iommu_import(struct iep_iommu_info *iommu_info,
+		     struct iep_session *session, int fd)
+{
+	struct iep_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info || !iommu_info->ops->import || !session)
+		return -EINVAL;
+
+	session_info = iep_iommu_get_session_info(iommu_info, session);
+	if (!session_info) {
+		session_info = kzalloc(sizeof(*session_info), GFP_KERNEL);
+		if (!session_info)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&session_info->head);
+		INIT_LIST_HEAD(&session_info->buffer_list);
+		mutex_init(&session_info->list_mutex);
+		session_info->max_idx = 0;
+		session_info->session = session;
+		session_info->mmu_dev = iommu_info->mmu_dev;
+		session_info->dev = iommu_info->dev;
+		session_info->iommu_info = iommu_info;
+		session_info->buffer_nums = 0;
+		mutex_lock(&iommu_info->list_mutex);
+		list_add_tail(&session_info->head, &iommu_info->session_list);
+		mutex_unlock(&iommu_info->list_mutex);
+	}
+
+	session_info->debug_level = iommu_info->debug_level;
+
+	return iommu_info->ops->import(session_info, fd);
+}
+
+int iep_iommu_free(struct iep_iommu_info *iommu_info,
+		   struct iep_session *session, int idx)
+{
+	struct iep_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info)
+		return -EINVAL;
+
+	session_info = iep_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info->ops->free || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->free(session_info, idx);
+}
+
+int iep_iommu_free_fd(struct iep_iommu_info *iommu_info,
+		      struct iep_session *session, int fd)
+{
+	struct iep_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info)
+		return -EINVAL;
+
+	session_info = iep_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info->ops->free_fd || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->free_fd(session_info, fd);
+}
+
+int iep_iommu_map_iommu(struct iep_iommu_info *iommu_info,
+			struct iep_session *session,
+			int idx, unsigned long *iova,
+			unsigned long *size)
+{
+	struct iep_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info)
+		return -EINVAL;
+
+	session_info = iep_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info->ops->map_iommu || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->map_iommu(session_info, idx, iova, size);
+}
+
+int iep_iommu_unmap_iommu(struct iep_iommu_info *iommu_info,
+			  struct iep_session *session, int idx)
+{
+	struct iep_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info)
+		return -EINVAL;
+
+	session_info = iep_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info->ops->unmap_iommu || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->unmap_iommu(session_info, idx);
+}
+
+int iep_iommu_destroy(struct iep_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->destroy)
+		return -EINVAL;
+
+	return iommu_info->ops->destroy(iommu_info);
+}
+
+void iep_iommu_dump(struct iep_iommu_info *iommu_info,
+		    struct iep_session *session)
+{
+	struct iep_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info)
+		return;
+
+	session_info = iep_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info->ops->dump || !session_info)
+		return;
+
+	iommu_info->ops->dump(session_info);
+}
+
+void iep_iommu_clear(struct iep_iommu_info *iommu_info,
+		     struct iep_session *session)
+{
+	struct iep_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info)
+		return;
+
+	session_info = iep_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info->ops->clear || !session_info)
+		return;
+
+	iommu_info->ops->clear(session_info);
+
+	mutex_lock(&iommu_info->list_mutex);
+	list_del_init(&session_info->head);
+	kfree(session_info);
+	mutex_unlock(&iommu_info->list_mutex);
+}
+
+int iep_iommu_attach(struct iep_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->attach)
+		return 0;
+
+	return iommu_info->ops->attach(iommu_info);
+}
+
+void iep_iommu_detach(struct iep_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->detach)
+		return;
+
+	return iommu_info->ops->detach(iommu_info);
+}
+
+struct iep_iommu_info *
+iep_iommu_info_create(struct device *dev,
+		      struct device *mmu_dev,
+		      int alloc_type)
+{
+	struct iep_iommu_info *iommu_info = NULL;
+
+	iommu_info = kzalloc(sizeof(*iommu_info), GFP_KERNEL);
+	if (!iommu_info)
+		return NULL;
+
+	iommu_info->dev = dev;
+	INIT_LIST_HEAD(&iommu_info->session_list);
+	mutex_init(&iommu_info->list_mutex);
+	mutex_init(&iommu_info->iommu_mutex);
+	switch (alloc_type) {
+#ifdef CONFIG_DRM
+	case ALLOCATOR_USE_DRM:
+		iep_iommu_drm_set_ops(iommu_info);
+		break;
+#endif
+#ifdef CONFIG_ION
+	case ALLOCATOR_USE_ION:
+		iep_iommu_ion_set_ops(iommu_info);
+		break;
+#endif
+	default:
+		iommu_info->ops = NULL;
+		break;
+	}
+
+	iommu_info->mmu_dev = mmu_dev;
+
+	iep_iommu_create(iommu_info);
+
+	return iommu_info;
+}
+
+int iep_iommu_info_destroy(struct iep_iommu_info *iommu_info)
+{
+	iep_iommu_destroy(iommu_info);
+	kfree(iommu_info);
+
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/iep/iep_iommu_ops.h b/drivers/video/rockchip/iep/iep_iommu_ops.h
--- a/drivers/video/rockchip/iep/iep_iommu_ops.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep_iommu_ops.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,125 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __IEP_IOMMU_OPS_H__
+#define __IEP_IOMMU_OPS_H__
+
+#include <linux/platform_device.h>
+#include <linux/rockchip-iovmm.h>
+#include "iep_drv.h"
+
+#define BUFFER_LIST_MAX_NUMS	30
+
+#define ALLOCATOR_USE_ION		0x00000000
+#define ALLOCATOR_USE_DRM		0x00000001
+
+#define DEBUG_IOMMU_OPS_DUMP	0x00020000
+#define DEBUG_IOMMU_NORMAL	0x00040000
+
+#define vpu_iommu_debug_func(debug_level, type, fmt, args...)	\
+	do {							\
+		if (unlikely(debug_level & type)) {		\
+			pr_info("%s:%d: " fmt,			\
+				 __func__, __LINE__, ##args);	\
+		}						\
+	} while (0)
+#define vpu_iommu_debug(debug_level, type, fmt, args...)	\
+	do {							\
+		if (unlikely(debug_level & type)) {		\
+			pr_info(fmt, ##args);			\
+		}						\
+	} while (0)
+
+struct iep_iommu_info;
+struct iep_iommu_session_info;
+
+struct iep_iommu_ops {
+	int (*create)(struct iep_iommu_info *iommu_info);
+	int (*import)(struct iep_iommu_session_info *session_info, int fd);
+	int (*free)(struct iep_iommu_session_info *session_info, int idx);
+	int (*free_fd)(struct iep_iommu_session_info *session_info, int fd);
+	int (*map_iommu)(struct iep_iommu_session_info *session_info,
+			 int idx,
+			 unsigned long *iova, unsigned long *size);
+	int (*unmap_iommu)(struct iep_iommu_session_info *session_info,
+			   int idx);
+	int (*destroy)(struct iep_iommu_info *iommu_info);
+	void (*dump)(struct iep_iommu_session_info *session_info);
+	int (*attach)(struct iep_iommu_info *iommu_info);
+	void (*detach)(struct iep_iommu_info *iommu_info);
+	void (*clear)(struct iep_iommu_session_info *session_info);
+};
+
+struct iep_iommu_session_info {
+	struct list_head head;
+	struct iep_session *session;
+	int buffer_nums;
+	struct list_head buffer_list;
+	struct mutex list_mutex;
+	int max_idx;
+	struct device *dev;
+	struct device *mmu_dev;
+	struct iep_iommu_info *iommu_info;
+	int debug_level;
+};
+
+struct iep_iommu_info {
+	struct list_head session_list;
+	struct mutex list_mutex;
+	struct mutex iommu_mutex;
+	struct device *dev;
+	struct device *mmu_dev;
+	struct iep_iommu_ops *ops;
+	int debug_level;
+	void *private;
+};
+
+#ifdef CONFIG_DRM
+void iep_iommu_drm_set_ops(struct iep_iommu_info *iommu_info);
+#endif
+#ifdef CONFIG_ION
+void iep_iommu_ion_set_ops(struct iep_iommu_info *iommu_info);
+#endif
+
+struct iep_iommu_info *iep_iommu_info_create(struct device *dev,
+					     struct device *mmu_dev,
+					     int alloc_type);
+int iep_iommu_info_destroy(struct iep_iommu_info *iommu_info);
+
+int iep_iommu_create(struct iep_iommu_info *iommu_info);
+int iep_iommu_import(struct iep_iommu_info *iommu_info,
+		     struct iep_session *session, int fd);
+int iep_iommu_free(struct iep_iommu_info *iommu_info,
+		   struct iep_session *session, int idx);
+int iep_iommu_free_fd(struct iep_iommu_info *iommu_info,
+		      struct iep_session *session, int fd);
+int iep_iommu_map_iommu(struct iep_iommu_info *iommu_info,
+			struct iep_session *session,
+			int idx,
+			unsigned long *iova,
+			unsigned long *size);
+int iep_iommu_unmap_iommu(struct iep_iommu_info *iommu_info,
+			  struct iep_session *session,
+			  int idx);
+int iep_iommu_destroy(struct iep_iommu_info *iommu_info);
+void iep_iommu_dump(struct iep_iommu_info *iommu_info,
+		    struct iep_session *session);
+void iep_iommu_clear(struct iep_iommu_info *iommu_info,
+		     struct iep_session *session);
+
+int iep_iommu_attach(struct iep_iommu_info *iommu_info);
+void iep_iommu_detach(struct iep_iommu_info *iommu_info);
+
+#endif
diff -Nupr a/drivers/video/rockchip/iep/iep_mmu.c b/drivers/video/rockchip/iep/iep_mmu.c
--- a/drivers/video/rockchip/iep/iep_mmu.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep_mmu.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,233 @@
+/* 
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ */
+
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <asm/cacheflush.h>
+#include "iep_mmu.h"
+
+#define RK_MMU_DTE_SHIFT    22
+#define RK_MMU_DTE_MASK     (~0xFFFL)
+#define RK_MMU_PTE_SHIFT    12
+#define RK_MMU_PTE_MASK     (~0xFFFL)
+#define RK_MMU_DTE_ENTRY_CNT    ((1) << (32-RK_MMU_DTE_SHIFT))
+#define RK_MMU_PTE_ENTRY_CNT    ((1) << (RK_MMU_DTE_SHIFT - RK_MMU_PTE_SHIFT))
+
+#define RK_MMU_PAGE_PRESENT                 (1<<0)
+#define RK_MMU_READ_PERMISSION              (1<<1)
+#define RK_MMU_WRITE_PERMISSION             (1<<2)
+#define RK_MMU_OVERRIDE_CACHE_ATTRIBUTES    (0<<3)
+#define RK_MMU_WRITE_CACHE_ABLE             (0<<4)
+#define RK_MMU_WRITE_ALLOCABLE              (0<<5)
+#define RK_MMU_WRITE_BUFFERABLE             (0<<6)
+#define RK_MMU_READ_CACHE_ABLE              (0<<7)
+#define RK_MMU_READ_ALLOCABLE               (0<<8)
+
+#define RK_MMU_PTE_CTRL     (RK_MMU_PAGE_PRESENT | RK_MMU_READ_PERMISSION | \
+                            RK_MMU_WRITE_PERMISSION | RK_MMU_OVERRIDE_CACHE_ATTRIBUTES | \
+                            RK_MMU_WRITE_CACHE_ABLE | RK_MMU_WRITE_ALLOCABLE | \
+                            RK_MMU_WRITE_BUFFERABLE | RK_MMU_READ_CACHE_ABLE | \
+                            RK_MMU_READ_ALLOCABLE)
+
+#define RK_MMU_DTE_CTRL     RK_MMU_PAGE_PRESENT
+
+//#define RK_MMU_DEBUG
+
+static int map_user_space_addr(struct task_struct *tsk,
+                               uint32_t *pte_table,
+                               uint32_t page_index,
+                               uint32_t page_count)
+{
+    int result;
+    int i;
+    int status = 0;
+    uint32_t phy_addr = 0;
+    struct page **pages;
+
+    pages = kzalloc((page_count + 1) * sizeof(struct page*), GFP_KERNEL);
+
+    down_read(&tsk->mm->mmap_sem);
+    result = get_user_pages(tsk, 
+                            tsk->mm, 
+                            page_index << PAGE_SHIFT, 
+                            page_count,
+                            1, 0, pages, NULL
+                            );
+    up_read(&tsk->mm->mmap_sem);
+
+    if (result <= 0 || result < page_count) {
+        struct vm_area_struct *vma;
+
+        for(i=0; i<page_count; i++) {
+            vma = find_vma(tsk->mm, (page_index + i) << PAGE_SHIFT);
+
+            if (vma) {
+                pte_t *pte;
+                spinlock_t *ptl;
+                unsigned long pfn;
+                pgd_t *pgd;
+                pud_t *pud;
+                pmd_t *pmd;
+
+                pgd = pgd_offset(tsk->mm, (page_index + i) << PAGE_SHIFT);
+
+                if (pgd_none(*pgd) || pgd_bad(*pgd)) {
+                    IEP_ERR("iep, invalid pgd\n");
+                    status = -EIO;
+                    break;
+                }
+
+                pud = pud_offset(pgd, (page_index + i) << PAGE_SHIFT);
+                if (pud_none(*pud) || pud_bad(*pud)) {
+                    IEP_ERR("iep, invalid pud\n");
+                    status = -EIO;
+                    break;
+                }
+
+                pmd = pmd_offset(pud, (page_index + i) << PAGE_SHIFT);
+                if (pmd_none(*pmd) || pmd_bad(*pmd)) {
+                    status = -EIO;
+                    continue;
+                }
+
+                pte = pte_offset_map_lock(tsk->mm, pmd, (page_index + i) << PAGE_SHIFT, &ptl);
+                if (pte_none(*pte)) {
+                    pte_unmap_unlock(pte, ptl);
+                    status = -EIO;
+                    continue;
+                }
+
+                pfn = pte_pfn(*pte);
+                phy_addr = ((pfn << PAGE_SHIFT) | (((unsigned long)((page_index + i) << PAGE_SHIFT)) & ~PAGE_MASK));
+                pte_unmap_unlock(pte, ptl);
+
+                pte_table[i] = (phy_addr & RK_MMU_PTE_MASK) | RK_MMU_PTE_CTRL;
+            } else {
+                status = -EIO;
+                break;
+            }
+        }
+
+    } else {
+        /* fill the page table. */
+        for(i=0; i<page_count; i++) {
+            /* get the physical address from page struct. */
+            pte_table[i] = (page_to_phys(pages[i]) & RK_MMU_PTE_MASK) | RK_MMU_PTE_CTRL;
+        }
+    }
+
+    kfree(pages);
+
+    return status;
+}
+
+int rk_mmu_generate_pte_from_va(iep_session *session, uint32_t va) 
+{
+    int i;
+    int dte_index = va >> RK_MMU_DTE_SHIFT;
+    struct rk_mmu_pte *pte_node = NULL, *n;
+
+
+    if (session->dte_table[dte_index] != 0) {
+        list_for_each_entry_safe(pte_node, n, &session->pte_list, session_link) {
+            if (pte_node->index == dte_index) {
+                // a incomplete pte.
+#ifdef RK_MMU_DEBUG
+                uint32_t phy_addr;
+                uint32_t dte_addr;
+                uint32_t *pte_table;
+                uint32_t pte_addr;
+
+                int pte_index = (va >> PAGE_SHIFT) & 0x3FF;
+                int page_index = va & 0xFFF;
+
+                dte_addr = session->dte_table[dte_index];
+                IEP_DBG("dte_addr = %08x\n", dte_addr);
+
+                pte_table = phys_to_virt(dte_addr & RK_MMU_DTE_MASK);
+
+                pte_addr = pte_table[pte_index];
+
+                IEP_DBG("pte_addr = %08x\n", pte_addr);
+
+                phy_addr = (pte_addr & RK_MMU_PTE_MASK) | page_index;
+
+                IEP_DBG("phy %08x\n", phy_addr);
+#endif
+                IEP_DBG("Incomplete pte\n");
+                break;
+            }
+        }
+    }
+
+    if (pte_node == NULL || pte_node->index != dte_index) {
+        // pte node is absence
+        pte_node = (struct rk_mmu_pte*)kzalloc(sizeof(struct rk_mmu_pte), GFP_KERNEL);
+        pte_node->pte = (uint32_t*)kzalloc(sizeof(uint32_t) * RK_MMU_PTE_ENTRY_CNT, GFP_KERNEL);
+        pte_node->index = dte_index;
+    }
+    
+    IEP_DBG("va = %08x\n", va);
+
+    if (va < PAGE_OFFSET) {
+        map_user_space_addr(session->tsk, pte_node->pte, (va >> PAGE_SHIFT) & (~0x3FFL), RK_MMU_PTE_ENTRY_CNT);
+    } else {
+        for (i=0; i<RK_MMU_PTE_ENTRY_CNT; i++) {
+            pte_node->pte[i] = (uint32_t)(virt_to_phys((uint32_t*)((va + i) << PAGE_SHIFT)) & RK_MMU_PTE_MASK) | RK_MMU_PTE_CTRL;
+        }
+    }
+
+    IEP_DBG("pa = %08x\n", (uint32_t)((pte_node->pte[(va>>PAGE_SHIFT) & 0x3FFL] & RK_MMU_PTE_MASK) | (va & 0xFFFL)));
+
+    INIT_LIST_HEAD(&pte_node->session_link);
+    list_add_tail(&pte_node->session_link, &session->pte_list);
+
+    dmac_flush_range(&pte_node->pte[0], &pte_node->pte[RK_MMU_PTE_ENTRY_CNT-1]);
+    outer_flush_range(virt_to_phys(&pte_node->pte[0]),virt_to_phys(&pte_node->pte[RK_MMU_PTE_ENTRY_CNT-1]));
+
+    session->dte_table[pte_node->index] = (uint32_t)(virt_to_phys((uint32_t*)pte_node->pte) & RK_MMU_DTE_MASK) | RK_MMU_DTE_CTRL;
+
+    dmac_flush_range(&session->dte_table[pte_node->index], &session->dte_table[pte_node->index+1]);
+    outer_flush_range(virt_to_phys(&session->dte_table[pte_node->index]),virt_to_phys(&session->dte_table[pte_node->index+1]));
+
+    return 0;
+}
+
+void rk_mmu_reclaim_pte_list(iep_session *session)
+{
+    struct rk_mmu_pte *pte_node, *n;
+
+    list_for_each_entry_safe(pte_node, n, &session->pte_list, session_link) {
+        list_del_init(&pte_node->session_link);
+        kfree(pte_node->pte);
+        kfree(pte_node);
+    }
+}
+
+/// don't call this function in interupt service.
+int rk_mmu_init_dte_table(iep_session *session)
+{
+    session->tsk = current;
+    session->dte_table = (uint32_t*)kzalloc(sizeof(uint32_t) * RK_MMU_DTE_ENTRY_CNT, GFP_KERNEL);
+
+    return 0;
+}
+
+void rk_mmu_deinit_dte_table(iep_session *session)
+{
+    rk_mmu_reclaim_pte_list(session);
+    kfree(session->dte_table);
+}
+
diff -Nupr a/drivers/video/rockchip/iep/iep_mmu.h b/drivers/video/rockchip/iep/iep_mmu.h
--- a/drivers/video/rockchip/iep/iep_mmu.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/iep_mmu.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _IEP_MMU_H_
+#define _IEP_MMU_H_
+
+#include <linux/types.h>
+#include "iep_drv.h"
+
+struct rk_mmu_pte {
+    int index;                      // dte entry index [0, 1023]
+    uint32_t *pte;                  // point to pte table
+    struct list_head session_link;  // link to session
+};
+
+int rk_mmu_generate_pte_from_va(iep_session *session, uint32_t va);
+void rk_mmu_reclaim_pte_list(iep_session *session);
+int rk_mmu_init_dte_table(iep_session *session);
+void rk_mmu_deinit_dte_table(iep_session *session);
+
+#endif
diff -Nupr a/drivers/video/rockchip/iep/Kconfig b/drivers/video/rockchip/iep/Kconfig
--- a/drivers/video/rockchip/iep/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0
+menu "IEP"
+	depends on ARCH_ROCKCHIP
+
+config IEP
+	tristate "ROCKCHIP IEP driver"
+	help
+	  rockchip iep module.
+
+config IEP_MMU
+	tristate "ROCKCHIP IEP MMU driver"
+	depends on ARCH_ROCKCHIP
+	help
+	  rockchip iep mmu
+
+endmenu
diff -Nupr a/drivers/video/rockchip/iep/Makefile b/drivers/video/rockchip/iep/Makefile
--- a/drivers/video/rockchip/iep/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/iep/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_IEP) += hw_iep_reg.o iep_drv.o iep_iommu_drm.o iep_iommu_ion.o iep_iommu_ops.o
diff -Nupr a/drivers/video/rockchip/Kconfig b/drivers/video/rockchip/Kconfig
--- a/drivers/video/rockchip/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,73 @@
+# SPDX-License-Identifier: GPL-2.0
+menuconfig FB_ROCKCHIP
+	tristate "Frame buffer support for Rockchip "
+	depends on FB
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_MODE_HELPERS
+	select VIDEOMODE_HELPERS
+        help
+          Framebuffer driver for rockchip based platform
+
+config FB_MIRRORING
+	bool     "Mirroring support"
+	depends on FB_ROCKCHIP
+choice
+        bool "Dual display ploy select"
+	depends on FB_ROCKCHIP
+	default NO_DUAL_DISP
+        help
+	  If you use dual lcdc for dual display ,select "implement dual display in kernel with dual lcdc"
+	  If you use one lcdc like rk2928 or one lcdc with RK Jetta,select "one lcdc dual output display interface support"
+	
+config DUAL_LCDC_DUAL_DISP_IN_KERNEL
+        bool "implement dual display in kernel with dual lcdc"
+        depends on FB_ROCKCHIP
+        help
+          select y will implement dual screen display in kernel
+
+config ONE_LCDC_DUAL_OUTPUT_INF
+        bool "one lcdc dual output display interface support"
+        depends on FB_ROCKCHIP
+        help
+          select y if on platform like rk2928 which have one lcdc but two output interface
+config NO_DUAL_DISP
+	bool "NO dual display needed"
+	depends on FB_ROCKCHIP
+	help
+	  No dual display needed
+endchoice
+
+config FB_ROTATE
+	bool"FB rotate support"
+	depends on FB_ROCKCHIP
+	default n
+	help
+	  select y if you need rotate your screen
+
+config ROTATE_ORIENTATION
+	int "rotate orientation"
+	depends on FB_ROTATE
+	default 0
+	help
+	  select 0, 90, 180,270 according to your Mold
+config THREE_FB_BUFFER
+        bool "Three fb buffer support"
+        depends on FB_ROCKCHIP
+        default y
+        help
+           select y if android support three buffer,like Jelly Bean
+
+
+source "drivers/video/rockchip/lcdc/Kconfig"
+source "drivers/video/rockchip/screen/Kconfig"
+source "drivers/video/rockchip/transmitter/Kconfig"
+source "drivers/video/rockchip/hdmi/Kconfig"
+source "drivers/video/rockchip/tve/Kconfig"
+source "drivers/video/rockchip/rga/Kconfig"
+source "drivers/video/rockchip/rga2/Kconfig"
+source "drivers/video/rockchip/vcodec/Kconfig"
+source "drivers/video/rockchip/iep/Kconfig"
+source "drivers/video/rockchip/dp/Kconfig"
+source "drivers/video/rockchip/vpu/Kconfig"
diff -Nupr a/drivers/video/rockchip/lcdc/Kconfig b/drivers/video/rockchip/lcdc/Kconfig
--- a/drivers/video/rockchip/lcdc/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,66 @@
+# SPDX-License-Identifier: GPL-2.0
+config LCDC_RK2928
+        tristate "rk2928 lcdc support"
+        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK2928
+        help
+          Driver for rk2928 lcdc .
+
+config LCDC_RK30
+        tristate "rk30 lcdc support"
+        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK30XX
+        help
+          Driver for rk30 lcdc .There are two lcd controllers on rk30
+
+config LCDC_RK3066B
+        tristate "rk3066b lcdc support"
+        depends on (DRM_ROCKCHIP || FB_ROCKCHIP) && ARCH_RK3066B
+        help
+          Driver for rk3066b  lcdc.
+
+config LCDC_RK3188
+        bool "rk3188 lcdc support"
+        depends on DRM_ROCKCHIP || FB_ROCKCHIP 
+	depends on ARM
+        help
+          Driver for rk3188/rk302x/rk319x lcdc.There are two lcd controllers on rk3188
+
+config LCDC_RK3288
+        bool "rk3288 lcdc support"
+        depends on DRM_ROCKCHIP || FB_ROCKCHIP 
+	depends on ARM
+        help
+          Driver for rk3288 lcdc.There are two lcd controllers on rk3288
+
+config LCDC_RK3036
+	bool "rk3036 lcdc support"
+	depends on DRM_ROCKCHIP || FB_ROCKCHIP 
+	depends on ARM
+        help
+          Driver for rk3036 lcdc.
+
+config LCDC_RK312X
+        bool "rk312x lcdc support"
+        depends on DRM_ROCKCHIP || FB_ROCKCHIP
+	depends on ARM
+        help
+          Driver for rk312x lcdc.
+
+config LCDC_RK3368
+	bool "rk3368 lcdc support"
+	depends on DRM_ROCKCHIP || FB_ROCKCHIP
+	depends on ARM64
+	help
+	  Driver for rk3368 lcdc.There are one lcd controllers on rk3368
+
+config LCDC_RK322X
+	bool "rk322x lcdc support"
+	depends on FB_ROCKCHIP
+	help
+	  Driver for rk322x lcdc.There are one lcd controllers on rk322x
+
+config LCDC_LITE_RK3X
+	bool "rk lcdc lite support"
+	depends on FB_ROCKCHIP
+	help
+	  Driver for rk lcdc lite.There are one lcd controllers on rk3366 or
+	  on other chips in future
diff -Nupr a/drivers/video/rockchip/lcdc/Makefile b/drivers/video/rockchip/lcdc/Makefile
--- a/drivers/video/rockchip/lcdc/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_LCDC_RK30) += rk30_lcdc.o
+obj-$(CONFIG_LCDC_RK2928) += rk2928_lcdc.o
+obj-$(CONFIG_LCDC_RK3066B) += rk3066b_lcdc.o
+obj-$(CONFIG_LCDC_RK3188) += rk3188_lcdc.o
+obj-$(CONFIG_LCDC_RK3288) += rk3288_lcdc.o
+obj-$(CONFIG_LCDC_RK3036) += rk3036_lcdc.o
+obj-$(CONFIG_LCDC_RK312X) += rk312x_lcdc.o
+obj-$(CONFIG_LCDC_RK3368) += rk3368_lcdc.o
+obj-$(CONFIG_LCDC_RK322X) += rk322x_lcdc.o
+obj-$(CONFIG_LCDC_LITE_RK3X) += rk_vop_lite.o
diff -Nupr a/drivers/video/rockchip/lcdc/rk2928_lcdc.c b/drivers/video/rockchip/lcdc/rk2928_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk2928_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk2928_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1422 @@
+/*
+ * drivers/video/rockchip/chips/rk2928_lcdc.c
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *Author:yzq<yzq@rock-chips.com>
+ *	yxj<yxj@rock-chips.com>
+ *This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/earlysuspend.h>
+#include <asm/div64.h>
+#include <asm/uaccess.h>
+#include <mach/iomux.h>
+#include <mach/gpio.h>
+#include "rk2928_lcdc.h"
+#include "../transmitter/rk2928_lvds.h"
+
+
+
+
+
+static int dbg_thresd = 0;
+module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
+#define DBG(level,x...) do { if(unlikely(dbg_thresd >= level)) printk(KERN_INFO x); } while (0)
+
+
+
+//rk2928 lcdc iomux,mode:0,gpio,1 lcdc io
+static int rk2928_lcdc_iomux(rk_screen *screen,int mode)
+{
+	int ret = 0;
+	int i=0;
+	if((screen->type == SCREEN_RGB)&&(mode)) //iomux for RGB screen
+	{
+		for(i=0;i<8;i++)
+		{
+			gpio_free(RK2928_PIN2_PB0 + i); 
+		}
+		for(i=0;i<4;i++)
+		{
+			gpio_free(RK2928_PIN2_PC0 + i);
+		}
+
+		if(screen->lcdc_id == 0)
+		{
+			rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_LCDC0_DCLK);
+			rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME, GPIO2B_LCDC0_HSYNC);
+			rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, GPIO2B_LCDC0_VSYNC);
+			rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_LCDC0_DEN);
+			rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_LCDC0_D10);
+			rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_LCDC0_D11);
+			rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_LCDC0_D12);
+			rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_LCDC0_D13);
+			rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_LCDC0_D14);
+			rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_LCDC0_D15);
+			rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_LCDC0_D16);
+			rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_LCDC0_D17);
+		}
+		else if(screen->lcdc_id == 1)
+		{
+			rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_LCDC1_DCLK);
+			rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME, GPIO2B_LCDC1_HSYNC);
+			rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, GPIO2B_LCDC1_VSYNC);
+			rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_LCDC1_DEN);
+			rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_LCDC1_D10);
+			rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_LCDC1_D11);
+			rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_LCDC1_D12);
+			rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_LCDC1_D13);
+			rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_LCDC1_D14);
+			rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_LCDC1_D15);
+			rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_LCDC1_D16);
+			rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_LCDC1_D17);
+		}
+		else
+		{
+			printk(KERN_WARNING "%s>>>no such interface:%d\n",__func__,screen->lcdc_id);
+			return -1;
+		}	
+	}
+	else if((screen->type == SCREEN_RGB)&&(!mode))
+	{
+		rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_GPIO2B0 );
+		rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME,GPIO2B_GPIO2B1);
+		rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, 	GPIO2B_GPIO2B2);
+		rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_GPIO2B3);
+		rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_GPIO2B4 );
+		rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_GPIO2B5 );
+		rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_GPIO2B6 );
+		rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_GPIO2B7 );
+		rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_GPIO2C0);
+		rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_GPIO2C1);
+		rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_GPIO2C2);
+		rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_GPIO2C3);
+		for(i=0;i<8;i++)
+		{
+			ret += gpio_request(RK2928_PIN2_PB0 + i, NULL);
+			gpio_direction_output(RK2928_PIN2_PB0 + i, 0); 
+		}
+		for(i=0;i<4;i++)
+		{
+			ret += gpio_request(RK2928_PIN2_PC0 + i, NULL);
+			gpio_direction_output(RK2928_PIN2_PC0 + i, 0); 
+		}
+		if(ret < 0)
+		{
+			printk("%s:some gpio request fail\n",__func__);
+		}
+	}
+	return 0;
+}
+static int init_rk2928_lcdc(struct rk_lcdc_device_driver *dev_drv)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+	if(lcdc_dev->id == 0) //lcdc0
+	{
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
+		lcdc_dev->sclk = clk_get(NULL,"sclk_lcdc0");
+	}
+	else
+	{
+		printk(KERN_ERR "invalid lcdc device!\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(lcdc_dev->sclk) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
+    	{
+       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
+   	}
+
+	clk_enable(lcdc_dev->pd);
+	clk_enable(lcdc_dev->hclk);  //enable aclk and hclk for register config
+	clk_enable(lcdc_dev->aclk);  
+	lcdc_dev->clk_on = 1;
+	LcdSetBit(lcdc_dev,SYS_CFG, m_LCDC_AXICLK_AUTO_ENABLE);//eanble axi-clk auto gating for low power
+	LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR | m_BUS_ERR_INT_CLEAR | m_LINE_FLAG_INT_EN |
+              m_FRM_START_INT_EN | m_HOR_START_INT_EN,v_FRM_START_INT_CLEAR(1) | v_BUS_ERR_INT_CLEAR(0) |
+              v_LINE_FLAG_INT_EN(0) | v_FRM_START_INT_EN(0) | v_HOR_START_INT_EN(0));  //enable frame start interrupt for sync
+	//LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
+	return 0;
+}
+
+static int rk2928_lcdc_deinit(struct rk2928_lcdc_device *lcdc_dev)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+		LcdMskReg(lcdc_dev, INT_STATUS, m_HOR_START_INT_EN | m_FRM_START_INT_EN | 
+			m_LINE_FLAG_INT_EN | m_BUS_ERR_INT_EN,v_HOR_START_INT_EN(0) | v_FRM_START_INT_EN(0) | 
+			v_LINE_FLAG_INT_EN(0) | v_BUS_ERR_INT_EN(0));  //disable all lcdc interrupt
+		LcdSetBit(lcdc_dev,SYS_CFG,m_LCDC_STANDBY);
+		LCDC_REG_CFG_DONE();
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else   //clk already disabled 
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	mdelay(1);
+	
+	return 0;
+}
+
+static int rk2928_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
+{
+	int ret = -EINVAL;
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+	rk_screen *screen = dev_drv->cur_screen;
+	rk_screen *screen0 = dev_drv->screen0;
+	u64 ft;
+	int fps;
+	u16 face;
+	u16 right_margin = screen->right_margin;
+	u16 lower_margin = screen->lower_margin;
+	u16 x_res = screen->x_res, y_res = screen->y_res;
+	DBG(1,"left_margin:%d>>hsync_len:%d>>xres:%d>>right_margin:%d>>upper_margin:%d>>vsync_len:%d>>yres:%d>>lower_margin:%d\n",
+		screen->left_margin,screen->hsync_len,screen->x_res,screen->right_margin,screen->upper_margin,screen->vsync_len,screen->y_res,
+		screen->lower_margin);
+	// set the rgb or mcu
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(screen->type==SCREEN_MCU)
+		{
+	    		printk(KERN_ERR "MCU Screen is not supported by RK2928\n");
+	
+		}
+
+		switch (screen->face)
+		{
+	        	case OUT_P565:
+	            		face = OUT_P565;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_P666:
+	            		face = OUT_P666;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_D888_P565:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_D888_P666:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_P888:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
+	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	default:
+	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
+	            		LcdMskReg(lcdc_dev, DSP_CTRL, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		face = screen->face;
+	            		break;
+		}
+
+		//use default overlay,set vsyn hsync den dclk polarity
+		LcdMskReg(lcdc_dev, DSP_CTRL,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
+	     		m_DEN_POLARITY |m_DCLK_POLARITY | m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_BLACK_MODE,
+	     		v_DISPLAY_FORMAT(face) | v_HSYNC_POLARITY(screen->pin_hsync) | 
+	     		v_VSYNC_POLARITY(screen->pin_vsync) | v_DEN_POLARITY(screen->pin_den) |
+	     		v_DCLK_POLARITY(screen->pin_dclk) | v_OUTPUT_RB_SWAP(screen->swap_rb) | 
+		 	v_OUTPUT_RG_SWAP(screen->swap_rg) |v_BLACK_MODE(0));
+
+		//set background color to black,set swap according to the screen panel,disable blank mode
+		LcdMskReg(lcdc_dev, BG_COLOR, m_BG_COLOR ,v_BG_COLOR(0x000000));
+
+		
+		LcdWrReg(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
+	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
+		LcdWrReg(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
+	             v_HASP(screen->hsync_len + screen->left_margin));
+
+		LcdWrReg(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
+	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
+		LcdWrReg(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
+	              v_VASP(screen->vsync_len + screen->upper_margin));
+
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+	 if(dev_drv->screen0->lcdc_id == 1)
+	 {
+		//set register for scaller
+		LcdMskReg(lcdc_dev,SCL_REG0,m_SCL_DSP_ZERO | m_SCL_DEN_INVERT |
+			m_SCL_SYNC_INVERT | m_SCL_DCLK_INVERT | m_SCL_EN,v_SCL_DSP_ZERO(0) |
+			v_SCL_DEN_INVERT(screen0->s_den_inv) | v_SCL_SYNC_INVERT(screen0->s_hv_sync_inv) |
+			v_SCL_DCLK_INVERT(screen0->s_clk_inv) | v_SCL_EN(1));
+		LcdWrReg(lcdc_dev,SCL_REG2,v_HASP(screen0->s_vsync_st) | v_HAEP(screen0->s_hsync_st));
+		LcdWrReg(lcdc_dev,SCL_REG3,v_HASP(screen0->s_hsync_len) |
+			 v_HAEP(screen0->s_hsync_len + screen0->s_left_margin + 
+			 screen0->x_res + screen0->s_right_margin));
+		LcdWrReg(lcdc_dev,SCL_REG4,v_HASP(screen0->s_hsync_len + screen0->s_left_margin) |
+			 v_HAEP(screen0->s_hsync_len + screen0->s_left_margin + screen0->x_res));
+		LcdWrReg(lcdc_dev,SCL_REG5,v_VASP(screen0->s_vsync_len) |
+			 v_VAEP(screen0->s_vsync_len + screen0->s_upper_margin +
+			 screen0->y_res + screen0->s_lower_margin));
+		LcdWrReg(lcdc_dev,SCL_REG6,v_VASP(screen0->s_vsync_len + 
+			 screen0->s_upper_margin) | v_VAEP(screen0->s_vsync_len +
+			 screen0->s_upper_margin + screen0->y_res ));
+		LcdWrReg(lcdc_dev,SCL_REG8,v_VASP(screen0->s_vsync_len + screen0->s_upper_margin) |
+			 v_VAEP(screen0->s_vsync_len + screen0->s_upper_margin + screen0->y_res));
+		LcdWrReg(lcdc_dev,SCL_REG7,v_HASP(screen0->s_hsync_len + screen0->s_left_margin) |
+			 v_HAEP(screen0->s_hsync_len + screen0->s_left_margin + screen0->x_res ));
+		LcdWrReg(lcdc_dev,SCL_REG1,v_SCL_V_FACTOR(0x1000)|v_SCL_H_FACTOR(0x1000));
+	 }
+#endif
+		// let above to take effect
+		//LCDC_REG_CFG_DONE();
+	}
+ 	spin_unlock(&lcdc_dev->reg_lock);
+
+#ifdef CONFIG_RK2928_LVDS
+	rk_lvds_register(dev_drv->screen0);
+#endif
+	if(dev_drv->screen0->type == SCREEN_RGB) //iomux for RGB screen
+	{
+
+		if(dev_drv->screen0->lcdc_id == 0)
+		{
+			rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_LCDC0_DCLK);
+			rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME, GPIO2B_LCDC0_HSYNC);
+			rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, GPIO2B_LCDC0_VSYNC);
+			rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_LCDC0_DEN);
+			rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_LCDC0_D10);
+			rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_LCDC0_D11);
+			rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_LCDC0_D12);
+			rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_LCDC0_D13);
+			rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_LCDC0_D14);
+			rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_LCDC0_D15);
+			rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_LCDC0_D16);
+			rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_LCDC0_D17);
+		}
+		else if(dev_drv->screen0->lcdc_id == 1)
+		{
+			rk30_mux_api_set(GPIO2B0_LCDC0_DCLK_LCDC1_DCLK_NAME, GPIO2B_LCDC1_DCLK);
+			rk30_mux_api_set(GPIO2B1_LCDC0_HSYNC_LCDC1_HSYNC_NAME, GPIO2B_LCDC1_HSYNC);
+			rk30_mux_api_set(GPIO2B2_LCDC0_VSYNC_LCDC1_VSYNC_NAME, GPIO2B_LCDC1_VSYNC);
+			rk30_mux_api_set(GPIO2B3_LCDC0_DEN_LCDC1_DEN_NAME, GPIO2B_LCDC1_DEN);
+			rk30_mux_api_set(GPIO2B4_LCDC0_D10_LCDC1_D10_NAME, GPIO2B_LCDC1_D10);
+			rk30_mux_api_set(GPIO2B5_LCDC0_D11_LCDC1_D11_NAME, GPIO2B_LCDC1_D11);
+			rk30_mux_api_set(GPIO2B6_LCDC0_D12_LCDC1_D12_NAME, GPIO2B_LCDC1_D12);
+			rk30_mux_api_set(GPIO2B7_LCDC0_D13_LCDC1_D13_NAME, GPIO2B_LCDC1_D13);
+			rk30_mux_api_set(GPIO2C0_LCDC0_D14_LCDC1_D14_NAME, GPIO2C_LCDC1_D14);
+			rk30_mux_api_set(GPIO2C1_LCDC0_D15_LCDC1_D15_NAME, GPIO2C_LCDC1_D15);
+			rk30_mux_api_set(GPIO2C2_LCDC0_D16_LCDC1_D16_NAME, GPIO2C_LCDC1_D16);
+			rk30_mux_api_set(GPIO2C3_LCDC0_D17_LCDC1_D17_NAME, GPIO2C_LCDC1_D17);
+		}
+		else
+		{
+			printk(KERN_WARNING "%s>>>no such interface:%d\n",__func__,dev_drv->cur_screen->lcdc_id);
+			return -1;
+		}
+		
+		//rk30_mux_api_set(GPIO2C4_LCDC0_D18_LCDC1_D18_I2C2_SDA_NAME, GPIO2C_LCDC1_D18);
+		//rk30_mux_api_set(GPIO2C5_LCDC0_D19_LCDC1_D19_I2C2_SCL_NAME, GPIO2C_LCDC1_D19);
+		//rk30_mux_api_set(GPIO2C6_LCDC0_D20_LCDC1_D20_UART2_SIN_NAME, GPIO2C_LCDC1_D20);
+		//rk30_mux_api_set(GPIO2C7_LCDC0_D21_LCDC1_D21_UART2_SOUT_NAME, GPIO2C_LCDC1_D21);
+		//rk30_mux_api_set(GPIO2D0_LCDC0_D22_LCDC1_D22_NAME, GPIO2D_LCDC1_D22);
+		//rk30_mux_api_set(GPIO2D1_LCDC0_D23_LCDC1_D23_NAME, GPIO2D_LCDC1_D23);
+		printk("RGB screen connect to rk2928 lcdc interface%d\n",dev_drv->screen0->lcdc_id);
+
+	}
+
+	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
+	if(ret)
+	{
+        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+	}
+	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	clk_enable(lcdc_dev->dclk);
+#if  defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+
+	if(dev_drv->screen0->lcdc_id == 1)  //if connect to output interface 1,need scale
+	{
+		ret = clk_set_rate(lcdc_dev->sclk, screen0->s_pixclock);
+		if(ret)
+		{
+	        	printk(KERN_ERR ">>>>>> set lcdc%d sclk failed\n",lcdc_dev->id);
+		}
+		//lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->sclk));
+		//printk("%s: sclk:%lu>>need:%d",lcdc_dev->driver.name,,screen0->s_pixclock);
+		clk_enable(lcdc_dev->sclk);
+	}
+#endif
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+		(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps;
+    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk), 
+		fps);
+
+    	if(screen->init)
+    	{
+    		screen->init();
+    	}
+	
+	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
+	return 0;
+}
+
+
+//enable layer,open:1,enable;0 disable
+static int win0_open(struct rk2928_lcdc_device *lcdc_dev,bool open)
+{
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				LcdClrBit(lcdc_dev, SYS_CFG,m_LCDC_STANDBY);
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[0]->state = open;
+		
+		LcdMskReg(lcdc_dev, SYS_CFG, m_W0_EN, v_W0_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			LcdSetBit(lcdc_dev, SYS_CFG,m_LCDC_STANDBY);
+		}
+		//LCDC_REG_CFG_DONE();	
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win0 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+static int win1_open(struct rk2928_lcdc_device *lcdc_dev,bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				printk("lcdc%d wakeup from stanby\n",lcdc_dev->id);
+				LcdClrBit(lcdc_dev, SYS_CFG,m_LCDC_STANDBY);
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[1]->state = open;
+		
+		LcdMskReg(lcdc_dev, SYS_CFG, m_W1_EN, v_W1_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
+			LcdSetBit(lcdc_dev, SYS_CFG,m_LCDC_STANDBY);
+		}
+		//LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win1 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+
+
+static int rk2928_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
+{
+	struct rk2928_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk2928_lcdc_device ,driver);
+
+	printk(KERN_INFO "%s>>>>>%d\n",__func__, blank_mode);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch(blank_mode)
+	    	{
+	    		case FB_BLANK_UNBLANK:
+	      			LcdMskReg(lcdc_dev,DSP_CTRL,m_BLANK_MODE ,v_BLANK_MODE(0));
+				break;
+	    		case FB_BLANK_NORMAL:
+	         		LcdMskReg(lcdc_dev,DSP_CTRL,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+	    		default:
+				LcdMskReg(lcdc_dev,DSP_CTRL,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+		}
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+    	return 0;
+}
+
+static  int win0_display(struct rk2928_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN0_YRGB_MST,y_addr);
+	    	LcdWrReg(lcdc_dev, WIN0_CBR_MST,uv_addr);
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+	
+}
+
+static  int win1_display(struct rk2928_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN1_RGB_MST, y_addr);
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static  int win0_set_par(struct rk2928_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	u8 fmt_cfg = 0;
+	
+	xact = par->xact;			    //active (origin) picture window width/height		
+	yact = par->yact;
+	xvir = par->xvir;			   // virtual resolution		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+
+	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
+	ScaleYrgbY = CalScale(yact, par->ysize);
+
+	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+	switch (par->format)
+	{
+		case XBGR888:
+		case ABGR888:
+		case ARGB888:
+			fmt_cfg = 0;
+			break;
+		case RGB888:
+			fmt_cfg = 1;
+			break;
+		case RGB565:
+			fmt_cfg = 2;
+			break;
+		case YUV422:// yuv422
+			fmt_cfg = 5;
+			ScaleCbrX = CalScale((xact/2), par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		case YUV420: // yuv420
+			fmt_cfg = 4;
+			ScaleCbrX = CalScale(xact/2, par->xsize);
+		   	ScaleCbrY = CalScale(yact/2, par->ysize);
+		   	break;
+		case YUV444:// yuv444
+			fmt_cfg = 6;
+			ScaleCbrX = CalScale(xact, par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		default:
+			printk("%s:un supported format\n",__func__);
+		   	break;
+	}
+
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
+		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
+		LcdMskReg(lcdc_dev, SYS_CFG, m_W0_FORMAT, v_W0_FORMAT(fmt_cfg));		//(inf->video_mode==0)
+		LcdWrReg(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
+		LcdWrReg(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
+		LcdMskReg(lcdc_dev,WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
+			v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+		switch(par->format) 
+		{
+			case XBGR888:
+				LcdMskReg(lcdc_dev, WIN_VIR,m_WIN0_VIR,v_WIN0_ARGB888_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+			case ARGB888:
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_ARGB888_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
+				break;
+			case ABGR888:
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_ARGB888_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+			case RGB888:  //rgb888
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_RGB888_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
+				break;
+			case RGB565:  //rgb565
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_RGB565_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,DSP_CTRL,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
+				break;
+			case YUV422:
+			case YUV420:   
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN0_VIR,v_WIN0_YUV_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
+				break;
+			default:
+				printk("%s:un supported format\n",__func__);
+				break;
+		}
+		
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+    return 0;
+
+}
+
+static int win1_set_par(struct rk2928_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	u8 fmt_cfg = 0;
+	
+	xact = par->xact;			
+	yact = par->yact;
+	xvir = par->xvir;		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	
+	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
+		// enable win1 color key and set the color to black(rgb=0)
+		LcdMskReg(lcdc_dev, WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+
+		
+		switch(par->format)
+	       {	
+			case XBGR888:
+                		fmt_cfg = 0;
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_ARGB888_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+			case ABGR888:
+                		fmt_cfg = 0;
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_ARGB888_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+			case ARGB888:
+                		fmt_cfg = 0;
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_ARGB888_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
+				break;
+			case RGB888:  //rgb888
+                		fmt_cfg = 1;
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_RGB888_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,DSP_CTRL,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
+				break;
+			case RGB565:  //rgb565
+                		fmt_cfg = 2;
+				LcdMskReg(lcdc_dev,WIN_VIR,m_WIN1_VIR,v_WIN1_RGB565_VIRWIDTH(xvir));
+				LcdMskReg(lcdc_dev,SYS_CFG,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
+				break;
+			default:
+				printk("%s:un supported format\n",__func__);
+				break;
+	       }
+		
+	    	LcdMskReg(lcdc_dev,SYS_CFG, m_W1_FORMAT, v_W1_FORMAT(fmt_cfg));
+		//LCDC_REG_CFG_DONE(); 
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+    return 0;
+}
+
+static int rk2928_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+
+	if(open)
+	{
+		rk2928_load_screen(dev_drv,1);
+	}
+	if(layer_id == 0)
+	{
+		win0_open(lcdc_dev,open);	
+	}
+	else if(layer_id == 1)
+	{
+		win1_open(lcdc_dev,open);
+	}
+
+	return 0;
+}
+
+static int rk2928_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	rk_screen *screen0 = dev_drv->screen0;
+	u32 Scl_X = 0x1000;
+	u32 Scl_Y = 0x1000;
+	
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_set_par(lcdc_dev,screen,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_set_par(lcdc_dev,screen,par);
+	}
+	Scl_X = CalScale(screen->x_res - 1,screen0->x_res - 1);
+	if((screen->y_res-1)/(screen0->x_res -1) < 2)
+	{
+
+		Scl_Y = CalScale(screen->y_res - 1 ,screen0->y_res - 1);
+	}
+	else
+	{	
+		Scl_Y = CalScale(screen->y_res - 2 ,screen0->y_res - 1);
+	}
+	LcdWrReg(lcdc_dev,SCL_REG1,v_SCL_V_FACTOR(Scl_Y)|v_SCL_H_FACTOR(Scl_X));
+	
+	return 0;
+}
+
+int rk2928_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	unsigned long flags;
+	int timeout;
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;	
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_display(lcdc_dev,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_display(lcdc_dev,par);
+	}
+	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
+	{
+		dev_drv->first_frame = 0;
+		LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR |m_FRM_START_INT_EN ,
+			  v_FRM_START_INT_CLEAR(1) | v_FRM_START_INT_EN(1));
+		LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
+		 
+	}
+
+	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
+	{
+		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
+		if(!timeout&&(!dev_drv->frame_done.done))
+		{
+			//printk(KERN_ERR "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	
+	return 0;
+}
+
+int rk2928_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	int ret = 0;
+	switch(cmd)
+	{
+		case RK_FBIOGET_PANEL_SIZE:    //get panel size
+                	panel_size[0] = dev_drv->screen0->x_res;
+                	panel_size[1] = dev_drv->screen0->y_res;
+            		if(copy_to_user(argp, panel_size, 8)) 
+				return -EFAULT;
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+static int rk2928_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+	struct layer_par *par = dev_drv->layer_par[layer_id];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(layer_id == 0)
+		{
+			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W0_EN);
+		}
+		else if( layer_id == 1)
+		{
+			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W1_EN);
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return par->state;
+	
+}
+
+/***********************************
+overlay manager
+swap:1 win0 on the top of win1
+        0 win1 on the top of win0
+set  : 1 set overlay 
+        0 get overlay state
+************************************/
+static int rk2928_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+	int ovl;
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(set)  //set overlay
+		{
+			LcdMskReg(lcdc_dev,DSP_CTRL,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
+			LCDC_REG_CFG_DONE();
+			ovl = swap;
+		}
+		else  //get overlay
+		{
+			ovl = LcdReadBit(lcdc_dev,DSP_CTRL,m_W0W1_POSITION_SWAP);
+		}
+	}
+	else
+	{
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+static ssize_t dump_win0_disp_info(struct rk2928_lcdc_device *lcdc_dev,char *buf)
+{
+        char format[9] = "NULL";
+        u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CFG);
+        u32 xvir,act_info,dsp_info,dsp_st,factor;
+        u16 x_act,y_act,x_dsp,y_dsp,x_factor,y_factor;
+        u16 x_scale,y_scale;
+        switch((fmt_id&m_W0_FORMAT)>>3)
+        {
+                case 0:
+                        strcpy(format,"ARGB888");
+                        break;
+                case 1:
+                        strcpy(format,"RGB888");
+                        break;
+                case 2:
+                        strcpy(format,"RGB565");
+                        break;
+                case 4:
+                        strcpy(format,"YCbCr422");
+                        break;
+                case 5:
+                        strcpy(format,"YCbCr420");
+                        break;
+                case 6:
+                        strcpy(format,"YCbCr444");
+                        break;
+                default:
+                        strcpy(format,"inval\n");
+                        break;
+        }
+
+        xvir = LcdRdReg(lcdc_dev,WIN_VIR)&0xffff;
+        act_info = LcdRdReg(lcdc_dev,WIN0_ACT_INFO);
+        dsp_info = LcdRdReg(lcdc_dev,WIN0_DSP_INFO);
+        dsp_st = LcdRdReg(lcdc_dev,WIN0_DSP_ST);
+        factor = LcdRdReg(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
+        x_act =  (act_info&0xffff) + 1;
+        y_act = (act_info>>16) + 1;
+        x_dsp = (dsp_info&0xffff) + 1;
+        y_dsp = (dsp_info>>16) + 1;
+	x_factor = factor&0xffff;
+        y_factor = factor>>16;
+        x_scale = 4096*100/x_factor;
+        y_scale = 4096*100/y_factor;
+        return snprintf(buf,PAGE_SIZE,"xvir:%d\nxact:%d\nyact:%d\nxdsp:%d\nydsp:%d\nx_st:%d\ny_st:%d\nx_scale:%d.%d\ny_scale:%d.%d\nformat:%s\n",
+                xvir,x_act,y_act,x_dsp,y_dsp,dsp_st&0xffff,dsp_st>>16,x_scale/100,x_scale%100,y_scale/100,y_scale%100,format);
+
+}
+
+static ssize_t dump_win1_disp_info(struct rk2928_lcdc_device *lcdc_dev,char *buf)
+{
+        char format[9] = "NULL";
+        u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CFG);
+        u32 xvir,act_info,dsp_info,dsp_st,factor;
+        u16 x_act,y_act,x_dsp,y_dsp,x_factor,y_factor;
+        u16 x_scale,y_scale;
+        switch((fmt_id&m_W1_FORMAT)>>6)
+        {
+                case 0:
+                        strcpy(format,"ARGB888");
+                        break;
+                case 1:
+                        strcpy(format,"RGB888");
+                        break;
+                case 2:
+                        strcpy(format,"RGB565");
+                        break;
+                default:
+                        strcpy(format,"inval\n");
+                        break;
+        }
+
+        xvir = (LcdRdReg(lcdc_dev,WIN_VIR)>>16)&0xfff;
+        dsp_info = LcdRdReg(lcdc_dev,WIN1_DSP_INFO);
+        dsp_st = LcdRdReg(lcdc_dev,WIN1_DSP_ST);
+
+        x_dsp = dsp_info&0xffff;
+        y_dsp = dsp_info>>16;
+
+        return snprintf(buf,PAGE_SIZE,"xvir:%d\nxdsp:%d\nydsp:%d\nx_st:%d\ny_st:%d\nformat:%s\n",
+                xvir,x_dsp,y_dsp,dsp_st&0xffff,dsp_st>>16,format);
+}
+
+static ssize_t  rk2928_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id)
+{
+        struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+        if(layer_id == 0)
+        {
+                return dump_win0_disp_info(lcdc_dev,buf);
+        }
+        else if(layer_id == 1)
+        {
+                return dump_win1_disp_info(lcdc_dev,buf);
+        }
+       
+        return 0;
+}
+
+
+
+/*******************************************
+lcdc fps manager,set or get lcdc fps
+set:0 get
+     1 set
+********************************************/
+static int rk2928_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+	rk_screen * screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+
+	if(set)
+	{
+		ft = div_u64(1000000000000llu,fps);
+		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
+		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+		if(ret)
+		{
+	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+		}
+	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+			
+	}
+	
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+	(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps ;  //one frame time in ms
+	return fps;
+}
+
+
+static int rk2928_fb_layer_remap(struct rk_lcdc_device_driver *dev_drv,
+        enum fb_win_map_order order)
+{
+        mutex_lock(&dev_drv->fb_win_id_mutex);
+	if(order == FB_DEFAULT_ORDER)
+	{
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
+	}
+        dev_drv->fb2_win_id  = order/100;
+        dev_drv->fb1_win_id = (order/10)%10;
+        dev_drv->fb0_win_id = order%10;
+        mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+        printk("fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
+                dev_drv->fb2_win_id);
+
+        return 0;
+}
+
+static int rk2928_fb_get_layer(struct rk_lcdc_device_driver *dev_drv,const char *id)
+{
+        int layer_id = 0;
+        mutex_lock(&dev_drv->fb_win_id_mutex);
+        if(!strcmp(id,"fb0"))
+        {
+                layer_id = dev_drv->fb0_win_id;
+        }
+        else if(!strcmp(id,"fb1"))
+        {
+                layer_id = dev_drv->fb1_win_id;
+        }
+        else if(!strcmp(id,"fb2"))
+        {
+                layer_id = dev_drv->fb2_win_id;
+        }
+        else
+        {
+                printk(KERN_ERR "%s>>un supported %s\n",__func__,id);
+                layer_id = -1;
+        }
+        mutex_unlock(&dev_drv->fb_win_id_mutex);
+	//printk("%s %s win%d\n",__func__,id,layer_id);
+        return  layer_id;
+}
+
+static int rk2928_lcdc_hdmi_process(struct rk_lcdc_device_driver *dev_drv,int mode)
+{
+#if !defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+	printk("%s>>>>>>>>mode:%d\n",__func__,mode);
+	if(mode)
+	{
+		rk2928_lcdc_iomux(dev_drv->screen0,0); //switch to gpio mode,to avoid  current leakage
+		if(dev_drv->screen_ctr_info->io_disable)
+			dev_drv->screen_ctr_info->io_disable();
+	}
+	else
+	{
+		rk2928_lcdc_iomux(dev_drv->screen0,1); //switch to gpio mode,to avoid  current leakage
+		if(dev_drv->screen_ctr_info->io_enable)
+			dev_drv->screen_ctr_info->io_enable();
+	}
+#endif
+	
+	return 0;
+	
+}
+int rk2928_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
+{
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+
+	if(dev_drv->screen0->standby)
+		dev_drv->screen0->standby(1);
+	if(dev_drv->screen_ctr_info->io_disable)
+		dev_drv->screen_ctr_info->io_disable();
+	
+	if(dev_drv->cur_screen->sscreen_set)
+		dev_drv->cur_screen->sscreen_set(dev_drv->cur_screen , 0);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+		LcdSetBit(lcdc_dev,DSP_CTRL,m_BLACK_MODE);
+		LcdMskReg(lcdc_dev, SYS_CFG,m_DSP_OUT_ZERO | m_LCDC_STANDBY,
+			v_DSP_OUT_ZERO(1) | v_LCDC_STANDBY(1));
+		LCDC_REG_CFG_DONE();
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else  //clk already disabled
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	
+		
+	mdelay(10);
+ 	rk2928_lcdc_iomux(dev_drv->screen0,0); //switch to gpio mode,to avoid  current leakage
+	clk_disable(lcdc_dev->dclk);
+	clk_disable(lcdc_dev->hclk);
+	clk_disable(lcdc_dev->aclk);
+	clk_disable(lcdc_dev->pd);
+
+	return 0;
+}
+
+
+
+int rk2928_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
+{  
+	struct rk2928_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk2928_lcdc_device,driver);
+
+	if(dev_drv->screen_ctr_info->io_enable) 		//power on
+		dev_drv->screen_ctr_info->io_enable();
+	
+	if(!lcdc_dev->clk_on)
+	{
+		clk_enable(lcdc_dev->pd);
+		clk_enable(lcdc_dev->hclk);
+		clk_enable(lcdc_dev->dclk);
+		clk_enable(lcdc_dev->aclk);
+	}
+	rk2928_lcdc_iomux(dev_drv->screen0,1); //switch to lcdc io
+	memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0xc4);  //resume reg
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->atv_layer_cnt)
+	{
+		LcdMskReg(lcdc_dev, SYS_CFG,m_DSP_OUT_ZERO | m_LCDC_STANDBY,
+			v_DSP_OUT_ZERO(0) | v_LCDC_STANDBY(0));
+		LcdClrBit(lcdc_dev,DSP_CTRL,m_BLACK_MODE);
+		LCDC_REG_CFG_DONE();
+	}
+	lcdc_dev->clk_on = 1;
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	
+	if(dev_drv->cur_screen->sscreen_set)
+		dev_drv->cur_screen->sscreen_set(dev_drv->cur_screen , 1);
+
+	if(dev_drv->screen0->standby)
+		dev_drv->screen0->standby(0);	      //screen wake up
+	
+
+    	return 0;
+}
+static irqreturn_t rk2928_lcdc_isr(int irq, void *dev_id)
+{
+	struct rk2928_lcdc_device *lcdc_dev = (struct rk2928_lcdc_device *)dev_id;
+
+	ktime_t timestamp = ktime_get();
+	
+	LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+	//LCDC_REG_CFG_DONE();
+	//LcdMskReg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
+ 
+	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
+	{
+		spin_lock(&(lcdc_dev->driver.cpl_lock));
+		complete(&(lcdc_dev->driver.frame_done));
+		spin_unlock(&(lcdc_dev->driver.cpl_lock));
+	}
+	
+	lcdc_dev->driver.vsync_info.timestamp = timestamp;
+	wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
+	return IRQ_HANDLED;
+}
+
+static struct layer_par lcdc_layer[] = {
+	[0] = {
+		.name  		= "win0",
+		.id		= 0,
+		.support_3d	= true,
+	},
+	[1] = {
+		.name  		= "win1",
+		.id		= 1,
+		.support_3d	= false,
+	},
+};
+
+static struct rk_lcdc_device_driver lcdc_driver = {
+	.name			= "lcdc",
+	.def_layer_par		= lcdc_layer,
+	.num_layer		= ARRAY_SIZE(lcdc_layer),
+	.open			= rk2928_lcdc_open,
+	.init_lcdc		= init_rk2928_lcdc,
+	.ioctl			= rk2928_lcdc_ioctl,
+	.suspend		= rk2928_lcdc_early_suspend,
+	.resume			= rk2928_lcdc_early_resume,
+	.set_par       		= rk2928_lcdc_set_par,
+	.blank         		= rk2928_lcdc_blank,
+	.pan_display            = rk2928_lcdc_pan_display,
+	.load_screen		= rk2928_load_screen,
+	.get_layer_state	= rk2928_lcdc_get_layer_state,
+	.ovl_mgr		= rk2928_lcdc_ovl_mgr,
+	.get_disp_info		= rk2928_lcdc_get_disp_info,
+	.fps_mgr		= rk2928_lcdc_fps_mgr,
+	.fb_get_layer           = rk2928_fb_get_layer,
+	.fb_layer_remap         = rk2928_fb_layer_remap,
+	.lcdc_hdmi_process	= rk2928_lcdc_hdmi_process,
+};
+#ifdef CONFIG_PM
+static int rk2928_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk2928_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#else
+#define rk2928_lcdc_suspend NULL
+#define rk2928_lcdc_resume NULL
+#endif
+
+static int __devinit rk2928_lcdc_probe (struct platform_device *pdev)
+{
+	struct rk2928_lcdc_device *lcdc_dev=NULL;
+	rk_screen *screen0;
+	rk_screen *screen1;
+	struct rk29fb_info *screen_ctr_info;
+	struct resource *res = NULL;
+	struct resource *mem;
+	int ret = 0;
+	
+	/*************Malloc rk2928lcdc_inf and set it to pdev for drvdata**********/
+	lcdc_dev = kzalloc(sizeof(struct rk2928_lcdc_device), GFP_KERNEL);
+    	if(!lcdc_dev)
+    	{
+        	dev_err(&pdev->dev, ">>rk2928 lcdc device kmalloc fail!");
+        	return -ENOMEM;
+    	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->id = pdev->id;
+	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
+	screen0 =  kzalloc(sizeof(rk_screen), GFP_KERNEL); //rk2928 has one lcdc but two outputs
+	if(!screen0)
+	{
+		dev_err(&pdev->dev, ">>rk2928 lcdc screen1 kmalloc fail!");
+        	ret =  -ENOMEM;
+		goto err0;
+	}
+	screen0->lcdc_id = 0;  //this id can be changed dynamic
+	screen0->screen_id = 0; //this id is fixed
+	screen1 =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
+	if(!screen1)
+	{
+		dev_err(&pdev->dev, ">>rk2928 lcdc screen1 kmalloc fail!");
+        	ret =  -ENOMEM;
+		goto err0;
+	}
+	screen1->lcdc_id = 1;
+	screen1->screen_id = 1;
+	
+	/****************get lcdc0 reg  *************************/
+	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
+	if (res == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+    	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
+    	if (mem == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
+	if (lcdc_dev->reg_vir_base == NULL)
+	{
+		dev_err(&pdev->dev, "cannot map IO\n");
+		ret = -ENXIO;
+		goto err2;
+	}
+	
+    	lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
+	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->preg);
+	lcdc_dev->driver.dev=&pdev->dev;
+	lcdc_dev->driver.screen0 = screen0;  //direct out put
+	lcdc_dev->driver.screen1 = screen1; //out put from scale
+	lcdc_dev->driver.cur_screen = screen0;
+	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
+	spin_lock_init(&lcdc_dev->reg_lock);
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if(lcdc_dev->irq < 0)
+	{
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		goto err3;
+	}
+	ret = request_irq(lcdc_dev->irq, rk2928_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
+	if (ret)
+	{
+	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
+	       ret = -EBUSY;
+	       goto err3;
+	}
+
+	if(screen_ctr_info->set_screen_info)
+	{
+		screen_ctr_info->set_screen_info(screen0,screen_ctr_info->lcd_info);
+		if(SCREEN_NULL==screen0->type)
+		{
+			printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
+			ret = -ENODEV;
+		}
+		if(screen_ctr_info->io_init)
+			screen_ctr_info->io_init(NULL);
+	}
+	else
+	{
+		printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
+		ret =  -ENODEV;
+		goto err4;
+	}
+	
+	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
+	if(ret < 0)
+	{
+		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
+		goto err4;
+	}
+	printk("rk2928 lcdc%d probe ok!\n",lcdc_dev->id);
+
+	return 0;
+
+err4:
+	free_irq(lcdc_dev->irq,lcdc_dev);
+err3:	
+	iounmap(lcdc_dev->reg_vir_base);
+err2:
+	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
+err1:
+	kfree(screen0);
+err0:
+	platform_set_drvdata(pdev, NULL);
+	kfree(lcdc_dev);
+	return ret;
+    
+}
+static int __devexit rk2928_lcdc_remove(struct platform_device *pdev)
+{
+	struct rk2928_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	rk_fb_unregister(&(lcdc_dev->driver));
+	rk2928_lcdc_deinit(lcdc_dev);
+	iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);
+	return 0;
+}
+
+static void rk2928_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct rk2928_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	if(lcdc_dev->driver.cur_screen->standby) //standby the screen if necessary
+		lcdc_dev->driver.cur_screen->standby(1);
+	if(lcdc_dev->driver.screen_ctr_info->io_disable) //power off the screen if necessary
+		lcdc_dev->driver.screen_ctr_info->io_disable();
+	if(lcdc_dev->driver.cur_screen->sscreen_set) //turn off  lvds
+		lcdc_dev->driver.cur_screen->sscreen_set(lcdc_dev->driver.cur_screen , 0);
+	//rk_fb_unregister(&(lcdc_dev->driver));
+	rk2928_lcdc_deinit(lcdc_dev);
+	/*iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);*/
+}
+
+
+static struct platform_driver rk2928lcdc_driver = {
+	.probe		= rk2928_lcdc_probe,
+	.remove		= __devexit_p(rk2928_lcdc_remove),
+	.driver		= {
+		.name	= "rk2928-lcdc",
+		.owner	= THIS_MODULE,
+	},
+	.suspend	= rk2928_lcdc_suspend,
+	.resume		= rk2928_lcdc_resume,
+	.shutdown   = rk2928_lcdc_shutdown,
+};
+
+static int __init rk2928_lcdc_init(void)
+{
+    return platform_driver_register(&rk2928lcdc_driver);
+}
+
+static void __exit rk2928_lcdc_exit(void)
+{
+	platform_driver_unregister(&rk2928lcdc_driver);
+}
+
+
+
+fs_initcall(rk2928_lcdc_init);
+module_exit(rk2928_lcdc_exit);
+
+
+
diff -Nupr a/drivers/video/rockchip/lcdc/rk2928_lcdc.h b/drivers/video/rockchip/lcdc/rk2928_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk2928_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk2928_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,527 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef RK2928_LCDC_H_
+#define RK2928_LCDC_H_
+
+#include<linux/rk_fb.h>
+
+#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
+#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
+#define LcdRdReg(inf, addr)             (inf->preg->addr)
+#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
+#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
+#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
+#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
+#define LCDC_REG_CFG_DONE()             LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
+
+/********************************************************************
+**                                                          *
+********************************************************************/
+/* LCDC */
+
+typedef volatile struct tagLCDC_REG
+{
+    /* offset 0x00~0xc0 */
+	unsigned int SYS_CFG;               		//0x00 system config register
+	unsigned int DSP_CTRL;				//0x0c display control register 
+	unsigned int BG_COLOR;				//back ground color register
+	unsigned int ALPHA_CTRL;				//alpha control register
+	unsigned int INT_STATUS;             		//0x10 Interrupt status register
+	unsigned int WIN0_COLOR_KEY_CTRL;     //0x1c Win0 blending control register
+	unsigned int WIN1_COLOR_KEY_CTRL;     //0x20 Win1 blending control register
+	unsigned int WIN0_YRGB_MST;           //0x28 Win0 active YRGB memory start address0
+	unsigned int WIN0_CBR_MST;            //0x2c Win0 active Cbr memory start address0
+	unsigned int WIN_VIR;                //0x38 WIN0 virtual display width/height
+	unsigned int WIN0_ACT_INFO;           //0x3C Win0 active window width/height
+	unsigned int WIN0_DSP_INFO;           //0x40 Win0 display width/height on panel
+	unsigned int WIN0_DSP_ST;             //0x44 Win0 display start point on panel
+	unsigned int WIN0_SCL_FACTOR_YRGB;    //0x48Win0 YRGB scaling  factor setting
+	unsigned int WIN0_SCL_FACTOR_CBR;     //0x4c Win0 YRGB scaling factor setting
+	unsigned int WIN0_SCL_OFFSET;         //0x50 Win0 Cbr scaling start point offset
+	unsigned int WIN1_RGB_MST;           //0x54 Win1 active YRGB memory start address
+	unsigned int WIN1_DSP_INFO;           //0x64 Win1 display width/height on panel
+	unsigned int WIN1_DSP_ST;             //0x68 Win1 display start point on panel
+	unsigned int HWC_MST;                 //0x88 HWC memory start address
+	unsigned int HWC_DSP_ST;              //0x8C HWC display start point on panel
+	unsigned int HWC_COLOR_LUT0;          //0x90 Hardware cursor color 2b01 look up table 0
+	unsigned int HWC_COLOR_LUT1;          //0x94 Hardware cursor color 2b10 look up table 1
+	unsigned int HWC_COLOR_LUT2;          //0x98 Hardware cursor color 2b11 look up table 2
+	unsigned int DSP_HTOTAL_HS_END;       //0x9c Panel scanning horizontal width and hsync pulse end point
+	unsigned int DSP_HACT_ST_END;         //0xa0 Panel active horizontal scanning start/end point
+	unsigned int DSP_VTOTAL_VS_END;       //0xa4 Panel scanning vertical height and vsync pulse end point
+	unsigned int DSP_VACT_ST_END;         //0xa8 Panel active vertical scanning start/end point
+	unsigned int SCL_REG0;		      //scaler register
+	unsigned int SCL_REG1;
+	unsigned int SCL_REG2;
+	unsigned int SCL_REG3;
+	unsigned int SCL_REG4;
+	unsigned int SCL_REG5;
+	unsigned int SCL_REG6;
+	unsigned int SCL_REG7;
+	unsigned int SCL_REG8;
+	unsigned int reserve[3];
+	unsigned int REG_CFG_DONE;            //0xc0 REGISTER CONFIG FINISH
+  
+} LCDC_REG, *pLCDC_REG;
+
+
+/* SYS_CONFIG */
+
+#define  m_W0_EN              (1<<0)
+#define  m_W1_EN              (1<<1)
+#define  m_HWC_EN             (1<<2)
+#define  m_W0_FORMAT          (7<<3)
+#define  m_W1_FORMAT          (7<<6)
+#define  m_W0_RGB_RB_SWAP     (1<<10)
+#define  m_W1_RGB_RB_SWAP     (1<<14)
+
+#define m_W0_AXI_OUTSTANDING_DISABLE (1<<16) 
+#define m_W1_AXI_OUTSTANDING_DISABLE (1<<17)
+#define m_DMA_BURST_LENGTH	     (3<<18)
+#define m_LCDC_STANDBY		     (1<<22)
+
+#define m_LCDC_AXICLK_AUTO_ENABLE    (1<<24) //eanble for low power
+#define m_DSP_OUT_ZERO		     (1<<25)
+
+#define v_W0_EN(x)          		(((x)&1)<<0)
+#define v_W1_EN(x)          		(((x)&1)<<1)
+#define v_HWC_EN(x)         		(((x)&1)<<2)
+#define v_W0_FORMAT(x)      		(((x)&7)<<3)
+#define v_W1_FORMAT(x)      		(((x)&7)<<6)
+#define v_W0_RGB_RB_SWAP(x)		(((x)&1)<<10)	
+#define v_W1_RGB_RB_SWAP(x)		(((x)&1)<<14)
+
+#define v_LCDC_STANDBY(x)		(((x)&1)<<22)
+#define v_LCDC_AXICLK_AUTO_ENABLE(x)    (((x)&1)<<24)
+#define v_DSP_OUT_ZERO(x)    		(((x)&1)<<25)
+
+
+#define v_LCDC_DMA_STOP(x)              (((x)&1)<<0)
+#define v_HWC_RELOAD_EN(x)             (((x)&1)<<2)
+#define v_W0_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<3)
+#define v_W1_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<4)
+#define v_W2_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<5)
+#define v_DMA_BURST_LENGTH(x)		(((x)&3)<<6)
+#define v_WIN0_YRGB_CHANNEL0_ID(x)	(((x)&7)<<8)
+#define v_WIN0_CBR_CHANNEL0_ID(x)	(((x)&7)<<11)
+#define v_WIN0_YRGB_CHANNEL1_ID(x)      (((x)&7)<<14)
+#define v_WIN0_CBR_CHANNEL1_ID(x)	(((x)&7)<<17)
+#define v_WIN1_YRGB_CHANNEL_ID(x)	(((x)&7)<<20)
+#define v_WIN1_CBR_CHANNEL_ID(x)	(((x)&7)<<23)
+#define v_WIN2_CHANNEL_ID(x)	        (((x)&7)<<26)
+#define v_HWC_CHANNEL_ID(x)	        (((x)&7)<<29)
+
+
+
+//LCDC_DSP_CTRL_REG
+#define m_DISPLAY_FORMAT             (3<<0)
+#define m_BLANK_MODE                 (1<<2)
+#define m_BLACK_MODE                 (1<<3)
+#define m_HSYNC_POLARITY             (1<<4)
+#define m_VSYNC_POLARITY             (1<<5)
+#define m_DEN_POLARITY               (1<<6)
+#define m_DCLK_POLARITY              (1<<7)
+#define m_W0W1_POSITION_SWAP         (1<<8)
+#define m_OUTPUT_BG_SWAP             (1<<9)
+#define m_OUTPUT_RB_SWAP             (1<<10)
+#define m_OUTPUT_RG_SWAP             (1<<11)
+#define m_DITHER_UP_EN               (1<<12)
+#define m_DITHER_DOWN_MODE           (1<<13)
+#define m_DITHER_DOWN_EN             (1<<14)
+
+
+#define m_W1_INTERLACE_READ_MODE     (1<<15)
+#define m_W2_INTERLACE_READ_MODE     (1<<16)
+#define m_W0_YRGB_DEFLICK_MODE       (1<<17)
+#define m_W0_CBR_DEFLICK_MODE        (1<<18)
+#define m_W1_YRGB_DEFLICK_MODE       (1<<19)
+#define m_W1_CBR_DEFLICK_MODE        (1<<20)
+#define m_W0_ALPHA_MODE              (1<<21)
+#define m_W1_ALPHA_MODE              (1<<22)
+#define m_W2_ALPHA_MODE              (1<<23)
+#define m_W0_COLOR_SPACE_CONVERSION  (3<<24)
+#define m_W1_COLOR_SPACE_CONVERSION  (3<<26)
+#define m_W2_COLOR_SPACE_CONVERSION  (1<<28)
+#define m_YCRCB_CLIP_EN              (1<<29)
+#define m_CBR_FILTER_656             (1<<30)
+
+#define v_DISPLAY_FORMAT(x)           (((x)&0x3)<<0)
+#define v_BLANK_MODE(x)               (((x)&1)<<2)
+#define v_BLACK_MODE(x)               (((x)&1)<<3)
+#define v_HSYNC_POLARITY(x)           (((x)&1)<<4)
+#define v_VSYNC_POLARITY(x)           (((x)&1)<<5)
+#define v_DEN_POLARITY(x)             (((x)&1)<<6)
+#define v_DCLK_POLARITY(x)            (((x)&1)<<7)
+#define v_W0W1_POSITION_SWAP(x)	      (((x)&1)<<8)
+#define v_OUTPUT_BG_SWAP(x)           (((x)&1)<<9)
+#define v_OUTPUT_RB_SWAP(x)           (((x)&1)<<10)
+#define v_OUTPUT_RG_SWAP(x)           (((x)&1)<<11)
+#define v_DITHER_UP_EN(x)               (((x)&1)<<12)
+#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<13)
+#define v_DITHER_DOWN_EN(x)             (((x)&1)<<14)
+
+#define v_INTERLACE_DSP_EN(x)             (((x)&1)<<12)
+#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
+#define v_W0_INTERLACE_READ_MODE(x)     (((x)&1)<<14)
+#define v_W1_INTERLACE_READ_MODE(x)     (((x)&1)<<15)
+#define v_W2_INTERLACE_READ_MODE(x)     (((x)&1)<<16)
+#define v_W0_YRGB_DEFLICK_MODE(x)       (((x)&1)<<17)
+#define v_W0_CBR_DEFLICK_MODE(x)        (((x)&1)<<18)
+#define v_W1_YRGB_DEFLICK_MODE(x)       (((x)&1)<<19)
+#define v_W1_CBR_DEFLICK_MODE(x)        (((x)&1)<<20)
+#define v_W0_ALPHA_MODE(x)             (((x)&1)<<21)
+#define v_W1_ALPHA_MODE(x)              (((x)&1)<<22)
+#define v_W2_ALPHA_MODE(x)             (((x)&1)<<23)
+#define v_W0_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<24)
+#define v_W1_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<26)
+#define v_W2_COLOR_SPACE_CONVERSION(x)  (((x)&1)<<28)
+#define v_YCRCB_CLIP_EN(x)            (((x)&1)<<29)
+#define v_CBR_FILTER_656(x)             (((x)&1)<<30)
+
+//LCDC_BG_COLOR
+#define m_BG_COLOR                    (0xffffff<<0)
+#define m_BG_B                        (0xff<<0)
+#define m_BG_G                        (0xff<<8)
+#define m_BG_R                        (0xff<<16)
+#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
+#define v_BG_B(x)                     (((x)&0xff)<<0)
+#define v_BG_G(x)                     (((x)&0xff)<<8)
+#define v_BG_R(x)                     (((x)&0xff)<<16)
+
+
+
+
+//LCDC_ BLEND_CTRL
+#define m_HWC_BLEND_EN         (1<<0)
+#define m_W2_BLEND_EN          (1<<1)
+#define m_W1_BLEND_EN          (1<<2)
+#define m_W0_BLEND_EN          (1<<3)
+#define m_HWC_BLEND_FACTOR     (15<<4)
+#define m_W2_BLEND_FACTOR     (0xff<<8)
+#define m_W1_BLEND_FACTOR     (0xff<<16)
+#define m_W0_BLEND_FACTOR     (0xff<<24)
+
+#define v_HWC_BLEND_EN(x)         (((x)&1)<<0)
+#define v_W2_BLEND_EN(x)          (((x)&1)<<1)
+#define v_W1_BLEND_EN(x)          (((x)&1)<<2)
+#define v_W0_BLEND_EN(x)          (((x)&1)<<3)
+#define v_HWC_BLEND_FACTOR(x)    (((x)&15)<<4)
+#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<8)
+#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<16)
+#define v_W0_BLEND_FACTOR(x)     (((x)&0xff)<<24)
+
+//LCDC_INT_STATUS
+#define v_HOR_START_INT_STA        (1<<0)  //status
+#define v_FRM_START_INT_STA        (1<<1)
+#define v_LINE_FLAG_INT_STA        (1<<2)
+#define v_BUS_ERR_INT_STA	   (1<<3)
+#define m_HOR_START_INT_EN     	   (1<<4)  //enable
+#define m_FRM_START_INT_EN          (1<<5)
+#define m_LINE_FLAG_INT_EN         (1<<6)
+#define m_BUS_ERR_INT_EN	   (1<<7)
+#define m_HOR_START_INT_CLEAR      (1<<8) //auto clear
+#define m_FRM_START_INT_CLEAR      (1<<9)
+#define m_LINE_FLAG_INT_CLEAR      (1<<10)
+#define m_BUS_ERR_INT_CLEAR        (1<<11)
+#define m_LINE_FLAG_NUM		   (0xfff<<12)
+#define v_HOR_START_INT_EN(x)      (((x)&1)<<4)
+#define v_FRM_START_INT_EN(x)      (((x)&1)<<5)
+#define v_LINE_FLAG_INT_EN(x)      (((x)&1)<<6)
+#define v_BUS_ERR_INT_EN(x)	   (((x)&1)<<7)
+#define v_HOR_START_INT_CLEAR(x)      (((x)&1)<<8)
+#define v_FRM_START_INT_CLEAR(x)     (((x)&1)<<9)
+#define v_LINE_FLAG_INT_CLEAR(x)     (((x)&1)<<10)
+#define v_BUS_ERR_INT_CLEAR(x)        (((x)&1)<<11)
+#define v_LINE_FLAG_NUM(x)	   (((x)&0xfff)<<12)
+
+
+//LCDC_WIN_VIR
+#define m_WIN0_VIR   (0xfff << 0)
+#define m_WIN1_VIR   (0xfff << 16)
+//LCDC_WINx_VIR ,x is number of words of win0 virtual width
+#define v_WIN0_ARGB888_VIRWIDTH(x) (x)
+#define v_WIN0_RGB888_VIRWIDTH(x) (((x*3)>>2)+((x)%3))
+#define v_WIN0_RGB565_VIRWIDTH(x) (((x)>>1) + ((x%2)?1:0))
+#define v_WIN0_YUV_VIRWIDTH(x)    (((x)>>2) +((x%4)?1:0))
+
+#define v_WIN1_ARGB888_VIRWIDTH(x) (x << 16)
+#define v_WIN1_RGB888_VIRWIDTH(x)  ((((x*3)>>2)+((x)%3)) << 16)
+#define v_WIN1_RGB565_VIRWIDTH(x)  ((((x)>>1) + ((x%2)?1:0)) << 16)
+#define v_WIN1_YUV_VIRWIDTH(x)     ((((x)>>2) +((x%4)?1:0)) << 16 )
+
+
+//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
+#define m_KEYCOLOR          (0xffffff<<0)
+#define m_KEYCOLOR_B          (0xff<<0)
+#define m_KEYCOLOR_G          (0xff<<8)
+#define m_KEYCOLOR_R          (0xff<<16)
+#define m_COLORKEY_EN         (1<<24)
+#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
+#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
+#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
+#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
+#define v_COLORKEY_EN(x)         (((x)&1)<<24)
+
+//LCDC_DEFLICKER_SCL_OFFSET
+#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
+#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
+#define m_W1_VSD_OFFSET           (0xff<<16)
+#define m_W1_VSP_OFFSET           (0xff<<24)
+#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
+#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
+#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
+#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
+
+
+
+
+
+//AXI MS ID
+#define m_W0_YRGB_CH_ID        (0xF<<0)
+#define m_W0_CBR_CH_ID         (0xF<<4)
+#define m_W1_YRGB_CH_ID        (0xF<<8)
+#define m_W2_CH_ID             (0xF<<12)
+#define m_HWC_CH_ID            (0xF<<16)
+#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
+#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
+#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
+#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
+#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
+
+
+/* Low Bits Mask */
+#define m_WORDLO            (0xffff<<0)
+#define m_WORDHI            (0xffff<<16)
+#define v_WORDLO(x)         (((x)&0xffff)<<0)
+#define v_WORDHI(x)         (((x)&0xffff)<<16)
+
+
+//LCDC_WINx_SCL_FACTOR_Y/CBCR
+#define v_X_SCL_FACTOR(x)  ((x)<<0)
+#define v_Y_SCL_FACTOR(x)  ((x)<<16)
+
+//LCDC_DSP_HTOTAL_HS_END
+#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
+#define v_HORPRD(x) ((x)<<16)   //horizontal period
+
+
+//LCDC_DSP_HACT_ST_END
+#define v_HAEP(x) ((x)<<0)  //horizontal active end point
+#define v_HASP(x) ((x)<<16) //horizontal active start point
+
+//LCDC_DSP_VTOTAL_VS_END
+#define v_VSYNC(x) ((x)<<0)
+#define v_VERPRD(x) ((x)<<16)
+
+//LCDC_DSP_VACT_ST_END
+#define v_VAEP(x) ((x)<<0)
+#define v_VASP(x) ((x)<<16)
+
+
+
+#define m_ACTWIDTH       (0xffff<<0)
+#define m_ACTHEIGHT      (0xffff<<16)
+#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
+#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
+
+#define m_VIRST_X      (0xffff<<0)
+#define m_VIRST_Y      (0xffff<<16)
+#define v_VIRST_X(x)      (((x)&0xffff)<<0)
+#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
+
+#define m_PANELST_X      (0x3ff<<0)
+#define m_PANELST_Y      (0x3ff<<16)
+#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
+#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
+
+#define m_PANELWIDTH       (0x3ff<<0)
+#define m_PANELHEIGHT      (0x3ff<<16)
+#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
+#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
+
+#define m_HWC_B                 (0xff<<0)
+#define m_HWC_G                 (0xff<<8)
+#define m_HWC_R                 (0xff<<16)
+#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
+#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
+#define v_HWC_B(x)                 (((x)&0xff)<<0)
+#define v_HWC_G(x)                 (((x)&0xff)<<8)
+#define v_HWC_R(x)                 (((x)&0xff)<<16)
+#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
+#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
+
+//LCDC_WIN0_ACT_INFO
+#define v_ACT_WIDTH(x)     ((x-1)<<0)
+#define v_ACT_HEIGHT(x)    ((x-1)<<16)
+
+//LCDC_WIN0_DSP_INFO
+#define v_DSP_WIDTH(x)     ((x-1)<<0)
+#define v_DSP_HEIGHT(x)    ((x-1)<<16)
+
+//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
+#define v_DSP_STX(x)      (x<<0)
+#define v_DSP_STY(x)      (x<<16)
+
+//Panel display scanning
+#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
+
+#define m_PANEL_END              (0x3ff<<0)
+#define m_PANEL_START            (0x3ff<<16)
+#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
+#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
+
+#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
+//-----------
+
+#define m_HSCALE_FACTOR        (0xffff<<0)
+#define m_VSCALE_FACTOR        (0xffff<<16)
+#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
+#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
+
+#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
+#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
+#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
+#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
+#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
+#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
+#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
+#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
+
+
+//LCDC_SCL_REG0
+#define m_SCL_DSP_ZERO 		 (1<<4)
+#define m_SCL_DEN_INVERT	 (1<<3)
+#define m_SCL_SYNC_INVERT	 (1<<2)
+#define m_SCL_DCLK_INVERT	 (1<<1)
+#define m_SCL_EN	 	 (1<<0)
+#define v_SCL_DSP_ZERO(x) 	 (((x)&1)<<4)
+#define v_SCL_DEN_INVERT(x)	 (((x)&1)<<3)
+#define v_SCL_SYNC_INVERT(x)	 (((x)&1)<<2)
+#define v_SCL_DCLK_INVERT(x)	 (((x)&1)<<1)
+#define v_SCL_EN(x)	 	 (((x)&1)<<0)
+
+//LCDC_SCL_REG1
+#define m_SCL_V_FACTOR 		 (0x3fff<<16)
+#define m_SCL_H_FACTOR		 (0x3fff<<0)
+#define v_SCL_V_FACTOR(x) 		 (((x)&0x3fff)<<16)
+#define v_SCL_H_FACTOR(x)		 (((x)&0x3fff)<<0)
+
+
+//LCDC_SCL_REG2
+#define m_SCL_DSP_FRAME_VST	(0xfff<<16)
+#define m_SCL_DSP_FRAME_HST	(0xfff<<0)
+#define v_SCL_DSP_FRAME_VST(x)	(((x)&0xfff)<<16)
+#define v_SCL_DSP_FRAME_HST(x)	(((x)&0xfff)<<0)
+
+//LCDC_SCL_REG3
+#define m_SCL_DSP_HS_END	(0xff<<16)
+#define m_SCL_DSP_HTOTAL	(0xfff<<0)
+#define v_SCL_DSP_HS_END(x)	(((x)&0xff)<<16)
+#define v_SCL_DSP_HTOTAL(x)	(((x)&0xfff)<<0)
+
+//LCDC_SCL_REG4
+#define m_SCL_DSP_HACT_ST	(0x3ff<<16)
+#define m_SCL_DSP_HACT_END	(0xfff<<0)
+#define v_SCL_DSP_HACT_ST(x)	(((x)&0x3ff)<<16)
+#define v_SCL_DSP_HACT_END(x)	(((x)&0xfff)<<0)
+
+//LCDC_SCL_REG5
+#define m_SCL_DSP_VS_END	(0xff<<16)
+#define m_SCL_DSP_VTOTAL	(0xfff<<0)
+#define v_SCL_DSP_VS_END(x)	(((x)&0xff)<<16)
+#define v_SCL_DSP_VTOTAL(x)	(((x)&0xfff)<<0)
+
+//LCDC_SCL_REG6
+#define m_SCL_DSP_VACT_ST	(0xff<<16)
+#define m_SCL_DSP_VACT_END	(0xfff<<0)
+#define v_SCL_DSP_VACT_ST(x)	(((x)&0xff)<<16)
+#define v_SCL_DSP_VACT_END(x)	(((x)&0xfff)<<0)
+
+
+//LCDC_SCL_REG7
+#define m_SCL_DSP_HBOR_ST	(0x3ff<<16)
+#define m_SCL_DSP_HBOR_END	(0xfff<<0)
+#define v_SCL_DSP_HBOR_ST(x)	(((x)&0x3ff)<<16)
+#define v_SCL_DSP_HBOR_END(x)	(((x)&0xfff)<<0)
+
+//LCDC_SCL_REG8
+
+#define m_SCL_DSP_VBOR_ST	(0xff<<16)
+#define m_SCL_DSP_VBOR_END	(0xfff<<0)
+#define v_SCL_DSP_VBOR_ST(x)	(((x)&0xff)<<16)
+#define v_SCL_DSP_VBOR_END(x)	(((x)&0xfff)<<0)
+
+
+
+
+
+#define CalScale(x, y)	             (((u32)(x)*0x1000)/(y))
+struct rk2928_lcdc_device{
+	int id;
+	struct rk_lcdc_device_driver driver;
+	rk_screen *screen;
+	
+	LCDC_REG *preg;         // LCDC reg base address and backup reg 
+    	LCDC_REG regbak;
+
+	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
+	u32 reg_phy_base;       	// physical basic address of lcdc register
+	u32 len;               		// physical map length of lcdc register
+	spinlock_t  reg_lock;		//one time only one process allowed to config the register
+	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
+	u8 atv_layer_cnt;               //active layer counter,when  atv_layer_cnt = 0,disable lcdc
+	unsigned int		irq;
+	
+	struct clk              *pd;                            //lcdc power domain	
+	struct clk		*hclk;				//lcdc AHP clk
+	struct clk		*dclk;				//lcdc dclk
+	struct clk		*aclk;				//lcdc share memory frequency
+	struct clk		*sclk;				//scale clk
+	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
+	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
+	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
+	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
+	struct clk		*pd_display;		// display power domain
+	u32	pixclock;
+};
+
+struct lcdc_info{
+/*LCD CLK*/
+	struct rk2928_lcdc_device lcdc0;
+
+};
+
+
+struct win_set {
+	volatile u32 y_offset;
+	volatile u32 c_offset;
+};
+
+struct win0_par {
+    u32 refcount;
+    u32	pseudo_pal[16];
+    u32 y_offset;
+    u32 c_offset;
+    u32 xpos;         //size in panel
+    u32 ypos;
+    u32 xsize;        //start point in panel
+    u32 ysize;
+    enum data_format format;
+
+    wait_queue_head_t wait;
+    struct win_set mirror;
+    struct win_set displ;
+    struct win_set done;
+
+    u8 par_seted;
+    u8 addr_seted;
+};
+
+#endif
+
+
diff -Nupr a/drivers/video/rockchip/lcdc/rk3036_lcdc.c b/drivers/video/rockchip/lcdc/rk3036_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk3036_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3036_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1688 @@
+/*
+ * drivers/video/rockchip/lcdc/rk3036_lcdc.c
+ *
+ * Copyright (C) 2014 ROCKCHIP, Inc.
+ * Author:zhengyang<zhengyang@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <asm/div64.h>
+#include <linux/uaccess.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/iomap.h>
+#include <linux/rockchip/grf.h>
+#include <linux/rockchip/common.h>
+#include <dt-bindings/clock/rk_system_status.h>
+#if defined(CONFIG_ION_ROCKCHIP)
+#include <linux/rockchip-iovmm.h>
+#endif
+#include "rk3036_lcdc.h"
+
+static int dbg_thresd;
+module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
+
+#define DBG(level, x...) do {			\
+	if (unlikely(dbg_thresd >= level))	\
+		dev_info(dev_drv->dev, x);		\
+	} while (0)
+
+#define grf_writel(offset, v)	do { \
+	writel_relaxed(v, RK_GRF_VIRT + offset); \
+	dsb(); \
+	} while (0)
+
+static struct rk_lcdc_win lcdc_win[] = {
+	[0] = {
+	       .name = "win0",
+	       .id = 0,
+	       .support_3d = false,
+	       },
+	[1] = {
+	       .name = "win1",
+	       .id = 1,
+	       .support_3d = false,
+	       },
+	[2] = {
+	       .name = "hwc",
+	       .id = 2,
+	       .support_3d = false,
+	       },
+};
+
+static irqreturn_t rk3036_lcdc_isr(int irq, void *dev_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    (struct lcdc_device *)dev_id;
+	ktime_t timestamp = ktime_get();
+	u32 int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
+
+	if (int_reg & m_FS_INT_STA) {
+		timestamp = ktime_get();
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
+			     v_FS_INT_CLEAR(1));
+		/*if (lcdc_dev->driver.wait_fs) {*/
+		if (0) {
+			spin_lock(&(lcdc_dev->driver.cpl_lock));
+			complete(&(lcdc_dev->driver.frame_done));
+			spin_unlock(&(lcdc_dev->driver.cpl_lock));
+		}
+		lcdc_dev->driver.vsync_info.timestamp = timestamp;
+		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
+
+	} else if (int_reg & m_LF_INT_STA) {
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
+			     v_LF_INT_CLEAR(1));
+	}
+	return IRQ_HANDLED;
+}
+
+static int rk3036_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
+{
+#ifdef CONFIG_RK_FPGA
+	lcdc_dev->clk_on = 1;
+	return 0;
+#endif
+	if (!lcdc_dev->clk_on) {
+		clk_prepare_enable(lcdc_dev->hclk);
+		clk_prepare_enable(lcdc_dev->dclk);
+		clk_prepare_enable(lcdc_dev->aclk);
+/*		clk_prepare_enable(lcdc_dev->pd);*/
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 1;
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int rk3036_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
+{
+#ifdef CONFIG_RK_FPGA
+	lcdc_dev->clk_on = 0;
+	return 0;
+#endif
+	if (lcdc_dev->clk_on) {
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 0;
+		spin_unlock(&lcdc_dev->reg_lock);
+		mdelay(25);
+		clk_disable_unprepare(lcdc_dev->dclk);
+		clk_disable_unprepare(lcdc_dev->hclk);
+		clk_disable_unprepare(lcdc_dev->aclk);
+/*		clk_disable_unprepare(lcdc_dev->pd);*/
+	}
+
+	return 0;
+}
+
+static int rk3036_lcdc_enable_irq(struct rk_lcdc_driver *dev_drv)
+{
+	u32 mask, val;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	mask = m_FS_INT_CLEAR | m_FS_INT_EN;
+	val = v_FS_INT_CLEAR(1) | v_FS_INT_EN(1);
+	lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
+	return 0;
+}
+/*
+static int rk3036_lcdc_disable_irq(struct lcdc_device *lcdc_dev)
+{
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		mask = m_FS_INT_CLEAR | m_FS_INT_EN;
+		val = v_FS_INT_CLEAR(0) | v_FS_INT_EN(0);
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	mdelay(1);
+	return 0;
+}*/
+
+static void rk_lcdc_read_reg_defalut_cfg(struct lcdc_device
+					     *lcdc_dev)
+{
+	int reg = 0;
+	u32 value = 0;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	for (reg = 0; reg < 0xe0; reg += 4)
+		value = lcdc_readl(lcdc_dev, reg);
+
+	spin_unlock(&lcdc_dev->reg_lock);
+}
+
+static int rk3036_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
+{
+	int win0_top = 0;
+	u32 mask, val;
+	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
+	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
+
+	int win0_alpha_en = ((win0_format == ARGB888) ||
+				(win0_format == ABGR888)) ? 1 : 0;
+	int win1_alpha_en = ((win1_format == ARGB888) ||
+				(win1_format == ABGR888)) ? 1 : 0;
+	int atv_layer_cnt = lcdc_dev->driver.win[0]->state +
+			lcdc_dev->driver.win[1]->state;
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (DSP_CTRL0 >> 2);
+	win0_top = ((*_pv) & (m_WIN0_TOP)) >> 8;
+
+	if (win0_top && (atv_layer_cnt >= 2) && (win0_alpha_en)) {
+		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN |
+			m_WIN1_PREMUL_SCALE;
+		val = v_WIN0_ALPHA_EN(1) | v_WIN1_ALPHA_EN(0) |
+			v_WIN1_PREMUL_SCALE(0);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+
+		mask = m_WIN0_ALPHA_MODE | m_PREMUL_ALPHA_ENABLE |
+			m_ALPHA_MODE_SEL1;
+		val = v_WIN0_ALPHA_MODE(1) | v_PREMUL_ALPHA_ENABLE(1) |
+			v_ALPHA_MODE_SEL1(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+	} else if ((!win0_top) && (atv_layer_cnt >= 2) &&
+		   (win1_alpha_en)) {
+		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN |
+			m_WIN1_PREMUL_SCALE;
+		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(1) |
+			v_WIN1_PREMUL_SCALE(0);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+
+		mask = m_WIN1_ALPHA_MODE | m_PREMUL_ALPHA_ENABLE |
+			m_ALPHA_MODE_SEL1;
+		val = v_WIN1_ALPHA_MODE(1) | v_PREMUL_ALPHA_ENABLE(1) |
+			v_ALPHA_MODE_SEL1(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+	} else {
+		mask = m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
+		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(0);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+	}
+
+	if (lcdc_dev->driver.win[2]->state == 1) {
+		mask =  m_HWC_ALPAH_EN;
+		val = v_HWC_ALPAH_EN(1);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+
+		mask =  m_HWC_ALPHA_MODE;
+		val = v_HWC_ALPHA_MODE(1);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+	} else {
+		mask =  m_HWC_ALPAH_EN;
+		val = v_HWC_ALPAH_EN(0);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+	}
+
+	return 0;
+}
+
+static void lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
+				   struct rk_lcdc_win *win)
+{
+	u32 mask, val;
+	int hwc_size;
+
+	if (win->state == 1) {
+		if (win->id == 0) {
+			mask = m_WIN0_EN | m_WIN0_FORMAT | m_WIN0_RB_SWAP;
+			val = v_WIN0_EN(win->state) |
+			      v_WIN0_FORMAT(win->area[0].fmt_cfg) |
+			      v_WIN0_RB_SWAP(win->area[0].swap_rb);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
+				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
+				    v_Y_SCL_FACTOR(win->scale_yrgb_y));
+			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,
+				    v_X_SCL_FACTOR(win->scale_cbcr_x) |
+				    v_Y_SCL_FACTOR(win->scale_cbcr_y));
+			lcdc_msk_reg(lcdc_dev, WIN0_VIR,
+				     m_YRGB_VIR | m_CBBR_VIR,
+				     v_YRGB_VIR(win->area[0].y_vir_stride) |
+				     v_CBBR_VIR(win->area[0].uv_vir_stride));
+			lcdc_writel(lcdc_dev, WIN0_ACT_INFO,
+				    v_ACT_WIDTH(win->area[0].xact) |
+				    v_ACT_HEIGHT(win->area[0].yact));
+			lcdc_writel(lcdc_dev, WIN0_DSP_ST,
+				    v_DSP_STX(win->area[0].dsp_stx) |
+				    v_DSP_STY(win->area[0].dsp_sty));
+			lcdc_writel(lcdc_dev, WIN0_DSP_INFO,
+				    v_DSP_WIDTH(win->post_cfg.xsize) |
+				    v_DSP_HEIGHT(win->post_cfg.ysize));
+
+			lcdc_writel(lcdc_dev, WIN0_YRGB_MST,
+				    win->area[0].y_addr);
+			lcdc_writel(lcdc_dev, WIN0_CBR_MST,
+				    win->area[0].uv_addr);
+		} else if (win->id == 1) {
+			mask = m_WIN1_EN | m_WIN1_FORMAT | m_WIN1_RB_SWAP;
+			val = v_WIN1_EN(win->state) |
+			      v_WIN1_FORMAT(win->area[0].fmt_cfg) |
+			      v_WIN1_RB_SWAP(win->area[0].swap_rb);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_YRGB,
+				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
+				    v_Y_SCL_FACTOR(win->scale_yrgb_y));
+
+			lcdc_msk_reg(lcdc_dev, WIN1_VIR, m_YRGB_VIR,
+				     v_YRGB_VIR(win->area[0].y_vir_stride));
+			lcdc_writel(lcdc_dev, WIN1_ACT_INFO,
+				    v_ACT_WIDTH(win->area[0].xact) |
+				    v_ACT_HEIGHT(win->area[0].yact));
+			lcdc_writel(lcdc_dev, WIN1_DSP_INFO,
+				    v_DSP_WIDTH(win->post_cfg.xsize) |
+				    v_DSP_HEIGHT(win->post_cfg.ysize));
+			lcdc_writel(lcdc_dev, WIN1_DSP_ST,
+				    v_DSP_STX(win->area[0].dsp_stx) |
+				    v_DSP_STY(win->area[0].dsp_sty));
+			lcdc_writel(lcdc_dev, WIN1_MST, win->area[0].y_addr);
+		} else if (win->id == 2) {
+			mask = m_HWC_EN | m_HWC_LODAD_EN;
+			val = v_HWC_EN(win->state) | v_HWC_LODAD_EN(1);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			if ((win->area[0].xsize == 32) &&
+			    (win->area[0].ysize == 32))
+				hwc_size = 0;
+			else if ((win->area[0].xsize == 64) &&
+				 (win->area[0].ysize == 64))
+				hwc_size = 1;
+			else
+				dev_err(lcdc_dev->dev,
+					"unsupport hwc size:x=%d,y=%d\n",
+					win->area[0].xsize,
+					win->area[0].ysize);
+			lcdc_writel(lcdc_dev, HWC_DSP_ST,
+				    v_DSP_STX(win->area[0].dsp_stx) |
+				    v_DSP_STY(win->area[0].dsp_sty));
+			lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
+		}
+	} else {
+		win->area[0].y_addr = 0;
+		win->area[0].uv_addr = 0;
+		if (win->id == 0) {
+			lcdc_msk_reg(lcdc_dev,
+				     SYS_CTRL, m_WIN0_EN, v_WIN0_EN(0));
+			lcdc_writel(lcdc_dev, WIN0_YRGB_MST,
+				    win->area[0].y_addr);
+			lcdc_writel(lcdc_dev, WIN0_CBR_MST,
+				    win->area[0].uv_addr);
+		} else if (win->id == 1) {
+			lcdc_msk_reg(lcdc_dev,
+				     SYS_CTRL, m_WIN1_EN, v_WIN1_EN(0));
+			lcdc_writel(lcdc_dev, WIN1_MST, win->area[0].y_addr);
+		} else if (win->id == 2) {
+			lcdc_msk_reg(lcdc_dev,
+				     SYS_CTRL, m_HWC_EN | m_HWC_LODAD_EN,
+				     v_HWC_EN(0) | v_HWC_LODAD_EN(0));
+			lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
+		}
+	}
+	rk3036_lcdc_alpha_cfg(lcdc_dev);
+}
+
+static void lcdc_layer_enable(struct lcdc_device *lcdc_dev,
+			      unsigned int win_id, bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on) &&
+	    lcdc_dev->driver.win[win_id]->state != open) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev,
+					 "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt |= (1 << win_id);
+		} else if ((lcdc_dev->atv_layer_cnt & (1 << win_id)) && (!open)) {
+			lcdc_dev->atv_layer_cnt &= ~(1 << win_id);
+		}
+		lcdc_dev->driver.win[win_id]->state = open;
+		if (!open) {
+			lcdc_layer_update_regs(lcdc_dev,
+					       lcdc_dev->driver.win[win_id]);
+			lcdc_cfg_done(lcdc_dev);
+		}
+		/*if no layer used,disable lcdc*/
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev,
+				 "no layer is used, go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+}
+/*
+static int rk3036_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
+	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
+	int timeout;
+	unsigned long flags;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(lcdc_dev->standby));
+		lcdc_layer_update_regs(lcdc_dev, win0);
+		lcdc_layer_update_regs(lcdc_dev, win1);
+		rk3036_lcdc_alpha_cfg(lcdc_dev);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	if (0) {
+		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
+						      msecs_to_jiffies
+						      (dev_drv->cur_screen->ft
+						       + 5));
+		if (!timeout && (!dev_drv->frame_done.done)) {
+			dev_warn(lcdc_dev->dev,
+				 "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
+	return 0;
+}
+*/
+static void rk3036_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
+{
+	memcpy((u8 *)lcdc_dev->regs, (u8 *)lcdc_dev->regsbak, 0xe0);
+}
+
+static void rk3036_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
+{
+	u32 mask, val;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	/*spin_lock(&lcdc_dev->reg_lock);*/
+	if (likely(lcdc_dev->clk_on)) {
+		mask = m_MMU_EN | m_AXI_MAX_OUTSTANDING_EN |
+			m_AXI_OUTSTANDING_MAX_NUM;
+		val = v_MMU_EN(1) | v_AXI_OUTSTANDING_MAX_NUM(31) |
+			v_AXI_MAX_OUTSTANDING_EN(1);
+		lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+	}
+	/*spin_unlock(&lcdc_dev->reg_lock);*/
+}
+
+static int rk3036_lcdc_set_hwc_lut(struct rk_lcdc_driver *dev_drv,
+				   int *hwc_lut, int mode)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	int len = 256*4;
+
+	struct lcdc_device *lcdc_dev =
+			container_of(dev_drv, struct lcdc_device, driver);
+	if (dev_drv->hwc_lut == NULL)
+		dev_drv->hwc_lut = devm_kzalloc(lcdc_dev->dev, len, GFP_KERNEL);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_HWC_LUT_EN, v_HWC_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	mdelay(25);
+	for (i = 0; i < 256; i++) {
+		if (mode == 1)
+			dev_drv->hwc_lut[i] = hwc_lut[i];
+		v = dev_drv->hwc_lut[i];
+		c = lcdc_dev->hwc_lut_addr_base + i;
+		writel_relaxed(v, c);
+	}
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_HWC_LUT_EN, v_HWC_LUT_EN(1));
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+#if 0
+static int rk3036_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv)
+{
+#ifdef CONFIG_RK_FPGA
+	return 0;
+#endif
+	int ret, fps;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
+	if (ret)
+		dev_err(dev_drv->dev,
+			"set lcdc%d dclk failed\n", lcdc_dev->id);
+	lcdc_dev->pixclock =
+		 div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
+
+	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
+	screen->ft = 1000 / fps;
+	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
+		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
+	return 0;
+}
+#endif
+/********do basic init*********/
+static int rk3036_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+				struct lcdc_device, driver);
+
+	if (lcdc_dev->pre_init)
+		return 0;
+	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
+	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
+	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
+/*	lcdc_dev->pd   = devm_clk_get(lcdc_dev->dev, "pd_lcdc"); */
+
+	if (/*IS_ERR(lcdc_dev->pd) ||*/ (IS_ERR(lcdc_dev->aclk)) ||
+	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
+		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
+			lcdc_dev->id);
+	}
+
+	rk_disp_pwr_enable(dev_drv);
+	rk3036_lcdc_clk_enable(lcdc_dev);
+
+	/*backup reg config at uboot*/
+	rk_lcdc_read_reg_defalut_cfg(lcdc_dev);
+	if (lcdc_readl(lcdc_dev, AXI_BUS_CTRL) & m_TVE_DAC_DCLK_EN)
+		dev_drv->cur_screen->type = SCREEN_TVOUT;
+
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_AUTO_GATING_EN,
+		     v_AUTO_GATING_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	if (dev_drv->iommu_enabled)
+		/*disable win0 to workaround iommu pagefault*/
+		lcdc_layer_enable(lcdc_dev, 0, 0);
+	lcdc_dev->pre_init = true;
+
+	return 0;
+}
+
+static int rk3036_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
+{
+	int ret = -EINVAL;
+	int fps;
+	u16 face = 0;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 right_margin = screen->mode.right_margin;
+	u16 left_margin = screen->mode.left_margin;
+	u16 lower_margin = screen->mode.lower_margin;
+	u16 upper_margin = screen->mode.upper_margin;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		switch (screen->type) {
+		case SCREEN_HDMI:
+			mask = m_HDMI_DCLK_EN;
+			val = v_HDMI_DCLK_EN(1);
+			if (screen->pixelrepeat) {
+				mask |= m_CORE_CLK_DIV_EN;
+				val |= v_CORE_CLK_DIV_EN(1);
+			} else {
+				mask |= m_CORE_CLK_DIV_EN;
+				val |= v_CORE_CLK_DIV_EN(0);
+			}
+			lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+			mask = (1 << 4) | (1 << 5) | (1 << 6);
+			val = (screen->pin_hsync << 4) |
+				(screen->pin_vsync << 5) |
+				(screen->pin_den << 6);
+			grf_writel(RK3036_GRF_SOC_CON2, (mask << 16) | val);
+			break;
+		case SCREEN_TVOUT:
+			mask = m_TVE_DAC_DCLK_EN;
+			val = v_TVE_DAC_DCLK_EN(1);
+			if (screen->pixelrepeat) {
+				mask |= m_CORE_CLK_DIV_EN;
+				val |= v_CORE_CLK_DIV_EN(1);
+			} else {
+				mask |= m_CORE_CLK_DIV_EN;
+				val |= v_CORE_CLK_DIV_EN(0);
+			}
+			lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+			if ((x_res == 720) && (y_res == 576)) {
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+					     m_TVE_MODE, v_TVE_MODE(TV_PAL));
+			} else if ((x_res == 720) && (y_res == 480)) {
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+					     m_TVE_MODE, v_TVE_MODE(TV_NTSC));
+			} else {
+				dev_err(lcdc_dev->dev,
+					"unsupported video timing!\n");
+				return -1;
+			}
+			break;
+		default:
+			dev_err(lcdc_dev->dev, "un supported interface!\n");
+			break;
+		}
+
+		mask = m_DSP_OUT_FORMAT | m_HSYNC_POL | m_VSYNC_POL |
+		    m_DEN_POL | m_DCLK_POL;
+		val = v_DSP_OUT_FORMAT(face) |
+			v_HSYNC_POL(screen->pin_hsync) |
+			v_VSYNC_POL(screen->pin_vsync) |
+			v_DEN_POL(screen->pin_den) |
+			v_DCLK_POL(screen->pin_dclk);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+
+		mask = m_BG_COLOR | m_DSP_BG_SWAP | m_DSP_RB_SWAP |
+		    m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
+		    m_DSP_DUMMY_SWAP | m_BLANK_EN;
+
+		val = v_BG_COLOR(0x000000) | v_DSP_BG_SWAP(screen->swap_gb) |
+		    v_DSP_RB_SWAP(screen->swap_rb) |
+		    v_DSP_RG_SWAP(screen->swap_rg) |
+		    v_DSP_DELTA_SWAP(screen->swap_delta) |
+				     v_DSP_DUMMY_SWAP(screen->swap_dumy) |
+						      v_BLANK_EN(0) |
+				     v_BLACK_EN(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+		val =
+		    v_HSYNC(screen->mode.hsync_len) | v_HORPRD(screen->mode.
+							       hsync_len +
+							       left_margin +
+							       x_res +
+							       right_margin);
+		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END, val);
+		val = v_HAEP(screen->mode.hsync_len + left_margin + x_res) |
+		    v_HASP(screen->mode.hsync_len + left_margin);
+		lcdc_writel(lcdc_dev, DSP_HACT_ST_END, val);
+
+		if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+			/*First Field Timing*/
+			lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END,
+				    v_VSYNC(screen->mode.vsync_len) |
+				    v_VERPRD(2 * (screen->mode.vsync_len +
+						  upper_margin + lower_margin)
+					     + y_res + 1));
+			lcdc_writel(lcdc_dev, DSP_VACT_ST_END,
+				    v_VAEP(screen->mode.vsync_len +
+					upper_margin + y_res/2) |
+				    v_VASP(screen->mode.vsync_len +
+					upper_margin));
+			/*Second Field Timing*/
+			lcdc_writel(lcdc_dev, DSP_VS_ST_END_F1,
+				    v_VSYNC_ST_F1(screen->mode.vsync_len +
+						  upper_margin + y_res/2 +
+						  lower_margin) |
+				    v_VSYNC_END_F1(2 * screen->mode.vsync_len
+						   + upper_margin + y_res/2 +
+						   lower_margin));
+			lcdc_writel(lcdc_dev, DSP_VACT_ST_END_F1,
+				    v_VAEP(2 * (screen->mode.vsync_len +
+						upper_margin) + y_res +
+						lower_margin + 1) |
+				    v_VASP(2 * (screen->mode.vsync_len +
+						upper_margin) + y_res/2 +
+						lower_margin + 1));
+
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_INTERLACE_DSP_EN |
+				     m_INTERLACE_DSP_POL |
+				     m_WIN1_DIFF_DCLK_EN |
+				     m_WIN0_YRGB_DEFLICK_EN |
+				     m_WIN0_CBR_DEFLICK_EN |
+				     m_WIN0_INTERLACE_EN |
+				     m_WIN1_INTERLACE_EN,
+				     v_INTERLACE_DSP_EN(1) |
+				     v_INTERLACE_DSP_POL(0) |
+				     v_WIN1_DIFF_DCLK_EN(1) |
+				     v_WIN0_YRGB_DEFLICK_EN(1) |
+				     v_WIN0_CBR_DEFLICK_EN(1) |
+				     v_WIN0_INTERLACE_EN(1) |
+				     v_WIN1_INTERLACE_EN(1));
+		} else {
+			val = v_VSYNC(screen->mode.vsync_len) |
+			      v_VERPRD(screen->mode.vsync_len + upper_margin +
+					y_res + lower_margin);
+			lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END, val);
+
+			val = v_VAEP(screen->mode.vsync_len +
+				     upper_margin + y_res) |
+			    v_VASP(screen->mode.vsync_len +
+				   screen->mode.upper_margin);
+			lcdc_writel(lcdc_dev, DSP_VACT_ST_END, val);
+
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_INTERLACE_DSP_EN |
+				     m_WIN1_DIFF_DCLK_EN |
+				     m_WIN0_YRGB_DEFLICK_EN |
+				     m_WIN0_CBR_DEFLICK_EN |
+				     m_WIN0_INTERLACE_EN |
+				     m_WIN1_INTERLACE_EN,
+				     v_INTERLACE_DSP_EN(0) |
+				     v_WIN1_DIFF_DCLK_EN(0) |
+				     v_WIN0_YRGB_DEFLICK_EN(0) |
+				     v_WIN0_CBR_DEFLICK_EN(0) |
+				     v_WIN0_INTERLACE_EN(1) |
+				     v_WIN1_INTERLACE_EN(1));
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
+	if (ret)
+		dev_err(dev_drv->dev,
+			"set lcdc%d dclk failed\n", lcdc_dev->id);
+	lcdc_dev->pixclock =
+	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
+
+	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
+	screen->ft = 1000 / fps;
+	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
+		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	if (screen->init)
+		screen->init();
+
+	return 0;
+}
+
+static int rk3036_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
+			    bool open)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+
+	/*enable clk,when first layer open */
+	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
+		rk3036_lcdc_pre_init(dev_drv);
+		rk3036_lcdc_clk_enable(lcdc_dev);
+		if (dev_drv->iommu_enabled) {
+			if (!dev_drv->mmu_dev) {
+				dev_drv->mmu_dev =
+				rk_fb_get_sysmmu_device_by_compatible(
+					dev_drv->mmu_dts_name);
+				if (dev_drv->mmu_dev) {
+					rk_fb_platform_set_sysmmu(dev_drv->mmu_dev,
+								  dev_drv->dev);
+				} else {
+					dev_err(dev_drv->dev,
+						"failed to get iommu device\n"
+						);
+					return -1;
+				}
+			}
+		}
+		rk3036_lcdc_reg_restore(lcdc_dev);
+		/*if (dev_drv->iommu_enabled)
+			rk3036_lcdc_mmu_en(dev_drv);*/
+		if ((support_uboot_display() && (lcdc_dev->prop == PRMRY))) {
+			/*rk3036_lcdc_set_dclk(dev_drv);*/
+			rk3036_lcdc_enable_irq(dev_drv);
+		} else {
+			rk3036_load_screen(dev_drv, 1);
+		}
+	}
+
+	if (win_id < ARRAY_SIZE(lcdc_win))
+		lcdc_layer_enable(lcdc_dev, win_id, open);
+	else
+		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
+
+	/*when all layer closed,disable clk */
+/*
+	if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
+		rk3036_lcdc_disable_irq(lcdc_dev);
+		rk3036_lcdc_reg_update(dev_drv);
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+		rk3036_lcdc_clk_disable(lcdc_dev);
+	}
+*/
+	return 0;
+}
+
+static int rk3036_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+			container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	struct rk_lcdc_win *win = NULL;
+	char fmt[9] = "NULL";
+
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+
+	if (win_id == 0) {
+		win = dev_drv->win[0];
+	} else if (win_id == 1) {
+		win = dev_drv->win[1];
+	} else if (win_id == 2) {
+		win = dev_drv->win[2];
+	} else {
+		dev_err(dev_drv->dev, "un supported win number:%d\n", win_id);
+		return -EINVAL;
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	win->post_cfg.xpos = win->area[0].xpos * (dev_drv->overscan.left +
+		dev_drv->overscan.right)/200 + screen->mode.xres *
+			(100 - dev_drv->overscan.left) / 200;
+
+	win->post_cfg.ypos = win->area[0].ypos * (dev_drv->overscan.top +
+		dev_drv->overscan.bottom)/200 +
+		screen->mode.yres *
+			(100 - dev_drv->overscan.top) / 200;
+	win->post_cfg.xsize = win->area[0].xsize *
+				(dev_drv->overscan.left +
+				dev_drv->overscan.right)/200;
+	win->post_cfg.ysize = win->area[0].ysize *
+				(dev_drv->overscan.top +
+				dev_drv->overscan.bottom)/200;
+
+	win->area[0].dsp_stx = win->post_cfg.xpos + screen->mode.left_margin +
+				screen->mode.hsync_len;
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		win->post_cfg.ysize /= 2;
+		win->area[0].dsp_sty = win->post_cfg.ypos/2 +
+					screen->mode.upper_margin +
+					screen->mode.vsync_len;
+	} else {
+		win->area[0].dsp_sty = win->post_cfg.ypos +
+					screen->mode.upper_margin +
+					screen->mode.vsync_len;
+	}
+	win->scale_yrgb_x = calscale(win->area[0].xact, win->post_cfg.xsize);
+	win->scale_yrgb_y = calscale(win->area[0].yact, win->post_cfg.ysize);
+
+	switch (win->area[0].format) {
+	case ARGB888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 0;
+		break;
+	case XBGR888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
+		break;
+	case ABGR888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
+		break;
+	case RGB888:
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
+		win->area[0].swap_rb = 0;
+		break;
+	case RGB565:
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
+		win->area[0].swap_rb = 0;
+		break;
+	case YUV444:
+		if (win_id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR444;
+			win->scale_cbcr_x = calscale(win->area[0].xact,
+						     win->post_cfg.xsize);
+			win->scale_cbcr_y = calscale(win->area[0].yact,
+						     win->post_cfg.ysize);
+			win->area[0].swap_rb = 0;
+		} else {
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n",
+				__func__);
+		}
+		break;
+	case YUV422:
+		if (win_id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR422;
+			win->scale_cbcr_x = calscale((win->area[0].xact / 2),
+						     win->post_cfg.xsize);
+			win->scale_cbcr_y = calscale(win->area[0].yact,
+						     win->post_cfg.ysize);
+			win->area[0].swap_rb = 0;
+		} else {
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n",
+				__func__);
+		}
+		break;
+	case YUV420:
+		if (win_id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
+			win->scale_cbcr_x = calscale(win->area[0].xact / 2,
+						     win->post_cfg.xsize);
+			win->scale_cbcr_y = calscale(win->area[0].yact / 2,
+						     win->post_cfg.ysize);
+			win->area[0].swap_rb = 0;
+		} else {
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n",
+				__func__);
+		}
+		break;
+	default:
+		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
+			__func__);
+		break;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	DBG(2, "lcdc%d>>%s\n"
+		">>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
+		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
+		__func__, get_format_string(win->area[0].format, fmt),
+		win->area[0].xact, win->area[0].yact, win->post_cfg.xsize,
+		win->post_cfg.ysize, win->area[0].xvir, win->area[0].yvir,
+		win->post_cfg.xpos, win->post_cfg.ypos);
+	return 0;
+}
+
+static int rk3036_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+
+	if (win_id == 0) {
+		win = dev_drv->win[0];
+	} else if (win_id == 1) {
+		win = dev_drv->win[1];
+	} else if (win_id == 2) {
+		win = dev_drv->win[2];
+	} else {
+		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
+		return -EINVAL;
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		win->area[0].y_addr = win->area[0].smem_start +
+					win->area[0].y_offset;
+		win->area[0].uv_addr = win->area[0].cbr_start +
+					win->area[0].c_offset;
+		if (win->area[0].y_addr)
+			lcdc_layer_update_regs(lcdc_dev, win);
+		/*lcdc_cfg_done(lcdc_dev);*/
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x>>offset:%d\n",
+	    lcdc_dev->id, __func__, win->area[0].y_addr,
+	    win->area[0].uv_addr, win->area[0].y_offset);
+	 /* this is the first frame of the system,
+		enable frame start interrupt*/
+	if ((dev_drv->first_frame))  {
+		dev_drv->first_frame = 0;
+		rk3036_lcdc_enable_irq(dev_drv);
+	}
+	return 0;
+}
+
+static int rk3036_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
+			     unsigned long arg, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	struct color_key_cfg clr_key_cfg;
+
+	switch (cmd) {
+	case RK_FBIOGET_PANEL_SIZE:
+		panel_size[0] = lcdc_dev->screen->mode.xres;
+		panel_size[1] = lcdc_dev->screen->mode.yres;
+		if (copy_to_user(argp, panel_size, 8))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_COLOR_KEY_CFG:
+		if (copy_from_user(&clr_key_cfg, argp,
+				   sizeof(struct color_key_cfg)))
+			return -EFAULT;
+		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
+			    clr_key_cfg.win0_color_key_cfg);
+		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
+			    clr_key_cfg.win1_color_key_cfg);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int rk3036_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
+				  const char *id)
+{
+	int win_id = 0;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (!strcmp(id, "fb0"))
+		win_id = dev_drv->fb0_win_id;
+	else if (!strcmp(id, "fb1"))
+		win_id = dev_drv->fb1_win_id;
+	else if (!strcmp(id, "fb2"))
+		win_id = dev_drv->fb2_win_id;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return win_id;
+}
+
+static int rk3036_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
+				     int win_id,
+				     int area_id)
+{
+	return dev_drv->win[win_id]->state;
+}
+
+static int rk3036_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
+	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
+	int ovl, needswap = 0;
+
+	if (!swap) {
+		if (win0->z_order >= 0 &&
+		    win1->z_order >= 0 &&
+		    win0->z_order > win1->z_order)
+			needswap = 1;
+		else
+			needswap = 0;
+	} else {
+		needswap = swap;
+	}
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (set) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_TOP,
+				     v_WIN0_TOP(needswap));
+			ovl = swap;
+		} else {
+			ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
+		}
+	} else {
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+static int rk3036_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	if (dev_drv->suspend_flag)
+		return 0;
+	dev_drv->suspend_flag = 1;
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
+			     v_BLANK_EN(1));
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
+			     v_FS_INT_CLEAR(1));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(1));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(1));
+		lcdc_cfg_done(lcdc_dev);
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	rk3036_lcdc_clk_disable(lcdc_dev);
+	rk_disp_pwr_disable(dev_drv);
+	return 0;
+}
+
+static int rk3036_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (!dev_drv->suspend_flag)
+		return 0;
+	rk_disp_pwr_enable(dev_drv);
+	dev_drv->suspend_flag = 0;
+
+	if (lcdc_dev->atv_layer_cnt) {
+		rk3036_lcdc_clk_enable(lcdc_dev);
+		rk3036_lcdc_reg_restore(lcdc_dev);
+		/*set hwc lut*/
+		rk3036_lcdc_set_hwc_lut(dev_drv, dev_drv->hwc_lut, 0);
+
+		spin_lock(&lcdc_dev->reg_lock);
+
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(0));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(0));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
+			     v_BLANK_EN(0));
+		lcdc_cfg_done(lcdc_dev);
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_activate(dev_drv->dev);
+		}
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	return 0;
+}
+
+
+static int rk3036_lcdc_blank(struct rk_lcdc_driver *dev_drv,
+			     int win_id, int blank_mode)
+{
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		rk3036_lcdc_early_resume(dev_drv);
+		break;
+	case FB_BLANK_NORMAL:
+		rk3036_lcdc_early_suspend(dev_drv);
+		break;
+	default:
+		rk3036_lcdc_early_suspend(dev_drv);
+		break;
+	}
+
+	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
+
+	return 0;
+}
+
+static int rk3036_lcdc_cfg_done(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int i;
+	struct rk_lcdc_win *win = NULL;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (dev_drv->iommu_enabled) {
+			if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
+				lcdc_dev->iommu_status = 1;
+				if (support_uboot_display() &&
+				    lcdc_dev->prop == PRMRY) {
+					lcdc_msk_reg(lcdc_dev, SYS_CTRL,
+						     m_WIN0_EN,
+						     v_WIN0_EN(0));
+				}
+				lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+					     v_LCDC_STANDBY(1));
+				lcdc_cfg_done(lcdc_dev);
+				mdelay(50);
+				rockchip_iovmm_activate(dev_drv->dev);
+				rk3036_lcdc_mmu_en(dev_drv);
+			}
+		}
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(lcdc_dev->standby));
+		for (i = 0; i < ARRAY_SIZE(lcdc_win); i++) {
+			win = dev_drv->win[i];
+			if ((win->state == 0) && (win->last_state == 1))
+				lcdc_layer_update_regs(lcdc_dev, win);
+			win->last_state = win->state;
+		}
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+/*
+	a:[-30~0]:
+	    sin_hue = sin(a)*256 +0x100;
+	    cos_hue = cos(a)*256;
+	a:[0~30]
+	    sin_hue = sin(a)*256;
+	    cos_hue = cos(a)*256;
+*/
+static int rk3036_lcdc_get_bcsh_hue(struct rk_lcdc_driver *dev_drv,
+				    bcsh_hue_mode mode)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		val = lcdc_readl(lcdc_dev, BCSH_H);
+		switch (mode) {
+		case H_SIN:
+			val &= m_BCSH_SIN_HUE;
+			break;
+		case H_COS:
+			val &= m_BCSH_COS_HUE;
+			val >>= 8;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return val;
+}
+
+
+static int rk3036_lcdc_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,
+				    int sin_hue, int cos_hue)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		mask = m_BCSH_SIN_HUE | m_BCSH_COS_HUE;
+		val = v_BCSH_SIN_HUE(sin_hue) | v_BCSH_COS_HUE(cos_hue);
+		lcdc_msk_reg(lcdc_dev, BCSH_H, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk3036_lcdc_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
+				    bcsh_bcs_mode mode, int value)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		switch (mode) {
+		case BRIGHTNESS:
+		/*from 0 to 255,typical is 128*/
+			if (value < 0x20)
+				value += 0x20;
+			else if (value >= 0x20)
+				value = value - 0x20;
+			mask =  m_BCSH_BRIGHTNESS;
+			val = v_BCSH_BRIGHTNESS(value);
+			break;
+		case CONTRAST:
+		/*from 0 to 510,typical is 256*/
+			mask =  m_BCSH_CONTRAST;
+			val =  v_BCSH_CONTRAST(value);
+			break;
+		case SAT_CON:
+		/*from 0 to 1015,typical is 256*/
+			mask = m_BCSH_SAT_CON;
+			val = v_BCSH_SAT_CON(value);
+			break;
+		default:
+			break;
+		}
+		lcdc_msk_reg(lcdc_dev, BCSH_BCS, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return val;
+}
+
+static int rk3036_lcdc_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
+				    bcsh_bcs_mode mode)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		val = lcdc_readl(lcdc_dev, BCSH_BCS);
+		switch (mode) {
+		case BRIGHTNESS:
+			val &= m_BCSH_BRIGHTNESS;
+			if (val > 0x20)
+				val -= 0x20;
+			else if (val == 0x20)
+				val = -32;
+			break;
+		case CONTRAST:
+			val &= m_BCSH_CONTRAST;
+			val >>= 8;
+			break;
+		case SAT_CON:
+			val &= m_BCSH_SAT_CON;
+			val >>= 16;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return val;
+}
+
+
+static int rk3036_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (open) {
+			lcdc_writel(lcdc_dev, BCSH_CTRL,
+				    v_BCSH_EN(1) | v_BCSH_OUT_MODE(3));
+			lcdc_writel(lcdc_dev, BCSH_BCS,
+				    v_BCSH_BRIGHTNESS(0x00) |
+				    v_BCSH_CONTRAST(0x80) |
+				    v_BCSH_SAT_CON(0x80));
+			lcdc_writel(lcdc_dev, BCSH_H, v_BCSH_COS_HUE(0x80));
+		} else {
+			mask = m_BCSH_EN;
+			val = v_BCSH_EN(0);
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL, mask, val);
+		}
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk3036_lcdc_set_overscan(struct rk_lcdc_driver *dev_drv,
+				    struct overscan *overscan)
+{
+	int i;
+
+	dev_drv->overscan = *overscan;
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		if (dev_drv->win[i] && dev_drv->win[i]->state) {
+			rk3036_lcdc_set_par(dev_drv, i);
+			rk3036_lcdc_pan_display(dev_drv, i);
+		}
+	}
+	rk3036_lcdc_cfg_done(dev_drv);
+	return 0;
+}
+
+static int rk3036_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
+{
+	struct rk_lcdc_win_area area;
+	int fb2_win_id, fb1_win_id, fb0_win_id;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (order == FB_DEFAULT_ORDER)
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
+
+	fb2_win_id = order / 100;
+	fb1_win_id = (order / 10) % 10;
+	fb0_win_id = order % 10;
+
+	if (fb0_win_id != dev_drv->fb0_win_id) {
+		area = dev_drv->win[(int)dev_drv->fb0_win_id]->area[0];
+		dev_drv->win[(int)dev_drv->fb0_win_id]->area[0] =
+			dev_drv->win[fb0_win_id]->area[0];
+		dev_drv->win[fb0_win_id]->area[0] = area;
+		dev_drv->fb0_win_id = fb0_win_id;
+	}
+	dev_drv->fb1_win_id = fb1_win_id;
+	dev_drv->fb2_win_id = fb2_win_id;
+
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return 0;
+}
+
+static int rk3036_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+	u32 pixclock;
+	u32 x_total, y_total;
+
+	if (set) {
+		ft = div_u64(1000000000000llu, fps);
+		x_total =
+		    screen->mode.upper_margin + screen->mode.lower_margin +
+		    screen->mode.yres + screen->mode.vsync_len;
+		y_total =
+		    screen->mode.left_margin + screen->mode.right_margin +
+		    screen->mode.xres + screen->mode.hsync_len;
+		dev_drv->pixclock = div_u64(ft, x_total * y_total);
+		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+	}
+
+	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	lcdc_dev->pixclock = pixclock;
+	dev_drv->pixclock = pixclock;
+	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
+	screen->ft = 1000 / fps;	/*one frame time in ms */
+
+	if (set)
+		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
+			 clk_get_rate(lcdc_dev->dclk), fps);
+
+	return fps;
+}
+
+static int rk3036_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 int_reg;
+	int ret;
+
+	if (lcdc_dev->clk_on) {
+		int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
+		if (int_reg & m_LF_INT_STA) {
+			lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
+				     v_LF_INT_CLEAR(1));
+			ret = RK_LF_STATUS_FC;
+		} else {
+			ret = RK_LF_STATUS_FR;
+		}
+	} else {
+		ret = RK_LF_STATUS_NC;
+	}
+
+	return ret;
+}
+
+static int rk3036_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
+				    unsigned int dsp_addr[][4])
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (lcdc_dev->clk_on) {
+		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
+		dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_MST);
+	}
+	return 0;
+}
+
+static ssize_t rk3036_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
+					 char *buf, int win_id)
+{
+	struct rk_lcdc_win *win = NULL;
+	char fmt[9] = "NULL";
+	u32	size;
+
+	if (win_id < ARRAY_SIZE(lcdc_win)) {
+		win = dev_drv->win[win_id];
+	} else {
+		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
+		return 0;
+	}
+
+	size = snprintf(buf, PAGE_SIZE, "win%d: %s\n", win_id,
+			get_format_string(win->area[0].format, fmt));
+	size += snprintf(buf + size, PAGE_SIZE - size,
+			 "	xact %d yact %d xvir %d yvir %d\n",
+		win->area[0].xact, win->area[0].yact,
+		win->area[0].xvir, win->area[0].yvir);
+	size += snprintf(buf + size, PAGE_SIZE - size,
+			 "	xpos %d ypos %d xsize %d ysize %d\n",
+		win->area[0].xpos, win->area[0].ypos,
+		win->area[0].xsize, win->area[0].ysize);
+	size += snprintf(buf + size, PAGE_SIZE - size,
+			 "	yaddr 0x%x uvaddr 0x%x\n",
+		win->area[0].y_addr, win->area[0].uv_addr);
+	return size;
+}
+
+static int rk3036_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						struct lcdc_device,
+						driver);
+	int *cbase = (int *)lcdc_dev->regs;
+	int *regsbak = (int *)lcdc_dev->regsbak;
+	int i, j;
+
+	dev_info(dev_drv->dev, "back up reg:\n");
+	for (i = 0; i <= (0xDC >> 4); i++) {
+		for (j = 0; j < 4; j++)
+			dev_info(dev_drv->dev, "%08x  ",
+				 *(regsbak + i * 4 + j));
+		dev_info(dev_drv->dev, "\n");
+	}
+
+	dev_info(dev_drv->dev, "lcdc reg:\n");
+	for (i = 0; i <= (0xDC >> 4); i++) {
+		for (j = 0; j < 4; j++)
+			dev_info(dev_drv->dev, "%08x  ",
+				 readl_relaxed(cbase + i * 4 + j));
+		dev_info(dev_drv->dev, "\n");
+	}
+	return 0;
+}
+
+static struct rk_lcdc_drv_ops lcdc_drv_ops = {
+	.open			= rk3036_lcdc_open,
+	.load_screen		= rk3036_load_screen,
+	.set_par		= rk3036_lcdc_set_par,
+	.pan_display		= rk3036_lcdc_pan_display,
+	.blank			= rk3036_lcdc_blank,
+	.ioctl			= rk3036_lcdc_ioctl,
+	.get_win_state		= rk3036_lcdc_get_win_state,
+	.ovl_mgr		= rk3036_lcdc_ovl_mgr,
+	.get_disp_info		= rk3036_lcdc_get_disp_info,
+	.fps_mgr		= rk3036_lcdc_fps_mgr,
+	.fb_get_win_id		= rk3036_lcdc_get_win_id,
+	.fb_win_remap		= rk3036_fb_win_remap,
+	.poll_vblank		= rk3036_lcdc_poll_vblank,
+	.get_dsp_addr		= rk3036_lcdc_get_dsp_addr,
+	.cfg_done		= rk3036_lcdc_cfg_done,
+	.dump_reg		= rk3036_lcdc_reg_dump,
+	.set_dsp_bcsh_hue	= rk3036_lcdc_set_bcsh_hue,
+	.set_dsp_bcsh_bcs	= rk3036_lcdc_set_bcsh_bcs,
+	.get_dsp_bcsh_hue	= rk3036_lcdc_get_bcsh_hue,
+	.get_dsp_bcsh_bcs	= rk3036_lcdc_get_bcsh_bcs,
+	.open_bcsh		= rk3036_lcdc_open_bcsh,
+	.set_overscan		= rk3036_lcdc_set_overscan,
+	.set_hwc_lut		= rk3036_lcdc_set_hwc_lut,
+};
+
+static int rk3036_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
+{
+	struct device_node *np = lcdc_dev->dev->of_node;
+	int val;
+
+	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
+		lcdc_dev->driver.iommu_enabled = 0;
+	else
+		lcdc_dev->driver.iommu_enabled = val;
+	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
+		lcdc_dev->driver.fb_win_map = FB_DEFAULT_ORDER;
+	else
+		lcdc_dev->driver.fb_win_map = val;
+
+	return 0;
+}
+
+static int rk3036_lcdc_probe(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = NULL;
+	struct rk_lcdc_driver *dev_drv;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int ret;
+
+	lcdc_dev = devm_kzalloc(dev,
+				sizeof(struct lcdc_device), GFP_KERNEL);
+	if (!lcdc_dev) {
+		dev_err(&pdev->dev, "rk3036 lcdc device kmalloc fail!");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->dev = dev;
+	rk3036_lcdc_parse_dt(lcdc_dev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+	lcdc_dev->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lcdc_dev->regs))
+		return PTR_ERR(lcdc_dev->regs);
+
+	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
+	if (IS_ERR(lcdc_dev->regsbak))
+		return PTR_ERR(lcdc_dev->regsbak);
+
+	lcdc_dev->hwc_lut_addr_base = (lcdc_dev->regs + HWC_LUT_ADDR);
+	lcdc_dev->prop = PRMRY;
+	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
+	dev_drv = &lcdc_dev->driver;
+	dev_drv->dev = dev;
+	dev_drv->prop = PRMRY;
+	dev_drv->id = lcdc_dev->id;
+	dev_drv->ops = &lcdc_drv_ops;
+	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
+	spin_lock_init(&lcdc_dev->reg_lock);
+
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if (lcdc_dev->irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
+			lcdc_dev->id);
+		return -ENXIO;
+	}
+
+	ret = devm_request_irq(dev, lcdc_dev->irq, rk3036_lcdc_isr,
+			       IRQF_DISABLED | IRQF_SHARED,
+			       dev_name(dev), lcdc_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
+			lcdc_dev->irq, ret);
+		return ret;
+	}
+
+	if (dev_drv->iommu_enabled)
+		strcpy(dev_drv->mmu_dts_name, VOP_IOMMU_COMPATIBLE_NAME);
+
+	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
+	if (ret < 0) {
+		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
+		return ret;
+	}
+	lcdc_dev->screen = dev_drv->screen0;
+
+	dev_info(dev, "lcdc probe ok, iommu %s\n",
+		 dev_drv->iommu_enabled ? "enabled" : "disabled");
+
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+static int rk3036_lcdc_suspend(struct platform_device *pdev,
+			       pm_message_t state)
+{
+	return 0;
+}
+
+static int rk3036_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define rk3036_lcdc_suspend NULL
+#define rk3036_lcdc_resume  NULL
+#endif
+
+static int rk3036_lcdc_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void rk3036_lcdc_shutdown(struct platform_device *pdev)
+{
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk3036_lcdc_dt_ids[] = {
+	{.compatible = "rockchip,rk3036-lcdc",},
+	{}
+};
+#endif
+
+static struct platform_driver rk3036_lcdc_driver = {
+	.probe = rk3036_lcdc_probe,
+	.remove = rk3036_lcdc_remove,
+	.driver = {
+		.name = "rk3036-lcdc",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(rk3036_lcdc_dt_ids),
+	},
+	.suspend = rk3036_lcdc_suspend,
+	.resume = rk3036_lcdc_resume,
+	.shutdown = rk3036_lcdc_shutdown,
+};
+
+static int __init rk3036_lcdc_module_init(void)
+{
+	return platform_driver_register(&rk3036_lcdc_driver);
+}
+
+static void __exit rk3036_lcdc_module_exit(void)
+{
+	platform_driver_unregister(&rk3036_lcdc_driver);
+}
+
+fs_initcall(rk3036_lcdc_module_init);
+module_exit(rk3036_lcdc_module_exit);
diff -Nupr a/drivers/video/rockchip/lcdc/rk3036_lcdc.h b/drivers/video/rockchip/lcdc/rk3036_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk3036_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3036_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,578 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RK3036_LCDC_H_
+#define _RK3036_LCDC_H_
+
+#include<linux/rk_fb.h>
+#include<linux/io.h>
+#include<linux/clk.h>
+
+/*******************register definition**********************/
+
+#define SYS_CTRL		(0x00)
+	#define m_WIN0_EN		(1<<0)
+	#define m_WIN1_EN		(1<<1)
+	#define m_HWC_EN		(1<<2)
+	#define m_WIN0_FORMAT		(7<<3)
+	#define m_WIN1_FORMAT		(7<<6)
+	#define m_HWC_LUT_EN		(1<<9)
+	#define m_HWC_SIZE		(1<<10)
+	#define m_WIN0_RB_SWAP		(1<<15)
+	#define m_WIN0_ALPHA_SWAP	(1<<16)
+	#define m_WIN0_Y8_SWAP		(1<<17)
+	#define m_WIN0_UV_SWAP		(1<<18)
+	#define m_WIN1_RB_SWAP		(1<<19)
+	#define m_WIN1_ALPHA_SWAP	(1<<20)
+	#define m_WIN0_OTSD_DISABLE	(1<<22)
+	#define m_WIN1_OTSD_DISABLE	(1<<23)
+	#define m_DMA_BURST_LENGTH	(3<<24)
+	#define m_HWC_LODAD_EN		(1<<26)
+	#define m_DMA_STOP		(1<<29)
+	#define m_LCDC_STANDBY		(1<<30)
+	#define m_AUTO_GATING_EN	(1<<31)
+
+	#define v_WIN0_EN(x)		(((x)&1)<<0)
+	#define v_WIN1_EN(x)		(((x)&1)<<1)
+	#define v_HWC_EN(x)		(((x)&1)<<2)
+	#define v_WIN0_FORMAT(x)	(((x)&7)<<3)
+	#define v_WIN1_FORMAT(x)	(((x)&7)<<6)
+	#define v_HWC_LUT_EN(x)		(((x)&1)<<9)
+	#define v_HWC_SIZE(x)		(((x)&1)<<10)
+	#define v_WIN0_RB_SWAP(x)	(((x)&1)<<15)
+	#define v_WIN0_ALPHA_SWAP(x)	(((x)&1)<<16)
+	#define v_WIN0_Y8_SWAP(x)	(((x)&1)<<17)
+	#define v_WIN0_UV_SWAP(x)	(((x)&1)<<18)
+	#define v_WIN1_RB_SWAP(x)	(((x)&1)<<19)
+	#define v_WIN1_ALPHA_SWAP(x)	(((x)&1)<<20)
+	#define v_WIN0_OTSD_DISABLE(x)	(((x)&1)<<22)
+	#define v_WIN1_OTSD_DISABLE(x)	(((x)&1)<<23)
+	#define v_DMA_BURST_LENGTH(x)	(((x)&3)<<24)
+	#define v_HWC_LODAD_EN(x)	(((x)&1)<<26)
+	#define v_WIN1_LUT_EN(x)	(((x)&1)<<27)
+	#define v_DMA_STOP(x)		(((x)&1)<<29)
+	#define v_LCDC_STANDBY(x)	(((x)&1)<<30)
+	#define v_AUTO_GATING_EN(x)	(((x)&1)<<31)
+
+#define DSP_CTRL0		(0x04)
+	#define m_DSP_OUT_FORMAT	(0x0f<<0)
+	#define m_HSYNC_POL		(1<<4)
+	#define m_VSYNC_POL		(1<<5)
+	#define m_DEN_POL		(1<<6)
+	#define m_DCLK_POL		(1<<7)
+	#define m_WIN0_TOP		(1<<8)
+	#define m_DITHER_UP_EN		(1<<9)
+	#define m_INTERLACE_DSP_EN	(1<<12)
+	#define m_INTERLACE_DSP_POL	(1<<13)
+	#define m_WIN0_INTERLACE_EN	(1<<14)
+	#define m_WIN1_INTERLACE_EN	(1<<15)
+	#define m_WIN0_YRGB_DEFLICK_EN	(1<<16)
+	#define m_WIN0_CBR_DEFLICK_EN	(1<<17)
+	#define m_WIN0_ALPHA_MODE	(1<<18)
+	#define m_WIN1_ALPHA_MODE	(1<<19)
+	#define m_WIN0_CSC_MODE		(3<<20)
+	#define m_WIN0_YUV_CLIP		(1<<23)
+	#define m_TVE_MODE		(1<<25)
+	#define m_HWC_ALPHA_MODE	(1<<28)
+	#define m_PREMUL_ALPHA_ENABLE	(1<<29)
+	#define m_ALPHA_MODE_SEL1	(1<<30)
+	#define m_WIN1_DIFF_DCLK_EN	(1<<31)
+
+	#define v_DSP_OUT_FORMAT(x)	(((x)&0x0f)<<0)
+	#define v_HSYNC_POL(x)		(((x)&1)<<4)
+	#define v_VSYNC_POL(x)		(((x)&1)<<5)
+	#define v_DEN_POL(x)		(((x)&1)<<6)
+	#define v_DCLK_POL(x)		(((x)&1)<<7)
+	#define v_WIN0_TOP(x)		(((x)&1)<<8)
+	#define v_DITHER_UP_EN(x)	(((x)&1)<<9)
+	#define v_INTERLACE_DSP_EN(x)	(((x)&1)<<12)
+	#define v_INTERLACE_DSP_POL(x)	(((x)&1)<<13)
+	#define v_WIN0_INTERLACE_EN(x)	(((x)&1)<<14)
+	#define v_WIN1_INTERLACE_EN(x)	(((x)&1)<<15)
+	#define v_WIN0_YRGB_DEFLICK_EN(x)	(((x)&1)<<16)
+	#define v_WIN0_CBR_DEFLICK_EN(x)	(((x)&1)<<17)
+	#define v_WIN0_ALPHA_MODE(x)		(((x)&1)<<18)
+	#define v_WIN1_ALPHA_MODE(x)		(((x)&1)<<19)
+	#define v_WIN0_CSC_MODE(x)		(((x)&3)<<20)
+	#define v_WIN0_YUV_CLIP(x)		(((x)&1)<<23)
+	#define v_TVE_MODE(x)			(((x)&1)<<25)
+	#define v_HWC_ALPHA_MODE(x)		(((x)&1)<<28)
+	#define v_PREMUL_ALPHA_ENABLE(x)	(((x)&1)<<29)
+	#define v_ALPHA_MODE_SEL1(x)		(((x)&1)<<30)
+	#define v_WIN1_DIFF_DCLK_EN(x)		(((x)&1)<<31)
+
+#define DSP_CTRL1		(0x08)
+	#define m_BG_COLOR		(0xffffff<<0)
+	#define m_BG_B			(0xff<<0)
+	#define m_BG_G			(0xff<<8)
+	#define m_BG_R			(0xff<<16)
+	#define m_BLANK_EN		(1<<24)
+	#define m_BLACK_EN		(1<<25)
+	#define m_DSP_BG_SWAP		(1<<26)
+	#define m_DSP_RB_SWAP		(1<<27)
+	#define m_DSP_RG_SWAP		(1<<28)
+	#define m_DSP_DELTA_SWAP	(1<<29)
+	#define m_DSP_DUMMY_SWAP	(1<<30)
+	#define m_DSP_OUT_ZERO		(1<<31)
+
+	#define v_BG_COLOR(x)		(((x)&0xffffff)<<0)
+	#define v_BG_B(x)		(((x)&0xff)<<0)
+	#define v_BG_G(x)		(((x)&0xff)<<8)
+	#define v_BG_R(x)		(((x)&0xff)<<16)
+	#define v_BLANK_EN(x)		(((x)&1)<<24)
+	#define v_BLACK_EN(x)		(((x)&1)<<25)
+	#define v_DSP_BG_SWAP(x)	(((x)&1)<<26)
+	#define v_DSP_RB_SWAP(x)	(((x)&1)<<27)
+	#define v_DSP_RG_SWAP(x)	(((x)&1)<<28)
+	#define v_DSP_DELTA_SWAP(x)	(((x)&1)<<29)
+	#define v_DSP_DUMMY_SWAP(x)	(((x)&1)<<30)
+	#define v_DSP_OUT_ZERO(x)	(((x)&1)<<31)
+
+#define INT_STATUS		(0x10)
+	#define m_HS_INT_STA		(1<<0) /* status */
+	#define m_FS_INT_STA		(1<<1)
+	#define m_LF_INT_STA		(1<<2)
+	#define m_BUS_ERR_INT_STA	(1<<3)
+	#define m_HS_INT_EN		(1<<4) /* enable */
+	#define m_FS_INT_EN		(1<<5)
+	#define m_LF_INT_EN		(1<<6)
+	#define m_BUS_ERR_INT_EN	(1<<7)
+	#define m_HS_INT_CLEAR		(1<<8) /* auto clear*/
+	#define m_FS_INT_CLEAR		(1<<9)
+	#define m_LF_INT_CLEAR		(1<<10)
+	#define m_BUS_ERR_INT_CLEAR	(1<<11)
+	#define m_LF_INT_NUM		(0xfff<<12)
+	#define m_WIN0_EMPTY_INT_EN	(1<<24)
+	#define m_WIN1_EMPTY_INT_EN	(1<<25)
+	#define m_WIN0_EMPTY_INT_CLEAR	(1<<26)
+	#define m_WIN1_EMPTY_INT_CLEAR	(1<<27)
+	#define m_WIN0_EMPTY_INT_STA	(1<<28)
+	#define m_WIN1_EMPTY_INT_STA	(1<<29)
+	#define m_FS_RAW_STA		(1<<30)
+	#define m_LF_RAW_STA		(1<<31)
+
+	#define v_HS_INT_EN(x)			(((x)&1)<<4)
+	#define v_FS_INT_EN(x)			(((x)&1)<<5)
+	#define v_LF_INT_EN(x)			(((x)&1)<<6)
+	#define v_BUS_ERR_INT_EN(x)		(((x)&1)<<7)
+	#define v_HS_INT_CLEAR(x)		(((x)&1)<<8)
+	#define v_FS_INT_CLEAR(x)		(((x)&1)<<9)
+	#define v_LF_INT_CLEAR(x)		(((x)&1)<<10)
+	#define v_BUS_ERR_INT_CLEAR(x)		(((x)&1)<<11)
+	#define v_LF_INT_NUM(x)			(((x)&0xfff)<<12)
+	#define v_WIN0_EMPTY_INT_EN(x)		(((x)&1)<<24)
+	#define v_WIN1_EMPTY_INT_EN(x)		(((x)&1)<<25)
+	#define v_WIN0_EMPTY_INT_CLEAR(x)	(((x)&1)<<26)
+	#define v_WIN1_EMPTY_INT_CLEAR(x)	(((x)&1)<<27)
+
+
+#define ALPHA_CTRL		(0x14)
+	#define m_WIN0_ALPHA_EN		(1<<0)
+	#define m_WIN1_ALPHA_EN		(1<<1)
+	#define m_HWC_ALPAH_EN		(1<<2)
+	#define m_WIN1_PREMUL_SCALE	(1<<3)
+	#define m_WIN0_ALPHA_VAL	(0xff<<4)
+	#define m_WIN1_ALPHA_VAL	(0xff<<12)
+	#define m_HWC_ALPAH_VAL		(0xff<<20)
+
+	#define v_WIN0_ALPHA_EN(x)	(((x)&1)<<0)
+	#define v_WIN1_ALPHA_EN(x)	(((x)&1)<<1)
+	#define v_HWC_ALPAH_EN(x)	(((x)&1)<<2)
+	#define v_WIN1_PREMUL_SCALE(x)	(((x)&1)<<3)
+	#define v_WIN0_ALPHA_VAL(x)	(((x)&0xff)<<4)
+	#define v_WIN1_ALPHA_VAL(x)	(((x)&0xff)<<12)
+	#define v_HWC_ALPAH_VAL(x)	(((x)&0xff)<<20)
+
+#define WIN0_COLOR_KEY		(0x18)
+#define WIN1_COLOR_KEY		(0x1C)
+	#define m_COLOR_KEY_VAL		(0xffffff<<0)
+	#define m_COLOR_KEY_EN		(1<<24)
+	#define v_COLOR_KEY_VAL(x)	(((x)&0xffffff)<<0)
+	#define v_COLOR_KEY_EN(x)	(((x)&1)<<24)
+
+/* Layer Registers */
+#define WIN0_YRGB_MST		(0x20)
+#define WIN0_CBR_MST		(0x24)
+#define WIN1_MST		(0xa0)
+#define HWC_MST			(0x58)
+
+#define WIN1_VIR		(0x28)
+#define WIN0_VIR		(0x30)
+	#define m_YRGB_VIR	(0x1fff << 0)
+	#define m_CBBR_VIR	(0x1fff << 16)
+
+	#define v_YRGB_VIR(x)	((x & 0x1fff) << 0)
+	#define v_CBBR_VIR(x)	((x & 0x1fff) << 16)
+
+	#define v_ARGB888_VIRWIDTH(x)	(((x) & 0x1fff) << 0)
+	#define v_RGB888_VIRWIDTH(x)	(((((x * 3) >> 2)+(x % 3))&0x1fff)<<0)
+	#define v_RGB565_VIRWIDTH(x)	((DIV_ROUND_UP(x, 2)&0x1fff)<<0)
+	#define v_YUV_VIRWIDTH(x)	((DIV_ROUND_UP(x, 4)&0x1fff)<<0)
+	#define v_CBCR_VIR(x)		((x & 0x1fff) << 16)
+
+#define WIN0_ACT_INFO		(0x34)
+#define WIN1_ACT_INFO		(0xB4)
+	#define m_ACT_WIDTH		(0x1fff << 0)
+	#define m_ACT_HEIGHT		(0x1fff << 16)
+	#define v_ACT_WIDTH(x)		(((x-1) & 0x1fff)<<0)
+	#define v_ACT_HEIGHT(x)		(((x-1) & 0x1fff)<<16)
+
+#define WIN0_DSP_INFO		(0x38)
+#define WIN1_DSP_INFO		(0xB8)
+	#define v_DSP_WIDTH(x)		(((x-1)&0x7ff)<<0)
+	#define v_DSP_HEIGHT(x)		(((x-1)&0x7ff)<<16)
+
+#define WIN0_DSP_ST		(0x3C)
+#define WIN1_DSP_ST		(0xBC)
+#define HWC_DSP_ST		(0x5C)
+	#define v_DSP_STX(x)		(((x)&0xfff)<<0)
+	#define v_DSP_STY(x)		(((x)&0xfff)<<16)
+
+#define WIN0_SCL_FACTOR_YRGB	(0x40)
+#define WIN0_SCL_FACTOR_CBR	(0x44)
+#define WIN1_SCL_FACTOR_YRGB	(0xC0)
+	#define v_X_SCL_FACTOR(x)	(((x)&0xffff)<<0)
+	#define v_Y_SCL_FACTOR(x)	(((x)&0xffff)<<16)
+
+#define WIN0_SCL_OFFSET		(0x48)
+#define WIN1_SCL_OFFSET		(0xC8)
+
+/* LUT Registers */
+#define WIN1_LUT_ADDR			(0x0400)
+#define HWC_LUT_ADDR			(0x0800)
+
+/* Display Infomation Registers */
+#define DSP_HTOTAL_HS_END	(0x6C)
+	/*hsync pulse width*/
+	#define v_HSYNC(x)		(((x)&0xfff)<<0)
+	/*horizontal period*/
+	#define v_HORPRD(x)		(((x)&0xfff)<<16)
+
+#define DSP_HACT_ST_END		(0x70)
+	/*horizontal active end point*/
+	#define v_HAEP(x)		(((x)&0xfff)<<0)
+	/*horizontal active start point*/
+	#define v_HASP(x)		(((x)&0xfff)<<16)
+
+#define DSP_VTOTAL_VS_END	(0x74)
+	#define v_VSYNC(x)		(((x)&0xfff)<<0)
+	#define v_VERPRD(x)		(((x)&0xfff)<<16)
+
+#define DSP_VACT_ST_END		(0x78)
+	#define v_VAEP(x)		(((x)&0xfff)<<0)
+	#define v_VASP(x)		(((x)&0xfff)<<16)
+
+#define DSP_VS_ST_END_F1	(0x7C)
+	#define v_VSYNC_END_F1(x)	(((x)&0xfff)<<0)
+	#define v_VSYNC_ST_F1(x)	(((x)&0xfff)<<16)
+#define DSP_VACT_ST_END_F1	(0x80)
+
+/*BCSH Registers*/
+#define BCSH_CTRL			(0xD0)
+	#define m_BCSH_EN		(1 << 0)
+	#define m_BCSH_OUT_MODE		(3 << 2)
+	#define m_BCSH_CSC_MODE		(3 << 4)
+
+	#define v_BCSH_EN(x)		((1 & x) << 0)
+	#define v_BCSH_OUT_MODE(x)	((3 & x) << 2)
+	#define v_BCSH_CSC_MODE(x)	((3 & x) << 4)
+
+#define BCSH_COLOR_BAR			(0xD4)
+	#define v_BCSH_COLOR_BAR_Y(x)		(((x)&0xf) << 0)
+	#define v_BCSH_COLOR_BAR_U(x)		(((x)&0xf) << 8)
+	#define v_BCSH_COLOR_BAR_V(x)		(((x)&0xf) << 16)
+
+	#define m_BCSH_COLOR_BAR_Y		(0xf << 0)
+	#define m_BCSH_COLOR_BAR_U		(0xf << 8)
+	#define m_BCSH_COLOR_BAR_V		(0xf << 16)
+
+#define BCSH_BCS			(0xD8)
+	#define v_BCSH_BRIGHTNESS(x)		(((x)&0x3f) << 0)
+	#define v_BCSH_CONTRAST(x)		(((x)&0xff) << 8)
+	#define v_BCSH_SAT_CON(x)		(((x)&0x1ff) << 16)
+
+	#define m_BCSH_BRIGHTNESS		(0x3f << 0)
+	#define m_BCSH_CONTRAST			(0xff << 8)
+	#define m_BCSH_SAT_CON			(0x1ff << 16)
+
+#define BCSH_H				(0xDC)
+	#define v_BCSH_SIN_HUE(x)		(((x)&0xff) << 0)
+	#define v_BCSH_COS_HUE(x)		(((x)&0xff) << 8)
+
+	#define m_BCSH_SIN_HUE			(0xff << 0)
+	#define m_BCSH_COS_HUE			(0xff << 8)
+
+/* Bus Register */
+#define AXI_BUS_CTRL		(0x2C)
+	#define m_IO_PAD_CLK			(1 << 31)
+	#define m_CORE_CLK_DIV_EN		(1 << 30)
+	#define m_HDMI_DCLK_INVERT		(1 << 23)
+	#define m_HDMI_DCLK_EN			(1 << 22)
+	#define m_TVE_DAC_DCLK_INVERT		(1 << 21)
+	#define m_TVE_DAC_DCLK_EN		(1 << 20)
+	#define m_HDMI_DCLK_DIV_EN		(1 << 19)
+	#define m_AXI_OUTSTANDING_MAX_NUM	(0x1f << 12)
+	#define m_AXI_MAX_OUTSTANDING_EN	(1 << 11)
+	#define m_MMU_EN			(1 << 10)
+	#define m_NOC_HURRY_THRESHOLD		(0xf << 6)
+	#define m_NOC_HURRY_VALUE		(3 << 4)
+	#define m_NOC_HURRY_EN			(1 << 3)
+	#define m_NOC_QOS_VALUE			(3 << 1)
+	#define m_NOC_QOS_EN			(1 << 0)
+
+	#define v_IO_PAD_CLK(x)			((x&1) << 31)
+	#define v_CORE_CLK_DIV_EN(x)		((x&1) << 30)
+	#define v_HDMI_DCLK_INVERT(x)		((x&1) << 23)
+	#define v_HDMI_DCLK_EN(x)		((x&1) << 22)
+	#define v_TVE_DAC_DCLK_INVERT(x)	((x&1) << 21)
+	#define v_TVE_DAC_DCLK_EN(x)		((x&1) << 20)
+	#define v_HDMI_DCLK_DIV_EN(x)		((x&1) << 19)
+	#define v_AXI_OUTSTANDING_MAX_NUM(x)	((x&0x1f) << 12)
+	#define v_AXI_MAX_OUTSTANDING_EN(x)	((x&1) << 11)
+	#define v_MMU_EN(x)			((x&1) << 10)
+	#define v_NOC_HURRY_THRESHOLD(x)	((x&0xf) << 6)
+	#define v_NOC_HURRY_VALUE(x)		((x&3) << 4)
+	#define v_NOC_HURRY_EN(x)		((x&1) << 3)
+	#define v_NOC_QOS_VALUE(x)		((x&3) << 1)
+	#define v_NOC_QOS_EN(x)			((x&1) << 0)
+
+#define GATHER_TRANSFER		(0x84)
+	#define m_WIN1_AXI_GATHER_NUM		(0xf << 12)
+	#define m_WIN0_CBCR_AXI_GATHER_NUM	(0x7 << 8)
+	#define m_WIN0_YRGB_AXI_GATHER_NUM	(0xf << 4)
+	#define m_WIN1_AXI_GAHTER_EN		(1 << 2)
+	#define m_WIN0_CBCR_AXI_GATHER_EN	(1 << 1)
+	#define m_WIN0_YRGB_AXI_GATHER_EN	(1 << 0)
+
+	#define v_WIN1_AXI_GATHER_NUM(x)	((x & 0xf) << 12)
+	#define v_WIN0_CBCR_AXI_GATHER_NUM(x)	((x & 0x7) << 8)
+	#define v_WIN0_YRGB_AXI_GATHER_NUM(x)	((x & 0xf) << 4)
+	#define v_WIN1_AXI_GAHTER_EN(x)		((x & 1) << 2)
+	#define v_WIN0_CBCR_AXI_GATHER_EN(x)	((x & 1) << 1)
+	#define v_WIN0_YRGB_AXI_GATHER_EN(x)	((x & 1) << 0)
+
+#define VERSION_INFO		(0x94)
+	#define m_MAJOR		(0xff << 24)
+	#define m_MINOR		(0xff << 16)
+	#define m_BUILD		(0xffff)
+
+#define REG_CFG_DONE		(0x90)
+
+/* TV Control Registers */
+#define TV_CTRL			(0x200)
+#define TV_SYNC_TIMING		(0x204)
+#define TV_ACT_TIMING		(0x208)
+#define TV_ADJ_TIMING		(0x20c)
+#define TV_FREQ_SC		(0x210)
+#define TV_FILTER0		(0x214)
+#define TV_FILTER1		(0x218)
+#define TV_FILTER2		(0x21C)
+#define TV_ACT_ST		(0x234)
+#define TV_ROUTING		(0x238)
+#define TV_SYNC_ADJUST		(0x250)
+#define TV_STATUS		(0x254)
+#define TV_RESET		(0x268)
+#define TV_SATURATION		(0x278)
+#define TV_BW_CTRL		(0x28C)
+#define TV_BRIGHTNESS_CONTRAST	(0x290)
+
+
+/* MMU registers */
+#define MMU_DTE_ADDR			(0x0300)
+	#define v_MMU_DTE_ADDR(x)		(((x)&0xffffffff)<<0)
+	#define m_MMU_DTE_ADDR			(0xffffffff<<0)
+
+#define MMU_STATUS			(0x0304)
+	#define v_PAGING_ENABLED(x)		(((x)&1)<<0)
+	#define v_PAGE_FAULT_ACTIVE(x)		(((x)&1)<<1)
+	#define v_STAIL_ACTIVE(x)		(((x)&1)<<2)
+	#define v_MMU_IDLE(x)			(((x)&1)<<3)
+	#define v_REPLAY_BUFFER_EMPTY(x)	(((x)&1)<<4)
+	#define v_PAGE_FAULT_IS_WRITE(x)	(((x)&1)<<5)
+	#define v_PAGE_FAULT_BUS_ID(x)		(((x)&0x1f)<<6)
+	#define m_PAGING_ENABLED		(1<<0)
+	#define m_PAGE_FAULT_ACTIVE		(1<<1)
+	#define m_STAIL_ACTIVE			(1<<2)
+	#define m_MMU_IDLE			(1<<3)
+	#define m_REPLAY_BUFFER_EMPTY		(1<<4)
+	#define m_PAGE_FAULT_IS_WRITE		(1<<5)
+	#define m_PAGE_FAULT_BUS_ID		(0x1f<<6)
+
+#define MMU_COMMAND			(0x0308)
+	#define v_MMU_CMD(x)			(((x)&0x3)<<0)
+	#define m_MMU_CMD			(0x3<<0)
+
+#define MMU_PAGE_FAULT_ADDR		(0x030c)
+	#define v_PAGE_FAULT_ADDR(x)		(((x)&0xffffffff)<<0)
+	#define m_PAGE_FAULT_ADDR		(0xffffffff<<0)
+
+#define MMU_ZAP_ONE_LINE		(0x0310)
+	#define v_MMU_ZAP_ONE_LINE(x)		(((x)&0xffffffff)<<0)
+	#define m_MMU_ZAP_ONE_LINE		(0xffffffff<<0)
+
+#define MMU_INT_RAWSTAT			(0x0314)
+	#define v_PAGE_FAULT_RAWSTAT(x)		(((x)&1)<<0)
+	#define v_READ_BUS_ERROR_RAWSTAT(x)	(((x)&1)<<1)
+	#define m_PAGE_FAULT_RAWSTAT		(1<<0)
+	#define m_READ_BUS_ERROR_RAWSTAT	(1<<1)
+
+#define MMU_INT_CLEAR			(0x0318)
+	#define v_PAGE_FAULT_CLEAR(x)		(((x)&1)<<0)
+	#define v_READ_BUS_ERROR_CLEAR(x)	(((x)&1)<<1)
+	#define m_PAGE_FAULT_CLEAR		(1<<0)
+	#define m_READ_BUS_ERROR_CLEAR		(1<<1)
+
+#define MMU_INT_MASK			(0x031c)
+	#define v_PAGE_FAULT_MASK(x)		(((x)&1)<<0)
+	#define v_READ_BUS_ERROR_MASK(x)	(((x)&1)<<1)
+	#define m_PAGE_FAULT_MASK		(1<<0)
+	#define m_READ_BUS_ERROR_MASK		(1<<1)
+
+#define MMU_INT_STATUS			(0x0320)
+	#define v_PAGE_FAULT_STATUS(x)		(((x)&1)<<0)
+	#define v_READ_BUS_ERROR_STATUS(x)	(((x)&1)<<1)
+	#define m_PAGE_FAULT_STATUS		(1<<0)
+	#define m_READ_BUS_ERROR_STATUS		(1<<1)
+
+#define MMU_AUTO_GATING			(0x0324)
+	#define v_MMU_AUTO_GATING(x)		(((x)&1)<<0)
+	#define m_MMU_AUTO_GATING		(1<<0)
+
+enum _vop_dma_burst {
+	DMA_BURST_16 = 0,
+	DMA_BURST_8,
+	DMA_BURST_4
+};
+
+enum _vop_format_e {
+	VOP_FORMAT_ARGB888 = 0,
+	VOP_FORMAT_RGB888,
+	VOP_FORMAT_RGB565,
+	VOP_FORMAT_YCBCR420 = 4,
+	VOP_FORMAT_YCBCR422,
+	VOP_FORMAT_YCBCR444
+};
+
+enum _vop_tv_mode {
+	TV_NTSC,
+	TV_PAL,
+};
+
+enum _vop_csc_mode {
+	VOP_CSC_BT601 = 0,
+	VOP_CSC_JPEG,
+	VOP_CSC_BT709
+};
+
+enum _vop_hwc_size {
+	VOP_HWC_SIZE_32,
+	VOP_HWC_SIZE_64
+};
+
+#define calscale(x, y)		((((u32)(x-1))*0x1000)/(y-1))
+
+struct lcdc_device {
+	int id;
+	struct rk_lcdc_driver driver;
+	struct device *dev;
+	struct rk_screen *screen;
+
+	void __iomem *regs;
+	void *regsbak;		/* back up reg */
+	u32 reg_phy_base;	/* physical basic address of lcdc register*/
+	u32 len;		/* physical map length of lcdc register*/
+	spinlock_t  reg_lock;	/* one time only one process allowed to
+				   config the register*/
+
+	int __iomem *hwc_lut_addr_base;
+	int __iomem *dsp_lut_addr_base;
+
+
+	int prop;			/*used for primary or */
+					/*extended display device*/
+	bool pre_init;
+	bool pwr18;			/*if lcdc use 1.8v power supply*/
+	bool clk_on;			/*if aclk or hclk is closed,
+					  acess to register is not allowed*/
+	u8 atv_layer_cnt;		/*active layer counter, when
+					  atv_layer_cnt = 0,disable lcdc*/
+
+	unsigned int		irq;
+
+	struct clk		*pd;	/*lcdc power domain*/
+	struct clk		*hclk;	/*lcdc AHP clk*/
+	struct clk		*dclk;	/*lcdc dclk*/
+	struct clk		*aclk;	/*lcdc share memory frequency*/
+	u32 pixclock;
+
+	u32 standby;			/*1:standby,0:work*/
+	u32 iommu_status;
+};
+
+static inline
+void lcdc_writel(struct lcdc_device *lcdc_dev, u32 offset, u32 v)
+{
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	*_pv = v;
+	writel_relaxed(v, lcdc_dev->regs + offset);
+}
+
+static inline
+u32 lcdc_readl(struct lcdc_device *lcdc_dev, u32 offset)
+{
+	u32 v;
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	v = readl_relaxed(lcdc_dev->regs + offset);
+	*_pv = v;
+	return v;
+}
+
+static inline
+u32 lcdc_read_bit(struct lcdc_device *lcdc_dev, u32 offset, u32 msk)
+{
+	u32 _v = readl_relaxed(lcdc_dev->regs + offset);
+
+	_v &= msk;
+	return _v ? 1 : 0;
+}
+
+static inline
+void  lcdc_set_bit(struct lcdc_device *lcdc_dev, u32 offset, u32 msk)
+{
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) |= msk;
+	writel_relaxed(*_pv, lcdc_dev->regs + offset);
+}
+
+static inline
+void lcdc_clr_bit(struct lcdc_device *lcdc_dev, u32 offset, u32 msk)
+{
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) &= (~msk);
+	writel_relaxed(*_pv, lcdc_dev->regs + offset);
+}
+
+static inline
+void  lcdc_msk_reg(struct lcdc_device *lcdc_dev, u32 offset, u32 msk, u32 v)
+{
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) &= (~msk);
+	(*_pv) |= v;
+	writel_relaxed(*_pv, lcdc_dev->regs + offset);
+}
+
+static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev)
+{
+	writel_relaxed(0x01, lcdc_dev->regs + REG_CFG_DONE);
+	dsb();
+}
+
+#endif /* _RK3036_LCDC_H_ */
diff -Nupr a/drivers/video/rockchip/lcdc/rk3066b_lcdc.c b/drivers/video/rockchip/lcdc/rk3066b_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk3066b_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3066b_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1519 @@
+/*
+ * drivers/video/rockchip/chips/rk3066b_lcdc.c
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *Author:yzq<yzq@rock-chips.com>
+ *	yxj<yxj@rock-chips.com>
+ *This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/earlysuspend.h>
+#include <asm/div64.h>
+#include <asm/uaccess.h>
+#include <mach/iomux.h>
+
+#include "rk3066b_lcdc.h"
+#include "../hdmi/rk_hdmi.h"
+
+
+
+
+static int dbg_thresd = 0;
+module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
+#define DBG(level,x...) do { if(unlikely(dbg_thresd >= level)) printk(KERN_INFO x); } while (0)
+
+
+static int  rk3066b_lcdc_clk_enable(struct rk3066b_lcdc_device *lcdc_dev)
+{
+	if(!lcdc_dev->clk_on)
+	{
+		clk_enable(lcdc_dev->hclk);
+		clk_enable(lcdc_dev->dclk);
+		clk_enable(lcdc_dev->aclk);
+		clk_enable(lcdc_dev->pd);
+
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 1;
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	printk("rk3066b lcdc%d clk enable...\n",lcdc_dev->id);
+	
+	return 0;
+}
+
+static int rk3066b_lcdc_clk_disable(struct rk3066b_lcdc_device *lcdc_dev)
+{
+	if(lcdc_dev->clk_on)
+	{
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 0;
+		spin_unlock(&lcdc_dev->reg_lock);
+		mdelay(25);
+		clk_disable(lcdc_dev->dclk);
+		clk_disable(lcdc_dev->hclk);
+		clk_disable(lcdc_dev->aclk);
+		clk_disable(lcdc_dev->pd);
+	}
+	printk("rk3066b lcdc%d clk disable...\n",lcdc_dev->id);
+	
+	return 0;
+}
+
+static int rk3066b_lcdc_reg_resume(struct rk3066b_lcdc_device *lcdc_dev)
+{
+	memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0x9C);
+	return 0;	
+}
+
+static int init_rk3066b_lcdc(struct rk_lcdc_device_driver *dev_drv)
+{
+	int i=0;
+	int __iomem *c;
+	int v;
+
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	
+	if(lcdc_dev->id == 0) //lcdc0
+	{
+		lcdc_dev->pd = clk_get(NULL,"pd_lcdc0");
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
+	}
+	else if(lcdc_dev->id == 1)
+	{
+		lcdc_dev->pd = clk_get(NULL,"pd_lcdc1");
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc1");  
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc1");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc1");
+	}
+	else
+	{
+		printk(KERN_ERR "invalid lcdc device!\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
+    	{
+       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
+   	}
+
+	rk3066b_lcdc_clk_enable(lcdc_dev);
+	
+	if(lcdc_dev->id == 0)
+	{
+		#if defined(CONFIG_RK3066B_LCDC0_IO_18V)
+		v = 0x40004000;               //bit14: 1,1.8v;0,3.3v
+		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
+		#else
+		v = 0x40000000;              
+		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
+		#endif
+	}
+
+	if(lcdc_dev->id == 1) //iomux for lcdc1
+	{
+		#if defined(CONFIG_RK3066B_LCDC1_IO_18V)
+		v = 0x80008000;               //bit14: 1,1.8v;0,3.3v
+		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
+		#else
+		v = 0x80000000;
+		writel_relaxed(v,RK30_GRF_BASE + GRF_IO_CON4);
+		#endif
+		
+		iomux_set(LCDC1_DCLK);
+		iomux_set(LCDC1_DEN);
+		iomux_set(LCDC1_HSYNC);
+		iomux_set(LCDC1_VSYNC);
+		iomux_set(LCDC1_D0);
+		iomux_set(LCDC1_D1);
+		iomux_set(LCDC1_D2);
+		iomux_set(LCDC1_D3);
+		iomux_set(LCDC1_D4);
+		iomux_set(LCDC1_D5);
+		iomux_set(LCDC1_D6);
+		iomux_set(LCDC1_D7);
+		iomux_set(LCDC1_D8);
+		iomux_set(LCDC1_D9);
+		iomux_set(LCDC1_D10);
+		iomux_set(LCDC1_D11);
+		iomux_set(LCDC1_D12);
+		iomux_set(LCDC1_D13);
+		iomux_set(LCDC1_D14);
+		iomux_set(LCDC1_D15);
+		iomux_set(LCDC1_D16);
+		iomux_set(LCDC1_D17);
+		iomux_set(LCDC1_D18);
+		iomux_set(LCDC1_D19);
+		iomux_set(LCDC1_D20);
+		iomux_set(LCDC1_D21);
+		iomux_set(LCDC1_D22);
+		iomux_set(LCDC1_D23);
+		
+	}
+	LcdMskReg(lcdc_dev,SYS_CFG, m_LCDC_AXICLK_AUTO_ENABLE | m_W0_AXI_OUTSTANDING2 |
+		m_W1_AXI_OUTSTANDING2,v_LCDC_AXICLK_AUTO_ENABLE(1) | v_W0_AXI_OUTSTANDING2(1) |
+		v_W1_AXI_OUTSTANDING2(1));//eanble axi-clk auto gating for low power
+	 LcdWrReg(lcdc_dev,AXI_MS_ID,v_HWC_CHANNEL_ID(5) | v_WIN2_CHANNEL_ID(4) |
+	 	v_WIN1_YRGB_CHANNEL_ID(3) | v_WIN0_CBR_CHANNEL_ID(2) | 
+	 	v_WIN0_YRGB_CHANNEL_ID(1));
+	LcdMskReg(lcdc_dev, INT_STATUS,m_HOR_STARTMASK| m_FRM_STARTMASK | 
+    	      m_SCANNING_MASK, v_HOR_STARTMASK(1) | v_FRM_STARTMASK(1) | 
+    	      v_SCANNING_MASK(1));  //mask all interrupt in init
+	LcdMskReg(lcdc_dev,FIFO_WATER_MARK,m_WIN1_FIFO_FULL_LEVEL,v_WIN1_FIFO_FULL_LEVEL(0x1e0));
+	//LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
+	if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
+	{
+		LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(0));
+		LCDC_REG_CFG_DONE();
+
+		mdelay(25); //wait for dsp lut disabled
+		for(i=0;i<256;i++)
+		{
+			v = dev_drv->cur_screen->dsp_lut[i];
+			c = lcdc_dev->dsp_lut_addr_base+i;
+			writel_relaxed(v,c);
+		}
+		LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(1));//enable dsp lut
+	}
+
+	rk3066b_lcdc_clk_disable(lcdc_dev);
+	return 0;
+}
+
+static int rk3066b_lcdc_deinit(struct rk3066b_lcdc_device *lcdc_dev)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
+		LcdMskReg(lcdc_dev, INT_STATUS,m_HOR_STARTMASK| m_FRM_STARTMASK | 
+    	      		  m_SCANNING_MASK, v_HOR_STARTMASK(1) | v_FRM_STARTMASK(1) | 
+    	                  v_SCANNING_MASK(1));  //mask all interrupt in init
+		LcdSetBit(lcdc_dev,SYS_CFG,m_LCDC_STANDBY);
+		LCDC_REG_CFG_DONE();
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else   //clk already disabled 
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	mdelay(1);
+	
+	return 0;
+}
+
+static int rk3066b_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
+{
+	int ret = -EINVAL;
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	rk_screen *screen = dev_drv->cur_screen;
+	u64 ft;
+	int fps;
+	u16 face;
+	u16 mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend;
+	u16 right_margin = screen->right_margin;
+	u16 lower_margin = screen->lower_margin;
+	u16 x_res = screen->x_res, y_res = screen->y_res;
+
+	// set the rgb or mcu
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(screen->type==SCREEN_MCU)
+		{
+	    		LcdMskReg(lcdc_dev, MCU_CTRL, m_MCU_OUTPUT_SELECT,v_MCU_OUTPUT_SELECT(1));
+			// set out format and mcu timing
+	   		mcu_total  = (screen->mcu_wrperiod*150*1000)/1000000;
+	    		if(mcu_total>31)    
+				mcu_total = 31;
+	   		if(mcu_total<3)    
+				mcu_total = 3;
+	    		mcu_rwstart = (mcu_total+1)/4 - 1;
+	    		mcu_rwend = ((mcu_total+1)*3)/4 - 1;
+	    		mcu_csstart = (mcu_rwstart>2) ? (mcu_rwstart-3) : (0);
+	    		mcu_csend = (mcu_rwend>15) ? (mcu_rwend-1) : (mcu_rwend);
+
+	    		//DBG(1,">> mcu_total=%d, mcu_rwstart=%d, mcu_csstart=%d, mcu_rwend=%d, mcu_csend=%d \n",
+	        	//	mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend);
+
+			// set horizontal & vertical out timing
+		
+		    	right_margin = x_res/6; 
+			screen->pixclock = 150000000; //mcu fix to 150 MHz
+			LcdMskReg(lcdc_dev, MCU_CTRL,m_MCU_CS_ST | m_MCU_CS_END| m_MCU_RW_ST | m_MCU_RW_END |
+	             		m_MCU_WRITE_PERIOD | m_MCU_HOLDMODE_SELECT | m_MCU_HOLDMODE_FRAME_ST,
+	            		v_MCU_CS_ST(mcu_csstart) | v_MCU_CS_END(mcu_csend) | v_MCU_RW_ST(mcu_rwstart) |
+	            		v_MCU_RW_END(mcu_rwend) |  v_MCU_WRITE_PERIOD(mcu_total) |
+	            		v_MCU_HOLDMODE_SELECT((SCREEN_MCU==screen->type)?(1):(0)) | v_MCU_HOLDMODE_FRAME_ST(0));
+	
+		}
+
+		switch (screen->face)
+		{
+	        	case OUT_P565:
+	            		face = OUT_P565;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_P666:
+	            		face = OUT_P666;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_D888_P565:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_D888_P666:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_P888:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(1));
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	default:
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		face = screen->face;
+	            		break;
+		}
+
+		//use default overlay,set vsyn hsync den dclk polarity
+		LcdMskReg(lcdc_dev, DSP_CTRL0,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
+	     		m_DEN_POLARITY |m_DCLK_POLARITY,v_DISPLAY_FORMAT(face) | 
+	     		v_HSYNC_POLARITY(screen->pin_hsync) | v_VSYNC_POLARITY(screen->pin_vsync) |
+	        	v_DEN_POLARITY(screen->pin_den) | v_DCLK_POLARITY(screen->pin_dclk));
+
+		//set background color to black,set swap according to the screen panel,disable blank mode
+		LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE | m_BLACK_MODE | m_BG_COLOR, v_BLANK_MODE(0) | 
+					v_BLACK_MODE(0) | v_BG_COLOR(0x000000));
+		LcdMskReg(lcdc_dev,SWAP_CTRL,m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_DELTA_SWAP | m_DUMMY_SWAP, 
+					v_OUTPUT_RB_SWAP(screen->swap_rb) | v_OUTPUT_RG_SWAP(screen->swap_rg) | 
+		 			v_DELTA_SWAP(screen->swap_delta) | v_DUMMY_SWAP(screen->swap_dumy));
+		LcdWrReg(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
+	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
+		LcdWrReg(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
+	             v_HASP(screen->hsync_len + screen->left_margin));
+
+		LcdWrReg(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
+	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
+		LcdWrReg(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
+	              v_VASP(screen->vsync_len + screen->upper_margin));
+		// let above to take effect
+		//LCDC_REG_CFG_DONE();
+	}
+ 	spin_unlock(&lcdc_dev->reg_lock);
+
+	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
+	if(ret)
+	{
+        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+	}
+    	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	
+	
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+		(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps;
+    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk),fps);
+
+    	if(screen->init)
+    	{
+    		screen->init();
+    	}
+	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
+	return 0;
+}
+
+static int mcu_refresh(struct rk3066b_lcdc_device *lcdc_dev)
+{
+   
+    return 0;
+}
+
+
+
+//enable layer,open:1,enable;0 disable
+static int win0_open(struct rk3066b_lcdc_device *lcdc_dev,bool open)
+{
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[0]->state = open;
+		
+		LcdMskReg(lcdc_dev, SYS_CFG, m_W0_EN, v_W0_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		//LCDC_REG_CFG_DONE();	
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win0 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+static int win1_open(struct rk3066b_lcdc_device *lcdc_dev,bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				printk("lcdc%d wakeup from stanby\n",lcdc_dev->id);
+				LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[1]->state = open;
+		
+		LcdMskReg(lcdc_dev, SYS_CFG, m_W1_EN, v_W1_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
+			LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win1 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+
+
+static int rk3066b_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
+{
+	struct rk3066b_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk3066b_lcdc_device ,driver);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch(blank_mode)
+	    	{
+	    		case FB_BLANK_UNBLANK:
+	      			LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(0));
+				break;
+	    		case FB_BLANK_NORMAL:
+	         		LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+	    		default:
+				LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+		}
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	dev_info(lcdc_drv->dev,"blank mode:%d\n",blank_mode);
+	
+    	return 0;
+}
+
+static  int win0_display(struct rk3066b_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN0_YRGB_MST,y_addr);
+	    	LcdWrReg(lcdc_dev, WIN0_CBR_MST,uv_addr);
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+	
+}
+
+static  int win1_display(struct rk3066b_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN1_YRGB_MST, y_addr);
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static  int win0_set_par(struct rk3066b_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	u8 fmt_cfg =0 ; //data format register config value
+	char fmt[9] = "NULL";
+	xact = par->xact;			    //active (origin) picture window width/height		
+	yact = par->yact;
+	xvir = par->xvir;			   // virtual resolution		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+   
+	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+	
+	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
+	ScaleYrgbY = CalScale(yact, par->ysize);
+	switch (par->format)
+	{
+		case XBGR888:
+		case ABGR888:
+		case ARGB888:
+			fmt_cfg = 0;
+			break;
+		case RGB565:
+			fmt_cfg = 1;
+			break;
+		case YUV422:// yuv422
+			fmt_cfg = 2;
+			ScaleCbrX = CalScale((xact/2), par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		case YUV420: // yuv420
+			fmt_cfg = 3;
+			ScaleCbrX = CalScale(xact/2, par->xsize);
+		   	ScaleCbrY = CalScale(yact/2, par->ysize);
+		   	break;
+		case YUV444:// yuv444
+			fmt_cfg = 4;
+			ScaleCbrX = CalScale(xact, par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		default:
+			printk("%s:un supported format\n",__func__);
+		   break;
+	}
+
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
+		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
+		LcdMskReg(lcdc_dev,SYS_CFG, m_W0_FORMAT, v_W0_FORMAT(fmt_cfg));		//(inf->video_mode==0)
+		LcdWrReg(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
+		LcdWrReg(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
+		LcdMskReg(lcdc_dev, WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
+			v_COLORKEY_EN(0) | v_KEYCOLOR(0));
+		LcdWrReg(lcdc_dev,WIN0_VIR,v_VIRWIDTH(xvir));
+		//LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+    return 0;
+
+}
+
+static int win1_set_par(struct rk3066b_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u8 fmt_cfg;
+	char fmt[9]="NULL";
+	xact = par->xact;			
+	yact = par->yact;
+	xvir = par->xvir;		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	
+	
+	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch (par->format)
+	 	{
+	 		case XBGR888:
+			case ABGR888:
+			case ARGB888:
+				fmt_cfg = 0;
+				break;
+			case RGB565:
+				fmt_cfg = 1;
+				break;
+			default:
+				printk("%s:un supported format\n",__func__);
+				break;
+		}
+
+		LcdMskReg(lcdc_dev,SYS_CFG, m_W1_FORMAT, v_W1_FORMAT(fmt_cfg));
+		LcdWrReg(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
+		// enable win1 color key and set the color to black(rgb=0)
+		LcdMskReg(lcdc_dev,WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+		LcdWrReg(lcdc_dev,WIN1_VIR,v_VIRWIDTH(xvir));
+		
+		//LCDC_REG_CFG_DONE(); 
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+    return 0;
+}
+
+static int rk3066b_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
+{
+	int i=0;
+	int __iomem *c;
+	int v;
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+
+	if((open) && (!lcdc_dev->atv_layer_cnt)) //enable clk,when first layer open
+	{
+		rk3066b_lcdc_clk_enable(lcdc_dev);
+		rk3066b_lcdc_reg_resume(lcdc_dev); //resume reg
+		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+		rk3066b_load_screen(dev_drv,1);
+		spin_lock(&lcdc_dev->reg_lock);
+		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
+		{
+			LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(0));
+			LCDC_REG_CFG_DONE();
+
+			mdelay(25); //wait for dsp lut disabled
+			for(i=0;i<256;i++)
+			{
+				v = dev_drv->cur_screen->dsp_lut[i];
+				c = lcdc_dev->dsp_lut_addr_base+i;
+				writel_relaxed(v,c);
+			}
+			LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(1));//enable dsp lut
+		}
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	if(layer_id == 0)
+	{
+		win0_open(lcdc_dev,open);	
+	}
+	else if(layer_id == 1)
+	{
+		win1_open(lcdc_dev,open);
+	}
+	
+	if((!open) && (!lcdc_dev->atv_layer_cnt))  //when all layer closed,disable clk
+	{
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
+		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		LCDC_REG_CFG_DONE();
+		rk3066b_lcdc_clk_disable(lcdc_dev);
+	}
+	return 0;
+}
+
+static int rk3066b_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_set_par(lcdc_dev,screen,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_set_par(lcdc_dev,screen,par);
+	}
+	
+	return 0;
+}
+
+int rk3066b_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	unsigned long flags;
+	int timeout;
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;	
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_display(lcdc_dev,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_display(lcdc_dev,par);
+	}
+	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
+	{
+		dev_drv->first_frame = 0;
+		LcdMskReg(lcdc_dev,INT_STATUS,m_HOR_STARTMASK | m_FRM_STARTMASK | m_SCANNING_MASK | 
+			m_HOR_STARTCLEAR | m_FRM_STARTCLEAR |m_SCANNING_CLEAR | m_SCAN_LINE_NUM,
+			  v_HOR_STARTMASK(1) | v_FRM_STARTMASK(0) | v_SCANNING_MASK(0) |
+			  v_HOR_STARTCLEAR(1) | v_FRM_STARTCLEAR(1) | v_SCANNING_CLEAR(1) |
+			  //v_SCANNING_CLEAR(screen->vsync_len + screen->upper_margin+screen->y_res -1));
+			  v_SCAN_LINE_NUM(screen->vsync_len + screen->upper_margin+screen->y_res -1));
+		LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
+		 
+	}
+
+#if 0
+	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
+	{
+		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
+		if(!timeout&&(!dev_drv->frame_done.done))
+		{
+			printk(KERN_ERR "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+#endif
+	
+	return 0;
+}
+
+int rk3066b_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	int ret = 0;
+	switch(cmd)
+	{
+		case RK_FBIOGET_PANEL_SIZE:    //get panel size
+                	panel_size[0] = lcdc_dev->screen->x_res;
+                	panel_size[1] = lcdc_dev->screen->y_res;
+            		if(copy_to_user(argp, panel_size, 8)) 
+				return -EFAULT;
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+static int rk3066b_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	struct layer_par *par = dev_drv->layer_par[layer_id];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(layer_id == 0)
+		{
+			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W0_EN);
+		}
+		else if( layer_id == 1)
+		{
+			par->state = LcdReadBit(lcdc_dev,SYS_CFG,m_W1_EN);
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return par->state;
+	
+}
+
+/***********************************
+overlay manager
+swap:1 win0 on the top of win1
+        0 win1 on the top of win0
+set  : 1 set overlay 
+        0 get overlay state
+************************************/
+static int rk3066b_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	int ovl;
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(set)  //set overlay
+		{
+			LcdMskReg(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
+			LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01);
+			LCDC_REG_CFG_DONE();
+			ovl = swap;
+		}
+		else  //get overlay
+		{
+			ovl = LcdReadBit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
+		}
+	}
+	else
+	{
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+static ssize_t rk3066b_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id)
+
+{
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	char format_w0[9]= "NULL";
+	char format_w1[9]= "NULL";
+	char status_w0[9]= "NULL";
+	char status_w1[9]= "NULL";
+	u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CFG);
+	u32 act_info,dsp_info,dsp_st,factor;
+	u16 xvir_w0,x_act_w0,y_act_w0,x_dsp_w0,y_dsp_w0,x_st_w0,y_st_w0;
+	u16 xvir_w1,x_dsp_w1,y_dsp_w1,x_st_w1,y_st_w1;
+	u16 x_scale,y_scale;
+	int ovl = LcdReadBit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
+
+        switch((fmt_id&m_W0_FORMAT)>>3)
+        {
+                case 0:
+                        strcpy(format_w0,"ARGB888");
+                        break;
+                case 1:
+                        strcpy(format_w0,"RGB565");
+                        break;
+                case 2:
+                        strcpy(format_w0,"YCbCr422");
+                        break;
+                case 3:
+                        strcpy(format_w0,"YCbCr420");
+                        break;
+                case 5:
+                        strcpy(format_w0,"YCbCr444");
+                        break;
+                default:
+                        strcpy(format_w0,"invalid\n");
+                        break;
+        }
+
+	 switch((fmt_id&m_W1_FORMAT)>>2)
+        {
+                case 0:
+                        strcpy(format_w1,"ARGB888");
+                        break;
+                case 1:
+                        strcpy(format_w1,"RGB565");
+                        break;
+                default:
+                        strcpy(format_w1,"invalid\n");
+                        break;
+        }
+
+	if((fmt_id&m_W0_EN)>>11)
+	{
+		strcpy(status_w0,"enabled");
+	}
+	else
+	{
+		strcpy(status_w0,"disabled");
+	}
+
+	if((fmt_id&m_W1_EN)>>10)
+	{
+		strcpy(status_w1,"enabled");
+	}
+	else
+	{
+		strcpy(status_w1,"disabled");
+	}
+
+	xvir_w0 = LcdRdReg(lcdc_dev,WIN0_VIR)&0xffff;
+	act_info = LcdRdReg(lcdc_dev,WIN0_ACT_INFO);
+	dsp_info = LcdRdReg(lcdc_dev,WIN0_DSP_INFO);
+	dsp_st = LcdRdReg(lcdc_dev,WIN0_DSP_ST);
+	factor = LcdRdReg(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
+	x_act_w0 =  (act_info&0xffff);
+	y_act_w0 = (act_info>>16);
+	x_dsp_w0 = (dsp_info&0x7ff);
+	y_dsp_w0 = (dsp_info>>16);
+	x_scale = 4096*100/(factor&0xffff);
+	y_scale = 4096*100/(factor>>16);
+	x_st_w0 = dsp_st&0xffff;
+	y_st_w0 = dsp_st>>16;
+
+	
+	xvir_w1 = LcdRdReg(lcdc_dev,WIN1_VIR)&0xffff;
+	dsp_info = LcdRdReg(lcdc_dev,WIN1_DSP_INFO);
+	dsp_st = LcdRdReg(lcdc_dev,WIN1_DSP_ST);
+	x_dsp_w1 = dsp_info&0x7ff;
+	y_dsp_w1 = dsp_info>>16;
+	x_st_w1 = dsp_st&0xffff;
+	y_st_w1 = dsp_st>>16;
+
+	return snprintf(buf,PAGE_SIZE,
+		"win0:%s\n"
+		"xvir:%d\n"
+		"xact:%d\n"
+		"yact:%d\n"
+		"xdsp:%d\n"
+		"ydsp:%d\n"
+		"x_st:%d\n"
+		"y_st:%d\n"
+		"x_scale:%d.%d\n"
+		"y_scale:%d.%d\n"
+		"format:%s\n"
+		"YRGB buffer addr:0x%08x\n"
+		"CBR buffer addr:0x%08x\n\n"
+		"win1:%s\n"
+		"xvir:%d\n"
+		"xdsp:%d\n"
+		"ydsp:%d\n"
+		"x_st:%d\n"
+		"y_st:%d\n"
+		"format:%s\n"
+		"YRGB buffer addr:0x%08x\n"
+		"overlay:%s\n",
+		status_w0,
+                xvir_w0,
+                x_act_w0,
+                y_act_w0,
+                x_dsp_w0,
+                y_dsp_w0,
+                x_st_w0,
+                y_st_w0,
+                x_scale/100,
+                x_scale%100,
+                y_scale/100,
+                y_scale%100,
+                format_w0,
+                LcdRdReg(lcdc_dev,WIN0_YRGB_MST),
+                LcdRdReg(lcdc_dev,WIN0_CBR_MST),
+                status_w1,
+                xvir_w1,
+                x_dsp_w1,
+                y_dsp_w1,
+                x_st_w1,
+                y_st_w1,
+                format_w1,
+                LcdRdReg(lcdc_dev,WIN1_YRGB_MST),
+                ovl ? "win0 on the top of win1\n":"win1 on the top of win0\n");
+        return 0;
+}
+
+
+/*******************************************
+lcdc fps manager,set or get lcdc fps
+set:0 get
+     1 set
+********************************************/
+static int rk3066b_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	rk_screen * screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+
+	if(set)
+	{
+		ft = div_u64(1000000000000llu,fps);
+		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
+		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+		if(ret)
+		{
+	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+		}
+	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+			
+	}
+	
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+	(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps ;  //one frame time in ms
+	return fps;
+}
+
+static int rk3066b_fb_layer_remap(struct rk_lcdc_device_driver *dev_drv,
+        enum fb_win_map_order order)
+{
+        mutex_lock(&dev_drv->fb_win_id_mutex);
+	if(order == FB_DEFAULT_ORDER)
+	{
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
+	}
+        dev_drv->fb2_win_id  = order/100;
+        dev_drv->fb1_win_id = (order/10)%10;
+        dev_drv->fb0_win_id = order%10;
+        mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+        printk("fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
+                dev_drv->fb2_win_id);
+
+        return 0;
+}
+
+static int rk3066b_fb_get_layer(struct rk_lcdc_device_driver *dev_drv,const char *id)
+{
+        int layer_id = 0;
+        mutex_lock(&dev_drv->fb_win_id_mutex);
+        if(!strcmp(id,"fb0") || !strcmp(id,"fb2"))
+        {
+                layer_id = dev_drv->fb0_win_id;
+        }
+        else if(!strcmp(id,"fb1") || !strcmp(id,"fb3"))
+        {
+                layer_id = dev_drv->fb1_win_id;
+        }
+        else
+        {
+                printk(KERN_ERR "%s>>un supported %s\n",__func__,id);
+                layer_id = -1;
+        }
+        mutex_unlock(&dev_drv->fb_win_id_mutex);
+	
+        return  layer_id;
+}
+
+
+static void rk3066b_lcdc_reg_dump(struct rk3066b_lcdc_device *lcdc_dev)
+{
+	int *cbase =  (int *)lcdc_dev->reg_vir_base;
+	int i,j;
+	
+	for(i=0; i<=(0xa0>>4);i++)
+	{
+		for(j=0;j<4;j++)
+			printk("%08x  ",readl(cbase+i*4 +j));
+		printk("\n");
+	}
+	
+}
+
+int rk3066b_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+
+	if(dev_drv->screen0->standby)
+		dev_drv->screen0->standby(1);
+	if(dev_drv->screen_ctr_info->io_disable)
+		dev_drv->screen_ctr_info->io_disable();
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
+		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		LCDC_REG_CFG_DONE();
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else  //clk already disabled
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	
+	rk3066b_lcdc_clk_disable(lcdc_dev);
+
+	return 0;
+}
+
+
+int rk3066b_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
+{  
+	struct rk3066b_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	int i=0;
+	int __iomem *c;
+	int v;
+
+	if(dev_drv->screen_ctr_info->io_enable) 		//power on
+		dev_drv->screen_ctr_info->io_enable();
+	
+	if(lcdc_dev->atv_layer_cnt) //only resume the lcdc that need to use
+	{
+	
+		rk3066b_lcdc_clk_enable(lcdc_dev);
+		mdelay(5);
+		memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0x24);  //resume reg ,skip INT_STATUS reg
+		memcpy(((u8*)lcdc_dev->preg) + 0x28,((u8*)&lcdc_dev->regbak) + 0x28, 0x74);
+
+		spin_lock(&lcdc_dev->reg_lock);
+
+		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
+		{
+			LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(0));
+			LCDC_REG_CFG_DONE();
+
+			mdelay(25); //wait for dsp lut disabled
+			for(i=0;i<256;i++)
+			{
+				v = dev_drv->cur_screen->dsp_lut[i];
+				c = lcdc_dev->dsp_lut_addr_base+i;
+				writel_relaxed(v,c);
+			}
+			LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(1));//enable dsp lut
+		}
+		LcdMskReg(lcdc_dev, SYS_CFG,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+		LcdMskReg(lcdc_dev, INT_STATUS, m_SCANNING_CLEAR | m_FRM_STARTCLEAR | m_HOR_STARTCLEAR |
+					m_SCANNING_MASK | m_HOR_STARTMASK | m_FRM_STARTMASK , 
+					v_SCANNING_CLEAR(1) | v_FRM_STARTCLEAR(1) | v_HOR_STARTCLEAR(1) | 
+					v_SCANNING_MASK(0) | v_FRM_STARTMASK(0) | v_HOR_STARTMASK(1));
+		LCDC_REG_CFG_DONE();
+		
+		spin_unlock(&lcdc_dev->reg_lock);
+
+	}
+	
+	if(dev_drv->screen0->standby)
+		dev_drv->screen0->standby(0);	      //screen wake up
+	
+    	return 0;
+}
+
+static int no_report(struct rk3066b_lcdc_device *lcdc_dev)
+{
+	struct rk_lcdc_device_driver *dev = &(lcdc_dev->driver);
+	static u32 lcdc0_old_addr = 0,cur_addr = 0;
+	static u32 mode = 0,num = 0;
+	static u32 cur_state = 0,old_state = 0;
+	
+	if(dev->screen_ctr_info->prop == PRMRY){
+		cur_addr = LcdRdReg(lcdc_dev,WIN0_YRGB_MST);
+		if(lcdc0_old_addr != cur_addr){
+			if(cur_state++ > 10000)
+				cur_state = 0;
+
+			lcdc0_old_addr = cur_addr;
+		}
+	}
+
+	if(old_state == cur_state){
+		if(num++>10 && mode != 0)
+			mode = 0;
+	}
+	else{
+		mode = 1;
+		num = 0;
+	}
+
+	if(mode == 1 && old_state == cur_state){
+		return -1;
+	}
+
+	old_state = cur_state;
+
+	return 0;
+}
+
+static irqreturn_t rk3066b_lcdc_isr(int irq, void *dev_id)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = (struct rk3066b_lcdc_device *)dev_id;
+
+	u32 int_reg = LcdRdReg(lcdc_dev,INT_STATUS);
+	if(int_reg & m_FRM_START){
+	ktime_t timestamp = ktime_get();
+	
+	LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_STARTCLEAR, v_FRM_STARTCLEAR(1));
+	
+#if defined(CONFIG_FB_ROTATE) || !defined(CONFIG_THREE_FB_BUFFER)
+	if(hdmi_get_hotplug() == HDMI_HPD_ACTIVED){
+		if(no_report(lcdc_dev)){
+			return IRQ_HANDLED;
+		}
+	}
+#endif
+	//LcdMskReg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
+
+#if 0
+	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
+	{
+		spin_lock(&(lcdc_dev->driver.cpl_lock));
+		complete(&(lcdc_dev->driver.frame_done));
+		spin_unlock(&(lcdc_dev->driver.cpl_lock));
+	}
+#endif
+
+	lcdc_dev->driver.vsync_info.timestamp = timestamp;
+	wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
+	}
+	else if(int_reg & m_SCANNING_FLAG){
+		LcdMskReg(lcdc_dev, INT_STATUS, m_SCANNING_CLEAR, v_SCANNING_CLEAR(1));
+	}
+	return IRQ_HANDLED;
+}
+
+
+static int rk3066b_set_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
+{
+	int i=0;
+	int __iomem *c;
+	int v;
+	int ret = 0;
+
+	struct rk3066b_lcdc_device *lcdc_dev =
+				container_of(dev_drv,struct rk3066b_lcdc_device,driver);
+	LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(0));
+	LCDC_REG_CFG_DONE();
+	msleep(25);
+	if(dev_drv->cur_screen->dsp_lut)
+	{
+		for(i=0;i<256;i++)
+		{
+			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
+			c = lcdc_dev->dsp_lut_addr_base+i;
+			writel_relaxed(v,c);
+		}
+	}
+	else
+	{
+		dev_err(dev_drv->dev,"no buffer to backup lut data!\n");
+		ret =  -1;
+	}
+	LcdMskReg(lcdc_dev,SYS_CFG,m_DSIP_LUT_CTL,v_DSIP_LUT_CTL(1));
+	LCDC_REG_CFG_DONE();
+
+	return ret;
+}
+
+int rk3066b_lcdc_poll_vblank(struct rk_lcdc_device_driver * dev_drv)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = 
+				container_of(dev_drv,struct rk3066b_lcdc_device,driver);    
+        u32 int_reg ;
+	int ret;
+	//spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		int_reg = LcdRdReg(lcdc_dev,INT_STATUS);
+	        if(int_reg & m_SCANNING_FLAG)
+	        {
+	              LcdMskReg(lcdc_dev, INT_STATUS, m_SCANNING_CLEAR,v_SCANNING_CLEAR(1));              
+	              ret =  RK_LF_STATUS_FC;
+	        }
+	        else
+	             ret = RK_LF_STATUS_FR;
+	}
+	else
+	{
+		ret = RK_LF_STATUS_NC;
+	}	
+	//spin_unlock(&lcdc_dev->reg_lock);
+
+
+	return ret;
+}
+
+static struct layer_par lcdc_layer[] = {
+	[0] = {
+		.name  		= "win0",
+		.id		= 0,
+		.support_3d	= true,
+	},
+	[1] = {
+		.name  		= "win1",
+		.id		= 1,
+		.support_3d	= false,
+	},
+};
+
+static struct rk_lcdc_device_driver lcdc_driver = {
+	.name			= "lcdc",
+	.def_layer_par		= lcdc_layer,
+	.num_layer		= ARRAY_SIZE(lcdc_layer),
+	.open			= rk3066b_lcdc_open,
+	.init_lcdc		= init_rk3066b_lcdc,
+	.ioctl			= rk3066b_lcdc_ioctl,
+	.suspend		= rk3066b_lcdc_early_suspend,
+	.resume			= rk3066b_lcdc_early_resume,
+	.set_par       		= rk3066b_lcdc_set_par,
+	.blank         		= rk3066b_lcdc_blank,
+	.pan_display            = rk3066b_lcdc_pan_display,
+	.load_screen		= rk3066b_load_screen,
+	.get_layer_state	= rk3066b_lcdc_get_layer_state,
+	.ovl_mgr		= rk3066b_lcdc_ovl_mgr,
+	.get_disp_info		= rk3066b_lcdc_get_disp_info,
+	.fps_mgr		= rk3066b_lcdc_fps_mgr,
+	.fb_get_layer           = rk3066b_fb_get_layer,
+	.fb_layer_remap         = rk3066b_fb_layer_remap,
+	.set_dsp_lut            = rk3066b_set_dsp_lut,
+	.poll_vblank		= rk3066b_lcdc_poll_vblank,
+};
+#ifdef CONFIG_PM
+static int rk3066b_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk3066b_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#else
+#define rk3066b_lcdc_suspend NULL
+#define rk3066b_lcdc_resume NULL
+#endif
+
+static int __devinit rk3066b_lcdc_probe (struct platform_device *pdev)
+{
+	struct rk3066b_lcdc_device *lcdc_dev=NULL;
+	rk_screen *screen;
+	rk_screen *screen1;
+	struct rk29fb_info *screen_ctr_info;
+	struct resource *res = NULL;
+	struct resource *mem;
+	int ret = 0;
+	
+	/*************Malloc rk3066blcdc_inf and set it to pdev for drvdata**********/
+	lcdc_dev = kzalloc(sizeof(struct rk3066b_lcdc_device), GFP_KERNEL);
+    	if(!lcdc_dev)
+    	{
+        	dev_err(&pdev->dev, ">>rk3066b lcdc device kmalloc fail!");
+        	return -ENOMEM;
+    	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->id = pdev->id;
+	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
+	screen =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
+	if(!screen)
+	{
+		dev_err(&pdev->dev, ">>rk3066b lcdc screen kmalloc fail!");
+        	ret =  -ENOMEM;
+		goto err0;
+	}
+	else
+	{
+		lcdc_dev->screen = screen;
+	}
+	screen->lcdc_id = lcdc_dev->id;
+	screen->screen_id = 0;
+
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
+	screen1 =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
+	if(!screen1)
+	{
+		dev_err(&pdev->dev, ">>rk3066b lcdc screen1 kmalloc fail!");
+        	ret =  -ENOMEM;
+		goto err0;
+	}
+	screen1->lcdc_id = 1;
+	screen1->screen_id = 1;
+	printk("use lcdc%d and rk610 implemention dual display!\n",lcdc_dev->id);
+	
+#endif
+	/****************get lcdc0 reg  *************************/
+	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
+	if (res == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+    	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
+    	if (mem == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
+	if (lcdc_dev->reg_vir_base == NULL)
+	{
+		dev_err(&pdev->dev, "cannot map IO\n");
+		ret = -ENXIO;
+		goto err2;
+	}
+	
+    	lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
+	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->preg);
+	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->reg_vir_base+DSP_LUT_ADDR);
+
+	lcdc_dev->driver.dev=&pdev->dev;
+	lcdc_dev->driver.screen0 = screen;
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
+	lcdc_dev->driver.screen1 = screen1;
+#endif
+	lcdc_dev->driver.cur_screen = screen;
+	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
+	spin_lock_init(&lcdc_dev->reg_lock);
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if(lcdc_dev->irq < 0)
+	{
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		goto err3;
+	}
+	ret = request_irq(lcdc_dev->irq, rk3066b_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
+	if (ret)
+	{
+	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
+	       ret = -EBUSY;
+	       goto err3;
+	}
+
+	if(screen_ctr_info->set_screen_info)
+	{
+		screen_ctr_info->set_screen_info(screen,screen_ctr_info->lcd_info);
+		if(SCREEN_NULL==screen->type)
+		{
+			printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
+			ret = -ENODEV;
+		}
+		if(screen_ctr_info->io_init)
+			screen_ctr_info->io_init(NULL);
+	}
+	else
+	{
+		printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
+		ret =  -ENODEV;
+		goto err4;
+	}
+		
+	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
+	if(ret < 0)
+	{
+		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
+		goto err4;
+	}
+	printk("rk3066b lcdc%d probe ok!\n",lcdc_dev->id);
+
+	return 0;
+
+err4:
+	free_irq(lcdc_dev->irq,lcdc_dev);
+err3:	
+	iounmap(lcdc_dev->reg_vir_base);
+err2:
+	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
+err1:
+	kfree(screen);
+err0:
+	platform_set_drvdata(pdev, NULL);
+	kfree(lcdc_dev);
+	return ret;
+    
+}
+static int __devexit rk3066b_lcdc_remove(struct platform_device *pdev)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	rk_fb_unregister(&(lcdc_dev->driver));
+	rk3066b_lcdc_deinit(lcdc_dev);
+	iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);
+	return 0;
+}
+
+static void rk3066b_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct rk3066b_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	if(lcdc_dev->driver.cur_screen->standby) //standby the screen if necessary
+		lcdc_dev->driver.cur_screen->standby(1);
+	if(lcdc_dev->driver.screen_ctr_info->io_disable) //power off the screen if necessary
+		lcdc_dev->driver.screen_ctr_info->io_disable();
+	if(lcdc_dev->driver.cur_screen->sscreen_set) //turn off  lvds if necessary
+		lcdc_dev->driver.cur_screen->sscreen_set(lcdc_dev->driver.cur_screen , 0);
+
+	rk3066b_lcdc_deinit(lcdc_dev);
+	//rk_fb_unregister(&(lcdc_dev->driver));
+	
+	/*iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);*/
+}
+
+
+static struct platform_driver rk3066b_lcdc_driver = {
+	.probe		= rk3066b_lcdc_probe,
+	.remove		= __devexit_p(rk3066b_lcdc_remove),
+	.driver		= {
+		.name	= "rk30-lcdc",
+		.owner	= THIS_MODULE,
+	},
+	.suspend	= rk3066b_lcdc_suspend,
+	.resume		= rk3066b_lcdc_resume,
+	.shutdown   	= rk3066b_lcdc_shutdown,
+};
+
+static int __init rk3066b_lcdc_init(void)
+{
+	return platform_driver_register(&rk3066b_lcdc_driver);
+}
+
+static void __exit rk3066b_lcdc_exit(void)
+{
+	platform_driver_unregister(&rk3066b_lcdc_driver);
+}
+
+
+
+fs_initcall(rk3066b_lcdc_init);
+module_exit(rk3066b_lcdc_exit);
+
+
+
diff -Nupr a/drivers/video/rockchip/lcdc/rk3066b_lcdc.h b/drivers/video/rockchip/lcdc/rk3066b_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk3066b_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3066b_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,558 @@
+/* drivers/video/rockchip/chips/rk29_fb.h
+ *
+ * Copyright (C) 2010 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __RK3066B_LCDC_H
+#define __RK3066B_LCDC_H
+
+#include<linux/rk_fb.h>
+
+#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
+#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
+#define LcdRdReg(inf, addr)             (inf->preg->addr)
+#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
+#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
+#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
+#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
+#define LCDC_REG_CFG_DONE()		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
+
+
+/********************************************************************
+**                                                            *
+********************************************************************/
+/* SYS_CONFIG */
+#define m_W2_FORMAT          (3<<0)
+#define m_W1_FORMAT          (1<<2)
+#define m_W0_FORMAT          (7<<3)
+#define m_W0_CBR_DEFLICK_EN  (1<<6)
+#define m_W0_YRGB_DEFLICK_EN  (1<<7)
+#define m_INTERIACE_EN       (1<<8)
+#define m_W2_EN              (1<<9)
+#define m_W1_EN              (1<<10)
+#define m_W0_EN              (1<<11)
+#define m_HWC_EN              (1<<12)
+#define m_HWC_RELOAD_EN         (1<<13)
+#define m_W2_INTERLACE_READ    (1<<14)
+#define m_W1_INTERLACE_READ    (1<<15)
+#define m_W0_INTERLACE_READ    (1<<16)
+#define m_LCDC_STANDBY            (1<<17)
+#define m_HWC_BURST          (3<<18)
+#define m_W2_BURST           (3<<20)
+#define m_W1_BURST           (3<<22)
+#define m_W0_BURST           (3<<24)
+#define m_W2_LUT_CTL         (1<<26)
+#define m_DSIP_LUT_CTL       (1<<27)
+#define m_HWC_REVERSED_COLOR   (1<<28)
+#define m_W1_AXI_OUTSTANDING2     (1<<29)
+#define m_W0_AXI_OUTSTANDING2     (1<<30)
+#define m_LCDC_AXICLK_AUTO_ENABLE (1<<31)
+
+#define v_W2_FORMAT(x)         (((x)&3)<<0)
+#define v_W1_FORMAT(x)          (((x)&1)<<2)
+#define v_W0_FORMAT(x)          (((x)&7)<<3)
+#define v_W0_CBR_DEFLICK_EN(x)  (((x)&1)<<6)
+#define v_W0_YRGB_DEFLICK_EN(x)  (((x)&1)<<7)
+#define v_INTERIACE_EN(x)       (((x)&1)<<8)
+#define v_W2_EN(x)          (((x)&)1<<9)
+#define v_W1_EN(x)          (((x)&1)<<10)
+#define v_W0_EN(x)          (((x)&1)<<11)
+#define v_HWC_EN(x)         (((x)&1)<<12)
+#define v_HWC_RELOAD_EN(x)         (((x)&1)<<13)
+#define v_W2_INTERLACE_READ(x)    (((x)&1)<<14)
+#define v_W1_INTERLACE_READ(x)    (((x)&1)<<15)
+#define v_W0_INTERLACE_READ(x)    (((x)&1)<<16)
+#define v_LCDC_STANDBY(x)            (((x)&1)<<17)
+#define v_HWC_BURST(x)          (((x)&3)<<18)
+#define v_W2_BURST(x)           (((x)&3)<<20)
+#define v_W1_BURST(x)           (((x)&3)<<22)
+#define v_W0_BURST(x)           (((x)&3)<<24)
+#define v_W2_LUT_CTL(x)         (((x)&1)<<26)
+#define v_DSIP_LUT_CTL(x)       (((x)&1)<<27)
+#define v_HWC_REVERSED_COLOR(x)   (((x)&1)<<28)
+#define v_W1_AXI_OUTSTANDING2(x)     (((x)&1)<<29)
+#define v_W0_AXI_OUTSTANDING2(x)     (((x)&1)<<30)
+#define v_LCDC_AXICLK_AUTO_ENABLE(x)    (((x)&1)<<31)
+
+//LCDC_SWAP_CTRL
+#define m_W1_565_RB_SWAP        (1<<0)
+#define m_W0_565_RB_SWAP        (1<<1)
+#define m_W0_YRGB_M8_SWAP       (1<<2)
+#define m_W0_YRGB_R_SHIFT_SWAP  (1<<3)
+#define m_W0_CBR_R_SHIFT_SWAP   (1<<4)
+#define m_W0_YRGB_16_SWAP       (1<<5)
+#define m_W0_YRGB_8_SWAP        (1<<6)
+#define m_W0_CBR_16_SWAP        (1<<7)
+#define m_W0_CBR_8_SWAP         (1<<8)
+#define m_W1_16_SWAP            (1<<9)
+#define m_W1_8_SWAP             (1<<10)
+#define m_W1_R_SHIFT_SWAP       (1<<11)
+#define m_OUTPUT_BG_SWAP        (1<<12)
+#define m_OUTPUT_RB_SWAP        (1<<13)
+#define m_OUTPUT_RG_SWAP        (1<<14)
+#define m_DELTA_SWAP            (1<<15)
+#define m_DUMMY_SWAP            (1<<16)
+#define m_W2_BYTE_SWAP          (1<<17)
+#define v_W1_565_RB_SWAP(x)        (((x)&1)<<0)
+#define v_W0_565_RB_SWAP(x)        (((x)&1)<<1)
+#define v_W0_YRGB_M8_SWAP(x)       (((x)&1)<<2)
+#define v_W0_YRGB_R_SHIFT_SWAP(x)  (((x)&1)<<3)
+#define v_W0_CBR_R_SHIFT_SWAP(x)   (((x)&1)<<4)
+#define v_W0_YRGB_16_SWAP(x)       (((x)&1)<<5)
+#define v_W0_YRGB_8_SWAP(x)        (((x)&1)<<6)
+#define v_W0_CBR_16_SWAP(x)        (((x)&1)<<7)
+#define v_W0_CBR_8_SWAP(x)         (((x)&1)<<8)
+#define v_W1_16_SWAP(x)            (((x)&1)<<9)
+#define v_W1_8_SWAP(x)             (((x)&1)<<10)
+#define v_W1_R_SHIFT_SWAP(x)       (((x)&1)<<11)
+#define v_OUTPUT_BG_SWAP(x)        (((x)&1)<<12)
+#define v_OUTPUT_RB_SWAP(x)        (((x)&1)<<13)
+#define v_OUTPUT_RG_SWAP(x)        (((x)&1)<<14)
+#define v_DELTA_SWAP(x)            (((x)&1)<<15)
+#define v_DUMMY_SWAP(x)            (((x)&1)<<16)
+#define v_W2_BYTE_SWAP(x)      (((x)&1)<<17)
+
+//LCDC_MCU_TIMING_CTRL
+#define m_MCU_WRITE_PERIOD      (31<<0)
+#define m_MCU_CS_ST             (31<<5)
+#define m_MCU_CS_END            (31<<10)
+#define m_MCU_RW_ST             (31<<15)
+#define m_MCU_RW_END            (31<<20)
+#define m_MCU_HOLDMODE_SELECT     (1<<27)
+#define m_MCU_HOLDMODE_FRAME_ST   (1<<28)
+#define m_MCU_RS_SELECT            (1<<29)
+#define m_MCU_BYPASSMODE_SELECT   (1<<30)
+#define m_MCU_OUTPUT_SELECT        (1<<31)
+#define v_MCU_WRITE_PERIOD(x)      (((x)&31)<<0)
+#define v_MCU_CS_ST(x)          (((x)&31)<<5)
+#define v_MCU_CS_END(x)         (((x)&31)<<10)
+#define v_MCU_RW_ST(x)          (((x)&31)<<15)
+#define v_MCU_RW_END(x)         (((x)&31)<<20)
+#define v_MCU_HOLD_STATUS(x)          (((x)&1)<<26)
+#define v_MCU_HOLDMODE_SELECT(x)     (((x)&1)<<27)
+#define v_MCU_HOLDMODE_FRAME_ST(x)   (((x)&1)<<28)
+#define v_MCU_RS_SELECT(x)            (((x)&1)<<29)
+#define v_MCU_BYPASSMODE_SELECT(x)   (((x)&1)<<30)
+#define v_MCU_OUTPUT_SELECT(x)        (((x)&1)<<31)
+
+//LCDC_ BLEND_CTRL
+#define m_HWC_BLEND_EN         (1<<0)
+#define m_W2_BLEND_EN          (1<<1)
+#define m_W1_BLEND_EN          (1<<2)
+#define m_W0_BLEND_EN          (1<<3)
+#define m_HWC_BLEND_FACTOR     (15<<4)
+#define m_W2_BLEND_FACTOR     (0xff<<8)
+#define m_W1_BLEND_FACTOR     (0xff<<16)
+#define m_W0_BLEND_FACTOR     (0xff<<24)
+
+#define v_HWC_BLEND_EN(x)         (((x)&1)<<0)
+#define v_W2_BLEND_EN(x)          (((x)&1)<<1)
+#define v_W1_BLEND_EN(x)          (((x)&1)<<2)
+#define v_W0_BLEND_EN(x)          (((x)&1)<<3)
+#define v_HWC_BLEND_FACTOR(x)    (((x)&15)<<4)
+#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<8)
+#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<16)
+#define v_W0_BLEND_FACTOR(x)     (((x)&0xff)<<24)
+
+
+//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
+#define m_KEYCOLOR          (0xffffff<<0)
+#define m_KEYCOLOR_B          (0xff<<0)
+#define m_KEYCOLOR_G          (0xff<<8)
+#define m_KEYCOLOR_R          (0xff<<16)
+#define m_COLORKEY_EN         (1<<24)
+#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
+#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
+#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
+#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
+#define v_COLORKEY_EN(x)         (((x)&1)<<24)
+
+//LCDC_DEFLICKER_SCL_OFFSET
+#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
+#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
+#define m_W1_VSD_OFFSET           (0xff<<16)
+#define m_W1_VSP_OFFSET           (0xff<<24)
+#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
+#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
+#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
+#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
+
+//LCDC_DSP_CTRL_REG0
+#define m_DISPLAY_FORMAT             (0xf<<0)
+#define m_HSYNC_POLARITY             (1<<4)
+#define m_VSYNC_POLARITY             (1<<5)
+#define m_DEN_POLARITY               (1<<6)
+#define m_DCLK_POLARITY              (1<<7)
+#define m_COLOR_SPACE_CONVERSION     (3<<8)
+#define m_DITHER_UP_EN               (1<<10)
+#define m_DITHER_DOWN_MODE           (1<<11)
+#define m_DITHER_DOWN_EN             (1<<12)
+#define m_INTERLACE_FIELD_POLARITY   (1<<13)
+#define m_YUV_CLIP                   (1<<14)
+#define m_W1_TRANSP_FROM             (1<<15)
+#define m_W0_TRANSP_FROM             (1<<16)
+#define m_W0W1_POSITION_SWAP         (1<<17)
+#define m_W1_CLIP_EN                 (1<<18)
+#define m_W0_CLIP_EN                 (1<<19)
+#define m_W0_YCBR_PRIORITY_MODE      (1<<20)
+#define m_CBR_FILTER_656             (1<<21)
+#define m_W2_CHIP_EN                 (1<<22)
+
+#define v_DISPLAY_FORMAT(x)            (((x)&0xf)<<0)
+#define v_HSYNC_POLARITY(x)             (((x)&1)<<4)
+#define v_VSYNC_POLARITY(x)             (((x)&1)<<5)
+#define v_DEN_POLARITY(x)               (((x)&1)<<6)
+#define v_DCLK_POLARITY(x)              (((x)&1)<<7)
+#define v_COLOR_SPACE_CONVERSION(x)     (((x)&3)<<8)
+#define v_DITHER_UP_EN(x)               (((x)&1)<<10)
+#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<11)
+#define v_DITHER_DOWN_EN(x)             (((x)&1)<<12)
+#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
+#define v_YUV_CLIP(x)                   (((x)&1)<<14)
+#define v_W1_TRANSP_FROM(x)             (((x)&1)<<15)
+#define v_W0_TRANSP_FROM(x)             (((x)&1)<<16)
+#define v_W0W1_POSITION_SWAP(x)         (((x)&1)<<17)
+#define v_W1_CLIP_EN(x)                 (((x)&1)<<18)
+#define v_W0_CLIP_EN(x)                 (((x)&1)<<19)
+#define v_W0_YCBR_PRIORITY_MODE(x)      (((x)&1)<<20)
+#define v_CBR_FILTER_656(x)             (((x)&1)<<21)
+#define v_W2_CHIP_EN(x)                 (((x)&1)<<22)
+
+
+//LCDC_DSP_CTRL_REG1
+#define m_BG_COLOR                    (0xffffff<<0)
+#define m_BG_B                        (0xff<<0)
+#define m_BG_G                        (0xff<<8)
+#define m_BG_R                        (0xff<<16)
+#define m_BLANK_MODE                  (1<<24)
+#define m_BLACK_MODE                  (1<<25)
+#define m_DISP_FILTER_FACTOR          (3<<26)
+#define m_DISP_FILTER_MODE            (1<<28)
+#define m_DISP_FILTER_EN              (1<<29)
+#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
+#define v_BG_B(x)                     (((x)&0xff)<<0)
+#define v_BG_G(x)                     (((x)&0xff)<<8)
+#define v_BG_R(x)                     (((x)&0xff)<<16)
+#define v_BLANK_MODE(x)               (((x)&1)<<24)
+#define v_BLACK_MODE(x)               (((x)&1)<<25)
+#define v_DISP_FILTER_FACTOR(x)       (((x)&3)<<26)
+#define v_DISP_FILTER_MODE(x)         (((x)&1)<<28)
+#define v_DISP_FILTER_EN(x)           (((x)&1)<<29)
+
+//LCDC_INT_STATUS
+#define m_HOR_START         (1<<0)
+#define m_FRM_START         (1<<1)
+#define m_SCANNING_FLAG     (1<<2)
+#define m_HOR_STARTMASK     (1<<3)
+#define m_FRM_STARTMASK     (1<<4)
+#define m_SCANNING_MASK     (1<<5)
+#define m_HOR_STARTCLEAR    (1<<6)
+#define m_FRM_STARTCLEAR    (1<<7)
+#define m_SCANNING_CLEAR    (1<<8)
+#define m_SCAN_LINE_NUM     (0x7ff<<9)
+#define v_HOR_START(x)         (((x)&1)<<0)
+#define v_FRM_START(x)         (((x)&1)<<1)
+#define v_SCANNING_FLAG(x)     (((x)&1)<<2)
+#define v_HOR_STARTMASK(x)     (((x)&1)<<3)
+#define v_FRM_STARTMASK(x)     (((x)&1)<<4)
+#define v_SCANNING_MASK(x)     (((x)&1)<<5)
+#define v_HOR_STARTCLEAR(x)    (((x)&1)<<6)
+#define v_FRM_STARTCLEAR(x)    (((x)&1)<<7)
+#define v_SCANNING_CLEAR(x)    (((x)&1)<<8)
+#define v_SCAN_LINE_NUM(x)     (((x)&0x7ff)<<9)
+
+//AXI MS ID
+#define m_W0_YRGB_CH_ID        (0xF<<0)
+#define m_W0_CBR_CH_ID         (0xF<<4)
+#define m_W1_YRGB_CH_ID        (0xF<<8)
+#define m_W2_CH_ID             (0xF<<12)
+#define m_HWC_CH_ID            (0xF<<16)
+#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
+#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
+#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
+#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
+#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
+
+
+/* Low Bits Mask */
+#define m_WORDLO            (0xffff<<0)
+#define m_WORDHI            (0xffff<<16)
+#define v_WORDLO(x)         (((x)&0xffff)<<0)
+#define v_WORDHI(x)         (((x)&0xffff)<<16)
+
+#define m_BIT11LO           (0x7ff<<0)
+#define m_BIT11HI           (0x7ff<<16)
+#define v_BIT11LO(x)        (((x)&0x7ff)<<0)
+#define v_BIT11HI(x)        (((x)&0x7ff)<<16)
+
+#define m_BIT12LO           (0xfff<<0)
+#define m_BIT12HI           (0xfff<<16)
+#define v_BIT12LO(x)        (((x)&0xfff)<<0)
+#define v_BIT12HI(x)        (((x)&0xfff)<<16)
+
+
+#define m_VIRWIDTH       (0xffff<<0)
+#define m_VIRHEIGHT      (0xffff<<16)
+#define v_VIRWIDTH(x)       (((x)&0xffff)<<0)
+#define v_VIRHEIGHT(x)      (((x)&0xffff)<<16)
+
+#define m_ACTWIDTH       (0xffff<<0)
+#define m_ACTHEIGHT      (0xffff<<16)
+#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
+#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
+
+#define m_VIRST_X      (0xffff<<0)
+#define m_VIRST_Y      (0xffff<<16)
+#define v_VIRST_X(x)      (((x)&0xffff)<<0)
+#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
+
+#define m_PANELST_X      (0x3ff<<0)
+#define m_PANELST_Y      (0x3ff<<16)
+#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
+#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
+
+#define m_PANELWIDTH       (0x3ff<<0)
+#define m_PANELHEIGHT      (0x3ff<<16)
+#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
+#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
+
+#define m_HWC_B                 (0xff<<0)
+#define m_HWC_G                 (0xff<<8)
+#define m_HWC_R                 (0xff<<16)
+#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
+#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
+#define v_HWC_B(x)                 (((x)&0xff)<<0)
+#define v_HWC_G(x)                 (((x)&0xff)<<8)
+#define v_HWC_R(x)                 (((x)&0xff)<<16)
+#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
+#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
+
+
+//Panel display scanning
+#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
+
+#define m_PANEL_END              (0x3ff<<0)
+#define m_PANEL_START            (0x3ff<<16)
+#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
+#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
+
+#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
+//-----------
+
+#define m_HSCALE_FACTOR        (0xffff<<0)
+#define m_VSCALE_FACTOR        (0xffff<<16)
+#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
+#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
+
+#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
+#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
+#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
+#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
+#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
+#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
+#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
+#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
+
+
+#define m_WIN1_FIFO_FULL_LEVEL 		(0x7f << 0)
+#define m_WIN2_FIFO_FULL_LEVEL 		(0x1f << 7)
+#define v_WIN1_FIFO_FULL_LEVEL(x)	(((x)&0x7f) << 0)
+#define v_WIN2_FIFO_FULL_LEVEL(x)	(((x)&0x1f) << 7)
+
+
+#define m_WIN0_YRGB_CHANNEL_ID	      	((0x0f)<<0)
+#define m_WIN0_CBR_CHANNEL_ID	      	((0x0f)<<4)
+#define m_WIN1_YRGB_CHANNEL_ID	      	((0x0f)<<8)
+#define m_WIN2_CHANNEL_ID	      	((0x0f)<<12)
+#define m_HWC_CHANNEL_ID	      	((0x0f)<<16)
+#define v_WIN0_YRGB_CHANNEL_ID(x)	(((x)&0x0f)<<0)
+#define v_WIN0_CBR_CHANNEL_ID(x)	(((x)&0x0f)<<4)
+#define v_WIN1_YRGB_CHANNEL_ID(x)	(((x)&0x0f)<<8)
+#define v_WIN2_CHANNEL_ID(x)	      	(((x)&0x0f)<<12)
+#define v_HWC_CHANNEL_ID(x)	      	(((x)&0x0f)<<16)
+
+
+//LCDC_WINx_SCL_FACTOR_Y/CBCR
+#define v_X_SCL_FACTOR(x)  ((x)<<0)
+#define v_Y_SCL_FACTOR(x)  ((x)<<16)
+
+//LCDC_DSP_HTOTAL_HS_END
+#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
+#define v_HORPRD(x) ((x)<<16)   //horizontal period
+
+
+//LCDC_DSP_HACT_ST_END
+#define v_HAEP(x) ((x)<<0)  //horizontal active end point
+#define v_HASP(x) ((x)<<16) //horizontal active start point
+
+//LCDC_DSP_VTOTAL_VS_END
+#define v_VSYNC(x) ((x)<<0)
+#define v_VERPRD(x) ((x)<<16)
+
+//LCDC_DSP_VACT_ST_END
+#define v_VAEP(x) ((x)<<0)
+#define v_VASP(x) ((x)<<16)
+
+//LCDC_WIN0_ACT_INFO
+#define v_ACT_WIDTH(x)     ((x)<<0)
+#define v_ACT_HEIGHT(x)    ((x)<<16)
+
+//LCDC_WIN0_DSP_INFO
+#define v_DSP_WIDTH(x)     ((x)<<0)
+#define v_DSP_HEIGHT(x)    ((x)<<16)
+
+//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
+#define v_DSP_STX(x)      (x<<0)
+#define v_DSP_STY(x)      (x<<16)
+
+
+/********************************************************************
+**                                                          *
+********************************************************************/
+/* LCDC */
+
+typedef volatile struct tagLCDC_REG
+{
+    /* offset 0x00~0xc0 */
+    unsigned int SYS_CFG;              //0x00 SYSTEM configure register
+    unsigned int SWAP_CTRL;               //0x04 Data SWAP control
+    unsigned int MCU_CTRL;         //0x08 MCU TIMING control register
+    unsigned int BLEND_CTRL;              //0x0c Blending control register
+    unsigned int WIN0_COLOR_KEY_CTRL;     //0x10 Win0 blending control register
+    unsigned int WIN1_COLOR_KEY_CTRL;     //0x14 Win1 blending control register
+    unsigned int WIN2_VIR;                //0x18 WIN2 virtual display width
+    unsigned int DSP_CTRL0;               //0x1c Display control register0
+    unsigned int DSP_CTRL1;               //0x20 Display control register1
+    unsigned int INT_STATUS;              //0x24 Interrupt status register
+    unsigned int WIN0_VIR;                //0x28 WIN0 virtual display width/height
+    unsigned int WIN0_YRGB_MST;           //0x2c Win0 active YRGB memory start address
+    unsigned int WIN0_CBR_MST;            //0x30 Win0 active Cbr memory start address
+    unsigned int WIN0_ACT_INFO;           //0x34 Win0 active window width/height
+    unsigned int WIN0_DSP_ST;             //0x38 Win0 display start point on panel
+    unsigned int WIN0_DSP_INFO;           //0x3c Win0 display width/height on panel
+    unsigned int WIN1_VIR;                //0x40 Win1 virtual display width/height
+    unsigned int WIN1_YRGB_MST;           //0x44 Win1 active  memory start address
+    unsigned int WIN1_DSP_INFO;           //0x48 Win1 display width/height on panel
+    unsigned int WIN1_DSP_ST;             //0x4c Win1 display start point on panel
+    unsigned int WIN2_MST;                //0X50 Win2 memory start address
+    unsigned int WIN2_DSP_INFO;           //0x54 Win1 display width/height on panel
+    unsigned int WIN2_DSP_ST;             //0x58 Win1 display start point on panel
+    unsigned int HWC_MST;                 //0x5C HWC memory start address
+    unsigned int HWC_DSP_ST;              //0x60 HWC display start point on panel
+    unsigned int HWC_COLOR_LUT0;          //0x64 Hardware cursor color 2b01 look up table 0
+    unsigned int HWC_COLOR_LUT1;          //0x68 Hardware cursor color 2b10 look up table 1
+    unsigned int HWC_COLOR_LUT2;          //0x6c Hardware cursor color 2b11 look up table 2
+    unsigned int DSP_HTOTAL_HS_END;       //0x70 Panel scanning horizontal width and hsync pulse end point
+    unsigned int DSP_HACT_ST_END;         //0x74 Panel active horizontal scanning start/end point
+    unsigned int DSP_VTOTAL_VS_END;       //0x78 Panel scanning vertical height and vsync pulse end point
+    unsigned int DSP_VACT_ST_END;         //0x7c Panel active vertical scanning start/end point
+    unsigned int DSP_VS_ST_END_F1;        //0x80 Vertical scanning start point and vsync pulse end point of even filed in interlace mode
+    unsigned int DSP_VACT_ST_END_F1;      //0x84 Vertical scanning active start/end point of even filed in interlace mode
+    unsigned int WIN0_SCL_FACTOR_YRGB;    //0x88 Win0 YRGB scaling down factor setting
+    unsigned int WIN0_SCL_FACTOR_CBR;     //0x8c Win0 YRGB scaling up factor setting
+    unsigned int WIN0_SCL_OFFSET;         //0x90 Win0 Cbr scaling start point offset
+    unsigned int FIFO_WATER_MARK;         //0x94 Fifo water mark
+    unsigned int AXI_MS_ID;               //0x98 Axi master ID
+    unsigned int reserved0;               //0x9c
+    unsigned int REG_CFG_DONE;            //0xa0 REGISTER CONFIG FINISH
+    unsigned int reserved1[(0x100-0xa4)/4];
+    unsigned int MCU_BYPASS_WPORT;         //0x100 MCU BYPASS MODE, DATA Write Only Port
+    unsigned int reserved2[(0x200-0x104)/4];
+    unsigned int MCU_BYPASS_RPORT;         //0x200 MCU BYPASS MODE, DATA Read Only Port
+} LCDC_REG, *pLCDC_REG;
+
+#define Win2_LUT_ADDR 0x400
+#define DSP_LUT_ADDR  0x800
+
+//roate
+#define 	ROTATE_0		0
+#define 	ROTATE_90		90
+#define 	ROTATE_180		180
+#define 	ROTATE_270		270
+#define 	X_MIRROR		(1<<10)
+#define		Y_MIRROR		(1<<11)
+
+
+
+
+#define CalScale(x, y)	             (((u32)x*0x1000)/y)
+struct rk3066b_lcdc_device{
+	int id;
+	struct rk_lcdc_device_driver driver;
+	rk_screen *screen;
+	
+	LCDC_REG *preg;         // LCDC reg base address and backup reg 
+    	LCDC_REG regbak;
+
+	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
+	u32 reg_phy_base;       	// physical basic address of lcdc register
+	u32 len;               		// physical map length of lcdc register
+	spinlock_t  reg_lock;		//one time only one process allowed to config the register
+	int __iomem *dsp_lut_addr_base;
+	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
+	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
+
+	unsigned int		irq;
+
+	struct clk		*pd;				//lcdc power domain
+	struct clk		*hclk;				//lcdc AHP clk
+	struct clk		*dclk;				//lcdc dclk
+	struct clk		*aclk;				//lcdc share memory frequency
+	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
+	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
+	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
+	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
+	struct clk		*pd_display;		// display power domain
+	u32	pixclock;
+};
+
+struct lcdc_info{
+/*LCD CLK*/
+	struct rk3066b_lcdc_device lcdc0;
+	struct rk3066b_lcdc_device lcdc1;
+
+};
+
+
+struct win_set {
+	volatile u32 y_offset;
+	volatile u32 c_offset;
+};
+
+struct win0_par {
+    u32 refcount;
+    u32	pseudo_pal[16];
+    u32 y_offset;
+    u32 c_offset;
+    u32 xpos;         //size in panel
+    u32 ypos;
+    u32 xsize;        //start point in panel
+    u32 ysize;
+    enum data_format format;
+
+    wait_queue_head_t wait;
+    struct win_set mirror;
+    struct win_set displ;
+    struct win_set done;
+
+    u8 par_seted;
+    u8 addr_seted;
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/lcdc/rk30_lcdc.c b/drivers/video/rockchip/lcdc/rk30_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk30_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk30_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1748 @@
+/*
+ * drivers/video/rockchip/chips/rk30_lcdc.c
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *Author:yzq<yzq@rock-chips.com>
+ *	yxj<yxj@rock-chips.com>
+ *This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/earlysuspend.h>
+#include <asm/div64.h>
+#include <asm/uaccess.h>
+#include "rk30_lcdc.h"
+
+
+
+static int dbg_thresd = 0;
+module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
+#define DBG(level,x...) do { if(unlikely(dbg_thresd >= level)) printk(KERN_INFO x); } while (0)
+
+
+static int  rk30_lcdc_clk_enable(struct rk30_lcdc_device *lcdc_dev)
+{
+	if(!lcdc_dev->clk_on)
+	{
+		clk_enable(lcdc_dev->pd);
+		clk_enable(lcdc_dev->hclk);
+		clk_enable(lcdc_dev->dclk);
+		clk_enable(lcdc_dev->aclk);
+	
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 1;
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	printk("rk30 lcdc%d clk enable...\n",lcdc_dev->id);
+	
+	return 0;
+}
+
+static int rk30_lcdc_clk_disable(struct rk30_lcdc_device *lcdc_dev)
+{
+	if(lcdc_dev->clk_on)
+	{
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 0;
+		spin_unlock(&lcdc_dev->reg_lock);
+		mdelay(30);
+		clk_disable(lcdc_dev->dclk);
+		clk_disable(lcdc_dev->hclk);
+		clk_disable(lcdc_dev->aclk);
+		clk_disable(lcdc_dev->pd);
+	}
+	printk("rk30 lcdc%d clk disable...\n",lcdc_dev->id);
+	return 0;
+}
+
+static int rk30_lcdc_read_reg_defalut_cfg(struct rk30_lcdc_device *lcdc_dev)
+{
+	int reg = 0;
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		for(reg=SYS_CTRL0;reg<=DSP_VACT_ST_END_F1; reg +=4)
+		{
+			lcdc_readl(lcdc_dev,reg);
+		}
+		
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else   //clk already disabled 
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		
+	}
+
+	return 0;
+}
+static int rk30_lcdc_init(struct rk_lcdc_device_driver *dev_drv)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	if(lcdc_dev->id == 0) //lcdc0
+	{
+		lcdc_dev->pd = clk_get(NULL,"pd_lcdc0");
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
+	}
+	else if(lcdc_dev->id == 1)
+	{
+		lcdc_dev->pd = clk_get(NULL,"pd_lcdc1");
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc1");  
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc1");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc1");
+	}
+	else
+	{
+		printk(KERN_ERR "invalid lcdc device!\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
+    	{
+       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
+   	}
+	
+	rk30_lcdc_clk_enable(lcdc_dev);
+	rk30_lcdc_read_reg_defalut_cfg(lcdc_dev);
+	lcdc_msk_reg(lcdc_dev,SYS_CTRL0,m_HWC_CHANNEL_ID | m_WIN2_CHANNEL_ID | m_WIN1_CBR_CHANNEL_ID |
+		m_WIN1_YRGB_CHANNEL_ID | m_WIN0_CBR_CHANNEL1_ID | m_WIN0_YRGB_CHANNEL1_ID | 
+		m_WIN0_CBR_CHANNEL0_ID | m_WIN0_YRGB_CHANNEL0_ID,v_HWC_CHANNEL_ID(7) | 
+		v_WIN2_CHANNEL_ID(6) | v_WIN1_CBR_CHANNEL_ID(5) | v_WIN1_YRGB_CHANNEL_ID(4) | 
+		v_WIN0_CBR_CHANNEL1_ID(3) | v_WIN0_YRGB_CHANNEL1_ID(2) | v_WIN0_CBR_CHANNEL0_ID(1) |
+		v_WIN0_YRGB_CHANNEL0_ID(0));			//channel id ,just use default value
+	lcdc_writel(lcdc_dev,WIN0_SCL_FACTOR_YRGB,0x10001000);
+	lcdc_writel(lcdc_dev,WIN1_SCL_FACTOR_YRGB,0x10001000);
+	lcdc_set_bit(lcdc_dev,DSP_CTRL0, m_LCDC_AXICLK_AUTO_ENABLE);//eanble axi-clk auto gating for low power
+	lcdc_msk_reg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR | m_BUS_ERR_INT_CLEAR | m_LINE_FLAG_INT_EN |
+              m_FRM_START_INT_EN | m_HOR_START_INT_EN,v_FRM_START_INT_CLEAR(1) | v_BUS_ERR_INT_CLEAR(0) |
+              v_LINE_FLAG_INT_EN(0) | v_FRM_START_INT_EN(0) | v_HOR_START_INT_EN(0));  //enable frame start interrupt for sync
+              
+        if(dev_drv->cur_screen->dsp_lut)
+        {
+        	lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
+		lcdc_cfg_done(lcdc_dev);
+		msleep(25);
+		for(i=0;i<256;i++)
+		{
+			v = dev_drv->cur_screen->dsp_lut[i];
+			c = lcdc_dev->dsp_lut_addr_base+i;
+			writel_relaxed(v,c);
+			
+		}
+		lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
+        }
+	
+	lcdc_cfg_done(lcdc_dev);  // write any value to  REG_CFG_DONE let config become effective
+
+	rk30_lcdc_clk_disable(lcdc_dev);
+	
+	return 0;
+}
+
+static int rk30_lcdc_deinit(struct rk30_lcdc_device *lcdc_dev)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_HOR_START_INT_EN | m_FRM_START_INT_EN | 
+			m_LINE_FLAG_INT_EN | m_BUS_ERR_INT_EN,v_HOR_START_INT_EN(0) | v_FRM_START_INT_EN(0) | 
+			v_LINE_FLAG_INT_EN(0) | v_BUS_ERR_INT_EN(0));  //disable all lcdc interrupt
+		lcdc_set_bit(lcdc_dev,SYS_CTRL0,m_LCDC_STANDBY);
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else   //clk already disabled 
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	mdelay(1);
+	
+	return 0;
+}
+
+static int rk30_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
+{
+	int ret = -EINVAL;
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	rk_screen *screen = dev_drv->cur_screen;
+	u64 ft;
+	int fps;
+	u16 face;
+	u16 mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend;
+	u16 right_margin = screen->right_margin;
+	u16 lower_margin = screen->lower_margin;
+	u16 x_res = screen->x_res, y_res = screen->y_res;
+
+	
+	// set the rgb or mcu
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(screen->type==SCREEN_MCU)
+		{
+	    		lcdc_msk_reg(lcdc_dev, MCU_CTRL, m_MCU_OUTPUT_SELECT,v_MCU_OUTPUT_SELECT(1));
+			// set out format and mcu timing
+	   		mcu_total  = (screen->mcu_wrperiod*150*1000)/1000000;
+	    		if(mcu_total>31)    
+				mcu_total = 31;
+	   		if(mcu_total<3)    
+				mcu_total = 3;
+	    		mcu_rwstart = (mcu_total+1)/4 - 1;
+	    		mcu_rwend = ((mcu_total+1)*3)/4 - 1;
+	    		mcu_csstart = (mcu_rwstart>2) ? (mcu_rwstart-3) : (0);
+	    		mcu_csend = (mcu_rwend>15) ? (mcu_rwend-1) : (mcu_rwend);
+
+	    		//DBG(1,">> mcu_total=%d, mcu_rwstart=%d, mcu_csstart=%d, mcu_rwend=%d, mcu_csend=%d \n",
+	        	//	mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend);
+
+			// set horizontal & vertical out timing
+		
+		    	right_margin = x_res/6; 
+			screen->pixclock = 150000000; //mcu fix to 150 MHz
+			lcdc_msk_reg(lcdc_dev, MCU_CTRL,m_MCU_CS_ST | m_MCU_CS_END| m_MCU_RW_ST | m_MCU_RW_END |
+	             		m_MCU_WRITE_PERIOD | m_MCU_HOLDMODE_SELECT | m_MCU_HOLDMODE_FRAME_ST,
+	            		v_MCU_CS_ST(mcu_csstart) | v_MCU_CS_END(mcu_csend) | v_MCU_RW_ST(mcu_rwstart) |
+	            		v_MCU_RW_END(mcu_rwend) |  v_MCU_WRITE_PERIOD(mcu_total) |
+	            		v_MCU_HOLDMODE_SELECT((SCREEN_MCU==screen->type)?(1):(0)) | v_MCU_HOLDMODE_FRAME_ST(0));
+	
+		}
+
+		switch (screen->face)
+		{
+	        	case OUT_P565:
+	            		face = OUT_P565;
+	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_P666:
+	            		face = OUT_P666;
+	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_D888_P565:
+	            		face = OUT_P888;
+	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_D888_P666:
+	            		face = OUT_P888;
+	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_P888:
+	            		face = OUT_P888;
+	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(1));
+	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	default:
+	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
+	            		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		face = screen->face;
+	            		break;
+		}
+
+		//use default overlay,set vsyn hsync den dclk polarity
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
+	     		m_DEN_POLARITY |m_DCLK_POLARITY,v_DISPLAY_FORMAT(face) | 
+	     		v_HSYNC_POLARITY(screen->pin_hsync) | v_VSYNC_POLARITY(screen->pin_vsync) |
+	        	v_DEN_POLARITY(screen->pin_den) | v_DCLK_POLARITY(screen->pin_dclk));
+
+		//set background color to black,set swap according to the screen panel,disable blank mode
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BG_COLOR | m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_DELTA_SWAP | 
+		 	m_DUMMY_SWAP | m_BLANK_MODE,v_BG_COLOR(0x000000) | v_OUTPUT_RB_SWAP(screen->swap_rb) | 
+		 	v_OUTPUT_RG_SWAP(screen->swap_rg) | v_DELTA_SWAP(screen->swap_delta) | v_DUMMY_SWAP(screen->swap_dumy) |
+		 	v_BLACK_MODE(0));
+
+		
+		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
+	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
+		lcdc_writel(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
+	             v_HASP(screen->hsync_len + screen->left_margin));
+
+		lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
+	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
+		lcdc_writel(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
+	              v_VASP(screen->vsync_len + screen->upper_margin));
+		// let above to take effect
+		lcdc_cfg_done(lcdc_dev);
+	}
+ 	spin_unlock(&lcdc_dev->reg_lock);
+
+	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
+	if(ret)
+	{
+        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+	}
+    	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+		(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps;
+    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk),fps);
+
+    	if(screen->init)
+    	{
+    		screen->init();
+    	}
+	
+	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
+	return 0;
+}
+
+static int mcu_refresh(struct rk30_lcdc_device *lcdc_dev)
+{
+   
+    return 0;
+}
+
+
+
+//enable layer,open:1,enable;0 disable
+static int win0_open(struct rk30_lcdc_device *lcdc_dev,bool open)
+{
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				printk(KERN_INFO "lcdc%d wakeup from standby!\n",lcdc_dev->id);
+				lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else if((lcdc_dev->atv_layer_cnt > 0) && (!open))
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[0]->state = open;
+		
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL1, m_W0_EN, v_W0_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!\n",lcdc_dev->id);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		lcdc_cfg_done(lcdc_dev);	
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	
+	return 0;
+}
+static int win1_open(struct rk30_lcdc_device *lcdc_dev,bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				printk(KERN_INFO "lcdc%d wakeup from standby!\n",lcdc_dev->id);
+				lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else if((lcdc_dev->atv_layer_cnt > 0) && (!open))
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[1]->state = open;
+		
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL1, m_W1_EN, v_W1_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!\n",lcdc_dev->id);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static int win2_open(struct rk30_lcdc_device *lcdc_dev,bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				printk(KERN_INFO "lcdc%d wakeup from standby!",lcdc_dev->id);
+				lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else if((lcdc_dev->atv_layer_cnt > 0) && (!open))
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[1]->state = open;
+		
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL1, m_W2_EN, v_W2_EN(open));
+
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		
+		lcdc_writel(lcdc_dev, REG_CFG_DONE, 0x01);
+		lcdc_dev->driver.layer_par[1]->state = open;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static int rk30_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
+{
+	struct rk30_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk30_lcdc_device ,driver);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch(blank_mode)
+	    	{
+	    		case FB_BLANK_UNBLANK:
+	      			lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(0));
+				break;
+	    		case FB_BLANK_NORMAL:
+	         		lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+	    		default:
+				lcdc_msk_reg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+		}
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	dev_info(lcdc_drv->dev,"blank mode:%d\n",blank_mode);
+	
+    	return 0;
+}
+
+static  int win0_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_writel(lcdc_dev, WIN0_YRGB_MST0, y_addr);
+	    	lcdc_writel(lcdc_dev, WIN0_CBR_MST0, uv_addr);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+	
+}
+
+static  int win1_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_writel(lcdc_dev, WIN1_YRGB_MST, y_addr);
+	    	lcdc_writel(lcdc_dev, WIN1_CBR_MST, uv_addr);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static  int win2_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_writel(lcdc_dev, WIN2_MST, y_addr);
+		lcdc_writel(lcdc_dev, REG_CFG_DONE, 0x01); 
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static  int win0_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	u8 fmt_cfg = 0;
+	char fmt[9] = "NULL";
+	xact = par->xact;			    //active (origin) picture window width/height		
+	yact = par->yact;
+	xvir = par->xvir;			   // virtual resolution		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+   
+
+	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+
+	if((!xact) || (!yact) || (!par->xsize) || (!par->ysize))
+	{
+		dev_err(lcdc_dev->driver.dev,"invalid parameter for win0-->xact:%d yact:%d xsize:%d ysize:%d\n",
+			xact,yact,par->xsize,par->ysize);
+		return -EINVAL;
+	}	
+	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
+	ScaleYrgbY = CalScale(yact, par->ysize);
+	switch (par->format)
+	{
+		case ARGB888:
+		case XBGR888:
+		case ABGR888:
+	     		fmt_cfg = 0;
+			break;
+		case RGB888:
+			fmt_cfg = 1;
+			break;
+		case RGB565:
+			fmt_cfg = 2;
+			break;
+		case YUV422:// yuv422
+			fmt_cfg = 5;
+			ScaleCbrX = CalScale((xact/2), par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		case YUV420: // yuv420
+			fmt_cfg = 4;
+			ScaleCbrX = CalScale(xact/2, par->xsize);
+		   	ScaleCbrY = CalScale(yact/2, par->ysize);
+		   	break;
+		case YUV444:// yuv444
+			fmt_cfg = 6;
+			ScaleCbrX = CalScale(xact, par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		default:
+			printk("%s un supported format\n",__func__);
+		   	break;
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL1, m_W0_FORMAT, v_W0_FORMAT(fmt_cfg));		//(inf->video_mode==0)
+		lcdc_writel(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
+		lcdc_writel(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		lcdc_writel(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
+		//lcdc_msk_reg(lcdc_dev, WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
+		//	v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+		switch(par->format) 
+		{
+			case XBGR888:
+				lcdc_writel(lcdc_dev, WIN0_VIR,v_ARGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(1));
+				break;
+			case ARGB888:
+				lcdc_writel(lcdc_dev, WIN0_VIR,v_ARGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
+				break;
+			case ABGR888:
+				lcdc_writel(lcdc_dev, WIN0_VIR,v_ARGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(1));
+				break;
+			case RGB888:  //rgb888
+				lcdc_writel(lcdc_dev, WIN0_VIR,v_RGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
+				break;
+			case RGB565:  //rgb565
+				lcdc_writel(lcdc_dev, WIN0_VIR,v_RGB565_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
+				break;
+			case YUV422:
+			case YUV420:   
+				lcdc_writel(lcdc_dev, WIN0_VIR,v_YUV_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(0));
+				break;
+			default:
+				printk("%s:un supported format\n",__func__);
+				break;
+		}
+
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+    return 0;
+
+}
+
+static int win1_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	u8 fmt_cfg = 0;
+	char fmt[9];
+	xact = par->xact;			
+	yact = par->yact;
+	xvir = par->xvir;		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	
+	ScaleYrgbX = CalScale(xact, par->xsize);
+	ScaleYrgbY = CalScale(yact, par->ysize);
+	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+
+	if((!xact) || (!yact) || (!par->xsize) || (!par->ysize))
+	{
+		dev_err(lcdc_dev->driver.dev,"invalid parameter for win1-->xact:%d yact:%d xsize:%d ysize:%d\n",
+			xact,yact,par->xsize,par->ysize);
+		return -EINVAL;
+	}	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch (par->format)
+	 	{
+	 		case ARGB888:
+			case XBGR888:
+			case ABGR888:
+		     		fmt_cfg = 0;
+				break;
+			case RGB888:
+				fmt_cfg = 1;
+				break;
+			case RGB565:
+				fmt_cfg = 2;
+				break;
+			case YUV422:// yuv422
+				fmt_cfg = 5;
+				ScaleCbrX = CalScale((xact/2), par->xsize);
+				ScaleCbrY = CalScale(yact, par->ysize);
+				break;
+			case YUV420: // yuv420
+				fmt_cfg = 4;
+				ScaleCbrX = CalScale(xact/2, par->xsize);
+				ScaleCbrY = CalScale(yact/2, par->ysize);
+				break;
+			case YUV444:// yuv444
+				fmt_cfg = 6;
+				ScaleCbrX = CalScale(xact, par->xsize);
+				ScaleCbrY = CalScale(yact, par->ysize);
+				break;
+			default:
+				printk("%s:un supported format\n",__func__);
+				break;
+		}
+
+		lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
+		lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_CBR,  v_X_SCL_FACTOR(ScaleCbrX) | v_Y_SCL_FACTOR(ScaleCbrY));
+		lcdc_msk_reg(lcdc_dev,SYS_CTRL1, m_W1_FORMAT, v_W1_FORMAT(fmt_cfg));
+		lcdc_writel(lcdc_dev, WIN1_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
+		lcdc_writel(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		lcdc_writel(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
+		// enable win1 color key and set the color to black(rgb=0)
+		//lcdc_msk_reg(lcdc_dev, WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+		switch(par->format)
+	    	{
+	    		case XBGR888:
+				lcdc_writel(lcdc_dev, WIN1_VIR,v_ARGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+		        case ARGB888:
+				lcdc_writel(lcdc_dev, WIN1_VIR,v_ARGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
+				break;
+		        case RGB888:  //rgb888
+				lcdc_writel(lcdc_dev, WIN1_VIR,v_RGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
+				break;
+		        case RGB565:  //rgb565
+				lcdc_writel(lcdc_dev, WIN1_VIR,v_RGB565_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
+				break;
+		        case YUV422:
+		        case YUV420:   
+				lcdc_writel(lcdc_dev, WIN1_VIR,v_YUV_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(0));
+				break;
+		        default:
+				printk("%s:un supported formate\n",__func__);
+				break;
+	    	}
+		
+		lcdc_cfg_done(lcdc_dev); 
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+    return 0;
+}
+
+static int win2_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u8 fmt_cfg = 0;
+	char fmt[9];
+	
+	xact = par->xact;			
+	yact = par->yact;
+	xvir = par->xvir;		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	
+	
+	DBG(1,"%s for lcdc%d>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,get_format_string(par->format,fmt),xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+
+	if((!xact) || (!yact) || (!par->xsize) || (!par->ysize))
+	{
+		dev_err(lcdc_dev->driver.dev,"invalid parameter for win2-->xact:%d yact:%d xsize:%d ysize:%d\n",
+			xact,yact,par->xsize,par->ysize);
+		return -EINVAL;
+	}	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+
+		lcdc_writel(lcdc_dev, WIN2_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		lcdc_writel(lcdc_dev, WIN2_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
+		// enable win1 color key and set the color to black(rgb=0)
+		//lcdc_msk_reg(lcdc_dev, WIN2_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+		switch(par->format)
+	    	{
+	    		case XBGR888:
+				fmt_cfg = 0;
+				lcdc_writel(lcdc_dev, WIN2_VIR,v_ARGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(1));
+				break;
+		        case ARGB888:
+				fmt_cfg = 0;
+				lcdc_writel(lcdc_dev, WIN2_VIR,v_ARGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(0));
+				break;
+			case ABGR888:
+				fmt_cfg = 0;
+				lcdc_writel(lcdc_dev, WIN2_VIR,v_ARGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(1));
+				break;
+		        case RGB888:  //rgb888
+		        	fmt_cfg = 1;
+				lcdc_writel(lcdc_dev, WIN2_VIR,v_RGB888_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(0));
+				break;
+		        case RGB565:  //rgb565
+		        	fmt_cfg = 2;
+				lcdc_writel(lcdc_dev, WIN2_VIR,v_RGB565_VIRWIDTH(xvir));
+				lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_W2_RGB_RB_SWAP,v_W2_RGB_RB_SWAP(0));
+				break;
+		        default:
+				printk("%s:un supported format\n",__func__);
+				break;
+	    	}
+		
+		lcdc_msk_reg(lcdc_dev,SYS_CTRL1, m_W2_FORMAT, v_W2_FORMAT(fmt_cfg));
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+    return 0;
+}
+
+static int rk30_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
+{
+	int i=0;
+	int __iomem *c;
+	int v;
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	
+	//printk("%s>>open:%d>>cnt:%d\n",__func__,open,lcdc_dev->atv_layer_cnt);
+	if((open) && (!lcdc_dev->atv_layer_cnt)) //enable clk,when first layer open
+	{
+		rk30_lcdc_clk_enable(lcdc_dev);
+		memcpy((u8*)lcdc_dev->regs, (u8*)lcdc_dev->regsbak, 0xc4);  //resume reg
+		rk30_load_screen(dev_drv,1);
+		spin_lock(&lcdc_dev->reg_lock);
+		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
+		{
+			lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
+			lcdc_cfg_done(lcdc_dev);
+			mdelay(25);
+			for(i=0;i<256;i++)
+			{
+				v = dev_drv->cur_screen->dsp_lut[i];
+				c = lcdc_dev->dsp_lut_addr_base+i;
+				writel_relaxed(v,c);
+				
+			}
+			lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
+		}
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	
+	if(layer_id == 0)
+	{
+		win0_open(lcdc_dev,open);	
+	}
+	else if(layer_id == 1)
+	{
+		win1_open(lcdc_dev,open);
+	}
+	else if(layer_id == 2)
+	{
+		win2_open(lcdc_dev,open);
+	}
+
+	if((!open) && (!lcdc_dev->atv_layer_cnt))  //when all layer closed,disable clk
+	{
+		rk30_lcdc_clk_disable(lcdc_dev);
+	}
+
+	printk(KERN_INFO "lcdc%d win%d %s,atv layer:%d\n",
+		lcdc_dev->id,layer_id,open?"open":"closed",
+		lcdc_dev->atv_layer_cnt);
+	return 0;
+}
+
+static int rk30_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_set_par(lcdc_dev,screen,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_set_par(lcdc_dev,screen,par);
+	}
+	else if(layer_id == 2)
+	{
+		par = dev_drv->layer_par[2];
+        	win2_set_par(lcdc_dev,screen,par);
+	}
+	
+	return 0;
+}
+
+int rk30_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	unsigned long flags;
+	int timeout;
+	
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;	
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_display(lcdc_dev,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_display(lcdc_dev,par);
+	}
+	else if(layer_id == 2)
+	{
+		par = dev_drv->layer_par[2];
+        	win2_display(lcdc_dev,par);
+	}
+	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
+	{
+		dev_drv->first_frame = 0;
+		lcdc_msk_reg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR |m_FRM_START_INT_EN ,
+			  v_FRM_START_INT_CLEAR(1) | v_FRM_START_INT_EN(1));
+		lcdc_cfg_done(lcdc_dev);  // write any value to  REG_CFG_DONE let config become effective
+		 
+	}
+
+	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
+	{
+		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
+		if(!timeout&&(!dev_drv->frame_done.done))
+		{
+			printk(KERN_ERR "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	
+	return 0;
+}
+
+int rk30_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	int ret = 0;
+	struct color_key_cfg clr_key_cfg;
+	switch(cmd)
+	{
+		case RK_FBIOGET_PANEL_SIZE:    //get panel size
+                	panel_size[0] = dev_drv->screen0->x_res;
+                	panel_size[1] = dev_drv->screen0->y_res;
+            		if(copy_to_user(argp, panel_size, 8)) 
+				return -EFAULT;
+			break;
+		case RK_FBIOPUT_COLOR_KEY_CFG:
+			if(copy_from_user(&clr_key_cfg,argp,sizeof(struct color_key_cfg ))) 
+				return -EFAULT;
+			lcdc_writel(lcdc_dev,WIN0_COLOR_KEY_CTRL,clr_key_cfg.win0_color_key_cfg);
+			lcdc_writel(lcdc_dev,WIN1_COLOR_KEY_CTRL,clr_key_cfg.win1_color_key_cfg);
+			lcdc_writel(lcdc_dev,WIN2_COLOR_KEY_CTRL,clr_key_cfg.win2_color_key_cfg);
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+static int rk30_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	struct layer_par *par = dev_drv->layer_par[layer_id];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(layer_id == 0)
+		{
+			par->state = lcdc_read_bit(lcdc_dev,SYS_CTRL1,m_W0_EN);
+		}
+		else if( layer_id == 1)
+		{
+			par->state = lcdc_read_bit(lcdc_dev,SYS_CTRL1,m_W1_EN);
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return par->state;
+	
+}
+
+/***********************************
+overlay manager
+swap:1 win0 on the top of win1
+        0 win1 on the top of win0
+set  : 1 set overlay 
+        0 get overlay state
+************************************/
+static int rk30_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	int ovl;
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(set)  //set overlay
+		{
+			lcdc_msk_reg(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
+			lcdc_writel(lcdc_dev, REG_CFG_DONE, 0x01);
+			lcdc_cfg_done(lcdc_dev);
+			ovl = swap;
+		}
+		else  //get overlay
+		{
+			ovl = lcdc_read_bit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
+		}
+	}
+	else
+	{
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+
+static ssize_t  rk30_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id)
+{
+        struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	char format_w0[9]= "NULL";
+	char format_w1[9]= "NULL";
+	char format_w2[9]= "NULL";
+	char status_w0[9]= "NULL";
+	char status_w1[9]= "NULL";
+	char status_w2[9]= "NULL";
+	u32 fmt_id = lcdc_readl(lcdc_dev,SYS_CTRL1);
+	u32 act_info,dsp_info,dsp_st,factor;
+	u16 xvir_w0,x_act_w0,y_act_w0,x_dsp_w0,y_dsp_w0,x_st_w0,y_st_w0;
+	u16 xvir_w1,x_act_w1,y_act_w1,x_dsp_w1,y_dsp_w1,x_st_w1,y_st_w1;
+	u16 xvir_w2,x_dsp_w2,y_dsp_w2,x_st_w2,y_st_w2;
+	u16 x_scale_w0,y_scale_w0,x_scale_w1,y_scale_w1;
+	int ovl = lcdc_read_bit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
+
+	switch((fmt_id&m_W0_FORMAT)>>4)
+	{
+	case 0:
+	        strcpy(format_w0,"ARGB888");
+	        break;
+	case 1:
+	        strcpy(format_w0,"RGB888");
+	        break;
+	case 2:
+	        strcpy(format_w0,"RGB565");
+	        break;
+	case 4:
+	        strcpy(format_w0,"YCbCr420");
+	        break;
+	case 5:
+	        strcpy(format_w0,"YCbCr422");
+	        break;
+	case 6:
+	        strcpy(format_w0,"YCbCr444");
+	        break;
+	default:
+	        strcpy(format_w0,"inval\n");
+	        break;
+	}
+
+	
+	switch((fmt_id&m_W1_FORMAT)>>7)
+	{
+	case 0:
+		strcpy(format_w1,"ARGB888");
+		break;
+	case 1:
+		strcpy(format_w1,"RGB888");
+		break;
+	case 2:
+		strcpy(format_w1,"RGB565");
+		break;
+	case 4:
+		strcpy(format_w1,"YCbCr420");
+		break;
+	case 5:
+		strcpy(format_w1,"YCbCr422");
+		break;
+	case 6:
+		strcpy(format_w1,"YCbCr444");
+		break;
+	default:
+		strcpy(format_w1,"inval\n");
+		break;
+	}
+
+	switch((fmt_id&m_W2_FORMAT)>>10)
+	{
+	case 0:
+	        strcpy(format_w2,"ARGB888");
+	        break;
+	case 1:
+	        strcpy(format_w2,"RGB888");
+	        break;
+	case 2:
+	        strcpy(format_w2,"RGB565");
+	        break;
+	case 4:
+	        strcpy(format_w2,"8bpp");
+	        break;
+	        case 5:
+	        strcpy(format_w2,"4bpp");
+	        break;
+	case 6:
+	        strcpy(format_w2,"2bpp");
+	        break;
+	case 7:
+	        strcpy(format_w2,"1bpp");
+	        break;
+	default:
+	        strcpy(format_w2,"inval\n");
+	        break;
+	}
+
+	if(fmt_id&m_W0_EN)
+	{
+		strcpy(status_w0,"enabled");
+	}
+	else
+	{
+		strcpy(status_w0,"disabled");
+	}
+
+	if((fmt_id&m_W1_EN)>>1)
+	{
+		strcpy(status_w1,"enabled");
+	}
+	else
+	{
+		strcpy(status_w1,"disabled");
+	}
+
+	
+	if((fmt_id&m_W2_EN)>>1)
+	{
+		strcpy(status_w2,"enabled");
+	}
+	else
+	{
+		strcpy(status_w2,"disabled");
+	}
+	
+	xvir_w0 = lcdc_readl(lcdc_dev,WIN0_VIR)&0xffff;
+	act_info = lcdc_readl(lcdc_dev,WIN0_ACT_INFO);
+	dsp_info = lcdc_readl(lcdc_dev,WIN0_DSP_INFO);
+	dsp_st = lcdc_readl(lcdc_dev,WIN0_DSP_ST);
+	factor = lcdc_readl(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
+	x_act_w0 =  (act_info&0xffff) + 1;
+	y_act_w0 = (act_info>>16) + 1;
+	x_dsp_w0 = (dsp_info&0xffff) + 1;
+	y_dsp_w0 = (dsp_info>>16) + 1;
+	x_st_w0 = (dsp_st&0xfff);
+	y_st_w0 = (dsp_st>>16);
+	x_scale_w0 = 4096*100/(factor&0xffff);
+	y_scale_w0 = 4096*100/(factor>>16);
+	
+	xvir_w1= lcdc_readl(lcdc_dev,WIN1_VIR)&0xffff;
+	act_info = lcdc_readl(lcdc_dev,WIN1_ACT_INFO);
+	dsp_info = lcdc_readl(lcdc_dev,WIN1_DSP_INFO);
+	dsp_st = lcdc_readl(lcdc_dev,WIN1_DSP_ST);
+	factor = lcdc_readl(lcdc_dev,WIN1_SCL_FACTOR_YRGB);
+	x_act_w1= (act_info&0xffff) + 1;
+	y_act_w1 = (act_info>>16) + 1;
+	x_dsp_w1 = (dsp_info&0xffff) + 1;
+	y_dsp_w1= (dsp_info>>16) + 1;
+	x_st_w1 = (dsp_st&0xfff);
+	y_st_w1 = (dsp_st>>16);
+	x_scale_w1= 4096*100/(factor&0xffff);
+	y_scale_w1= 4096*100/(factor>>16);
+
+	xvir_w2 = lcdc_readl(lcdc_dev,WIN2_VIR)&0xffff;
+        dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO);
+        dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST);
+
+        x_dsp_w2 = dsp_info&0xffff;
+        y_dsp_w2 = dsp_info>>16;
+	x_st_w2 = dsp_st&0xfff;
+	y_st_w2 = dsp_st>>16;
+
+	
+	return snprintf(buf,PAGE_SIZE,
+			"win0:%s\n"
+			"xvir:%d\n"
+			"xact:%d\n"
+			"yact:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"x_scale:%d.%d\n"
+			"y_scale:%d.%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n"
+			"CBR buffer addr:0x%08x\n\n"
+			"win1:%s\n"
+			"xvir:%d\n"
+			"xact:%d\n"
+			"yact:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"x_scale:%d.%d\n"
+			"y_scale:%d.%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n"
+			"CBR buffer addr:0x%08x\n\n"
+			"overlay:%s\n\n"
+			"win2:%s\n"
+			"xvir:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n",
+			status_w0,
+			xvir_w0,
+			x_act_w0,
+			y_act_w0,
+			x_dsp_w0,
+			y_dsp_w0,
+			x_st_w0,
+			y_st_w0,
+			x_scale_w0/100,
+			x_scale_w0%100,
+			y_scale_w0/100,
+			y_scale_w0%100,
+			format_w0,
+			lcdc_readl(lcdc_dev,WIN0_YRGB_MST0),
+			lcdc_readl(lcdc_dev,WIN0_CBR_MST0),
+			status_w1,
+			xvir_w1,
+			x_act_w1,
+			y_act_w1,
+			x_dsp_w1,
+			y_dsp_w1,
+			x_st_w1,
+			y_st_w1,
+			x_scale_w1/100,
+			x_scale_w1%100,
+			y_scale_w1/100,
+			y_scale_w1%100,
+			format_w1,
+			lcdc_readl(lcdc_dev,WIN1_YRGB_MST),
+			lcdc_readl(lcdc_dev,WIN1_CBR_MST),
+			ovl ? "win0 on the top of win1\n":"win1 on the top of win0\n",
+			status_w2,
+			xvir_w2,
+			x_dsp_w2,
+			y_dsp_w2,
+			x_st_w2,
+			y_st_w2,
+			format_w2,
+			lcdc_readl(lcdc_dev,WIN2_MST));
+        return 0;
+}
+
+/*******************************************
+lcdc fps manager,set or get lcdc fps
+
+
+
+set:0 get
+     1 set
+********************************************/
+static int rk30_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	rk_screen * screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+
+	if(set)
+	{
+		ft = div_u64(1000000000000llu,fps);
+		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
+		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+		if(ret)
+		{
+	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+		}
+	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+			
+	}
+
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+	(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps ;  //one frame time in ms
+	return fps;
+}
+
+static int rk30_fb_layer_remap(struct rk_lcdc_device_driver *dev_drv,
+	enum fb_win_map_order order)
+{
+       mutex_lock(&dev_drv->fb_win_id_mutex);
+       if(order == FB_DEFAULT_ORDER )
+	{
+		order = FB0_WIN1_FB1_WIN0_FB2_WIN2;
+	}
+       dev_drv->fb2_win_id  = order/100;
+       dev_drv->fb1_win_id = (order/10)%10;
+       dev_drv->fb0_win_id = order%10;
+       mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+       printk("fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
+               dev_drv->fb2_win_id);
+
+       return 0;
+}
+
+static int rk30_fb_get_layer(struct rk_lcdc_device_driver *dev_drv,const char *id)
+{
+       int layer_id = 0;
+       mutex_lock(&dev_drv->fb_win_id_mutex);
+       if(!strcmp(id,"fb0")||!strcmp(id,"fb3"))
+       {
+               layer_id = dev_drv->fb0_win_id;
+       }
+       else if(!strcmp(id,"fb1")||!strcmp(id,"fb4"))
+       {
+               layer_id = dev_drv->fb1_win_id;
+       }
+       else if(!strcmp(id,"fb2")||!strcmp(id,"fb5"))
+       {
+               layer_id = dev_drv->fb2_win_id;
+       }
+       mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+       return  layer_id;
+}
+
+static int rk30_read_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
+{
+
+	return 0;
+}
+
+static int rk30_set_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
+{
+	int i=0;
+	int __iomem *c;
+	int v;
+	int ret = 0;
+
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	msleep(25);
+	if(dev_drv->cur_screen->dsp_lut)
+	{
+		for(i=0;i<256;i++)
+		{
+			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
+			c = lcdc_dev->dsp_lut_addr_base+i;
+			writel_relaxed(v,c);
+			
+		}
+	}
+	else
+	{
+		printk(KERN_WARNING "no buffer to backup lut data!\n");
+		ret =  -1;
+	}
+	lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
+	lcdc_cfg_done(lcdc_dev);
+
+	return ret;
+}
+int rk30_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+
+
+	if(dev_drv->screen0->standby)
+		dev_drv->screen0->standby(1);
+	if(dev_drv->screen_ctr_info->io_disable)
+		dev_drv->screen_ctr_info->io_disable();
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else  //clk already disabled
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+		
+	rk30_lcdc_clk_disable(lcdc_dev);
+
+	return 0;
+}
+
+
+int rk30_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
+{  
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	int i=0;
+	int __iomem *c;
+	int v;
+
+	if(dev_drv->screen_ctr_info->io_enable) 		//power on
+		dev_drv->screen_ctr_info->io_enable();
+		
+	if(lcdc_dev->atv_layer_cnt)
+	{
+		rk30_lcdc_clk_enable(lcdc_dev);
+		
+		memcpy((u8*)lcdc_dev->regs, (u8*)lcdc_dev->regsbak, 0xc4);  //resume reg
+
+		spin_lock(&lcdc_dev->reg_lock);
+		if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
+		{
+			lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
+			lcdc_cfg_done(lcdc_dev);
+			mdelay(25);
+			for(i=0;i<256;i++)
+			{
+				v = dev_drv->cur_screen->dsp_lut[i];
+				c = lcdc_dev->dsp_lut_addr_base+i;
+				writel_relaxed(v,c);
+				
+			}
+			lcdc_msk_reg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
+		}
+		
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+		lcdc_cfg_done(lcdc_dev);
+		
+		spin_unlock(&lcdc_dev->reg_lock);
+
+	}
+	
+	if(dev_drv->screen0->standby)
+		dev_drv->screen0->standby(0);	      //screen wake up
+		
+    	return 0;
+}
+
+
+static irqreturn_t rk30_lcdc_isr(int irq, void *dev_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = (struct rk30_lcdc_device *)dev_id;
+	ktime_t timestamp = ktime_get();
+	
+	lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+	//lcdc_cfg_done(lcdc_dev);
+	//lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
+ 
+	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
+	{
+		spin_lock(&(lcdc_dev->driver.cpl_lock));
+		complete(&(lcdc_dev->driver.frame_done));
+		spin_unlock(&(lcdc_dev->driver.cpl_lock));
+	}
+
+	lcdc_dev->driver.vsync_info.timestamp = timestamp;
+	wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
+	
+	return IRQ_HANDLED;
+}
+
+static struct layer_par lcdc_layer[] = {
+	[0] = {
+		.name  		= "win0",
+		.id		= 0,
+		.support_3d	= true,
+	},
+	[1] = {
+		.name  		= "win1",
+		.id		= 1,
+		.support_3d	= false,
+	},
+	[2] = {
+		.name  		= "win2",
+		.id		= 2,
+		.support_3d	= false,
+	},
+};
+
+static struct rk_lcdc_device_driver lcdc_driver = {
+	.name			= "lcdc",
+	.def_layer_par		= lcdc_layer,
+	.num_layer		= ARRAY_SIZE(lcdc_layer),
+	.open			= rk30_lcdc_open,
+	.init_lcdc		= rk30_lcdc_init,
+	.ioctl			= rk30_lcdc_ioctl,
+	.suspend		= rk30_lcdc_early_suspend,
+	.resume			= rk30_lcdc_early_resume,
+	.set_par       		= rk30_lcdc_set_par,
+	.blank         		= rk30_lcdc_blank,
+	.pan_display            = rk30_lcdc_pan_display,
+	.load_screen		= rk30_load_screen,
+	.get_layer_state	= rk30_lcdc_get_layer_state,
+	.ovl_mgr		= rk30_lcdc_ovl_mgr,
+	.get_disp_info		= rk30_lcdc_get_disp_info,
+	.fps_mgr		= rk30_lcdc_fps_mgr,
+	.fb_get_layer           = rk30_fb_get_layer,
+	.fb_layer_remap         = rk30_fb_layer_remap,
+	.set_dsp_lut            = rk30_set_dsp_lut,
+	.read_dsp_lut           = rk30_read_dsp_lut,
+};
+#ifdef CONFIG_PM
+static int rk30_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk30_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#else
+#define rk30_lcdc_suspend NULL
+#define rk30_lcdc_resume NULL
+#endif
+
+static int __devinit rk30_lcdc_probe (struct platform_device *pdev)
+{
+	struct rk30_lcdc_device *lcdc_dev=NULL;
+	rk_screen *screen;
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+	rk_screen *screen1;
+#endif
+	struct rk29fb_info *screen_ctr_info;
+	struct resource *res = NULL;
+	struct resource *mem;
+	int ret = 0;
+	
+	/*************Malloc rk30lcdc_inf and set it to pdev for drvdata**********/
+	lcdc_dev = kzalloc(sizeof(struct rk30_lcdc_device), GFP_KERNEL);
+    	if(!lcdc_dev)
+    	{
+        	dev_err(&pdev->dev, ">>rk30 lcdc device kmalloc fail!");
+        	return -ENOMEM;
+    	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->id = pdev->id;
+	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
+	screen =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
+	if(!screen)
+	{
+		dev_err(&pdev->dev, ">>rk30 lcdc screen kmalloc fail!");
+        	ret =  -ENOMEM;
+		goto err0;
+	}
+	else
+	{
+		lcdc_dev->screen = screen;
+		screen->lcdc_id = lcdc_dev->id;
+		screen->screen_id = 0;
+	}
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&&  (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
+	screen1 =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
+	if(!screen1)
+	{
+		dev_err(&pdev->dev, ">>rk30 lcdc screen1 kmalloc fail!");
+        	ret =  -ENOMEM;
+		goto err0;
+	}
+	screen1->lcdc_id = 1;
+	screen1->screen_id = 1;
+	printk("use lcdc%d and jetta implemention dual display!\n",lcdc_dev->id);
+	
+#endif
+	/****************get lcdc0 reg  *************************/
+	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
+	if (res == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+    	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
+    	if (mem == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
+	if (lcdc_dev->reg_vir_base == NULL)
+	{
+		dev_err(&pdev->dev, "cannot map IO\n");
+		ret = -ENXIO;
+		goto err2;
+	}
+	
+    	//lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
+    	lcdc_dev->regs = lcdc_dev->reg_vir_base;
+	lcdc_dev->regsbak = kzalloc(lcdc_dev->len,GFP_KERNEL);
+	if(!lcdc_dev->regsbak)
+	{
+		dev_err(&pdev->dev, "failed to map memory for reg backup!\n");
+	}
+	//lcdc_dev->dsp_lut_addr_base = &lcdc_dev->preg->DSP_LUT_ADDR;
+	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + DSP_LUT_ADDR);
+	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->regs);
+	lcdc_dev->driver.dev=&pdev->dev;
+	lcdc_dev->driver.screen0 = screen;
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& (defined(CONFIG_RK610_LVDS) || defined(CONFIG_RK616_LVDS))
+	lcdc_dev->driver.screen1 = screen1;
+#endif
+	lcdc_dev->driver.cur_screen = screen;
+	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
+	
+	spin_lock_init(&lcdc_dev->reg_lock);
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if(lcdc_dev->irq < 0)
+	{
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		goto err3;
+	}
+	ret = request_irq(lcdc_dev->irq, rk30_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
+	if (ret)
+	{
+	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
+	       ret = -EBUSY;
+	       goto err3;
+	}
+	
+	if(screen_ctr_info->set_screen_info)
+	{
+		screen_ctr_info->set_screen_info(screen,screen_ctr_info->lcd_info);
+		if(SCREEN_NULL==screen->type)
+		{
+			printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
+			ret = -ENODEV;
+		}
+		if(screen_ctr_info->io_init)
+			screen_ctr_info->io_init(NULL);
+	}
+	else
+	{
+		printk(KERN_WARNING "no display device on lcdc%d!?\n",lcdc_dev->id);
+		ret =  -ENODEV;
+		goto err4;
+	}
+	
+	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
+	if(ret < 0)
+	{
+		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
+		goto err4;
+	}
+	printk("rk30 lcdc%d probe ok!\n",lcdc_dev->id);
+
+	return 0;
+
+err4:
+	free_irq(lcdc_dev->irq,lcdc_dev);
+err3:	
+	iounmap(lcdc_dev->reg_vir_base);
+err2:
+	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
+err1:
+	kfree(screen);
+err0:
+	platform_set_drvdata(pdev, NULL);
+	kfree(lcdc_dev);
+	return ret;
+    
+}
+static int __devexit rk30_lcdc_remove(struct platform_device *pdev)
+{
+	struct rk30_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	rk_fb_unregister(&(lcdc_dev->driver));
+	rk30_lcdc_deinit(lcdc_dev);
+	iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);
+	return 0;
+}
+
+static void rk30_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct rk30_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	if(lcdc_dev->driver.cur_screen->standby) //standby the screen if necessary
+		lcdc_dev->driver.cur_screen->standby(1);
+	if(lcdc_dev->driver.screen_ctr_info->io_disable) //power off the screen if necessary
+		lcdc_dev->driver.screen_ctr_info->io_disable();
+	if(lcdc_dev->driver.cur_screen->sscreen_set) //turn off  lvds if necessary
+		lcdc_dev->driver.cur_screen->sscreen_set(lcdc_dev->driver.cur_screen , 0);
+	rk30_lcdc_deinit(lcdc_dev);
+	//rk_fb_unregister(&(lcdc_dev->driver));
+	
+	/*iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);*/
+}
+
+
+static struct platform_driver rk30lcdc_driver = {
+	.probe		= rk30_lcdc_probe,
+	.remove		= __devexit_p(rk30_lcdc_remove),
+	.driver		= {
+		.name	= "rk30-lcdc",
+		.owner	= THIS_MODULE,
+	},
+	.suspend	= rk30_lcdc_suspend,
+	.resume		= rk30_lcdc_resume,
+	.shutdown   = rk30_lcdc_shutdown,
+};
+
+static int __init rk30_lcdc_module_init(void)
+{
+	return platform_driver_register(&rk30lcdc_driver);
+}
+
+static void __exit rk30_lcdc_module_exit(void)
+{
+	platform_driver_unregister(&rk30lcdc_driver);
+}
+
+
+
+fs_initcall(rk30_lcdc_module_init);
+module_exit(rk30_lcdc_module_exit);
+
+
+
diff -Nupr a/drivers/video/rockchip/lcdc/rk30_lcdc.h b/drivers/video/rockchip/lcdc/rk30_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk30_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk30_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,700 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef RK30_LCDC_H_
+#define RK30_LCDC_H_
+
+#include<linux/rk_fb.h>
+
+
+#if 0
+#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
+#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
+#define LcdRdReg(inf, addr)             (inf->preg->addr)
+#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
+#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
+#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
+#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
+#define LCDC_REG_CFG_DONE()		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
+
+/********************************************************************
+**                                                          *
+********************************************************************/
+/* LCDC */
+
+typedef volatile struct tagLCDC_REG
+{
+    /* offset 0x00~0xc0 */
+	unsigned int SYS_CTRL0;               //0x00 system control register 0
+	unsigned int SYS_CTRL1;				  //0x04 system control register 1
+	unsigned int DSP_CTRL0;				 //0x08 display control register 0
+	unsigned int DSP_CTRL1;				 //0x0c display control register 1
+	unsigned int INT_STATUS;             //0x10 Interrupt status register
+	unsigned int MCU_CTRL ;				 //0x14 MCU mode contol register
+	unsigned int BLEND_CTRL;             //0x18 Blending control register
+	unsigned int WIN0_COLOR_KEY_CTRL;     //0x1c Win0 blending control register
+	unsigned int WIN1_COLOR_KEY_CTRL;     //0x20 Win1 blending control register
+	unsigned int WIN2_COLOR_KEY_CTRL;     //0x24 Win2 blending control register
+	unsigned int WIN0_YRGB_MST0;           //0x28 Win0 active YRGB memory start address0
+	unsigned int WIN0_CBR_MST0;            //0x2c Win0 active Cbr memory start address0
+	unsigned int WIN0_YRGB_MST1;           //0x30 Win0 active YRGB memory start address1
+	unsigned int WIN0_CBR_MST1;            //0x34 Win0 active Cbr memory start address1
+	unsigned int WIN0_VIR;                //0x38 WIN0 virtual display width/height
+	unsigned int WIN0_ACT_INFO;           //0x3C Win0 active window width/height
+	unsigned int WIN0_DSP_INFO;           //0x40 Win0 display width/height on panel
+	unsigned int WIN0_DSP_ST;             //0x44 Win0 display start point on panel
+	unsigned int WIN0_SCL_FACTOR_YRGB;    //0x48Win0 YRGB scaling  factor setting
+	unsigned int WIN0_SCL_FACTOR_CBR;     //0x4c Win0 YRGB scaling factor setting
+	unsigned int WIN0_SCL_OFFSET;         //0x50 Win0 Cbr scaling start point offset
+	unsigned int WIN1_YRGB_MST;           //0x54 Win1 active YRGB memory start address
+	unsigned int WIN1_CBR_MST;            //0x58 Win1 active Cbr memory start address
+	unsigned int WIN1_VIR;                //0x5c WIN1 virtual display width/height
+	unsigned int WIN1_ACT_INFO;           //0x60 Win1 active window width/height
+	unsigned int WIN1_DSP_INFO;           //0x64 Win1 display width/height on panel
+	unsigned int WIN1_DSP_ST;             //0x68 Win1 display start point on panel
+	unsigned int WIN1_SCL_FACTOR_YRGB;    //0x6c Win1 YRGB scaling  factor setting
+	unsigned int WIN1_SCL_FACTOR_CBR;     //0x70 Win1 YRGB scaling factor setting
+	unsigned int WIN1_SCL_OFFSET;         //0x74 Win1 Cbr scaling start point offset
+	unsigned int WIN2_MST;		 		  //0x78 win2 memort start address
+	unsigned int WIN2_VIR;				  //0x7c win2 virtual stride
+	unsigned int WIN2_DSP_INFO;           //0x80 Win2 display width/height on panel
+	unsigned int WIN2_DSP_ST;             //0x84 Win2 display start point on panel
+	unsigned int HWC_MST;                 //0x88 HWC memory start address
+	unsigned int HWC_DSP_ST;              //0x8C HWC display start point on panel
+	unsigned int HWC_COLOR_LUT0;          //0x90 Hardware cursor color 2b01 look up table 0
+	unsigned int HWC_COLOR_LUT1;          //0x94 Hardware cursor color 2b10 look up table 1
+	unsigned int HWC_COLOR_LUT2;          //0x98 Hardware cursor color 2b11 look up table 2
+	unsigned int DSP_HTOTAL_HS_END;       //0x9c Panel scanning horizontal width and hsync pulse end point
+	unsigned int DSP_HACT_ST_END;         //0xa0 Panel active horizontal scanning start/end point
+	unsigned int DSP_VTOTAL_VS_END;       //0xa4 Panel scanning vertical height and vsync pulse end point
+	unsigned int DSP_VACT_ST_END;         //0xa8 Panel active vertical scanning start/end point
+	unsigned int DSP_VS_ST_END_F1;        //0xac Vertical scanning start point and vsync pulse end point of even filed in interlace mode
+	unsigned int DSP_VACT_ST_END_F1;      //0xb0 Vertical scanning active start/end point of even filed in interlace mode
+	unsigned int reserved0[(0xc0-0xb4)/4];
+	unsigned int REG_CFG_DONE;            //0xc0 REGISTER CONFIG FINISH
+	unsigned int reserved1[(0x100-0xc4)/4];
+	unsigned int MCU_BYPASS_WPORT;         //0x100 MCU BYPASS MODE, DATA Write Only Port
+	unsigned int reserved2[(0x200-0x104)/4];
+	unsigned int MCU_BYPASS_RPORT;         //0x200 MCU BYPASS MODE, DATA Read Only Port   
+	unsigned int reserved3[(0x400-0x204)/4];
+	unsigned int WIN2_LUT_ADDR;
+	unsigned int reserved4[(0x800-0x404)/4];
+	unsigned int DSP_LUT_ADDR;
+  
+} LCDC_REG, *pLCDC_REG;
+
+#else
+
+#define SYS_CTRL0  	0x00			//0x00 system control register 0
+#define SYS_CTRL1	0x04			//0x04 system control register 1
+#define DSP_CTRL0	0x08			//0x08 display control register 0
+#define DSP_CTRL1	0x0c			//0x0c display control register 1
+#define INT_STATUS 	0x10            	//0x10 Interrupt status register
+#define MCU_CTRL	0x14			//0x14 MCU mode contol register
+#define BLEND_CTRL 	0x18           		//0x18 Blending control register
+#define WIN0_COLOR_KEY_CTRL	0x1c    	//0x1c Win0 blending control register
+#define WIN1_COLOR_KEY_CTRL 	0x20    	//0x20 Win1 blending control register
+#define WIN2_COLOR_KEY_CTRL 	0x24    	//0x24 Win2 blending control register
+#define WIN0_YRGB_MST0 		0x28          //0x28 Win0 active YRGB memory start address0
+#define WIN0_CBR_MST0 		0x2c           //0x2c Win0 active Cbr memory start address0
+#define WIN0_YRGB_MST1		0x30           //0x30 Win0 active YRGB memory start address1
+#define WIN0_CBR_MST1		0x34            //0x34 Win0 active Cbr memory start address1
+#define WIN0_VIR 		0x38              //0x38 WIN0 virtual display width/height
+#define WIN0_ACT_INFO		0x3c           //0x3C Win0 active window width/height
+#define WIN0_DSP_INFO 		0x40          //0x40 Win0 display width/height on panel
+#define WIN0_DSP_ST  		0x44          //0x44 Win0 display start point on panel
+#define WIN0_SCL_FACTOR_YRGB	0x48    //0x48Win0 YRGB scaling  factor setting
+#define WIN0_SCL_FACTOR_CBR 	0x4c    //0x4c Win0 YRGB scaling factor setting
+#define WIN0_SCL_OFFSET 	0x50        //0x50 Win0 Cbr scaling start point offset
+#define WIN1_YRGB_MST  		0x54       //0x54 Win1 active YRGB memory start address
+#define WIN1_CBR_MST		0x58       //0x58 Win1 active Cbr memory start address
+#define WIN1_VIR 		0x5c       //0x5c WIN1 virtual display width/height
+#define WIN1_ACT_INFO 		0x60          //0x60 Win1 active window width/height
+#define WIN1_DSP_INFO		0x64           //0x64 Win1 display width/height on panel
+#define WIN1_DSP_ST		0x68             //0x68 Win1 display start point on panel
+#define WIN1_SCL_FACTOR_YRGB    0x6c   //0x6c Win1 YRGB scaling  factor setting
+#define WIN1_SCL_FACTOR_CBR	0x70     //0x70 Win1 YRGB scaling factor setting
+#define WIN1_SCL_OFFSET 	0x74        //0x74 Win1 Cbr scaling start point offset
+#define WIN2_MST		0x78	 //0x78 win2 memort start address
+#define WIN2_VIR		0x7c	//0x7c win2 virtual stride
+#define WIN2_DSP_INFO 		0x80    //0x80 Win2 display width/height on panel
+#define WIN2_DSP_ST		0x84    //0x84 Win2 display start point on panel
+#define HWC_MST                 0x88	//0x88 HWC memory start address
+#define HWC_DSP_ST		0x8c    //0x8C HWC display start point on panel
+#define HWC_COLOR_LUT0 		0x90         //0x90 Hardware cursor color 2b01 look up table 0
+#define HWC_COLOR_LUT1		0x94          //0x94 Hardware cursor color 2b10 look up table 1
+#define HWC_COLOR_LUT2          0x98		//0x98 Hardware cursor color 2b11 look up table 2
+#define DSP_HTOTAL_HS_END       0x9c		//0x9c Panel scanning horizontal width and hsync pulse end point
+#define DSP_HACT_ST_END		0xa0         //0xa0 Panel active horizontal scanning start/end point
+#define DSP_VTOTAL_VS_END	0xa4       //0xa4 Panel scanning vertical height and vsync pulse end point
+#define DSP_VACT_ST_END		0xa8         //0xa8 Panel active vertical scanning start/end point
+#define DSP_VS_ST_END_F1 	0xac       //0xac Vertical scanning start point and vsync pulse end point of even filed in interlace mode
+#define DSP_VACT_ST_END_F1     	0xb0		//0xb0 Vertical scanning active start/end point of even filed in interlace mode
+#define REG_CFG_DONE		0xc0            //0xc0 REGISTER CONFIG FINISH
+#define MCU_BYPASS_WPORT 	0x100        //0x100 MCU BYPASS MODE, DATA Write Only Port
+#define MCU_BYPASS_RPORT        0x200		//0x200 MCU BYPASS MODE, DATA Read Only Port   
+#define WIN2_LUT_ADDR		0x400
+#define DSP_LUT_ADDR		0x800
+
+#if 0
+#define lcdc_writel(lcdc_dev,offset,v)  do { \
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	\
+	_pv += (offset >> 2);			\
+	writel_relaxed(v,lcdc_dev->regs+offset);\
+	*_pv = v;	\
+} while(0)
+
+#define lcdc_readl(lcdc_dev,offset)  		\
+	readl_relaxed(lcdc_dev->regs+offset)
+
+#define lcdc_read_bit(lcdc_dev,offset,msk) ( { \
+	u32 _v = readl_relaxed(lcdc_dev->regs+offset); \
+	_v &= msk;_v;	} )
+
+#define lcdc_set_bit(lcdc_dev,offset,msk) do {  \
+	u32* _pv = (u32*)lcdc_dev->regsbak;	\
+	_pv += (offset >> 2);				\
+	(*_pv) |= msk;				\
+	writel_relaxed(*_pv,lcdc_dev->regs + offset); \
+} while(0)
+
+#define lcdc_clr_bit(lcdc_dev,offset,msk) do{	\
+	u32* _pv = (u32*)lcdc_dev->regsbak;	\
+	_pv += (offset >> 2);				\
+	(*_pv) &= ~msk;				\
+	writel_relaxed(*_pv,lcdc_dev->regs + offset); \
+} while (0)
+
+#define lcdc_msk_reg(lcdc_dev,offset,msk,v) do {	\
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	\
+	_pv += (offset >> 2);			\
+	(*_pv) &= (~msk);				\
+	(*_pv) |= v;				\
+	writel_relaxed(*_pv,lcdc_dev->regs+offset);	\
+} while(0)
+
+#define lcdc_cfg_done(lcdc_dev) do{ \
+	writel_relaxed(0x01,lcdc_dev->regs+REG_CFG_DONE); \
+	dsb();						\
+} while(0)
+#endif
+#endif
+
+/* SYS_CONFIG */
+
+#define m_LCDC_DMA_STOP              (1<<0)
+#define m_LCDC_STANDBY               (1<<1)
+#define m_HWC_RELOAD_EN               (1<<2)
+#define m_W0_AXI_OUTSTANDING_DISABLE (1<<3) 
+#define m_W1_AXI_OUTSTANDING_DISABLE (1<<4)
+#define m_W2_AXI_OUTSTANDING_DISABLE (1<<5)
+#define m_DMA_BURST_LENGTH	      (3<<6)
+#define m_WIN0_YRGB_CHANNEL0_ID	      ((0x07)<<8)
+#define m_WIN0_CBR_CHANNEL0_ID	      ((0x07)<<11)
+#define m_WIN0_YRGB_CHANNEL1_ID	      ((0x07)<<14)
+#define m_WIN0_CBR_CHANNEL1_ID	      ((0x07)<<17)
+#define m_WIN1_YRGB_CHANNEL_ID	      ((0x07)<<20)
+#define m_WIN1_CBR_CHANNEL_ID	      ((0x07)<<23)
+#define m_WIN2_CHANNEL_ID	      ((0x07)<<26)
+#define m_HWC_CHANNEL_ID	      ((0x07)<<29)
+
+
+
+
+
+#define v_LCDC_DMA_STOP(x)              (((x)&1)<<0)
+#define v_LCDC_STANDBY(x)              (((x)&1)<<1)
+#define v_HWC_RELOAD_EN(x)             (((x)&1)<<2)
+#define v_W0_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<3)
+#define v_W1_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<4)
+#define v_W2_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<5)
+#define v_DMA_BURST_LENGTH(x)		(((x)&3)<<6)
+#define v_WIN0_YRGB_CHANNEL0_ID(x)	(((x)&7)<<8)
+#define v_WIN0_CBR_CHANNEL0_ID(x)	(((x)&7)<<11)
+#define v_WIN0_YRGB_CHANNEL1_ID(x)      (((x)&7)<<14)
+#define v_WIN0_CBR_CHANNEL1_ID(x)	(((x)&7)<<17)
+#define v_WIN1_YRGB_CHANNEL_ID(x)	(((x)&7)<<20)
+#define v_WIN1_CBR_CHANNEL_ID(x)	(((x)&7)<<23)
+#define v_WIN2_CHANNEL_ID(x)	        (((x)&7)<<26)
+#define v_HWC_CHANNEL_ID(x)	        (((x)&7)<<29)
+
+
+
+//LCDC_SYS_CTRL1
+#define m_W0_EN          (1<<0)
+#define m_W1_EN          (1<<1)
+#define m_W2_EN         (1<<2)
+#define m_HWC_EN         (1<<3)
+#define m_W0_FORMAT          (7<<4)
+#define m_W1_FORMAT          (7<<7)
+#define m_W2_FORMAT          (7<<10)
+#define m_HWC_COLOR_MODE     (1<<13)
+#define m_HWC_SIZE_SELET     (1<<14)
+#define m_W0_3D_MODE_EN      (1<<15)
+#define m_W0_3D_MODE_SELET    (7<<16)
+#define m_W0_RGB_RB_SWAP      (1<<19)
+#define m_W0_RGB_ALPHA_SWAP   (1<<20)
+#define m_W0_YRGB_M8_SWAP     (1<<21)
+#define m_W0_CBCR_SWAP        (1<<22)
+#define m_W1_RGB_RB_SWAP      (1<<23)
+#define m_W1_RGB_ALPHA_SWAP   (1<<24)
+#define m_W1_YRGB_M8_SWAP     (1<<25)
+#define m_W1_CBCR_SWAP        (1<<26)
+#define m_W2_RGB_RB_SWAP      (1<<27)
+#define m_W2_RGB_ALPHA_SWAP   (1<<28)
+#define m_W2_8pp_PALETTE_ENDIAN_SELECT (1<<29)
+#define m_W2_LUT_RAM_EN       (1<<30)
+#define m_DSP_LUT_RAM_EN      (1<<31)
+
+#define v_W0_EN(x)          (((x)&1)<<0)
+#define v_W1_EN(x)          (((x)&1)<<1)
+#define v_W2_EN(x)          (((x)&1)<<2)
+#define v_HWC_EN(x)         (((x)&1)<<3)
+#define v_W0_FORMAT(x)      (((x)&7)<<4)
+#define v_W1_FORMAT(x)      (((x)&7)<<7)
+#define v_W2_FORMAT(x)      (((x)&7)<<10)
+#define v_HWC_COLOR_MODE(x)     (((x)&1)<<13)
+#define v_HWC_SIZE_SELET(x)     (((x)&1)<<14)
+#define v_W0_3D_MODE_EN(x)     (((x)&1)<<15)
+#define v_W0_3D_MODE_SELET(x)    (((x)&3)<<16)
+#define v_W0_RGB_RB_SWAP(x)      (((x)&1)<<19)
+#define v_W0_RGB_ALPHA_SWAP(x)   (((x)&1)<<20)
+#define v_W0_YRGB_M8_SWAP(x)     (((x)&1)<<21)
+#define v_W0_CBCR_SWAP(x)       (((x)&1)<<22)
+#define v_W1_RGB_RB_SWAP(x)      (((x)&1)<<23)
+#define v_W1_RGB_ALPHA_SWAP(x)   (((x)&1)<<24)
+#define v_W1_YRGB_M8_SWAP(x)     (((x)&1)<<25)
+#define v_W1_CBCR_SWAP(x)       (((x)&1)<<26)
+#define v_W2_RGB_RB_SWAP(x)      (((x)&1)<<27)
+#define v_W2_RGB_ALPHA_SWAP(x)   (((x)&1)<<28)
+#define v_W2_8pp_PALETTE_ENDIAN_SELECT (((x)&1)<<29)
+#define v_W2_LUT_RAM_EN(x)      (((x)&1)<<30)
+#define v_DSP_LUT_RAM_EN(x)      (((x)&1)<<31)
+
+//LCDC_DSP_CTRL_REG0
+#define m_DISPLAY_FORMAT             (0x0f<<0)
+#define m_HSYNC_POLARITY             (1<<4)
+#define m_VSYNC_POLARITY             (1<<5)
+#define m_DEN_POLARITY               (1<<6)
+#define m_DCLK_POLARITY              (1<<7)
+#define m_W0W1_POSITION_SWAP         (1<<8)
+#define m_DITHER_UP_EN               (1<<9)
+#define m_DITHER_DOWN_MODE           (1<<10)
+#define m_DITHER_DOWN_EN             (1<<11)
+#define m_INTERLACE_DSP_EN           (1<<12)
+#define m_INTERLACE_FIELD_POLARITY   (1<<13)
+#define m_W0_INTERLACE_READ_MODE     (1<<14)
+#define m_W1_INTERLACE_READ_MODE     (1<<15)
+#define m_W2_INTERLACE_READ_MODE     (1<<16)
+#define m_W0_YRGB_DEFLICK_MODE       (1<<17)
+#define m_W0_CBR_DEFLICK_MODE        (1<<18)
+#define m_W1_YRGB_DEFLICK_MODE       (1<<19)
+#define m_W1_CBR_DEFLICK_MODE        (1<<20)
+#define m_W0_ALPHA_MODE              (1<<21)
+#define m_W1_ALPHA_MODE              (1<<22)
+#define m_W2_ALPHA_MODE              (1<<23)
+#define m_W0_COLOR_SPACE_CONVERSION  (3<<24)
+#define m_W1_COLOR_SPACE_CONVERSION  (3<<26)
+#define m_W2_COLOR_SPACE_CONVERSION  (1<<28)
+#define m_YCRCB_CLIP_EN              (1<<29)
+#define m_CBR_FILTER_656             (1<<30)
+#define m_LCDC_AXICLK_AUTO_ENABLE 	(1<<31) //eanble for low power
+
+#define v_DISPLAY_FORMAT(x)            (((x)&0xf)<<0)
+#define v_HSYNC_POLARITY(x)             (((x)&1)<<4)
+#define v_VSYNC_POLARITY(x)             (((x)&1)<<5)
+#define v_DEN_POLARITY(x)               (((x)&1)<<6)
+#define v_DCLK_POLARITY(x)              (((x)&1)<<7)
+#define v_W0W1_POSITION_SWAP(x)			(((x)&1)<<8)		
+#define v_DITHER_UP_EN(x)               (((x)&1)<<9)
+#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<10)
+#define v_DITHER_DOWN_EN(x)             (((x)&1)<<11)
+#define v_INTERLACE_DSP_EN(x)             (((x)&1)<<12)
+#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
+#define v_W0_INTERLACE_READ_MODE(x)     (((x)&1)<<14)
+#define v_W1_INTERLACE_READ_MODE(x)     (((x)&1)<<15)
+#define v_W2_INTERLACE_READ_MODE(x)     (((x)&1)<<16)
+#define v_W0_YRGB_DEFLICK_MODE(x)       (((x)&1)<<17)
+#define v_W0_CBR_DEFLICK_MODE(x)        (((x)&1)<<18)
+#define v_W1_YRGB_DEFLICK_MODE(x)       (((x)&1)<<19)
+#define v_W1_CBR_DEFLICK_MODE(x)        (((x)&1)<<20)
+#define v_W0_ALPHA_MODE(x)             (((x)&1)<<21)
+#define v_W1_ALPHA_MODE(x)              (((x)&1)<<22)
+#define v_W2_ALPHA_MODE(x)             (((x)&1)<<23)
+#define v_W0_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<24)
+#define v_W1_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<26)
+#define v_W2_COLOR_SPACE_CONVERSION(x)  (((x)&1)<<28)
+#define v_YCRCB_CLIP_EN(x)            (((x)&1)<<29)
+#define v_CBR_FILTER_656(x)             (((x)&1)<<30)
+#define v_LCDC_AXICLK_AUTO_ENABLE(x) 	(((x)&1)<<31) //eanble for low power
+
+//LCDC_DSP_CTRL_REG1
+#define m_BG_COLOR                    (0xffffff<<0)
+#define m_BG_B                        (0xff<<0)
+#define m_BG_G                        (0xff<<8)
+#define m_BG_R                        (0xff<<16)
+#define m_BLANK_MODE                  (1<<24)
+#define m_BLACK_MODE                  (1<<25)
+#define m_OUTPUT_BG_SWAP        	  (1<<26)
+#define m_OUTPUT_RB_SWAP        	  (1<<27)
+#define m_OUTPUT_RG_SWAP        	  (1<<28)
+#define m_DELTA_SWAP            	  (1<<29)
+#define m_DUMMY_SWAP            	  (1<<30)
+
+#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
+#define v_BG_B(x)                     (((x)&0xff)<<0)
+#define v_BG_G(x)                     (((x)&0xff)<<8)
+#define v_BG_R(x)                     (((x)&0xff)<<16)
+#define v_BLANK_MODE(x)               (((x)&1)<<24)
+#define v_BLACK_MODE(x)               (((x)&1)<<25)
+#define v_OUTPUT_BG_SWAP(x)        	  (((x)&1)<<26)
+#define v_OUTPUT_RB_SWAP(x)        	  (((x)&1)<<27)
+#define v_OUTPUT_RG_SWAP(x)        	  (((x)&1)<<28)
+#define v_DELTA_SWAP(x)            	  (((x)&1)<<29)
+#define v_DUMMY_SWAP(x)            	  (((x)&1)<<30)
+
+
+//LCDC_INT_STATUS
+#define v_HOR_START_INT_STA        (1<<0)  //status
+#define v_FRM_START_INT_STA        (1<<1)
+#define v_LINE_FLAG_INT_STA        (1<<2)
+#define v_BUS_ERR_INT_STA	   (1<<3)
+#define m_HOR_START_INT_EN     	   (1<<4)  //enable
+#define m_FRM_START_INT_EN          (1<<5)
+#define m_LINE_FLAG_INT_EN         (1<<6)
+#define m_BUS_ERR_INT_EN	   (1<<7)
+#define m_HOR_START_INT_CLEAR      (1<<8) //auto clear
+#define m_FRM_START_INT_CLEAR      (1<<9)
+#define m_LINE_FLAG_INT_CLEAR      (1<<10)
+#define m_BUS_ERR_INT_CLEAR        (1<<11)
+#define m_LINE_FLAG_NUM		   (0xfff<<12)
+#define v_HOR_START_INT_EN(x)      (((x)&1)<<4)
+#define v_FRM_START_INT_EN(x)      (((x)&1)<<5)
+#define v_LINE_FLAG_INT_EN(x)      (((x)&1)<<6)
+#define v_BUS_ERR_INT_EN(x)	   (((x)&1)<<7)
+#define v_HOR_START_INT_CLEAR(x)      (((x)&1)<<8)
+#define v_FRM_START_INT_CLEAR(x)     (((x)&1)<<9)
+#define v_LINE_FLAG_INT_CLEAR(x)     (((x)&1)<<10)
+#define v_BUS_ERR_INT_CLEAR(x)        (((x)&1)<<11)
+#define v_LINE_FLAG_NUM(x)	   (((x)&0xfff)<<12)
+
+
+
+//LCDC_MCU_TIMING_CTRL
+#define m_MCU_WRITE_PERIOD      (0x3f<<0)
+#define m_MCU_CS_ST             (0xf<<6)
+#define m_MCU_CS_END            (0x3f<<10)
+#define m_MCU_RW_ST             (0xf<<16)
+#define m_MCU_RW_END            (0x3f<<20)
+#define m_MCU_BPS_CLK_SEL		(1<<26)
+#define m_MCU_HOLDMODE_SELECT     (1<<27)
+#define m_MCU_HOLDMODE_FRAME_ST   (1<<28)
+#define m_MCU_RS_SELECT            (1<<29)
+#define m_MCU_BYPASSMODE_SELECT   (1<<30)
+#define m_MCU_OUTPUT_SELECT        (1<<31)
+#define v_MCU_WRITE_PERIOD(x)      (((x)&0x3f)<<0)
+#define v_MCU_CS_ST(x)          (((x)&0xf)<<6)
+#define v_MCU_CS_END(x)         (((x)&0x3f)<<10)
+#define v_MCU_RW_ST(x)          (((x)&0xf)<<16)
+#define v_MCU_RW_END(x)         (((x)&0x3f)<<20)
+#define v_MCU_BPS_CLK_SEL	(((x)&1)<<26)
+#define v_MCU_HOLDMODE_SELECT(x)     (((x)&1)<<27)
+#define v_MCU_HOLDMODE_FRAME_ST(x)   (((x)&1)<<28)
+#define v_MCU_RS_SELECT(x)            (((x)&1)<<29)
+#define v_MCU_BYPASSMODE_SELECT(x)   (((x)&1)<<30)
+#define v_MCU_OUTPUT_SELECT(x)        (((x)&1)<<31)
+
+//LCDC_ BLEND_CTRL
+#define m_W0_BLEND_EN         (1<<0)
+#define m_W1_BLEND_EN          (1<<1)
+#define m_W2_BLEND_EN          (1<<2)
+#define m_HWC_BLEND_EN          (1<<3)
+#define m_W0_BLEND_FACTOR     (15<<4)
+#define m_W1_BLEND_FACTOR     (0xff<<8)
+#define m_W2_BLEND_FACTOR     (0xff<<16)
+#define m_HWC_BLEND_FACTOR     (0xff<<24)
+
+#define v_W0_BLEND_EN(x)         (((x)&1)<<0)
+#define v_W1_BLEND_EN(x)          (((x)&1)<<1)
+#define v_W2_BLEND_EN(x)          (((x)&1)<<2)
+#define v_HWC_BLEND_EN(x)          (((x)&1)<<3)
+#define v_W0_BLEND_FACTOR(x)    (((x)&15)<<4)
+#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<8)
+#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<16)
+#define v_HWC_BLEND_FACTOR(x)     (((x)&0xff)<<24)
+
+
+//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
+#define m_KEYCOLOR          (0xffffff<<0)
+#define m_KEYCOLOR_B          (0xff<<0)
+#define m_KEYCOLOR_G          (0xff<<8)
+#define m_KEYCOLOR_R          (0xff<<16)
+#define m_COLORKEY_EN         (1<<24)
+#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
+#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
+#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
+#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
+#define v_COLORKEY_EN(x)         (((x)&1)<<24)
+
+//LCDC_DEFLICKER_SCL_OFFSET
+#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
+#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
+#define m_W1_VSD_OFFSET           (0xff<<16)
+#define m_W1_VSP_OFFSET           (0xff<<24)
+#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
+#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
+#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
+#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
+
+
+
+
+
+//AXI MS ID
+#define m_W0_YRGB_CH_ID        (0xF<<0)
+#define m_W0_CBR_CH_ID         (0xF<<4)
+#define m_W1_YRGB_CH_ID        (0xF<<8)
+#define m_W2_CH_ID             (0xF<<12)
+#define m_HWC_CH_ID            (0xF<<16)
+#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
+#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
+#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
+#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
+#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
+
+
+/* Low Bits Mask */
+#define m_WORDLO            (0xffff<<0)
+#define m_WORDHI            (0xffff<<16)
+#define v_WORDLO(x)         (((x)&0xffff)<<0)
+#define v_WORDHI(x)         (((x)&0xffff)<<16)
+
+
+//LCDC_WINx_SCL_FACTOR_Y/CBCR
+#define v_X_SCL_FACTOR(x)  ((x)<<0)
+#define v_Y_SCL_FACTOR(x)  ((x)<<16)
+
+//LCDC_DSP_HTOTAL_HS_END
+#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
+#define v_HORPRD(x) ((x)<<16)   //horizontal period
+
+
+//LCDC_DSP_HACT_ST_END
+#define v_HAEP(x) ((x)<<0)  //horizontal active end point
+#define v_HASP(x) ((x)<<16) //horizontal active start point
+
+//LCDC_DSP_VTOTAL_VS_END
+#define v_VSYNC(x) ((x)<<0)
+#define v_VERPRD(x) ((x)<<16)
+
+//LCDC_DSP_VACT_ST_END
+#define v_VAEP(x) ((x)<<0)
+#define v_VASP(x) ((x)<<16)
+
+
+//LCDC_WINx_VIR ,x is number of words of win0 virtual width
+#define v_ARGB888_VIRWIDTH(x) (x)
+#define v_RGB888_VIRWIDTH(x) (((x*3)>>2)+((x)%3))
+#define v_RGB565_VIRWIDTH(x) (((x)>>1) + ((x%2)?1:0))
+#define v_YUV_VIRWIDTH(x)    (((x)>>2) +((x%4)?1:0))
+
+#define m_ACTWIDTH       (0xffff<<0)
+#define m_ACTHEIGHT      (0xffff<<16)
+#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
+#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
+
+#define m_VIRST_X      (0xffff<<0)
+#define m_VIRST_Y      (0xffff<<16)
+#define v_VIRST_X(x)      (((x)&0xffff)<<0)
+#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
+
+#define m_PANELST_X      (0x3ff<<0)
+#define m_PANELST_Y      (0x3ff<<16)
+#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
+#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
+
+#define m_PANELWIDTH       (0x3ff<<0)
+#define m_PANELHEIGHT      (0x3ff<<16)
+#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
+#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
+
+#define m_HWC_B                 (0xff<<0)
+#define m_HWC_G                 (0xff<<8)
+#define m_HWC_R                 (0xff<<16)
+#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
+#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
+#define v_HWC_B(x)                 (((x)&0xff)<<0)
+#define v_HWC_G(x)                 (((x)&0xff)<<8)
+#define v_HWC_R(x)                 (((x)&0xff)<<16)
+#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
+#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
+
+//LCDC_WIN0_ACT_INFO
+#define v_ACT_WIDTH(x)     ((x-1)<<0)
+#define v_ACT_HEIGHT(x)    ((x-1)<<16)
+
+//LCDC_WIN0_DSP_INFO
+#define v_DSP_WIDTH(x)     ((x-1)<<0)
+#define v_DSP_HEIGHT(x)    ((x-1)<<16)
+
+//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
+#define v_DSP_STX(x)      (x<<0)
+#define v_DSP_STY(x)      (x<<16)
+
+//Panel display scanning
+#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
+
+#define m_PANEL_END              (0x3ff<<0)
+#define m_PANEL_START            (0x3ff<<16)
+#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
+#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
+
+#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
+//-----------
+
+#define m_HSCALE_FACTOR        (0xffff<<0)
+#define m_VSCALE_FACTOR        (0xffff<<16)
+#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
+#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
+
+#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
+#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
+#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
+#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
+#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
+#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
+#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
+#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
+
+
+
+#define CalScale(x, y)	             (((u32)x*0x1000)/y)
+struct rk30_lcdc_device{
+	int id;
+	struct rk_lcdc_device_driver driver;
+	rk_screen *screen;
+	
+	//LCDC_REG *preg;         // LCDC reg base address and backup reg 
+    	//LCDC_REG regbak;
+    	void __iomem *regs;
+	void *regsbak;		//back up reg
+	int __iomem *dsp_lut_addr_base;
+
+	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
+	u32 reg_phy_base;       	// physical basic address of lcdc register
+	u32 len;               		// physical map length of lcdc register
+	spinlock_t  reg_lock;		//one time only one process allowed to config the register
+	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
+	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
+	
+	unsigned int		irq;
+
+	struct clk		*pd;				//lcdc power domain
+	struct clk		*hclk;				//lcdc AHP clk
+	struct clk		*dclk;				//lcdc dclk
+	struct clk		*aclk;				//lcdc share memory frequency
+	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
+	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
+	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
+	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
+	struct clk		*pd_display;		// display power domain
+	u32	pixclock;
+};
+
+struct lcdc_info{
+/*LCD CLK*/
+	struct rk30_lcdc_device lcdc0;
+	struct rk30_lcdc_device lcdc1;
+
+};
+
+
+struct win_set {
+	volatile u32 y_offset;
+	volatile u32 c_offset;
+};
+
+struct win0_par {
+    u32 refcount;
+    u32	pseudo_pal[16];
+    u32 y_offset;
+    u32 c_offset;
+    u32 xpos;         //size in panel
+    u32 ypos;
+    u32 xsize;        //start point in panel
+    u32 ysize;
+    enum data_format format;
+
+    wait_queue_head_t wait;
+    struct win_set mirror;
+    struct win_set displ;
+    struct win_set done;
+
+    u8 par_seted;
+    u8 addr_seted;
+};
+
+
+static inline void lcdc_writel(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 v)
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);	
+	*_pv = v;
+	writel_relaxed(v,lcdc_dev->regs+offset);	
+}
+
+static inline u32 lcdc_readl(struct rk30_lcdc_device *lcdc_dev,u32 offset)
+{
+	u32 v;
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);
+	v = readl_relaxed(lcdc_dev->regs+offset);
+	*_pv = v;
+	return v;
+}
+
+static inline u32 lcdc_read_bit(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 msk) 
+{
+       u32 _v = readl_relaxed(lcdc_dev->regs+offset); 
+       _v &= msk;
+       return (_v >> msk);   
+}
+
+static inline void  lcdc_set_bit(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 msk) 
+{
+	u32* _pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);				
+	(*_pv) |= msk;				
+	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
+} 
+
+static inline void lcdc_clr_bit(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 msk)
+{
+	u32* _pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);				
+	(*_pv) &= (~msk);				
+	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
+} 
+
+static inline void  lcdc_msk_reg(struct rk30_lcdc_device *lcdc_dev,u32 offset,u32 msk,u32 v)
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);			
+	(*_pv) &= (~msk);				
+	(*_pv) |= v;				
+	writel_relaxed(*_pv,lcdc_dev->regs+offset);	
+}
+
+static inline void lcdc_cfg_done(struct rk30_lcdc_device *lcdc_dev) 
+{
+	writel_relaxed(0x01,lcdc_dev->regs+REG_CFG_DONE); 
+	dsb();						
+} 
+
+#endif
+
+
diff -Nupr a/drivers/video/rockchip/lcdc/rk312x_lcdc.c b/drivers/video/rockchip/lcdc/rk312x_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk312x_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk312x_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2781 @@
+/*
+ * drivers/video/rockchip/lcdc/rk312x_lcdc.c
+ *
+ * Copyright (C) 2014 ROCKCHIP, Inc.
+ * Author:      zhuangwenlong<zwl@rock-chips.com>
+ *              zhengyang<zhengyang@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <asm/div64.h>
+#include <linux/uaccess.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/iomap.h>
+#include <linux/rockchip/grf.h>
+#include <linux/rockchip/common.h>
+#include <dt-bindings/clock/rk_system_status.h>
+#include <linux/rockchip-iovmm.h>
+#include "rk312x_lcdc.h"
+#include <linux/rockchip/dvfs.h>
+
+static int dbg_thresd;
+module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
+
+#define DBG(level, x...) do {			\
+	if (unlikely(dbg_thresd >= level))	\
+		pr_info(KERN_INFO x); \
+			} while (0)
+
+#define grf_writel(offset, v)	do { \
+			writel_relaxed(v, RK_GRF_VIRT + offset); \
+			dsb(); \
+			} while (0)
+
+static struct rk_lcdc_win lcdc_win[] = {
+	[0] = {
+	       .name = "win0",
+	       .id = 0,
+	       .support_3d = false,
+	       },
+	[1] = {
+	       .name = "win1",
+	       .id = 1,
+	       .support_3d = false,
+	       },
+	[2] = {
+	       .name = "hwc",
+	       .id = 2,
+	       .support_3d = false,
+	       },
+};
+
+static irqreturn_t rk312x_lcdc_isr(int irq, void *dev_id)
+{
+	struct lcdc_device *lcdc_dev = (struct lcdc_device *)dev_id;
+	ktime_t timestamp = ktime_get();
+	u32 int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
+	u32 irq_active = 0;
+
+	irq_active = int_reg & INT_STA_MSK;
+	if (irq_active)
+		lcdc_writel(lcdc_dev, INT_STATUS,
+			    int_reg | (irq_active << INT_CLR_SHIFT));
+
+	if (int_reg & m_FS_INT_STA) {
+		timestamp = ktime_get();
+
+		/*if (lcdc_dev->driver.wait_fs) {*/
+		if (0) {
+			spin_lock(&(lcdc_dev->driver.cpl_lock));
+			complete(&(lcdc_dev->driver.frame_done));
+			spin_unlock(&(lcdc_dev->driver.cpl_lock));
+		}
+		lcdc_dev->driver.vsync_info.timestamp = timestamp;
+		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
+	}
+
+	if (int_reg & m_LF_INT_STA) {
+		lcdc_dev->driver.frame_time.last_framedone_t =
+				lcdc_dev->driver.frame_time.framedone_t;
+		lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
+	}
+
+	if (int_reg & m_HS_INT_STA) {
+		spin_lock(&lcdc_dev->driver.cpl_lock);
+		complete(&lcdc_dev->driver.frame_done);
+		spin_unlock(&lcdc_dev->driver.cpl_lock);
+	}
+
+#ifdef LCDC_IRQ_EMPTY_DEBUG
+	if (int_reg & m_WIN0_EMPTY_INT_STA) {
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_WIN0_EMPTY_INT_CLEAR,
+			     v_WIN0_EMPTY_INT_CLEAR(1));
+		dev_info(lcdc_dev->dev, "win0 empty irq\n");
+	} else if (int_reg & m_WIN1_EMPTY_INT_STA) {
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_WIN1_EMPTY_INT_CLEAR,
+			     v_WIN1_EMPTY_INT_CLEAR(1));
+		dev_info(lcdc_dev->dev, "win1 empty irq\n");
+	}
+#endif
+
+	return IRQ_HANDLED;
+}
+
+static int rk312x_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
+{
+#ifdef CONFIG_RK_FPGA
+	lcdc_dev->clk_on = 1;
+	return 0;
+#endif
+	if (!lcdc_dev->clk_on) {
+		clk_prepare_enable(lcdc_dev->hclk);
+		clk_prepare_enable(lcdc_dev->dclk);
+		clk_prepare_enable(lcdc_dev->aclk);
+		clk_prepare_enable(lcdc_dev->pd);
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 1;
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int rk312x_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
+{
+#ifdef CONFIG_RK_FPGA
+	lcdc_dev->clk_on = 0;
+	return 0;
+#endif
+	if (lcdc_dev->clk_on) {
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 0;
+		spin_unlock(&lcdc_dev->reg_lock);
+		mdelay(25);
+		clk_disable_unprepare(lcdc_dev->dclk);
+		clk_disable_unprepare(lcdc_dev->hclk);
+		clk_disable_unprepare(lcdc_dev->aclk);
+		clk_disable_unprepare(lcdc_dev->pd);
+	}
+
+	return 0;
+}
+
+static int rk312x_lcdc_enable_irq(struct rk_lcdc_driver *dev_drv)
+{
+	u32 mask, val;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	/*struct rk_screen *screen = dev_drv->cur_screen;*/
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+			mask = m_FS_INT_CLEAR | m_FS_INT_EN |
+			m_LF_INT_CLEAR | m_LF_INT_EN |
+			m_HS_INT_CLEAR | m_HS_INT_EN |
+			m_BUS_ERR_INT_CLEAR | m_BUS_ERR_INT_EN;
+		val = v_FS_INT_CLEAR(1) | v_FS_INT_EN(1) |
+			v_LF_INT_CLEAR(1) | v_LF_INT_EN(1) |
+			v_HS_INT_CLEAR(1) | v_HS_INT_EN(1) |
+			v_BUS_ERR_INT_CLEAR(1) | v_BUS_ERR_INT_EN(0);
+		#if 0
+			mask |= m_LF_INT_NUM;
+			val  |= v_LF_INT_NUM(screen->mode.vsync_len +
+						screen->mode.upper_margin +
+						screen->mode.yres)
+		#endif
+#ifdef LCDC_IRQ_EMPTY_DEBUG
+		mask |= m_WIN0_EMPTY_INT_EN | m_WIN1_EMPTY_INT_EN;
+		val |= v_WIN0_EMPTY_INT_EN(1) | v_WIN1_EMPTY_INT_EN(1);
+#endif
+
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int rk312x_lcdc_disable_irq(struct lcdc_device *lcdc_dev)
+{
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		mask = m_FS_INT_CLEAR | m_FS_INT_EN |
+			m_LF_INT_CLEAR | m_LF_INT_EN |
+			m_HS_INT_CLEAR | m_HS_INT_EN |
+			m_BUS_ERR_INT_CLEAR | m_BUS_ERR_INT_EN;
+		val = v_FS_INT_CLEAR(0) | v_FS_INT_EN(0) |
+			v_LF_INT_CLEAR(0) | v_LF_INT_EN(0) |
+			v_HS_INT_CLEAR(0) | v_HS_INT_EN(0) |
+			v_BUS_ERR_INT_CLEAR(0) | v_BUS_ERR_INT_EN(0);
+#ifdef LCDC_IRQ_EMPTY_DEBUG
+		mask |= m_WIN0_EMPTY_INT_EN | m_WIN1_EMPTY_INT_EN;
+		val |= v_WIN0_EMPTY_INT_EN(0) | v_WIN1_EMPTY_INT_EN(0);
+#endif
+
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	mdelay(1);
+	return 0;
+}
+
+
+static int win0_set_addr(struct lcdc_device *lcdc_dev, u32 addr)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	lcdc_writel(lcdc_dev, WIN0_YRGB_MST, addr);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN, v_WIN0_EN(1));
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int win1_set_addr(struct lcdc_device *lcdc_dev, u32 addr)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->soc_type == VOP_RK3036)
+		lcdc_writel(lcdc_dev, WIN1_MST, addr);
+	else
+		lcdc_writel(lcdc_dev, WIN1_MST_RK312X, addr);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN, v_WIN1_EN(1));
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+int rk312x_lcdc_direct_set_win_addr(struct rk_lcdc_driver *dev_drv,
+				    int win_id, u32 addr)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+				struct lcdc_device, driver);
+	if (win_id == 0)
+		win0_set_addr(lcdc_dev, addr);
+	else
+		win1_set_addr(lcdc_dev, addr);
+
+	return 0;
+}
+
+static void rk_lcdc_read_reg_defalut_cfg(struct lcdc_device *lcdc_dev)
+{
+	int reg = 0;
+	u32 val = 0;
+	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
+	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	for (reg = 0; reg < 0xe0; reg += 4) {
+		val = lcdc_readl_backup(lcdc_dev, reg);
+		if (reg == WIN0_ACT_INFO) {
+			win0->area[0].xact = (val & m_ACT_WIDTH)+1;
+			win0->area[0].yact = ((val & m_ACT_HEIGHT)>>16)+1;
+		}
+
+		if (lcdc_dev->soc_type == VOP_RK312X) {
+			if (reg == WIN1_DSP_INFO_RK312X) {
+				win1->area[0].xact = (val & m_DSP_WIDTH) + 1;
+				win1->area[0].yact =
+					((val & m_DSP_HEIGHT) >> 16) + 1;
+			}
+		} else {
+			if (reg == WIN1_ACT_INFO) {
+				win1->area[0].xact = (val & m_ACT_WIDTH) + 1;
+				win1->area[0].yact =
+					((val & m_ACT_HEIGHT) >> 16) + 1;
+			}
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+}
+
+static int rk312x_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
+{
+	int win0_top = 0;
+	u32 mask, val;
+	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
+	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
+
+	int win0_alpha_en = ((win0_format == ARGB888) ||
+				(win0_format == ABGR888)) ? 1 : 0;
+	int win1_alpha_en = ((win1_format == ARGB888) ||
+				(win1_format == ABGR888)) ? 1 : 0;
+	int atv_layer_cnt = lcdc_dev->driver.win[0]->state +
+			lcdc_dev->driver.win[1]->state;
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (DSP_CTRL0 >> 2);
+	win0_top = ((*_pv) & (m_WIN0_TOP)) >> 8;
+	if (win0_top && (atv_layer_cnt >= 2) && (win0_alpha_en)) {
+		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
+		val = v_WIN0_ALPHA_EN(1) | v_WIN1_ALPHA_EN(0);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+
+		mask = m_WIN0_ALPHA_MODE |
+				m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1;
+		val = v_WIN0_ALPHA_MODE(1) |
+				v_ALPHA_MODE_SEL0(1) | v_ALPHA_MODE_SEL1(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+		/*this vop bg layer not support yuv domain overlay,so bg val
+		have to set 0x800a80 equeal to 0x000000 at rgb domian,after
+		android start we recover to 0x00000*/
+		mask = m_BG_COLOR;
+		val = v_BG_COLOR(0x000000);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+	} else if ((!win0_top) && (atv_layer_cnt >= 2) &&
+				(win1_alpha_en)) {
+		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
+		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(1);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+
+		mask = m_WIN1_ALPHA_MODE |
+				m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1;
+		if (lcdc_dev->driver.overlay_mode == VOP_YUV_DOMAIN)
+			val = v_WIN0_ALPHA_MODE(1) |
+			      v_ALPHA_MODE_SEL0(0) |
+			      v_ALPHA_MODE_SEL1(0);
+		else
+			val = v_WIN1_ALPHA_MODE(1) |
+			      v_ALPHA_MODE_SEL0(1) |
+			      v_ALPHA_MODE_SEL1(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+		/*this vop bg layer not support yuv domain overlay,so bg val
+		have to set 0x800a80 equeal to 0x000000 at rgb domian,after
+		android start we recover to 0x00000*/
+		mask = m_BG_COLOR;
+		val = v_BG_COLOR(0x000000);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+	} else {
+		mask = m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
+		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(0);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+	}
+
+	if (lcdc_dev->driver.win[2]->state == 1) {
+		mask =  m_HWC_ALPAH_EN;
+		val = v_HWC_ALPAH_EN(1);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+
+		mask =  m_HWC_ALPHA_MODE;
+		val = v_HWC_ALPHA_MODE(1);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+	} else {
+		mask =  m_HWC_ALPAH_EN;
+		val = v_HWC_ALPAH_EN(0);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+	}
+
+	return 0;
+}
+
+static void lcdc_layer_csc_mode(struct lcdc_device *lcdc_dev,
+				struct rk_lcdc_win *win)
+{
+	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
+		switch (win->area[0].fmt_cfg) {
+		case VOP_FORMAT_ARGB888:
+		case VOP_FORMAT_RGB888:
+		case VOP_FORMAT_RGB565:
+			if ((screen->mode.xres < 1280) &&
+			    (screen->mode.yres < 720)) {
+				win->csc_mode = VOP_R2Y_CSC_BT601;
+			} else {
+				win->csc_mode = VOP_R2Y_CSC_BT709;
+			}
+			break;
+		default:
+			break;
+		}
+		if (win->id  == 0) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_CSC_MODE,
+				     v_WIN0_CSC_MODE(win->csc_mode));
+		} else if (win->id  == 1) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN1_CSC_MODE,
+				     v_WIN1_CSC_MODE(win->csc_mode));
+		}
+	} else if (dev_drv->overlay_mode == VOP_RGB_DOMAIN) {
+		switch (win->area[0].fmt_cfg) {
+		case VOP_FORMAT_YCBCR420:
+			if (win->id  == 0) {
+				win->csc_mode = VOP_Y2R_CSC_MPEG;
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+					     m_WIN0_CSC_MODE,
+					v_WIN0_CSC_MODE(win->csc_mode));
+			}
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+
+static void lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
+				   struct rk_lcdc_win *win)
+{
+	u32 mask, val;
+	int hwc_size;
+
+	if (win->state == 1) {
+		if (lcdc_dev->soc_type == VOP_RK312X)
+			lcdc_layer_csc_mode(lcdc_dev, win);
+
+		if (win->id == 0) {
+			mask = m_WIN0_EN | m_WIN0_FORMAT | m_WIN0_RB_SWAP |
+			        m_WIN0_UV_SWAP;
+			val = v_WIN0_EN(win->state) |
+				v_WIN0_FORMAT(win->area[0].fmt_cfg) |
+				v_WIN0_RB_SWAP(win->area[0].swap_rb) |
+				v_WIN0_UV_SWAP(win->area[0].swap_uv);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
+				    v_X_SCL_FACTOR(win->scale_yrgb_x) |
+				    v_Y_SCL_FACTOR(win->scale_yrgb_y));
+			lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,
+				    v_X_SCL_FACTOR(win->scale_cbcr_x) |
+				    v_Y_SCL_FACTOR(win->scale_cbcr_y));
+
+			lcdc_msk_reg(lcdc_dev, WIN0_VIR,
+				     m_YRGB_VIR | m_CBBR_VIR,
+				     v_YRGB_VIR(win->area[0].y_vir_stride) |
+				     v_CBCR_VIR(win->area[0].uv_vir_stride));
+			lcdc_writel(lcdc_dev, WIN0_ACT_INFO,
+				    v_ACT_WIDTH(win->area[0].xact) |
+				    v_ACT_HEIGHT(win->area[0].yact));
+			lcdc_writel(lcdc_dev, WIN0_DSP_ST,
+				    v_DSP_STX(win->area[0].dsp_stx) |
+				    v_DSP_STY(win->area[0].dsp_sty));
+			lcdc_writel(lcdc_dev, WIN0_DSP_INFO,
+				    v_DSP_WIDTH(win->area[0].xsize) |
+				    v_DSP_HEIGHT(win->area[0].ysize));
+
+			lcdc_writel(lcdc_dev, WIN0_YRGB_MST,
+				    win->area[0].y_addr);
+			lcdc_writel(lcdc_dev, WIN0_CBR_MST,
+				    win->area[0].uv_addr);
+		} else if (win->id == 1) {
+			mask = m_WIN1_EN | m_WIN1_FORMAT | m_WIN1_RB_SWAP;
+			val = v_WIN1_EN(win->state) |
+					v_WIN1_FORMAT(win->area[0].fmt_cfg) |
+					v_WIN1_RB_SWAP(win->area[0].swap_rb);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			/* rk312x unsupport win1 scale */
+			if (lcdc_dev->soc_type == VOP_RK3036) {
+				lcdc_writel(lcdc_dev, WIN1_SCL_FACTOR_YRGB,
+					    v_X_SCL_FACTOR(win->scale_yrgb_x) |
+					    v_Y_SCL_FACTOR(win->scale_yrgb_y));
+				lcdc_writel(lcdc_dev, WIN1_ACT_INFO,
+					    v_ACT_WIDTH(win->area[0].xact) |
+					    v_ACT_HEIGHT(win->area[0].yact));
+				lcdc_writel(lcdc_dev, WIN1_DSP_INFO,
+					    v_DSP_WIDTH(win->area[0].xsize) |
+					    v_DSP_HEIGHT(win->area[0].ysize));
+				lcdc_writel(lcdc_dev, WIN1_DSP_ST,
+					    v_DSP_STX(win->area[0].dsp_stx) |
+					    v_DSP_STY(win->area[0].dsp_sty));
+				lcdc_writel(lcdc_dev,
+					    WIN1_MST, win->area[0].y_addr);
+			} else {
+				lcdc_writel(lcdc_dev, WIN1_DSP_INFO_RK312X,
+					    v_DSP_WIDTH(win->area[0].xsize) |
+					    v_DSP_HEIGHT(win->area[0].ysize));
+				lcdc_writel(lcdc_dev, WIN1_DSP_ST_RK312X,
+					    v_DSP_STX(win->area[0].dsp_stx) |
+					    v_DSP_STY(win->area[0].dsp_sty));
+
+				lcdc_writel(lcdc_dev,
+					    WIN1_MST_RK312X,
+					    win->area[0].y_addr);
+			}
+
+			lcdc_msk_reg(lcdc_dev, WIN1_VIR, m_YRGB_VIR,
+				     v_YRGB_VIR(win->area[0].y_vir_stride));
+
+
+		} else if (win->id == 2) {
+			mask = m_HWC_EN | m_HWC_LODAD_EN;
+			val = v_HWC_EN(win->state) | v_HWC_LODAD_EN(1);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			if ((win->area[0].xsize == 32) &&
+			    (win->area[0].ysize == 32))
+				hwc_size = 0;
+			else if ((win->area[0].xsize == 64) &&
+				 (win->area[0].ysize == 64))
+				hwc_size = 1;
+			else
+				dev_err(lcdc_dev->dev, "unsupport hwc size:x=%d,y=%d\n",
+					win->area[0].xsize, win->area[0].ysize);
+			lcdc_writel(lcdc_dev, HWC_DSP_ST,
+				    v_DSP_STX(win->area[0].dsp_stx) |
+				    v_DSP_STY(win->area[0].dsp_sty));
+
+			lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
+		}
+	} else {
+		win->area[0].y_addr = 0;
+		win->area[0].uv_addr = 0;
+		if (win->id == 0) {
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN,
+				     v_WIN0_EN(0));
+			lcdc_writel(lcdc_dev, WIN0_YRGB_MST,
+				    win->area[0].y_addr);
+			lcdc_writel(lcdc_dev, WIN0_CBR_MST,
+				    win->area[0].uv_addr);
+		} else if (win->id == 1) {
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN,
+				     v_WIN1_EN(0));
+			 lcdc_writel(lcdc_dev, WIN1_MST, win->area[0].y_addr);
+		} else if (win->id == 2) {
+			lcdc_msk_reg(lcdc_dev,
+			             SYS_CTRL, m_HWC_EN | m_HWC_LODAD_EN,
+			             v_HWC_EN(0) | v_HWC_LODAD_EN(0));
+			lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
+		}
+	}
+	rk312x_lcdc_alpha_cfg(lcdc_dev);
+}
+
+static void lcdc_layer_enable(struct lcdc_device *lcdc_dev, unsigned int win_id,
+			      bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on) &&
+	    lcdc_dev->driver.win[win_id]->state != open) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev,
+					 "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt  |= (1 << win_id);
+		} else if ((lcdc_dev->atv_layer_cnt & (1 << win_id)) && (!open)) {
+			 lcdc_dev->atv_layer_cnt &= ~(1 << win_id);
+		}
+		lcdc_dev->driver.win[win_id]->state = open;
+		if (!open) {
+			lcdc_layer_update_regs(lcdc_dev,
+					       lcdc_dev->driver.win[win_id]);
+			lcdc_cfg_done(lcdc_dev);
+		}
+		/*if no layer used,disable lcdc */
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev,
+				 "no layer is used,go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+}
+/*
+static int rk312x_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
+	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
+	int timeout;
+	unsigned long flags;
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(lcdc_dev->standby));
+		lcdc_layer_update_regs(lcdc_dev, win0);
+		lcdc_layer_update_regs(lcdc_dev, win1);
+		rk312x_lcdc_alpha_cfg(lcdc_dev);
+		lcdc_cfg_done(lcdc_dev);
+
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	//if (dev_drv->wait_fs) {
+	if (0) {
+		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
+						      msecs_to_jiffies
+						      (dev_drv->cur_screen->ft +
+						       5));
+		if (!timeout && (!dev_drv->frame_done.done)) {
+			dev_warn(lcdc_dev->dev,
+				 "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
+	return 0;
+
+}*/
+
+static void rk312x_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
+{
+	memcpy((u8 *)lcdc_dev->regs, (u8 *)lcdc_dev->regsbak, 0xe0);
+}
+
+static int rk312x_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
+{
+	u32 mask, val;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	/*spin_lock(&lcdc_dev->reg_lock);*/
+	if (likely(lcdc_dev->clk_on)) {
+		mask = m_MMU_EN | m_AXI_MAX_OUTSTANDING_EN |
+			m_AXI_OUTSTANDING_MAX_NUM;
+		val = v_MMU_EN(1) | v_AXI_OUTSTANDING_MAX_NUM(31) |
+			v_AXI_MAX_OUTSTANDING_EN(1);
+		lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+	}
+	/*spin_unlock(&lcdc_dev->reg_lock);*/
+	if (dev_drv->iommu_enabled) {
+		if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
+			lcdc_dev->iommu_status = 1;
+			rockchip_iovmm_activate(dev_drv->dev);
+		}
+	}
+
+	return 0;
+}
+
+static int rk312x_lcdc_set_hwc_lut(struct rk_lcdc_driver *dev_drv,
+				   int *hwc_lut, int mode)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	int len = 256*4;
+	struct lcdc_device *lcdc_dev =
+			container_of(dev_drv, struct lcdc_device, driver);
+	if (dev_drv->hwc_lut == NULL)
+		dev_drv->hwc_lut = devm_kzalloc(lcdc_dev->dev, len, GFP_KERNEL);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_HWC_LUT_EN, v_HWC_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	mdelay(25);
+	for (i = 0; i < 256; i++) {
+		if (mode == 1)
+			dev_drv->hwc_lut[i] = hwc_lut[i];
+		v = dev_drv->hwc_lut[i];
+		c = lcdc_dev->hwc_lut_addr_base + i;
+		writel_relaxed(v, c);
+	}
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_HWC_LUT_EN, v_HWC_LUT_EN(1));
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk312x_lcdc_set_lut(struct rk_lcdc_driver *dev_drv,
+			       int *dsp_lut)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	struct lcdc_device *lcdc_dev =
+		container_of(dev_drv, struct lcdc_device, driver);
+
+	if (!dsp_lut)
+		return 0;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	mdelay(25);
+	for (i = 0; i < 256; i++) {
+		v = dsp_lut[i];
+		c = lcdc_dev->dsp_lut_addr_base + i;
+		writel_relaxed(v, c);
+	}
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk312x_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv,
+				    int reset_rate)
+{
+#ifdef CONFIG_RK_FPGA
+	return 0;
+#endif
+	int ret, fps;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (reset_rate)
+		ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
+	if (ret)
+		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
+	lcdc_dev->pixclock =
+	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
+
+	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
+	screen->ft = 1000 / fps;
+	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
+		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
+	return 0;
+}
+
+static int rk312x_lcdc_standby(struct rk_lcdc_driver *dev_drv, bool enable)
+{
+	struct lcdc_device *vop_dev =
+		container_of(dev_drv, struct lcdc_device, driver);
+	int timeout;
+	unsigned long flags;
+
+	if (unlikely(!vop_dev->clk_on))
+		return 0;
+
+	if (dev_drv->standby && !enable) {
+		dev_drv->standby = 0;
+		lcdc_msk_reg(vop_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(0));
+		return 0;
+	} else if (!dev_drv->standby && enable) {
+		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+
+		lcdc_msk_reg(vop_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(1));
+		/* wait for standby hold valid */
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
+						      msecs_to_jiffies(25));
+
+		if (!timeout && (!dev_drv->frame_done.done)) {
+			dev_info(dev_drv->dev,
+				 "wait for standy hold valid start time out!\n");
+			return -ETIMEDOUT;
+		}
+
+		dev_drv->standby = 1;
+	}
+
+	return 0;
+}
+
+/********do basic init*********/
+static int rk312x_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	if (lcdc_dev->pre_init)
+		return 0;
+
+	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
+	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
+	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
+	lcdc_dev->sclk = devm_clk_get(lcdc_dev->dev, "sclk_lcdc");
+	lcdc_dev->pd   = devm_clk_get(lcdc_dev->dev, "pd_lcdc");
+	lcdc_dev->pll_sclk = devm_clk_get(lcdc_dev->dev, "sclk_pll");
+
+	if (/*IS_ERR(lcdc_dev->pd) || */ (IS_ERR(lcdc_dev->aclk)) ||
+	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
+		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
+			lcdc_dev->id);
+	}
+
+	rk_disp_pwr_enable(dev_drv);
+	rk312x_lcdc_clk_enable(lcdc_dev);
+
+	/* backup reg config at uboot */
+	rk_lcdc_read_reg_defalut_cfg(lcdc_dev);
+
+	/* config for the FRC mode of dither down */
+	lcdc_writel(lcdc_dev, FRC_LOWER01_0, 0x12844821);
+	lcdc_writel(lcdc_dev, FRC_LOWER01_1, 0x21488412);
+	lcdc_writel(lcdc_dev, FRC_LOWER10_0, 0x55aaaa55);
+	lcdc_writel(lcdc_dev, FRC_LOWER10_1, 0x55aaaa55);
+	lcdc_writel(lcdc_dev, FRC_LOWER11_0, 0xdeb77deb);
+	lcdc_writel(lcdc_dev, FRC_LOWER11_1, 0xed7bb7de);
+
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_AUTO_GATING_EN, v_AUTO_GATING_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	/*if (dev_drv->iommu_enabled)
+		{// disable all wins to workaround iommu pagefault
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN | m_WIN1_EN,
+			     v_WIN0_EN(0) | v_WIN1_EN(0));
+		lcdc_cfg_done(lcdc_dev);
+		while(lcdc_readl(lcdc_dev, SYS_CTRL) & (m_WIN0_EN | m_WIN1_EN));
+	}*/
+	if ((dev_drv->ops->open_bcsh) && (dev_drv->output_color == COLOR_YCBCR)) {
+		if (support_uboot_display())
+			dev_drv->bcsh_init_status = 1;
+		else
+			dev_drv->ops->open_bcsh(dev_drv, 1);
+	}
+	lcdc_dev->pre_init = true;
+
+	return 0;
+}
+
+static void rk312x_lcdc_deinit(struct lcdc_device *lcdc_dev)
+{
+	rk312x_lcdc_disable_irq(lcdc_dev);
+}
+
+static u32 calc_sclk_freq(struct rk_screen *src_screen,
+			  struct rk_screen *dst_screen)
+{
+	u32 dsp_vtotal;
+	u64 dsp_htotal;
+	u32 dsp_in_vtotal;
+	u64 dsp_in_htotal;
+	u64 sclk_freq;
+
+	if (!src_screen || !dst_screen)
+		return 0;
+
+	dsp_vtotal = dst_screen->mode.yres;
+	dsp_htotal = dst_screen->mode.left_margin + dst_screen->mode.hsync_len +
+			dst_screen->mode.xres + dst_screen->mode.right_margin;
+	dsp_in_vtotal = src_screen->mode.yres;
+	dsp_in_htotal = src_screen->mode.left_margin +
+			src_screen->mode.hsync_len +
+			src_screen->mode.xres + src_screen->mode.right_margin;
+	sclk_freq = dsp_vtotal * dsp_htotal * src_screen->mode.pixclock;
+	do_div(sclk_freq, dsp_in_vtotal * dsp_in_htotal);
+
+	return (u32)sclk_freq;
+}
+
+#define SCLK_PLL_LIMIT		594000000
+#define GPU_FREQ_MAX_LIMIT	297000000
+#define GPU_FREQ_NEED		400000000
+
+static u32 calc_sclk_pll_freq(u32 sclk_freq)
+{
+	u32 multi_num;
+
+	if (sclk_freq < (SCLK_PLL_LIMIT / 10)) {
+		return (sclk_freq * 10);
+	} else {
+		multi_num = GPU_FREQ_NEED / sclk_freq;
+		return (sclk_freq * multi_num);
+	}
+}
+
+static int calc_dsp_frm_vst_hst(struct rk_screen *src,
+				struct rk_screen *dst, u32 sclk_freq)
+{
+	u32 BP_in, BP_out;
+	u32 v_scale_ratio;
+	long long T_frm_st;
+	u64 T_BP_in, T_BP_out, T_Delta, Tin;
+	u32 src_pixclock, dst_pixclock;
+	u64 temp;
+	u32 dsp_htotal, dsp_vtotal, src_htotal, src_vtotal;
+
+	if (unlikely(!src) || unlikely(!dst))
+		return -1;
+
+	src_pixclock = div_u64(1000000000000llu, src->mode.pixclock);
+	dst_pixclock = div_u64(1000000000000llu, sclk_freq);
+	dsp_htotal = dst->mode.left_margin + dst->mode.hsync_len +
+		     dst->mode.xres + dst->mode.right_margin;
+	dsp_vtotal = dst->mode.upper_margin + dst->mode.vsync_len +
+		     dst->mode.yres + dst->mode.lower_margin;
+	src_htotal = src->mode.left_margin + src->mode.hsync_len +
+		     src->mode.xres + src->mode.right_margin;
+	src_vtotal = src->mode.upper_margin + src->mode.vsync_len +
+		     src->mode.yres + src->mode.lower_margin;
+	BP_in  = (src->mode.upper_margin + src->mode.vsync_len) * src_htotal +
+		 src->mode.hsync_len + src->mode.left_margin;
+	BP_out = (dst->mode.upper_margin + dst->mode.vsync_len) * dsp_htotal +
+		 dst->mode.hsync_len + dst->mode.left_margin;
+
+	T_BP_in = BP_in * src_pixclock;
+	T_BP_out = BP_out * dst_pixclock;
+	Tin = src_vtotal * src_htotal * src_pixclock;
+
+	v_scale_ratio = src->mode.yres / dst->mode.yres;
+	if (v_scale_ratio <= 2)
+		T_Delta = 5 * src_htotal * src_pixclock;
+	else
+		T_Delta = 12 * src_htotal * src_pixclock;
+
+	if (T_BP_in + T_Delta > T_BP_out)
+		T_frm_st = (T_BP_in + T_Delta - T_BP_out);
+	else
+		T_frm_st = Tin - (T_BP_out - (T_BP_in + T_Delta));
+
+	/* (T_frm_st = scl_vst * src_htotal * src_pixclock +
+						scl_hst * src_pixclock) */
+	temp = do_div(T_frm_st, src_pixclock);
+	temp = do_div(T_frm_st, src_htotal);
+	dst->scl_hst = temp - 1;
+	dst->scl_vst = T_frm_st;
+
+	return 0;
+}
+
+static int rk312x_lcdc_set_scaler(struct rk_lcdc_driver *dev_drv,
+				  struct rk_screen *dst_screen, bool enable)
+{
+	u32 dsp_htotal, dsp_hs_end, dsp_hact_st, dsp_hact_end;
+	u32 dsp_vtotal, dsp_vs_end, dsp_vact_st, dsp_vact_end;
+	u32 dsp_hbor_end, dsp_hbor_st, dsp_vbor_end, dsp_vbor_st;
+	u32 scl_v_factor, scl_h_factor;
+	u32 dst_frame_hst, dst_frame_vst;
+	u32 src_w, src_h, dst_w, dst_h;
+	u16 bor_right = 0;
+	u16 bor_left = 0;
+	u16 bor_up = 0;
+	u16 bor_down = 0;
+	u32 pll_freq = 0;
+	struct rk_screen *src;
+	struct rk_screen *dst;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	struct dvfs_node *gpu_clk = clk_get_dvfs_node("clk_gpu");
+
+	if (unlikely(!lcdc_dev->clk_on))
+		return 0;
+
+	if (!enable) {
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_msk_reg(lcdc_dev, SCALER_CTRL,
+			     m_SCALER_EN | m_SCALER_OUT_ZERO |
+					m_SCALER_OUT_EN,
+					v_SCALER_EN(0) | v_SCALER_OUT_ZERO(1) |
+					v_SCALER_OUT_EN(0));
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+		if (lcdc_dev->sclk_on) {
+			clk_disable_unprepare(lcdc_dev->sclk);
+			lcdc_dev->sclk_on = false;
+		}
+
+		/* switch pll freq as default when sclk is no used */
+		if (clk_get_rate(lcdc_dev->pll_sclk) != GPU_FREQ_NEED) {
+			dvfs_clk_enable_limit(gpu_clk, GPU_FREQ_MAX_LIMIT,
+					      GPU_FREQ_MAX_LIMIT);
+			clk_set_rate(lcdc_dev->pll_sclk, GPU_FREQ_NEED);
+			dvfs_clk_enable_limit(gpu_clk, 0, -1);
+		}
+		dev_dbg(lcdc_dev->dev, "%s: disable\n", __func__);
+		return 0;
+	}
+
+	/*
+	 * rk312x used one lcdc to apply dual disp
+	 * hdmi screen is used for scaler src
+	 * prmry screen is used for scaler dst
+	 */
+	dst = dst_screen;
+	src = dev_drv->cur_screen;
+	if (!dst || !src) {
+		dev_err(lcdc_dev->dev, "%s: dst screen is null!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!lcdc_dev->sclk_on) {
+		clk_prepare_enable(lcdc_dev->sclk);
+		lcdc_dev->s_pixclock = calc_sclk_freq(src, dst);
+		pll_freq = calc_sclk_pll_freq(lcdc_dev->s_pixclock);
+
+		/* limit gpu freq */
+		dvfs_clk_enable_limit(gpu_clk,
+				      GPU_FREQ_MAX_LIMIT,
+				      GPU_FREQ_MAX_LIMIT);
+		/* set pll freq */
+		clk_set_rate(lcdc_dev->pll_sclk, pll_freq);
+		/* cancel limit gpu freq */
+		dvfs_clk_enable_limit(gpu_clk, 0, -1);
+
+		clk_set_rate(lcdc_dev->sclk, lcdc_dev->s_pixclock);
+		lcdc_dev->sclk_on = true;
+		dev_info(lcdc_dev->dev, "%s:sclk=%d\n", __func__,
+			 lcdc_dev->s_pixclock);
+	}
+
+	/* config scale timing */
+	calc_dsp_frm_vst_hst(src, dst, lcdc_dev->s_pixclock);
+	dst_frame_vst = dst->scl_vst;
+	dst_frame_hst = dst->scl_hst;
+
+	dsp_htotal    = dst->mode.hsync_len + dst->mode.left_margin +
+			dst->mode.xres + dst->mode.right_margin;
+	dsp_hs_end    = dst->mode.hsync_len;
+
+	dsp_vtotal    = dst->mode.vsync_len + dst->mode.upper_margin +
+			dst->mode.yres + dst->mode.lower_margin;
+	dsp_vs_end    = dst->mode.vsync_len;
+
+	dsp_hbor_end  = dst->mode.hsync_len + dst->mode.left_margin +
+			dst->mode.xres;
+	dsp_hbor_st   = dst->mode.hsync_len + dst->mode.left_margin;
+	dsp_vbor_end  = dst->mode.vsync_len + dst->mode.upper_margin +
+			dst->mode.yres;
+	dsp_vbor_st   = dst->mode.vsync_len + dst->mode.upper_margin;
+
+	dsp_hact_st   = dsp_hbor_st  + bor_left;
+	dsp_hact_end  = dsp_hbor_end - bor_right;
+	dsp_vact_st   = dsp_vbor_st  + bor_up;
+	dsp_vact_end  = dsp_vbor_end - bor_down;
+
+	src_w = src->mode.xres;
+	src_h = src->mode.yres;
+	dst_w = dsp_hact_end - dsp_hact_st;
+	dst_h = dsp_vact_end - dsp_vact_st;
+
+	/* calc scale factor */
+	scl_h_factor = ((src_w - 1) << 12) / (dst_w - 1);
+	scl_v_factor = ((src_h - 1) << 12) / (dst_h - 1);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (dst->color_mode != src->color_mode) {
+		/*dev_drv->output_color = dst->color_mode;
+		if (dev_drv->output_color == COLOR_YCBCR)
+			dev_drv->overlay_mode = VOP_YUV_DOMAIN;
+		else
+			dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_SW_OVERLAY_MODE,
+			     v_SW_OVERLAY_MODE(dev_drv->overlay_mode));*/
+	}
+
+	lcdc_writel(lcdc_dev, SCALER_FACTOR,
+		    v_SCALER_H_FACTOR(scl_h_factor) |
+		    v_SCALER_V_FACTOR(scl_v_factor));
+
+	lcdc_writel(lcdc_dev, SCALER_FRAME_ST,
+		    v_SCALER_FRAME_HST(dst_frame_hst) |
+		    v_SCALER_FRAME_VST(dst_frame_vst));
+	lcdc_writel(lcdc_dev, SCALER_DSP_HOR_TIMING,
+		    v_SCALER_HS_END(dsp_hs_end) |
+		    v_SCALER_HTOTAL(dsp_htotal));
+	lcdc_writel(lcdc_dev, SCALER_DSP_HACT_ST_END,
+		    v_SCALER_HAEP(dsp_hact_end) |
+		    v_SCALER_HASP(dsp_hact_st));
+	lcdc_writel(lcdc_dev, SCALER_DSP_VER_TIMING,
+		    v_SCALER_VS_END(dsp_vs_end) |
+		    v_SCALER_VTOTAL(dsp_vtotal));
+	lcdc_writel(lcdc_dev, SCALER_DSP_VACT_ST_END,
+		    v_SCALER_VAEP(dsp_vact_end) |
+		    v_SCALER_VASP(dsp_vact_st));
+	lcdc_writel(lcdc_dev, SCALER_DSP_HBOR_TIMING,
+		    v_SCALER_HBOR_END(dsp_hbor_end) |
+		    v_SCALER_HBOR_ST(dsp_hbor_st));
+	lcdc_writel(lcdc_dev, SCALER_DSP_VBOR_TIMING,
+		    v_SCALER_VBOR_END(dsp_vbor_end) |
+		    v_SCALER_VBOR_ST(dsp_vbor_st));
+	lcdc_msk_reg(lcdc_dev, SCALER_CTRL,
+		     m_SCALER_VSYNC_VST | m_SCALER_VSYNC_MODE,
+		     v_SCALER_VSYNC_VST(4) | v_SCALER_VSYNC_MODE(2));
+	lcdc_msk_reg(lcdc_dev, SCALER_CTRL,
+		     m_SCALER_EN | m_SCALER_OUT_ZERO |
+		     m_SCALER_OUT_EN,
+		     v_SCALER_EN(1) | v_SCALER_OUT_ZERO(0) |
+		     v_SCALER_OUT_EN(1));
+
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static void rk312x_lcdc_select_bcsh(struct rk_lcdc_driver *dev_drv,
+				    struct lcdc_device *lcdc_dev)
+{
+	u32 bcsh_ctrl;
+	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
+		if (IS_YUV_COLOR(dev_drv->output_color))/* bypass */
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     m_BCSH_Y2R_EN | m_BCSH_R2Y_EN,
+				     v_BCSH_Y2R_EN(0) | v_BCSH_R2Y_EN(0));
+	else	/* YUV2RGB */
+		lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+			     m_BCSH_Y2R_EN | m_BCSH_Y2R_CSC_MODE |
+			     m_BCSH_R2Y_EN,
+			     v_BCSH_Y2R_EN(1) |
+			     v_BCSH_Y2R_CSC_MODE(VOP_Y2R_CSC_MPEG) |
+			     v_BCSH_R2Y_EN(0));
+	} else {	/* overlay_mode=VOP_RGB_DOMAIN */
+		if (dev_drv->output_color == COLOR_RGB) {
+			/* bypass */
+			bcsh_ctrl = lcdc_readl(lcdc_dev, BCSH_CTRL);
+			if (((bcsh_ctrl&m_BCSH_EN) == 1) ||
+				(dev_drv->bcsh.enable == 1))/*bcsh enabled*/
+				lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     	m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
+				     	v_BCSH_R2Y_EN(1) | v_BCSH_Y2R_EN(1));
+			else/*bcsh disabled*/
+				lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     	m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
+				     	v_BCSH_R2Y_EN(0) | v_BCSH_Y2R_EN(0));
+		} else	/* RGB2YUV */
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     m_BCSH_R2Y_EN |
+					m_BCSH_R2Y_CSC_MODE | m_BCSH_Y2R_EN,
+					v_BCSH_R2Y_EN(1) |
+					v_BCSH_R2Y_CSC_MODE(VOP_Y2R_CSC_MPEG) |
+					v_BCSH_Y2R_EN(0));
+		}
+}
+
+static int rk312x_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
+				  u16 *yact, int *format, u32 *dsp_addr,
+				  int *ymirror)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	u32 val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+
+	val = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
+	*xact = (val & m_ACT_WIDTH)+1;
+	*yact = ((val & m_ACT_HEIGHT)>>16)+1;
+
+	val = lcdc_readl(lcdc_dev, SYS_CTRL);
+
+	*format = (val & m_WIN0_FORMAT) >> 3;
+	*dsp_addr = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
+
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk312x_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
+			      int format, u16 xact, u16 yact, u16 xvir,
+			      int ymirror)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[0];
+	u32 val, mask;
+
+	mask = m_WIN0_FORMAT;
+	val = v_WIN0_FORMAT(format);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+
+	lcdc_msk_reg(lcdc_dev, WIN0_VIR, m_YRGB_VIR,
+			v_YRGB_VIR(xvir));
+	lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_ACT_WIDTH(xact) |
+		    v_ACT_HEIGHT(yact));
+
+	lcdc_writel(lcdc_dev, WIN0_YRGB_MST, rgb_mst);
+
+	lcdc_cfg_done(lcdc_dev);
+	win->state = 1;
+	win->last_state = 1;
+
+	return 0;
+}
+
+static int rk312x_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
+{
+	u16 face = 0;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 right_margin = screen->mode.right_margin;
+	u16 left_margin = screen->mode.left_margin;
+	u16 lower_margin = screen->mode.lower_margin;
+	u16 upper_margin = screen->mode.upper_margin;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		/* Select output color domain */
+		dev_drv->output_color = screen->color_mode;
+		/*if (lcdc_dev->soc_type == VOP_RK312X) {
+			if (dev_drv->output_color == COLOR_YCBCR)
+				dev_drv->overlay_mode = VOP_YUV_DOMAIN;
+			else
+				dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+		} else {
+			dev_drv->output_color = COLOR_RGB;
+			dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+		}*/
+		dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+		/*something wrong at yuv domain*/
+
+		switch (screen->type) {
+		case SCREEN_RGB:
+			if (lcdc_dev->soc_type == VOP_RK312X) {
+				mask = m_RGB_DCLK_EN | m_RGB_DCLK_INVERT;
+				val = v_RGB_DCLK_EN(1) | v_RGB_DCLK_INVERT(0);
+				lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+			}
+			break;
+		case SCREEN_LVDS:
+			if (lcdc_dev->soc_type == VOP_RK312X) {
+				mask = m_LVDS_DCLK_EN | m_LVDS_DCLK_INVERT;
+				val = v_LVDS_DCLK_EN(1) | v_LVDS_DCLK_INVERT(1);
+				lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+			}
+			break;
+		case SCREEN_MIPI:
+			if (lcdc_dev->soc_type == VOP_RK312X) {
+				mask = m_MIPI_DCLK_EN | m_MIPI_DCLK_INVERT;
+				val = v_MIPI_DCLK_EN(1) | v_MIPI_DCLK_INVERT(0);
+				lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+			}
+			break;
+		case SCREEN_HDMI:
+			mask = m_HDMI_DCLK_EN;
+			val = v_HDMI_DCLK_EN(1);
+			if (screen->pixelrepeat) {
+				mask |= m_CORE_CLK_DIV_EN;
+				val |= v_CORE_CLK_DIV_EN(1);
+			} else {
+				mask |= m_CORE_CLK_DIV_EN;
+				val |= v_CORE_CLK_DIV_EN(0);
+			}
+			lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+			if (lcdc_dev->soc_type == VOP_RK312X) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_SW_UV_OFFSET_EN,
+				     v_SW_UV_OFFSET_EN(0));
+				mask = m_HDMI_HSYNC_POL | m_HDMI_VSYNC_POL |
+				       m_HDMI_DEN_POL;
+				val = v_HDMI_HSYNC_POL(screen->pin_hsync) |
+				      v_HDMI_VSYNC_POL(screen->pin_vsync) |
+				      v_HDMI_DEN_POL(screen->pin_den);
+				lcdc_msk_reg(lcdc_dev, INT_SCALER, mask, val);
+			} else {
+				mask = (1 << 4) | (1 << 5) | (1 << 6);
+				val = (screen->pin_hsync << 4) |
+					(screen->pin_vsync << 5) |
+					(screen->pin_den << 6);
+				grf_writel(RK3036_GRF_SOC_CON2,
+					   (mask << 16) | val);
+			}
+			rk312x_lcdc_select_bcsh(dev_drv,  lcdc_dev);
+			break;
+		case SCREEN_TVOUT:
+		case SCREEN_TVOUT_TEST:
+			mask = m_TVE_DAC_DCLK_EN;
+			val = v_TVE_DAC_DCLK_EN(1);
+			if (screen->pixelrepeat) {
+				mask |= m_CORE_CLK_DIV_EN;
+				val |= v_CORE_CLK_DIV_EN(1);
+			}
+			lcdc_msk_reg(lcdc_dev, AXI_BUS_CTRL, mask, val);
+			if (x_res == 720 && y_res == 576)
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_TVE_MODE,
+					     v_TVE_MODE(TV_PAL));
+			else if (x_res == 720 && y_res == 480)
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_TVE_MODE,
+					     v_TVE_MODE(TV_NTSC));
+			else {
+				dev_err(lcdc_dev->dev,
+					"unsupported video timing!\n");
+				return -1;
+			}
+			if (lcdc_dev->soc_type == VOP_RK312X) {
+				if (screen->type == SCREEN_TVOUT_TEST)
+			/*for TVE index test,vop must ovarlay at yuv domain*/
+					dev_drv->overlay_mode = VOP_YUV_DOMAIN;
+					lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+						     m_SW_UV_OFFSET_EN,
+						     v_SW_UV_OFFSET_EN(1));
+
+			rk312x_lcdc_select_bcsh(dev_drv, lcdc_dev);
+			}
+			break;
+		default:
+			dev_err(lcdc_dev->dev, "un supported interface!\n");
+			break;
+		}
+		if (lcdc_dev->soc_type == VOP_RK312X) {
+			switch (dev_drv->screen0->face) {
+			case OUT_P565:
+				face = OUT_P565;
+				mask = m_DITHER_DOWN_EN |
+				       m_DITHER_DOWN_MODE |
+				       m_DITHER_DOWN_SEL;
+				val = v_DITHER_DOWN_EN(1) |
+				      v_DITHER_DOWN_MODE(0) |
+				      v_DITHER_DOWN_SEL(1);
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+				break;
+			case OUT_P666:
+				face = OUT_P666;
+				mask = m_DITHER_DOWN_EN |
+				       m_DITHER_DOWN_MODE |
+				       m_DITHER_DOWN_SEL;
+				val = v_DITHER_DOWN_EN(1) |
+				      v_DITHER_DOWN_MODE(1) |
+				      v_DITHER_DOWN_SEL(1);
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+				break;
+			case OUT_D888_P565:
+				face = OUT_P888;
+				mask = m_DITHER_DOWN_EN |
+				       m_DITHER_DOWN_MODE |
+				       m_DITHER_DOWN_SEL;
+				val = v_DITHER_DOWN_EN(1) |
+				      v_DITHER_DOWN_MODE(0) |
+				      v_DITHER_DOWN_SEL(1);
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+				break;
+			case OUT_D888_P666:
+				face = OUT_P888;
+				mask = m_DITHER_DOWN_EN |
+				       m_DITHER_DOWN_MODE |
+				       m_DITHER_DOWN_SEL;
+				val = v_DITHER_DOWN_EN(1) |
+				      v_DITHER_DOWN_MODE(1) |
+				      v_DITHER_DOWN_SEL(1);
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+				break;
+			case OUT_P888:
+				face = OUT_P888;
+				mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN;
+				val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0);
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+				break;
+			default:
+				dev_err(lcdc_dev->dev, "un supported interface!\n");
+				break;
+			}
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_SW_OVERLAY_MODE,
+				     v_SW_OVERLAY_MODE(dev_drv->overlay_mode));
+		}
+
+		mask = m_HSYNC_POL | m_VSYNC_POL |
+		       m_DEN_POL | m_DCLK_POL;
+		val = v_HSYNC_POL(screen->pin_hsync) |
+		      v_VSYNC_POL(screen->pin_vsync) |
+		      v_DEN_POL(screen->pin_den) |
+		      v_DCLK_POL(screen->pin_dclk);
+
+		if (screen->type != SCREEN_HDMI) {
+			mask |= m_DSP_OUT_FORMAT;
+			val |= v_DSP_OUT_FORMAT(face);
+		}
+
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+
+		mask = m_BG_COLOR | m_DSP_BG_SWAP | m_DSP_RB_SWAP |
+		       m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
+		       m_DSP_DUMMY_SWAP | m_BLANK_EN | m_BLACK_EN;
+
+		val = v_BG_COLOR(0x000000) | v_DSP_BG_SWAP(screen->swap_gb) |
+		      v_DSP_RB_SWAP(screen->swap_rb) |
+		      v_DSP_RG_SWAP(screen->swap_rg) |
+		      v_DSP_DELTA_SWAP(screen->swap_delta) |
+		      v_DSP_DUMMY_SWAP(screen->swap_dumy) |
+		      v_BLANK_EN(0) | v_BLACK_EN(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+
+		/* config timing */
+		val = v_HSYNC(screen->mode.hsync_len) |
+		      v_HORPRD(screen->mode.hsync_len + left_margin + x_res +
+				right_margin);
+		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END, val);
+		val = v_HAEP(screen->mode.hsync_len + left_margin + x_res) |
+		      v_HASP(screen->mode.hsync_len + left_margin);
+		lcdc_writel(lcdc_dev, DSP_HACT_ST_END, val);
+
+		if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+			/* First Field Timing */
+			lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END,
+				    v_VSYNC(screen->mode.vsync_len) |
+				    v_VERPRD(2 * (screen->mode.vsync_len +
+						  upper_margin +
+						  lower_margin) + y_res + 1));
+			lcdc_writel(lcdc_dev, DSP_VACT_ST_END,
+				    v_VAEP(screen->mode.vsync_len +
+					   upper_margin + y_res / 2) |
+				    v_VASP(screen->mode.vsync_len +
+					   upper_margin));
+			/* Second Field Timing */
+			lcdc_writel(lcdc_dev, DSP_VS_ST_END_F1,
+				    v_VSYNC_ST_F1(screen->mode.vsync_len +
+						  upper_margin + y_res / 2 +
+						lower_margin) |
+				    v_VSYNC_END_F1(2 * screen->mode.vsync_len +
+						   upper_margin + y_res / 2 +
+						   lower_margin));
+			lcdc_writel(lcdc_dev, DSP_VACT_ST_END_F1,
+				    v_VAEP(2 * (screen->mode.vsync_len +
+						upper_margin) +
+						y_res + lower_margin + 1) |
+				    v_VASP(2 * (screen->mode.vsync_len +
+						upper_margin) +
+						y_res / 2 + lower_margin + 1));
+
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_INTERLACE_DSP_EN |
+				     m_WIN0_YRGB_DEFLICK_EN |
+				     m_WIN0_CBR_DEFLICK_EN |
+				     m_INTERLACE_FIELD_POL |
+				     m_WIN0_INTERLACE_EN |
+				     m_WIN1_INTERLACE_EN,
+				     v_INTERLACE_DSP_EN(1) |
+				     v_WIN0_YRGB_DEFLICK_EN(1) |
+				     v_WIN0_CBR_DEFLICK_EN(1) |
+				     v_INTERLACE_FIELD_POL(0) |
+				     v_WIN0_INTERLACE_EN(1) |
+				     v_WIN1_INTERLACE_EN(1));
+			mask = m_LF_INT_NUM;
+			val = v_LF_INT_NUM(screen->mode.vsync_len +
+					   screen->mode.upper_margin +
+					   screen->mode.yres/2);
+			lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
+		} else {
+			val = v_VSYNC(screen->mode.vsync_len) |
+			      v_VERPRD(screen->mode.vsync_len + upper_margin +
+				     y_res + lower_margin);
+			lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END, val);
+
+			val = v_VAEP(screen->mode.vsync_len +
+				     upper_margin + y_res) |
+			      v_VASP(screen->mode.vsync_len + upper_margin);
+			lcdc_writel(lcdc_dev, DSP_VACT_ST_END, val);
+
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_INTERLACE_DSP_EN |
+				     m_WIN0_YRGB_DEFLICK_EN |
+				     m_WIN0_CBR_DEFLICK_EN |
+				     m_INTERLACE_FIELD_POL |
+				     m_WIN0_INTERLACE_EN |
+				     m_WIN1_INTERLACE_EN,
+				     v_INTERLACE_DSP_EN(0) |
+				     v_WIN0_YRGB_DEFLICK_EN(0) |
+				     v_WIN0_CBR_DEFLICK_EN(0) |
+				     v_INTERLACE_FIELD_POL(0) |
+				     v_WIN0_INTERLACE_EN(0) |
+				     v_WIN1_INTERLACE_EN(0));
+			mask = m_LF_INT_NUM;
+			val = v_LF_INT_NUM(screen->mode.vsync_len +
+					   screen->mode.upper_margin +
+					   screen->mode.yres);
+			lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	rk312x_lcdc_set_dclk(dev_drv, 1);
+	lcdc_cfg_done(lcdc_dev);
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	if (screen->init)
+		screen->init();
+
+	return 0;
+}
+
+static int rk312x_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
+			    bool open)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+
+	/* enable clk,when first layer open */
+	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
+		rockchip_set_system_status(SYS_STATUS_LCDC0);
+		rk312x_lcdc_pre_init(dev_drv);
+		rk312x_lcdc_clk_enable(lcdc_dev);
+		if (dev_drv->iommu_enabled) {
+			if (!dev_drv->mmu_dev) {
+				dev_drv->mmu_dev =
+					rk_fb_get_sysmmu_device_by_compatible(dev_drv->mmu_dts_name);
+				if (dev_drv->mmu_dev) {
+					rk_fb_platform_set_sysmmu(dev_drv->mmu_dev,
+								  dev_drv->dev);
+				} else {
+					dev_err(dev_drv->dev,
+						"failed to get rockchip iommu device\n");
+					return -1;
+				}
+			}
+			/*if (dev_drv->mmu_dev)
+				rockchip_iovmm_activate(dev_drv->dev);*/
+		}
+		rk312x_lcdc_reg_restore(lcdc_dev);
+		/*if (dev_drv->iommu_enabled)
+			rk312x_lcdc_mmu_en(dev_drv);*/
+		if ((support_uboot_display() && (lcdc_dev->prop == PRMRY))) {
+			rk312x_lcdc_set_dclk(dev_drv, 0);
+			rk312x_lcdc_enable_irq(dev_drv);
+		} else {
+			dev_drv->standby = 1;
+			rk312x_load_screen(dev_drv, 1);
+			rk312x_lcdc_standby(dev_drv, false);
+		}
+
+		/* set screen lut */
+		if (dev_drv->cur_screen->dsp_lut)
+			rk312x_lcdc_set_lut(dev_drv,
+					    dev_drv->cur_screen->dsp_lut);
+	}
+
+	if (win_id < ARRAY_SIZE(lcdc_win))
+		lcdc_layer_enable(lcdc_dev, win_id, open);
+	else
+		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
+
+	/* when all layer closed,disable clk */
+/*	if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
+		rk312x_lcdc_disable_irq(lcdc_dev);
+		rk312x_lcdc_reg_update(dev_drv);
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+		rk312x_lcdc_clk_disable(lcdc_dev);
+		rockchip_clear_system_status(SYS_STATUS_LCDC0);
+	}*/
+	return 0;
+}
+
+static int rk312x_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	struct rk_lcdc_win *win = NULL;
+	char fmt[9] = "NULL";
+
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+
+	if (win_id == 0) {
+		win = dev_drv->win[0];
+	} else if (win_id == 1) {
+		win = dev_drv->win[1];
+	} else if (win_id == 2) {
+		win = dev_drv->win[2];
+	} else {
+		dev_err(dev_drv->dev, "un supported win number:%d\n", win_id);
+		return -EINVAL;
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	win->area[0].dsp_stx = win->area[0].xpos + screen->mode.left_margin +
+			       screen->mode.hsync_len;
+	if (win_id == 1) {
+                if ((win->area[0].xact != win->area[0].xsize) ||
+                    (win->area[0].yact != win->area[0].ysize)) {
+                        pr_err("win[1],not support scale\n");
+                        pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
+                                win->area[0].xact,win->area[0].yact,
+                                win->area[0].xsize,win->area[0].ysize);
+                        win->area[0].xsize = win->area[0].xact;
+                        win->area[0].ysize = win->area[0].yact;
+                    }
+	}
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		win->area[0].ysize /= 2;
+		win->area[0].dsp_sty = win->area[0].ypos / 2 +
+				       screen->mode.upper_margin +
+				       screen->mode.vsync_len;
+	} else {
+		win->area[0].dsp_sty = win->area[0].ypos +
+				       screen->mode.upper_margin +
+				       screen->mode.vsync_len;
+	}
+	win->scale_yrgb_x = CalScale(win->area[0].xact, win->area[0].xsize);
+	win->scale_yrgb_y = CalScale(win->area[0].yact, win->area[0].ysize);
+
+	switch (win->area[0].format) {
+	case ARGB888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 0;
+		win->area[0].swap_uv = 0;
+		break;
+	case XBGR888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
+		win->area[0].swap_uv = 0;
+		break;
+	case ABGR888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
+		win->area[0].swap_uv = 0;
+		break;
+	case RGB888:
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
+		win->area[0].swap_rb = 0;
+		win->area[0].swap_uv = 0;
+		break;
+	case RGB565:
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
+		win->area[0].swap_rb = 0;
+		break;
+	case YUV444:
+		if (win_id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR444;
+			win->scale_cbcr_x =
+			    CalScale(win->area[0].xact, win->area[0].xsize);
+			win->scale_cbcr_y =
+			    CalScale(win->area[0].yact, win->area[0].ysize);
+			win->area[0].swap_rb = 0;
+			win->area[0].swap_uv = 0;
+		} else {
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n", __func__);
+		}
+		break;
+	case YUV422:
+		if (win_id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR422;
+			win->scale_cbcr_x = CalScale((win->area[0].xact / 2),
+					    win->area[0].xsize);
+			win->scale_cbcr_y =
+			    CalScale(win->area[0].yact, win->area[0].ysize);
+			win->area[0].swap_rb = 0;
+			win->area[0].swap_uv = 0;
+		} else {
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n", __func__);
+		}
+		break;
+	case YUV420:
+		if (win_id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
+			win->scale_cbcr_x =
+			    CalScale(win->area[0].xact / 2, win->area[0].xsize);
+			win->scale_cbcr_y =
+			    CalScale(win->area[0].yact / 2, win->area[0].ysize);
+			win->area[0].swap_rb = 0;
+		        win->area[0].swap_uv = 0;
+		} else {
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n", __func__);
+		}
+		break;
+	case YUV420_NV21:
+		if (win_id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
+			win->scale_cbcr_x =
+			    CalScale(win->area[0].xact / 2, win->area[0].xsize);
+			win->scale_cbcr_y =
+			    CalScale(win->area[0].yact / 2, win->area[0].ysize);
+			win->area[0].swap_rb = 0;
+			win->area[0].swap_uv = 1;
+		} else {
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n", __func__);
+		}
+		break;
+	default:
+		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
+			__func__);
+		break;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	DBG(1,
+	    "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
+	    ">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id, __func__,
+	    get_format_string(win->area[0].format, fmt), win->area[0].xact,
+	    win->area[0].yact, win->area[0].xsize, win->area[0].ysize,
+	    win->area[0].xvir, win->area[0].yvir, win->area[0].xpos,
+	    win->area[0].ypos);
+	return 0;
+}
+
+static int rk312x_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+
+	if (win_id == 0) {
+		win = dev_drv->win[0];
+	} else if (win_id == 1) {
+		win = dev_drv->win[1];
+	} else if (win_id == 2) {
+		win = dev_drv->win[2];
+	} else {
+		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
+		return -EINVAL;
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		win->area[0].y_addr =
+		    win->area[0].smem_start + win->area[0].y_offset;
+		win->area[0].uv_addr =
+		    win->area[0].cbr_start + win->area[0].c_offset;
+		if (win->area[0].y_addr)
+			lcdc_layer_update_regs(lcdc_dev, win);
+		/* lcdc_cfg_done(lcdc_dev); */
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x>>offset:%d\n",
+	    lcdc_dev->id, __func__, win->area[0].y_addr, win->area[0].uv_addr,
+	    win->area[0].y_offset);
+	/* this is the first frame of the system,enable frame start interrupt */
+	if ((dev_drv->first_frame)) {
+		dev_drv->first_frame = 0;
+		rk312x_lcdc_enable_irq(dev_drv);
+	}
+
+	return 0;
+}
+
+static int rk312x_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
+			     unsigned long arg, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	struct color_key_cfg clr_key_cfg;
+
+	switch (cmd) {
+	case RK_FBIOGET_PANEL_SIZE:
+		panel_size[0] = lcdc_dev->screen->mode.xres;
+		panel_size[1] = lcdc_dev->screen->mode.yres;
+		if (copy_to_user(argp, panel_size, 8))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_COLOR_KEY_CFG:
+		if (copy_from_user(&clr_key_cfg, argp,
+				   sizeof(struct color_key_cfg)))
+			return -EFAULT;
+		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
+			    clr_key_cfg.win0_color_key_cfg);
+		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
+			    clr_key_cfg.win1_color_key_cfg);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int rk312x_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
+				  const char *id)
+{
+	int win_id = 0;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (!strcmp(id, "fb0"))
+		win_id = dev_drv->fb0_win_id;
+	else if (!strcmp(id, "fb1"))
+		win_id = dev_drv->fb1_win_id;
+	else if (!strcmp(id, "fb2"))
+		win_id = dev_drv->fb2_win_id;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return win_id;
+}
+
+static int rk312x_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
+				     int win_id,
+				     int area_id)
+{
+	struct lcdc_device *lcdc_dev =
+	        container_of(dev_drv, struct lcdc_device, driver);
+	int win_status = 0;
+
+	if (win_id == 0)
+	        win_status = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_WIN0_EN);
+	else if (win_id == 1)
+	        win_status = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_WIN1_EN);
+	else if (win_id == 2)
+                win_status = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_HWC_EN);
+	else
+	        pr_err("!!!%s,win_id :%d,unsupport!!!\n",__func__,win_id);
+
+	return win_status;
+}
+
+static int rk312x_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int ovl;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (set) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_TOP,
+				     v_WIN0_TOP(swap));
+			ovl = swap;
+		} else {
+			ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
+		}
+	} else {
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+static int rk312x_lcdc_get_backlight_device(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	struct device_node *backlight;
+
+	if (lcdc_dev->backlight)
+		return 0;
+
+	backlight = of_parse_phandle(lcdc_dev->dev->of_node,
+				     "backlight", 0);
+	if (backlight) {
+		lcdc_dev->backlight = of_find_backlight_by_node(backlight);
+		if (!lcdc_dev->backlight)
+			dev_info(lcdc_dev->dev, "No find backlight device\n");
+	} else {
+		dev_info(lcdc_dev->dev, "No find backlight device node\n");
+	}
+
+	return 0;
+}
+
+static int rk312x_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	if (dev_drv->suspend_flag)
+		return 0;
+
+	/* close the backlight */
+	rk312x_lcdc_get_backlight_device(dev_drv);
+	if (lcdc_dev->backlight) {
+		lcdc_dev->backlight->props.fb_blank = FB_BLANK_POWERDOWN;
+		backlight_update_status(lcdc_dev->backlight);
+	}
+
+	dev_drv->suspend_flag = 1;
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN, v_BLANK_EN(1));
+		lcdc_msk_reg(lcdc_dev, INT_STATUS,
+			     m_FS_INT_CLEAR | m_LF_INT_CLEAR,
+			     v_FS_INT_CLEAR(1) | v_LF_INT_CLEAR(1));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(1));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(1));
+		lcdc_cfg_done(lcdc_dev);
+
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	rk312x_lcdc_clk_disable(lcdc_dev);
+	rk_disp_pwr_disable(dev_drv);
+	return 0;
+}
+
+static int rk312x_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (!dev_drv->suspend_flag)
+		return 0;
+	rk_disp_pwr_enable(dev_drv);
+
+	rk312x_lcdc_clk_enable(lcdc_dev);
+	rk312x_lcdc_reg_restore(lcdc_dev);
+
+	/* config for the FRC mode of dither down */
+	if (dev_drv->cur_screen &&
+			dev_drv->cur_screen->face != OUT_P888) {
+		lcdc_writel(lcdc_dev, FRC_LOWER01_0, 0x12844821);
+		lcdc_writel(lcdc_dev, FRC_LOWER01_1, 0x21488412);
+		lcdc_writel(lcdc_dev, FRC_LOWER10_0, 0x55aaaa55);
+		lcdc_writel(lcdc_dev, FRC_LOWER10_1, 0x55aaaa55);
+		lcdc_writel(lcdc_dev, FRC_LOWER11_0, 0xdeb77deb);
+		lcdc_writel(lcdc_dev, FRC_LOWER11_1, 0xed7bb7de);
+	}
+
+	/* set screen lut */
+	if (dev_drv->cur_screen && dev_drv->cur_screen->dsp_lut)
+		rk312x_lcdc_set_lut(dev_drv,
+				    dev_drv->cur_screen->dsp_lut);
+	/*set hwc lut*/
+	rk312x_lcdc_set_hwc_lut(dev_drv, dev_drv->hwc_lut, 0);
+
+	spin_lock(&lcdc_dev->reg_lock);
+
+	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
+			v_DSP_OUT_ZERO(0));
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			v_LCDC_STANDBY(0));
+	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN, v_BLANK_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+
+	if (dev_drv->iommu_enabled) {
+		if (dev_drv->mmu_dev) {
+			/*
+			 * At here, maybe win is enabled and buffer address
+			 * is not a vaild iommu mapped addr, incase crash,
+			 * delay 30ms to ensure H/W switch done.
+			 */
+			mdelay(30);
+			rockchip_iovmm_activate(dev_drv->dev);
+		}
+	}
+
+	spin_unlock(&lcdc_dev->reg_lock);
+	dev_drv->suspend_flag = 0;
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	mdelay(100);
+
+	return 0;
+}
+
+static int rk312x_lcdc_blank(struct rk_lcdc_driver *dev_drv,
+			     int win_id, int blank_mode)
+{
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		rk312x_lcdc_early_resume(dev_drv);
+		break;
+	case FB_BLANK_NORMAL:
+		rk312x_lcdc_early_suspend(dev_drv);
+		break;
+	default:
+		rk312x_lcdc_early_suspend(dev_drv);
+		break;
+	}
+
+	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
+
+	return 0;
+}
+
+static int rk312x_lcdc_cfg_done(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	int i;
+	struct rk_lcdc_win *win = NULL;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		for (i = 0; i < ARRAY_SIZE(lcdc_win); i++) {
+			win = dev_drv->win[i];
+			if ((win->state == 0) && (win->last_state == 1))
+				lcdc_layer_update_regs(lcdc_dev, win);
+			win->last_state = win->state;
+		}
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+/*
+	a:[-30~0]:
+	    sin_hue = sin(a)*256 +0x100;
+	    cos_hue = cos(a)*256;
+	a:[0~30]
+	    sin_hue = sin(a)*256;
+	    cos_hue = cos(a)*256;
+*/
+static int rk312x_lcdc_get_bcsh_hue(struct rk_lcdc_driver *dev_drv,
+				    bcsh_hue_mode mode)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		val = lcdc_readl(lcdc_dev, BCSH_H);
+		switch (mode) {
+		case H_SIN:
+			val &= m_BCSH_SIN_HUE;
+			break;
+		case H_COS:
+			val &= m_BCSH_COS_HUE;
+			val >>= 16;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return val;
+}
+
+static int rk312x_lcdc_set_bcsh_hue(struct rk_lcdc_driver *dev_drv, int sin_hue,
+				    int cos_hue)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		mask = m_BCSH_SIN_HUE | m_BCSH_COS_HUE;
+		val = v_BCSH_SIN_HUE(sin_hue) | v_BCSH_COS_HUE(cos_hue);
+		lcdc_msk_reg(lcdc_dev, BCSH_H, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk312x_lcdc_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
+				    bcsh_bcs_mode mode, int value)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		switch (mode) {
+		case BRIGHTNESS:
+			/* from 0 to 255,typical is 128 */
+			if (value < 0x80)
+				value += 0x80;
+			else if (value >= 0x80)
+				value = value - 0x80;
+			mask = m_BCSH_BRIGHTNESS;
+			val = v_BCSH_BRIGHTNESS(value);
+			break;
+		case CONTRAST:
+			/* from 0 to 510,typical is 256 */
+			mask = m_BCSH_CONTRAST;
+			val = v_BCSH_CONTRAST(value);
+			break;
+		case SAT_CON:
+			/* from 0 to 1015,typical is 256 */
+			mask = m_BCSH_SAT_CON;
+			val = v_BCSH_SAT_CON(value);
+			break;
+		default:
+			break;
+		}
+		lcdc_msk_reg(lcdc_dev, BCSH_BCS, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return val;
+}
+
+static int rk312x_lcdc_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
+				    bcsh_bcs_mode mode)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		val = lcdc_readl(lcdc_dev, BCSH_BCS);
+		switch (mode) {
+		case BRIGHTNESS:
+			val &= m_BCSH_BRIGHTNESS;
+			if (val > 0x80)
+				val -= 0x80;
+			else
+				val += 0x80;
+			break;
+		case CONTRAST:
+			val &= m_BCSH_CONTRAST;
+			val >>= 8;
+			break;
+		case SAT_CON:
+			val &= m_BCSH_SAT_CON;
+			val >>= 20;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return val;
+}
+
+static int rk312x_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+	if (dev_drv->bcsh_init_status && open) {
+		dev_drv->bcsh_init_status = 0;
+		return 0;
+	}
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (open) {
+			lcdc_msk_reg(lcdc_dev,
+				     BCSH_CTRL, m_BCSH_EN | m_BCSH_OUT_MODE,
+				     v_BCSH_EN(1) | v_BCSH_OUT_MODE(3));
+			lcdc_writel(lcdc_dev, BCSH_BCS,
+				    v_BCSH_BRIGHTNESS(0x00) |
+				    v_BCSH_CONTRAST(0x80) |
+				    v_BCSH_SAT_CON(0x80));
+			lcdc_writel(lcdc_dev, BCSH_H, v_BCSH_COS_HUE(0x80));
+			dev_drv->bcsh.enable = 1;
+		} else {
+			mask = m_BCSH_EN;
+			val = v_BCSH_EN(0);
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL, mask, val);
+			dev_drv->bcsh.enable = 0;
+		}
+		rk312x_lcdc_select_bcsh(dev_drv,  lcdc_dev);
+		lcdc_cfg_done(lcdc_dev);
+	}
+
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk312x_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
+{
+	struct rk_lcdc_win_area area;
+	int fb2_win_id, fb1_win_id, fb0_win_id;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (order == FB_DEFAULT_ORDER)
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
+
+	fb2_win_id = order / 100;
+	fb1_win_id = (order / 10) % 10;
+	fb0_win_id = order % 10;
+
+	if (fb0_win_id != dev_drv->fb0_win_id) {
+		area = dev_drv->win[(int)dev_drv->fb0_win_id]->area[0];
+		dev_drv->win[(int)dev_drv->fb0_win_id]->area[0] =
+			dev_drv->win[fb0_win_id]->area[0];
+		dev_drv->win[fb0_win_id]->area[0] = area;
+		dev_drv->fb0_win_id = fb0_win_id;
+	}
+	dev_drv->fb1_win_id = fb1_win_id;
+	dev_drv->fb2_win_id = fb2_win_id;
+
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return 0;
+}
+
+static int rk312x_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+	u32 pixclock;
+	u32 x_total, y_total;
+
+	if (set) {
+		ft = div_u64(1000000000000llu, fps);
+		x_total =
+		    screen->mode.upper_margin + screen->mode.lower_margin +
+		    screen->mode.yres + screen->mode.vsync_len;
+		y_total =
+		    screen->mode.left_margin + screen->mode.right_margin +
+		    screen->mode.xres + screen->mode.hsync_len;
+		dev_drv->pixclock = div_u64(ft, x_total * y_total);
+		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+	}
+
+	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	dev_drv->pixclock = lcdc_dev->pixclock = pixclock;
+	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
+	screen->ft = 1000 / fps;	/*one frame time in ms */
+
+	if (set)
+		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
+			 clk_get_rate(lcdc_dev->dclk), fps);
+
+	return fps;
+}
+
+static int rk312x_lcdc_set_irq_to_cpu(struct rk_lcdc_driver *dev_drv,
+				      int enable)
+{
+	struct lcdc_device *lcdc_dev =
+				container_of(dev_drv,
+					     struct lcdc_device, driver);
+	if (enable)
+		enable_irq(lcdc_dev->irq);
+	else
+		disable_irq(lcdc_dev->irq);
+	return 0;
+}
+
+static int rk312x_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 int_reg;
+	int ret;
+
+	if (lcdc_dev->clk_on && (!dev_drv->suspend_flag)) {
+		int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
+		if (int_reg & m_LF_INT_STA) {
+			dev_drv->frame_time.last_framedone_t =
+					dev_drv->frame_time.framedone_t;
+			dev_drv->frame_time.framedone_t = cpu_clock(0);
+			lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
+				     v_LF_INT_CLEAR(1));
+			ret = RK_LF_STATUS_FC;
+		} else {
+			ret = RK_LF_STATUS_FR;
+		}
+	} else {
+		ret = RK_LF_STATUS_NC;
+	}
+
+	return ret;
+}
+
+static int rk312x_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
+				    unsigned int dsp_addr[][4])
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (lcdc_dev->clk_on) {
+		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
+		if (lcdc_dev->soc_type == VOP_RK3036)
+			dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_MST);
+		else if (lcdc_dev->soc_type == VOP_RK312X)
+			dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_MST_RK312X);
+	}
+	return 0;
+}
+
+static ssize_t rk312x_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
+					 char *buf, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv, struct lcdc_device,
+						    driver);
+	char format_w0[9] = "NULL";
+	char format_w1[9] = "NULL";
+	char status_w0[9] = "NULL";
+	char status_w1[9] = "NULL";
+	u32 fmt_id, act_info, dsp_info, dsp_st, factor;
+	u16 xvir_w0, x_act_w0, y_act_w0, x_dsp_w0, y_dsp_w0, x_st_w0, y_st_w0;
+	u16 xvir_w1, x_act_w1, y_act_w1, x_dsp_w1, y_dsp_w1, x_st_w1, y_st_w1;
+	u16 x_factor, y_factor, x_scale, y_scale;
+	u16 ovl;
+	u32 win1_dsp_yaddr = 0;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		/* data format */
+		fmt_id = lcdc_readl(lcdc_dev, SYS_CTRL);
+		get_format_string((fmt_id & m_WIN0_FORMAT) >> 3, format_w0);
+		get_format_string((fmt_id & m_WIN1_FORMAT) >> 6, format_w1);
+
+		/* win status */
+		if (fmt_id & m_WIN0_EN)
+			strcpy(status_w0, "enabled");
+		else
+			strcpy(status_w0, "disabled");
+
+		if ((fmt_id & m_WIN1_EN) >> 1)
+			strcpy(status_w1, "enabled");
+		else
+			strcpy(status_w1, "disabled");
+
+		/* ovl */
+		ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
+
+		/* xvir */
+		xvir_w0 = lcdc_readl(lcdc_dev, WIN0_VIR) & m_YRGB_VIR;
+		xvir_w1 = lcdc_readl(lcdc_dev, WIN1_VIR) & m_YRGB_VIR;
+
+		/* xact/yact */
+		act_info = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
+		x_act_w0 = (act_info & m_ACT_WIDTH) + 1;
+		y_act_w0 = ((act_info & m_ACT_HEIGHT) >> 16) + 1;
+
+		if (lcdc_dev->soc_type == VOP_RK3036) {
+			act_info = lcdc_readl(lcdc_dev, WIN1_ACT_INFO);
+			x_act_w1 = (act_info & m_ACT_WIDTH) + 1;
+			y_act_w1 = ((act_info & m_ACT_HEIGHT) >> 16) + 1;
+		} else if (lcdc_dev->soc_type == VOP_RK312X) {
+			/* rk312x unsupport win1 scaler,so have no act info */
+			x_act_w1 = 0;
+			y_act_w1 = 0;
+		}
+
+		/* xsize/ysize */
+		dsp_info = lcdc_readl(lcdc_dev, WIN0_DSP_INFO);
+		x_dsp_w0 = (dsp_info & m_DSP_WIDTH) + 1;
+		y_dsp_w0 = ((dsp_info & m_DSP_HEIGHT) >> 16) + 1;
+
+		if (lcdc_dev->soc_type == VOP_RK3036)
+			dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO);
+		else if (lcdc_dev->soc_type == VOP_RK312X)
+			dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO_RK312X);
+		x_dsp_w1 = (dsp_info & m_DSP_WIDTH) + 1;
+		y_dsp_w1 = ((dsp_info & m_DSP_HEIGHT) >> 16) + 1;
+
+		/* xpos/ypos */
+		dsp_st = lcdc_readl(lcdc_dev, WIN0_DSP_ST);
+		x_st_w0 = dsp_st & m_DSP_STX;
+		y_st_w0 = (dsp_st & m_DSP_STY) >> 16;
+
+		if (lcdc_dev->soc_type == VOP_RK3036)
+			dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST);
+		else if (lcdc_dev->soc_type == VOP_RK312X)
+			dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST_RK312X);
+
+		x_st_w1 = dsp_st & m_DSP_STX;
+		y_st_w1 = (dsp_st & m_DSP_STY) >> 16;
+
+		/* scale factor */
+		factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_YRGB);
+		x_factor = factor & m_X_SCL_FACTOR;
+		y_factor = (factor & m_Y_SCL_FACTOR) >> 16;
+		x_scale = 4096 * 100 / x_factor;
+		y_scale = 4096 * 100 / y_factor;
+
+		/* dsp addr */
+		if (lcdc_dev->soc_type == VOP_RK3036)
+			win1_dsp_yaddr = lcdc_readl(lcdc_dev, WIN1_MST);
+		else if (lcdc_dev->soc_type == VOP_RK312X)
+			win1_dsp_yaddr = lcdc_readl(lcdc_dev, WIN1_MST_RK312X);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return snprintf(buf, PAGE_SIZE,
+			"win0:%s\n"
+			"xvir:%d\n"
+			"xact:%d\n"
+			"yact:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"x_scale:%d.%d\n"
+			"y_scale:%d.%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n"
+			"CBR buffer addr:0x%08x\n\n"
+			"win1:%s\n"
+			"xvir:%d\n"
+			"xact:%d\n"
+			"yact:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n"
+			"overlay:%s\n",
+			status_w0,
+			xvir_w0,
+			x_act_w0,
+			y_act_w0,
+			x_dsp_w0,
+			y_dsp_w0,
+			x_st_w0,
+			y_st_w0,
+			x_scale / 100,
+			x_scale % 100,
+			y_scale / 100,
+			y_scale % 100,
+			format_w0,
+			lcdc_readl(lcdc_dev, WIN0_YRGB_MST),
+			lcdc_readl(lcdc_dev, WIN0_CBR_MST),
+			status_w1,
+			xvir_w1,
+			x_act_w1,
+			y_act_w1,
+			x_dsp_w1,
+			y_dsp_w1,
+			x_st_w1,
+			y_st_w1,
+			format_w1,
+			win1_dsp_yaddr,
+			ovl ? "win0 on the top of win1\n" :
+			"win1 on the top of win0\n");
+}
+
+static int rk312x_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device,
+						    driver);
+	int *cbase = (int *)lcdc_dev->regs;
+	int *regsbak = (int *)lcdc_dev->regsbak;
+	int i, j;
+
+	pr_info("back up reg:\n");
+	for (i = 0; i <= (0xDC >> 4); i++) {
+		for (j = 0; j < 4; j++)
+			pr_info("%08x  ", *(regsbak + i * 4 + j));
+		pr_info("\n");
+	}
+
+	pr_info("lcdc reg:\n");
+	for (i = 0; i <= (0xDC >> 4); i++) {
+		for (j = 0; j < 4; j++)
+			pr_info("%08x  ", readl_relaxed(cbase + i * 4 + j));
+		pr_info("\n");
+	}
+	return 0;
+}
+
+static int rk312x_lcdc_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	if (lcdc_dev->soc_type == VOP_RK312X) {
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_EN,
+			     v_DIRECT_PATH_EN(open));
+		lcdc_cfg_done(lcdc_dev);
+	}
+	return 0;
+}
+
+static int rk312x_lcdc_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+
+	if (lcdc_dev->soc_type == VOP_RK312X) {
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_LAYER,
+			     v_DIRECT_PATH_LAYER(win_id));
+		lcdc_cfg_done(lcdc_dev);
+	}
+	return 0;
+}
+
+static int rk312x_lcdc_dpi_status(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	int ovl = 0;
+
+	if (lcdc_dev->soc_type == VOP_RK312X)
+		ovl = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_EN);
+
+	return ovl;
+}
+
+static int rk312x_lcdc_dsp_black(struct rk_lcdc_driver *dev_drv, int enable)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+
+	rk312x_lcdc_get_backlight_device(dev_drv);
+
+	if (enable) {
+		/* close the backlight */
+		if (lcdc_dev->backlight) {
+			lcdc_dev->backlight->props.power = FB_BLANK_POWERDOWN;
+			backlight_update_status(lcdc_dev->backlight);
+		}
+
+		spin_lock(&lcdc_dev->reg_lock);
+		if (likely(lcdc_dev->clk_on)) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLACK_EN,
+				     v_BLACK_EN(1));
+			lcdc_cfg_done(lcdc_dev);
+		}
+		spin_unlock(&lcdc_dev->reg_lock);
+
+		rk312x_lcdc_standby(dev_drv, true);
+
+		if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+			dev_drv->trsm_ops->disable();
+	} else {
+		spin_lock(&lcdc_dev->reg_lock);
+		if (likely(lcdc_dev->clk_on)) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLACK_EN,
+				     v_BLACK_EN(0));
+			lcdc_cfg_done(lcdc_dev);
+		}
+		spin_unlock(&lcdc_dev->reg_lock);
+
+		if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+			dev_drv->trsm_ops->enable();
+
+		rk312x_lcdc_standby(dev_drv, false);
+
+		msleep(100);
+		/* open the backlight */
+		if (lcdc_dev->backlight) {
+			lcdc_dev->backlight->props.power = FB_BLANK_UNBLANK;
+			backlight_update_status(lcdc_dev->backlight);
+		}
+	}
+
+	return 0;
+}
+
+
+static struct rk_lcdc_drv_ops lcdc_drv_ops = {
+	.open = rk312x_lcdc_open,
+	.load_screen = rk312x_load_screen,
+	.get_dspbuf_info = rk312x_get_dspbuf_info,
+	.post_dspbuf = rk312x_post_dspbuf,
+	.set_par = rk312x_lcdc_set_par,
+	.pan_display = rk312x_lcdc_pan_display,
+	.direct_set_addr = rk312x_lcdc_direct_set_win_addr,
+	.blank = rk312x_lcdc_blank,
+	.ioctl = rk312x_lcdc_ioctl,
+	.get_win_state = rk312x_lcdc_get_win_state,
+	.ovl_mgr = rk312x_lcdc_ovl_mgr,
+	.get_disp_info = rk312x_lcdc_get_disp_info,
+	.fps_mgr = rk312x_lcdc_fps_mgr,
+	.fb_get_win_id = rk312x_lcdc_get_win_id,
+	.fb_win_remap = rk312x_fb_win_remap,
+	.poll_vblank = rk312x_lcdc_poll_vblank,
+	.get_dsp_addr = rk312x_lcdc_get_dsp_addr,
+	.cfg_done = rk312x_lcdc_cfg_done,
+	.dump_reg = rk312x_lcdc_reg_dump,
+	.dpi_open = rk312x_lcdc_dpi_open,
+	.dpi_win_sel = rk312x_lcdc_dpi_win_sel,
+	.dpi_status = rk312x_lcdc_dpi_status,
+	.set_dsp_bcsh_hue = rk312x_lcdc_set_bcsh_hue,
+	.set_dsp_bcsh_bcs = rk312x_lcdc_set_bcsh_bcs,
+	.get_dsp_bcsh_hue = rk312x_lcdc_get_bcsh_hue,
+	.get_dsp_bcsh_bcs = rk312x_lcdc_get_bcsh_bcs,
+	.open_bcsh = rk312x_lcdc_open_bcsh,
+	.set_screen_scaler = rk312x_lcdc_set_scaler,
+	.set_dsp_lut = rk312x_lcdc_set_lut,
+	.set_hwc_lut = rk312x_lcdc_set_hwc_lut,
+	.set_irq_to_cpu = rk312x_lcdc_set_irq_to_cpu,
+	.dsp_black = rk312x_lcdc_dsp_black,
+	.mmu_en = rk312x_lcdc_mmu_en,
+};
+#if 0
+static const struct rk_lcdc_drvdata rk3036_lcdc_drvdata = {
+	.soc_type = VOP_RK3036,
+};
+#endif
+static const struct rk_lcdc_drvdata rk312x_lcdc_drvdata = {
+	.soc_type = VOP_RK312X,
+};
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk312x_lcdc_dt_ids[] = {
+#if 0
+	{
+		.compatible = "rockchip,rk3036-lcdc",
+		.data = (void *)&rk3036_lcdc_drvdata,
+	},
+#endif
+	{
+		.compatible = "rockchip,rk312x-lcdc",
+		.data = (void *)&rk312x_lcdc_drvdata,
+	},
+};
+#endif
+
+static int rk312x_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
+{
+	struct device_node *np = lcdc_dev->dev->of_node;
+	const struct of_device_id *match;
+	const struct rk_lcdc_drvdata *lcdc_drvdata;
+	int val;
+
+	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
+		lcdc_dev->driver.iommu_enabled = 0;
+	else
+		lcdc_dev->driver.iommu_enabled = val;
+
+	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
+		lcdc_dev->driver.fb_win_map = FB_DEFAULT_ORDER;
+	else
+		lcdc_dev->driver.fb_win_map = val;
+
+	match = of_match_node(rk312x_lcdc_dt_ids, np);
+	if (match) {
+		lcdc_drvdata = (const struct rk_lcdc_drvdata *)match->data;
+		lcdc_dev->soc_type = lcdc_drvdata->soc_type;
+	} else {
+		return PTR_ERR(match);
+	}
+
+	return 0;
+}
+
+static int rk312x_lcdc_probe(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = NULL;
+	struct rk_lcdc_driver *dev_drv;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int ret;
+
+	lcdc_dev = devm_kzalloc(dev, sizeof(struct lcdc_device), GFP_KERNEL);
+	if (!lcdc_dev) {
+		dev_err(&pdev->dev, "rk312x lcdc device kzalloc fail!\n");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->dev = dev;
+	if (rk312x_lcdc_parse_dt(lcdc_dev)) {
+		dev_err(lcdc_dev->dev, "rk312x lcdc parse dt failed!\n");
+		goto err_parse_dt;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+	lcdc_dev->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lcdc_dev->regs)) {
+		ret = PTR_ERR(lcdc_dev->regs);
+		goto err_remap_reg;
+	}
+
+	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
+	if (IS_ERR(lcdc_dev->regsbak)) {
+		dev_err(&pdev->dev, "rk312x lcdc device kmalloc fail!\n");
+		ret = PTR_ERR(lcdc_dev->regsbak);
+		goto err_remap_reg;
+	}
+	lcdc_dev->hwc_lut_addr_base = (lcdc_dev->regs + HWC_LUT_ADDR);
+	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + DSP_LUT_ADDR);
+	lcdc_dev->prop = PRMRY;
+	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
+	dev_drv = &lcdc_dev->driver;
+	dev_drv->dev = dev;
+	dev_drv->prop = lcdc_dev->prop;
+	dev_drv->id = lcdc_dev->id;
+	dev_drv->ops = &lcdc_drv_ops;
+	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
+	spin_lock_init(&lcdc_dev->reg_lock);
+
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if (lcdc_dev->irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
+			lcdc_dev->id);
+		ret = -ENXIO;
+		goto err_request_irq;
+	}
+
+	ret = devm_request_irq(dev, lcdc_dev->irq, rk312x_lcdc_isr,
+			       IRQF_DISABLED | IRQF_SHARED,
+			       dev_name(dev), lcdc_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
+			lcdc_dev->irq, ret);
+		goto err_request_irq;
+	}
+
+	if (dev_drv->iommu_enabled)
+		strcpy(dev_drv->mmu_dts_name, VOP_IOMMU_COMPATIBLE_NAME);
+
+	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
+	if (ret < 0) {
+		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
+		goto err_register_fb;
+	}
+	lcdc_dev->screen = dev_drv->screen0;
+
+	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
+		 lcdc_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
+
+	return 0;
+err_register_fb:
+err_request_irq:
+	devm_kfree(lcdc_dev->dev, lcdc_dev->regsbak);
+err_remap_reg:
+err_parse_dt:
+	devm_kfree(&pdev->dev, lcdc_dev);
+	return ret;
+}
+
+#if defined(CONFIG_PM)
+static int rk312x_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk312x_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define rk312x_lcdc_suspend NULL
+#define rk312x_lcdc_resume  NULL
+#endif
+
+static int rk312x_lcdc_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void rk312x_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	struct rk_lcdc_driver *dev_drv=&lcdc_dev->driver;
+
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+	kthread_stop(dev_drv->update_regs_thread);
+
+	rk312x_lcdc_standby(dev_drv, true);
+	rk312x_lcdc_deinit(lcdc_dev);
+	rk312x_lcdc_clk_disable(lcdc_dev);
+	rk_disp_pwr_disable(&lcdc_dev->driver);
+}
+
+static struct platform_driver rk312x_lcdc_driver = {
+	.probe = rk312x_lcdc_probe,
+	.remove = rk312x_lcdc_remove,
+	.driver = {
+		   .name = "rk312x-lcdc",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rk312x_lcdc_dt_ids),
+		   },
+	.suspend = rk312x_lcdc_suspend,
+	.resume = rk312x_lcdc_resume,
+	.shutdown = rk312x_lcdc_shutdown,
+};
+
+static int __init rk312x_lcdc_module_init(void)
+{
+	return platform_driver_register(&rk312x_lcdc_driver);
+}
+
+static void __exit rk312x_lcdc_module_exit(void)
+{
+	platform_driver_unregister(&rk312x_lcdc_driver);
+}
+
+fs_initcall(rk312x_lcdc_module_init);
+module_exit(rk312x_lcdc_module_exit);
diff -Nupr a/drivers/video/rockchip/lcdc/rk312x_lcdc.h b/drivers/video/rockchip/lcdc/rk312x_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk312x_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk312x_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,768 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RK312X_LCDC_H_
+#define _RK312X_LCDC_H_
+
+#include<linux/rk_fb.h>
+#include<linux/io.h>
+#include<linux/clk.h>
+
+enum _VOP_SOC_TYPE {
+        VOP_RK3036 = 0,
+        VOP_RK312X,
+};
+
+
+#define BITS(x, bit)            ((x) << (bit))
+#define BITS_MASK(x, mask, bit) BITS((x) & (mask), bit)
+
+/*******************register definition**********************/
+
+#define SYS_CTRL                (0x00)
+        #define m_WIN0_EN               BITS(1, 0)
+        #define m_WIN1_EN		BITS(1, 1)
+        #define m_HWC_EN		BITS(1, 2)
+        #define m_WIN0_FORMAT		BITS(7, 3)
+        #define m_WIN1_FORMAT		BITS(7, 6)
+        #define m_HWC_LUT_EN		BITS(1, 9)
+        #define m_HWC_SIZE		BITS(1, 10)
+        #define m_DIRECT_PATH_EN        BITS(1, 11)      /* rk312x */
+        #define m_DIRECT_PATH_LAYER     BITS(1, 12)      /* rk312x */
+        #define m_TVE_MODE_SEL          BITS(1, 13)      /* rk312x */
+        #define m_TVE_DAC_EN            BITS(1, 14)      /* rk312x */
+        #define m_WIN0_RB_SWAP		BITS(1, 15)
+        #define m_WIN0_ALPHA_SWAP	BITS(1, 16)
+        #define m_WIN0_Y8_SWAP		BITS(1, 17)
+        #define m_WIN0_UV_SWAP		BITS(1, 18)
+        #define m_WIN1_RB_SWAP		BITS(1, 19)
+        #define m_WIN1_ALPHA_SWAP	BITS(1, 20)
+        #define m_WIN1_ENDIAN_SWAP      BITS(1, 21)      /* rk312x */
+        #define m_WIN0_OTSD_DISABLE	BITS(1, 22)
+        #define m_WIN1_OTSD_DISABLE	BITS(1, 23)
+        #define m_DMA_BURST_LENGTH	BITS(3, 24)
+        #define m_HWC_LODAD_EN		BITS(1, 26)
+        #define m_WIN1_LUT_EN           BITS(1, 27)      /* rk312x */
+        #define m_DSP_LUT_EN            BITS(1, 28)      /* rk312x */
+        #define m_DMA_STOP		BITS(1, 29)
+        #define m_LCDC_STANDBY		BITS(1, 30)
+        #define m_AUTO_GATING_EN	BITS(1, 31)
+	
+        #define v_WIN0_EN(x)		BITS_MASK(x, 1, 0)
+        #define v_WIN1_EN(x)		BITS_MASK(x, 1, 1)
+        #define v_HWC_EN(x)		BITS_MASK(x, 1, 2)
+        #define v_WIN0_FORMAT(x)	BITS_MASK(x, 7, 3)
+        #define v_WIN1_FORMAT(x)	BITS_MASK(x, 7, 6)
+        #define v_HWC_LUT_EN(x)		BITS_MASK(x, 1, 9)
+        #define v_HWC_SIZE(x)		BITS_MASK(x, 1, 10)
+        #define v_DIRECT_PATH_EN(x)     BITS_MASK(x, 1, 11)
+        #define v_DIRECT_PATH_LAYER(x)  BITS_MASK(x, 1, 12)
+        #define v_TVE_MODE_SEL(x)       BITS_MASK(x, 1, 13)
+        #define v_TVE_DAC_EN(x)         BITS_MASK(x, 1, 14)
+        #define v_WIN0_RB_SWAP(x)	BITS_MASK(x, 1, 15)
+        #define v_WIN0_ALPHA_SWAP(x)	BITS_MASK(x, 1, 16)
+        #define v_WIN0_Y8_SWAP(x)	BITS_MASK(x, 1, 17)
+        #define v_WIN0_UV_SWAP(x)	BITS_MASK(x, 1, 18)
+        #define v_WIN1_RB_SWAP(x)	BITS_MASK(x, 1, 19)
+        #define v_WIN1_ALPHA_SWAP(x)	BITS_MASK(x, 1, 20)
+        #define v_WIN1_ENDIAN_SWAP(x)   BITS_MASK(x, 1, 21)
+        #define v_WIN0_OTSD_DISABLE(x)	BITS_MASK(x, 1, 22)
+        #define v_WIN1_OTSD_DISABLE(x)	BITS_MASK(x, 1, 23)
+        #define v_DMA_BURST_LENGTH(x)	BITS_MASK(x, 3, 24)
+        #define v_HWC_LODAD_EN(x)	BITS_MASK(x, 1, 26)
+        #define v_WIN1_LUT_EN(x)	BITS_MASK(x, 1, 27)
+        #define v_DSP_LUT_EN(x)         BITS_MASK(x, 1, 28)
+        #define v_DMA_STOP(x)		BITS_MASK(x, 1, 29)
+        #define v_LCDC_STANDBY(x)	BITS_MASK(x, 1, 30)
+        #define v_AUTO_GATING_EN(x)	BITS_MASK(x, 1, 31)
+
+#define DSP_CTRL0		(0x04)
+        #define m_DSP_OUT_FORMAT	BITS(0x0f, 0)
+        #define m_HSYNC_POL		BITS(1, 4)
+        #define m_VSYNC_POL		BITS(1, 5)
+        #define m_DEN_POL		BITS(1, 6)
+        #define m_DCLK_POL		BITS(1, 7)
+        #define m_WIN0_TOP		BITS(1, 8)
+        #define m_DITHER_UP_EN		BITS(1, 9)
+        #define m_DITHER_DOWN_MODE	BITS(1, 10)	/* use for rk312x */
+        #define m_DITHER_DOWN_EN	BITS(1, 11)	/* use for rk312x */
+        #define m_INTERLACE_DSP_EN	BITS(1, 12)
+        #define m_INTERLACE_FIELD_POL	BITS(1, 13)	/* use for rk312x */
+        #define m_WIN0_INTERLACE_EN	BITS(1, 14)	/* use for rk312x */
+        #define m_WIN1_INTERLACE_EN	BITS(1, 15)
+        #define m_WIN0_YRGB_DEFLICK_EN	BITS(1, 16)
+        #define m_WIN0_CBR_DEFLICK_EN	BITS(1, 17)
+        #define m_WIN0_ALPHA_MODE	BITS(1, 18)
+        #define m_WIN1_ALPHA_MODE	BITS(1, 19)
+        #define m_WIN0_CSC_MODE		BITS(3, 20)
+	#define m_WIN1_CSC_MODE		BITS(1, 22)
+        #define m_WIN0_YUV_CLIP		BITS(1, 23)
+        #define m_TVE_MODE		BITS(1, 25)
+        #define m_SW_UV_OFFSET_EN	BITS(1, 26)	/* use for rk312x */
+        #define m_DITHER_DOWN_SEL	BITS(1, 27)	/* use for rk312x */
+        #define m_HWC_ALPHA_MODE	BITS(1, 28)
+        #define m_ALPHA_MODE_SEL0       BITS(1, 29)
+        #define m_ALPHA_MODE_SEL1	BITS(1, 30)
+        #define m_WIN1_DIFF_DCLK_EN	BITS(1, 31)	/* use for rk3036 */
+        #define m_SW_OVERLAY_MODE	BITS(1, 31)	/* use for rk312x */
+	
+        #define v_DSP_OUT_FORMAT(x)	BITS_MASK(x, 0x0f, 0)
+        #define v_HSYNC_POL(x)		BITS_MASK(x, 1, 4)
+        #define v_VSYNC_POL(x)		BITS_MASK(x, 1, 5)
+        #define v_DEN_POL(x)		BITS_MASK(x, 1, 6)
+        #define v_DCLK_POL(x)		BITS_MASK(x, 1, 7)
+        #define v_WIN0_TOP(x)		BITS_MASK(x, 1, 8)
+        #define v_DITHER_UP_EN(x)	BITS_MASK(x, 1, 9)
+        #define v_DITHER_DOWN_MODE(x)	BITS_MASK(x, 1, 10)	/* rk312x */
+        #define v_DITHER_DOWN_EN(x)	BITS_MASK(x, 1, 11)	/* rk312x */
+        #define v_INTERLACE_DSP_EN(x)	BITS_MASK(x, 1, 12)
+        #define v_INTERLACE_FIELD_POL(x)	BITS_MASK(x, 1, 13)	/* rk312x */
+        #define v_WIN0_INTERLACE_EN(x)		BITS_MASK(x, 1, 14)	/* rk312x */
+        #define v_WIN1_INTERLACE_EN(x)		BITS_MASK(x, 1, 15)
+        #define v_WIN0_YRGB_DEFLICK_EN(x)	BITS_MASK(x, 1, 16)
+        #define v_WIN0_CBR_DEFLICK_EN(x)	BITS_MASK(x, 1, 17)
+        #define v_WIN0_ALPHA_MODE(x)		BITS_MASK(x, 1, 18)
+        #define v_WIN1_ALPHA_MODE(x)		BITS_MASK(x, 1, 19)
+        #define v_WIN0_CSC_MODE(x)		BITS_MASK(x, 3, 20)
+	#define v_WIN1_CSC_MODE(x)		BITS_MASK(x, 1, 22)
+        #define v_WIN0_YUV_CLIP(x)		BITS_MASK(x, 1, 23)
+        #define v_TVE_MODE(x)			BITS_MASK(x, 1, 25)
+        #define v_SW_UV_OFFSET_EN(x)		BITS_MASK(x, 1, 26)      /* rk312x */
+        #define v_DITHER_DOWN_SEL(x)		BITS_MASK(x, 1, 27)      /* rk312x */
+        #define v_HWC_ALPHA_MODE(x)		BITS_MASK(x, 1, 28)
+        #define v_ALPHA_MODE_SEL0(x)            BITS_MASK(x, 1, 29)
+        #define v_ALPHA_MODE_SEL1(x)		BITS_MASK(x, 1, 30)
+        #define v_WIN1_DIFF_DCLK_EN(x)		BITS_MASK(x, 1, 31)	/* rk3036 */
+        #define v_SW_OVERLAY_MODE(x)		BITS_MASK(x, 1, 31)	/* rk312x */
+
+#define DSP_CTRL1		(0x08)
+        #define m_BG_COLOR		BITS(0xffffff, 0)
+        #define m_BG_B			BITS(0xff, 0)
+        #define m_BG_G			BITS(0xff, 8)
+        #define m_BG_R			BITS(0xff, 16)
+        #define m_BLANK_EN		BITS(1, 24)
+        #define m_BLACK_EN		BITS(1, 25)
+        #define m_DSP_BG_SWAP		BITS(1, 26)
+        #define m_DSP_RB_SWAP		BITS(1, 27)
+        #define m_DSP_RG_SWAP		BITS(1, 28)
+        #define m_DSP_DELTA_SWAP	BITS(1, 29)              /* rk3036 */
+        #define m_DSP_DUMMY_SWAP	BITS(1, 30)	        /* rk3036 */
+        #define m_DSP_OUT_ZERO		BITS(1, 31)
+	
+        #define v_BG_COLOR(x)		BITS_MASK(x, 0xffffff, 0)
+        #define v_BG_B(x)		BITS_MASK(x, 0xff, 0)
+        #define v_BG_G(x)		BITS_MASK(x, 0xff, 8)
+        #define v_BG_R(x)		BITS_MASK(x, 0xff, 16)
+        #define v_BLANK_EN(x)		BITS_MASK(x, 1, 24)
+        #define v_BLACK_EN(x)		BITS_MASK(x, 1, 25)
+        #define v_DSP_BG_SWAP(x)	BITS_MASK(x, 1, 26)
+        #define v_DSP_RB_SWAP(x)	BITS_MASK(x, 1, 27)
+        #define v_DSP_RG_SWAP(x)	BITS_MASK(x, 1, 28)
+        #define v_DSP_DELTA_SWAP(x)	BITS_MASK(x, 1, 29)      /* rk3036 */
+        #define v_DSP_DUMMY_SWAP(x)	BITS_MASK(x, 1, 30)      /* rk3036 */
+        #define v_DSP_OUT_ZERO(x)	BITS_MASK(x, 1, 31)
+
+#define INT_SCALER              (0x0c)          /* only use for rk312x */
+        #define m_SCALER_EMPTY_INTR_EN  BITS(1, 0)
+        #define m_SCLAER_EMPTY_INTR_CLR BITS(1, 1)
+        #define m_SCLAER_EMPTY_INTR_STA BITS(1, 2)
+        #define m_FS_MASK_EN            BITS(1, 3)
+        #define m_HDMI_HSYNC_POL        BITS(1, 4)
+        #define m_HDMI_VSYNC_POL        BITS(1, 5)
+        #define m_HDMI_DEN_POL          BITS(1, 6)
+
+        #define v_SCALER_EMPTY_INTR_EN(x)       BITS_MASK(x, 1, 0)
+        #define v_SCLAER_EMPTY_INTR_CLR(x)      BITS_MASK(x, 1, 1)
+        #define v_SCLAER_EMPTY_INTR_STA(x)      BITS_MASK(x, 1, 2)
+        #define v_FS_MASK_EN(x)                 BITS_MASK(x, 1, 3)
+        #define v_HDMI_HSYNC_POL(x)             BITS_MASK(x, 1, 4)
+        #define v_HDMI_VSYNC_POL(x)             BITS_MASK(x, 1, 5)
+        #define v_HDMI_DEN_POL(x)               BITS_MASK(x, 1, 6)
+
+#define INT_STATUS		(0x10)
+        #define m_HS_INT_STA		BITS(1, 0)
+        #define m_FS_INT_STA		BITS(1, 1)
+        #define m_LF_INT_STA		BITS(1, 2)
+        #define m_BUS_ERR_INT_STA	BITS(1, 3)
+        #define m_HS_INT_EN		BITS(1, 4)
+        #define m_FS_INT_EN          	BITS(1, 5)
+        #define m_LF_INT_EN         	BITS(1, 6)
+        #define m_BUS_ERR_INT_EN	BITS(1, 7)
+        #define m_HS_INT_CLEAR		BITS(1, 8)
+        #define m_FS_INT_CLEAR		BITS(1, 9)
+        #define m_LF_INT_CLEAR		BITS(1, 10)
+        #define m_BUS_ERR_INT_CLEAR	BITS(1, 11)
+        #define m_LF_INT_NUM		BITS(0xfff, 12)
+        #define m_WIN0_EMPTY_INT_EN	BITS(1, 24)
+        #define m_WIN1_EMPTY_INT_EN	BITS(1, 25)
+        #define m_WIN0_EMPTY_INT_CLEAR	BITS(1, 26)
+        #define m_WIN1_EMPTY_INT_CLEAR	BITS(1, 27)
+        #define m_WIN0_EMPTY_INT_STA	BITS(1, 28)
+        #define m_WIN1_EMPTY_INT_STA	BITS(1, 29)
+        #define m_FS_RAW_STA		BITS(1, 30)
+        #define m_LF_RAW_STA		BITS(1, 31)
+	
+        #define v_HS_INT_EN(x)		BITS_MASK(x, 1, 4)
+        #define v_FS_INT_EN(x)		BITS_MASK(x, 1, 5)
+        #define v_LF_INT_EN(x)		BITS_MASK(x, 1, 6)
+        #define v_BUS_ERR_INT_EN(x)	BITS_MASK(x, 1, 7)
+        #define v_HS_INT_CLEAR(x)	BITS_MASK(x, 1, 8)
+        #define v_FS_INT_CLEAR(x)	BITS_MASK(x, 1, 9)
+        #define v_LF_INT_CLEAR(x)	BITS_MASK(x, 1, 10)
+        #define v_BUS_ERR_INT_CLEAR(x)	BITS_MASK(x, 1, 11)
+        #define v_LF_INT_NUM(x)		BITS_MASK(x, 0xfff, 12)
+        #define v_WIN0_EMPTY_INT_EN(x)	BITS_MASK(x, 1, 24)
+        #define v_WIN1_EMPTY_INT_EN(x)	BITS_MASK(x, 1, 25)
+        #define v_WIN0_EMPTY_INT_CLEAR(x)	BITS_MASK(x, 1, 26)
+        #define v_WIN1_EMPTY_INT_CLEAR(x)	BITS_MASK(x, 1, 27)
+
+#define ALPHA_CTRL		(0x14)
+        #define m_WIN0_ALPHA_EN		BITS(1, 0)
+        #define m_WIN1_ALPHA_EN		BITS(1, 1)
+        #define m_HWC_ALPAH_EN		BITS(1, 2)
+        #define m_WIN1_PREMUL_SCALE	BITS(1, 3)               /* rk3036 */
+        #define m_WIN0_ALPHA_VAL	BITS(0xff, 4)
+        #define m_WIN1_ALPHA_VAL	BITS(0xff, 12)
+        #define m_HWC_ALPAH_VAL		BITS(0xff, 20)
+	
+        #define v_WIN0_ALPHA_EN(x)	BITS_MASK(x, 1, 0)
+        #define v_WIN1_ALPHA_EN(x)	BITS_MASK(x, 1, 1)
+        #define v_HWC_ALPAH_EN(x)	BITS_MASK(x, 1, 2)
+        #define v_WIN1_PREMUL_SCALE(x)	BITS_MASK(x, 1, 3)       /* rk3036 */
+        #define v_WIN0_ALPHA_VAL(x)	BITS_MASK(x, 0xff, 4)
+        #define v_WIN1_ALPHA_VAL(x)	BITS_MASK(x, 0xff, 12)
+        #define v_HWC_ALPAH_VAL(x)	BITS_MASK(x, 0xff, 20)
+
+#define WIN0_COLOR_KEY		(0x18)
+#define WIN1_COLOR_KEY		(0x1c)
+        #define m_COLOR_KEY_VAL		BITS(0xffffff, 0)
+        #define m_COLOR_KEY_EN		BITS(1, 24)
+
+        #define v_COLOR_KEY_VAL(x)	BITS_MASK(x, 0xffffff, 0)
+        #define v_COLOR_KEY_EN(x)	BITS_MASK(x, 1, 24)
+
+/* Layer Registers */
+#define WIN0_YRGB_MST		(0x20)
+#define WIN0_CBR_MST		(0x24)
+#define WIN1_MST		(0xa0)                  /* rk3036 */
+#define WIN1_MST_RK312X         (0x4c)                  /* rk312x */
+#define HWC_MST			(0x58)
+
+#define WIN1_VIR		(0x28)
+#define WIN0_VIR		(0x30)
+        #define m_YRGB_VIR	        BITS(0x1fff, 0)
+        #define m_CBBR_VIR	        BITS(0x1fff, 16)   
+	
+        #define v_YRGB_VIR(x)           BITS_MASK(x, 0x1fff, 0)
+        #define v_CBBR_VIR(x)           BITS_MASK(x, 0x1fff, 16)
+	
+	#define v_ARGB888_VIRWIDTH(x)	BITS_MASK(x, 0x1fff, 0)
+	#define v_RGB888_VIRWIDTH(x) 	BITS_MASK(((x*3)>>2)+((x)%3), 0x1fff, 0)
+	#define v_RGB565_VIRWIDTH(x)	BITS_MASK(DIV_ROUND_UP(x, 2), 0x1fff, 0)
+	#define v_YUV_VIRWIDTH(x)	BITS_MASK(DIV_ROUND_UP(x, 4), 0x1fff, 0)
+	#define v_CBCR_VIR(x)		BITS_MASK(x, 0x1fff, 16)
+
+#define WIN0_ACT_INFO		(0x34)
+#define WIN1_ACT_INFO		(0xb4)          /* rk3036 */
+	#define m_ACT_WIDTH       	BITS(0x1fff, 0)
+	#define m_ACT_HEIGHT      	BITS(0x1fff, 16)
+ 
+	#define v_ACT_WIDTH(x)       	BITS_MASK(x - 1, 0x1fff, 0)
+	#define v_ACT_HEIGHT(x)      	BITS_MASK(x - 1, 0x1fff, 16)
+
+#define WIN0_DSP_INFO		(0x38)
+#define WIN1_DSP_INFO		(0xb8)          /* rk3036 */
+#define WIN1_DSP_INFO_RK312X    (0x50)          /* rk312x */
+        #define m_DSP_WIDTH       	BITS(0x7ff, 0)
+	#define m_DSP_HEIGHT      	BITS(0x7ff, 16)
+
+	#define v_DSP_WIDTH(x)     	BITS_MASK(x - 1, 0x7ff, 0)
+	#define v_DSP_HEIGHT(x)    	BITS_MASK(x - 1, 0x7ff, 16)
+	
+#define WIN0_DSP_ST		(0x3c)
+#define WIN1_DSP_ST		(0xbc)          /* rk3036 */
+#define WIN1_DSP_ST_RK312X      (0x54)          /* rk312x */
+#define HWC_DSP_ST		(0x5c)
+        #define m_DSP_STX               BITS(0xfff, 0)
+	#define m_DSP_STY               BITS(0xfff, 16)
+
+	#define v_DSP_STX(x)      	BITS_MASK(x, 0xfff, 0)
+	#define v_DSP_STY(x)      	BITS_MASK(x, 0xfff, 16)
+	
+#define WIN0_SCL_FACTOR_YRGB	(0x40)
+#define WIN0_SCL_FACTOR_CBR	(0x44)
+#define WIN1_SCL_FACTOR_YRGB	(0xc0)          /* rk3036 */
+        #define m_X_SCL_FACTOR          BITS(0xffff, 0)
+	#define m_Y_SCL_FACTOR          BITS(0xffff, 16)
+
+	#define v_X_SCL_FACTOR(x)  	BITS_MASK(x, 0xffff, 0)
+	#define v_Y_SCL_FACTOR(x)  	BITS_MASK(x, 0xffff, 16)
+	
+#define WIN0_SCL_OFFSET		(0x48)
+#define WIN1_SCL_OFFSET		(0xc8)          /* rk3036 */
+
+/* LUT Registers */
+#define WIN1_LUT_ADDR 		(0x0400)        /* rk3036 */
+#define HWC_LUT_ADDR   		(0x0800)
+#define DSP_LUT_ADDR            (0x0c00)        /* rk312x */
+
+/* Display Infomation Registers */
+#define DSP_HTOTAL_HS_END	(0x6c)
+	#define v_HSYNC(x)  		BITS_MASK(x, 0xfff, 0)   /* hsync pulse width */
+	#define v_HORPRD(x) 		BITS_MASK(x, 0xfff, 16)  /* horizontal period */
+
+#define DSP_HACT_ST_END		(0x70)
+	#define v_HAEP(x) 		BITS_MASK(x, 0xfff, 0)  /* horizontal active end point */
+	#define v_HASP(x) 		BITS_MASK(x, 0xfff, 16) /* horizontal active start point */
+
+#define DSP_VTOTAL_VS_END	(0x74)
+	#define v_VSYNC(x) 		BITS_MASK(x, 0xfff, 0)
+	#define v_VERPRD(x) 		BITS_MASK(x, 0xfff, 16)
+	
+#define DSP_VACT_ST_END		(0x78)
+	#define v_VAEP(x) 		BITS_MASK(x, 0xfff, 0)
+	#define v_VASP(x) 		BITS_MASK(x, 0xfff, 16)
+
+#define DSP_VS_ST_END_F1	(0x7c)
+	#define v_VSYNC_END_F1(x) 	BITS_MASK(x, 0xfff, 0)
+	#define v_VSYNC_ST_F1(x) 	BITS_MASK(x, 0xfff, 16)
+#define DSP_VACT_ST_END_F1	(0x80)
+        #define v_VAEP_F1(x) 		BITS_MASK(x, 0xfff, 0)
+	#define v_VASP_F1(x) 		BITS_MASK(x, 0xfff, 16)
+
+/* Scaler Registers 
+ * Only used for rk312x
+ */
+#define SCALER_CTRL             (0xa0)
+        #define m_SCALER_EN             BITS(1, 0)
+        #define m_SCALER_SYNC_INVERT    BITS(1, 2)
+        #define m_SCALER_DEN_INVERT     BITS(1, 3)
+        #define m_SCALER_OUT_ZERO       BITS(1, 4)
+        #define m_SCALER_OUT_EN         BITS(1, 5)
+        #define m_SCALER_VSYNC_MODE     BITS(3, 6)
+        #define m_SCALER_VSYNC_VST      BITS(0xff, 8)
+
+        #define v_SCALER_EN(x)          BITS_MASK(x, 1, 0)
+        #define v_SCALER_SYNC_INVERT(x) BITS_MASK(x, 1, 2)
+        #define v_SCALER_DEN_INVERT(x)  BITS_MASK(x, 1, 3)
+        #define v_SCALER_OUT_ZERO(x)    BITS_MASK(x, 1, 4)
+        #define v_SCALER_OUT_EN(x)      BITS_MASK(x, 1, 5)
+        #define v_SCALER_VSYNC_MODE(x)  BITS_MASK(x, 3, 6)
+        #define v_SCALER_VSYNC_VST(x)   BITS_MASK(x, 0xff, 8)
+
+#define SCALER_FACTOR           (0xa4)
+        #define m_SCALER_H_FACTOR       BITS(0x3fff, 0)
+        #define m_SCALER_V_FACTOR       BITS(0x3fff, 16)
+
+        #define v_SCALER_H_FACTOR(x)    BITS_MASK(x, 0x3fff, 0)
+        #define v_SCALER_V_FACTOR(x)    BITS_MASK(x, 0x3fff, 16)
+
+#define SCALER_FRAME_ST         (0xa8)
+        #define m_SCALER_FRAME_HST      BITS(0xfff, 0)
+        #define m_SCALER_FRAME_VST      BITS(0xfff, 16)
+
+        #define v_SCALER_FRAME_HST(x)   BITS_MASK(x, 0xfff, 0)
+        #define v_SCALER_FRAME_VST(x)   BITS_MASK(x, 0xfff, 16)
+
+#define SCALER_DSP_HOR_TIMING   (0xac)
+        #define m_SCALER_HTOTAL         BITS(0xfff, 0)
+        #define m_SCALER_HS_END         BITS(0xff, 16)
+
+        #define v_SCALER_HTOTAL(x)      BITS_MASK(x, 0xfff, 0)
+        #define v_SCALER_HS_END(x)      BITS_MASK(x, 0xff, 16)
+
+#define SCALER_DSP_HACT_ST_END  (0xb0)
+        #define m_SCALER_HAEP           BITS(0xfff, 0)
+        #define m_SCALER_HASP           BITS(0x3ff, 16)
+
+        #define v_SCALER_HAEP(x)        BITS_MASK(x, 0xfff, 0)
+        #define v_SCALER_HASP(x)        BITS_MASK(x, 0x3ff, 16)
+
+#define SCALER_DSP_VER_TIMING   (0xb4)
+        #define m_SCALER_VTOTAL         BITS(0xfff, 0)
+        #define m_SCALER_VS_END         BITS(0xff, 16)
+
+        #define v_SCALER_VTOTAL(x)      BITS_MASK(x, 0xfff, 0)
+        #define v_SCALER_VS_END(x)      BITS_MASK(x, 0xff, 16)
+
+#define SCALER_DSP_VACT_ST_END  (0xb8)
+        #define m_SCALER_VAEP           BITS(0xfff, 0)
+        #define m_SCALER_VASP           BITS(0xff, 16)
+
+        #define v_SCALER_VAEP(x)        BITS_MASK(x, 0xfff, 0)
+        #define v_SCALER_VASP(x)        BITS_MASK(x, 0xff, 16)
+
+#define SCALER_DSP_HBOR_TIMING  (0xbc)
+        #define m_SCALER_HBOR_END       BITS(0xfff, 0)
+        #define m_SCALER_HBOR_ST        BITS(0x3ff, 16)
+
+        #define v_SCALER_HBOR_END(x)    BITS_MASK(x, 0xfff, 0)
+        #define v_SCALER_HBOR_ST(x)     BITS_MASK(x, 0x3ff, 16)
+
+#define SCALER_DSP_VBOR_TIMING  (0xc0)
+        #define m_SCALER_VBOR_END       BITS(0xfff, 0)
+        #define m_SCALER_VBOR_ST        BITS(0xff, 16)
+
+        #define v_SCALER_VBOR_END(x)    BITS_MASK(x, 0xfff, 0)
+        #define v_SCALER_VBOR_ST(x)     BITS_MASK(x, 0xff, 16)        
+
+/* BCSH Registers */
+#define BCSH_CTRL		(0xd0)
+	#define m_BCSH_EN		BITS(1, 0)
+        #define m_BCSH_R2Y_CSC_MODE     BITS(1, 1)       /* rk312x */
+	#define m_BCSH_OUT_MODE		BITS(3, 2)
+	#define m_BCSH_Y2R_CSC_MODE     BITS(3, 4)
+        #define m_BCSH_Y2R_EN           BITS(1, 6)       /* rk312x */
+        #define m_BCSH_R2Y_EN           BITS(1, 7)       /* rk312x */
+	
+	#define v_BCSH_EN(x)		BITS_MASK(x, 1, 0)
+        #define v_BCSH_R2Y_CSC_MODE(x)  BITS_MASK(x, 1, 1)       /* rk312x */
+	#define v_BCSH_OUT_MODE(x)	BITS_MASK(x, 3, 2)
+	#define v_BCSH_Y2R_CSC_MODE(x)	BITS_MASK(x, 3, 4)
+        #define v_BCSH_Y2R_EN(x)        BITS_MASK(x, 1, 6)       /* rk312x */
+        #define v_BCSH_R2Y_EN(x)        BITS_MASK(x, 1, 7)       /* rk312x */
+
+#define BCSH_COLOR_BAR 		(0xd4)
+        #define m_BCSH_COLOR_BAR_Y      BITS(0xff, 0)
+	#define m_BCSH_COLOR_BAR_U	BITS(0xff, 8)
+	#define m_BCSH_COLOR_BAR_V	BITS(0xff, 16)
+
+	#define v_BCSH_COLOR_BAR_Y(x)	BITS_MASK(x, 0xff, 0)
+	#define v_BCSH_COLOR_BAR_U(x)   BITS_MASK(x, 0xff, 8)
+	#define v_BCSH_COLOR_BAR_V(x)   BITS_MASK(x, 0xff, 16)
+
+#define BCSH_BCS 		(0xd8)	
+	#define m_BCSH_BRIGHTNESS	BITS(0x1f, 0)	
+	#define m_BCSH_CONTRAST		BITS(0xff, 8)
+	#define m_BCSH_SAT_CON		BITS(0x1ff, 16)
+
+	#define v_BCSH_BRIGHTNESS(x)	BITS_MASK(x, 0x1f, 0)	
+	#define v_BCSH_CONTRAST(x)	BITS_MASK(x, 0xff, 8)	
+	#define v_BCSH_SAT_CON(x)       BITS_MASK(x, 0x1ff, 16)			
+
+#define BCSH_H 			(0xdc)	
+	#define m_BCSH_SIN_HUE		BITS(0xff, 0)
+	#define m_BCSH_COS_HUE		BITS(0xff, 8)
+
+	#define v_BCSH_SIN_HUE(x)	BITS_MASK(x, 0xff, 0)
+	#define v_BCSH_COS_HUE(x)	BITS_MASK(x, 0xff, 8)
+
+#define FRC_LOWER01_0           (0xe0)
+#define FRC_LOWER01_1           (0xe4)
+#define FRC_LOWER10_0           (0xe8)
+#define FRC_LOWER10_1           (0xec)
+#define FRC_LOWER11_0           (0xf0)
+#define FRC_LOWER11_1           (0xf4)
+
+/* Bus Register */
+#define AXI_BUS_CTRL		(0x2c)
+	#define m_IO_PAD_CLK			BITS(1, 31)
+	#define m_CORE_CLK_DIV_EN		BITS(1, 30)
+        #define m_MIPI_DCLK_INVERT              BITS(1, 29)      /* rk312x */
+        #define m_MIPI_DCLK_EN                  BITS(1, 28)      /* rk312x */
+        #define m_LVDS_DCLK_INVERT              BITS(1, 27)      /* rk312x */
+        #define m_LVDS_DCLK_EN                  BITS(1, 26)      /* rk312x */
+        #define m_RGB_DCLK_INVERT               BITS(1, 25)      /* rk312x */
+        #define m_RGB_DCLK_EN                   BITS(1, 24)      /* rk312x */
+	#define m_HDMI_DCLK_INVERT		BITS(1, 23)
+	#define m_HDMI_DCLK_EN			BITS(1, 22)
+	#define m_TVE_DAC_DCLK_INVERT		BITS(1, 21)
+	#define m_TVE_DAC_DCLK_EN		BITS(1, 20)
+	#define m_HDMI_DCLK_DIV_EN		BITS(1, 19)
+	#define m_AXI_OUTSTANDING_MAX_NUM	BITS(0x1f, 12)
+	#define m_AXI_MAX_OUTSTANDING_EN	BITS(1, 11)
+	#define m_MMU_EN			BITS(1, 10)
+	#define m_NOC_HURRY_THRESHOLD		BITS(0xf, 6)
+	#define m_NOC_HURRY_VALUE		BITS(3, 4)
+	#define m_NOC_HURRY_EN			BITS(1, 3)
+	#define m_NOC_QOS_VALUE			BITS(3, 1)
+	#define m_NOC_QOS_EN			BITS(1, 0)
+	
+	#define v_IO_PAD_CLK(x)			BITS_MASK(x, 1, 31)
+	#define v_CORE_CLK_DIV_EN(x)		BITS_MASK(x, 1, 30)
+        #define v_MIPI_DCLK_INVERT(x)           BITS_MASK(x, 1, 29)
+        #define v_MIPI_DCLK_EN(x)               BITS_MASK(x, 1, 28)
+        #define v_LVDS_DCLK_INVERT(x)           BITS_MASK(x, 1, 27)
+        #define v_LVDS_DCLK_EN(x)               BITS_MASK(x, 1, 26)
+        #define v_RGB_DCLK_INVERT(x)            BITS_MASK(x, 1, 25)
+        #define v_RGB_DCLK_EN(x)                BITS_MASK(x, 1, 24)
+	#define v_HDMI_DCLK_INVERT(x)		BITS_MASK(x, 1, 23)
+	#define v_HDMI_DCLK_EN(x)		BITS_MASK(x, 1, 22)
+	#define v_TVE_DAC_DCLK_INVERT(x)	BITS_MASK(x, 1, 21)
+	#define v_TVE_DAC_DCLK_EN(x)		BITS_MASK(x, 1, 20)
+	#define v_HDMI_DCLK_DIV_EN(x)		BITS_MASK(x, 1, 19)
+	#define v_AXI_OUTSTANDING_MAX_NUM(x)	BITS_MASK(x, 0x1f, 12)
+	#define v_AXI_MAX_OUTSTANDING_EN(x)	BITS_MASK(x, 1, 11)
+	#define v_MMU_EN(x)			BITS_MASK(x, 1, 10)
+	#define v_NOC_HURRY_THRESHOLD(x)	BITS_MASK(x, 0xf, 6)
+	#define v_NOC_HURRY_VALUE(x)		BITS_MASK(x, 3, 4)
+	#define v_NOC_HURRY_EN(x)		BITS_MASK(x, 1, 3)
+	#define v_NOC_QOS_VALUE(x)		BITS_MASK(x, 3, 1)
+	#define v_NOC_QOS_EN(x)			BITS_MASK(x, 1, 0)
+	
+#define GATHER_TRANSFER		(0x84)
+	#define m_WIN1_AXI_GATHER_NUM		BITS(0xf, 12)
+	#define m_WIN0_CBCR_AXI_GATHER_NUM	BITS(0x7, 8)
+	#define m_WIN0_YRGB_AXI_GATHER_NUM	BITS(0xf, 4)
+	#define m_WIN1_AXI_GAHTER_EN		BITS(1, 2)
+	#define m_WIN0_CBCR_AXI_GATHER_EN	BITS(1, 1)
+	#define m_WIN0_YRGB_AXI_GATHER_EN	BITS(1, 0)
+	
+	#define v_WIN1_AXI_GATHER_NUM(x)	BITS_MASK(x, 0xf, 12)
+	#define v_WIN0_CBCR_AXI_GATHER_NUM(x)	BITS_MASK(x, 0x7, 8)
+	#define v_WIN0_YRGB_AXI_GATHER_NUM(x)	BITS_MASK(x, 0xf, 4)
+	#define v_WIN1_AXI_GAHTER_EN(x)		BITS_MASK(x, 1, 2)
+	#define v_WIN0_CBCR_AXI_GATHER_EN(x)	BITS_MASK(x, 1, 1)
+	#define v_WIN0_YRGB_AXI_GATHER_EN(x)	BITS_MASK(x, 1, 0)
+	
+#define VERSION_INFO		(0x94)
+	#define m_MAJOR		                BITS(0xff, 24)
+	#define m_MINOR		                BITS(0xff, 16)
+	#define m_BUILD		                BITS(0xffff)
+		
+#define REG_CFG_DONE		(0x90)
+
+/* TV Control Registers */
+#define TV_CTRL			(0x200)	
+#define TV_SYNC_TIMING		(0x204)
+#define TV_ACT_TIMING		(0x208)
+#define TV_ADJ_TIMING		(0x20c)
+#define TV_FREQ_SC		(0x210)
+#define TV_FILTER0		(0x214)
+#define TV_FILTER1		(0x218)
+#define TV_FILTER2		(0x21C)
+#define TV_ACT_ST		(0x234)
+#define TV_ROUTING		(0x238)
+#define TV_SYNC_ADJUST		(0x250)
+#define TV_STATUS		(0x254)
+#define TV_RESET		(0x268)
+#define TV_SATURATION		(0x278)
+#define TV_BW_CTRL		(0x28C)
+#define TV_BRIGHTNESS_CONTRAST	(0x290)
+
+
+/* MMU registers */
+#define MMU_DTE_ADDR		(0x0300)
+        #define m_MMU_DTE_ADDR			BITS(0xffffffff, 0)
+	#define v_MMU_DTE_ADDR(x)		BITS_MASK(x, 0xffffffff, 0)
+
+#define MMU_STATUS		(0x0304)
+        #define m_PAGING_ENABLED		BITS(1, 0)
+	#define m_PAGE_FAULT_ACTIVE		BITS(1, 1)
+	#define m_STAIL_ACTIVE			BITS(1, 2)
+	#define m_MMU_IDLE			BITS(1, 3)
+	#define m_REPLAY_BUFFER_EMPTY		BITS(1, 4)
+	#define m_PAGE_FAULT_IS_WRITE		BITS(1, 5)
+	#define m_PAGE_FAULT_BUS_ID		BITS(0x1f, 6)
+
+	#define v_PAGING_ENABLED(x)		BITS_MASK(x, 1, 0)
+	#define v_PAGE_FAULT_ACTIVE(x)		BITS_MASK(x, 1, 1)
+	#define v_STAIL_ACTIVE(x)		BITS_MASK(x, 1, 2)
+	#define v_MMU_IDLE(x)			BITS_MASK(x, 1, 3)
+	#define v_REPLAY_BUFFER_EMPTY(x)	BITS_MASK(x, 1, 4)
+	#define v_PAGE_FAULT_IS_WRITE(x)	BITS_MASK(x, 1, 5)
+	#define v_PAGE_FAULT_BUS_ID(x)		BITS_MASK(x, 0x1f, 6)
+	
+#define MMU_COMMAND		(0x0308)
+        #define m_MMU_CMD			BITS(0x7, 0)
+	#define v_MMU_CMD(x)			BITS_MASK(x, 0x7, 0)	
+
+#define MMU_PAGE_FAULT_ADDR	(0x030c)
+        #define m_PAGE_FAULT_ADDR		BITS(0xffffffff, 0)
+	#define v_PAGE_FAULT_ADDR(x)		BITS_MASK(x, 0xffffffff, 0)
+	
+#define MMU_ZAP_ONE_LINE	(0x0310)
+        #define m_MMU_ZAP_ONE_LINE		BITS(0xffffffff, 0)
+	#define v_MMU_ZAP_ONE_LINE(x)		BITS_MASK(x, 0xffffffff, 0)
+
+#define MMU_INT_RAWSTAT		(0x0314)
+        #define m_PAGE_FAULT_RAWSTAT		BITS(1, 0)
+	#define m_READ_BUS_ERROR_RAWSTAT	BITS(1, 1)
+ 
+	#define v_PAGE_FAULT_RAWSTAT(x)		BITS(x, 1, 0)
+	#define v_READ_BUS_ERROR_RAWSTAT(x)	BITS(x, 1, 1)
+	
+#define MMU_INT_CLEAR		(0x0318)
+        #define m_PAGE_FAULT_CLEAR		BITS(1, 0)
+	#define m_READ_BUS_ERROR_CLEAR		BITS(1, 1)
+
+	#define v_PAGE_FAULT_CLEAR(x)		BITS(x, 1, 0)
+	#define v_READ_BUS_ERROR_CLEAR(x)	BITS(x, 1, 1)
+	
+#define MMU_INT_MASK		(0x031c)
+        #define m_PAGE_FAULT_MASK		BITS(1, 0)
+	#define m_READ_BUS_ERROR_MASK		BITS(1, 1)
+
+	#define v_PAGE_FAULT_MASK(x)		BITS(x, 1, 0)
+	#define v_READ_BUS_ERROR_MASK(x)	BITS(x, 1, 1)
+	
+#define MMU_INT_STATUS		(0x0320)
+        #define m_PAGE_FAULT_STATUS		BITS(1, 0)
+	#define m_READ_BUS_ERROR_STATUS		BITS(1, 1)
+
+	#define v_PAGE_FAULT_STATUS(x)		BITS(x, 1, 0)
+	#define v_READ_BUS_ERROR_STATUS(x)	BITS(x, 1, 1)
+
+#define MMU_AUTO_GATING		(0x0324)
+        #define m_MMU_AUTO_GATING		BITS(1, 0)
+	#define v_MMU_AUTO_GATING(x)		BITS(x, 1, 0)
+
+
+enum _vop_dma_burst {
+	DMA_BURST_16 = 0,
+	DMA_BURST_8,
+	DMA_BURST_4
+};
+
+enum _vop_format_e {
+	VOP_FORMAT_ARGB888 = 0,
+	VOP_FORMAT_RGB888,
+	VOP_FORMAT_RGB565,
+	VOP_FORMAT_YCBCR420 = 4,
+	VOP_FORMAT_YCBCR422,
+	VOP_FORMAT_YCBCR444
+};
+
+enum _vop_tv_mode {
+	TV_NTSC,
+	TV_PAL,
+};
+
+enum _vop_r2y_csc_mode {
+	VOP_R2Y_CSC_BT601 = 0,
+	VOP_R2Y_CSC_BT709
+};
+
+enum _vop_y2r_csc_mode {
+	VOP_Y2R_CSC_MPEG = 0,
+	VOP_Y2R_CSC_JPEG,
+	VOP_Y2R_CSC_HD,
+	VOP_Y2R_CSC_BYPASS
+};
+
+enum _vop_hwc_size {
+	VOP_HWC_SIZE_32,
+	VOP_HWC_SIZE_64
+};
+
+enum _vop_overlay_mode {
+	VOP_RGB_DOMAIN,
+	VOP_YUV_DOMAIN
+};
+
+
+#define CalScale(x, y)	             ((((u32)(x - 1)) * 0x1000) / (y - 1))
+#define INT_STA_MSK	(m_HS_INT_STA | m_FS_INT_STA |		\
+			 m_LF_INT_STA | m_BUS_ERR_INT_STA)
+#define INT_CLR_SHIFT	8
+
+struct rk_lcdc_drvdata {
+     u8 soc_type;
+     u32 reserve;
+};
+
+struct lcdc_device {
+	int id;
+        u8 soc_type;
+	struct rk_lcdc_driver driver;
+	struct device *dev;
+	struct rk_screen *screen;
+
+	void __iomem *regs;
+	void *regsbak;			/* back up reg */
+	u32 reg_phy_base;       	/* physical basic address of lcdc register */
+	u32 len;               		/* physical map length of lcdc register */
+	spinlock_t  reg_lock;		/* one time only one process allowed to config the register */
+
+	int __iomem *hwc_lut_addr_base;
+	int __iomem *dsp_lut_addr_base;
+
+	int prop;			/* used for primary or extended display device */
+	bool pre_init;
+	bool pwr18;			/* if lcdc use 1.8v power supply */
+	bool clk_on;			/* if aclk or hclk is closed ,acess to register is not allowed */
+	bool sclk_on;			/* if sclk is open or closed */
+	u8 atv_layer_cnt;		/* active layer counter,when atv_layer_cnt = 0,lcdc is disable*/
+
+	unsigned int		irq;
+
+	struct clk		*pd;	/* lcdc power domain */
+	struct clk		*hclk;	/* lcdc AHP clk */
+	struct clk		*dclk;	/* lcdc dclk */
+	struct clk		*aclk;	/* lcdc share memory frequency */
+        struct clk              *sclk;  /* scaler clk */
+	struct clk		*pll_sclk;
+	u32 pixclock;
+        u32 s_pixclock;
+
+	u32 standby;			/* 1:standby,0:work */
+	struct backlight_device *backlight;
+	u32 iommu_status;
+};
+
+static inline void lcdc_writel(struct lcdc_device *lcdc_dev, u32 offset, u32 v)
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);	
+	*_pv = v;
+	writel_relaxed(v, lcdc_dev->regs + offset);	
+}
+
+static inline u32 lcdc_readl(struct lcdc_device *lcdc_dev, u32 offset)
+{
+	u32 v;
+	v = readl_relaxed(lcdc_dev->regs + offset);
+	return v;
+}
+
+static inline u32 lcdc_readl_backup(struct lcdc_device *lcdc_dev, u32 offset)
+{
+	u32 v;
+	u32 *_pv = (u32*)lcdc_dev->regsbak;
+	_pv += (offset >> 2);
+	v = readl_relaxed(lcdc_dev->regs + offset);
+	*_pv = v;
+	return v;
+}
+
+static inline u32 lcdc_read_bit(struct lcdc_device *lcdc_dev, u32 offset,
+                                u32 msk) 
+{
+       u32 _v = readl_relaxed(lcdc_dev->regs + offset); 
+       _v &= msk;
+       return (_v? 1 : 0);   
+}
+
+static inline void  lcdc_set_bit(struct lcdc_device *lcdc_dev, u32 offset,
+                                 u32 msk) 
+{
+	u32* _pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);				
+	(*_pv) |= msk;				
+	writel_relaxed(*_pv, lcdc_dev->regs + offset); 
+} 
+
+static inline void lcdc_clr_bit(struct lcdc_device *lcdc_dev, u32 offset,
+                                u32 msk)
+{
+	u32* _pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);				
+	(*_pv) &= (~msk);				
+	writel_relaxed(*_pv, lcdc_dev->regs + offset); 
+} 
+
+static inline void  lcdc_msk_reg(struct lcdc_device *lcdc_dev, u32 offset,
+                                 u32 msk, u32 v)
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);			
+	(*_pv) &= (~msk);				
+	(*_pv) |= v;				
+	writel_relaxed(*_pv, lcdc_dev->regs + offset);	
+}
+
+static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev) 
+{
+	writel_relaxed(0x01, lcdc_dev->regs + REG_CFG_DONE); 
+	dsb();	
+} 
+
+#endif /* _RK312X_LCDC_H_ */
diff -Nupr a/drivers/video/rockchip/lcdc/rk3188_lcdc.c b/drivers/video/rockchip/lcdc/rk3188_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk3188_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3188_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1666 @@
+/*
+ * drivers/video/rockchip/lcdc/rk3188_lcdc.c
+ *
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *Author:yxj<yxj@rock-chips.com>
+ *This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <asm/div64.h>
+#include <asm/uaccess.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/iomap.h>
+#include <linux/rockchip/grf.h>
+
+#include "rk3188_lcdc.h"
+
+
+static int dbg_thresd;
+module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
+
+#define DBG(level, x...) do {			\
+	if (unlikely(dbg_thresd >= level))	\
+		printk(KERN_INFO x); } while (0)
+
+//#define WAIT_FOR_SYNC 1
+
+static int rk3188_lcdc_get_id(u32 phy_base)
+{
+	if (cpu_is_rk319x()) {
+		if (phy_base == 0xffc40000)
+			return 0;
+		else if (phy_base == 0xffc50000)
+			return 1;
+		else
+			return -EINVAL;
+	} else if (cpu_is_rk3188()) {
+		if (phy_base == 0x1010c000)
+			return 0;
+		else if (phy_base == 0x1010e000)
+			return 1;
+		else
+			return -EINVAL;
+	} else if (cpu_is_rk3026()) {
+		if (phy_base == 0x1010e000)
+			return 0;
+		else if (phy_base == 0x01110000)
+			return 1;
+		else
+			return -EINVAL;
+	} else {
+		pr_err("un supported platform \n");
+		return -EINVAL;
+	}
+
+}
+
+static int rk3188_lcdc_set_lut(struct rk_lcdc_driver *dev_drv)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+							   struct
+							   lcdc_device,
+							   driver);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	mdelay(25);
+	for (i = 0; i < 256; i++) {
+		v = dev_drv->cur_screen->dsp_lut[i];
+		c = lcdc_dev->dsp_lut_addr_base + i;
+		writel_relaxed(v, c);
+
+	}
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
+
+	return 0;
+
+}
+
+static int rk3188_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
+{
+
+	if (!lcdc_dev->clk_on) {
+		clk_prepare_enable(lcdc_dev->hclk);
+		clk_prepare_enable(lcdc_dev->dclk);
+		clk_prepare_enable(lcdc_dev->aclk);
+		//clk_enable(lcdc_dev->pd);
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 1;
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	return 0;
+}
+
+static int rk3188_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
+{
+	if (lcdc_dev->clk_on) {
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 0;
+		spin_unlock(&lcdc_dev->reg_lock);
+		mdelay(25);
+		clk_disable_unprepare(lcdc_dev->dclk);
+		clk_disable_unprepare(lcdc_dev->hclk);
+		clk_disable_unprepare(lcdc_dev->aclk);
+		//clk_disable(lcdc_dev->pd);
+	}
+	return 0;
+}
+
+static int rk3188_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						struct lcdc_device,
+						driver);
+	int *cbase = (int *)lcdc_dev->regs;
+	int *regsbak = (int *)lcdc_dev->regsbak;
+	int i, j;
+
+	printk("back up reg:\n");
+	for (i = 0; i <= (0x90 >> 4); i++) {
+		for (j = 0; j < 4; j++)
+			printk("%08x  ", *(regsbak + i * 4 + j));
+		printk("\n");
+	}
+
+	printk("lcdc reg:\n");
+	for (i = 0; i <= (0x90 >> 4); i++) {
+		for (j = 0; j < 4; j++)
+			printk("%08x  ", readl_relaxed(cbase + i * 4 + j));
+		printk("\n");
+	}
+	return 0;
+}
+
+static void rk3188_lcdc_read_reg_defalut_cfg(struct lcdc_device
+					     *lcdc_dev)
+{
+	int reg = 0;
+	u32 value = 0;
+	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
+	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	for (reg = 0; reg < REG_CFG_DONE; reg += 4) {
+		value = lcdc_readl(lcdc_dev, reg);
+		switch (reg) {
+		case SYS_CTRL:
+			lcdc_dev->standby = (value & m_LCDC_STANDBY) >> 17;
+			win0->state = (value & m_WIN0_EN) >> 0;
+			win1->state = (value & m_WIN1_EN) >> 1;
+			if (lcdc_dev->id == 0)
+				lcdc_dev->atv_layer_cnt = win0->state;
+			else
+				lcdc_dev->atv_layer_cnt = win1->state;
+			win0->area[0].swap_rb = (value & m_WIN0_RB_SWAP) >> 15;
+			win1->area[0].swap_rb = (value & m_WIN1_RB_SWAP) >> 19;
+			win0->area[0].fmt_cfg = (value & m_WIN0_FORMAT) >> 3;
+			win1->area[0].fmt_cfg = (value & m_WIN1_FORMAT) >> 6;
+			break;
+		case WIN0_SCL_FACTOR_YRGB:
+			win0->scale_yrgb_x = (value >> 0) & 0xffff;
+			win0->scale_yrgb_y = (value >> 16) & 0xffff;
+			break;
+		case WIN0_SCL_FACTOR_CBR:
+			win0->scale_cbcr_x = (value >> 0) & 0xffff;
+			win0->scale_cbcr_y = (value >> 16) & 0xffff;
+			break;
+		case WIN0_ACT_INFO:
+			win0->area[0].xact = (((value >> 0) & 0x1fff) + 1);
+			win0->area[0].yact = (((value >> 16) & 0x1fff) + 1);
+			break;
+		case WIN0_DSP_ST:
+			win0->area[0].dsp_stx = (value >> 0) & 0xfff;
+			win0->area[0].dsp_sty = (value >> 16) & 0xfff;
+			break;
+		case WIN0_DSP_INFO:
+			win0->area[0].xsize = (((value >> 0) & 0x7ff) + 1);
+			win0->area[0].ysize = (((value >> 16) & 0x7ff) + 1);
+			break;
+		case WIN_VIR:
+			win0->area[0].y_vir_stride = (value >> 0) & 0x1fff;
+			win1->area[0].y_vir_stride = (value) & 0x1fff0000;
+			break;
+		case WIN0_YRGB_MST0:
+			win0->area[0].y_addr = value >> 0;
+			break;
+		case WIN0_CBR_MST0:
+			win0->area[0].uv_addr = value >> 0;
+			break;
+		case WIN1_DSP_INFO:
+			win1->area[0].xsize = (((value >> 0) & 0x7ff) + 1);
+			win1->area[0].ysize = (((value >> 16) & 0x7ff) + 1);
+			break;
+		case WIN1_DSP_ST:
+			win1->area[0].dsp_stx = (value >> 0) & 0xfff;
+			win1->area[0].dsp_sty = (value >> 16) & 0xfff;
+			break;
+		case WIN1_MST:
+			win1->area[0].y_addr = value >> 0;
+			break;
+		default:
+			DBG(2, "%s:uncare reg\n", __func__);
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+}
+
+/********do basic init*********/
+static int rk3188_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
+{
+	int v;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+							   struct
+							   lcdc_device,
+							   driver);
+
+	if (lcdc_dev->pre_init)
+		return 0;
+
+	if (lcdc_dev->id == 0) {
+		//lcdc_dev->pd  = clk_get(NULL,"pd_lcdc0");
+		lcdc_dev->hclk = clk_get(NULL, "g_h_lcdc0");
+		lcdc_dev->aclk = clk_get(NULL, "aclk_lcdc0");
+		lcdc_dev->dclk = clk_get(NULL, "dclk_lcdc0");
+	} else if (lcdc_dev->id == 1) {
+		//lcdc_dev->pd  = clk_get(NULL,"pd_lcdc1");
+		lcdc_dev->hclk = clk_get(NULL, "g_h_lcdc1");
+		lcdc_dev->aclk = clk_get(NULL, "aclk_lcdc1");
+		lcdc_dev->dclk = clk_get(NULL, "dclk_lcdc1");
+	} else {
+		dev_err(lcdc_dev->dev, "invalid lcdc device!\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||
+	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
+		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
+			lcdc_dev->id);
+	}
+
+	/*uboot display has enabled lcdc in boot */
+	if (!support_uboot_display()) {
+		rk_disp_pwr_enable(dev_drv);
+		rk3188_lcdc_clk_enable(lcdc_dev);
+	} else {
+		lcdc_dev->clk_on = 1;
+	}
+
+	rk3188_lcdc_read_reg_defalut_cfg(lcdc_dev);
+
+	if (lcdc_dev->id == 0) {
+		if (lcdc_dev->pwr18 == true) {
+			v = 0x40004000;	/*bit14: 1,1.8v;0,3.3v*/
+			writel_relaxed(v, RK_GRF_VIRT + RK3188_GRF_IO_CON4);
+		} else {
+			v = 0x40000000;
+			writel_relaxed(v, RK_GRF_VIRT + RK3188_GRF_IO_CON4);
+		}
+	}
+
+	if (lcdc_dev->id == 1) {
+		if (lcdc_dev->pwr18 == true) {
+			v = 0x80008000;	/*bit14: 1,1.8v;0,3.3v*/
+			writel_relaxed(v, RK_GRF_VIRT + RK3188_GRF_IO_CON4);
+		} else {
+			v = 0x80000000;
+			writel_relaxed(v, RK_GRF_VIRT + RK3188_GRF_IO_CON4);
+		}
+		pinctrl_select_state(lcdc_dev->dev->pins->p,
+				     lcdc_dev->dev->pins->default_state);
+	}
+
+	lcdc_set_bit(lcdc_dev, SYS_CTRL, m_AUTO_GATING_EN);
+	lcdc_cfg_done(lcdc_dev);
+	lcdc_dev->pre_init = true;
+
+	return 0;
+}
+
+static void rk3188_lcdc_deint(struct lcdc_device *lcdc_dev)
+{
+	u32 mask, val;
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_dev->clk_on = 0;
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
+			     v_FS_INT_CLEAR(1));
+		mask = m_HS_INT_EN | m_FS_INT_EN | m_LF_INT_EN |
+			m_BUS_ERR_INT_EN;
+		val = v_HS_INT_EN(0) | v_FS_INT_EN(0) |
+			v_LF_INT_EN(0) | v_BUS_ERR_INT_EN(0);
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, mask, val);
+		lcdc_set_bit(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY);
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	mdelay(1);
+
+}
+
+static int rk3188_lcdc_alpha_cfg(struct lcdc_device *lcdc_dev)
+{
+	int win0_top = 0;
+	u32 mask, val;
+	enum data_format win0_format = lcdc_dev->driver.win[0]->area[0].format;
+	enum data_format win1_format = lcdc_dev->driver.win[1]->area[0].format;
+
+	int win0_alpha_en = ((win0_format == ARGB888)
+			     || (win0_format == ABGR888)) ? 1 : 0;
+	int win1_alpha_en = ((win1_format == ARGB888)
+			     || (win1_format == ABGR888)) ? 1 : 0;
+	u32 *_pv = (u32 *) lcdc_dev->regsbak;
+	_pv += (DSP_CTRL0 >> 2);
+	win0_top = ((*_pv) & (m_WIN0_TOP)) >> 8;
+	if (win0_top && (lcdc_dev->atv_layer_cnt >= 2) && (win0_alpha_en)) {
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, m_WIN0_ALPHA_EN |
+			     m_WIN1_ALPHA_EN, v_WIN0_ALPHA_EN(1) |
+			     v_WIN1_ALPHA_EN(0));
+		mask = m_WIN0_ALPHA_MODE | m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1;
+		val = v_WIN0_ALPHA_MODE(1) | v_ALPHA_MODE_SEL0(1) | v_ALPHA_MODE_SEL1(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+	} else if ((!win0_top) && (lcdc_dev->atv_layer_cnt >= 2)
+		   && (win1_alpha_en)) {
+		mask =  m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
+		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(1);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+
+		mask = m_WIN1_ALPHA_MODE | m_ALPHA_MODE_SEL0 | m_ALPHA_MODE_SEL1;
+		val = v_WIN1_ALPHA_MODE(1) | v_ALPHA_MODE_SEL0(1) | v_ALPHA_MODE_SEL1(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+	} else {
+		mask = m_WIN0_ALPHA_EN | m_WIN1_ALPHA_EN;
+		val = v_WIN0_ALPHA_EN(0) | v_WIN1_ALPHA_EN(0);
+		lcdc_msk_reg(lcdc_dev, ALPHA_CTRL, mask, val);
+	}
+
+	return 0;
+}
+
+static int rk3188_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
+	struct rk_lcdc_win *win1 = lcdc_dev->driver.win[1];
+	int timeout;
+	unsigned long flags;
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(lcdc_dev->standby));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL,
+			     m_WIN0_EN | m_WIN1_EN | m_WIN0_RB_SWAP |
+			     m_WIN1_RB_SWAP,
+			     v_WIN0_EN(win0->state) | v_WIN1_EN(win1->state) |
+			     v_WIN0_RB_SWAP(win0->area[0].swap_rb) |
+			     v_WIN1_RB_SWAP(win1->area[0].swap_rb));
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,
+			    v_X_SCL_FACTOR(win0->scale_yrgb_x) |
+			    v_Y_SCL_FACTOR(win0->scale_yrgb_y));
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,
+			    v_X_SCL_FACTOR(win0->scale_cbcr_x) |
+			    v_Y_SCL_FACTOR(win0->scale_cbcr_y));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_FORMAT,
+			     v_WIN0_FORMAT(win0->area[0].fmt_cfg));
+		lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_ACT_WIDTH(win0->area[0].xact) |
+			    v_ACT_HEIGHT(win0->area[0].yact));
+		lcdc_writel(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(win0->area[0].dsp_stx) |
+			    v_DSP_STY(win0->area[0].dsp_sty));
+		lcdc_writel(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(win0->area[0].xsize) |
+			    v_DSP_HEIGHT(win0->area[0].ysize));
+		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN0_VIR,
+			     v_WIN0_VIR_VAL(win0->area[0].y_vir_stride));
+		lcdc_writel(lcdc_dev, WIN0_YRGB_MST0, win0->area[0].y_addr);
+		lcdc_writel(lcdc_dev, WIN0_CBR_MST0, win0->area[0].uv_addr);
+		lcdc_writel(lcdc_dev, WIN1_DSP_INFO, v_DSP_WIDTH(win1->area[0].xsize) |
+			    v_DSP_HEIGHT(win1->area[0].ysize));
+		lcdc_writel(lcdc_dev, WIN1_DSP_ST, v_DSP_STX(win1->area[0].dsp_stx) |
+			    v_DSP_STY(win1->area[0].dsp_sty));
+		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR,
+			     ((win1->area[0].y_vir_stride)&0x1fff)<<16);
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_FORMAT,
+			     v_WIN1_FORMAT(win1->area[0].fmt_cfg));
+		lcdc_writel(lcdc_dev, WIN1_MST, win1->area[0].y_addr);
+		rk3188_lcdc_alpha_cfg(lcdc_dev);
+		lcdc_cfg_done(lcdc_dev);
+
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	//if (dev_drv->wait_fs) {
+	if (0) {
+		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
+						      msecs_to_jiffies
+						      (dev_drv->cur_screen->ft +
+						       5));
+		if (!timeout && (!dev_drv->frame_done.done)) {
+			dev_warn(lcdc_dev->dev, "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
+	return 0;
+
+}
+
+static int rk3188_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
+{
+	memcpy((u8 *) lcdc_dev->regs, (u8 *) lcdc_dev->regsbak, 0x84);
+	return 0;
+}
+
+
+static int rk3188_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
+{
+	int ret = -EINVAL;
+	int fps;
+	u16 face = 0;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 right_margin = screen->mode.right_margin;
+	u16 left_margin = screen->mode.left_margin;
+	u16 lower_margin = screen->mode.lower_margin;
+	u16 upper_margin = screen->mode.upper_margin;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		switch (screen->face) {
+		case OUT_P565:
+			face = OUT_P565;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
+			    v_DITHER_DOWN_SEL(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+			break;
+		case OUT_P666:
+			face = OUT_P666;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
+			    v_DITHER_DOWN_SEL(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+			break;
+		case OUT_D888_P565:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
+			    v_DITHER_DOWN_SEL(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+			break;
+		case OUT_D888_P666:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
+			    v_DITHER_DOWN_SEL(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+			break;
+		case OUT_P888:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN;
+			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(0);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+			break;
+		default:
+			dev_err(lcdc_dev->dev, "un supported interface!\n");
+			break;
+		}
+
+		mask = m_DSP_OUT_FORMAT | m_HSYNC_POL | m_VSYNC_POL |
+		    m_DEN_POL | m_DCLK_POL;
+		val = v_DSP_OUT_FORMAT(face) | v_HSYNC_POL(screen->pin_hsync) |
+		    v_VSYNC_POL(screen->pin_vsync) | v_DEN_POL(screen->pin_den) |
+		    v_DCLK_POL(screen->pin_dclk);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+
+		mask = m_BG_COLOR | m_DSP_BG_SWAP | m_DSP_RB_SWAP |
+		    m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
+		    m_DSP_DUMMY_SWAP | m_BLANK_EN;
+		val = v_BG_COLOR(0x000000) | v_DSP_BG_SWAP(screen->swap_gb) |
+		    v_DSP_RB_SWAP(screen->swap_rb) | v_DSP_RG_SWAP(screen->
+								   swap_rg) |
+		    v_DSP_DELTA_SWAP(screen->
+				     swap_delta) | v_DSP_DUMMY_SWAP(screen->
+								    swap_dumy) |
+		    v_BLANK_EN(0) | v_BLACK_EN(0);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+		val =
+		    v_HSYNC(screen->mode.hsync_len) | v_HORPRD(screen->mode.
+							       hsync_len +
+							       left_margin +
+							       x_res +
+							       right_margin);
+		lcdc_writel(lcdc_dev, DSP_HTOTAL_HS_END, val);
+		val = v_HAEP(screen->mode.hsync_len + left_margin + x_res) |
+		    v_HASP(screen->mode.hsync_len + left_margin);
+		lcdc_writel(lcdc_dev, DSP_HACT_ST_END, val);
+
+		val =
+		    v_VSYNC(screen->mode.vsync_len) | v_VERPRD(screen->mode.
+							       vsync_len +
+							       upper_margin +
+							       y_res +
+							       lower_margin);
+		lcdc_writel(lcdc_dev, DSP_VTOTAL_VS_END, val);
+
+		val = v_VAEP(screen->mode.vsync_len + upper_margin + y_res) |
+		    v_VASP(screen->mode.vsync_len + screen->mode.upper_margin);
+		lcdc_writel(lcdc_dev, DSP_VACT_ST_END, val);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
+	if (ret)
+		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
+	lcdc_dev->pixclock =
+	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
+
+	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
+	screen->ft = 1000 / fps;
+	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
+		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	if (screen->init)
+		screen->init();
+
+	return 0;
+}
+
+/*enable layer,open:1,enable;0 disable*/
+static int win0_open(struct lcdc_device *lcdc_dev, bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt++;
+		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.win[0]->state = open;
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN, v_WIN0_EN(open));
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int win1_open(struct lcdc_device *lcdc_dev, bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt++;
+		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.win[1]->state = open;
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN, v_WIN1_EN(open));
+		/*if no layer used,disable lcdc*/
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk3188_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
+			    bool open)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+
+	/*enable clk,when first layer open */
+	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
+		rk3188_lcdc_pre_init(dev_drv);
+		rk3188_lcdc_clk_enable(lcdc_dev);
+		rk3188_lcdc_reg_restore(lcdc_dev);
+		rk3188_load_screen(dev_drv, 1);
+		spin_lock(&lcdc_dev->reg_lock);
+		if (dev_drv->cur_screen->dsp_lut)
+			rk3188_lcdc_set_lut(dev_drv);
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	if (win_id == 0)
+		win0_open(lcdc_dev, open);
+	else if (win_id == 1)
+		win1_open(lcdc_dev, open);
+	else
+		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
+
+	/*when all layer closed,disable clk */
+	if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
+		lcdc_msk_reg(lcdc_dev, INT_STATUS,
+			     m_FS_INT_CLEAR, v_FS_INT_CLEAR(1));
+		rk3188_lcdc_reg_update(dev_drv);
+		rk3188_lcdc_clk_disable(lcdc_dev);
+	}
+
+	return 0;
+}
+
+static int win0_display(struct lcdc_device *lcdc_dev,
+			struct rk_lcdc_win *win)
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = win->area[0].smem_start+win->area[0].y_offset;
+	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
+	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",
+	    	lcdc_dev->id, __func__, y_addr, uv_addr);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_writel(lcdc_dev, WIN0_YRGB_MST0, y_addr);
+		lcdc_writel(lcdc_dev, WIN0_CBR_MST0, uv_addr);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+
+}
+
+static int win1_display(struct lcdc_device *lcdc_dev,
+			struct rk_lcdc_win *win)
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
+	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",
+	    lcdc_dev->id, __func__, y_addr, uv_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on))
+		lcdc_writel(lcdc_dev,WIN1_MST,y_addr);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+
+static int rk3188_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv, 
+						struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u32 msk, val;
+#if defined(WAIT_FOR_SYNC)
+	int timeout;
+	unsigned long flags;
+#endif
+
+	if (!screen) {
+		dev_err(dev_drv->dev,"screen is null!\n");
+		return -ENOENT;
+	}
+	
+	if (win_id == 0) {
+		win = dev_drv->win[0];
+		win0_display(lcdc_dev, win);
+	} else if(win_id==1) {
+		win = dev_drv->win[1];
+		win1_display(lcdc_dev, win);
+	} else {
+		dev_err(dev_drv->dev,"invalid win number:%d!\n", win_id);
+		return -EINVAL;
+	}
+
+	 /*this is the first frame of the system ,enable frame start interrupt*/
+	if ((dev_drv->first_frame))  {
+		dev_drv->first_frame = 0;
+		msk = m_FS_INT_CLEAR |m_FS_INT_EN;
+		val = v_FS_INT_CLEAR(1) | v_FS_INT_EN(1);
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, msk, val);
+
+	}
+
+#if defined(WAIT_FOR_SYNC)
+	spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+	init_completion(&dev_drv->frame_done);
+	spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+	timeout = wait_for_completion_timeout(&dev_drv->frame_done,
+				msecs_to_jiffies(dev_drv->cur_screen->ft +5));
+	if (!timeout && (!dev_drv->frame_done.done)) {
+		dev_info(dev_drv->dev, "wait for new frame start time out!\n");
+		return -ETIMEDOUT;
+	}
+#endif
+
+	return 0;
+}
+
+
+static int win0_set_par(struct lcdc_device *lcdc_dev,
+			struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	u8 fmt_cfg = 0;
+	char fmt[9] = "NULL";
+	xact = win->area[0].xact;
+	yact = win->area[0].yact;
+	xvir = win->area[0].xvir;
+	yvir = win->area[0].yvir;
+	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
+	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
+
+	ScaleYrgbX = CalScale(xact, win->area[0].xsize);
+	ScaleYrgbY = CalScale(yact, win->area[0].ysize);
+	switch (win->area[0].format) {
+	case ARGB888:
+	case XBGR888:
+	case ABGR888:
+		fmt_cfg = 0;
+		break;
+	case RGB888:
+		fmt_cfg = 1;
+		break;
+	case RGB565:
+		fmt_cfg = 2;
+		break;
+	case YUV422:
+		fmt_cfg = 5;
+		ScaleCbrX = CalScale((xact / 2), win->area[0].xsize);
+		ScaleCbrY = CalScale(yact, win->area[0].ysize);
+		break;
+	case YUV420:
+		fmt_cfg = 4;
+		ScaleCbrX = CalScale(xact / 2, win->area[0].xsize);
+		ScaleCbrY = CalScale(yact / 2, win->area[0].ysize);
+		break;
+	case YUV444:
+		fmt_cfg = 6;
+		ScaleCbrX = CalScale(xact, win->area[0].xsize);
+		ScaleCbrY = CalScale(yact, win->area[0].ysize);
+		break;
+	default:
+		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
+			__func__);
+		break;
+	}
+
+	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
+		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
+		__func__, get_format_string(win->area[0].format, fmt), xact,
+		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	
+	win->scale_yrgb_x = ScaleYrgbX;
+	win->scale_yrgb_y = ScaleYrgbY;
+	win->scale_cbcr_x = ScaleCbrX;
+	win->scale_cbcr_y = ScaleCbrY;
+	win->area[0].fmt_cfg = fmt_cfg;
+	win->area[0].dsp_stx = xpos;
+	win->area[0].dsp_sty = ypos;
+	
+	switch (win->area[0].format) {
+	case XBGR888:
+	case ABGR888:
+		win->area[0].swap_rb = 1;
+		break;
+	case ARGB888:
+		win->area[0].swap_rb = 0;
+		break;
+	case RGB888:
+		win->area[0].swap_rb = 0;
+		break;
+	case RGB565:
+		win->area[0].swap_rb = 0;
+		break;
+	case YUV422:
+	case YUV420:
+	case YUV444:
+		win->area[0].swap_rb = 0;
+		break;
+	default:
+		dev_err(lcdc_dev->driver.dev,
+			"%s:un supported format!\n", __func__);
+		break;
+	}
+
+	
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB,v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX) | v_Y_SCL_FACTOR(ScaleCbrY));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL,m_WIN0_FORMAT,v_WIN0_FORMAT(fmt_cfg));         
+		lcdc_writel(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
+		lcdc_writel(lcdc_dev, WIN0_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		lcdc_writel(lcdc_dev, WIN0_DSP_INFO,v_DSP_WIDTH(win->area[0].xsize) |
+						v_DSP_HEIGHT(win->area[0].ysize));
+		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN0_VIR, v_WIN0_VIR_VAL(win->area[0].y_vir_stride));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN0_EN | m_WIN0_RB_SWAP,
+			     v_WIN0_EN(win->state) |
+			     v_WIN0_RB_SWAP(win->area[0].swap_rb));
+		lcdc_msk_reg(lcdc_dev, WIN0_COLOR_KEY, m_COLOR_KEY_EN, v_COLOR_KEY_EN(0));
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+
+}
+
+static int win1_set_par(struct lcdc_device *lcdc_dev,
+			struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u8 fmt_cfg;
+	char fmt[9] = "NULL";
+	xact = win->area[0].xact;
+	yact = win->area[0].yact;
+	xvir = win->area[0].xvir;
+	yvir = win->area[0].yvir;
+	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
+	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
+
+	DBG(1, "lcdc%d>>%s>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
+		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
+		__func__, get_format_string(win->area[0].format, fmt),
+		xact, yact, win->area[0].xsize, win->area[0].ysize,
+		xvir, yvir, xpos, ypos);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	win->area[0].dsp_stx = xpos;
+	win->area[0].dsp_sty = ypos;
+	switch (win->area[0].format) {
+	case XBGR888:
+	case ABGR888:
+		fmt_cfg = 0;
+		win->area[0].swap_rb = 1;
+		break;
+	case ARGB888:
+		fmt_cfg = 0;
+		win->area[0].swap_rb = 0;
+
+		break;
+	case RGB888:
+		fmt_cfg = 1;
+		win->area[0].swap_rb = 0;
+		break;
+	case RGB565:
+		fmt_cfg = 2;
+		win->area[0].swap_rb = 0;
+		break;
+	default:
+		dev_err(lcdc_dev->driver.dev,
+			"%s:un supported format!\n", __func__);
+		break;
+	}
+	win->area[0].fmt_cfg = fmt_cfg;
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_writel(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(win->area[0].xsize) |
+							v_DSP_HEIGHT(win->area[0].ysize));
+		lcdc_writel(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_WIN1_EN | m_WIN1_RB_SWAP,
+			     v_WIN1_EN(win->state) |
+			     v_WIN1_RB_SWAP(win->area[0].swap_rb));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL,m_WIN1_FORMAT, v_WIN1_FORMAT(fmt_cfg));
+		lcdc_msk_reg(lcdc_dev, WIN_VIR, m_WIN1_VIR,
+			     ((win->area[0].y_vir_stride)&0x1fff)<<16);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk3188_lcdc_set_par(struct rk_lcdc_driver *dev_drv,int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+	
+	if (win_id == 0) {
+		win = dev_drv->win[0];
+		win0_set_par(lcdc_dev, screen, win);
+	} else if (win_id == 1) {
+		win = dev_drv->win[1];
+		win1_set_par(lcdc_dev, screen, win);
+	} else {
+		dev_err(dev_drv->dev, "un supported win number:%d\n", win_id);
+		return -EINVAL;
+	}
+	
+	if (lcdc_dev->clk_on) {
+		rk3188_lcdc_alpha_cfg(lcdc_dev);
+	}
+
+	return 0;
+}
+
+
+
+static int rk3188_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
+			     unsigned long arg, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	struct color_key_cfg clr_key_cfg;
+
+	switch (cmd) {
+	case RK_FBIOGET_PANEL_SIZE:
+		panel_size[0] = lcdc_dev->screen->mode.xres;
+		panel_size[1] = lcdc_dev->screen->mode.yres;
+		if (copy_to_user(argp, panel_size, 8))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_COLOR_KEY_CFG:
+		if (copy_from_user(&clr_key_cfg, argp,
+				   sizeof(struct color_key_cfg)))
+			return -EFAULT;
+		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
+			    clr_key_cfg.win0_color_key_cfg);
+		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
+			    clr_key_cfg.win1_color_key_cfg);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int rk3188_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
+{
+
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	if (dev_drv->suspend_flag) 
+		return 0;
+	dev_drv->suspend_flag = 1;
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
+			     v_BLANK_EN(1));
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
+			     v_FS_INT_CLEAR(1));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(1));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(1));
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	rk3188_lcdc_clk_disable(lcdc_dev);
+	rk_disp_pwr_disable(dev_drv);
+	return 0;
+}
+
+static int rk3188_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int i = 0;
+	int __iomem *c;
+	int v;
+
+	if (!dev_drv->suspend_flag)
+		return 0;
+	rk_disp_pwr_enable(dev_drv);
+	dev_drv->suspend_flag = 0;
+
+	if (lcdc_dev->atv_layer_cnt) {
+		rk3188_lcdc_clk_enable(lcdc_dev);
+		rk3188_lcdc_reg_restore(lcdc_dev);
+
+		spin_lock(&lcdc_dev->reg_lock);
+		if (dev_drv->cur_screen->dsp_lut) {
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN,
+				     v_DSP_LUT_EN(0));
+			lcdc_cfg_done(lcdc_dev);
+			mdelay(25);
+			for (i = 0; i < 256; i++) {
+				v = dev_drv->cur_screen->dsp_lut[i];
+				c = lcdc_dev->dsp_lut_addr_base + i;
+				writel_relaxed(v, c);
+			}
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN,
+				     v_DSP_LUT_EN(1));
+		}
+
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(0));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_LCDC_STANDBY,
+			     v_LCDC_STANDBY(0));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_BLANK_EN,
+			     v_BLANK_EN(0));
+		lcdc_cfg_done(lcdc_dev);
+
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	return 0;
+}
+
+
+static int rk3188_lcdc_blank(struct rk_lcdc_driver *dev_drv,
+			     int win_id, int blank_mode)
+{
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		rk3188_lcdc_early_resume(dev_drv);
+		break;
+	case FB_BLANK_NORMAL:
+		rk3188_lcdc_early_suspend(dev_drv);
+		break;
+	default:
+		rk3188_lcdc_early_suspend(dev_drv);
+		break;
+	}
+	
+	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
+
+	return 0;
+}
+
+static int rk3188_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
+				     int win_id,
+				     int area_id)
+{
+	return 0;
+}
+
+static int rk3188_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int ovl;
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (set) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_WIN0_TOP,
+				     v_WIN0_TOP(swap));
+			ovl = swap;
+		} else {
+			ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
+		}
+	} else {
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+static ssize_t rk3188_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
+					 char *buf, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+							   struct
+							   lcdc_device,
+							   driver);
+
+	char format_w0[9] = "NULL";
+	char format_w1[9] = "NULL";
+	char status_w0[9] = "NULL";
+	char status_w1[9] = "NULL";
+	u32 fmt_id, act_info, dsp_info, dsp_st, factor;
+	u16 xvir_w0, x_act_w0, y_act_w0, x_dsp_w0, y_dsp_w0;
+	u16 x_st_w0, y_st_w0, x_factor, y_factor;
+	u16 xvir_w1, x_dsp_w1, y_dsp_w1, x_st_w1, y_st_w1;
+	u16 x_scale, y_scale, ovl;
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		fmt_id = lcdc_readl(lcdc_dev, SYS_CTRL);
+		ovl = lcdc_read_bit(lcdc_dev, DSP_CTRL0, m_WIN0_TOP);
+		switch ((fmt_id & m_WIN0_FORMAT) >> 3) {
+		case 0:
+			strcpy(format_w0, "ARGB888");
+			break;
+		case 1:
+			strcpy(format_w0, "RGB888");
+			break;
+		case 2:
+			strcpy(format_w0, "RGB565");
+			break;
+		case 4:
+			strcpy(format_w0, "YCbCr420");
+			break;
+		case 5:
+			strcpy(format_w0, "YCbCr422");
+			break;
+		case 6:
+			strcpy(format_w0, "YCbCr444");
+			break;
+		default:
+			strcpy(format_w0, "invalid\n");
+			break;
+		}
+
+		switch ((fmt_id & m_WIN1_FORMAT) >> 6) {
+		case 0:
+			strcpy(format_w1, "ARGB888");
+			break;
+		case 1:
+			strcpy(format_w1, "RGB888");
+			break;
+		case 2:
+			strcpy(format_w1, "RGB565");
+			break;
+		case 4:
+			strcpy(format_w1, "8bpp");
+			break;
+		case 5:
+			strcpy(format_w1, "4bpp");
+			break;
+		case 6:
+			strcpy(format_w1, "2bpp");
+			break;
+		case 7:
+			strcpy(format_w1, "1bpp");
+			break;
+		default:
+			strcpy(format_w1, "invalid\n");
+			break;
+		}
+
+		if (fmt_id & m_WIN0_EN)
+			strcpy(status_w0, "enabled");
+		else
+			strcpy(status_w0, "disabled");
+
+		if ((fmt_id & m_WIN1_EN) >> 1)
+			strcpy(status_w1, "enabled");
+		else
+			strcpy(status_w1, "disabled");
+
+		xvir_w0 = lcdc_readl(lcdc_dev, WIN_VIR) & 0x1fff;
+		act_info = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
+		dsp_info = lcdc_readl(lcdc_dev, WIN0_DSP_INFO);
+		dsp_st = lcdc_readl(lcdc_dev, WIN0_DSP_ST);
+		factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_YRGB);
+		x_act_w0 = (act_info & 0x1fff) + 1;
+		y_act_w0 = ((act_info >> 16) & 0x1fff) + 1;
+		x_dsp_w0 = (dsp_info & 0x7ff) + 1;
+		y_dsp_w0 = ((dsp_info >> 16) & 0x7ff) + 1;
+		x_st_w0 = dsp_st & 0xffff;
+		y_st_w0 = dsp_st >> 16;
+		x_factor = factor & 0xffff;
+		y_factor = factor >> 16;
+		x_scale = 4096 * 100 / x_factor;
+		y_scale = 4096 * 100 / y_factor;
+		xvir_w1 = (lcdc_readl(lcdc_dev, WIN_VIR) >> 16) & 0x1fff;
+		dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO);
+		dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST);
+		x_dsp_w1 = (dsp_info & 0x7ff) + 1;
+		y_dsp_w1 = ((dsp_info >> 16) & 0x7ff) + 1;
+		x_st_w1 = dsp_st & 0xffff;
+		y_st_w1 = dsp_st >> 16;
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return snprintf(buf, PAGE_SIZE,
+			"win0:%s\n"
+			"xvir:%d\n"
+			"xact:%d\n"
+			"yact:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"x_scale:%d.%d\n"
+			"y_scale:%d.%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n"
+			"CBR buffer addr:0x%08x\n\n"
+			"win1:%s\n"
+			"xvir:%d\n"
+			"xdsp:%d\n"
+			"ydsp:%d\n"
+			"x_st:%d\n"
+			"y_st:%d\n"
+			"format:%s\n"
+			"YRGB buffer addr:0x%08x\n"
+			"overlay:%s\n",
+			status_w0,
+			xvir_w0,
+			x_act_w0,
+			y_act_w0,
+			x_dsp_w0,
+			y_dsp_w0,
+			x_st_w0,
+			y_st_w0,
+			x_scale / 100,
+			x_scale % 100,
+			y_scale / 100,
+			y_scale % 100,
+			format_w0,
+			lcdc_readl(lcdc_dev, WIN0_YRGB_MST0),
+			lcdc_readl(lcdc_dev, WIN0_CBR_MST0),
+			status_w1,
+			xvir_w1,
+			x_dsp_w1,
+			y_dsp_w1,
+			x_st_w1,
+			y_st_w1,
+			format_w1,
+			lcdc_readl(lcdc_dev, WIN1_MST),
+			ovl ? "win0 on the top of win1\n" :
+			"win1 on the top of win0\n");
+}
+
+static int rk3188_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+	u32 pixclock;
+	u32 x_total, y_total;
+	if (set) {
+		ft = div_u64(1000000000000llu, fps);
+		x_total =
+		    screen->mode.upper_margin + screen->mode.lower_margin +
+		    screen->mode.yres + screen->mode.vsync_len;
+		y_total =
+		    screen->mode.left_margin + screen->mode.right_margin +
+		    screen->mode.xres + screen->mode.hsync_len;
+		dev_drv->pixclock = div_u64(ft, x_total * y_total);
+		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+	}
+
+	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	dev_drv->pixclock = lcdc_dev->pixclock = pixclock;
+	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
+	screen->ft = 1000 / fps;	/*one frame time in ms */
+
+	if (set)
+		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
+			 clk_get_rate(lcdc_dev->dclk), fps);
+
+	return fps;
+}
+
+static int rk3188_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
+{
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (order == FB_DEFAULT_ORDER)
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2;
+	dev_drv->fb2_win_id = order / 100;
+	dev_drv->fb1_win_id = (order / 10) % 10;
+	dev_drv->fb0_win_id = order % 10;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return 0;
+}
+
+static int rk3188_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
+				  const char *id)
+{
+	int win_id = 0;
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (!strcmp(id, "fb0") || !strcmp(id, "fb2"))
+		win_id = dev_drv->fb0_win_id;
+	else if (!strcmp(id, "fb1") || !strcmp(id, "fb3"))
+		win_id = dev_drv->fb1_win_id;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return win_id;
+}
+
+static int rk3188_set_dsp_lut(struct rk_lcdc_driver *dev_drv, int *lut)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	int ret = 0;
+
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	msleep(25);
+	if (dev_drv->cur_screen->dsp_lut) {
+		for (i = 0; i < 256; i++) {
+			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
+			c = lcdc_dev->dsp_lut_addr_base + i;
+			writel_relaxed(v, c);
+
+		}
+	} else {
+		dev_err(dev_drv->dev, "no buffer to backup lut data!\n");
+		ret = -1;
+	}
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
+	lcdc_cfg_done(lcdc_dev);
+
+	return ret;
+}
+
+static int rk3188_lcdc_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATCH_EN,
+		     v_DIRECT_PATCH_EN(open));
+	lcdc_cfg_done(lcdc_dev);
+	return 0;
+}
+
+static int rk3188_lcdc_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_LAY_SEL,
+		     v_DIRECT_PATH_LAY_SEL(win_id));
+	lcdc_cfg_done(lcdc_dev);
+	return 0;
+
+}
+
+static int rk3188_lcdc_dpi_status(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int ovl = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_DIRECT_PATCH_EN);
+	return ovl;
+}
+
+int rk3188_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 int_reg;
+	int ret;
+
+	if (lcdc_dev->clk_on) {
+		int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
+		if (int_reg & m_LF_INT_STA) {
+			lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
+				     v_LF_INT_CLEAR(1));
+			ret = RK_LF_STATUS_FC;
+		} else
+			ret = RK_LF_STATUS_FR;
+	} else {
+		ret = RK_LF_STATUS_NC;
+	}
+
+	return ret;
+}
+
+
+static int rk3188_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,unsigned int dsp_addr[][4])
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if(lcdc_dev->clk_on){
+		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST0);
+		dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_MST);
+	}
+	return 0;
+}
+
+static int rk3188_lcdc_cfg_done(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv, 
+					struct lcdc_device, driver);
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on)
+		lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+
+static struct rk_lcdc_win lcdc_win[] = {
+	[0] = {
+	       .name = "win0",
+	       .id = 0,
+	       .support_3d = true,
+	       },
+	[1] = {
+	       .name = "win1",
+	       .id = 1,
+	       .support_3d = false,
+	       },
+};
+
+static struct rk_lcdc_drv_ops lcdc_drv_ops = {
+	.open			= rk3188_lcdc_open,
+	.load_screen 		= rk3188_load_screen,
+	.set_par 		= rk3188_lcdc_set_par,
+	.pan_display 		= rk3188_lcdc_pan_display,
+	.blank 			= rk3188_lcdc_blank,
+	.ioctl 			= rk3188_lcdc_ioctl,
+	.get_win_state 		= rk3188_lcdc_get_win_state,
+	.ovl_mgr 		= rk3188_lcdc_ovl_mgr,
+	.get_disp_info 		= rk3188_lcdc_get_disp_info,
+	.fps_mgr 		= rk3188_lcdc_fps_mgr,
+	.fb_get_win_id 		= rk3188_lcdc_get_win_id,
+	.fb_win_remap 		= rk3188_fb_win_remap,
+	.set_dsp_lut 		= rk3188_set_dsp_lut,
+	.poll_vblank 		= rk3188_lcdc_poll_vblank,
+	.dpi_open 		= rk3188_lcdc_dpi_open,
+	.dpi_win_sel 		= rk3188_lcdc_dpi_win_sel,
+	.dpi_status 		= rk3188_lcdc_dpi_status,
+	.get_dsp_addr 		= rk3188_lcdc_get_dsp_addr,
+	.cfg_done		= rk3188_lcdc_cfg_done,
+	.dump_reg 		= rk3188_lcdc_reg_dump,
+};
+
+static irqreturn_t rk3188_lcdc_isr(int irq, void *dev_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    (struct lcdc_device *)dev_id;
+	ktime_t timestamp = ktime_get();
+	u32 int_reg = lcdc_readl(lcdc_dev, INT_STATUS);
+
+	if (int_reg & m_FS_INT_STA) {
+		timestamp = ktime_get();
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_FS_INT_CLEAR,
+			     v_FS_INT_CLEAR(1));
+		//if (lcdc_dev->driver.wait_fs) {
+		if (0) {	
+			spin_lock(&(lcdc_dev->driver.cpl_lock));
+			complete(&(lcdc_dev->driver.frame_done));
+			spin_unlock(&(lcdc_dev->driver.cpl_lock));
+		}
+		lcdc_dev->driver.vsync_info.timestamp = timestamp;
+		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
+
+	} else if (int_reg & m_LF_INT_STA) {
+		lcdc_msk_reg(lcdc_dev, INT_STATUS, m_LF_INT_CLEAR,
+			     v_LF_INT_CLEAR(1));
+	}
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_PM)
+static int rk3188_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk3188_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define rk3188_lcdc_suspend NULL
+#define rk3188_lcdc_resume  NULL
+#endif
+
+static int rk3188_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
+{
+	struct device_node *np = lcdc_dev->dev->of_node;
+	int val;
+	if (of_property_read_u32(np, "rockchip,prop", &val))
+		lcdc_dev->prop = PRMRY;	/*default set it as primary */
+	else
+		lcdc_dev->prop = val;
+
+	if (of_property_read_u32(np, "rockchip,pwr18", &val))
+		lcdc_dev->pwr18 = false;	/*default set it as 3.xv power supply */
+	else
+		lcdc_dev->pwr18 = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
+		lcdc_dev->driver.fb_win_map = FB_DEFAULT_ORDER;
+	else
+		lcdc_dev->driver.fb_win_map = val;
+
+	return 0;
+}
+
+static int rk3188_lcdc_probe(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = NULL;
+	struct rk_lcdc_driver *dev_drv;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	int prop;
+	int ret = 0;
+
+	/*if the primary lcdc has not registered ,the extend
+	   lcdc register later */
+	of_property_read_u32(np, "rockchip,prop", &prop);
+	if (prop == EXTEND) {
+		if (!is_prmry_rk_lcdc_registered())
+			return -EPROBE_DEFER;
+	}
+	lcdc_dev = devm_kzalloc(dev,
+				sizeof(struct lcdc_device), GFP_KERNEL);
+	if (!lcdc_dev) {
+		dev_err(&pdev->dev, "rk3188 lcdc device kmalloc fail!");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->dev = dev;
+	rk3188_lcdc_parse_dt(lcdc_dev);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+	lcdc_dev->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lcdc_dev->regs))
+		return PTR_ERR(lcdc_dev->regs);
+
+	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
+	if (IS_ERR(lcdc_dev->regsbak))
+		return PTR_ERR(lcdc_dev->regsbak);
+	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + DSP_LUT_ADDR);
+	lcdc_dev->id = rk3188_lcdc_get_id(lcdc_dev->reg_phy_base);
+	if (lcdc_dev->id < 0) {
+		dev_err(&pdev->dev, "no such lcdc device!\n");
+		return -ENXIO;
+	}
+	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
+	dev_drv = &lcdc_dev->driver;
+	dev_drv->dev = dev;
+	dev_drv->prop = prop;
+	dev_drv->id = lcdc_dev->id;
+	dev_drv->ops = &lcdc_drv_ops;
+	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
+	spin_lock_init(&lcdc_dev->reg_lock);
+
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if (lcdc_dev->irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
+			lcdc_dev->id);
+		return -ENXIO;
+	}
+
+	ret = devm_request_irq(dev, lcdc_dev->irq, rk3188_lcdc_isr,
+			       IRQF_DISABLED, dev_name(dev), lcdc_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
+			lcdc_dev->irq, ret);
+		return ret;
+	}
+
+	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
+	if (ret < 0) {
+		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
+		return ret;
+	}
+	lcdc_dev->screen = dev_drv->screen0;
+	
+	dev_info(dev, "lcdc%d probe ok\n", lcdc_dev->id);
+
+	return 0;
+}
+
+static int rk3188_lcdc_remove(struct platform_device *pdev)
+{
+
+	return 0;
+}
+
+static void rk3188_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+
+	rk3188_lcdc_deint(lcdc_dev);
+	rk_disp_pwr_disable(&lcdc_dev->driver);
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk3188_lcdc_dt_ids[] = {
+	{.compatible = "rockchip,rk3188-lcdc",},
+	{}
+};
+#endif
+
+static struct platform_driver rk3188_lcdc_driver = {
+	.probe = rk3188_lcdc_probe,
+	.remove = rk3188_lcdc_remove,
+	.driver = {
+		   .name = "rk3188-lcdc",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rk3188_lcdc_dt_ids),
+		   },
+	.suspend = rk3188_lcdc_suspend,
+	.resume = rk3188_lcdc_resume,
+	.shutdown = rk3188_lcdc_shutdown,
+};
+
+static int __init rk3188_lcdc_module_init(void)
+{
+	return platform_driver_register(&rk3188_lcdc_driver);
+}
+
+static void __exit rk3188_lcdc_module_exit(void)
+{
+	platform_driver_unregister(&rk3188_lcdc_driver);
+}
+
+fs_initcall(rk3188_lcdc_module_init);
+module_exit(rk3188_lcdc_module_exit);
diff -Nupr a/drivers/video/rockchip/lcdc/rk3188_lcdc.h b/drivers/video/rockchip/lcdc/rk3188_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk3188_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3188_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,413 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef RK3188_LCDC_H_
+#define RK3188_LCDC_H_
+
+#include<linux/rk_fb.h>
+#include<linux/io.h>
+#include<linux/clk.h>
+
+
+/*******************register definition**********************/
+
+#define SYS_CTRL 		(0x00)
+#define m_WIN0_EN		(1<<0)
+#define m_WIN1_EN		(1<<1)
+#define m_HWC_EN		(1<<2)
+#define m_WIN0_FORMAT		(7<<3)
+#define m_WIN1_FORMAT		(7<<6)
+#define m_HWC_COLOR_MODE	(1<<9)
+#define m_HWC_SIZE		(1<<10)
+#define m_WIN0_3D_EN		(1<<11)
+#define m_WIN0_3D_MODE		(7<<12)
+#define m_WIN0_RB_SWAP		(1<<15)
+#define m_WIN0_ALPHA_SWAP	(1<<16)
+#define m_WIN0_Y8_SWAP		(1<<17)
+#define m_WIN0_UV_SWAP		(1<<18)
+#define m_WIN1_RB_SWAP		(1<<19)
+#define m_WIN1_ALPHA_SWAP	(1<<20)
+#define m_WIN1_BL_SWAP		(1<<21)
+#define m_WIN0_OTSD_DISABLE	(1<<22)
+#define m_WIN1_OTSD_DISABLE	(1<<23)
+#define m_DMA_BURST_LENGTH	(3<<24)
+#define m_HWC_LODAD_EN		(1<<26)
+#define m_WIN1_LUT_EN		(1<<27)
+#define m_DSP_LUT_EN		(1<<28)
+#define m_DMA_STOP		(1<<29)
+#define m_LCDC_STANDBY		(1<<30)
+#define m_AUTO_GATING_EN	(1<<31)
+#define v_WIN0_EN(x)		(((x)&1)<<0)
+#define v_WIN1_EN(x)		(((x)&1)<<1)
+#define v_HWC_EN(x)		(((x)&1)<<2)
+#define v_WIN0_FORMAT(x)	(((x)&7)<<3)
+#define v_WIN1_FORMAT(x)	(((x)&7)<<6)
+#define v_HWC_COLOR_MODE(x)	(((x)&1)<<9)
+#define v_HWC_SIZE(x)		(((x)&1)<<10)
+#define v_WIN0_3D_EN(x)		(((x)&1)<<11)
+#define v_WIN0_3D_MODE(x)	(((x)&7)<<12)
+#define v_WIN0_RB_SWAP(x)	(((x)&1)<<15)
+#define v_WIN0_ALPHA_SWAP(x)	(((x)&1)<<16)
+#define v_WIN0_Y8_SWAP(x)	(((x)&1)<<17)
+#define v_WIN0_UV_SWAP(x)	(((x)&1)<<18)
+#define v_WIN1_RB_SWAP(x)	(((x)&1)<<19)
+#define v_WIN1_ALPHA_SWAP(x)	(((x)&1)<<20)
+#define v_WIN1_BL_SWAP(x)	(((x)&1)<<21)
+#define v_WIN0_OTSD_DISABLE(x)	(((x)&1)<<22)
+#define v_WIN1_OTSD_DISABLE(x)	(((x)&1)<<23)
+#define v_DMA_BURST_LENGTH(x)	(((x)&3)<<24)
+#define v_HWC_LODAD_EN(x)	(((x)&1)<<26)
+#define v_WIN1_LUT_EN(x)	(((x)&1)<<27)
+#define v_DSP_LUT_EN(x)		(((x)&1)<<28)
+#define v_DMA_STOP(x)		(((x)&1)<<29)
+#define v_LCDC_STANDBY(x)	(((x)&1)<<30)
+#define v_AUTO_GATING_EN(x)	(((x)&1)<<31)
+
+
+#define DSP_CTRL0		(0x04)
+#define m_DSP_OUT_FORMAT	(0x0f<<0)
+#define m_HSYNC_POL		(1<<4)
+#define m_VSYNC_POL		(1<<5)
+#define m_DEN_POL		(1<<6)
+#define m_DCLK_POL		(1<<7)
+#define m_WIN0_TOP		(1<<8)
+#define m_DITHER_UP_EN		(1<<9)
+#define m_DITHER_DOWN_MODE	(1<<10)
+#define m_DITHER_DOWN_EN	(1<<11)
+#define m_INTERLACE_DSP_EN	(1<<12)
+#define m_INTERLACE_POL		(1<<13)
+#define m_WIN0_INTERLACE_EN	(1<<14)
+#define m_WIN1_INTERLACE_EN	(1<<15)
+#define m_WIN0_YRGB_DEFLICK_EN	(1<<16)
+#define m_WIN0_CBR_DEFLICK_EN	(1<<17)
+#define m_WIN0_ALPHA_MODE	(1<<18)
+#define m_WIN1_ALPHA_MODE	(1<<19)
+#define m_WIN0_CSC_MODE		(3<<20)
+#define m_WIN1_CSC_MODE		(1<<22)
+#define m_WIN0_YUV_CLIP		(1<<23)
+#define m_DSP_CCIR656_AVG	(1<<24)
+#define m_DCLK_OUTPUT_MODE	(1<<25)
+#define m_DCLK_PHASE_LOCK	(1<<26)
+#define m_DITHER_DOWN_SEL	(3<<27)
+#define m_ALPHA_MODE_SEL0	(1<<29)
+#define m_ALPHA_MODE_SEL1	(1<<30)
+#define m_DIFF_DCLK_EN		(1<<31)
+#define v_DSP_OUT_FORMAT(x)	(((x)&0x0f)<<0)
+#define v_HSYNC_POL(x)		(((x)&1)<<4)
+#define v_VSYNC_POL(x)		(((x)&1)<<5)
+#define v_DEN_POL(x)		(((x)&1)<<6)
+#define v_DCLK_POL(x)		(((x)&1)<<7)
+#define v_WIN0_TOP(x)		(((x)&1)<<8)
+#define v_DITHER_UP_EN(x)	(((x)&1)<<9)
+#define v_DITHER_DOWN_MODE(x)	(((x)&1)<<10)
+#define v_DITHER_DOWN_EN(x)	(((x)&1)<<11)
+#define v_INTERLACE_DSP_EN(x)	(((x)&1)<<12)
+#define v_INTERLACE_POL(x)	(((x)&1)<<13)
+#define v_WIN0_INTERLACE_EN(x)	(((x)&1)<<14)
+#define v_WIN1_INTERLACE_EN(x)	(((x)&1)<<15)
+#define v_WIN0_YRGB_DEFLICK_EN(x)	(((x)&1)<<16)
+#define v_WIN0_CBR_DEFLICK_EN(x)	(((x)&1)<<17)
+#define v_WIN0_ALPHA_MODE(x)		(((x)&1)<<18)
+#define v_WIN1_ALPHA_MODE(x)		(((x)&1)<<19)
+#define v_WIN0_CSC_MODE(x)		(((x)&3)<<20)
+#define v_WIN1_CSC_MODE(x)		(((x)&1)<<22)
+#define v_WIN0_YUV_CLIP(x)		(((x)&1)<<23)
+#define v_DSP_CCIR656_AVG(x)		(((x)&1)<<24)
+#define v_DCLK_OUTPUT_MODE(x)		(((x)&1)<<25)
+#define v_DCLK_PHASE_LOCK(x)		(((x)&1)<<26)
+#define v_DITHER_DOWN_SEL(x)		(((x)&1)<<27)
+#define v_ALPHA_MODE_SEL0(x)		(((x)&1)<<29)
+#define v_ALPHA_MODE_SEL1(x)		(((x)&1)<<30)
+#define v_DIFF_DCLK_EN(x)		(((x)&1)<<31)
+
+
+#define DSP_CTRL1		(0x08)
+#define m_BG_COLOR		(0xffffff<<0)
+#define m_BG_B			(0xff<<0)
+#define m_BG_G			(0xff<<8)
+#define m_BG_R			(0xff<<16)
+#define m_BLANK_EN		(1<<24)
+#define m_BLACK_EN		(1<<25)
+#define m_DSP_BG_SWAP		(1<<26)
+#define m_DSP_RB_SWAP		(1<<27)
+#define m_DSP_RG_SWAP		(1<<28)
+#define m_DSP_DELTA_SWAP	(1<<29)
+#define m_DSP_DUMMY_SWAP	(1<<30)
+#define m_DSP_OUT_ZERO		(1<<31)
+#define v_BG_COLOR(x)		(((x)&0xffffff)<<0)
+#define v_BG_B(x)		(((x)&0xff)<<0)
+#define v_BG_G(x)		(((x)&0xff)<<8)
+#define v_BG_R(x)		(((x)&0xff)<<16)
+#define v_BLANK_EN(x)		(((x)&1)<<24)
+#define v_BLACK_EN(x)		(((x)&1)<<25)
+#define v_DSP_BG_SWAP(x)	(((x)&1)<<26)
+#define v_DSP_RB_SWAP(x)	(((x)&1)<<27)
+#define v_DSP_RG_SWAP(x)	(((x)&1)<<28)
+#define v_DSP_DELTA_SWAP(x)	(((x)&1)<<29)
+#define v_DSP_DUMMY_SWAP(x)	(((x)&1)<<30)
+#define v_DSP_OUT_ZERO(x)	(((x)&1)<<31)
+
+
+#define MCU_CTRL		(0x0c)
+#define m_MCU_PIX_TOTAL		(0x3f<<0)
+#define m_MCU_CS_ST		(0x0f<<6)
+#define m_MCU_CS_END		(0x3f<<10)
+#define m_MCU_RW_ST		(0x0f<<16)
+#define m_MCU_RW_END		(0x3f<<20)
+#define m_MCU_CLK_SEL		(1<<26)
+#define m_MCU_HOLD_MODE		(1<<27)
+#define m_MCU_FS_HOLD_STA	(1<<28)
+#define m_MCU_RS_SELECT		(1<<29)
+#define m_MCU_BYPASS 		(1<<30)
+#define m_MCU_TYPE		(1<<31)
+
+#define v_MCU_PIX_TOTAL(x)		(((x)&0x3f)<<0)
+#define v_MCU_CS_ST(x)			(((x)&0x0f)<<6)
+#define v_MCU_CS_END(x)			(((x)&0x3f)<<10)
+#define v_MCU_RW_ST(x)			(((x)&0x0f)<<16)
+#define v_MCU_RW_END(x)			(((x)&0x3f)<<20)
+#define v_MCU_CLK_SEL(x)		(((x)&1)<<26)
+#define v_MCU_HOLD_MODE(x)		(((x)&1)<<27)
+#define v_MCU_FS_HOLD_STA(x)		(((x)&1)<<28)
+#define v_MCU_RS_SELECT(x)		(((x)&1)<<29)
+#define v_MCU_BYPASS(x) 		(((x)&1)<<30)
+#define v_MCU_TYPE(x)			(((x)&1)<<31)
+
+#define INT_STATUS		(0x10)
+#define m_HS_INT_STA		(1<<0)  //status
+#define m_FS_INT_STA		(1<<1)
+#define m_LF_INT_STA		(1<<2)
+#define m_BUS_ERR_INT_STA	(1<<3)
+#define m_HS_INT_EN		(1<<4)  //enable
+#define m_FS_INT_EN          	(1<<5)
+#define m_LF_INT_EN         	(1<<6)
+#define m_BUS_ERR_INT_EN	(1<<7)
+#define m_HS_INT_CLEAR		(1<<8) //auto clear
+#define m_FS_INT_CLEAR		(1<<9)
+#define m_LF_INT_CLEAR		(1<<10)
+#define m_BUS_ERR_INT_CLEAR	(1<<11)
+#define m_LF_INT_NUM		(0xfff<<12)
+#define v_HS_INT_EN(x)		(((x)&1)<<4)
+#define v_FS_INT_EN(x)		(((x)&1)<<5)
+#define v_LF_INT_EN(x)		(((x)&1)<<6)
+#define v_BUS_ERR_INT_EN(x)	(((x)&1)<<7)
+#define v_HS_INT_CLEAR(x)	(((x)&1)<<8)
+#define v_FS_INT_CLEAR(x)	(((x)&1)<<9)
+#define v_LF_INT_CLEAR(x)	(((x)&1)<<10)
+#define v_BUS_ERR_INT_CLEAR(x)	(((x)&1)<<11)
+#define v_LF_INT_NUM(x)		(((x)&0xfff)<<12)
+
+
+#define ALPHA_CTRL		(0x14)
+#define m_WIN0_ALPHA_EN		(1<<0)
+#define m_WIN1_ALPHA_EN		(1<<1)
+#define m_HWC_ALPAH_EN		(1<<2)
+#define m_WIN0_ALPHA_VAL	(0xff<<4)
+#define m_WIN1_ALPHA_VAL	(0xff<<12)
+#define m_HWC_ALPAH_VAL		(0x0f<<20)
+#define v_WIN0_ALPHA_EN(x)	(((x)&1)<<0)
+#define v_WIN1_ALPHA_EN(x)	(((x)&1)<<1)
+#define v_HWC_ALPAH_EN(x)	(((x)&1)<<2)
+#define v_WIN0_ALPHA_VAL(x)	(((x)&0xff)<<4)
+#define v_WIN1_ALPHA_VAL(x)	(((x)&0xff)<<12)
+#define v_HWC_ALPAH_VAL(x)	(((x)&0x0f)<<20)
+
+#define WIN0_COLOR_KEY		(0x18)
+#define m_COLOR_KEY_VAL		(0xffffff<<0)
+#define m_COLOR_KEY_EN		(1<<24)
+#define v_COLOR_KEY_VAL(x)	(((x)&0xffffff)<<0)
+#define v_COLOR_KEY_EN(x)	(((x)&1)<<24)
+
+#define WIN1_COLOR_KEY		(0x1C)
+
+
+#define WIN0_YRGB_MST0		(0x20)
+#define WIN0_CBR_MST0		(0x24)
+#define WIN0_YRGB_MST1		(0x28)
+#define WIN0_CBR_MST1		(0x2C)
+#define WIN_VIR			(0x30)
+#define m_WIN0_VIR   		(0x1fff << 0)
+#define m_WIN1_VIR   		(0x1fff << 16)
+#define v_WIN0_VIR_VAL(x)       ((x)<<0)
+#define v_WIN1_VIR_VAL(x)       ((x)<<16)
+#define v_ARGB888_VIRWIDTH(x) 	(((x)&0x1fff)<<0)
+#define v_RGB888_VIRWIDTH(x) 	(((((x*3)>>2)+((x)%3))&0x1fff)<<0)
+#define v_RGB565_VIRWIDTH(x) 	 ((DIV_ROUND_UP(x,2)&0x1fff)<<0)
+#define v_YUV_VIRWIDTH(x)    	 ((DIV_ROUND_UP(x,4)&0x1fff)<<0)
+#define v_WIN1_ARGB888_VIRWIDTH(x) 	(((x)&0x1fff)<<16)
+#define v_WIN1_RGB888_VIRWIDTH(x) 	(((((x*3)>>2)+((x)%3))&0x1fff)<<16)
+#define v_WIN1_RGB565_VIRWIDTH(x) 	 ((DIV_ROUND_UP(x,2)&0x1fff)<<16)
+
+
+
+#define WIN0_ACT_INFO		(0x34)
+#define m_ACT_WIDTH       	(0x1fff<<0)
+#define m_ACT_HEIGHT      	(0x1fff<<16)
+#define v_ACT_WIDTH(x)       	(((x-1)&0x1fff)<<0)
+#define v_ACT_HEIGHT(x)      	(((x-1)&0x1fff)<<16)
+
+#define WIN0_DSP_INFO		(0x38)
+#define v_DSP_WIDTH(x)     	(((x-1)&0x7ff)<<0)
+#define v_DSP_HEIGHT(x)    	(((x-1)&0x7ff)<<16)
+
+#define WIN0_DSP_ST		(0x3C)
+#define v_DSP_STX(x)      	(((x)&0xfff)<<0)
+#define v_DSP_STY(x)      	(((x)&0xfff)<<16)
+
+#define WIN0_SCL_FACTOR_YRGB	(0x40)
+#define v_X_SCL_FACTOR(x)  (((x)&0xffff)<<0)
+#define v_Y_SCL_FACTOR(x)  (((x)&0xffff)<<16)
+
+#define WIN0_SCL_FACTOR_CBR	(0x44)
+#define WIN0_SCL_OFFSET		(0x48)
+#define WIN1_MST		(0x4C)
+#define WIN1_DSP_INFO		(0x50)
+#define WIN1_DSP_ST		(0x54)
+#define HWC_MST			(0x58)
+#define HWC_DSP_ST		(0x5C)
+#define HWC_COLOR_LUT0		(0x60)
+#define HWC_COLOR_LUT1		(0x64)
+#define HWC_COLOR_LUT2		(0x68)
+#define DSP_HTOTAL_HS_END	(0x6C)
+#define v_HSYNC(x)  		(((x)&0xfff)<<0)   //hsync pulse width
+#define v_HORPRD(x) 		(((x)&0xfff)<<16)   //horizontal period
+
+#define DSP_HACT_ST_END		(0x70)
+#define v_HAEP(x) 		(((x)&0xfff)<<0)  //horizontal active end point
+#define v_HASP(x) 		(((x)&0xfff)<<16) //horizontal active start point
+
+#define DSP_VTOTAL_VS_END	(0x74)
+#define v_VSYNC(x) 		(((x)&0xfff)<<0)
+#define v_VERPRD(x) 		(((x)&0xfff)<<16)
+#define DSP_VACT_ST_END		(0x78)
+#define v_VAEP(x) 		(((x)&0xfff)<<0)
+#define v_VASP(x) 		(((x)&0xfff)<<16)
+
+#define DSP_VS_ST_END_F1	(0x7C)
+#define DSP_VACT_ST_END_F1	(0x80)
+#define REG_CFG_DONE		(0x90)
+#define MCU_BYPASS_WPORT	(0x100)
+#define MCU_BYPASS_RPORT	(0x200)
+#define WIN1_LUT_ADDR		(0x400)
+#define DSP_LUT_ADDR		(0x800)
+
+/*
+	RK3026/RK3028A max output  resolution 1920x1080
+	support IEP instead of  3d
+*/
+//#ifdef CONFIG_ARCH_RK3026
+//SYS_CTRL 0x00
+#define m_DIRECT_PATCH_EN         (1<<11)
+#define m_DIRECT_PATH_LAY_SEL     (1<<12)
+
+#define v_DIRECT_PATCH_EN(x)      (((x)&1)<<11)
+#define v_DIRECT_PATH_LAY_SEL(x)  (((x)&1)<<12)
+
+//INT_STATUS 0x10
+#define m_WIN0_EMPTY_INTR_EN      (1<<24)
+#define m_WIN1_EMPTY_INTR_EN      (1<<25)
+#define m_WIN0_EMPTY_INTR_CLR     (1<<26)
+#define m_WIN1_EMPTY_INTR_CLR     (1<<27)
+#define m_WIN0_EMPTY_INTR_STA     (1<<28)
+#define m_WIN1_EMPTY_INTR_STA     (1<<29)
+
+#define v_WIN0_EMPTY_INTR_EN(x)   (((x)&1)<<24)
+#define v_WIN1_EMPTY_INTR_EN(x)   (((x)&1)<<25)
+#define v_WIN0_EMPTY_INTR_CLR(x)  (((x)&1)<<26)
+#define v_WIN1_EMPTY_INTR_CLR(x)  (((x)&1)<<27)
+#define v_WIN0_EMPTY_INTR_STA(x)  (((x)&1)<<28)
+#define v_WIN1_EMPTY_INTR_STA(x)  (((x)&1)<<29)
+//#endif
+
+
+#define CalScale(x, y)	             ((((u32)(x-1))*0x1000)/(y-1))
+
+struct lcdc_device{
+	int id;
+	struct rk_lcdc_driver driver;
+	struct device *dev;
+	struct rk_screen *screen;
+
+	void __iomem *regs;
+	void *regsbak;			//back up reg
+	u32 reg_phy_base;       	// physical basic address of lcdc register
+	u32 len;               		// physical map length of lcdc register
+	spinlock_t  reg_lock;		//one time only one process allowed to config the register
+	
+	int __iomem *dsp_lut_addr_base;
+
+	int prop;			/*used for primary or extended display device*/
+	bool pre_init;
+	bool pwr18;			/*if lcdc use 1.8v power supply*/
+	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
+	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
+	
+
+	unsigned int		irq;
+
+	struct clk		*pd;				//lcdc power domain
+	struct clk		*hclk;				//lcdc AHP clk
+	struct clk		*dclk;				//lcdc dclk
+	struct clk		*aclk;				//lcdc share memory frequency
+	u32 pixclock;	
+
+	u32 standby;						//1:standby,0:wrok
+};
+
+
+
+static inline void lcdc_writel(struct lcdc_device *lcdc_dev,u32 offset,u32 v)
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);	
+	*_pv = v;
+	writel_relaxed(v,lcdc_dev->regs+offset);	
+}
+
+static inline u32 lcdc_readl(struct lcdc_device *lcdc_dev,u32 offset)
+{
+	u32 v;
+	u32 *_pv = (u32*)lcdc_dev->regsbak;
+	_pv += (offset >> 2);
+	v = readl_relaxed(lcdc_dev->regs+offset);
+	*_pv = v;
+	return v;
+}
+
+static inline u32 lcdc_read_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk) 
+{
+       u32 _v = readl_relaxed(lcdc_dev->regs+offset); 
+       _v &= msk;
+       return (_v?1:0);   
+}
+
+static inline void  lcdc_set_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk) 
+{
+	u32* _pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);				
+	(*_pv) |= msk;				
+	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
+} 
+
+static inline void lcdc_clr_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk)
+{
+	u32* _pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);				
+	(*_pv) &= (~msk);				
+	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
+} 
+
+static inline void  lcdc_msk_reg(struct lcdc_device *lcdc_dev,u32 offset,u32 msk,u32 v)
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);			
+	(*_pv) &= (~msk);				
+	(*_pv) |= v;				
+	writel_relaxed(*_pv,lcdc_dev->regs+offset);	
+}
+
+static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev) 
+{
+	writel_relaxed(0x01,lcdc_dev->regs+REG_CFG_DONE); 
+	dsb();	
+} 
+
+#endif
diff -Nupr a/drivers/video/rockchip/lcdc/rk322x_lcdc.c b/drivers/video/rockchip/lcdc/rk322x_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk322x_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk322x_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,5334 @@
+/*
+ * drivers/video/rockchip/lcdc/rk322x_lcdc.c
+ *
+ * Copyright (C) 2015 ROCKCHIP, Inc.
+ * Author: Mark Yao <mark.yao@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/devfreq.h>
+#include <linux/devfreq-event.h>
+#include <linux/rockchip-iovmm.h>
+#include <asm/div64.h>
+#include <linux/uaccess.h>
+#include <linux/rockchip/grf.h>
+#include <dt-bindings/clock/rk_system_status.h>
+#include <soc/rockchip/rkfb_dmc.h>
+#include <linux/of_gpio.h>
+
+#include "rk322x_lcdc.h"
+
+/*#define CONFIG_RK_FPGA 1*/
+#define VOP_CHIP(dev)	(dev->data->chip_type)
+
+static int dbg_thresd;
+module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
+
+#define DBG(level, x...) do {			\
+	if (unlikely(dbg_thresd >= level))	\
+		pr_info(x);\
+	} while (0)
+
+static struct rk_lcdc_win rk322x_vop_win[] = {
+	{ .name = "win0",
+	  .id = VOP_WIN0,
+	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
+				SUPPORT_SCALE | SUPPORT_YUV |
+				SUPPORT_YUV10BIT,
+	  .property.max_input_x = 4096,
+	  .property.max_input_y = 2304},
+	{ .name = "win1",
+	  .id = VOP_WIN1,
+	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
+				SUPPORT_SCALE | SUPPORT_YUV |
+				SUPPORT_YUV10BIT,
+	  .property.max_input_x = 4096,
+	  .property.max_input_y = 2304},
+	{
+	  .name = "hwc",
+	  .id = VOP_HWC,
+	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
+				SUPPORT_HWC_LAYER,
+	  .property.max_input_x = 128,
+	  .property.max_input_y = 128
+	}
+};
+
+static struct rk_lcdc_win rk3399_vop_win[] = {
+	{ .name = "win0",
+	  .id = VOP_WIN0,
+	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
+				SUPPORT_SCALE | SUPPORT_YUV |
+				SUPPORT_YUV10BIT,
+	  .property.max_input_x = 4096,
+	  .property.max_input_y = 2304},
+	{ .name = "win1",
+	  .id = VOP_WIN1,
+	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
+				SUPPORT_SCALE | SUPPORT_YUV |
+				SUPPORT_YUV10BIT,
+	  .property.max_input_x = 4096,
+	  .property.max_input_y = 2304},
+	{ .name = "win2",
+	  .id = VOP_WIN2,
+	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
+				SUPPORT_MULTI_AREA,
+	  .property.max_input_x = 4096,
+	  .property.max_input_y = 2304},
+	{ .name = "win3",
+	  .id = VOP_WIN3,
+	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
+				SUPPORT_MULTI_AREA,
+	  .property.max_input_x = 4096,
+	  .property.max_input_y = 2304},
+	{
+	  .name = "hwc",
+	  .id = VOP_HWC,
+	  .property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HW_EXIST |
+				SUPPORT_HWC_LAYER,
+	  .property.max_input_x = 128,
+	  .property.max_input_y = 128
+	}
+};
+
+static const struct vop_data rk322x_data = {
+	.chip_type = VOP_RK322X,
+	.win = rk322x_vop_win,
+	.n_wins = ARRAY_SIZE(rk322x_vop_win),
+};
+
+static const struct vop_data rk3399_data = {
+	.chip_type = VOP_RK3399,
+	.win = rk3399_vop_win,
+	.n_wins = ARRAY_SIZE(rk3399_vop_win),
+};
+
+#if defined(CONFIG_OF)
+static const struct of_device_id vop_dt_ids[] = {
+	{.compatible = "rockchip,rk322x-lcdc",
+	 .data = &rk322x_data, },
+	{.compatible = "rockchip,rk3399-lcdc",
+	 .data = &rk3399_data, },
+	{}
+};
+#endif
+
+static const u32 csc_y2r_bt601_limit[12] = {
+	0x04a8,      0,  0x0662, 0xfffc8654,
+	0x04a8, 0xfe6f,  0xfcbf, 0x00022056,
+	0x04a8, 0x0812,       0, 0xfffbaeac,
+};
+
+static const u32 csc_y2r_bt709_full[12] = {
+	0x04a8,      0,  0x072c, 0xfffc219e,
+	0x04a8, 0xff26,  0xfdde, 0x0001357b,
+	0x04a8, 0x0873,       0, 0xfffb7dee,
+};
+
+static const u32 csc_y2r_bt601_full[12] = {
+	0x0400,      0,  0x059c, 0xfffd342d,
+	0x0400, 0xfea0,  0xfd25, 0x00021fcc,
+	0x0400, 0x0717,       0, 0xfffc76bc,
+};
+
+static const u32 csc_y2r_bt601_limit_10[12] = {
+	0x04a8,      0,  0x0662, 0xfff2134e,
+	0x04a8, 0xfe6f,  0xfcbf, 0x00087b58,
+	0x04a8, 0x0812,       0, 0xffeeb4b0,
+};
+
+static const u32 csc_y2r_bt709_full_10[12] = {
+	0x04a8,      0,  0x072c, 0xfff08077,
+	0x04a8, 0xff26,  0xfdde, 0x0004cfed,
+	0x04a8, 0x0873,       0, 0xffedf1b8,
+};
+
+static const u32 csc_y2r_bt601_full_10[12] = {
+	0x0400,      0,  0x059c, 0xfff4cab4,
+	0x0400, 0xfea0,  0xfd25, 0x00087932,
+	0x0400, 0x0717,       0, 0xfff1d4f2,
+};
+
+static const u32 csc_y2r_bt2020[12] = {
+	0x04a8,      0, 0x06b6, 0xfff16bfc,
+	0x04a8, 0xff40, 0xfd66, 0x58ae9,
+	0x04a8, 0x0890,      0, 0xffedb828,
+};
+
+static const u32 csc_r2y_bt601_limit[12] = {
+	0x0107, 0x0204, 0x0064, 0x04200,
+	0xff68, 0xfed6, 0x01c2, 0x20200,
+	0x01c2, 0xfe87, 0xffb7, 0x20200,
+};
+
+static const u32 csc_r2y_bt709_full[12] = {
+	0x00bb, 0x0275, 0x003f, 0x04200,
+	0xff99, 0xfea5, 0x01c2, 0x20200,
+	0x01c2, 0xfe68, 0xffd7, 0x20200,
+};
+
+static const u32 csc_r2y_bt601_full[12] = {
+	0x0132, 0x0259, 0x0075, 0x200,
+	0xff53, 0xfead, 0x0200, 0x20200,
+	0x0200, 0xfe53, 0xffad, 0x20200,
+};
+
+static const u32 csc_r2y_bt601_limit_10[12] = {
+	0x0107, 0x0204, 0x0064, 0x10200,
+	0xff68, 0xfed6, 0x01c2, 0x80200,
+	0x01c2, 0xfe87, 0xffb7, 0x80200,
+};
+
+static const u32 csc_r2y_bt709_full_10[12] = {
+	0x00bb, 0x0275, 0x003f, 0x10200,
+	0xff99, 0xfea5, 0x01c2, 0x80200,
+	0x01c2, 0xfe68, 0xffd7, 0x80200,
+};
+
+static const u32 csc_r2y_bt601_full_10[12] = {
+	0x0132, 0x0259, 0x0075, 0x200,
+	0xff53, 0xfead, 0x0200, 0x80200,
+	0x0200, 0xfe53, 0xffad, 0x80200,
+};
+
+static const u32 csc_r2y_bt2020[12] = {
+	0x00e6, 0x0253, 0x0034, 0x10200,
+	0xff83, 0xfebd, 0x01c1, 0x80200,
+	0x01c1, 0xfe64, 0xffdc, 0x80200,
+};
+
+static const u32 csc_r2r_bt2020to709[12] = {
+	0x06a4, 0xfda6, 0xffb5, 0x200,
+	0xff80, 0x0488, 0xfff8, 0x200,
+	0xffed, 0xff99, 0x047a, 0x200,
+};
+
+static const u32 csc_r2r_bt709to2020[12] = {
+	0x282, 0x151, 0x02c, 0x200,
+	0x047, 0x3ae, 0x00c, 0x200,
+	0x011, 0x05a, 0x395, 0x200,
+};
+
+static int vop_get_id(struct vop_device *vop_dev, u32 phy_base)
+{
+	if (VOP_CHIP(vop_dev) == VOP_RK3399) {
+		if (phy_base == 0xff900000) /* vop big */
+			return 0;
+		else if (phy_base == 0xff8f0000) /* vop lit */
+			return 1;
+		else
+			return -EINVAL;
+	} else {
+		return 0;
+	}
+}
+
+static void vop_load_csc_table(struct vop_device *vop_dev, u32 offset,
+			       const u32 *table)
+{
+	u32 csc_val;
+
+	csc_val = table[1] << 16 | table[0];
+	vop_writel(vop_dev, offset, csc_val);
+	csc_val = table[4] << 16 | table[2];
+	vop_writel(vop_dev, offset + 4, csc_val);
+	csc_val = table[6] << 16 | table[5];
+	vop_writel(vop_dev, offset + 8, csc_val);
+	csc_val = table[9] << 16 | table[8];
+	vop_writel(vop_dev, offset + 0xc, csc_val);
+	csc_val = table[10];
+	vop_writel(vop_dev, offset + 0x10, csc_val);
+	csc_val = table[3];
+	vop_writel(vop_dev, offset + 0x14, csc_val);
+	csc_val = table[7];
+	vop_writel(vop_dev, offset + 0x18, csc_val);
+	csc_val = table[11];
+	vop_writel(vop_dev, offset + 0x1c, csc_val);
+}
+
+#define LOAD_CSC(dev, mode, table, win_id) \
+		vop_load_csc_table(dev, \
+				   WIN0_YUV2YUV_##mode + 0x60 * win_id, \
+				   table)
+
+static int vop_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable);
+
+static int vop_set_lut(struct rk_lcdc_driver *dev_drv, int *dsp_lut)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	int i, j;
+
+	if (!vop_dev->dsp_lut_addr_base) {
+		dev_warn(vop_dev->dev, "not support dsp lut config\n");
+		return 0;
+	}
+
+	if (!dsp_lut) {
+		dev_err(vop_dev->dev, "dsp lut table is null\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&vop_dev->reg_lock);
+	for (i = 0; i < 256; i++) {
+		u32 v, r, g, b;
+		int __iomem *c;
+
+		v = dsp_lut[i];
+		if (dev_drv->id == 0) {
+			c = vop_dev->dsp_lut_addr_base + (i << 2);
+			b = (v & 0xff) << 2;
+			g = (v & 0xff00) << 4;
+			r = (v & 0xff0000) << 6;
+			v = r + g + b;
+			for (j = 0; j < 4; j++) {
+				writel_relaxed(v, c);
+				v += (1 + (1 << 10) + (1 << 20));
+				c++;
+			}
+		} else {
+			c = vop_dev->dsp_lut_addr_base + i;
+			writel_relaxed(v, c);
+		}
+	}
+	vop_msk_reg(vop_dev, DSP_CTRL1, V_DSP_LUT_EN(1));
+	/*
+	 * update_gamma value auto clean to 0 by HW, should not
+	 * bakeup it.
+	 */
+	vop_msk_reg_nobak(vop_dev, DSP_CTRL1, V_UPDATE_GAMMA_LUT(1));
+
+	vop_cfg_done(vop_dev);
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_set_cabc(struct rk_lcdc_driver *dev_drv, int *cabc_lut)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	int i;
+
+	if (!vop_dev->cabc_lut_addr_base) {
+		dev_warn(vop_dev->dev, "not support cabc config\n");
+		return 0;
+	}
+
+	if (!cabc_lut) {
+		dev_err(vop_dev->dev, "cabc lut table is null\n");
+		return -EINVAL;
+	}
+	spin_lock(&vop_dev->reg_lock);
+	vop_msk_reg(vop_dev, CABC_CTRL1, V_CABC_LUT_EN(0));
+	vop_cfg_done(vop_dev);
+	spin_unlock(&vop_dev->reg_lock);
+
+	mdelay(25);
+
+	spin_lock(&vop_dev->reg_lock);
+	for (i = 0; i < 128; i++) {
+		u32 v;
+
+		v = cabc_lut[i];
+
+		writel_relaxed(v, vop_dev->cabc_lut_addr_base + i);
+	}
+	vop_msk_reg(vop_dev, CABC_CTRL1, V_CABC_LUT_EN(1));
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_clk_enable(struct vop_device *vop_dev)
+{
+	if (!vop_dev->clk_on) {
+		clk_prepare_enable(vop_dev->hclk);
+		clk_prepare_enable(vop_dev->dclk);
+		clk_prepare_enable(vop_dev->aclk);
+		if (vop_dev->hclk_noc)
+			clk_prepare_enable(vop_dev->hclk_noc);
+		if (vop_dev->aclk_noc)
+			clk_prepare_enable(vop_dev->aclk_noc);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		pm_runtime_get_sync(vop_dev->dev);
+#endif
+		spin_lock(&vop_dev->reg_lock);
+		vop_dev->clk_on = 1;
+		spin_unlock(&vop_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int vop_clk_disable(struct vop_device *vop_dev)
+{
+	if (vop_dev->clk_on) {
+		spin_lock(&vop_dev->reg_lock);
+		vop_dev->clk_on = 0;
+		spin_unlock(&vop_dev->reg_lock);
+		mdelay(25);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		pm_runtime_put_sync(vop_dev->dev);
+#endif
+		clk_disable_unprepare(vop_dev->dclk);
+		clk_disable_unprepare(vop_dev->hclk);
+		clk_disable_unprepare(vop_dev->aclk);
+		if (vop_dev->hclk_noc)
+			clk_disable_unprepare(vop_dev->hclk_noc);
+		if (vop_dev->aclk_noc)
+			clk_disable_unprepare(vop_dev->aclk_noc);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused vop_disable_irq(struct vop_device *vop_dev)
+{
+	if (likely(vop_dev->clk_on)) {
+		spin_lock(&vop_dev->reg_lock);
+		vop_writel(vop_dev, INTR_EN0, 0xffff0000);
+		vop_writel(vop_dev, INTR_EN1, 0xffff0000);
+		vop_writel(vop_dev, INTR_CLEAR0, 0xffffffff);
+		vop_writel(vop_dev, INTR_CLEAR1, 0xffffffff);
+		vop_cfg_done(vop_dev);
+		spin_unlock(&vop_dev->reg_lock);
+	};
+
+	return 0;
+}
+
+static int vop_reg_dump(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	int *cbase = (int *)vop_dev->regs;
+	int *regsbak = (int *)vop_dev->regsbak;
+	int i, j, val;
+	char dbg_message[30];
+	char buf[10];
+
+	pr_info("lcd back up reg:\n");
+	memset(dbg_message, 0, sizeof(dbg_message));
+	memset(buf, 0, sizeof(buf));
+	for (i = 0; i <= (0x200 >> 4); i++) {
+		val = sprintf(dbg_message, "0x%04x: ", i * 16);
+		for (j = 0; j < 4; j++) {
+			val = sprintf(buf, "%08x  ", *(regsbak + i * 4 + j));
+			strcat(dbg_message, buf);
+		}
+		pr_info("%s\n", dbg_message);
+		memset(dbg_message, 0, sizeof(dbg_message));
+		memset(buf, 0, sizeof(buf));
+	}
+
+	pr_info("lcdc reg:\n");
+	for (i = 0; i <= (0x200 >> 4); i++) {
+		val = sprintf(dbg_message, "0x%04x: ", i * 16);
+		for (j = 0; j < 4; j++) {
+			sprintf(buf, "%08x  ",
+				readl_relaxed(cbase + i * 4 + j));
+			strcat(dbg_message, buf);
+		}
+		pr_info("%s\n", dbg_message);
+		memset(dbg_message, 0, sizeof(dbg_message));
+		memset(buf, 0, sizeof(buf));
+	}
+
+	return 0;
+}
+
+#define WIN_EN(id)		\
+static int win##id##_enable(struct vop_device *vop_dev, int en)	\
+{ \
+	spin_lock(&vop_dev->reg_lock);					\
+	vop_msk_reg(vop_dev, WIN##id##_CTRL0, V_WIN##id##_EN((u64)en));	\
+	vop_cfg_done(vop_dev);						\
+	spin_unlock(&vop_dev->reg_lock);				\
+	return 0;							\
+}
+
+WIN_EN(0);
+WIN_EN(1);
+WIN_EN(2);
+WIN_EN(3);
+
+/*enable/disable win directly*/
+static int vop_win_direct_en(struct rk_lcdc_driver *drv,
+			     int win_id, int en)
+{
+	struct vop_device *vop_dev =
+	    container_of(drv, struct vop_device, driver);
+
+	drv->win[win_id]->state = en;
+	if (win_id == 0)
+		win0_enable(vop_dev, en);
+	else if (win_id == 1)
+		win1_enable(vop_dev, en);
+	else if (win_id == 2)
+		win2_enable(vop_dev, en);
+	else if (win_id == 3)
+		win3_enable(vop_dev, en);
+	else
+		dev_err(vop_dev->dev, "invalid win number:%d\n", win_id);
+	return 0;
+}
+
+#define SET_WIN_ADDR(id) \
+static int set_win##id##_addr(struct vop_device *vop_dev, u32 addr) \
+{							\
+	spin_lock(&vop_dev->reg_lock);			\
+	vop_writel(vop_dev, WIN##id##_YRGB_MST, addr);	\
+	vop_msk_reg(vop_dev, WIN##id##_CTRL0, V_WIN##id##_EN(1));	\
+	vop_cfg_done(vop_dev);			\
+	spin_unlock(&vop_dev->reg_lock);		\
+	return 0;					\
+}
+
+SET_WIN_ADDR(0);
+SET_WIN_ADDR(1);
+int vop_direct_set_win_addr(struct rk_lcdc_driver *dev_drv,
+			    int win_id, u32 addr)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	if (win_id == 0)
+		set_win0_addr(vop_dev, addr);
+	else
+		set_win1_addr(vop_dev, addr);
+
+	return 0;
+}
+
+static void lcdc_read_reg_defalut_cfg(struct vop_device *vop_dev)
+{
+	int reg = 0;
+	u32 val = 0;
+	struct rk_screen *screen = vop_dev->driver.cur_screen;
+	u32 h_pw_bp = screen->mode.hsync_len + screen->mode.left_margin;
+	u32 V_pw_bp = screen->mode.vsync_len + screen->mode.upper_margin;
+	u32 st_x, st_y;
+	struct rk_lcdc_win *win0 = vop_dev->driver.win[0];
+
+	spin_lock(&vop_dev->reg_lock);
+	for (reg = 0; reg < vop_dev->len; reg += 4) {
+		val = vop_readl_backup(vop_dev, reg);
+		switch (reg) {
+		case WIN0_ACT_INFO:
+			win0->area[0].xact = (val & MASK(WIN0_ACT_WIDTH)) + 1;
+			win0->area[0].yact =
+				((val & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
+			break;
+		case WIN0_DSP_INFO:
+			win0->area[0].xsize = (val & MASK(WIN0_DSP_WIDTH)) + 1;
+			win0->area[0].ysize =
+			    ((val & MASK(WIN0_DSP_HEIGHT)) >> 16) + 1;
+			break;
+		case WIN0_DSP_ST:
+			st_x = val & MASK(WIN0_DSP_XST);
+			st_y = (val & MASK(WIN0_DSP_YST)) >> 16;
+			win0->area[0].xpos = st_x - h_pw_bp;
+			win0->area[0].ypos = st_y - V_pw_bp;
+			break;
+		case WIN0_CTRL0:
+			win0->state = val & MASK(WIN0_EN);
+			win0->area[0].fmt_cfg =
+					(val & MASK(WIN0_DATA_FMT)) >> 1;
+			win0->fmt_10 = (val & MASK(WIN0_FMT_10)) >> 4;
+			win0->area[0].format = win0->area[0].fmt_cfg;
+			break;
+		case WIN0_VIR:
+			win0->area[0].y_vir_stride =
+					val & MASK(WIN0_VIR_STRIDE);
+			win0->area[0].uv_vir_stride =
+			    (val & MASK(WIN0_VIR_STRIDE_UV)) >> 16;
+			if (win0->area[0].format == ARGB888)
+				win0->area[0].xvir = win0->area[0].y_vir_stride;
+			else if (win0->area[0].format == RGB888)
+				win0->area[0].xvir =
+				    win0->area[0].y_vir_stride * 4 / 3;
+			else if (win0->area[0].format == RGB565)
+				win0->area[0].xvir =
+				    2 * win0->area[0].y_vir_stride;
+			else
+				win0->area[0].xvir =
+				    4 * win0->area[0].y_vir_stride;
+			break;
+		case WIN0_YRGB_MST:
+			win0->area[0].smem_start = val;
+			break;
+		case WIN0_CBR_MST:
+			win0->area[0].cbr_start = val;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+}
+
+/********do basic init*********/
+static int vop_pre_init(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	if (vop_dev->pre_init)
+		return 0;
+	vop_dev->hclk = devm_clk_get(vop_dev->dev, "hclk_lcdc");
+	vop_dev->aclk = devm_clk_get(vop_dev->dev, "aclk_lcdc");
+	vop_dev->dclk = devm_clk_get(vop_dev->dev, "dclk_lcdc");
+	if (IS_ERR(vop_dev->aclk) || IS_ERR(vop_dev->dclk) ||
+	    IS_ERR(vop_dev->hclk)) {
+		dev_err(vop_dev->dev, "failed to get clk source\n");
+		return -1;
+	}
+	vop_dev->hclk_noc = devm_clk_get(vop_dev->dev, "hclk_vop_noc");
+	if (IS_ERR(vop_dev->hclk_noc)) {
+		vop_dev->hclk_noc = NULL;
+		dev_err(vop_dev->dev, "failed to get clk source\n");
+	}
+	vop_dev->aclk_noc = devm_clk_get(vop_dev->dev, "aclk_vop_noc");
+	if (IS_ERR(vop_dev->aclk_noc)) {
+		vop_dev->aclk_noc = NULL;
+		dev_err(vop_dev->dev, "failed to get clk source\n");
+	}
+	if (!support_uboot_display())
+		rk_disp_pwr_enable(dev_drv);
+	vop_clk_enable(vop_dev);
+
+	memcpy(vop_dev->regsbak, vop_dev->regs, vop_dev->len);
+	/*backup reg config at uboot */
+	lcdc_read_reg_defalut_cfg(vop_dev);
+	#ifndef CONFIG_RK_FPGA
+	/*
+	 * Todo, not verified
+	 *
+	if (vop_dev->pwr18 == 1) {
+		v = 0x00200020;
+		vop_grf_writel(vop_dev->pmugrf_base,
+				PMUGRF_SOC_CON0_VOP, v);
+	} else {
+		v = 0x00200000;
+		vop_grf_writel(vop_dev->pmugrf_base,
+				PMUGRF_SOC_CON0_VOP, v);
+	}
+	*/
+	#endif
+	vop_writel(vop_dev, FRC_LOWER01_0, 0x12844821);
+	vop_writel(vop_dev, FRC_LOWER01_1, 0x21488412);
+	vop_writel(vop_dev, FRC_LOWER10_0, 0xa55a9696);
+	vop_writel(vop_dev, FRC_LOWER10_1, 0x5aa56969);
+	vop_writel(vop_dev, FRC_LOWER11_0, 0xdeb77deb);
+	vop_writel(vop_dev, FRC_LOWER11_1, 0xed7bb7de);
+
+	if (!dev_drv->cabc_mode)
+		vop_msk_reg(vop_dev, SYS_CTRL, V_AUTO_GATING_EN(0));
+	vop_msk_reg(vop_dev, DSP_CTRL1, V_DITHER_UP_EN(1));
+	vop_cfg_done(vop_dev);
+	if ((dev_drv->cur_screen->refresh_mode == SCREEN_CMD_MODE) &&
+	    (support_uboot_display() == 0))
+		vop_msk_reg(vop_dev, SYS_CTRL, V_EDPI_WMS_MODE(1));
+	vop_dev->pre_init = true;
+
+	return 0;
+}
+
+static void vop_deint(struct vop_device *vop_dev)
+{
+	if (vop_dev->clk_on) {
+		u64 val;
+
+		vop_disable_irq(vop_dev);
+		spin_lock(&vop_dev->reg_lock);
+		vop_msk_reg(vop_dev, WIN0_CTRL0, V_WIN0_EN(0));
+		vop_msk_reg(vop_dev, WIN1_CTRL0, V_WIN0_EN(0));
+
+		val = V_WIN2_EN(0) | V_WIN2_MST0_EN(0) | V_WIN2_MST1_EN(0) |
+			V_WIN2_MST2_EN(0) | V_WIN2_MST3_EN(0);
+		vop_msk_reg(vop_dev, WIN2_CTRL0, val);
+		vop_msk_reg(vop_dev, WIN3_CTRL0, val);
+		vop_cfg_done(vop_dev);
+		spin_unlock(&vop_dev->reg_lock);
+		mdelay(50);
+	}
+}
+
+static void vop_win_csc_mode(struct vop_device *vop_dev,
+			     struct rk_lcdc_win *win,
+			     int csc_mode)
+{
+	u64 val;
+
+	if (win->id == VOP_WIN0) {
+		val = V_WIN0_CSC_MODE(csc_mode);
+		vop_msk_reg(vop_dev, WIN0_CTRL0, val);
+	} else if (win->id == VOP_WIN1) {
+		val = V_WIN1_CSC_MODE(csc_mode);
+		vop_msk_reg(vop_dev, WIN1_CTRL0, val);
+	} else {
+		val = V_HWC_CSC_MODE(csc_mode);
+		vop_msk_reg(vop_dev, HWC_CTRL0, val);
+	}
+}
+
+static int rk3399_vop_win_csc_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	int output_color = dev_drv->output_color;
+	int i;
+
+	for (i = 0; i < dev_drv->lcdc_win_num && i < 4; i++) {
+		struct rk_lcdc_win *win = dev_drv->win[i];
+		int shift = i * 8;
+		u64 val = V_WIN0_YUV2YUV_EN(0) | V_WIN0_YUV2YUV_R2Y_EN(0) |
+				V_WIN0_YUV2YUV_Y2R_EN(0);
+
+		if (!win->state)
+			continue;
+		if (output_color == COLOR_RGB &&
+		    !(IS_YUV(win->area[0].fmt_cfg) || win->area[0].yuyv_fmt))
+			goto post;
+
+		if (output_color == COLOR_RGB) {
+			val |= V_WIN0_YUV2YUV_Y2R_EN(1);
+			if (win->colorspace == CSC_BT601) {
+				/*
+				 * Win Y2Y moudle always use 10bit mode.
+				 */
+				LOAD_CSC(vop_dev, Y2R,
+					 csc_y2r_bt601_full_10, i);
+			} else if (win->colorspace == CSC_BT709) {
+				LOAD_CSC(vop_dev, Y2R,
+					 csc_y2r_bt709_full_10, i);
+			} else if (win->colorspace == CSC_BT2020) {
+				val |= V_WIN0_YUV2YUV_EN(1);
+				LOAD_CSC(vop_dev, Y2R, csc_y2r_bt2020, i);
+				LOAD_CSC(vop_dev, R2R, csc_r2r_bt2020to709, i);
+			}
+		} else if (output_color == COLOR_YCBCR ||
+				output_color == COLOR_YCBCR_BT709) {
+			if (!(IS_YUV(win->area[0].fmt_cfg) ||
+			      win->area[0].yuyv_fmt)) {
+				val |= V_WIN0_YUV2YUV_R2Y_EN(1);
+				if ((win->id == 0) || (win->id == 1))
+					LOAD_CSC(vop_dev, R2Y, csc_r2y_bt709_full_10, i);
+				else
+					val |= V_WIN0_YUV2YUV_R2Y_MODE(VOP_R2Y_CSC_BT709);
+
+			} else if (win->colorspace == CSC_BT2020) {
+				val |= V_WIN0_YUV2YUV_EN(1) |
+					V_WIN0_YUV2YUV_Y2R_EN(1) |
+					V_WIN0_YUV2YUV_R2Y_EN(1);
+				LOAD_CSC(vop_dev, Y2R, csc_y2r_bt2020, i);
+				LOAD_CSC(vop_dev, R2R, csc_r2r_bt2020to709, i);
+				LOAD_CSC(vop_dev, R2Y, csc_r2y_bt709_full_10, i);
+			}
+		} else if (output_color == COLOR_YCBCR_BT2020) {
+			if (!(IS_YUV(win->area[0].fmt_cfg) ||
+			      win->area[0].yuyv_fmt)) {
+				LOAD_CSC(vop_dev, R2R, csc_r2r_bt709to2020, i);
+				val |= V_WIN0_YUV2YUV_R2Y_EN(1) |
+					V_WIN0_YUV2YUV_EN(1);
+				if ((win->id == 0) || (win->id == 1)) {
+					LOAD_CSC(vop_dev, R2Y, csc_r2y_bt2020, i);
+				} else {
+					val |= V_WIN0_YUV2YUV_R2Y_MODE(VOP_R2Y_CSC_BT2020);
+				}
+			} else if (win->colorspace == CSC_BT601 ||
+					win->colorspace == CSC_BT709) {
+				val |= V_WIN0_YUV2YUV_Y2R_EN(1) |
+					V_WIN0_YUV2YUV_R2Y_EN(1) |
+					V_WIN0_YUV2YUV_EN(1);
+				LOAD_CSC(vop_dev, Y2R, csc_y2r_bt709_full_10, i);
+				LOAD_CSC(vop_dev, R2R, csc_r2r_bt709to2020, i);
+				LOAD_CSC(vop_dev, R2Y, csc_r2y_bt2020, i);
+			}
+		}
+post:
+		vop_msk_reg(vop_dev, YUV2YUV_WIN, val << shift);
+	}
+
+	return output_color;
+}
+
+/*
+ * colorspace path:
+ *      Input        Win csc            Post csc              Output
+ * 1. YUV(2020)  --> bypass   ---+ Y2R->2020To709->R2Y --> YUV_OUTPUT(601/709)
+ *    RGB        --> R2Y(709) __/
+ *
+ * 2. YUV(2020)  --> bypass   ---+       bypass        --> YUV_OUTPUT(2020)
+ *    RGB        --> R2Y(709) __/
+ *
+ * 3. YUV(2020)  --> bypass   ---+    Y2R->2020To709   --> RGB_OUTPUT(709)
+ *    RGB        --> R2Y(709) __/
+ *
+ * 4. YUV(601/709)-> bypass   ---+ Y2R->709To2020->R2Y --> YUV_OUTPUT(2020)
+ *    RGB        --> R2Y(709) __/
+ *
+ * 5. YUV(601/709)-> bypass   ---+       bypass        --> YUV_OUTPUT(709)
+ *    RGB        --> R2Y(709) __/
+ *
+ * 6. YUV(601/709)-> bypass   ---+       bypass        --> YUV_OUTPUT(601)
+ *    RGB        --> R2Y(601) __/
+ *
+ * 7. YUV(601)   --> Y2R(601/mpeg)-+     bypass        --> RGB_OUTPUT(709)
+ *    RGB        --> bypass   ____/
+ *
+ * 8. YUV(709)   --> Y2R(709/hd) --+     bypass        --> RGB_OUTPUT(709)
+ *    RGB        --> bypass   ____/
+ *
+ * 9. RGB        --> bypass   --->    709To2020->R2Y   --> YUV_OUTPUT(2020)
+ *
+ * 10. RGB       --> R2Y(709) --->      bypass        --> YUV_OUTPUT(709)
+ *
+ * 11. RGB       --> R2Y(601) --->       bypass        --> YUV_OUTPUT(601)
+ *
+ * 12. RGB       --> bypass   --->       bypass        --> RGB_OUTPUT(709)
+ */
+static int rk3228_vop_win_csc_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win;
+	int output_color = dev_drv->output_color;
+	int win_csc = COLOR_RGB;
+	int r2y_mode = VOP_R2Y_CSC_BT709;
+	int i;
+
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		win = dev_drv->win[i];
+		if (!win->state)
+			continue;
+
+		if (IS_YUV(win->area[0].fmt_cfg)) {
+			if (win->colorspace == CSC_BT2020 &&
+			    win_csc < COLOR_YCBCR_BT2020) {
+				r2y_mode = VOP_R2Y_CSC_BT709;
+				win_csc = COLOR_YCBCR_BT2020;
+			}
+
+			if (win->colorspace == CSC_BT709 &&
+			    win_csc < COLOR_YCBCR_BT709) {
+				r2y_mode = VOP_R2Y_CSC_BT709;
+				win_csc = COLOR_YCBCR_BT709;
+			}
+
+			if (win->colorspace == CSC_BT601 &&
+			    win_csc < COLOR_YCBCR) {
+				r2y_mode = VOP_R2Y_CSC_BT709;
+				win_csc = COLOR_YCBCR;
+			}
+		}
+	}
+
+	if (win_csc == COLOR_RGB) {
+		if (output_color == COLOR_YCBCR_BT709) {
+			r2y_mode = VOP_R2Y_CSC_BT709;
+			win_csc = COLOR_YCBCR_BT709;
+		} else if (output_color == COLOR_YCBCR) {
+			r2y_mode = VOP_R2Y_CSC_BT601;
+			win_csc = COLOR_YCBCR;
+		}
+	}
+
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		win = dev_drv->win[i];
+		if (!win->state)
+			continue;
+
+		if (win_csc != COLOR_RGB && !IS_YUV(win->area[0].fmt_cfg))
+			vop_win_csc_mode(vop_dev, win, r2y_mode);
+
+		if (IS_YUV(win->area[0].fmt_cfg)) {
+			if (win_csc == COLOR_YCBCR)
+				vop_win_csc_mode(vop_dev, win,
+						 VOP_Y2R_CSC_MPEG);
+			else if (win_csc == COLOR_YCBCR_BT709)
+				vop_win_csc_mode(vop_dev, win, VOP_Y2R_CSC_HD);
+		}
+	}
+
+	return win_csc;
+}
+
+static int vop_post_csc_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	int output_color = dev_drv->output_color;
+	int win_csc = 0, overlay_mode = 0;
+	u64 val;
+
+	if (VOP_CHIP(vop_dev) == VOP_RK322X) {
+		win_csc = rk3228_vop_win_csc_cfg(dev_drv);
+	} else if (VOP_CHIP(vop_dev) == VOP_RK3399) {
+		win_csc = rk3399_vop_win_csc_cfg(dev_drv);
+
+		/*
+		 * RK3399 not support post csc config.
+		 */
+		goto done;
+	}
+
+	val = V_YUV2YUV_POST_Y2R_EN(0) | V_YUV2YUV_POST_EN(0) |
+		V_YUV2YUV_POST_R2Y_EN(0);
+	/* Y2R */
+	if (win_csc == COLOR_YCBCR && output_color == COLOR_YCBCR_BT2020) {
+		val |= V_YUV2YUV_POST_Y2R_EN(1);
+		vop_load_csc_table(vop_dev, POST_YUV2YUV_Y2R_COE,
+				   csc_y2r_bt709_full);
+	}
+	if (win_csc == COLOR_YCBCR_BT2020 &&
+	    output_color != COLOR_YCBCR_BT2020) {
+		val |= V_YUV2YUV_POST_Y2R_EN(1);
+		vop_load_csc_table(vop_dev, POST_YUV2YUV_Y2R_COE,
+				   csc_y2r_bt2020);
+	}
+
+	/* R2R */
+	if ((win_csc == COLOR_YCBCR ||
+	     win_csc == COLOR_YCBCR_BT709 ||
+	     win_csc == COLOR_RGB) && output_color == COLOR_YCBCR_BT2020) {
+		val |= V_YUV2YUV_POST_EN(1);
+		vop_load_csc_table(vop_dev, POST_YUV2YUV_3x3_COE,
+				   csc_r2r_bt709to2020);
+	}
+	if (win_csc == COLOR_YCBCR_BT2020 &&
+	    (output_color == COLOR_YCBCR ||
+	     output_color == COLOR_YCBCR_BT709 ||
+	     output_color == COLOR_RGB)) {
+		val |= V_YUV2YUV_POST_EN(1);
+		vop_load_csc_table(vop_dev, POST_YUV2YUV_3x3_COE,
+				   csc_r2r_bt2020to709);
+	}
+
+	/* Y2R */
+	if (output_color != COLOR_RGB) {
+		val |= V_YUV2YUV_POST_R2Y_EN(1);
+
+		if (output_color == COLOR_YCBCR_BT2020)
+			vop_load_csc_table(vop_dev, POST_YUV2YUV_R2Y_COE,
+					   csc_r2y_bt2020);
+		else
+			vop_load_csc_table(vop_dev, POST_YUV2YUV_R2Y_COE,
+					   csc_r2y_bt709_full);
+	}
+
+	DBG(1, "win_csc=%d output_color=%d val=%llx\n",
+	    win_csc, output_color, val);
+	vop_msk_reg(vop_dev, YUV2YUV_POST, val);
+done:
+	overlay_mode = (win_csc != COLOR_RGB) ? VOP_YUV_DOMAIN : VOP_RGB_DOMAIN;
+	vop_msk_reg(vop_dev, SYS_CTRL, V_OVERLAY_MODE(overlay_mode));
+
+	return 0;
+}
+
+static int vop_post_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u64 val;
+	u16 h_total, v_total;
+	u16 post_hsd_en, post_vsd_en;
+	u16 post_dsp_hact_st, post_dsp_hact_end;
+	u16 post_dsp_vact_st, post_dsp_vact_end;
+	u16 post_dsp_vact_st_f1, post_dsp_vact_end_f1;
+	u16 post_h_fac, post_v_fac;
+
+	screen->post_dsp_stx = x_res * (100 - dev_drv->overscan.left) / 200;
+	screen->post_dsp_sty = y_res * (100 - dev_drv->overscan.top) / 200;
+	screen->post_xsize = x_res *
+	    (dev_drv->overscan.left + dev_drv->overscan.right) / 200;
+	screen->post_ysize = y_res *
+	    (dev_drv->overscan.top + dev_drv->overscan.bottom) / 200;
+
+	h_total = screen->mode.hsync_len + screen->mode.left_margin +
+	    x_res + screen->mode.right_margin;
+	v_total = screen->mode.vsync_len + screen->mode.upper_margin +
+	    y_res + screen->mode.lower_margin;
+
+	if (screen->post_dsp_stx + screen->post_xsize > x_res) {
+		dev_warn(vop_dev->dev, "post:stx[%d]+xsize[%d]>x_res[%d]\n",
+			 screen->post_dsp_stx, screen->post_xsize, x_res);
+		screen->post_dsp_stx = x_res - screen->post_xsize;
+	}
+	if (screen->x_mirror == 0) {
+		post_dsp_hact_st = screen->post_dsp_stx +
+		    screen->mode.hsync_len + screen->mode.left_margin;
+		post_dsp_hact_end = post_dsp_hact_st + screen->post_xsize;
+	} else {
+		post_dsp_hact_end = h_total - screen->mode.right_margin -
+		    screen->post_dsp_stx;
+		post_dsp_hact_st = post_dsp_hact_end - screen->post_xsize;
+	}
+	if ((screen->post_xsize < x_res) && (screen->post_xsize != 0)) {
+		post_hsd_en = 1;
+		post_h_fac =
+		    GET_SCALE_FACTOR_BILI_DN(x_res, screen->post_xsize);
+	} else {
+		post_hsd_en = 0;
+		post_h_fac = 0x1000;
+	}
+
+	if (screen->post_dsp_sty + screen->post_ysize > y_res) {
+		dev_warn(vop_dev->dev, "post:sty[%d]+ysize[%d]> y_res[%d]\n",
+			 screen->post_dsp_sty, screen->post_ysize, y_res);
+		screen->post_dsp_sty = y_res - screen->post_ysize;
+	}
+
+	if ((screen->post_ysize < y_res) && (screen->post_ysize != 0)) {
+		post_vsd_en = 1;
+		post_v_fac = GET_SCALE_FACTOR_BILI_DN(y_res,
+						      screen->post_ysize);
+	} else {
+		post_vsd_en = 0;
+		post_v_fac = 0x1000;
+	}
+
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		post_dsp_vact_st = screen->post_dsp_sty / 2 +
+					screen->mode.vsync_len +
+					screen->mode.upper_margin;
+		post_dsp_vact_end = post_dsp_vact_st +
+					screen->post_ysize / 2;
+
+		post_dsp_vact_st_f1 = screen->mode.vsync_len +
+					screen->mode.upper_margin +
+					y_res / 2 +
+					screen->mode.lower_margin +
+					screen->mode.vsync_len +
+					screen->mode.upper_margin +
+					screen->post_dsp_sty / 2 +
+					1;
+		post_dsp_vact_end_f1 = post_dsp_vact_st_f1 +
+					screen->post_ysize / 2;
+	} else {
+		if (screen->y_mirror == 0) {
+			post_dsp_vact_st = screen->post_dsp_sty +
+			    screen->mode.vsync_len +
+			    screen->mode.upper_margin;
+			post_dsp_vact_end = post_dsp_vact_st +
+				screen->post_ysize;
+		} else {
+			post_dsp_vact_end = v_total -
+				screen->mode.lower_margin -
+			    screen->post_dsp_sty;
+			post_dsp_vact_st = post_dsp_vact_end -
+				screen->post_ysize;
+		}
+		post_dsp_vact_st_f1 = 0;
+		post_dsp_vact_end_f1 = 0;
+	}
+	DBG(1, "post:xsize=%d,ysize=%d,xpos=%d",
+	    screen->post_xsize, screen->post_ysize, screen->xpos);
+	DBG(1, ",ypos=%d,hsd_en=%d,h_fac=%d,vsd_en=%d,v_fac=%d\n",
+	    screen->ypos, post_hsd_en, post_h_fac, post_vsd_en, post_v_fac);
+	val = V_DSP_HACT_END_POST(post_dsp_hact_end) |
+	    V_DSP_HACT_ST_POST(post_dsp_hact_st);
+	vop_msk_reg(vop_dev, POST_DSP_HACT_INFO, val);
+
+	val = V_DSP_VACT_END_POST(post_dsp_vact_end) |
+	    V_DSP_VACT_ST_POST(post_dsp_vact_st);
+	vop_msk_reg(vop_dev, POST_DSP_VACT_INFO, val);
+
+	val = V_POST_HS_FACTOR_YRGB(post_h_fac) |
+	    V_POST_VS_FACTOR_YRGB(post_v_fac);
+	vop_msk_reg(vop_dev, POST_SCL_FACTOR_YRGB, val);
+	val = V_DSP_VACT_END_POST(post_dsp_vact_end_f1) |
+	    V_DSP_VACT_ST_POST(post_dsp_vact_st_f1);
+	vop_msk_reg(vop_dev, POST_DSP_VACT_INFO_F1, val);
+	val = V_POST_HOR_SD_EN(post_hsd_en) | V_POST_VER_SD_EN(post_vsd_en);
+	vop_msk_reg(vop_dev, POST_SCL_CTRL, val);
+
+	vop_post_csc_cfg(dev_drv);
+
+	return 0;
+}
+
+static int vop_clr_key_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win;
+	u32 colorkey_r, colorkey_g, colorkey_b;
+	int i, key_val;
+
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		win = dev_drv->win[i];
+		key_val = win->color_key_val;
+		colorkey_r = (key_val & 0xff) << 2;
+		colorkey_g = ((key_val >> 8) & 0xff) << 12;
+		colorkey_b = ((key_val >> 16) & 0xff) << 22;
+		/* color key dither 565/888->aaa */
+		key_val = colorkey_r | colorkey_g | colorkey_b;
+		switch (i) {
+		case 0:
+			vop_writel(vop_dev, WIN0_COLOR_KEY, key_val);
+			break;
+		case 1:
+			vop_writel(vop_dev, WIN1_COLOR_KEY, key_val);
+			break;
+		case 2:
+			vop_writel(vop_dev, WIN2_COLOR_KEY, key_val);
+			break;
+		case 3:
+			vop_writel(vop_dev, WIN3_COLOR_KEY, key_val);
+			break;
+		default:
+			pr_info("%s:un support win num:%d\n",
+				__func__, i);
+			break;
+		}
+	}
+	return 0;
+}
+
+static int vop_alpha_cfg(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	struct alpha_config alpha_config;
+	u64 val;
+	int ppixel_alpha = 0, global_alpha = 0, i;
+	u32 src_alpha_ctl = 0, dst_alpha_ctl = 0;
+	int alpha_en = 1;
+
+	memset(&alpha_config, 0, sizeof(struct alpha_config));
+	for (i = 0; i < win->area_num; i++) {
+		ppixel_alpha |= ((win->area[i].format == ARGB888) ||
+				 (win->area[i].format == FBDC_ARGB_888) ||
+				 (win->area[i].format == FBDC_ABGR_888) ||
+				 (win->area[i].format == ABGR888)) ? 1 : 0;
+	}
+
+	global_alpha = (win->g_alpha_val == 0) ? 0 : 1;
+
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		if (!dev_drv->win[i]->state)
+			continue;
+		if (win->z_order > dev_drv->win[i]->z_order)
+			break;
+	}
+
+	/*
+	 * The bottom layer not support ppixel_alpha mode.
+	 */
+	if (i == dev_drv->lcdc_win_num)
+		ppixel_alpha = 0;
+	alpha_config.src_global_alpha_val = win->g_alpha_val;
+	win->alpha_mode = AB_SRC_OVER;
+
+	switch (win->alpha_mode) {
+	case AB_USER_DEFINE:
+		break;
+	case AB_CLEAR:
+		alpha_config.src_factor_mode = AA_ZERO;
+		alpha_config.dst_factor_mode = AA_ZERO;
+		break;
+	case AB_SRC:
+		alpha_config.src_factor_mode = AA_ONE;
+		alpha_config.dst_factor_mode = AA_ZERO;
+		break;
+	case AB_DST:
+		alpha_config.src_factor_mode = AA_ZERO;
+		alpha_config.dst_factor_mode = AA_ONE;
+		break;
+	case AB_SRC_OVER:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		if (global_alpha)
+			alpha_config.src_factor_mode = AA_SRC_GLOBAL;
+		else
+			alpha_config.src_factor_mode = AA_ONE;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	case AB_DST_OVER:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode = AA_ONE;
+		break;
+	case AB_SRC_IN:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC;
+		alpha_config.dst_factor_mode = AA_ZERO;
+		break;
+	case AB_DST_IN:
+		alpha_config.src_factor_mode = AA_ZERO;
+		alpha_config.dst_factor_mode = AA_SRC;
+		break;
+	case AB_SRC_OUT:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode = AA_ZERO;
+		break;
+	case AB_DST_OUT:
+		alpha_config.src_factor_mode = AA_ZERO;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	case AB_SRC_ATOP:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	case AB_DST_ATOP:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode = AA_SRC;
+		break;
+	case XOR:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	case AB_SRC_OVER_GLOBAL:
+		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
+		alpha_config.src_color_mode = AA_SRC_NO_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_GLOBAL;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	default:
+		pr_err("alpha mode error\n");
+		break;
+	}
+	if ((ppixel_alpha == 1) && (global_alpha == 1))
+		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
+	else if (ppixel_alpha == 1)
+		alpha_config.src_global_alpha_mode = AA_PER_PIX;
+	else if (global_alpha == 1)
+		alpha_config.src_global_alpha_mode = AA_GLOBAL;
+	else
+		alpha_en = 0;
+	alpha_config.src_alpha_mode = AA_STRAIGHT;
+	alpha_config.src_alpha_cal_m0 = AA_NO_SAT;
+
+	switch (win_id) {
+	case 0:
+		src_alpha_ctl = 0x60;
+		dst_alpha_ctl = 0x64;
+		break;
+	case 1:
+		src_alpha_ctl = 0xa0;
+		dst_alpha_ctl = 0xa4;
+		break;
+	case 2:
+		src_alpha_ctl = 0xdc;
+		dst_alpha_ctl = 0xec;
+		break;
+	case 3:
+		src_alpha_ctl = 0x12c;
+		dst_alpha_ctl = 0x13c;
+		break;
+	case 4:
+		src_alpha_ctl = 0x160;
+		dst_alpha_ctl = 0x164;
+		break;
+	}
+	val = V_WIN0_DST_FACTOR_MODE(alpha_config.dst_factor_mode);
+	vop_msk_reg(vop_dev, dst_alpha_ctl, val);
+	val = V_WIN0_SRC_ALPHA_EN(alpha_en) |
+	    V_WIN0_SRC_COLOR_MODE(alpha_config.src_color_mode) |
+	    V_WIN0_SRC_ALPHA_MODE(alpha_config.src_alpha_mode) |
+	    V_WIN0_SRC_BLEND_MODE(alpha_config.src_global_alpha_mode) |
+	    V_WIN0_SRC_ALPHA_CAL_MODE(alpha_config.src_alpha_cal_m0) |
+	    V_WIN0_SRC_FACTOR_MODE(alpha_config.src_factor_mode) |
+	    V_WIN0_SRC_GLOBAL_ALPHA(alpha_config.src_global_alpha_val);
+
+	vop_msk_reg(vop_dev, src_alpha_ctl, val);
+
+	return 0;
+}
+
+static int vop_axi_gather_cfg(struct vop_device *vop_dev,
+			      struct rk_lcdc_win *win)
+{
+	u64 val;
+	u16 yrgb_gather_num = 3;
+	u16 cbcr_gather_num = 1;
+
+	switch (win->area[0].format) {
+	case XRGB888:
+	case ARGB888:
+	case XBGR888:
+	case ABGR888:
+	case FBDC_ARGB_888:
+	case FBDC_RGBX_888:
+	case FBDC_ABGR_888:
+		yrgb_gather_num = 3;
+		break;
+	case RGB888:
+	case BGR888:
+	case RGB565:
+	case BGR565:
+	case FBDC_RGB_565:
+		yrgb_gather_num = 2;
+		break;
+	case YUV444:
+	case YUV422:
+	case YUV420:
+	case YUV420_A:
+	case YUV422_A:
+	case YUV444_A:
+	case YUV420_NV21:
+	case YUYV420:
+	case UYVY420:
+		yrgb_gather_num = 1;
+		cbcr_gather_num = 2;
+		break;
+	case YUYV422:
+	case UYVY422:
+		yrgb_gather_num = 2;
+		cbcr_gather_num = 2;
+		break;
+	default:
+		dev_err(vop_dev->driver.dev, "%s:un supported format[%d]\n",
+			__func__, win->area[0].format);
+		return -EINVAL;
+	}
+
+	if ((win->id == VOP_WIN0) || (win->id == VOP_WIN1)) {
+		val = V_WIN0_YRGB_AXI_GATHER_EN(1) |
+			V_WIN0_CBR_AXI_GATHER_EN(1) |
+			V_WIN0_YRGB_AXI_GATHER_NUM(yrgb_gather_num) |
+			V_WIN0_CBR_AXI_GATHER_NUM(cbcr_gather_num);
+		vop_msk_reg(vop_dev, WIN0_CTRL1 + (win->id * 0x40), val);
+	} else if ((win->id == VOP_WIN2) || (win->id == VOP_WIN3)) {
+		val = V_WIN2_AXI_GATHER_EN(1) |
+			V_WIN2_AXI_GATHER_NUM(yrgb_gather_num);
+		vop_msk_reg(vop_dev, WIN2_CTRL1 + ((win->id - 2) * 0x50), val);
+	} else if (win->id == VOP_HWC) {
+		val = V_HWC_AXI_GATHER_EN(1) |
+			V_HWC_AXI_GATHER_NUM(yrgb_gather_num);
+		vop_msk_reg(vop_dev, HWC_CTRL1, val);
+	}
+	return 0;
+}
+
+static int vop_fbdc_reg_update(struct vop_device *vop_dev, int win_id)
+{
+	struct rk_lcdc_win *win = vop_dev->driver.win[win_id];
+	u64 val;
+
+	val = V_VOP_FBDC_WIN_SEL(win_id) |
+		V_AFBCD_HREG_PIXEL_PACKING_FMT(win->area[0].fbdc_fmt_cfg) |
+		V_AFBCD_HREG_BLOCK_SPLIT(win->area[0].fbdc_cor_en);
+	vop_msk_reg(vop_dev, AFBCD0_CTRL, val);
+
+	val = V_AFBCD_HREG_PIC_WIDTH(win->area[0].fbdc_mb_width - 1) |
+		V_AFBCD_HREG_PIC_HEIGHT(win->area[0].fbdc_mb_height - 1);
+	vop_msk_reg(vop_dev, AFBCD0_PIC_SIZE, val);
+
+	return 0;
+}
+
+static int vop_init_fbdc_config(struct vop_device *vop_dev, int win_id)
+{
+	struct rk_lcdc_driver *vop_drv = &vop_dev->driver;
+	struct rk_lcdc_win *win = vop_drv->win[win_id];
+	struct rk_screen *screen = vop_drv->cur_screen;
+
+	if (screen->mode.flag & FB_VMODE_INTERLACED) {
+		dev_err(vop_dev->dev, "unsupport fbdc+interlace!\n");
+		return 0;
+	}
+
+	if (VOP_CHIP(vop_dev) != VOP_RK3399) {
+		pr_err("soc: 0x%08x not support FBDC\n", VOP_CHIP(vop_dev));
+		return 0;
+	}
+
+	win->area[0].fbdc_mb_width = win->area[0].xvir;
+	win->area[0].fbdc_mb_height = win->area[0].yact;
+	win->area[0].fbdc_cor_en = 0; /* hreg_block_split */
+	win->area[0].fbdc_fmt_cfg |= AFBDC_YUV_COLOR_TRANSFORM << 4;
+
+	return 0;
+}
+
+static int vop_win_0_1_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	u64 val;
+	u32 off;
+	int format;
+	struct rk_win_property *win_property =
+				&dev_drv->win[win_id]->property;
+
+	off = win_id * 0x40;
+
+	if (win->state == 1) {
+		if (!(win_property->feature & SUPPORT_HW_EXIST)) {
+			pr_err("vop[%d] win[%d] hardware unsupport\n",
+			       vop_dev->id, win_id);
+			return 0;
+		}
+		vop_axi_gather_cfg(vop_dev, win);
+		if (win->area[0].fbdc_en)
+			vop_fbdc_reg_update(vop_dev, win_id);
+		/*
+		 * rk322x have a bug on windows 0 and 1:
+		 *
+		 * When switch win format from RGB to YUV, would flash
+		 * some green lines on the top of the windows.
+		 *
+		 * Use bg_en show one blank frame to skip the error frame.
+		 */
+		if (IS_YUV(win->area[0].fmt_cfg)) {
+			val = vop_readl(vop_dev, WIN0_CTRL0);
+			format = (val & MASK(WIN0_DATA_FMT)) >> 1;
+
+			if (!IS_YUV(format)) {
+				if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
+					val = V_WIN0_DSP_BG_RED(0x200) |
+						V_WIN0_DSP_BG_GREEN(0x40) |
+						V_WIN0_DSP_BG_BLUE(0x200) |
+						V_WIN0_BG_EN(1);
+					vop_msk_reg(vop_dev, WIN0_DSP_BG + off,
+						    val);
+				} else {
+					val = V_WIN0_DSP_BG_RED(0) |
+						V_WIN0_DSP_BG_GREEN(0) |
+						V_WIN0_DSP_BG_BLUE(0) |
+						V_WIN0_BG_EN(1);
+					vop_msk_reg(vop_dev, WIN0_DSP_BG + off,
+						    val);
+				}
+			} else {
+				val = V_WIN0_BG_EN(0);
+				vop_msk_reg(vop_dev, WIN0_DSP_BG + off, val);
+			}
+		} else {
+			val = V_WIN0_BG_EN(0);
+			vop_msk_reg(vop_dev, WIN0_DSP_BG + off, val);
+		}
+
+		val = V_WIN0_EN(win->state) |
+			V_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
+			V_WIN0_FMT_10(win->fmt_10) |
+			V_WIN0_LB_MODE(win->win_lb_mode) |
+			V_WIN0_RB_SWAP(win->area[0].swap_rb) |
+			V_WIN0_X_MIR_EN(win->xmirror) |
+			V_WIN0_Y_MIR_EN(win->ymirror) |
+			V_WIN0_UV_SWAP(win->area[0].swap_uv);
+		if (VOP_CHIP(vop_dev) == VOP_RK3399)
+			val |= V_WIN0_YUYV(win->area[0].yuyv_fmt);
+		vop_msk_reg(vop_dev, WIN0_CTRL0 + off, val);
+		val = V_WIN0_BIC_COE_SEL(win->bic_coe_el) |
+		    V_WIN0_VSD_YRGB_GT4(win->vsd_yrgb_gt4) |
+		    V_WIN0_VSD_YRGB_GT2(win->vsd_yrgb_gt2) |
+		    V_WIN0_VSD_CBR_GT4(win->vsd_cbr_gt4) |
+		    V_WIN0_VSD_CBR_GT2(win->vsd_cbr_gt2) |
+		    V_WIN0_YRGB_HOR_SCL_MODE(win->yrgb_hor_scl_mode) |
+		    V_WIN0_YRGB_VER_SCL_MODE(win->yrgb_ver_scl_mode) |
+		    V_WIN0_YRGB_HSD_MODE(win->yrgb_hsd_mode) |
+		    V_WIN0_YRGB_VSU_MODE(win->yrgb_vsu_mode) |
+		    V_WIN0_YRGB_VSD_MODE(win->yrgb_vsd_mode) |
+		    V_WIN0_CBR_HOR_SCL_MODE(win->cbr_hor_scl_mode) |
+		    V_WIN0_CBR_VER_SCL_MODE(win->cbr_ver_scl_mode) |
+		    V_WIN0_CBR_HSD_MODE(win->cbr_hsd_mode) |
+		    V_WIN0_CBR_VSU_MODE(win->cbr_vsu_mode) |
+		    V_WIN0_CBR_VSD_MODE(win->cbr_vsd_mode);
+		vop_msk_reg(vop_dev, WIN0_CTRL1 + off, val);
+		val = V_WIN0_VIR_STRIDE(win->area[0].y_vir_stride) |
+		    V_WIN0_VIR_STRIDE_UV(win->area[0].uv_vir_stride);
+		vop_writel(vop_dev, WIN0_VIR + off, val);
+		val = V_WIN0_ACT_WIDTH(win->area[0].xact - 1) |
+		    V_WIN0_ACT_HEIGHT(win->area[0].yact - 1);
+		vop_writel(vop_dev, WIN0_ACT_INFO + off, val);
+
+		val = V_WIN0_DSP_WIDTH(win->area[0].xsize - 1) |
+		    V_WIN0_DSP_HEIGHT(win->area[0].ysize - 1);
+		vop_writel(vop_dev, WIN0_DSP_INFO + off, val);
+
+		val = V_WIN0_DSP_XST(win->area[0].dsp_stx) |
+		    V_WIN0_DSP_YST(win->area[0].dsp_sty);
+		vop_writel(vop_dev, WIN0_DSP_ST + off, val);
+
+		val = V_WIN0_HS_FACTOR_YRGB(win->scale_yrgb_x) |
+		    V_WIN0_VS_FACTOR_YRGB(win->scale_yrgb_y);
+		vop_writel(vop_dev, WIN0_SCL_FACTOR_YRGB + off, val);
+
+		val = V_WIN0_HS_FACTOR_CBR(win->scale_cbcr_x) |
+		    V_WIN0_VS_FACTOR_CBR(win->scale_cbcr_y);
+		vop_writel(vop_dev, WIN0_SCL_FACTOR_CBR + off, val);
+	} else {
+		val = V_WIN0_EN(win->state);
+		vop_msk_reg(vop_dev, WIN0_CTRL0 + off, val);
+	}
+
+	return 0;
+}
+
+static int area_xst(struct rk_lcdc_win *win, int area_num)
+{
+	struct rk_lcdc_win_area area_temp;
+	int i, j;
+
+	for (i = 0; i < area_num; i++) {
+		for (j = i + 1; j < area_num; j++) {
+			if (win->area[i].dsp_stx >  win->area[j].dsp_stx) {
+				memcpy(&area_temp, &win->area[i],
+				       sizeof(struct rk_lcdc_win_area));
+				memcpy(&win->area[i], &win->area[j],
+				       sizeof(struct rk_lcdc_win_area));
+				memcpy(&win->area[j], &area_temp,
+				       sizeof(struct rk_lcdc_win_area));
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int vop_win_2_3_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	unsigned int off;
+	u64 val;
+	struct rk_win_property *win_property =
+				&dev_drv->win[win_id]->property;
+
+	off = (win_id - 2) * 0x50;
+	area_xst(win, win->area_num);
+
+	if (win->state == 1) {
+		if (!(win_property->feature & SUPPORT_HW_EXIST)) {
+			pr_err("vop[%d] win[%d] hardware unsupport\n",
+			       vop_dev->id, win_id);
+			return 0;
+		}
+		vop_axi_gather_cfg(vop_dev, win);
+		if (win->area[0].fbdc_en)
+			vop_fbdc_reg_update(vop_dev, win_id);
+		val = V_WIN2_EN(1) | V_WIN1_CSC_MODE(win->csc_mode);
+		vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+		/* area 0 */
+		if (win->area[0].state == 1) {
+			val = V_WIN2_MST0_EN(win->area[0].state) |
+			    V_WIN2_DATA_FMT0(win->area[0].fmt_cfg) |
+			    V_WIN2_RB_SWAP0(win->area[0].swap_rb);
+			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+
+			val = V_WIN2_VIR_STRIDE0(win->area[0].y_vir_stride);
+			vop_msk_reg(vop_dev, WIN2_VIR0_1 + off, val);
+
+			val = V_WIN2_DSP_WIDTH0(win->area[0].xsize - 1) |
+			    V_WIN2_DSP_HEIGHT0(win->area[0].ysize - 1);
+			vop_writel(vop_dev, WIN2_DSP_INFO0 + off, val);
+			val = V_WIN2_DSP_XST0(win->area[0].dsp_stx) |
+			    V_WIN2_DSP_YST0(win->area[0].dsp_sty);
+			vop_writel(vop_dev, WIN2_DSP_ST0 + off, val);
+		} else {
+			val = V_WIN2_MST0_EN(0);
+			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+		}
+		/* area 1 */
+		if (win->area[1].state == 1) {
+			val = V_WIN2_MST1_EN(win->area[1].state) |
+			    V_WIN2_DATA_FMT1(win->area[1].fmt_cfg) |
+			    V_WIN2_RB_SWAP1(win->area[1].swap_rb);
+			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+
+			val = V_WIN2_VIR_STRIDE1(win->area[1].y_vir_stride);
+			vop_msk_reg(vop_dev, WIN2_VIR0_1 + off, val);
+
+			val = V_WIN2_DSP_WIDTH1(win->area[1].xsize - 1) |
+			    V_WIN2_DSP_HEIGHT1(win->area[1].ysize - 1);
+			vop_writel(vop_dev, WIN2_DSP_INFO1 + off, val);
+			val = V_WIN2_DSP_XST1(win->area[1].dsp_stx) |
+			    V_WIN2_DSP_YST1(win->area[1].dsp_sty);
+			vop_writel(vop_dev, WIN2_DSP_ST1 + off, val);
+		} else {
+			val = V_WIN2_MST1_EN(0);
+			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+		}
+		/* area 2 */
+		if (win->area[2].state == 1) {
+			val = V_WIN2_MST2_EN(win->area[2].state) |
+			    V_WIN2_DATA_FMT2(win->area[2].fmt_cfg) |
+			    V_WIN2_RB_SWAP2(win->area[2].swap_rb);
+			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+
+			val = V_WIN2_VIR_STRIDE2(win->area[2].y_vir_stride);
+			vop_msk_reg(vop_dev, WIN2_VIR2_3 + off, val);
+
+			val = V_WIN2_DSP_WIDTH2(win->area[2].xsize - 1) |
+			    V_WIN2_DSP_HEIGHT2(win->area[2].ysize - 1);
+			vop_writel(vop_dev, WIN2_DSP_INFO2 + off, val);
+			val = V_WIN2_DSP_XST2(win->area[2].dsp_stx) |
+			    V_WIN2_DSP_YST2(win->area[2].dsp_sty);
+			vop_writel(vop_dev, WIN2_DSP_ST2 + off, val);
+		} else {
+			val = V_WIN2_MST2_EN(0);
+			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+		}
+		/* area 3 */
+		if (win->area[3].state == 1) {
+			val = V_WIN2_MST3_EN(win->area[3].state) |
+			    V_WIN2_DATA_FMT3(win->area[3].fmt_cfg) |
+			    V_WIN2_RB_SWAP3(win->area[3].swap_rb);
+			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+
+			val = V_WIN2_VIR_STRIDE3(win->area[3].y_vir_stride);
+			vop_msk_reg(vop_dev, WIN2_VIR2_3 + off, val);
+
+			val = V_WIN2_DSP_WIDTH3(win->area[3].xsize - 1) |
+			    V_WIN2_DSP_HEIGHT3(win->area[3].ysize - 1);
+			vop_writel(vop_dev, WIN2_DSP_INFO3 + off, val);
+			val = V_WIN2_DSP_XST3(win->area[3].dsp_stx) |
+			    V_WIN2_DSP_YST3(win->area[3].dsp_sty);
+			vop_writel(vop_dev, WIN2_DSP_ST3 + off, val);
+		} else {
+			val = V_WIN2_MST3_EN(0);
+			vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+		}
+	} else {
+		val = V_WIN2_EN(win->state) | V_WIN2_MST0_EN(0) |
+		    V_WIN2_MST1_EN(0) | V_WIN2_MST2_EN(0) | V_WIN2_MST3_EN(0);
+		vop_msk_reg(vop_dev, WIN2_CTRL0 + off, val);
+	}
+
+	return 0;
+}
+
+static int vop_hwc_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	unsigned int hwc_size = 0;
+	u64 val;
+
+	if ((win->area[0].xsize == 32) && (win->area[0].ysize == 32)) {
+		hwc_size = 0;
+	} else if ((win->area[0].xsize == 64) && (win->area[0].ysize == 64)) {
+		hwc_size = 1;
+	} else if ((win->area[0].xsize == 96) && (win->area[0].ysize == 96)) {
+		hwc_size = 2;
+	} else if ((win->area[0].xsize == 128) &&
+		   (win->area[0].ysize == 128)) {
+		hwc_size = 3;
+	} else {
+		dev_err(vop_dev->dev, "un supported hwc size[%dx%d]!\n",
+				win->area[0].xsize, win->area[0].ysize);
+		return -EINVAL;
+	}
+
+	if (win->state == 1) {
+		vop_axi_gather_cfg(vop_dev, win);
+		val = V_HWC_EN(1) | V_HWC_DATA_FMT(win->area[0].fmt_cfg) |
+		    V_HWC_RB_SWAP(win->area[0].swap_rb);
+		vop_msk_reg(vop_dev, HWC_CTRL0, val);
+
+		val = V_HWC_SIZE(hwc_size);
+		vop_msk_reg(vop_dev, HWC_CTRL0, val);
+
+		val = V_HWC_DSP_XST(win->area[0].dsp_stx) |
+		    V_HWC_DSP_YST(win->area[0].dsp_sty);
+		vop_msk_reg(vop_dev, HWC_DSP_ST, val);
+	} else {
+		val = V_HWC_EN(win->state);
+		vop_msk_reg(vop_dev, HWC_CTRL0, val);
+	}
+
+	return 0;
+}
+
+static int vop_layer_update_regs(struct vop_device *vop_dev,
+				 struct rk_lcdc_win *win)
+{
+	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
+
+	if (likely(vop_dev->clk_on)) {
+		vop_msk_reg(vop_dev, SYS_CTRL,
+			    V_VOP_STANDBY_EN(vop_dev->standby));
+		if ((win->id == VOP_WIN0) || (win->id == VOP_WIN1))
+			vop_win_0_1_reg_update(dev_drv, win->id);
+		else if ((win->id == VOP_WIN2) || (win->id == VOP_WIN3))
+			vop_win_2_3_reg_update(dev_drv, win->id);
+		else if (win->id == VOP_HWC)
+			vop_hwc_reg_update(dev_drv, win->id);
+		vop_cfg_done(vop_dev);
+	}
+
+	DBG(2, "%s for lcdc%d\n", __func__, vop_dev->id);
+	return 0;
+}
+
+static int __maybe_unused vop_mmu_en(struct rk_lcdc_driver *dev_drv)
+{
+	u64 val;
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+	if (dev_drv->iommu_enabled) {
+		if (!vop_dev->iommu_status && dev_drv->mmu_dev) {
+			if (likely(vop_dev->clk_on)) {
+				val = V_VOP_MMU_EN(1);
+				vop_msk_reg(vop_dev, SYS_CTRL, val);
+				val = V_AXI_OUTSTANDING_MAX_NUM(31) |
+					V_AXI_MAX_OUTSTANDING_EN(1);
+				vop_msk_reg(vop_dev, SYS_CTRL1, val);
+			}
+			vop_dev->iommu_status = 1;
+			rockchip_iovmm_activate(dev_drv->dev);
+		}
+	}
+	return 0;
+}
+
+static int vop_set_dclk(struct rk_lcdc_driver *dev_drv, int reset_rate)
+{
+	int ret = 0, fps = 0;
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+#ifdef CONFIG_RK_FPGA
+	return 0;
+#endif
+	if (reset_rate)
+		ret = clk_set_rate(vop_dev->dclk, screen->mode.pixclock);
+	if (ret)
+		dev_err(dev_drv->dev, "set lcdc%d dclk[%d] failed\n",
+			vop_dev->id, screen->mode.pixclock);
+	vop_dev->pixclock =
+	    div_u64(1000000000000llu, clk_get_rate(vop_dev->dclk));
+	vop_dev->driver.pixclock = vop_dev->pixclock;
+
+	fps = rk_fb_calc_fps(screen, vop_dev->pixclock);
+	screen->ft = 1000 / fps;
+	dev_info(vop_dev->dev, "%s: dclk:%lu>>fps:%d ",
+		 vop_dev->driver.name, clk_get_rate(vop_dev->dclk), fps);
+	return 0;
+}
+
+static int vop_config_timing(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 hsync_len = screen->mode.hsync_len;
+	u16 left_margin = screen->mode.left_margin;
+	u16 right_margin = screen->mode.right_margin;
+	u16 vsync_len = screen->mode.vsync_len;
+	u16 upper_margin = screen->mode.upper_margin;
+	u16 lower_margin = screen->mode.lower_margin;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u64 val;
+	u16 h_total, v_total;
+	u16 vact_end_f1, vact_st_f1, vs_end_f1, vs_st_f1;
+
+	h_total = hsync_len + left_margin + x_res + right_margin;
+	v_total = vsync_len + upper_margin + y_res + lower_margin;
+
+	val = V_DSP_HS_END(hsync_len) | V_DSP_HTOTAL(h_total);
+	vop_msk_reg(vop_dev, DSP_HTOTAL_HS_END, val);
+
+	val = V_DSP_HACT_END(hsync_len + left_margin + x_res) |
+	    V_DSP_HACT_ST(hsync_len + left_margin);
+	vop_msk_reg(vop_dev, DSP_HACT_ST_END, val);
+
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		/* First Field Timing */
+		val = V_DSP_VS_END(vsync_len) |
+		    V_DSP_VTOTAL(2 * (vsync_len + upper_margin +
+				      lower_margin) + y_res + 1);
+		vop_msk_reg(vop_dev, DSP_VTOTAL_VS_END, val);
+
+		val = V_DSP_VACT_END(vsync_len + upper_margin + y_res / 2) |
+		    V_DSP_VACT_ST(vsync_len + upper_margin);
+		vop_msk_reg(vop_dev, DSP_VACT_ST_END, val);
+
+		/* Second Field Timing */
+		vs_st_f1 = vsync_len + upper_margin + y_res / 2 + lower_margin;
+		vs_end_f1 = 2 * vsync_len + upper_margin + y_res / 2 +
+		    lower_margin;
+		val = V_DSP_VS_ST_F1(vs_st_f1) | V_DSP_VS_END_F1(vs_end_f1);
+		vop_msk_reg(vop_dev, DSP_VS_ST_END_F1, val);
+
+		vact_end_f1 = 2 * (vsync_len + upper_margin) + y_res +
+		    lower_margin + 1;
+		vact_st_f1 = 2 * (vsync_len + upper_margin) + y_res / 2 +
+		    lower_margin + 1;
+		val = V_DSP_VACT_END_F1(vact_end_f1) |
+			V_DSP_VACT_ST_F1(vact_st_f1);
+		vop_msk_reg(vop_dev, DSP_VACT_ST_END_F1, val);
+		vop_msk_reg(vop_dev, DSP_CTRL0,
+			    V_DSP_INTERLACE(1) | V_DSP_FIELD_POL(0));
+
+		val = V_DSP_LINE_FLAG_NUM_0(lower_margin ?
+					    vact_end_f1 : vact_end_f1 - 1);
+
+		val |= V_DSP_LINE_FLAG_NUM_1(lower_margin ?
+					     vact_end_f1 : vact_end_f1 - 1);
+		vop_msk_reg(vop_dev, LINE_FLAG, val);
+	} else {
+		val = V_DSP_VS_END(vsync_len) | V_DSP_VTOTAL(v_total);
+		vop_msk_reg(vop_dev, DSP_VTOTAL_VS_END, val);
+
+		val = V_DSP_VACT_END(vsync_len + upper_margin + y_res) |
+		    V_DSP_VACT_ST(vsync_len + upper_margin);
+		vop_msk_reg(vop_dev, DSP_VACT_ST_END, val);
+
+		vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_INTERLACE(0) |
+			    V_DSP_FIELD_POL(0));
+
+		val = V_DSP_LINE_FLAG_NUM_0(vsync_len + upper_margin + y_res) |
+			V_DSP_LINE_FLAG_NUM_1(vsync_len + upper_margin + y_res);
+		vop_msk_reg(vop_dev, LINE_FLAG, val);
+	}
+	vop_post_cfg(dev_drv);
+	if ((x_res <= VOP_INPUT_MAX_WIDTH / 2) && (vop_dev->id == 0))
+		vop_msk_reg(vop_dev, SYS_CTRL, V_POST_LB_MODE(1));
+	else
+		vop_msk_reg(vop_dev, SYS_CTRL, V_POST_LB_MODE(0));
+
+	return 0;
+}
+
+static void vop_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	u32 bcsh_ctrl;
+
+	vop_msk_reg(vop_dev, SYS_CTRL, V_OVERLAY_MODE(dev_drv->overlay_mode));
+	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
+		if (IS_YUV_COLOR(dev_drv->output_color))	/* bypass */
+			vop_msk_reg(vop_dev, BCSH_CTRL,
+				    V_BCSH_Y2R_EN(0) | V_BCSH_R2Y_EN(0));
+		else		/* YUV2RGB */
+			vop_msk_reg(vop_dev, BCSH_CTRL, V_BCSH_Y2R_EN(1) |
+				    V_BCSH_Y2R_CSC_MODE(VOP_Y2R_CSC_MPEG) |
+				    V_BCSH_R2Y_EN(0));
+	} else {
+		/* overlay_mode=VOP_RGB_DOMAIN */
+		/* bypass  --need check,if bcsh close? */
+		if (dev_drv->output_color == COLOR_RGB) {
+			bcsh_ctrl = vop_readl(vop_dev, BCSH_CTRL);
+			if (((bcsh_ctrl & MASK(BCSH_EN)) == 1) ||
+			    (dev_drv->bcsh.enable == 1))/*bcsh enabled */
+				vop_msk_reg(vop_dev, BCSH_CTRL,
+					    V_BCSH_R2Y_EN(1) |
+					    V_BCSH_Y2R_EN(1));
+			else
+				vop_msk_reg(vop_dev, BCSH_CTRL,
+					    V_BCSH_R2Y_EN(0) |
+					    V_BCSH_Y2R_EN(0));
+		} else {
+			/* RGB2YUV */
+			vop_msk_reg(vop_dev, BCSH_CTRL,
+				    V_BCSH_R2Y_EN(1) |
+				    V_BCSH_R2Y_CSC_MODE(VOP_Y2R_CSC_MPEG) |
+				    V_BCSH_Y2R_EN(0));
+		}
+	}
+}
+
+static int vop_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
+			       u16 *yact, int *format, u32 *dsp_addr,
+			       int *ymirror)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	u32 val;
+
+	spin_lock(&vop_dev->reg_lock);
+
+	val = vop_readl(vop_dev, WIN0_ACT_INFO);
+	*xact = (val & MASK(WIN0_ACT_WIDTH)) + 1;
+	*yact = ((val & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
+
+	val = vop_readl(vop_dev, WIN0_CTRL0);
+	*format = (val & MASK(WIN0_DATA_FMT)) >> 1;
+	*ymirror = (val & MASK(WIN0_Y_MIR_EN)) >> 22;
+	*dsp_addr = vop_readl(vop_dev, WIN0_YRGB_MST);
+
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
+			   int format, u16 xact, u16 yact, u16 xvir,
+			   int ymirror)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	int swap = (format == RGB888) ? 1 : 0;
+	struct rk_lcdc_win *win = dev_drv->win[0];
+	u64 val;
+
+	val = V_WIN0_DATA_FMT(format) | V_WIN0_RB_SWAP(swap) |
+		V_WIN0_Y_MIR_EN(ymirror);
+	vop_msk_reg(vop_dev, WIN0_CTRL0, val);
+
+	vop_msk_reg(vop_dev, WIN0_VIR, V_WIN0_VIR_STRIDE(xvir));
+	vop_writel(vop_dev, WIN0_ACT_INFO, V_WIN0_ACT_WIDTH(xact - 1) |
+		   V_WIN0_ACT_HEIGHT(yact - 1));
+
+	vop_writel(vop_dev, WIN0_YRGB_MST, rgb_mst);
+
+	vop_cfg_done(vop_dev);
+
+	if (format == RGB888)
+		win->area[0].format = BGR888;
+	else
+		win->area[0].format = format;
+
+	win->ymirror = ymirror;
+	win->state = 1;
+	win->last_state = 1;
+
+	return 0;
+}
+
+static int vop_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
+{
+	u16 face = 0;
+	u16 dclk_ddr = 0;
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 val = 0;
+
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+
+	if (!vop_dev->standby && initscreen && (dev_drv->first_frame != 1))
+		flush_kthread_worker(&dev_drv->update_regs_worker);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		switch (screen->face) {
+		case OUT_P565:
+			face = OUT_P565;
+			val = V_DITHER_DOWN_EN(1) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(1) | V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_P666:
+			face = OUT_P666;
+			val = V_DITHER_DOWN_EN(1) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(1) | V_DITHER_DOWN_MODE(1);
+			break;
+		case OUT_D888_P565:
+			face = OUT_P888;
+			val = V_DITHER_DOWN_EN(1) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(1) | V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_D888_P666:
+			face = OUT_P888;
+			val = V_DITHER_DOWN_EN(1) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(1) | V_DITHER_DOWN_MODE(1);
+			break;
+		case OUT_P888:
+			face = OUT_P888;
+			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1)
+				| V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(0) | V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_S888x:
+			face = OUT_S888x;
+			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1)
+				| V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(0) | V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_S888:
+			face = OUT_S888;
+			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1)
+				| V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(0) | V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_YUV_420:
+			face = OUT_YUV_420;
+			dclk_ddr = 1;
+			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(0) |
+				V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_YUV_420_10BIT:
+			face = OUT_YUV_420;
+			dclk_ddr = 1;
+			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(0) |
+				V_DITHER_DOWN_SEL(0) |
+				V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_YUV_422:
+			face = OUT_YUV_422;
+			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(1) |
+				V_DITHER_DOWN_SEL(0) |
+				V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_YUV_422_10BIT:
+			face = OUT_YUV_422;
+			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(0) |
+				V_DITHER_DOWN_SEL(0) |
+				V_DITHER_DOWN_MODE(0);
+			break;
+		case OUT_P101010:
+			face = OUT_P101010;
+			val = V_DITHER_DOWN_EN(0) | V_DITHER_UP_EN(1) |
+				V_PRE_DITHER_DOWN_EN(0) |
+				V_DITHER_DOWN_SEL(0) |
+				V_DITHER_DOWN_MODE(0);
+			break;
+		default:
+			dev_err(vop_dev->dev, "un supported screen face[%d]!\n",
+				screen->face);
+			break;
+		}
+
+		vop_msk_reg(vop_dev, DSP_CTRL1, val);
+		switch (screen->type) {
+		case SCREEN_TVOUT:
+			val = V_SW_UV_OFFSET_EN(1) | V_SW_IMD_TVE_DCLK_EN(1) |
+				V_SW_IMD_TVE_DCLK_EN(1) |
+				V_SW_IMD_TVE_DCLK_POL(1) |
+				V_SW_GENLOCK(1) | V_SW_DAC_SEL(1);
+			if (screen->mode.xres == 720 &&
+			    screen->mode.yres == 576)
+				val |= V_SW_TVE_MODE(1);
+			else
+				val |= V_SW_TVE_MODE(0);
+			vop_msk_reg(vop_dev, SYS_CTRL, val);
+			break;
+		case SCREEN_HDMI:
+			if ((VOP_CHIP(vop_dev) == VOP_RK3399) &&
+			    ((screen->face == OUT_P888) ||
+			     (screen->face == OUT_P101010))) {
+				if (vop_dev->id == 0)
+					face = OUT_P101010; /*RGB 10bit output*/
+				else
+					face = OUT_P888;
+			}
+			val = V_HDMI_OUT_EN(1) | V_SW_UV_OFFSET_EN(0);
+			vop_msk_reg(vop_dev, SYS_CTRL, val);
+			val = V_HDMI_HSYNC_POL(screen->pin_hsync) |
+				V_HDMI_VSYNC_POL(screen->pin_vsync) |
+				V_HDMI_DEN_POL(screen->pin_den) |
+				V_HDMI_DCLK_POL(screen->pin_dclk);
+			/*hsync vsync den dclk polo,dither */
+			vop_msk_reg(vop_dev, DSP_CTRL1, val);
+			break;
+		case SCREEN_RGB:
+		case SCREEN_LVDS:
+			val = V_RGB_OUT_EN(1);
+			vop_msk_reg(vop_dev, SYS_CTRL, val);
+			break;
+		case SCREEN_MIPI:
+			val = V_MIPI_OUT_EN(1);
+			vop_msk_reg(vop_dev, SYS_CTRL, val);
+			val = V_MIPI_HSYNC_POL(screen->pin_hsync) |
+				V_MIPI_VSYNC_POL(screen->pin_vsync) |
+				V_MIPI_DEN_POL(screen->pin_den) |
+				V_MIPI_DCLK_POL(screen->pin_dclk);
+			/*hsync vsync den dclk polo,dither */
+			vop_msk_reg(vop_dev, DSP_CTRL1, val);
+			break;
+		case SCREEN_DUAL_MIPI:
+			val = V_MIPI_OUT_EN(1) | V_MIPI_DUAL_CHANNEL_EN(1);
+			vop_msk_reg(vop_dev, SYS_CTRL, val);
+			val = V_MIPI_HSYNC_POL(screen->pin_hsync) |
+				V_MIPI_VSYNC_POL(screen->pin_vsync) |
+				V_MIPI_DEN_POL(screen->pin_den) |
+				V_MIPI_DCLK_POL(screen->pin_dclk);
+			/*hsync vsync den dclk polo,dither */
+			vop_msk_reg(vop_dev, DSP_CTRL1, val);
+			break;
+		case SCREEN_EDP:
+			if (VOP_CHIP(vop_dev) == VOP_RK3399) {
+				if (vop_dev->id == 0)
+					face = OUT_P101010;
+				else
+					face = OUT_P888;
+			}
+			val = V_EDP_OUT_EN(1);
+			vop_msk_reg(vop_dev, SYS_CTRL, val);
+			val = V_EDP_HSYNC_POL(screen->pin_hsync) |
+				V_EDP_VSYNC_POL(screen->pin_vsync) |
+				V_EDP_DEN_POL(screen->pin_den) |
+				V_EDP_DCLK_POL(screen->pin_dclk);
+			/*hsync vsync den dclk polo,dither */
+			vop_msk_reg(vop_dev, DSP_CTRL1, val);
+			break;
+		case SCREEN_DP:
+			dclk_ddr = 0;
+			if ((VOP_CHIP(vop_dev) == VOP_RK3399) &&
+			    ((screen->face == OUT_P888) ||
+			     (screen->face == OUT_P101010))) {
+				if (vop_dev->id == 0)
+					face = OUT_P101010;
+				else
+					face = OUT_P888;
+			}
+			val = V_DP_OUT_EN(1);
+			vop_msk_reg(vop_dev, SYS_CTRL, val);
+			val = V_DP_HSYNC_POL(screen->pin_hsync) |
+				V_DP_VSYNC_POL(screen->pin_vsync) |
+				V_DP_DEN_POL(screen->pin_den) |
+				V_DP_DCLK_POL(screen->pin_dclk);
+			/*hsync vsync den dclk polo,dither */
+			vop_msk_reg(vop_dev, DSP_CTRL1, val);
+			break;
+		default:
+			dev_err(vop_dev->dev, "un supported interface[%d]!\n",
+				screen->type);
+			break;
+		}
+
+		if (screen->color_mode == COLOR_RGB)
+			dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+		else
+			dev_drv->overlay_mode = VOP_YUV_DOMAIN;
+
+#ifndef CONFIG_RK_FPGA
+		/*
+		 * Todo:
+		 * writel_relaxed(v, RK_GRF_VIRT + vop_GRF_SOC_CON7);
+		 *  move to  lvds driver
+		 */
+		/*GRF_SOC_CON7 bit[15]:0->dsi/lvds mode,1->ttl mode */
+#endif
+		val = V_DSP_OUT_MODE(face) | V_DSP_DCLK_DDR(dclk_ddr) |
+		    V_DSP_BG_SWAP(screen->swap_gb) |
+		    V_DSP_RB_SWAP(screen->swap_rb) |
+		    V_DSP_RG_SWAP(screen->swap_rg) |
+		    V_DSP_DELTA_SWAP(screen->swap_delta) |
+		    V_DSP_DUMMY_SWAP(screen->swap_dumy) | V_DSP_OUT_ZERO(0) |
+		    V_DSP_BLANK_EN(0) | V_DSP_BLACK_EN(0) |
+		    V_DSP_X_MIR_EN(screen->x_mirror) |
+		    V_DSP_Y_MIR_EN(screen->y_mirror);
+		val |= V_SW_CORE_DCLK_SEL(!!screen->pixelrepeat);
+		if (screen->mode.vmode & FB_VMODE_INTERLACED)
+			val |= V_SW_HDMI_CLK_I_SEL(1);
+		else
+			val |= V_SW_HDMI_CLK_I_SEL(0);
+		vop_msk_reg(vop_dev, DSP_CTRL0, val);
+
+		if (screen->mode.vmode & FB_VMODE_INTERLACED)
+			vop_msk_reg(vop_dev, SYS_CTRL1, V_REG_DONE_FRM(1));
+		else
+			vop_msk_reg(vop_dev, SYS_CTRL1, V_REG_DONE_FRM(0));
+		/* BG color */
+		if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
+			val = V_DSP_OUT_RGB_YUV(1);
+			vop_msk_reg(vop_dev, POST_SCL_CTRL, val);
+			val = V_DSP_BG_BLUE(0x200) | V_DSP_BG_GREEN(0x40) |
+				V_DSP_BG_RED(0x200);
+			vop_msk_reg(vop_dev, DSP_BG, val);
+		} else {
+			val = V_DSP_OUT_RGB_YUV(0);
+			vop_msk_reg(vop_dev, POST_SCL_CTRL, val);
+			val = V_DSP_BG_BLUE(0x55) | V_DSP_BG_GREEN(0x55) |
+				V_DSP_BG_RED(0x55);
+			vop_msk_reg(vop_dev, DSP_BG, val);
+		}
+		dev_drv->output_color = screen->color_mode;
+		vop_bcsh_path_sel(dev_drv);
+		vop_config_timing(dev_drv);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	vop_set_dclk(dev_drv, 1);
+	if (screen->type != SCREEN_HDMI && screen->type != SCREEN_TVOUT &&
+	    dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	if (screen->init)
+		screen->init();
+
+	return 0;
+}
+
+static int vop_early_suspend(struct rk_lcdc_driver *dev_drv);
+static int vop_early_resume(struct rk_lcdc_driver *dev_drv);
+/*enable layer,open:1,enable;0 disable*/
+static void vop_layer_enable(struct vop_device *vop_dev,
+			     unsigned int win_id, bool open)
+{
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on) &&
+	    vop_dev->driver.win[win_id]->state != open) {
+		if (open) {
+			if (!vop_dev->atv_layer_cnt) {
+				dev_info(vop_dev->dev,
+					 "wakeup from standby!\n");
+				vop_dev->standby = 0;
+			}
+			vop_dev->atv_layer_cnt |= (1 << win_id);
+		} else {
+			if (vop_dev->atv_layer_cnt & (1 << win_id))
+				vop_dev->atv_layer_cnt &= ~(1 << win_id);
+		}
+		vop_dev->driver.win[win_id]->state = open;
+		if (!open) {
+			vop_layer_update_regs(vop_dev,
+					      vop_dev->driver.win[win_id]);
+			vop_cfg_done(vop_dev);
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	/* if no layer used,disable lcdc */
+	if (vop_dev->prop == EXTEND) {
+		if (!vop_dev->atv_layer_cnt && !open) {
+			if (!wait_event_timeout(vop_dev->wait_dmc_queue,
+						!vop_dev->dmc_in_process, HZ / 5))
+				dev_warn(vop_dev->dev,
+					 "Timeout waiting for dmc when vop disable\n");
+
+			vop_dev->vop_switch_status = 1;
+			vop_early_suspend(&vop_dev->driver);
+			dev_info(vop_dev->dev,
+				 "no layer is used,go to standby!\n");
+			vop_dev->standby = 1;
+
+			vop_dev->vop_switch_status = 0;
+			wake_up(&vop_dev->wait_vop_switch_queue);
+			/*
+			 * if clsoe enxtend vop need to enable dmc again.
+			 */
+			if (vop_dev->devfreq) {
+				if (vop_dev->devfreq_event_dev)
+					devfreq_event_enable_edev(vop_dev->devfreq_event_dev);
+				devfreq_resume_device(vop_dev->devfreq);
+			}
+		} else if (open) {
+			vop_early_resume(&vop_dev->driver);
+			vop_dev->vop_switch_status = 0;
+			wake_up(&vop_dev->wait_vop_switch_queue);
+			/* if enable two vop, need to disable dmc */
+			if (vop_dev->devfreq) {
+				if (vop_dev->devfreq_event_dev)
+					devfreq_event_disable_edev(vop_dev->devfreq_event_dev);
+				devfreq_suspend_device(vop_dev->devfreq);
+			}
+			dev_info(vop_dev->dev, "wake up from standby!\n");
+		}
+	} else if (vop_dev->prop == PRMRY) {
+		if ((open) && (!vop_dev->atv_layer_cnt)) {
+			vop_dev->vop_switch_status = 0;
+			wake_up(&vop_dev->wait_vop_switch_queue);
+		}
+	}
+}
+
+static int vop_enable_irq(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = container_of(dev_drv,
+						    struct vop_device, driver);
+	u64 val;
+	/* struct rk_screen *screen = dev_drv->cur_screen; */
+
+	vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_MASK, INTR_MASK);
+
+	val = INTR_FS | INTR_LINE_FLAG0 | INTR_BUS_ERROR | INTR_LINE_FLAG1 |
+		INTR_WIN0_EMPTY | INTR_WIN1_EMPTY | INTR_HWC_EMPTY |
+		INTR_POST_BUF_EMPTY;
+	val |= val << 16;
+
+	vop_msk_reg(vop_dev, INTR_EN0, val);
+
+	return 0;
+}
+
+static int dmc_notify(struct notifier_block *nb, unsigned long event,
+		      void *data)
+{
+	struct vop_device *vop = container_of(nb, struct vop_device, dmc_nb);
+
+	if (event == DEVFREQ_PRECHANGE) {
+
+		/*
+		 * check if vop in enable or disable process,
+		 * if yes, wait until it finish, use 200ms as
+		 * timeout.
+		 */
+		if (!wait_event_timeout(vop->wait_vop_switch_queue,
+					!vop->vop_switch_status, HZ / 5))
+			dev_warn(vop->dev,
+				 "Timeout waiting for vop swtich status\n");
+		vop->dmc_in_process = 1;
+	} else if (event == DEVFREQ_POSTCHANGE) {
+		vop->dmc_in_process = 0;
+		wake_up(&vop->wait_dmc_queue);
+	}
+
+	return NOTIFY_OK;
+}
+
+static int vop_open(struct rk_lcdc_driver *dev_drv, int win_id,
+		    bool open)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	if (dev_drv->shutdown_flag)
+		return 0;
+	/* enable clk,when first layer open */
+	if ((open) && (!vop_dev->atv_layer_cnt)) {
+		/* rockchip_set_system_status(sys_status); */
+		if (!wait_event_timeout(vop_dev->wait_dmc_queue,
+				!vop_dev->dmc_in_process, HZ / 5))
+			dev_warn(vop_dev->dev,
+				 "Timeout waiting for dmc when vop enable\n");
+		vop_dev->vop_switch_status = 1;
+		if (vop_pre_init(dev_drv))
+			return -1;
+		vop_clk_enable(vop_dev);
+		vop_enable_irq(dev_drv);
+		if (dev_drv->iommu_enabled) {
+			if (!dev_drv->mmu_dev) {
+				dev_drv->mmu_dev =
+				    rk_fb_get_sysmmu_device_by_compatible
+				    (dev_drv->mmu_dts_name);
+				if (dev_drv->mmu_dev) {
+					rk_fb_platform_set_sysmmu
+					    (dev_drv->mmu_dev, dev_drv->dev);
+				} else {
+					dev_err(dev_drv->dev,
+						"fail get rk iommu device\n");
+					return -1;
+				}
+			}
+		}
+		if ((support_uboot_display() && (vop_dev->prop == PRMRY)))
+			vop_set_dclk(dev_drv, 0);
+		else
+			vop_load_screen(dev_drv, 1);
+		if (dev_drv->bcsh.enable)
+			vop_set_bcsh(dev_drv, 1);
+		vop_set_lut(dev_drv, dev_drv->cur_screen->dsp_lut);
+		vop_set_cabc(dev_drv, dev_drv->cur_screen->cabc_lut);
+	}
+
+	if (win_id < dev_drv->lcdc_win_num)
+		vop_layer_enable(vop_dev, win_id, open);
+	else
+		dev_err(vop_dev->dev, "invalid win id:%d\n", win_id);
+
+	dev_drv->first_frame = 0;
+	return 0;
+}
+
+static int win_0_1_display(struct vop_device *vop_dev,
+			   struct rk_lcdc_win *win)
+{
+	u32 y_addr;
+	u32 uv_addr;
+	unsigned int off;
+
+	off = win->id * 0x40;
+	/*win->smem_start + win->y_offset; */
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
+	DBG(2, "lcdc[%d]:win[%d]>>:y_addr:0x%x>>uv_addr:0x%x",
+	    vop_dev->id, win->id, y_addr, uv_addr);
+	DBG(2, ">>y_offset:0x%x>>c_offset=0x%x\n",
+	    win->area[0].y_offset, win->area[0].c_offset);
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		win->area[0].y_addr = y_addr;
+		win->area[0].uv_addr = uv_addr;
+		vop_writel(vop_dev, WIN0_YRGB_MST + off, win->area[0].y_addr);
+		vop_writel(vop_dev, WIN0_CBR_MST + off, win->area[0].uv_addr);
+		if (win->area[0].fbdc_en == 1)
+			vop_writel(vop_dev, AFBCD0_HDR_PTR,
+				   win->area[0].y_addr);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int win_2_3_display(struct vop_device *vop_dev,
+			   struct rk_lcdc_win *win)
+{
+	u32 i, y_addr;
+	unsigned int off;
+
+	off = (win->id - 2) * 0x50;
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	DBG(2, "lcdc[%d]:win[%d]:", vop_dev->id, win->id);
+
+	if (likely(vop_dev->clk_on)) {
+		for (i = 0; i < win->area_num; i++) {
+			DBG(2, "area[%d]:yaddr:0x%x>>offset:0x%x>>\n",
+			    i, win->area[i].y_addr, win->area[i].y_offset);
+			win->area[i].y_addr =
+			    win->area[i].smem_start + win->area[i].y_offset;
+			}
+		spin_lock(&vop_dev->reg_lock);
+		vop_writel(vop_dev, WIN2_MST0 + off, win->area[0].y_addr);
+		vop_writel(vop_dev, WIN2_MST1 + off, win->area[1].y_addr);
+		vop_writel(vop_dev, WIN2_MST2 + off, win->area[2].y_addr);
+		vop_writel(vop_dev, WIN2_MST3 + off, win->area[3].y_addr);
+		if (win->area[0].fbdc_en == 1)
+			vop_writel(vop_dev, AFBCD0_HDR_PTR,
+				   win->area[0].y_addr);
+		spin_unlock(&vop_dev->reg_lock);
+	}
+	return 0;
+}
+
+static int hwc_display(struct vop_device *vop_dev, struct rk_lcdc_win *win)
+{
+	u32 y_addr;
+
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	DBG(2, "lcdc[%d]:hwc>>%s>>y_addr:0x%x>>\n",
+	    vop_dev->id, __func__, y_addr);
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		win->area[0].y_addr = y_addr;
+		vop_writel(vop_dev, HWC_MST, win->area[0].y_addr);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	win = dev_drv->win[win_id];
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+	if (win_id == 0) {
+		win_0_1_display(vop_dev, win);
+	} else if (win_id == 1) {
+		win_0_1_display(vop_dev, win);
+	} else if (win_id == 2) {
+		win_2_3_display(vop_dev, win);
+	} else if (win_id == 3) {
+		win_2_3_display(vop_dev, win);
+	} else if (win_id == 4) {
+		hwc_display(vop_dev, win);
+	} else {
+		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int vop_cal_scl_fac(struct rk_lcdc_win *win, struct rk_screen *screen)
+{
+	u16 srcW = 0;
+	u16 srcH = 0;
+	u16 dstW = 0;
+	u16 dstH = 0;
+	u16 yrgb_srcW = 0;
+	u16 yrgb_srcH = 0;
+	u16 yrgb_dstW = 0;
+	u16 yrgb_dstH = 0;
+	u32 yrgb_vscalednmult = 0;
+	u32 yrgb_xscl_factor = 0;
+	u32 yrgb_yscl_factor = 0;
+	u8 yrgb_vsd_bil_gt2 = 0;
+	u8 yrgb_vsd_bil_gt4 = 0;
+
+	u16 cbcr_srcW = 0;
+	u16 cbcr_srcH = 0;
+	u16 cbcr_dstW = 0;
+	u16 cbcr_dstH = 0;
+	u32 cbcr_vscalednmult = 0;
+	u32 cbcr_xscl_factor = 0;
+	u32 cbcr_yscl_factor = 0;
+	u8 cbcr_vsd_bil_gt2 = 0;
+	u8 cbcr_vsd_bil_gt4 = 0;
+	u8 yuv_fmt = 0;
+
+	srcW = win->area[0].xact;
+	if ((screen->mode.vmode & FB_VMODE_INTERLACED) &&
+	    (win->area[0].yact == 2 * win->area[0].ysize)) {
+		srcH = win->area[0].yact / 2;
+		yrgb_vsd_bil_gt2 = 1;
+		cbcr_vsd_bil_gt2 = 1;
+	} else {
+		srcH = win->area[0].yact;
+	}
+	dstW = win->area[0].xsize;
+	dstH = win->area[0].ysize;
+
+	/*yrgb scl mode */
+	yrgb_srcW = srcW;
+	yrgb_srcH = srcH;
+	yrgb_dstW = dstW;
+	yrgb_dstH = dstH;
+	if ((yrgb_dstW * 8 <= yrgb_srcW) || (yrgb_dstH * 8 <= yrgb_srcH)) {
+		pr_err("ERROR: yrgb scale exceed 8,");
+		pr_err("srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
+		       yrgb_srcW, yrgb_srcH, yrgb_dstW, yrgb_dstH);
+	}
+	if (yrgb_srcW < yrgb_dstW)
+		win->yrgb_hor_scl_mode = SCALE_UP;
+	else if (yrgb_srcW > yrgb_dstW)
+		win->yrgb_hor_scl_mode = SCALE_DOWN;
+	else
+		win->yrgb_hor_scl_mode = SCALE_NONE;
+
+	if (yrgb_srcH < yrgb_dstH)
+		win->yrgb_ver_scl_mode = SCALE_UP;
+	else if (yrgb_srcH > yrgb_dstH)
+		win->yrgb_ver_scl_mode = SCALE_DOWN;
+	else
+		win->yrgb_ver_scl_mode = SCALE_NONE;
+
+	/*cbcr scl mode */
+	switch (win->area[0].format) {
+	case YUV422:
+	case YUYV422:
+	case UYVY422:
+	case YUV422_A:
+		cbcr_srcW = srcW / 2;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	case YUV420:
+	case YUYV420:
+	case UYVY420:
+	case YUV420_A:
+	case YUV420_NV21:
+		cbcr_srcW = srcW / 2;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH / 2;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	case YUV444:
+	case YUV444_A:
+		cbcr_srcW = srcW;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	default:
+		cbcr_srcW = 0;
+		cbcr_dstW = 0;
+		cbcr_srcH = 0;
+		cbcr_dstH = 0;
+		yuv_fmt = 0;
+		break;
+	}
+	if (yuv_fmt) {
+		if ((cbcr_dstW * 8 <= cbcr_srcW) ||
+		    (cbcr_dstH * 8 <= cbcr_srcH)) {
+			pr_err("ERROR: cbcr scale exceed 8,");
+			pr_err("srcW=%d,srcH=%d,dstW=%d,dstH=%d\n", cbcr_srcW,
+			       cbcr_srcH, cbcr_dstW, cbcr_dstH);
+		}
+	}
+
+	if (cbcr_srcW < cbcr_dstW)
+		win->cbr_hor_scl_mode = SCALE_UP;
+	else if (cbcr_srcW > cbcr_dstW)
+		win->cbr_hor_scl_mode = SCALE_DOWN;
+	else
+		win->cbr_hor_scl_mode = SCALE_NONE;
+
+	if (cbcr_srcH < cbcr_dstH)
+		win->cbr_ver_scl_mode = SCALE_UP;
+	else if (cbcr_srcH > cbcr_dstH)
+		win->cbr_ver_scl_mode = SCALE_DOWN;
+	else
+		win->cbr_ver_scl_mode = SCALE_NONE;
+
+	/* line buffer mode */
+	if ((win->area[0].format == YUV422) ||
+	    (win->area[0].format == YUV420) ||
+	    (win->area[0].format == YUYV422) ||
+	    (win->area[0].format == YUYV420) ||
+	    (win->area[0].format == UYVY422) ||
+	    (win->area[0].format == UYVY420) ||
+	    (win->area[0].format == YUV420_NV21) ||
+	    (win->area[0].format == YUV422_A) ||
+	    (win->area[0].format == YUV420_A)) {
+		if (win->cbr_hor_scl_mode == SCALE_DOWN) {
+			if ((cbcr_dstW > VOP_INPUT_MAX_WIDTH / 2) ||
+			    (cbcr_dstW == 0))
+				pr_err("ERROR cbcr_dstW = %d,exceeds 2048\n",
+				       cbcr_dstW);
+			else if (cbcr_dstW > 1280)
+				win->win_lb_mode = LB_YUV_3840X5;
+			else
+				win->win_lb_mode = LB_YUV_2560X8;
+		} else {	/* SCALE_UP or SCALE_NONE */
+			if ((cbcr_srcW > VOP_INPUT_MAX_WIDTH / 2) ||
+			    (cbcr_srcW == 0))
+				pr_err("ERROR cbcr_srcW = %d,exceeds 2048\n",
+				       cbcr_srcW);
+			else if (cbcr_srcW > 1280)
+				win->win_lb_mode = LB_YUV_3840X5;
+			else
+				win->win_lb_mode = LB_YUV_2560X8;
+		}
+	} else {
+		if (win->yrgb_hor_scl_mode == SCALE_DOWN) {
+			if ((yrgb_dstW > VOP_INPUT_MAX_WIDTH) ||
+			    (yrgb_dstW == 0))
+				pr_err("ERROR yrgb_dstW = %d\n", yrgb_dstW);
+			else if (yrgb_dstW > 2560)
+				win->win_lb_mode = LB_RGB_3840X2;
+			else if (yrgb_dstW > 1920)
+				win->win_lb_mode = LB_RGB_2560X4;
+			else if (yrgb_dstW > 1280)
+				win->win_lb_mode = LB_RGB_1920X5;
+			else
+				win->win_lb_mode = LB_RGB_1280X8;
+		} else {	/* SCALE_UP or SCALE_NONE */
+			if ((yrgb_srcW > VOP_INPUT_MAX_WIDTH) ||
+			    (yrgb_srcW == 0))
+				pr_err("ERROR yrgb_srcW = %d\n", yrgb_srcW);
+			else if (yrgb_srcW > 2560)
+				win->win_lb_mode = LB_RGB_3840X2;
+			else if (yrgb_srcW > 1920)
+				win->win_lb_mode = LB_RGB_2560X4;
+			else if (yrgb_srcW > 1280)
+				win->win_lb_mode = LB_RGB_1920X5;
+			else
+				win->win_lb_mode = LB_RGB_1280X8;
+		}
+	}
+	DBG(1, "win->win_lb_mode = %d;\n", win->win_lb_mode);
+
+	/* vsd/vsu scale ALGORITHM */
+	win->yrgb_hsd_mode = SCALE_DOWN_BIL;	/*not to specify */
+	win->cbr_hsd_mode = SCALE_DOWN_BIL;	/*not to specify */
+	win->yrgb_vsd_mode = SCALE_DOWN_BIL;	/*not to specify */
+	win->cbr_vsd_mode = SCALE_DOWN_BIL;	/*not to specify */
+
+	/* if (VOP_CHIP(vop_dev) == VOP_RK3399) { */
+	if ((win->area[0].format == YUYV422) ||
+	    (win->area[0].format == YUYV420) ||
+	    (win->area[0].format == UYVY422) ||
+	    (win->area[0].format == UYVY420)) {
+		yrgb_vscalednmult =
+			vop_get_hard_ware_vskiplines(yrgb_srcH, yrgb_dstH);
+		if (yrgb_vscalednmult == 4) {
+			yrgb_vsd_bil_gt4 = 1;
+			yrgb_vsd_bil_gt2 = 0;
+		} else if (yrgb_vscalednmult == 2) {
+			yrgb_vsd_bil_gt4 = 0;
+			yrgb_vsd_bil_gt2 = 1;
+		} else {
+			yrgb_vsd_bil_gt4 = 0;
+			yrgb_vsd_bil_gt2 = 0;
+		}
+		if ((win->area[0].format == YUYV420) ||
+		    (win->area[0].format == UYVY420)) {
+			if ((yrgb_vsd_bil_gt4 == 1) || (yrgb_vsd_bil_gt2 == 1))
+				win->yrgb_vsd_mode = SCALE_DOWN_AVG;
+		}
+
+		cbcr_vscalednmult =
+			vop_get_hard_ware_vskiplines(cbcr_srcH, cbcr_dstH);
+		if (cbcr_vscalednmult == 4) {
+			cbcr_vsd_bil_gt4 = 1;
+			cbcr_vsd_bil_gt2 = 0;
+		} else if (cbcr_vscalednmult == 2) {
+			cbcr_vsd_bil_gt4 = 0;
+			cbcr_vsd_bil_gt2 = 1;
+		} else {
+			cbcr_vsd_bil_gt4 = 0;
+			cbcr_vsd_bil_gt2 = 0;
+		}
+		if ((win->area[0].format == YUYV420) ||
+		    (win->area[0].format == UYVY420)) {
+			if ((cbcr_vsd_bil_gt4 == 1) || (cbcr_vsd_bil_gt2 == 1))
+				win->cbr_vsd_mode = SCALE_DOWN_AVG;
+		}
+		/* CBCR vsd_mode must same to YRGB for YUYV when gt2 or gt4 */
+		if ((cbcr_vsd_bil_gt4 == 1) || (cbcr_vsd_bil_gt2 == 1)) {
+			if (win->yrgb_vsd_mode != win->cbr_vsd_mode)
+				win->cbr_vsd_mode = win->yrgb_vsd_mode;
+		}
+	}
+	/* 3399 yuyv support*/
+	if (win->ymirror == 1) {
+		if (win->yrgb_vsd_mode == SCALE_DOWN_AVG)
+			pr_info("y_mirror enable, y-vsd AVG mode unsupprot\n");
+		win->yrgb_vsd_mode = SCALE_DOWN_BIL;
+	}
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		if (win->yrgb_vsd_mode == SCALE_DOWN_AVG)
+			pr_info("interlace mode, y-vsd AVG mode unsupprot\n");
+		/* interlace mode must bill */
+		win->yrgb_vsd_mode = SCALE_DOWN_BIL;
+		win->cbr_vsd_mode = SCALE_DOWN_BIL;
+	}
+	switch (win->win_lb_mode) {
+	case LB_YUV_3840X5:
+	case LB_YUV_2560X8:
+	case LB_RGB_1920X5:
+	case LB_RGB_1280X8:
+		win->yrgb_vsu_mode = SCALE_UP_BIC;
+		win->cbr_vsu_mode = SCALE_UP_BIC;
+		break;
+	case LB_RGB_3840X2:
+		if (win->yrgb_ver_scl_mode != SCALE_NONE)
+			pr_err("ERROR : not allow yrgb ver scale\n");
+		if (win->cbr_ver_scl_mode != SCALE_NONE)
+			pr_err("ERROR : not allow cbcr ver scale\n");
+		break;
+	case LB_RGB_2560X4:
+		win->yrgb_vsu_mode = SCALE_UP_BIL;
+		win->cbr_vsu_mode = SCALE_UP_BIL;
+		break;
+	default:
+		pr_info("%s:un supported win_lb_mode:%d\n",
+			__func__, win->win_lb_mode);
+		break;
+	}
+
+	if ((win->yrgb_ver_scl_mode == SCALE_DOWN) &&
+	    (win->area[0].fbdc_en == 1)) {
+		/* in this pattern,use bil mode,not support souble scd,
+		 * use avg mode, support double scd, but aclk should be
+		 * bigger than dclk.
+		 */
+		if (yrgb_srcH >= 2 * yrgb_dstH) {
+			pr_err("ERROR : fbdc mode,not support y scale down:");
+			pr_err("srcH[%d] > 2 *dstH[%d]\n",
+			       yrgb_srcH, yrgb_dstH);
+		}
+	}
+	DBG(1, "yrgb:hsd=%d,vsd=%d,vsu=%d;cbcr:hsd=%d,vsd=%d,vsu=%d\n",
+	    win->yrgb_hsd_mode, win->yrgb_vsd_mode, win->yrgb_vsu_mode,
+	    win->cbr_hsd_mode, win->cbr_vsd_mode, win->cbr_vsu_mode);
+
+	/* SCALE FACTOR */
+
+	/* (1.1)YRGB HOR SCALE FACTOR */
+	switch (win->yrgb_hor_scl_mode) {
+	case SCALE_NONE:
+		yrgb_xscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+		break;
+	case SCALE_UP:
+		yrgb_xscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcW, yrgb_dstW);
+		break;
+	case SCALE_DOWN:
+		switch (win->yrgb_hsd_mode) {
+		case SCALE_DOWN_BIL:
+			yrgb_xscl_factor =
+			    GET_SCALE_FACTOR_BILI_DN(yrgb_srcW, yrgb_dstW);
+			break;
+		case SCALE_DOWN_AVG:
+			yrgb_xscl_factor =
+			    GET_SCALE_FACTOR_AVRG(yrgb_srcW, yrgb_dstW);
+			break;
+		default:
+			pr_info("%s:un supported yrgb_hsd_mode:%d\n", __func__,
+				win->yrgb_hsd_mode);
+			break;
+		}
+		break;
+	default:
+		pr_info("%s:un supported yrgb_hor_scl_mode:%d\n",
+			__func__, win->yrgb_hor_scl_mode);
+		break;
+	}
+
+	/* (1.2)YRGB VER SCALE FACTOR */
+	switch (win->yrgb_ver_scl_mode) {
+	case SCALE_NONE:
+		yrgb_yscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+		break;
+	case SCALE_UP:
+		switch (win->yrgb_vsu_mode) {
+		case SCALE_UP_BIL:
+			yrgb_yscl_factor =
+			    GET_SCALE_FACTOR_BILI_UP(yrgb_srcH, yrgb_dstH);
+			break;
+		case SCALE_UP_BIC:
+			if (yrgb_srcH < 3) {
+				pr_err("yrgb_srcH should be");
+				pr_err(" greater than 3 !!!\n");
+			}
+			yrgb_yscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcH,
+								yrgb_dstH);
+			break;
+		default:
+			pr_info("%s:un support yrgb_vsu_mode:%d\n",
+				__func__, win->yrgb_vsu_mode);
+			break;
+		}
+		break;
+	case SCALE_DOWN:
+		switch (win->yrgb_vsd_mode) {
+		case SCALE_DOWN_BIL:
+			yrgb_vscalednmult =
+			    vop_get_hard_ware_vskiplines(yrgb_srcH, yrgb_dstH);
+			yrgb_yscl_factor =
+			    GET_SCALE_FACTOR_BILI_DN_VSKIP(yrgb_srcH, yrgb_dstH,
+							   yrgb_vscalednmult);
+			if (yrgb_yscl_factor >= 0x2000) {
+				pr_err("yrgb_yscl_factor should less 0x2000");
+				pr_err("yrgb_yscl_factor=%4x;\n",
+				       yrgb_yscl_factor);
+			}
+			if (yrgb_vscalednmult == 4) {
+				yrgb_vsd_bil_gt4 = 1;
+				yrgb_vsd_bil_gt2 = 0;
+			} else if (yrgb_vscalednmult == 2) {
+				yrgb_vsd_bil_gt4 = 0;
+				yrgb_vsd_bil_gt2 = 1;
+			} else {
+				yrgb_vsd_bil_gt4 = 0;
+				yrgb_vsd_bil_gt2 = 0;
+			}
+			break;
+		case SCALE_DOWN_AVG:
+			yrgb_yscl_factor = GET_SCALE_FACTOR_AVRG(yrgb_srcH,
+								 yrgb_dstH);
+			break;
+		default:
+			pr_info("%s:un support yrgb_vsd_mode:%d\n",
+				__func__, win->yrgb_vsd_mode);
+			break;
+		}		/*win->yrgb_vsd_mode */
+		break;
+	default:
+		pr_info("%s:un supported yrgb_ver_scl_mode:%d\n",
+			__func__, win->yrgb_ver_scl_mode);
+		break;
+	}
+	win->scale_yrgb_x = yrgb_xscl_factor;
+	win->scale_yrgb_y = yrgb_yscl_factor;
+	win->vsd_yrgb_gt4 = yrgb_vsd_bil_gt4;
+	win->vsd_yrgb_gt2 = yrgb_vsd_bil_gt2;
+	DBG(1, "yrgb:h_fac=%d, V_fac=%d,gt4=%d, gt2=%d\n", yrgb_xscl_factor,
+	    yrgb_yscl_factor, yrgb_vsd_bil_gt4, yrgb_vsd_bil_gt2);
+
+	/*(2.1)CBCR HOR SCALE FACTOR */
+	switch (win->cbr_hor_scl_mode) {
+	case SCALE_NONE:
+		cbcr_xscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+		break;
+	case SCALE_UP:
+		cbcr_xscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcW, cbcr_dstW);
+		break;
+	case SCALE_DOWN:
+		switch (win->cbr_hsd_mode) {
+		case SCALE_DOWN_BIL:
+			cbcr_xscl_factor =
+			    GET_SCALE_FACTOR_BILI_DN(cbcr_srcW, cbcr_dstW);
+			break;
+		case SCALE_DOWN_AVG:
+			cbcr_xscl_factor =
+			    GET_SCALE_FACTOR_AVRG(cbcr_srcW, cbcr_dstW);
+			break;
+		default:
+			pr_info("%s:un support cbr_hsd_mode:%d\n",
+				__func__, win->cbr_hsd_mode);
+			break;
+		}
+		break;
+	default:
+		pr_info("%s:un supported cbr_hor_scl_mode:%d\n",
+			__func__, win->cbr_hor_scl_mode);
+		break;
+	}			/*win->cbr_hor_scl_mode */
+
+	/* (2.2)CBCR VER SCALE FACTOR */
+	switch (win->cbr_ver_scl_mode) {
+	case SCALE_NONE:
+		cbcr_yscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+		break;
+	case SCALE_UP:
+		switch (win->cbr_vsu_mode) {
+		case SCALE_UP_BIL:
+			cbcr_yscl_factor =
+			    GET_SCALE_FACTOR_BILI_UP(cbcr_srcH, cbcr_dstH);
+			break;
+		case SCALE_UP_BIC:
+			if (cbcr_srcH < 3) {
+				pr_err("cbcr_srcH should be ");
+				pr_err("greater than 3 !!!\n");
+			}
+			cbcr_yscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcH,
+								cbcr_dstH);
+			break;
+		default:
+			pr_info("%s:un support cbr_vsu_mode:%d\n",
+				__func__, win->cbr_vsu_mode);
+			break;
+		}
+		break;
+	case SCALE_DOWN:
+		switch (win->cbr_vsd_mode) {
+		case SCALE_DOWN_BIL:
+			cbcr_vscalednmult =
+			    vop_get_hard_ware_vskiplines(cbcr_srcH, cbcr_dstH);
+			cbcr_yscl_factor =
+			    GET_SCALE_FACTOR_BILI_DN_VSKIP(cbcr_srcH, cbcr_dstH,
+							   cbcr_vscalednmult);
+			if (cbcr_yscl_factor >= 0x2000) {
+				pr_err("cbcr_yscl_factor should be less ");
+				pr_err("than 0x2000,cbcr_yscl_factor=%4x;\n",
+				       cbcr_yscl_factor);
+			}
+
+			if (cbcr_vscalednmult == 4) {
+				cbcr_vsd_bil_gt4 = 1;
+				cbcr_vsd_bil_gt2 = 0;
+			} else if (cbcr_vscalednmult == 2) {
+				cbcr_vsd_bil_gt4 = 0;
+				cbcr_vsd_bil_gt2 = 1;
+			} else {
+				cbcr_vsd_bil_gt4 = 0;
+				cbcr_vsd_bil_gt2 = 0;
+			}
+			break;
+		case SCALE_DOWN_AVG:
+			cbcr_yscl_factor = GET_SCALE_FACTOR_AVRG(cbcr_srcH,
+								 cbcr_dstH);
+			break;
+		default:
+			pr_info("%s:un support cbr_vsd_mode:%d\n",
+				__func__, win->cbr_vsd_mode);
+			break;
+		}
+		break;
+	default:
+		pr_info("%s:un supported cbr_ver_scl_mode:%d\n",
+			__func__, win->cbr_ver_scl_mode);
+		break;
+	}
+	win->scale_cbcr_x = cbcr_xscl_factor;
+	win->scale_cbcr_y = cbcr_yscl_factor;
+	win->vsd_cbr_gt4 = cbcr_vsd_bil_gt4;
+	win->vsd_cbr_gt2 = cbcr_vsd_bil_gt2;
+
+	DBG(1, "cbcr:h_fac=%d,v_fac=%d,gt4=%d,gt2=%d\n", cbcr_xscl_factor,
+	    cbcr_yscl_factor, cbcr_vsd_bil_gt4, cbcr_vsd_bil_gt2);
+	return 0;
+}
+
+static int dsp_x_pos(int mirror_en, struct rk_screen *screen,
+		     struct rk_lcdc_win_area *area)
+{
+	int pos;
+
+	if (screen->x_mirror && mirror_en)
+		pr_err("not support both win and global mirror\n");
+
+	if ((!mirror_en) && (!screen->x_mirror))
+		pos = area->xpos + screen->mode.left_margin +
+			screen->mode.hsync_len;
+	else
+		pos = screen->mode.xres - area->xpos -
+			area->xsize + screen->mode.left_margin +
+			screen->mode.hsync_len;
+
+	return pos;
+}
+
+static int dsp_y_pos(int mirror_en, struct rk_screen *screen,
+		     struct rk_lcdc_win_area *area)
+{
+	int pos;
+
+	if (screen->y_mirror && mirror_en)
+		pr_err("not support both win and global mirror\n");
+
+	if ((!mirror_en) && (!screen->y_mirror))
+		pos = area->ypos + screen->mode.upper_margin +
+			screen->mode.vsync_len;
+	else
+		pos = screen->mode.yres - area->ypos -
+			area->ysize + screen->mode.upper_margin +
+			screen->mode.vsync_len;
+
+	return pos;
+}
+
+static int win_0_1_set_par(struct vop_device *vop_dev,
+			   struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	u32 xact = 0, yact = 0, xvir = 0, yvir = 0, xpos = 0, ypos = 0;
+	u8 fmt_cfg = 0, swap_rb = 0, swap_uv = 0;
+	char fmt[9] = "NULL";
+
+	xpos = dsp_x_pos(win->xmirror, screen, &win->area[0]);
+	ypos = dsp_y_pos(win->ymirror, screen, &win->area[0]);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_cal_scl_fac(win, screen);
+		switch (win->area[0].format) {
+		case FBDC_RGB_565:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].fbdc_fmt_cfg = AFBDC_FMT_RGB565;
+			break;
+		case FBDC_ARGB_888:
+			fmt_cfg = 0;
+			swap_rb = 1;
+			win->fmt_10 = 0;
+			win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
+			break;
+		case FBDC_ABGR_888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
+			break;
+		case FBDC_RGBX_888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
+			break;
+		case ARGB888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case XBGR888:
+		case ABGR888:
+			fmt_cfg = 0;
+			swap_rb = 1;
+			win->fmt_10 = 0;
+			break;
+		case BGR888:
+			fmt_cfg = 1;
+			swap_rb = 1;
+			win->fmt_10 = 0;
+			break;
+		case RGB888:
+			fmt_cfg = 1;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case RGB565:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV422:
+			fmt_cfg = 5;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV420:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV420_NV21:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			swap_uv = 1;
+			win->fmt_10 = 0;
+			break;
+		case YUV444:
+			fmt_cfg = 6;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV422_A:
+			fmt_cfg = 5;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUV420_A:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUV444_A:
+			fmt_cfg = 6;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUYV422:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].yuyv_fmt = 1;
+			break;
+		case YUYV420:
+			fmt_cfg = 1;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].yuyv_fmt = 1;
+			break;
+		case UYVY422:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].yuyv_fmt = 1;
+			break;
+		case UYVY420:
+			fmt_cfg = 3;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].yuyv_fmt = 1;
+			break;
+		default:
+			dev_err(vop_dev->dev, "%s:unsupport format[%d]!\n",
+				__func__, win->area[0].format);
+			break;
+		}
+		win->area[0].fmt_cfg = fmt_cfg;
+		win->area[0].swap_rb = swap_rb;
+		win->area[0].swap_uv = swap_uv;
+		win->area[0].dsp_stx = xpos;
+		win->area[0].dsp_sty = ypos;
+		xact = win->area[0].xact;
+		yact = win->area[0].yact;
+		xvir = win->area[0].xvir;
+		yvir = win->area[0].yvir;
+	}
+	if (win->area[0].fbdc_en)
+		vop_init_fbdc_config(vop_dev, win->id);
+	vop_win_0_1_reg_update(&vop_dev->driver, win->id);
+	spin_unlock(&vop_dev->reg_lock);
+
+	DBG(1, "lcdc[%d]:win[%d]\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
+	    vop_dev->id, win->id, get_format_string(win->area[0].format, fmt),
+	    xact, yact, win->area[0].xsize);
+	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+	    win->area[0].ysize, xvir, yvir, xpos, ypos);
+
+	return 0;
+}
+
+static int win_2_3_set_par(struct vop_device *vop_dev,
+			   struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	int i;
+	u8 fmt_cfg = 0, swap_rb = 0;
+	char fmt[9] = "NULL";
+
+	if (VOP_CHIP(vop_dev) == VOP_RK322X) {
+		pr_err("rk3228 not support win2/3 set par\n");
+		return -EINVAL;
+	}
+	if (win->ymirror) {
+		pr_err("win[%d] not support y mirror\n", win->id);
+		return -EINVAL;
+	}
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		DBG(2, "lcdc[%d]:win[%d]>>\n>\n", vop_dev->id, win->id);
+		for (i = 0; i < win->area_num; i++) {
+			switch (win->area[i].format) {
+			case FBDC_RGB_565:
+				fmt_cfg = 2;
+				swap_rb = 0;
+				win->fmt_10 = 0;
+				win->area[0].fbdc_fmt_cfg = AFBDC_FMT_RGB565;
+				break;
+			case FBDC_ARGB_888:
+				fmt_cfg = 0;
+				swap_rb = 1;
+				win->fmt_10 = 0;
+				win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
+				break;
+			case FBDC_ABGR_888:
+				fmt_cfg = 0;
+				swap_rb = 0;
+				win->fmt_10 = 0;
+				win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
+				break;
+			case FBDC_RGBX_888:
+				fmt_cfg = 0;
+				swap_rb = 0;
+				win->fmt_10 = 0;
+				win->area[0].fbdc_fmt_cfg = AFBDC_FMT_U8U8U8U8;
+				break;
+			case ARGB888:
+				fmt_cfg = 0;
+				swap_rb = 0;
+				break;
+			case XBGR888:
+			case ABGR888:
+				fmt_cfg = 0;
+				swap_rb = 1;
+				break;
+			case RGB888:
+				fmt_cfg = 1;
+				swap_rb = 0;
+				break;
+			case RGB565:
+				fmt_cfg = 2;
+				swap_rb = 0;
+				break;
+			default:
+				dev_err(vop_dev->driver.dev,
+					"%s:un supported format!\n", __func__);
+				spin_unlock(&vop_dev->reg_lock);
+				return -EINVAL;
+			}
+			win->area[i].fmt_cfg = fmt_cfg;
+			win->area[i].swap_rb = swap_rb;
+			win->area[i].dsp_stx = dsp_x_pos(win->xmirror, screen,
+							 &win->area[i]);
+			win->area[i].dsp_sty = dsp_y_pos(win->ymirror, screen,
+							 &win->area[i]);
+			if (((win->area[i].xact != win->area[i].xsize) ||
+			     (win->area[i].yact != win->area[i].ysize)) &&
+			    (screen->mode.vmode == FB_VMODE_NONINTERLACED)) {
+				pr_err("win[%d]->area[%d],not support scale\n",
+				       win->id, i);
+				pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
+				       win->area[i].xact, win->area[i].yact,
+				       win->area[i].xsize, win->area[i].ysize);
+				win->area[i].xsize = win->area[i].xact;
+				win->area[i].ysize = win->area[i].yact;
+			}
+			DBG(2, "fmt:%s:xsize:%d>>ysize:%d>>xpos:%d>>ypos:%d\n",
+			    get_format_string(win->area[i].format, fmt),
+			    win->area[i].xsize, win->area[i].ysize,
+			    win->area[i].xpos, win->area[i].ypos);
+		}
+	}
+	if (win->area[0].fbdc_en)
+		vop_init_fbdc_config(vop_dev, win->id);
+	vop_win_2_3_reg_update(&vop_dev->driver, win->id);
+	spin_unlock(&vop_dev->reg_lock);
+	return 0;
+}
+
+static int hwc_set_par(struct vop_device *vop_dev,
+		       struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	u32 xact = 0, yact = 0, xvir = 0, yvir = 0, xpos = 0, ypos = 0;
+	u8 fmt_cfg = 0, swap_rb = 0;
+	char fmt[9] = "NULL";
+
+	xpos = win->area[0].xpos + screen->mode.left_margin +
+	    screen->mode.hsync_len;
+	ypos = win->area[0].ypos + screen->mode.upper_margin +
+	    screen->mode.vsync_len;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		switch (win->area[0].format) {
+		case ARGB888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			break;
+		case XBGR888:
+		case ABGR888:
+			fmt_cfg = 0;
+			swap_rb = 1;
+			break;
+		case RGB888:
+			fmt_cfg = 1;
+			swap_rb = 0;
+			break;
+		case RGB565:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			break;
+		default:
+			dev_err(vop_dev->dev, "%s:un supported format[%d]!\n",
+				__func__, win->area[0].format);
+			break;
+		}
+		win->area[0].fmt_cfg = fmt_cfg;
+		win->area[0].swap_rb = swap_rb;
+		win->area[0].dsp_stx = xpos;
+		win->area[0].dsp_sty = ypos;
+		xact = win->area[0].xact;
+		yact = win->area[0].yact;
+		xvir = win->area[0].xvir;
+		yvir = win->area[0].yvir;
+	}
+	vop_hwc_reg_update(&vop_dev->driver, 4);
+	spin_unlock(&vop_dev->reg_lock);
+
+	DBG(1, "lcdc[%d]:hwc>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
+	    vop_dev->id, __func__, get_format_string(win->area[0].format, fmt),
+	    xact, yact, win->area[0].xsize);
+	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+	    win->area[0].ysize, xvir, yvir, xpos, ypos);
+	return 0;
+}
+
+static int vop_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+	win = dev_drv->win[win_id];
+	if (win)
+	switch (win_id) {
+	case 0:
+		win_0_1_set_par(vop_dev, screen, win);
+		break;
+	case 1:
+		win_0_1_set_par(vop_dev, screen, win);
+		break;
+	case 2:
+		win_2_3_set_par(vop_dev, screen, win);
+		break;
+	case 3:
+		win_2_3_set_par(vop_dev, screen, win);
+		break;
+	case 4:
+		hwc_set_par(vop_dev, screen, win);
+		break;
+	default:
+		dev_err(dev_drv->dev, "unsupported win number:%d\n", win_id);
+		break;
+	}
+	return 0;
+}
+
+static int vop_set_writeback(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	int output_color = dev_drv->output_color;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	struct rk_fb_reg_wb_data *wb_data;
+	int xact = screen->mode.xres;
+	int yact = screen->mode.yres;
+	u32 fmt_cfg;
+	int xsize, ysize;
+	u64 v;
+
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+	wb_data = &dev_drv->wb_data;
+	if ((wb_data->xsize == 0) || (wb_data->ysize == 0))
+		return 0;
+
+	xsize = wb_data->xsize;
+	ysize = wb_data->ysize;
+
+	/*
+	 * RGB overlay mode support ARGB888, RGB888, RGB565, NV12,
+	 * but YUV overlay mode only support NV12, it's hard to judge RGB
+	 * or YUV overlay mode by userspace, so here force only support
+	 * NV12 mode.
+	 */
+	if (wb_data->data_format != YUV420 && output_color != COLOR_RGB) {
+		pr_err("writeback only support NV12 when overlay is not RGB\n");
+		return -EINVAL;
+	}
+
+	if (ysize != yact && ysize != (yact / 2)) {
+		pr_err("WriteBack only support yact=%d, ysize=%d\n",
+		       yact, ysize);
+		return -EINVAL;
+	}
+
+	switch (wb_data->data_format) {
+	case ARGB888:
+	case ABGR888:
+	case XRGB888:
+	case XBGR888:
+		fmt_cfg = 0;
+		break;
+	case RGB888:
+	case BGR888:
+		fmt_cfg = 1;
+		break;
+	case RGB565:
+	case BGR565:
+		fmt_cfg = 2;
+		break;
+	case YUV420:
+		fmt_cfg = 8;
+		break;
+	default:
+		pr_info("unsupport fmt: %d\n", wb_data->data_format);
+		return -EINVAL;
+	}
+
+	v = V_WB_EN(wb_data->state) | V_WB_FMT(fmt_cfg) | V_WB_RGB2YUV_MODE(1) |
+		V_WB_XPSD_BIL_EN(xact != xsize) |
+		V_WB_YTHROW_EN(ysize == (yact / 2)) |
+		V_WB_YTHROW_MODE(0);
+
+	v |= V_WB_RGB2YUV_EN((output_color == COLOR_RGB) &&
+			     (wb_data->data_format == YUV420));
+
+	vop_msk_reg(vop_dev, WB_CTRL0, v);
+
+	v = V_WB_WIDTH(xsize) | V_WB_XPSD_BIL_FACTOR((xact << 12) / xsize);
+
+	vop_msk_reg(vop_dev, WB_CTRL1, v);
+
+	vop_writel(vop_dev, WB_YRGB_MST, wb_data->smem_start);
+	if (wb_data->data_format == YUV420)
+		vop_writel(vop_dev, WB_CBR_MST, wb_data->smem_start);
+
+	return 0;
+}
+
+static int vop_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
+		     unsigned long arg, int win_id)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	struct color_key_cfg clr_key_cfg;
+
+	switch (cmd) {
+	case RK_FBIOGET_PANEL_SIZE:
+		panel_size[0] = vop_dev->screen->mode.xres;
+		panel_size[1] = vop_dev->screen->mode.yres;
+		if (copy_to_user(argp, panel_size, 8))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_COLOR_KEY_CFG:
+		if (copy_from_user(&clr_key_cfg, argp, sizeof(clr_key_cfg)))
+			return -EFAULT;
+		vop_clr_key_cfg(dev_drv);
+		vop_writel(vop_dev, WIN0_COLOR_KEY,
+			   clr_key_cfg.win0_color_key_cfg);
+		vop_writel(vop_dev, WIN1_COLOR_KEY,
+			   clr_key_cfg.win1_color_key_cfg);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int vop_get_backlight_device(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = container_of(dev_drv,
+						    struct vop_device, driver);
+	struct device_node *backlight;
+	struct property *prop;
+	u32 *brightness_levels;
+	u32 length, max, last;
+
+	if (vop_dev->backlight)
+		return 0;
+	backlight = of_parse_phandle(vop_dev->dev->of_node, "backlight", 0);
+	if (backlight) {
+		vop_dev->backlight = of_find_backlight_by_node(backlight);
+		if (!vop_dev->backlight)
+			dev_info(vop_dev->dev, "No find backlight device\n");
+	} else {
+		dev_info(vop_dev->dev, "No find backlight device node\n");
+	}
+	prop = of_find_property(backlight, "brightness-levels", &length);
+	if (!prop)
+		return -EINVAL;
+	max = length / sizeof(u32);
+	last = max - 1;
+	brightness_levels = kmalloc(256, GFP_KERNEL);
+	if (!brightness_levels)
+		return -ENOMEM;
+
+	if (!of_property_read_u32_array(backlight, "brightness-levels",
+					brightness_levels, max)) {
+		if (brightness_levels[0] > brightness_levels[last])
+			dev_drv->cabc_pwm_pol = 1;/*negative*/
+		else
+			dev_drv->cabc_pwm_pol = 0;/*positive*/
+	} else {
+		dev_info(vop_dev->dev,
+			 "Can not read brightness-levels value\n");
+	}
+
+	kfree(brightness_levels);
+
+	return 0;
+}
+
+static int vop_early_suspend(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	if (dev_drv->suspend_flag)
+		return 0;
+
+	dev_drv->suspend_flag = 1;
+	/* ensure suspend_flag take effect on multi process */
+	smp_wmb();
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();
+
+	if (likely(vop_dev->clk_on)) {
+		spin_lock(&vop_dev->reg_lock);
+		vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLANK_EN(1));
+		vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_MASK, INTR_MASK);
+		vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_OUT_ZERO(1));
+		vop_msk_reg(vop_dev, SYS_CTRL, V_VOP_STANDBY_EN(1));
+		if (VOP_CHIP(vop_dev) == VOP_RK3399) {
+			vop_msk_reg(vop_dev, WIN0_CTRL0, V_WIN0_EN(0));
+			vop_msk_reg(vop_dev, WIN1_CTRL0, V_WIN1_EN(0));
+			vop_msk_reg(vop_dev, WIN2_CTRL0, V_WIN2_EN(0));
+			vop_msk_reg(vop_dev, WIN3_CTRL0, V_WIN3_EN(0));
+			vop_msk_reg(vop_dev, AFBCD0_CTRL, V_VOP_FBDC_EN(0));
+		}
+		vop_cfg_done(vop_dev);
+
+		if (dev_drv->iommu_enabled && dev_drv->mmu_dev) {
+			mdelay(50);
+			rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+
+		spin_unlock(&vop_dev->reg_lock);
+	}
+
+	vop_clk_disable(vop_dev);
+	rk_disp_pwr_disable(dev_drv);
+
+	return 0;
+}
+
+static int vop_early_resume(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	if (!dev_drv->suspend_flag)
+		return 0;
+	rk_disp_pwr_enable(dev_drv);
+
+	vop_clk_enable(vop_dev);
+	spin_lock(&vop_dev->reg_lock);
+	memcpy(vop_dev->regs, vop_dev->regsbak, vop_dev->len);
+	spin_unlock(&vop_dev->reg_lock);
+
+	vop_set_lut(dev_drv, dev_drv->cur_screen->dsp_lut);
+	vop_set_cabc(dev_drv, dev_drv->cur_screen->cabc_lut);
+	spin_lock(&vop_dev->reg_lock);
+
+	vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_OUT_ZERO(0));
+	vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLANK_EN(0));
+	vop_cfg_done(vop_dev);
+	spin_unlock(&vop_dev->reg_lock);
+
+	if (dev_drv->iommu_enabled && dev_drv->mmu_dev) {
+		/* win address maybe effect after next frame start,
+		 * but mmu maybe effect right now, so we delay 50ms
+		 */
+		mdelay(50);
+		rockchip_iovmm_activate(dev_drv->dev);
+	}
+
+	spin_lock(&vop_dev->reg_lock);
+	vop_msk_reg(vop_dev, SYS_CTRL, V_VOP_STANDBY_EN(0));
+	vop_cfg_done(vop_dev);
+	spin_unlock(&vop_dev->reg_lock);
+
+	dev_drv->suspend_flag = 0;
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+
+	return 0;
+}
+
+static int vop_blank(struct rk_lcdc_driver *dev_drv, int win_id, int blank_mode)
+{
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		vop_early_resume(dev_drv);
+		break;
+	case FB_BLANK_NORMAL:
+		vop_early_suspend(dev_drv);
+		break;
+	default:
+		vop_early_suspend(dev_drv);
+		break;
+	}
+
+	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
+
+	return 0;
+}
+
+static int vop_get_win_state(struct rk_lcdc_driver *dev_drv,
+			     int win_id, int area_id)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	u32 area_status = 0, state = 0;
+
+	switch (win_id) {
+	case 0:
+		area_status = vop_read_bit(vop_dev, WIN0_CTRL0, V_WIN0_EN(0));
+		break;
+	case 1:
+		area_status = vop_read_bit(vop_dev, WIN1_CTRL0, V_WIN1_EN(0));
+		break;
+	case 2:
+		if (area_id == 0)
+			area_status = vop_read_bit(vop_dev, WIN2_CTRL0,
+						   V_WIN2_MST0_EN(0));
+		if (area_id == 1)
+			area_status = vop_read_bit(vop_dev, WIN2_CTRL0,
+						   V_WIN2_MST1_EN(0));
+		if (area_id == 2)
+			area_status = vop_read_bit(vop_dev, WIN2_CTRL0,
+						   V_WIN2_MST2_EN(0));
+		if (area_id == 3)
+			area_status = vop_read_bit(vop_dev, WIN2_CTRL0,
+						   V_WIN2_MST3_EN(0));
+		break;
+	case 3:
+		if (area_id == 0)
+			area_status = vop_read_bit(vop_dev, WIN3_CTRL0,
+						   V_WIN3_MST0_EN(0));
+		if (area_id == 1)
+			area_status = vop_read_bit(vop_dev, WIN3_CTRL0,
+						   V_WIN3_MST1_EN(0));
+		if (area_id == 2)
+			area_status = vop_read_bit(vop_dev, WIN3_CTRL0,
+						   V_WIN3_MST2_EN(0));
+		if (area_id == 3)
+			area_status = vop_read_bit(vop_dev, WIN3_CTRL0,
+						   V_WIN3_MST3_EN(0));
+		break;
+	case 4:
+		area_status = vop_read_bit(vop_dev, HWC_CTRL0, V_HWC_EN(0));
+		break;
+	default:
+		pr_err("!!!%s,win[%d]area[%d],unsupport!!!\n",
+		       __func__, win_id, area_id);
+		break;
+	}
+
+	state = (area_status > 0) ? 1 : 0;
+	return state;
+}
+
+static int vop_get_area_num(struct rk_lcdc_driver *dev_drv,
+			    unsigned int *area_support)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	area_support[0] = 1;
+	area_support[1] = 1;
+
+	if (VOP_CHIP(vop_dev) == VOP_RK3399) {
+		area_support[2] = 4;
+		area_support[3] = 4;
+	}
+
+	return 0;
+}
+
+/*overlay will be do at regupdate*/
+static int vop_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap, bool set)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	int i, ovl = 0;
+	u64 val;
+	int z_order_num = 0;
+	int layer0_sel = 0, layer1_sel = 1, layer2_sel = 2, layer3_sel = 3;
+
+	if (swap == 0) {
+		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+			win = dev_drv->win[i];
+			if (win->state == 1)
+				z_order_num++;
+		}
+		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+			win = dev_drv->win[i];
+			if (win->state == 0)
+				win->z_order = z_order_num++;
+			switch (win->z_order) {
+			case 0:
+				layer0_sel = win->id;
+				break;
+			case 1:
+				layer1_sel = win->id;
+				break;
+			case 2:
+				layer2_sel = win->id;
+				break;
+			case 3:
+				layer3_sel = win->id;
+				break;
+			default:
+				break;
+			}
+		}
+	} else {
+		layer0_sel = swap % 10;
+		layer1_sel = swap / 10 % 10;
+		layer2_sel = swap / 100 % 10;
+		layer3_sel = swap / 1000;
+	}
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		if (set) {
+			val = V_DSP_LAYER0_SEL(layer0_sel) |
+			    V_DSP_LAYER1_SEL(layer1_sel) |
+			    V_DSP_LAYER2_SEL(layer2_sel) |
+			    V_DSP_LAYER3_SEL(layer3_sel);
+			vop_msk_reg(vop_dev, DSP_CTRL1, val);
+		} else {
+			layer0_sel = vop_read_bit(vop_dev, DSP_CTRL1,
+						  V_DSP_LAYER0_SEL(0));
+			layer1_sel = vop_read_bit(vop_dev, DSP_CTRL1,
+						  V_DSP_LAYER1_SEL(0));
+			layer2_sel = vop_read_bit(vop_dev, DSP_CTRL1,
+						  V_DSP_LAYER2_SEL(0));
+			layer3_sel = vop_read_bit(vop_dev, DSP_CTRL1,
+						  V_DSP_LAYER3_SEL(0));
+			ovl = layer3_sel * 1000 + layer2_sel * 100 +
+			    layer1_sel * 10 + layer0_sel;
+		}
+	} else {
+		ovl = -EPERM;
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return ovl;
+}
+
+static char *vop_format_to_string(int format, char *fmt)
+{
+	if (!fmt)
+		return NULL;
+
+	switch (format) {
+	case 0:
+		strcpy(fmt, "ARGB888");
+		break;
+	case 1:
+		strcpy(fmt, "RGB888");
+		break;
+	case 2:
+		strcpy(fmt, "RGB565");
+		break;
+	case 4:
+		strcpy(fmt, "YCbCr420");
+		break;
+	case 5:
+		strcpy(fmt, "YCbCr422");
+		break;
+	case 6:
+		strcpy(fmt, "YCbCr444");
+	case 8:
+		strcpy(fmt, "YUYV422");
+		break;
+	case 9:
+		strcpy(fmt, "YUYV420");
+		break;
+	case 10:
+		strcpy(fmt, "UYVY422");
+		break;
+	case 11:
+		strcpy(fmt, "UYVY420");
+		break;
+	default:
+		strcpy(fmt, "invalid\n");
+		break;
+	}
+	return fmt;
+}
+
+static ssize_t vop_get_disp_info(struct rk_lcdc_driver *dev_drv,
+				 char *buf, int win_id)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 hsync_len = screen->mode.hsync_len;
+	u16 left_margin = screen->mode.left_margin;
+	u16 vsync_len = screen->mode.vsync_len;
+	u16 upper_margin = screen->mode.upper_margin;
+	u32 h_pw_bp = hsync_len + left_margin;
+	u32 v_pw_bp = vsync_len + upper_margin;
+	u32 fmt_id;
+	char format_w0[9] = "NULL";
+	char format_w1[9] = "NULL";
+	char format_w2_0[9] = "NULL";
+	char format_w2_1[9] = "NULL";
+	char format_w2_2[9] = "NULL";
+	char format_w2_3[9] = "NULL";
+	char format_w3_0[9] = "NULL";
+	char format_w3_1[9] = "NULL";
+	char format_w3_2[9] = "NULL";
+	char format_w3_3[9] = "NULL";
+	char dsp_buf[100];
+	u32 win_ctrl, zorder, vir_info, act_info, dsp_info, dsp_st;
+	u32 y_factor, uv_factor;
+	u8 layer0_sel, layer1_sel, layer2_sel, layer3_sel;
+	u8 w0_state, w1_state, w2_state, w3_state;
+	u8 w2_0_state, w2_1_state, w2_2_state, w2_3_state;
+	u8 w3_0_state, w3_1_state, w3_2_state, w3_3_state;
+
+	u32 w0_vir_y, w0_vir_uv, w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y;
+	u32 w0_st_x = h_pw_bp, w0_st_y = v_pw_bp;
+	u32 w1_vir_y, w1_vir_uv, w1_act_x, w1_act_y, w1_dsp_x, w1_dsp_y;
+	u32 w1_st_x = h_pw_bp, w1_st_y = v_pw_bp;
+	u32 w0_y_h_fac, w0_y_v_fac, w0_uv_h_fac, w0_uv_v_fac;
+	u32 w1_y_h_fac, w1_y_v_fac, w1_uv_h_fac, w1_uv_v_fac;
+
+	u32 w2_0_vir_y, w2_1_vir_y, w2_2_vir_y, w2_3_vir_y;
+	u32 w2_0_dsp_x, w2_1_dsp_x, w2_2_dsp_x, w2_3_dsp_x;
+	u32 w2_0_dsp_y, w2_1_dsp_y, w2_2_dsp_y, w2_3_dsp_y;
+	u32 w2_0_st_x = h_pw_bp, w2_1_st_x = h_pw_bp;
+	u32 w2_2_st_x = h_pw_bp, w2_3_st_x = h_pw_bp;
+	u32 w2_0_st_y = v_pw_bp, w2_1_st_y = v_pw_bp;
+	u32 w2_2_st_y = v_pw_bp, w2_3_st_y = v_pw_bp;
+
+	u32 w3_0_vir_y, w3_1_vir_y, w3_2_vir_y, w3_3_vir_y;
+	u32 w3_0_dsp_x, w3_1_dsp_x, w3_2_dsp_x, w3_3_dsp_x;
+	u32 w3_0_dsp_y, w3_1_dsp_y, w3_2_dsp_y, w3_3_dsp_y;
+	u32 w3_0_st_x = h_pw_bp, w3_1_st_x = h_pw_bp;
+	u32 w3_2_st_x = h_pw_bp, w3_3_st_x = h_pw_bp;
+	u32 w3_0_st_y = v_pw_bp, w3_1_st_y = v_pw_bp;
+	u32 w3_2_st_y = v_pw_bp, w3_3_st_y = v_pw_bp;
+	u32 dclk_freq;
+	int size = 0;
+
+	dclk_freq = screen->mode.pixclock;
+	/*vop_reg_dump(dev_drv); */
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		zorder = vop_readl(vop_dev, DSP_CTRL1);
+		layer0_sel = (zorder & MASK(DSP_LAYER0_SEL)) >> 8;
+		layer1_sel = (zorder & MASK(DSP_LAYER1_SEL)) >> 10;
+		layer2_sel = (zorder & MASK(DSP_LAYER2_SEL)) >> 12;
+		layer3_sel = (zorder & MASK(DSP_LAYER3_SEL)) >> 14;
+		/* WIN0 */
+		win_ctrl = vop_readl(vop_dev, WIN0_CTRL0);
+		w0_state = win_ctrl & MASK(WIN0_EN);
+		fmt_id = (win_ctrl & MASK(WIN0_DATA_FMT)) >> 1;
+		fmt_id |= (win_ctrl & MASK(WIN0_YUYV)) >> 14; /* yuyv*/
+		vop_format_to_string(fmt_id, format_w0);
+		vir_info = vop_readl(vop_dev, WIN0_VIR);
+		act_info = vop_readl(vop_dev, WIN0_ACT_INFO);
+		dsp_info = vop_readl(vop_dev, WIN0_DSP_INFO);
+		dsp_st = vop_readl(vop_dev, WIN0_DSP_ST);
+		y_factor = vop_readl(vop_dev, WIN0_SCL_FACTOR_YRGB);
+		uv_factor = vop_readl(vop_dev, WIN0_SCL_FACTOR_CBR);
+		w0_vir_y = vir_info & MASK(WIN0_VIR_STRIDE);
+		w0_vir_uv = (vir_info & MASK(WIN0_VIR_STRIDE_UV)) >> 16;
+		w0_act_x = (act_info & MASK(WIN0_ACT_WIDTH)) + 1;
+		w0_act_y = ((act_info & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
+		w0_dsp_x = (dsp_info & MASK(WIN0_DSP_WIDTH)) + 1;
+		w0_dsp_y = ((dsp_info & MASK(WIN0_DSP_HEIGHT)) >> 16) + 1;
+		if (w0_state) {
+			w0_st_x = dsp_st & MASK(WIN0_DSP_XST);
+			w0_st_y = (dsp_st & MASK(WIN0_DSP_YST)) >> 16;
+		}
+		w0_y_h_fac = y_factor & MASK(WIN0_HS_FACTOR_YRGB);
+		w0_y_v_fac = (y_factor & MASK(WIN0_VS_FACTOR_YRGB)) >> 16;
+		w0_uv_h_fac = uv_factor & MASK(WIN0_HS_FACTOR_CBR);
+		w0_uv_v_fac = (uv_factor & MASK(WIN0_VS_FACTOR_CBR)) >> 16;
+
+		/* WIN1 */
+		win_ctrl = vop_readl(vop_dev, WIN1_CTRL0);
+		w1_state = win_ctrl & MASK(WIN1_EN);
+		fmt_id = (win_ctrl & MASK(WIN1_DATA_FMT)) >> 1;
+		fmt_id |= (win_ctrl & MASK(WIN1_YUYV)) >> 14; /* yuyv*/
+		vop_format_to_string(fmt_id, format_w1);
+		vir_info = vop_readl(vop_dev, WIN1_VIR);
+		act_info = vop_readl(vop_dev, WIN1_ACT_INFO);
+		dsp_info = vop_readl(vop_dev, WIN1_DSP_INFO);
+		dsp_st = vop_readl(vop_dev, WIN1_DSP_ST);
+		y_factor = vop_readl(vop_dev, WIN1_SCL_FACTOR_YRGB);
+		uv_factor = vop_readl(vop_dev, WIN1_SCL_FACTOR_CBR);
+		w1_vir_y = vir_info & MASK(WIN1_VIR_STRIDE);
+		w1_vir_uv = (vir_info & MASK(WIN1_VIR_STRIDE_UV)) >> 16;
+		w1_act_x = (act_info & MASK(WIN1_ACT_WIDTH)) + 1;
+		w1_act_y = ((act_info & MASK(WIN1_ACT_HEIGHT)) >> 16) + 1;
+		w1_dsp_x = (dsp_info & MASK(WIN1_DSP_WIDTH)) + 1;
+		w1_dsp_y = ((dsp_info & MASK(WIN1_DSP_HEIGHT)) >> 16) + 1;
+		if (w1_state) {
+			w1_st_x = dsp_st & MASK(WIN1_DSP_XST);
+			w1_st_y = (dsp_st & MASK(WIN1_DSP_YST)) >> 16;
+		}
+		w1_y_h_fac = y_factor & MASK(WIN1_HS_FACTOR_YRGB);
+		w1_y_v_fac = (y_factor & MASK(WIN1_VS_FACTOR_YRGB)) >> 16;
+		w1_uv_h_fac = uv_factor & MASK(WIN1_HS_FACTOR_CBR);
+		w1_uv_v_fac = (uv_factor & MASK(WIN1_VS_FACTOR_CBR)) >> 16;
+
+		/*WIN2 */
+		win_ctrl = vop_readl(vop_dev, WIN2_CTRL0);
+		w2_state = win_ctrl & MASK(WIN2_EN);
+		w2_0_state = (win_ctrl & 0x10) >> 4;
+		w2_1_state = (win_ctrl & 0x100) >> 8;
+		w2_2_state = (win_ctrl & 0x1000) >> 12;
+		w2_3_state = (win_ctrl & 0x10000) >> 16;
+		vir_info = vop_readl(vop_dev, WIN2_VIR0_1);
+		w2_0_vir_y = vir_info & MASK(WIN2_VIR_STRIDE0);
+		w2_1_vir_y = (vir_info & MASK(WIN2_VIR_STRIDE1)) >> 16;
+		vir_info = vop_readl(vop_dev, WIN2_VIR2_3);
+		w2_2_vir_y = vir_info & MASK(WIN2_VIR_STRIDE2);
+		w2_3_vir_y = (vir_info & MASK(WIN2_VIR_STRIDE3)) >> 16;
+
+		fmt_id = (win_ctrl & MASK(WIN2_DATA_FMT0)) >> 5;
+		vop_format_to_string(fmt_id, format_w2_0);
+		fmt_id = (win_ctrl & MASK(WIN2_DATA_FMT1)) >> 9;
+		vop_format_to_string(fmt_id, format_w2_1);
+		fmt_id = (win_ctrl & MASK(WIN2_DATA_FMT2)) >> 13;
+		vop_format_to_string(fmt_id, format_w2_2);
+		fmt_id = (win_ctrl & MASK(WIN2_DATA_FMT3)) >> 17;
+		vop_format_to_string(fmt_id, format_w2_3);
+
+		dsp_info = vop_readl(vop_dev, WIN2_DSP_INFO0);
+		dsp_st = vop_readl(vop_dev, WIN2_DSP_ST0);
+		w2_0_dsp_x = (dsp_info & MASK(WIN2_DSP_WIDTH0)) + 1;
+		w2_0_dsp_y = ((dsp_info & MASK(WIN2_DSP_HEIGHT0)) >> 16) + 1;
+		if (w2_0_state) {
+			w2_0_st_x = dsp_st & MASK(WIN2_DSP_XST0);
+			w2_0_st_y = (dsp_st & MASK(WIN2_DSP_YST0)) >> 16;
+		}
+		dsp_info = vop_readl(vop_dev, WIN2_DSP_INFO1);
+		dsp_st = vop_readl(vop_dev, WIN2_DSP_ST1);
+		w2_1_dsp_x = (dsp_info & MASK(WIN2_DSP_WIDTH1)) + 1;
+		w2_1_dsp_y = ((dsp_info & MASK(WIN2_DSP_HEIGHT1)) >> 16) + 1;
+		if (w2_1_state) {
+			w2_1_st_x = dsp_st & MASK(WIN2_DSP_XST1);
+			w2_1_st_y = (dsp_st & MASK(WIN2_DSP_YST1)) >> 16;
+		}
+		dsp_info = vop_readl(vop_dev, WIN2_DSP_INFO2);
+		dsp_st = vop_readl(vop_dev, WIN2_DSP_ST2);
+		w2_2_dsp_x = (dsp_info & MASK(WIN2_DSP_WIDTH2)) + 1;
+		w2_2_dsp_y = ((dsp_info & MASK(WIN2_DSP_HEIGHT2)) >> 16) + 1;
+		if (w2_2_state) {
+			w2_2_st_x = dsp_st & MASK(WIN2_DSP_XST2);
+			w2_2_st_y = (dsp_st & MASK(WIN2_DSP_YST2)) >> 16;
+		}
+		dsp_info = vop_readl(vop_dev, WIN2_DSP_INFO3);
+		dsp_st = vop_readl(vop_dev, WIN2_DSP_ST3);
+		w2_3_dsp_x = (dsp_info & MASK(WIN2_DSP_WIDTH3)) + 1;
+		w2_3_dsp_y = ((dsp_info & MASK(WIN2_DSP_HEIGHT3)) >> 16) + 1;
+		if (w2_3_state) {
+			w2_3_st_x = dsp_st & MASK(WIN2_DSP_XST3);
+			w2_3_st_y = (dsp_st & MASK(WIN2_DSP_YST3)) >> 16;
+		}
+
+		/*WIN3 */
+		win_ctrl = vop_readl(vop_dev, WIN3_CTRL0);
+		w3_state = win_ctrl & MASK(WIN3_EN);
+		w3_0_state = (win_ctrl & 0x10) >> 4;
+		w3_1_state = (win_ctrl & 0x100) >> 8;
+		w3_2_state = (win_ctrl & 0x1000) >> 12;
+		w3_3_state = (win_ctrl & 0x10000) >> 16;
+		vir_info = vop_readl(vop_dev, WIN3_VIR0_1);
+		w3_0_vir_y = vir_info & MASK(WIN3_VIR_STRIDE0);
+		w3_1_vir_y = (vir_info & MASK(WIN3_VIR_STRIDE1)) >> 16;
+		vir_info = vop_readl(vop_dev, WIN3_VIR2_3);
+		w3_2_vir_y = vir_info & MASK(WIN3_VIR_STRIDE2);
+		w3_3_vir_y = (vir_info & MASK(WIN3_VIR_STRIDE3)) >> 16;
+
+		fmt_id = (win_ctrl & MASK(WIN3_DATA_FMT0)) >> 5;
+		vop_format_to_string(fmt_id, format_w3_0);
+		fmt_id = (win_ctrl & MASK(WIN3_DATA_FMT1)) >> 9;
+		vop_format_to_string(fmt_id, format_w3_1);
+		fmt_id = (win_ctrl & MASK(WIN3_DATA_FMT2)) >> 13;
+		vop_format_to_string(fmt_id, format_w3_2);
+		fmt_id = (win_ctrl & MASK(WIN3_DATA_FMT3)) >> 17;
+		vop_format_to_string(fmt_id, format_w3_3);
+
+		dsp_info = vop_readl(vop_dev, WIN3_DSP_INFO0);
+		dsp_st = vop_readl(vop_dev, WIN3_DSP_ST0);
+		w3_0_dsp_x = (dsp_info & MASK(WIN3_DSP_WIDTH0)) + 1;
+		w3_0_dsp_y = ((dsp_info & MASK(WIN3_DSP_HEIGHT0)) >> 16) + 1;
+		if (w3_0_state) {
+			w3_0_st_x = dsp_st & MASK(WIN3_DSP_XST0);
+			w3_0_st_y = (dsp_st & MASK(WIN3_DSP_YST0)) >> 16;
+		}
+		dsp_info = vop_readl(vop_dev, WIN3_DSP_INFO1);
+		dsp_st = vop_readl(vop_dev, WIN3_DSP_ST1);
+		w3_1_dsp_x = (dsp_info & MASK(WIN3_DSP_WIDTH1)) + 1;
+		w3_1_dsp_y = ((dsp_info & MASK(WIN3_DSP_HEIGHT1)) >> 16) + 1;
+		if (w3_1_state) {
+			w3_1_st_x = dsp_st & MASK(WIN3_DSP_XST1);
+			w3_1_st_y = (dsp_st & MASK(WIN3_DSP_YST1)) >> 16;
+		}
+		dsp_info = vop_readl(vop_dev, WIN3_DSP_INFO2);
+		dsp_st = vop_readl(vop_dev, WIN3_DSP_ST2);
+		w3_2_dsp_x = (dsp_info & MASK(WIN3_DSP_WIDTH2)) + 1;
+		w3_2_dsp_y = ((dsp_info & MASK(WIN3_DSP_HEIGHT2)) >> 16) + 1;
+		if (w3_2_state) {
+			w3_2_st_x = dsp_st & MASK(WIN3_DSP_XST2);
+			w3_2_st_y = (dsp_st & MASK(WIN3_DSP_YST2)) >> 16;
+		}
+		dsp_info = vop_readl(vop_dev, WIN3_DSP_INFO3);
+		dsp_st = vop_readl(vop_dev, WIN3_DSP_ST3);
+		w3_3_dsp_x = (dsp_info & MASK(WIN3_DSP_WIDTH3)) + 1;
+		w3_3_dsp_y = ((dsp_info & MASK(WIN3_DSP_HEIGHT3)) >> 16) + 1;
+		if (w3_3_state) {
+			w3_3_st_x = dsp_st & MASK(WIN3_DSP_XST3);
+			w3_3_st_y = (dsp_st & MASK(WIN3_DSP_YST3)) >> 16;
+		}
+	} else {
+		spin_unlock(&vop_dev->reg_lock);
+		return -EPERM;
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	size += snprintf(dsp_buf, 80,
+		"z-order:\n  win[%d]\n  win[%d]\n  win[%d]\n  win[%d]\n",
+		layer3_sel, layer2_sel, layer1_sel, layer0_sel);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	/* win0 */
+	size += snprintf(dsp_buf, 80,
+		 "win0:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
+		 w0_state, format_w0, w0_vir_y, w0_vir_uv);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
+		 w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
+		 w0_st_x - h_pw_bp, w0_st_y - v_pw_bp, w0_y_h_fac, w0_y_v_fac);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
+		 w0_uv_h_fac, w0_uv_v_fac, vop_readl(vop_dev, WIN0_YRGB_MST),
+		 vop_readl(vop_dev, WIN0_CBR_MST));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/* win1 */
+	size += snprintf(dsp_buf, 80,
+		 "win1:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
+		 w1_state, format_w1, w1_vir_y, w1_vir_uv);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
+		 w1_act_x, w1_act_y, w1_dsp_x, w1_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
+		 w1_st_x - h_pw_bp, w1_st_y - v_pw_bp, w1_y_h_fac, w1_y_v_fac);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
+		 w1_uv_h_fac, w1_uv_v_fac, vop_readl(vop_dev, WIN1_YRGB_MST),
+		 vop_readl(vop_dev, WIN1_CBR_MST));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*win2*/
+	size += snprintf(dsp_buf, 80,
+		 "win2:\n  state:%d\n",
+		 w2_state);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	/*area 0*/
+	size += snprintf(dsp_buf, 80,
+		 "  area0: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w2_0_state, format_w2_0, w2_0_dsp_x, w2_0_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w2_0_st_x - h_pw_bp, w2_0_st_y - v_pw_bp,
+		 vop_readl(vop_dev, WIN2_MST0));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 1*/
+	size += snprintf(dsp_buf, 80,
+		 "  area1: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w2_1_state, format_w2_1, w2_1_dsp_x, w2_1_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w2_1_st_x - h_pw_bp, w2_1_st_y - v_pw_bp,
+		 vop_readl(vop_dev, WIN2_MST1));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 2*/
+	size += snprintf(dsp_buf, 80,
+		 "  area2: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w2_2_state, format_w2_2, w2_2_dsp_x, w2_2_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w2_2_st_x - h_pw_bp, w2_2_st_y - v_pw_bp,
+		 vop_readl(vop_dev, WIN2_MST2));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 3*/
+	size += snprintf(dsp_buf, 80,
+		 "  area3: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w2_3_state, format_w2_3, w2_3_dsp_x, w2_3_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w2_3_st_x - h_pw_bp, w2_3_st_y - v_pw_bp,
+		 vop_readl(vop_dev, WIN2_MST3));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*win3*/
+	size += snprintf(dsp_buf, 80,
+		 "win3:\n  state:%d\n",
+		 w3_state);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	/*area 0*/
+	size += snprintf(dsp_buf, 80,
+		 "  area0: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w3_0_state, format_w3_0, w3_0_dsp_x, w3_0_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w3_0_st_x - h_pw_bp, w3_0_st_y - v_pw_bp,
+		 vop_readl(vop_dev, WIN3_MST0));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 1*/
+	size += snprintf(dsp_buf, 80,
+		 "  area1: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w3_1_state, format_w3_1, w3_1_dsp_x, w3_1_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w3_1_st_x - h_pw_bp, w3_1_st_y - v_pw_bp,
+		 vop_readl(vop_dev, WIN3_MST1));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 2*/
+	size += snprintf(dsp_buf, 80,
+		 "  area2: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w3_2_state, format_w3_2, w3_2_dsp_x, w3_2_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w3_2_st_x - h_pw_bp, w3_2_st_y - v_pw_bp,
+		 vop_readl(vop_dev, WIN3_MST2));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 3*/
+	size += snprintf(dsp_buf, 80,
+		 "  area3: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w3_3_state, format_w3_3, w3_3_dsp_x, w3_3_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w3_3_st_x - h_pw_bp, w3_3_st_y - v_pw_bp,
+		 vop_readl(vop_dev, WIN3_MST3));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	return size;
+}
+
+static int vop_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps, bool set)
+{
+	struct vop_device *vop_dev =
+		container_of(dev_drv, struct vop_device, driver);
+	struct rk_fb_vsync *vsync = &dev_drv->vsync_info;
+	int step_fps, old_fps;
+	u32 h_total, v_total;
+	unsigned long dclk;
+	u64 val;
+	int ret;
+
+	dclk = clk_get_rate(vop_dev->dclk);
+
+	spin_lock(&vop_dev->reg_lock);
+
+	if (!vop_dev->clk_on) {
+		spin_unlock(&vop_dev->reg_lock);
+		return 0;
+	}
+
+	val = vop_readl(vop_dev, DSP_HTOTAL_HS_END);
+	h_total = (val & MASK(DSP_HTOTAL)) >> 16;
+
+	val = vop_readl(vop_dev, DSP_VTOTAL_VS_END);
+	v_total = (val & MASK(DSP_VTOTAL)) >> 16;
+
+	spin_unlock(&vop_dev->reg_lock);
+
+	old_fps = div_u64(dclk, v_total * h_total);
+
+	if (!set)
+		return old_fps;
+
+	/*
+	 * Direct change fps to dest fps would may screen flash,
+	 * Every frame change one step fps is safe, screen flash
+	 * disappear.
+	 */
+	step_fps = old_fps;
+	while (step_fps != fps) {
+		ktime_t timestamp = vsync->timestamp;
+
+		if (step_fps > fps)
+			step_fps--;
+		else
+			step_fps++;
+		spin_lock(&vop_dev->reg_lock);
+		if (!vop_dev->clk_on) {
+			spin_unlock(&vop_dev->reg_lock);
+			break;
+		}
+		h_total = div_u64(dclk, step_fps * v_total);
+		val = V_DSP_HTOTAL(h_total);
+		vop_msk_reg(vop_dev, DSP_HTOTAL_HS_END, val);
+		vop_cfg_done(vop_dev);
+		spin_unlock(&vop_dev->reg_lock);
+
+		ret = wait_event_interruptible_timeout(vsync->wait,
+			!ktime_equal(timestamp, vsync->timestamp) &&
+			(vsync->active > 0 || vsync->irq_stop),
+			msecs_to_jiffies(50));
+	}
+
+	dev_info(dev_drv->dev, "%s:dclk:%lu, htotal=%d, vtatol=%d, fps:%d\n",
+		 __func__, dclk, h_total, v_total, fps);
+
+	return fps;
+}
+
+static int vop_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
+{
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (order == FB_DEFAULT_ORDER)
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3_FB4_HWC;
+	dev_drv->fb4_win_id = order / 10000;
+	dev_drv->fb3_win_id = (order / 1000) % 10;
+	dev_drv->fb2_win_id = (order / 100) % 10;
+	dev_drv->fb1_win_id = (order / 10) % 10;
+	dev_drv->fb0_win_id = order % 10;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return 0;
+}
+
+static int vop_get_win_id(struct rk_lcdc_driver *dev_drv, const char *id)
+{
+	int win_id = 0;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (!strcmp(id, "fb0") || !strcmp(id, "fb5"))
+		win_id = dev_drv->fb0_win_id;
+	else if (!strcmp(id, "fb1") || !strcmp(id, "fb6"))
+		win_id = dev_drv->fb1_win_id;
+	else if (!strcmp(id, "fb2") || !strcmp(id, "fb7"))
+		win_id = dev_drv->fb2_win_id;
+	else if (!strcmp(id, "fb3") || !strcmp(id, "fb8"))
+		win_id = dev_drv->fb3_win_id;
+	else if (!strcmp(id, "fb4") || !strcmp(id, "fb9"))
+		win_id = dev_drv->fb4_win_id;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return win_id;
+}
+
+static int vop_config_done(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	int i, fbdc_en = 0;
+	u64 val;
+	struct rk_lcdc_win *win = NULL;
+
+	spin_lock(&vop_dev->reg_lock);
+	vop_post_cfg(dev_drv);
+	vop_msk_reg(vop_dev, SYS_CTRL, V_VOP_STANDBY_EN(vop_dev->standby));
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		win = dev_drv->win[i];
+		vop_alpha_cfg(dev_drv, i);
+		fbdc_en |= win->area[0].fbdc_en;
+		vop_dev->atv_layer_cnt &= ~(1 << win->id);
+		vop_dev->atv_layer_cnt |= (win->state << win->id);
+		if ((win->state == 0) && (win->last_state == 1)) {
+			switch (win->id) {
+			case 0:
+				val = V_WIN0_EN(0);
+				vop_msk_reg(vop_dev, WIN0_CTRL0, val);
+				break;
+			case 1:
+				val = V_WIN1_EN(0);
+				vop_msk_reg(vop_dev, WIN1_CTRL0, val);
+				break;
+			case 2:
+				val = V_WIN2_EN(0) | V_WIN2_MST0_EN(0) |
+				    V_WIN2_MST1_EN(0) |
+				    V_WIN2_MST2_EN(0) | V_WIN2_MST3_EN(0);
+				vop_msk_reg(vop_dev, WIN2_CTRL0, val);
+				break;
+			case 3:
+				val = V_WIN3_EN(0) | V_WIN3_MST0_EN(0) |
+				    V_WIN3_MST1_EN(0) |
+				    V_WIN3_MST2_EN(0) | V_WIN3_MST3_EN(0);
+				vop_msk_reg(vop_dev, WIN3_CTRL0, val);
+				break;
+			case 4:
+				val = V_HWC_EN(0);
+				vop_msk_reg(vop_dev, HWC_CTRL0, val);
+				break;
+			default:
+				break;
+			}
+		}
+		win->last_state = win->state;
+	}
+	if (VOP_CHIP(vop_dev) == VOP_RK3399) {
+		val = V_VOP_FBDC_EN(fbdc_en);
+		vop_msk_reg(vop_dev, AFBCD0_CTRL, val);
+	}
+	vop_cfg_done(vop_dev);
+	spin_unlock(&vop_dev->reg_lock);
+	return 0;
+}
+
+static int vop_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	spin_lock(&vop_dev->reg_lock);
+	vop_msk_reg(vop_dev, SYS_CTRL, V_DIRECT_PATH_EN(open));
+	vop_cfg_done(vop_dev);
+	spin_unlock(&vop_dev->reg_lock);
+	return 0;
+}
+
+static int vop_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev = container_of(dev_drv,
+						    struct vop_device, driver);
+	spin_lock(&vop_dev->reg_lock);
+	vop_msk_reg(vop_dev, SYS_CTRL, V_DIRECT_PATH_LAYER_SEL(win_id));
+	vop_cfg_done(vop_dev);
+	spin_unlock(&vop_dev->reg_lock);
+	return 0;
+}
+
+static int vop_dpi_status(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	int ovl;
+
+	spin_lock(&vop_dev->reg_lock);
+	ovl = vop_read_bit(vop_dev, SYS_CTRL, V_DIRECT_PATH_EN(0));
+	spin_unlock(&vop_dev->reg_lock);
+	return ovl;
+}
+
+static int vop_set_irq_to_cpu(struct rk_lcdc_driver *dev_drv, int enable)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	if (enable)
+		enable_irq(vop_dev->irq);
+	else
+		disable_irq_nosync(vop_dev->irq);
+	return 0;
+}
+
+int vop_poll_vblank(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	u32 int_reg;
+	int ret;
+
+	if (vop_dev->clk_on && (!dev_drv->suspend_flag)) {
+		int_reg = vop_readl(vop_dev, INTR_STATUS0);
+		if (int_reg & INTR_LINE_FLAG0) {
+			vop_dev->driver.frame_time.last_framedone_t =
+			    vop_dev->driver.frame_time.framedone_t;
+			vop_dev->driver.frame_time.framedone_t = cpu_clock(0);
+			vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_LINE_FLAG0,
+					INTR_LINE_FLAG0);
+			ret = RK_LF_STATUS_FC;
+		} else {
+			ret = RK_LF_STATUS_FR;
+		}
+	} else {
+		ret = RK_LF_STATUS_NC;
+	}
+
+	return ret;
+}
+
+static int vop_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
+			    unsigned int dsp_addr[][4])
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		dsp_addr[0][0] = vop_readl(vop_dev, WIN0_YRGB_MST);
+		dsp_addr[1][0] = vop_readl(vop_dev, WIN1_YRGB_MST);
+		dsp_addr[2][0] = vop_readl(vop_dev, WIN2_MST0);
+		dsp_addr[2][1] = vop_readl(vop_dev, WIN2_MST1);
+		dsp_addr[2][2] = vop_readl(vop_dev, WIN2_MST2);
+		dsp_addr[2][3] = vop_readl(vop_dev, WIN2_MST3);
+		dsp_addr[3][0] = vop_readl(vop_dev, WIN3_MST0);
+		dsp_addr[3][1] = vop_readl(vop_dev, WIN3_MST1);
+		dsp_addr[3][2] = vop_readl(vop_dev, WIN3_MST2);
+		dsp_addr[3][3] = vop_readl(vop_dev, WIN3_MST3);
+		dsp_addr[4][0] = vop_readl(vop_dev, HWC_MST);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	return 0;
+}
+
+
+int vop_update_pwm(int bl_pwm_period, int bl_pwm_duty)
+{
+	/*
+	 * TODO:
+	 * pwm_period_hpr = bl_pwm_period;
+	 * pwm_duty_lpr = bl_pwm_duty;
+	 * pr_info("bl_pwm_period_hpr = 0x%x, bl_pwm_duty_lpr = 0x%x\n",
+	 * bl_pwm_period, bl_pwm_duty);
+	 */
+
+	return 0;
+}
+
+/*
+ *  a:[-30~0]:
+ *    sin_hue = sin(a)*256 +0x100;
+ *    cos_hue = cos(a)*256;
+ *  a:[0~30]
+ *    sin_hue = sin(a)*256;
+ *    cos_hue = cos(a)*256;
+ */
+static int vop_get_bcsh_hue(struct rk_lcdc_driver *dev_drv, bcsh_hue_mode mode)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	u32 val = 0;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		val = vop_readl(vop_dev, BCSH_H);
+		switch (mode) {
+		case H_SIN:
+			val &= MASK(SIN_HUE);
+			break;
+		case H_COS:
+			val &= MASK(COS_HUE);
+			val >>= 16;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return val;
+}
+
+static int vop_set_dsp_cabc(struct rk_lcdc_driver *dev_drv, int mode,
+			    int calc, int up, int down, int global)
+{
+	struct vop_device *vop_dev =
+			container_of(dev_drv, struct vop_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u32 total_pixel, calc_pixel, stage_up, stage_down;
+	u32 pixel_num, global_dn;
+	u64 val = 0;
+	ktime_t timestamp;
+	int ret = 0;
+
+	if (!vop_dev->cabc_lut_addr_base) {
+		pr_err("vop chip[%d] not supoort cabc\n", VOP_CHIP(vop_dev));
+		return 0;
+	}
+
+	if (!screen->cabc_lut) {
+		pr_err("screen cabc lut not config, so not open cabc\n");
+		return 0;
+	}
+
+	if (!mode) {
+		if (VOP_CHIP(vop_dev) == VOP_RK3399) {
+			calc = 0;
+			up = 256;
+			down = 255;
+			global = 0;
+		} else {
+			spin_lock(&vop_dev->reg_lock);
+			if (vop_dev->clk_on) {
+				vop_msk_reg(vop_dev, CABC_CTRL0,
+					    V_CABC_EN(0) | V_CABC_HANDLE_EN(0));
+				vop_cfg_done(vop_dev);
+			}
+			pr_info("mode = 0, close cabc\n");
+			spin_unlock(&vop_dev->reg_lock);
+			return 0;
+		}
+	}
+
+	total_pixel = screen->mode.xres * screen->mode.yres;
+	pixel_num = 1000 - calc;
+	calc_pixel = (total_pixel * pixel_num) / 1000;
+	stage_up = up;
+	stage_down = down;
+	global_dn = global;
+	pr_info("enable cabc:mode=%d, calc=%d, up=%d, down=%d, global=%d\n",
+		mode, calc, stage_up, stage_down, global_dn);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		val = V_PWM_CONFIG_MODE(STAGE_BY_STAGE) |
+			V_CABC_CALC_PIXEL_NUM(calc_pixel);
+		vop_msk_reg(vop_dev, CABC_CTRL0, val);
+
+		val = V_CABC_LUT_EN(1) | V_CABC_TOTAL_NUM(total_pixel);
+		vop_msk_reg(vop_dev, CABC_CTRL1, val);
+
+		val = V_CABC_STAGE_DOWN(stage_down) |
+			V_CABC_STAGE_UP(stage_up) |
+			V_CABC_STAGE_UP_MODE(0) | V_MAX_SCALE_CFG_VALUE(1) |
+			V_MAX_SCALE_CFG_ENABLE(0);
+		vop_msk_reg(vop_dev, CABC_CTRL2, val);
+
+		val = V_CABC_GLOBAL_DN(global_dn) |
+			V_CABC_GLOBAL_DN_LIMIT_EN(1);
+		vop_msk_reg(vop_dev, CABC_CTRL3, val);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	timestamp = dev_drv->vsync_info.timestamp;
+	ret = wait_event_interruptible_timeout(dev_drv->vsync_info.wait,
+			!ktime_equal(timestamp, dev_drv->vsync_info.timestamp),
+			msecs_to_jiffies(50));
+	if (ret < 0)
+		return ret;
+	else if (ret == 0)
+		pr_err("%s wait vsync time out\n", __func__);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		val = V_CABC_EN(1) | V_CABC_HANDLE_EN(1);
+		vop_msk_reg(vop_dev, CABC_CTRL0, val);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,
+			    int sin_hue, int cos_hue)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	u64 val;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		val = V_SIN_HUE(sin_hue) | V_COS_HUE(cos_hue);
+		vop_msk_reg(vop_dev, BCSH_H, val);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
+			    bcsh_bcs_mode mode, int value)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	u64 val = 0;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		switch (mode) {
+		case BRIGHTNESS:
+			/*from 0 to 255,typical is 128 */
+			if (value < 0x80)
+				value += 0x80;
+			else if (value >= 0x80)
+				value = value - 0x80;
+			val = V_BRIGHTNESS(value);
+			break;
+		case CONTRAST:
+			/*from 0 to 510,typical is 256 */
+			val = V_CONTRAST(value);
+			break;
+		case SAT_CON:
+			/*from 0 to 1015,typical is 256 */
+			val = V_SAT_CON(value);
+			break;
+		default:
+			break;
+		}
+		vop_msk_reg(vop_dev, BCSH_BCS, val);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return val;
+}
+
+static int vop_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv, bcsh_bcs_mode mode)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	u64 val = 0;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		val = vop_readl(vop_dev, BCSH_BCS);
+		switch (mode) {
+		case BRIGHTNESS:
+			val &= MASK(BRIGHTNESS);
+			if (val > 0x80)
+				val -= 0x80;
+			else
+				val += 0x80;
+			break;
+		case CONTRAST:
+			val &= MASK(CONTRAST);
+			val >>= 8;
+			break;
+		case SAT_CON:
+			val &= MASK(SAT_CON);
+			val >>= 20;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	return val;
+}
+
+static int vop_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (vop_dev->clk_on) {
+		if (open) {
+			vop_writel(vop_dev, BCSH_COLOR_BAR, 0x1);
+			vop_writel(vop_dev, BCSH_BCS, 0xd0010000);
+			vop_writel(vop_dev, BCSH_H, 0x01000000);
+			dev_drv->bcsh.enable = 1;
+		} else {
+			vop_msk_reg(vop_dev, BCSH_COLOR_BAR, V_BCSH_EN(0));
+			dev_drv->bcsh.enable = 0;
+		}
+		vop_bcsh_path_sel(dev_drv);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable)
+{
+	if (!enable || !dev_drv->bcsh.enable) {
+		vop_open_bcsh(dev_drv, false);
+		return 0;
+	}
+
+	if (dev_drv->bcsh.brightness <= 255 ||
+	    dev_drv->bcsh.contrast <= 510 ||
+	    dev_drv->bcsh.sat_con <= 1015 ||
+	    (dev_drv->bcsh.sin_hue <= 511 && dev_drv->bcsh.cos_hue <= 511)) {
+		vop_open_bcsh(dev_drv, true);
+		if (dev_drv->bcsh.brightness <= 255)
+			vop_set_bcsh_bcs(dev_drv, BRIGHTNESS,
+					 dev_drv->bcsh.brightness);
+		if (dev_drv->bcsh.contrast <= 510)
+			vop_set_bcsh_bcs(dev_drv, CONTRAST,
+					 dev_drv->bcsh.contrast);
+		if (dev_drv->bcsh.sat_con <= 1015)
+			vop_set_bcsh_bcs(dev_drv, SAT_CON,
+					 dev_drv->bcsh.sat_con);
+		if (dev_drv->bcsh.sin_hue <= 511 &&
+		    dev_drv->bcsh.cos_hue <= 511)
+			vop_set_bcsh_hue(dev_drv, dev_drv->bcsh.sin_hue,
+					 dev_drv->bcsh.cos_hue);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused
+vop_dsp_black(struct rk_lcdc_driver *dev_drv, int enable)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	if (enable) {
+		spin_lock(&vop_dev->reg_lock);
+		if (likely(vop_dev->clk_on)) {
+			vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLACK_EN(1));
+			vop_cfg_done(vop_dev);
+		}
+		spin_unlock(&vop_dev->reg_lock);
+	} else {
+		spin_lock(&vop_dev->reg_lock);
+		if (likely(vop_dev->clk_on)) {
+			vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLACK_EN(0));
+
+			vop_cfg_done(vop_dev);
+		}
+		spin_unlock(&vop_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int vop_backlight_close(struct rk_lcdc_driver *dev_drv, int enable)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+	vop_get_backlight_device(dev_drv);
+
+	if (enable) {
+		/* close the backlight */
+		if (vop_dev->backlight) {
+			vop_dev->backlight->props.power = FB_BLANK_POWERDOWN;
+			backlight_update_status(vop_dev->backlight);
+		}
+		if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+			dev_drv->trsm_ops->disable();
+	} else {
+		if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+			dev_drv->trsm_ops->enable();
+		msleep(100);
+		/* open the backlight */
+		if (vop_dev->backlight) {
+			vop_dev->backlight->props.power = FB_BLANK_UNBLANK;
+			backlight_update_status(vop_dev->backlight);
+		}
+	}
+
+	return 0;
+}
+
+static int vop_set_overscan(struct rk_lcdc_driver *dev_drv,
+			    struct overscan *overscan)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+	/*vop_post_cfg(dev_drv);*/
+
+	return 0;
+}
+
+static int vop_extern_func(struct rk_lcdc_driver *dev_drv, int cmd)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+	u64 val;
+
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+
+	switch (cmd) {
+	case UPDATE_CABC_PWM:
+		vop_cfg_done(vop_dev);
+		break;
+	case SET_DSP_MIRROR:
+		val = V_DSP_X_MIR_EN(dev_drv->cur_screen->x_mirror) |
+			V_DSP_Y_MIR_EN(dev_drv->cur_screen->y_mirror);
+		vop_msk_reg(vop_dev, DSP_CTRL0, val);
+		pr_info("%s: xmirror: %d, ymirror: %d\n",
+			__func__, dev_drv->cur_screen->x_mirror,
+			dev_drv->cur_screen->y_mirror);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static struct rk_lcdc_drv_ops lcdc_drv_ops = {
+	.open = vop_open,
+	.win_direct_en = vop_win_direct_en,
+	.load_screen = vop_load_screen,
+	.get_dspbuf_info = vop_get_dspbuf_info,
+	.post_dspbuf = vop_post_dspbuf,
+	.set_par = vop_set_par,
+	.pan_display = vop_pan_display,
+	.set_wb = vop_set_writeback,
+	.direct_set_addr = vop_direct_set_win_addr,
+	/*.lcdc_reg_update = vop_reg_update,*/
+	.blank = vop_blank,
+	.ioctl = vop_ioctl,
+	.suspend = vop_early_suspend,
+	.resume = vop_early_resume,
+	.get_win_state = vop_get_win_state,
+	.area_support_num = vop_get_area_num,
+	.ovl_mgr = vop_ovl_mgr,
+	.get_disp_info = vop_get_disp_info,
+	.fps_mgr = vop_fps_mgr,
+	.fb_get_win_id = vop_get_win_id,
+	.fb_win_remap = vop_fb_win_remap,
+	.poll_vblank = vop_poll_vblank,
+	.dpi_open = vop_dpi_open,
+	.dpi_win_sel = vop_dpi_win_sel,
+	.dpi_status = vop_dpi_status,
+	.get_dsp_addr = vop_get_dsp_addr,
+	.set_dsp_lut = vop_set_lut,
+	.set_cabc_lut = vop_set_cabc,
+	.set_dsp_cabc = vop_set_dsp_cabc,
+	.set_dsp_bcsh_hue = vop_set_bcsh_hue,
+	.set_dsp_bcsh_bcs = vop_set_bcsh_bcs,
+	.get_dsp_bcsh_hue = vop_get_bcsh_hue,
+	.get_dsp_bcsh_bcs = vop_get_bcsh_bcs,
+	.open_bcsh = vop_open_bcsh,
+	.dump_reg = vop_reg_dump,
+	.cfg_done = vop_config_done,
+	.set_irq_to_cpu = vop_set_irq_to_cpu,
+	/*.dsp_black = vop_dsp_black,*/
+	.backlight_close = vop_backlight_close,
+	.mmu_en    = vop_mmu_en,
+	.set_overscan   = vop_set_overscan,
+	.extern_func	= vop_extern_func,
+};
+
+static irqreturn_t vop_isr(int irq, void *dev_id)
+{
+	struct vop_device *vop_dev = (struct vop_device *)dev_id;
+	ktime_t timestamp = ktime_get();
+	u32 intr_status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&vop_dev->irq_lock, flags);
+
+	intr_status = vop_readl(vop_dev, INTR_STATUS0);
+	vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_MASK, intr_status);
+
+	spin_unlock_irqrestore(&vop_dev->irq_lock, flags);
+	/* This is expected for vop iommu irqs, since the irq is shared */
+	if (!intr_status)
+		return IRQ_NONE;
+
+	if (intr_status & INTR_FS) {
+		timestamp = ktime_get();
+		if (vop_dev->driver.wb_data.state) {
+			u32 wb_status;
+
+			spin_lock_irqsave(&vop_dev->irq_lock, flags);
+			wb_status = vop_read_bit(vop_dev, WB_CTRL0, V_WB_EN(0));
+
+			if (wb_status)
+				vop_clr_bit(vop_dev, WB_CTRL0, V_WB_EN(0));
+
+			vop_cfg_done(vop_dev);
+			vop_dev->driver.wb_data.state = 0;
+			spin_unlock_irqrestore(&vop_dev->irq_lock, flags);
+		}
+		vop_dev->driver.vsync_info.timestamp = timestamp;
+		wake_up_interruptible_all(&vop_dev->driver.vsync_info.wait);
+		intr_status &= ~INTR_FS;
+	}
+
+	if (intr_status & INTR_LINE_FLAG0)
+		intr_status &= ~INTR_LINE_FLAG0;
+
+	if (intr_status & INTR_LINE_FLAG1)
+		intr_status &= ~INTR_LINE_FLAG1;
+
+	if (intr_status & INTR_FS_NEW)
+		intr_status &= ~INTR_FS_NEW;
+
+	if (intr_status & INTR_BUS_ERROR) {
+		intr_status &= ~INTR_BUS_ERROR;
+		dev_warn_ratelimited(vop_dev->dev, "bus error!");
+	}
+
+	if (intr_status & INTR_WIN0_EMPTY) {
+		intr_status &= ~INTR_WIN0_EMPTY;
+		dev_warn_ratelimited(vop_dev->dev, "intr win0 empty!");
+	}
+
+	if (intr_status & INTR_WIN1_EMPTY) {
+		intr_status &= ~INTR_WIN1_EMPTY;
+		dev_warn_ratelimited(vop_dev->dev, "intr win1 empty!");
+	}
+
+	if (intr_status & INTR_HWC_EMPTY) {
+		intr_status &= ~INTR_HWC_EMPTY;
+		dev_warn_ratelimited(vop_dev->dev, "intr hwc empty!");
+	}
+
+	if (intr_status & INTR_POST_BUF_EMPTY) {
+		intr_status &= ~INTR_POST_BUF_EMPTY;
+		dev_warn_ratelimited(vop_dev->dev, "intr post buf empty!");
+	}
+
+	if (intr_status)
+		dev_err(vop_dev->dev, "Unknown VOP IRQs: %#02x\n", intr_status);
+
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_PM)
+static int vop_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int vop_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define vop_suspend NULL
+#define vop_resume  NULL
+#endif
+
+static int vop_parse_dt(struct vop_device *vop_dev)
+{
+	struct device_node *np = vop_dev->dev->of_node;
+	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
+	int val;
+
+	if (of_property_read_u32(np, "rockchip,prop", &val))
+		vop_dev->prop = PRMRY;	/*default set it as primary */
+	else
+		vop_dev->prop = val;
+
+	if (of_property_read_u32(np, "rockchip,mirror", &val))
+		dev_drv->rotate_mode = NO_MIRROR;
+	else
+		dev_drv->rotate_mode = val;
+
+	if (of_property_read_u32(np, "rockchip,cabc_mode", &val))
+		dev_drv->cabc_mode = 0;	/* default set close cabc */
+	else
+		dev_drv->cabc_mode = val;
+
+	if (of_property_read_u32(np, "rockchip,pwr18", &val))
+		/*default set it as 3.xv power supply */
+		vop_dev->pwr18 = false;
+	else
+		vop_dev->pwr18 = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
+		dev_drv->fb_win_map = FB_DEFAULT_ORDER;
+	else
+		dev_drv->fb_win_map = val;
+
+	if (of_property_read_u32(np, "rockchip,bcsh-en", &val))
+		dev_drv->bcsh.enable = false;
+	else
+		dev_drv->bcsh.enable = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,brightness", &val))
+		dev_drv->bcsh.brightness = 0xffff;
+	else
+		dev_drv->bcsh.brightness = val;
+
+	if (of_property_read_u32(np, "rockchip,contrast", &val))
+		dev_drv->bcsh.contrast = 0xffff;
+	else
+		dev_drv->bcsh.contrast = val;
+
+	if (of_property_read_u32(np, "rockchip,sat-con", &val))
+		dev_drv->bcsh.sat_con = 0xffff;
+	else
+		dev_drv->bcsh.sat_con = val;
+
+	if (of_property_read_u32(np, "rockchip,hue", &val)) {
+		dev_drv->bcsh.sin_hue = 0xffff;
+		dev_drv->bcsh.cos_hue = 0xffff;
+	} else {
+		dev_drv->bcsh.sin_hue = val & 0xff;
+		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
+	}
+
+	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
+		dev_drv->iommu_enabled = 0;
+	else
+		dev_drv->iommu_enabled = val;
+
+	if (of_property_read_u32(np, "rockchip,dsp_mode", &val))
+		dev_drv->dsp_mode = DEFAULT_MODE;
+	else
+		dev_drv->dsp_mode = val;
+
+	return 0;
+}
+
+static struct platform_device *rk322x_pdev;
+
+int vop_register_dmc(void)
+{
+	struct platform_device *pdev = rk322x_pdev;
+	struct vop_device *vop_dev;
+	struct device *dev = &pdev->dev;
+	struct devfreq *devfreq;
+	struct devfreq_event_dev *event_dev;
+
+	if (!pdev)
+		return -ENODEV;
+
+	vop_dev = platform_get_drvdata(pdev);;
+	if (!vop_dev)
+		return -ENODEV;
+
+	dev = &pdev->dev;
+	devfreq = devfreq_get_devfreq_by_phandle(dev, 0);
+	if (IS_ERR(devfreq)) {
+		dev_err(vop_dev->dev, "fail to get devfreq for dmc\n");
+		return -ENODEV;
+	}
+
+	vop_dev->devfreq = devfreq;
+	vop_dev->dmc_nb.notifier_call = dmc_notify;
+	devfreq_register_notifier(vop_dev->devfreq, &vop_dev->dmc_nb,
+				  DEVFREQ_TRANSITION_NOTIFIER);
+
+	event_dev = devfreq_event_get_edev_by_phandle(vop_dev->devfreq->dev.parent,
+						      0);
+	if (IS_ERR(event_dev)) {
+		dev_err(vop_dev->dev, "fail to get edev for dmc\n");
+		return -ENODEV;
+	}
+
+	vop_dev->devfreq_event_dev = event_dev;
+	return 0;
+}
+
+static int vop_wms_refresh(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev =
+	    container_of(dev_drv, struct vop_device, driver);
+
+	if (unlikely(!vop_dev->clk_on)) {
+		dev_info_ratelimited(vop_dev->dev, "%s,clk_on = %d\n",
+				     __func__, vop_dev->clk_on);
+		return 0;
+	}
+	vop_msk_reg_nobak(vop_dev, SYS_CTRL, V_EDPI_WMS_FS(1));
+	vop_msk_reg(vop_dev, SYS_CTRL, V_EDPI_WMS_MODE(0));
+	vop_msk_reg(vop_dev, SYS_CTRL, V_EDPI_WMS_MODE(1));
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->refresh)
+		dev_drv->trsm_ops->refresh(0, 0, dev_drv->cur_screen->mode.xres,
+					   dev_drv->cur_screen->mode.yres);
+
+	return 0;
+}
+
+static irqreturn_t te_irq_handle(int irq, void *dev_id)
+{
+	struct rk_lcdc_driver *dev_drv  = (struct rk_lcdc_driver *)dev_id;
+
+	vop_wms_refresh(dev_drv);
+
+	return IRQ_HANDLED;
+}
+
+static int vop_probe(struct platform_device *pdev)
+{
+	struct vop_device *vop_dev = NULL;
+	struct rk_lcdc_driver *dev_drv;
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	int prop;
+	int ret = 0;
+	int te_pin;
+
+	/* if the primary lcdc has not registered ,the extend
+	 * lcdc register later
+	 */
+	of_property_read_u32(np, "rockchip,prop", &prop);
+	if (prop == EXTEND) {
+		if (!is_prmry_rk_lcdc_registered())
+			return -EPROBE_DEFER;
+	}
+	vop_dev = devm_kzalloc(dev, sizeof(struct vop_device), GFP_KERNEL);
+	if (!vop_dev)
+		return -ENOMEM;
+	of_id = of_match_device(vop_dt_ids, dev);
+	vop_dev->data = of_id->data;
+	if (VOP_CHIP(vop_dev) != VOP_RK322X && VOP_CHIP(vop_dev) != VOP_RK3399)
+		return -ENODEV;
+	platform_set_drvdata(pdev, vop_dev);
+	vop_dev->dev = dev;
+	vop_parse_dt(vop_dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	/* enable power domain */
+	pm_runtime_enable(dev);
+#endif
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	vop_dev->reg_phy_base = res->start;
+	vop_dev->len = resource_size(res);
+	vop_dev->regs = devm_ioremap(&pdev->dev, res->start,
+				     resource_size(res));
+	if (IS_ERR(vop_dev->regs))
+		return PTR_ERR(vop_dev->regs);
+
+	dev_info(dev, "vop_dev->regs=0x%lx\n", (long)vop_dev->regs);
+
+	vop_dev->regsbak = devm_kzalloc(dev, vop_dev->len, GFP_KERNEL);
+	if (IS_ERR(vop_dev->regsbak))
+		return PTR_ERR(vop_dev->regsbak);
+	if (VOP_CHIP(vop_dev) == VOP_RK3399) {
+		vop_dev->dsp_lut_addr_base = vop_dev->regs + GAMMA_LUT_ADDR;
+		vop_dev->cabc_lut_addr_base = vop_dev->regs +
+						CABC_GAMMA_LUT_ADDR;
+	}
+	vop_dev->grf_base =
+		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(vop_dev->grf_base)) {
+		dev_err(&pdev->dev, "can't find lcdc grf property\n");
+		vop_dev->grf_base = NULL;
+	}
+
+	vop_dev->id = vop_get_id(vop_dev, vop_dev->reg_phy_base);
+	dev_set_name(vop_dev->dev, "vop%d", vop_dev->id);
+	dev_drv = &vop_dev->driver;
+	dev_drv->dev = dev;
+	dev_drv->prop = prop;
+	dev_drv->id = vop_dev->id;
+	dev_drv->ops = &lcdc_drv_ops;
+	dev_drv->lcdc_win_num = vop_dev->data->n_wins;
+	dev_drv->reserved_fb = 0;
+	spin_lock_init(&vop_dev->reg_lock);
+	spin_lock_init(&vop_dev->irq_lock);
+	vop_dev->irq = platform_get_irq(pdev, 0);
+	if (vop_dev->irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
+			vop_dev->id);
+		return -ENXIO;
+	}
+
+	ret = devm_request_irq(dev, vop_dev->irq, vop_isr,
+			       IRQF_SHARED, dev_name(dev), vop_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
+			vop_dev->irq, ret);
+		return ret;
+	}
+	if (dev_drv->iommu_enabled) {
+		if (VOP_CHIP(vop_dev) == VOP_RK322X) {
+			strcpy(dev_drv->mmu_dts_name,
+			       VOP_IOMMU_COMPATIBLE_NAME);
+		} else {
+			if (vop_dev->id == 0)
+				strcpy(dev_drv->mmu_dts_name,
+				       VOPB_IOMMU_COMPATIBLE_NAME);
+			else
+				strcpy(dev_drv->mmu_dts_name,
+				       VOPL_IOMMU_COMPATIBLE_NAME);
+		}
+	}
+	if (VOP_CHIP(vop_dev) == VOP_RK3399)
+		dev_drv->property.feature |= SUPPORT_WRITE_BACK | SUPPORT_AFBDC;
+	dev_drv->property.feature |= SUPPORT_VOP_IDENTIFY |
+					SUPPORT_YUV420_OUTPUT;
+	dev_drv->property.max_output_x = 4096;
+	dev_drv->property.max_output_y = 2160;
+
+	init_waitqueue_head(&vop_dev->wait_vop_switch_queue);
+	vop_dev->vop_switch_status = 0;
+	init_waitqueue_head(&vop_dev->wait_dmc_queue);
+	vop_dev->dmc_in_process = 0;
+
+	ret = rk_fb_register(dev_drv, vop_dev->data->win, vop_dev->id);
+	if (ret < 0) {
+		dev_err(dev, "register fb for lcdc%d failed!\n", vop_dev->id);
+		return ret;
+	}
+
+	if ((VOP_CHIP(vop_dev) == VOP_RK3399) && (vop_dev->id == 1)) {
+		dev_drv->win[1]->property.feature &= ~SUPPORT_HW_EXIST;
+		dev_drv->win[3]->property.feature &= ~SUPPORT_HW_EXIST;
+	}
+
+	vop_dev->screen = dev_drv->screen0;
+	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
+		 vop_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
+
+	rk322x_pdev = pdev;
+
+	if (dev_drv->cur_screen->refresh_mode == SCREEN_CMD_MODE) {
+		te_pin = of_get_named_gpio_flags(np, "te-gpio", 0, NULL);
+		if (IS_ERR_VALUE(te_pin)) {
+			dev_err(dev, "define te pin for cmd mode!\n");
+			return 0;
+		}
+		ret = devm_gpio_request(dev, te_pin, "vop-te-gpio");
+		if (ret) {
+			dev_err(dev, "request gpio %d failed\n", te_pin);
+			return 0;
+		}
+		gpio_direction_input(te_pin);
+		dev_drv->te_irq = gpio_to_irq(te_pin);
+		ret = devm_request_threaded_irq(dev,
+						dev_drv->te_irq,
+						NULL, te_irq_handle,
+						IRQ_TYPE_EDGE_FALLING | IRQF_ONESHOT,
+						"te_irq", dev_drv);
+		if (ret < 0)
+			dev_err(dev, "request te irq failed, ret: %d\n", ret);
+	}
+	return 0;
+}
+
+static int vop_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void vop_shutdown(struct platform_device *pdev)
+{
+	struct vop_device *vop_dev = platform_get_drvdata(pdev);
+	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
+
+	dev_drv->suspend_flag = 1;
+	dev_drv->shutdown_flag = 1;
+	/* ensure suspend_flag take effect on multi process */
+	smp_wmb();
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+	kthread_stop(dev_drv->update_regs_thread);
+	vop_deint(vop_dev);
+
+	vop_clk_disable(vop_dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_disable(vop_dev->dev);
+#endif
+	rk_disp_pwr_disable(dev_drv);
+}
+
+static struct platform_driver vop_driver = {
+	.probe = vop_probe,
+	.remove = vop_remove,
+	.driver = {
+		   .name = "rk322x-lcdc",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(vop_dt_ids),
+		   },
+	.suspend = vop_suspend,
+	.resume = vop_resume,
+	.shutdown = vop_shutdown,
+};
+
+static int __init vop_module_init(void)
+{
+	return platform_driver_register(&vop_driver);
+}
+
+static void __exit vop_module_exit(void)
+{
+	platform_driver_unregister(&vop_driver);
+}
+
+fs_initcall(vop_module_init);
+module_exit(vop_module_exit);
diff -Nupr a/drivers/video/rockchip/lcdc/rk322x_lcdc.h b/drivers/video/rockchip/lcdc/rk322x_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk322x_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk322x_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1797 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef RK322X_LCDC_H_
+#define RK322X_LCDC_H_
+
+#include<linux/rk_fb.h>
+#include<linux/io.h>
+#include<linux/clk.h>
+#include<linux/mfd/syscon.h>
+#include<linux/regmap.h>
+
+#define VOP_INPUT_MAX_WIDTH 4096
+/*
+ * Registers in this file
+ * REG_CFG_DONE: Register config done flag
+ * VERSION_INFO: Version for vop
+ * SYS_CTRL: System control register0
+ * SYS_CTRL1: System control register1
+ * DSP_CTRL0: Display control register0
+ * DSP_CTRL1: Display control register1
+ * DSP_BG: Background color
+ * MCU_CTRL: MCU mode control register
+ * WB_CTRL0: write back ctrl0
+ * WB_CTRL1: write back ctrl1
+ * WB_YRGB_MST: write back yrgb mst
+ * WB_CBR_MST: write back cbr mst
+ * WIN0_CTRL0: Win0 ctrl register0
+ * WIN0_CTRL1: Win0 ctrl register1
+ * WIN0_COLOR_KEY: Win0 color key register
+ * WIN0_VIR: Win0 virtual stride
+ * WIN0_YRGB_MST: Win0 YRGB memory start address
+ * WIN0_CBR_MST: Win0 Cbr memory start address
+ * WIN0_ACT_INFO: Win0 active window width/height
+ * WIN0_DSP_INFO: Win0 display width/height on panel
+ * WIN0_DSP_ST: Win0 display start point on panel
+ * WIN0_SCL_FACTOR_YRGB: Win0 YRGB scaling factor
+ * WIN0_SCL_FACTOR_CBR: Win0 Cbr scaling factor
+ * WIN0_SCL_OFFSET: Win0 scaling start point offset
+ * WIN0_SRC_ALPHA_CTRL: Win0 alpha source control register
+ * WIN0_DST_ALPHA_CTRL: Win0 alpha destination control register
+ * WIN0_FADING_CTRL: Win0 fading contrl register
+ * WIN0_CTRL2: Win0 ctrl register2
+ * WIN1_CTRL0: Win1 ctrl register0
+ * WIN1_CTRL1: Win1 ctrl register1
+ * WIN1_COLOR_KEY: Win1 color key register
+ * WIN1_VIR: win1 virtual stride
+ * WIN1_YRGB_MST: Win1 YRGB memory start address
+ * WIN1_CBR_MST: Win1 Cbr memory start address
+ * WIN1_ACT_INFO: Win1 active window width/height
+ * WIN1_DSP_INFO: Win1 display width/height on panel
+ * WIN1_DSP_ST: Win1 display start point on panel
+ * WIN1_SCL_FACTOR_YRGB: Win1 YRGB scaling factor
+ * WIN1_SCL_FACTOR_CBR: Win1 Cbr scaling factor
+ * WIN1_SCL_OFFSET: Win1 scaling start point offset
+ * WIN1_SRC_ALPHA_CTRL: Win1 alpha source control register
+ * WIN1_DST_ALPHA_CTRL: Win1 alpha destination control register
+ * WIN1_FADING_CTRL: Win1 fading contrl register
+ * WIN1_CTRL2: Win1 ctrl register2
+ * WIN2_CTRL0: win2 ctrl register0
+ * WIN2_CTRL1: win2 ctrl register1
+ * WIN2_VIR0_1: Win2 virtual stride0 and virtaul stride1
+ * WIN2_VIR2_3: Win2 virtual stride2 and virtaul stride3
+ * WIN2_MST0: Win2 memory start address0
+ * WIN2_DSP_INFO0: Win2 display width0/height0 on panel
+ * WIN2_DSP_ST0: Win2 display start point0 on panel
+ * WIN2_COLOR_KEY: Win2 color key register
+ * WIN2_MST1: Win2 memory start address1
+ * WIN2_DSP_INFO1: Win2 display width1/height1 on panel
+ * WIN2_DSP_ST1: Win2 display start point1 on panel
+ * WIN2_SRC_ALPHA_CTRL: Win2 alpha source control register
+ * WIN2_MST2: Win2 memory start address2
+ * WIN2_DSP_INFO2:  Win2 display width2/height2 on panel
+ * WIN2_DSP_ST2: Win2 display start point2 on panel
+ * WIN2_DST_ALPHA_CTRL: Win2 alpha destination control register
+ * WIN2_MST3: Win2 memory start address3
+ * WIN2_DSP_INFO3:  Win2 display width3/height3 on panel
+ * WIN2_DSP_ST3: Win2 display start point3 on panel
+ * WIN2_FADING_CTRL: Win2 fading contrl register
+ * WIN3_CTRL0: Win3 ctrl register0
+ * WIN3_CTRL1: Win3 ctrl register1
+ * WIN3_VIR0_1: Win3 virtual stride0 and virtaul stride1
+ * WIN3_VIR2_3: Win3 virtual stride2 and virtaul stride3
+ * WIN3_MST0: Win3 memory start address0
+ * WIN3_DSP_INFO0: Win3 display width0/height0 on panel
+ * WIN3_DSP_ST0: Win3 display start point0 on panel
+ * WIN3_COLOR_KEY: Win3 color key register
+ * WIN3_MST1: Win3 memory start address1
+ * WIN3_DSP_INFO1:  Win3 display width1/height1 on panel
+ * WIN3_DSP_ST1: Win3 display start point1 on panel
+ * WIN3_SRC_ALPHA_CTRL: Win3 alpha source control register
+ * WIN3_MST2: Win3 memory start address2
+ * WIN3_DSP_INFO2:  Win3 display width2/height2 on panel
+ * WIN3_DSP_ST2: Win3 display start point2 on panel
+ * WIN3_DST_ALPHA_CTRL: Win3 alpha destination control register
+ * WIN3_MST3: Win3 memory start address3
+ * WIN3_DSP_INFO3:  Win3 display width3/height3 on panel
+ * WIN3_DSP_ST3: Win3 display start point3 on panel
+ * WIN3_FADING_CTRL: Win3 fading contrl register
+ * HWC_CTRL0: Hwc ctrl register0
+ * HWC_CTRL1: Hwc ctrl register1
+ * HWC_MST: Hwc memory start address
+ * HWC_DSP_ST: Hwc display start point on panel
+ * HWC_SRC_ALPHA_CTRL: Hwc alpha source control register
+ * HWC_DST_ALPHA_CTRL: Hwc alpha destination control register
+ * HWC_FADING_CTRL: Hwc fading contrl register
+ * HWC_RESERVED1: Hwc reserved
+ * POST_DSP_HACT_INFO: Post scaler down horizontal start and end
+ * POST_DSP_VACT_INFO: Panel active horizontal scanning start point
+ *                     and end point
+ * POST_SCL_FACTOR_YRGB: Post yrgb scaling factor
+ * POST_RESERVED: Post reserved
+ * POST_SCL_CTRL: Post scaling start point offset
+ * POST_DSP_VACT_INFO_F1: Panel active horizontal scanning start point
+ *                        and end point F1
+ * DSP_HTOTAL_HS_END: Panel scanning horizontal width and hsync pulse end point
+ * DSP_HACT_ST_END: Panel active horizontal scanning start point and end point
+ * DSP_VTOTAL_VS_END: Panel scanning vertical height and vsync pulse end point
+ * DSP_VACT_ST_END: Panel active vertical scanning start point and end point
+ * DSP_VS_ST_END_F1: Vertical scanning start point and vsync pulse end point
+ *                   of even filed in interlace mode
+ * DSP_VACT_ST_END_F1: Vertical scanning active start point and end point of
+ *                     even filed in interlace mode
+ * PWM_CTRL: PWM Control Register
+ * PWM_PERIOD_HPR: PWM Period Register/High Polarity Capture Register
+ * PWM_DUTY_LPR: PWM Duty Register/Low Polarity Capture Register
+ * PWM_CNT: PWM Counter Register
+ * BCSH_COLOR_BAR: Color bar config register
+ * BCSH_BCS: Brightness contrast saturation*contrast config register
+ * BCSH_H: Sin hue and cos hue config register
+ * BCSH_CTRL: BCSH contrl register
+ * CABC_CTRL0: Content Adaptive Backlight Control register0
+ * CABC_CTRL1: Content Adaptive Backlight Control register1
+ * CABC_CTRL2: Content Adaptive Backlight Control register2
+ * CABC_CTRL3: Content Adaptive Backlight Control register3
+ * CABC_GAUSS_LINE0_0: CABC gauss line config register00
+ * CABC_GAUSS_LINE0_1: CABC gauss line config register01
+ * CABC_GAUSS_LINE1_0: CABC gauss line config register10
+ * CABC_GAUSS_LINE1_1: CABC gauss line config register11
+ * CABC_GAUSS_LINE2_0: CABC gauss line config register20
+ * CABC_GAUSS_LINE2_1: CABC gauss line config register21
+ * FRC_LOWER01_0: FRC lookup table config register010
+ * FRC_LOWER01_1: FRC lookup table config register011
+ * FRC_LOWER10_0: FRC lookup table config register100
+ * FRC_LOWER10_1: FRC lookup table config register101
+ * FRC_LOWER11_0: FRC lookup table config register110
+ * FRC_LOWER11_1: FRC lookup table config register111
+ * AFBCD0_CTRL:
+ * AFBCD0_HDR_PTR:
+ * AFBCD0_PIC_SIZE:
+ * AFBCD0_STATUS:
+ * AFBCD1_CTRL:
+ * AFBCD1_HDR_PTR:
+ * AFBCD1_PIC_SIZE:
+ * AFBCD1_STATUS:
+ * AFBCD2_CTRL:
+ * AFBCD2_HDR_PTR:
+ * AFBCD2_PIC_SIZE:
+ * AFBCD2_STATUS:
+ * AFBCD3_CTRL:
+ * AFBCD3_HDR_PTR:
+ * AFBCD3_PIC_SIZE:
+ * AFBCD3_STATUS:
+ * INTR_EN0: Interrupt enable register
+ * INTR_CLEAR0: Interrupt clear register
+ * INTR_STATUS0: interrupt  status
+ * INTR_RAW_STATUS0: raw interrupt status
+ * INTR_EN1: Interrupt enable register
+ * INTR_CLEAR1: Interrupt clear register
+ * INTR_STATUS1: interrupt  status
+ * INTR_RAW_STATUS1: raw interrupt status
+ * LINE_FLAG: Line flag config register
+ * VOP_STATUS: vop status register
+ * BLANKING_VALUE: Register0000 Abstract
+ * MCU_BYPASS_PORT: Mcu bypass value
+ * WIN0_DSP_BG: Win0 layer background color
+ * WIN1_DSP_BG: Win1 layer background color
+ * WIN2_DSP_BG: Win2 layer background color
+ * WIN3_DSP_BG: Win3 layer background color
+ * YUV2YUV_WIN: YUV to YUV win
+ * YUV2YUV_POST: Post YUV to YUV
+ * AUTO_GATING_EN: Auto gating enable
+ * DBG_PERF_LATENCY_CTRL0: Axi performance latency module contrl register0
+ * DBG_PERF_RD_MAX_LATENCY_NUM0: Read max latency number
+ * DBG_PERF_RD_LATENCY_THR_NUM0: The number of bigger than configed
+ *                               threshold value
+ * DBG_PERF_RD_LATENCY_SAMP_NUM0: Total sample number
+ * DBG_CABC0: CABC debug register0
+ * DBG_CABC1: CABC debug register1
+ * DBG_CABC2: CABC debug register2
+ * DBG_CABC3: CABC debug register3
+ * DBG_WIN0_REG0: Vop debug win0 register0
+ * DBG_WIN0_REG1: Vop debug win0 register1
+ * DBG_WIN0_REG2: Vop debug win0 register2
+ * DBG_WIN0_RESERVED: Vop debug win0 register3 reserved
+ * DBG_WIN1_REG0: Vop debug win1 register0
+ * DBG_WIN1_REG1: Vop debug win1 register1
+ * DBG_WIN1_REG2: Vop debug win1 register2
+ * DBG_WIN1_RESERVED: Vop debug win1 register3 reserved
+ * DBG_WIN2_REG0: Vop debug win2 register0
+ * DBG_WIN2_REG1: Vop debug win2 register1
+ * DBG_WIN2_REG2: Vop debug win2 register2
+ * DBG_WIN2_REG3: Vop debug win2 register3
+ * DBG_WIN3_REG0: Vop debug win3 register0
+ * DBG_WIN3_REG1: Vop debug win3 register1
+ * DBG_WIN3_REG2: Vop debug win3 register2
+ * DBG_WIN3_REG3: Vop debug win3 register3
+ * DBG_PRE_REG0: Vop debug pre register0
+ * DBG_PRE_RESERVED: Vop debug pre register1 reserved
+ * DBG_POST_REG0: Vop debug post register0
+ * DBG_POST_REG1: Vop debug
+ * DBG_DATAO: debug data output path
+ * DBG_DATAO_2: debug data output path 2
+ * WIN2_LUT_ADDR: Win2 lut base address
+ * WIN3_LUT_ADDR: Win3 lut base address
+ * HWC_LUT_ADDR: Hwc lut base address
+ * GAMMA0_LUT_ADDR: GAMMA lut base address
+ * GAMMA1_LUT_ADDR: GAMMA lut base address
+ * CABC_GAMMA_LUT_ADDR: CABC GAMMA lut base address
+ * MCU_BYPASS_WPORT:
+ * MCU_BYPASS_RPORT:
+ */
+
+static inline u64 val_mask(int val, u64 msk, int shift)
+{
+	return (msk << (shift + 32)) | ((msk & val) << shift);
+}
+
+#define VAL_MASK(x, width, shift) val_mask(x, (1 << width) - 1, shift)
+
+#define MASK(x) (V_##x(0) >> 32)
+
+#define REG_CFG_DONE			0x00000000
+#define  V_REG_LOAD_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_REG_LOAD_WIN0_EN(x)			VAL_MASK(x, 1, 1)
+#define  V_REG_LOAD_WIN1_EN(x)			VAL_MASK(x, 1, 2)
+#define  V_REG_LOAD_WIN2_EN(x)			VAL_MASK(x, 1, 3)
+#define  V_REG_LOAD_WIN3_EN(x)			VAL_MASK(x, 1, 4)
+#define  V_REG_LOAD_HWC_EN(x)			VAL_MASK(x, 1, 5)
+#define  V_REG_LOAD_IEP_EN(x)			VAL_MASK(x, 1, 6)
+#define  V_REG_LOAD_FBDC_EN(x)			VAL_MASK(x, 1, 7)
+#define  V_REG_LOAD_SYS_EN(x)			VAL_MASK(x, 1, 8)
+#define  V_WRITE_MASK(x)			VAL_MASK(x, 16, 16)
+#define VERSION_INFO			0x00000004
+#define  V_SVNBUILD(x)				VAL_MASK(x, 16, 0)
+#define  V_MINOR(x)				VAL_MASK(x, 8, 16)
+#define  V_MAJOR(x)				VAL_MASK(x, 8, 24)
+#define SYS_CTRL			0x00000008
+#define  V_DIRECT_PATH_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_DIRECT_PATH_LAYER_SEL(x)		VAL_MASK(x, 2, 1)
+#define  V_MIPI_DUAL_CHANNEL_EN(x)		VAL_MASK(x, 1, 3)
+#define  V_EDPI_HALT_EN(x)			VAL_MASK(x, 1, 8)
+#define  V_EDPI_WMS_MODE(x)			VAL_MASK(x, 1, 9)
+#define  V_EDPI_WMS_FS(x)			VAL_MASK(x, 1, 10)
+#define  V_GLOBAL_REGDONE_EN(x)			VAL_MASK(x, 1, 11)
+#define  V_RGB_OUT_EN(x)			VAL_MASK(x, 1, 12)
+#define  V_HDMI_OUT_EN(x)			VAL_MASK(x, 1, 13)
+#define  V_EDP_OUT_EN(x)			VAL_MASK(x, 1, 14)
+#define  V_MIPI_OUT_EN(x)			VAL_MASK(x, 1, 15)
+#define  V_OVERLAY_MODE(x)			VAL_MASK(x, 1, 16)
+/* rk3399 only*/
+#define  V_DP_OUT_EN(x)				VAL_MASK(x, 1, 11)
+/* rk322x only */
+#define  V_FS_SAME_ADDR_MASK_EN(x)		VAL_MASK(x, 1, 17)
+#define  V_POST_LB_MODE(x)			VAL_MASK(x, 1, 18)
+#define  V_WIN23_PRI_OPT_MODE(x)		VAL_MASK(x, 1, 19)
+/* rk322x only */
+#define  V_VOP_MMU_EN(x)			VAL_MASK(x, 1, 20)
+/* rk3399 only */
+#define  V_VOP_FIELD_TVE_TIMING_POL(x)		VAL_MASK(x, 1, 20)
+#define  V_VOP_DMA_STOP(x)			VAL_MASK(x, 1, 21)
+#define  V_VOP_STANDBY_EN(x)			VAL_MASK(x, 1, 22)
+#define  V_AUTO_GATING_EN(x)			VAL_MASK(x, 1, 23)
+#define  V_SW_IMD_TVE_DCLK_EN(x)		VAL_MASK(x, 1, 24)
+#define  V_SW_IMD_TVE_DCLK_POL(x)		VAL_MASK(x, 1, 25)
+#define  V_SW_TVE_MODE(x)			VAL_MASK(x, 1, 26)
+#define  V_SW_UV_OFFSET_EN(x)			VAL_MASK(x, 1, 27)
+#define  V_SW_GENLOCK(x)			VAL_MASK(x, 1, 28)
+#define  V_SW_DAC_SEL(x)			VAL_MASK(x, 1, 29)
+#define  V_VOP_FIELD_TVE_POL(x)			VAL_MASK(x, 1, 30)
+#define  V_IO_PAD_CLK_SEL(x)			VAL_MASK(x, 1, 31)
+#define SYS_CTRL1			0x0000000c
+#define  V_NOC_HURRY_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_NOC_HURRY_VALUE(x)			VAL_MASK(x, 2, 1)
+#define  V_NOC_HURRY_THRESHOLD(x)		VAL_MASK(x, 6, 3)
+#define  V_NOC_QOS_EN(x)			VAL_MASK(x, 1, 9)
+#define  V_NOC_WIN_QOS(x)			VAL_MASK(x, 2, 10)
+#define  V_AXI_MAX_OUTSTANDING_EN(x)		VAL_MASK(x, 1, 12)
+#define  V_AXI_OUTSTANDING_MAX_NUM(x)		VAL_MASK(x, 5, 13)
+#define  V_NOC_HURRY_W_MODE(x)			VAL_MASK(x, 2, 20)
+#define  V_NOC_HURRY_W_VALUE(x)			VAL_MASK(x, 2, 22)
+#define  V_REG_DONE_FRM(x)			VAL_MASK(x, 1, 24)
+#define  V_DSP_FP_STANDBY(x)			VAL_MASK(x, 1, 31)
+#define DSP_CTRL0			0x00000010
+#define  V_DSP_OUT_MODE(x)			VAL_MASK(x, 4, 0)
+#define  V_SW_CORE_DCLK_SEL(x)			VAL_MASK(x, 1, 4)
+/* rk322x */
+#define  V_SW_HDMI_CLK_I_SEL(x)			VAL_MASK(x, 1, 5)
+/* rk3399 */
+#define  V_P2I_EN(x)				VAL_MASK(x, 1, 5)
+#define  V_DSP_DCLK_DDR(x)			VAL_MASK(x, 1, 8)
+#define  V_DSP_DDR_PHASE(x)			VAL_MASK(x, 1, 9)
+#define  V_DSP_INTERLACE(x)			VAL_MASK(x, 1, 10)
+#define  V_DSP_FIELD_POL(x)			VAL_MASK(x, 1, 11)
+#define  V_DSP_BG_SWAP(x)			VAL_MASK(x, 1, 12)
+#define  V_DSP_RB_SWAP(x)			VAL_MASK(x, 1, 13)
+#define  V_DSP_RG_SWAP(x)			VAL_MASK(x, 1, 14)
+#define  V_DSP_DELTA_SWAP(x)			VAL_MASK(x, 1, 15)
+#define  V_DSP_DUMMY_SWAP(x)			VAL_MASK(x, 1, 16)
+#define  V_DSP_OUT_ZERO(x)			VAL_MASK(x, 1, 17)
+#define  V_DSP_BLANK_EN(x)			VAL_MASK(x, 1, 18)
+#define  V_DSP_BLACK_EN(x)			VAL_MASK(x, 1, 19)
+#define  V_DSP_CCIR656_AVG(x)			VAL_MASK(x, 1, 20)
+#define  V_DSP_YUV_CLIP(x)			VAL_MASK(x, 1, 21)
+#define  V_DSP_X_MIR_EN(x)			VAL_MASK(x, 1, 22)
+#define  V_DSP_Y_MIR_EN(x)			VAL_MASK(x, 1, 23)
+/* rk3399 only */
+#define  V_SW_TVE_OUTPUT_SEL(x)			VAL_MASK(x, 1, 25)
+#define  V_DSP_FIELD(x)				VAL_MASK(x, 1, 31)
+#define DSP_CTRL1			0x00000014
+#define  V_DSP_LUT_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_PRE_DITHER_DOWN_EN(x)		VAL_MASK(x, 1, 1)
+#define  V_DITHER_DOWN_EN(x)			VAL_MASK(x, 1, 2)
+#define  V_DITHER_DOWN_MODE(x)			VAL_MASK(x, 1, 3)
+#define  V_DITHER_DOWN_SEL(x)			VAL_MASK(x, 1, 4)
+#define  V_DITHER_UP_EN(x)			VAL_MASK(x, 1, 6)
+#define  V_UPDATE_GAMMA_LUT(x)			VAL_MASK(x, 1, 7)
+#define  V_DSP_LAYER0_SEL(x)			VAL_MASK(x, 2, 8)
+#define  V_DSP_LAYER1_SEL(x)			VAL_MASK(x, 2, 10)
+#define  V_DSP_LAYER2_SEL(x)			VAL_MASK(x, 2, 12)
+#define  V_DSP_LAYER3_SEL(x)			VAL_MASK(x, 2, 14)
+#define  V_RGB_LVDS_HSYNC_POL(x)		VAL_MASK(x, 1, 16)
+#define  V_RGB_LVDS_VSYNC_POL(x)		VAL_MASK(x, 1, 17)
+#define  V_RGB_LVDS_DEN_POL(x)			VAL_MASK(x, 1, 18)
+#define  V_RGB_LVDS_DCLK_POL(x)			VAL_MASK(x, 1, 19)
+#define  V_HDMI_HSYNC_POL(x)			VAL_MASK(x, 1, 20)
+#define  V_HDMI_VSYNC_POL(x)			VAL_MASK(x, 1, 21)
+#define  V_HDMI_DEN_POL(x)			VAL_MASK(x, 1, 22)
+#define  V_HDMI_DCLK_POL(x)			VAL_MASK(x, 1, 23)
+#define  V_EDP_HSYNC_POL(x)			VAL_MASK(x, 1, 24)
+#define  V_EDP_VSYNC_POL(x)			VAL_MASK(x, 1, 25)
+#define  V_EDP_DEN_POL(x)			VAL_MASK(x, 1, 26)
+#define  V_EDP_DCLK_POL(x)			VAL_MASK(x, 1, 27)
+#define  V_MIPI_HSYNC_POL(x)			VAL_MASK(x, 1, 28)
+#define  V_MIPI_VSYNC_POL(x)			VAL_MASK(x, 1, 29)
+#define  V_MIPI_DEN_POL(x)			VAL_MASK(x, 1, 30)
+#define  V_MIPI_DCLK_POL(x)			VAL_MASK(x, 1, 31)
+/* rk3399 only*/
+#define  V_DP_HSYNC_POL(x)			VAL_MASK(x, 1, 16)
+#define  V_DP_VSYNC_POL(x)			VAL_MASK(x, 1, 17)
+#define  V_DP_DEN_POL(x)			VAL_MASK(x, 1, 18)
+#define  V_DP_DCLK_POL(x)			VAL_MASK(x, 1, 19)
+#define DSP_BG				0x00000018
+#define  V_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
+#define  V_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
+#define  V_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
+#define MCU_CTRL			0x0000001c
+#define  V_MCU_PIX_TOTAL(x)			VAL_MASK(x, 6, 0)
+#define  V_MCU_CS_PST(x)			VAL_MASK(x, 4, 6)
+#define  V_MCU_CS_PEND(x)			VAL_MASK(x, 6, 10)
+#define  V_MCU_RW_PST(x)			VAL_MASK(x, 4, 16)
+#define  V_MCU_RW_PEND(x)			VAL_MASK(x, 6, 20)
+#define  V_MCU_CLK_SEL(x)			VAL_MASK(x, 1, 26)
+#define  V_MCU_HOLD_MODE(x)			VAL_MASK(x, 1, 27)
+#define  V_MCU_FRAME_ST(x)			VAL_MASK(x, 1, 28)
+#define  V_MCU_RS(x)				VAL_MASK(x, 1, 29)
+#define  V_MCU_BYPASS(x)			VAL_MASK(x, 1, 30)
+#define  V_MCU_TYPE(x)				VAL_MASK(x, 1, 31)
+#define WB_CTRL0			0x00000020
+#define  V_WB_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_WB_FMT(x)				VAL_MASK(x, 3, 1)
+#define  V_WB_DITHER_EN(x)			VAL_MASK(x, 1, 4)
+#define  V_WB_RGB2YUV_EN(x)			VAL_MASK(x, 1, 5)
+#define  V_WB_RGB2YUV_MODE(x)			VAL_MASK(x, 1, 6)
+#define  V_WB_XPSD_BIL_EN(x)			VAL_MASK(x, 1, 7)
+#define  V_WB_YTHROW_EN(x)			VAL_MASK(x, 1, 8)
+#define  V_WB_YTHROW_MODE(x)			VAL_MASK(x, 1, 9)
+#define  V_WB_HANDSHAKE_MODE(x)			VAL_MASK(x, 1, 11)
+#define  V_WB_YRGB_ID(x)			VAL_MASK(x, 4, 24)
+#define  V_WB_UV_ID(x)				VAL_MASK(x, 4, 28)
+#define WB_CTRL1			0x00000024
+#define  V_WB_WIDTH(x)				VAL_MASK(x, 12, 0)
+#define  V_WB_XPSD_BIL_FACTOR(x)		VAL_MASK(x, 14, 16)
+#define WB_YRGB_MST			0x00000028
+#define  V_WB_YRGB_MST(x)			VAL_MASK(x, 32, 0)
+#define WB_CBR_MST			0x0000002c
+#define  V_WB_CBR_MST(x)			VAL_MASK(x, 32, 0)
+#define WIN0_CTRL0			0x00000030
+#define  V_WIN0_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_WIN0_DATA_FMT(x)			VAL_MASK(x, 3, 1)
+#define  V_WIN0_FMT_10(x)			VAL_MASK(x, 1, 4)
+#define  V_WIN0_LB_MODE(x)			VAL_MASK(x, 3, 5)
+#define  V_WIN0_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
+#define  V_WIN0_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 9)
+#define  V_WIN0_CSC_MODE(x)			VAL_MASK(x, 2, 10)
+#define  V_WIN0_RB_SWAP(x)			VAL_MASK(x, 1, 12)
+#define  V_WIN0_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
+#define  V_WIN0_MID_SWAP(x)			VAL_MASK(x, 1, 14)
+#define  V_WIN0_UV_SWAP(x)			VAL_MASK(x, 1, 15)
+#define  V_WIN0_HW_PRE_MUL_EN(x)		VAL_MASK(x, 1, 16)
+/* rk3399 only */
+#define  V_WIN0_YUYV(x)				VAL_MASK(x, 1, 17)
+#define  V_WIN0_YRGB_DEFLICK(x)			VAL_MASK(x, 1, 18)
+#define  V_WIN0_CBR_DEFLICK(x)			VAL_MASK(x, 1, 19)
+#define  V_WIN0_YUV_CLIP(x)			VAL_MASK(x, 1, 20)
+#define  V_WIN0_X_MIR_EN(x)			VAL_MASK(x, 1, 21)
+#define  V_WIN0_Y_MIR_EN(x)			VAL_MASK(x, 1, 22)
+#define  V_WIN0_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 24)
+#define  V_WIN0_AXI_OUTSTANDING_MAX_NUM(x)	VAL_MASK(x, 5, 25)
+#define  V_WIN0_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 30)
+#define WIN0_CTRL1			0x00000034
+#define  V_WIN0_YRGB_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_WIN0_CBR_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN0_BIC_COE_SEL(x)			VAL_MASK(x, 2, 2)
+#define  V_WIN0_VSD_YRGB_GT4(x)			VAL_MASK(x, 1, 4)
+#define  V_WIN0_VSD_YRGB_GT2(x)			VAL_MASK(x, 1, 5)
+#define  V_WIN0_VSD_CBR_GT4(x)			VAL_MASK(x, 1, 6)
+#define  V_WIN0_VSD_CBR_GT2(x)			VAL_MASK(x, 1, 7)
+#define  V_WIN0_YRGB_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 8)
+#define  V_WIN0_CBR_AXI_GATHER_NUM(x)		VAL_MASK(x, 3, 12)
+#define  V_WIN0_LINE_LOAD_MODE(x)		VAL_MASK(x, 1, 15)
+#define  V_WIN0_YRGB_HOR_SCL_MODE(x)		VAL_MASK(x, 2, 16)
+#define  V_WIN0_YRGB_VER_SCL_MODE(x)		VAL_MASK(x, 2, 18)
+#define  V_WIN0_YRGB_HSD_MODE(x)		VAL_MASK(x, 2, 20)
+#define  V_WIN0_YRGB_VSU_MODE(x)		VAL_MASK(x, 1, 22)
+#define  V_WIN0_YRGB_VSD_MODE(x)		VAL_MASK(x, 1, 23)
+#define  V_WIN0_CBR_HOR_SCL_MODE(x)		VAL_MASK(x, 2, 24)
+#define  V_WIN0_CBR_VER_SCL_MODE(x)		VAL_MASK(x, 2, 26)
+#define  V_WIN0_CBR_HSD_MODE(x)			VAL_MASK(x, 2, 28)
+#define  V_WIN0_CBR_VSU_MODE(x)			VAL_MASK(x, 1, 30)
+#define  V_WIN0_CBR_VSD_MODE(x)			VAL_MASK(x, 1, 31)
+#define WIN0_COLOR_KEY			0x00000038
+#define  V_WIN0_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
+#define  V_WIN0_KEY_EN(x)			VAL_MASK(x, 1, 31)
+#define WIN0_VIR			0x0000003c
+#define  V_WIN0_VIR_STRIDE(x)			VAL_MASK(x, 16, 0)
+#define  V_WIN0_VIR_STRIDE_UV(x)		VAL_MASK(x, 16, 16)
+#define WIN0_YRGB_MST			0x00000040
+#define  V_WIN0_YRGB_MST(x)			VAL_MASK(x, 32, 0)
+#define WIN0_CBR_MST			0x00000044
+#define  V_WIN0_CBR_MST(x)			VAL_MASK(x, 32, 0)
+#define WIN0_ACT_INFO			0x00000048
+#define  V_WIN0_ACT_WIDTH(x)			VAL_MASK(x, 13, 0)
+#define  V_FIELD0002(x)				VAL_MASK(x, 1, 13)
+#define  V_FIELD0001(x)				VAL_MASK(x, 1, 14)
+#define  V_FIELD0000(x)				VAL_MASK(x, 1, 15)
+#define  V_WIN0_ACT_HEIGHT(x)			VAL_MASK(x, 13, 16)
+#define WIN0_DSP_INFO			0x0000004c
+#define  V_WIN0_DSP_WIDTH(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN0_DSP_HEIGHT(x)			VAL_MASK(x, 12, 16)
+#define WIN0_DSP_ST			0x00000050
+#define  V_WIN0_DSP_XST(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN0_DSP_YST(x)			VAL_MASK(x, 13, 16)
+#define WIN0_SCL_FACTOR_YRGB		0x00000054
+#define  V_WIN0_HS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 0)
+#define  V_WIN0_VS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 16)
+#define WIN0_SCL_FACTOR_CBR		0x00000058
+#define  V_WIN0_HS_FACTOR_CBR(x)		VAL_MASK(x, 16, 0)
+#define  V_WIN0_VS_FACTOR_CBR(x)		VAL_MASK(x, 16, 16)
+#define WIN0_SCL_OFFSET			0x0000005c
+#define  V_WIN0_HS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 0)
+#define  V_WIN0_HS_OFFSET_CBR(x)		VAL_MASK(x, 8, 8)
+#define  V_WIN0_VS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN0_VS_OFFSET_CBR(x)		VAL_MASK(x, 8, 24)
+#define WIN0_SRC_ALPHA_CTRL		0x00000060
+#define  V_WIN0_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_WIN0_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN0_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
+#define  V_WIN0_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
+#define  V_WIN0_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
+#define  V_WIN0_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define  V_WIN0_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN0_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
+#define WIN0_DST_ALPHA_CTRL		0x00000064
+#define  V_WIN0_DST_M0_RESERVED(x)		VAL_MASK(x, 6, 0)
+#define  V_WIN0_DST_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define WIN0_FADING_CTRL		0x00000068
+#define  V_LAYER0_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
+#define  V_LAYER0_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
+#define  V_LAYER0_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
+#define  V_LAYER0_FADING_EN(x)			VAL_MASK(x, 1, 24)
+#define WIN0_CTRL2			0x0000006c
+#define  V_WIN_RID_WIN0_YRGB(x)			VAL_MASK(x, 4, 0)
+#define  V_WIN_RID_WIN0_CBR(x)			VAL_MASK(x, 4, 4)
+#define WIN1_CTRL0			0x00000070
+#define  V_WIN1_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_WIN1_DATA_FMT(x)			VAL_MASK(x, 3, 1)
+#define  V_WIN1_FMT_10(x)			VAL_MASK(x, 1, 4)
+#define  V_WIN1_LB_MODE(x)			VAL_MASK(x, 3, 5)
+#define  V_WIN1_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
+#define  V_WIN1_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 9)
+#define  V_WIN1_CSC_MODE(x)			VAL_MASK(x, 2, 10)
+#define  V_WIN1_RB_SWAP(x)			VAL_MASK(x, 1, 12)
+#define  V_WIN1_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
+#define  V_WIN1_MID_SWAP(x)			VAL_MASK(x, 1, 14)
+#define  V_WIN1_UV_SWAP(x)			VAL_MASK(x, 1, 15)
+#define  V_WIN1_HW_PRE_MUL_EN(x)		VAL_MASK(x, 1, 16)
+/* rk3399 only */
+#define  V_WIN1_YUYV(x)				VAL_MASK(x, 1, 17)
+#define  V_WIN1_YRGB_DEFLICK(x)			VAL_MASK(x, 1, 18)
+#define  V_WIN1_CBR_DEFLICK(x)			VAL_MASK(x, 1, 19)
+#define  V_WIN1_YUV_CLIP(x)			VAL_MASK(x, 1, 20)
+#define  V_WIN1_X_MIR_EN(x)			VAL_MASK(x, 1, 21)
+#define  V_WIN1_Y_MIR_EN(x)			VAL_MASK(x, 1, 22)
+#define  V_WIN1_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 24)
+#define  V_WIN1_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 25)
+#define  V_WIN1_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 30)
+#define WIN1_CTRL1			0x00000074
+#define  V_WIN1_YRGB_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_WIN1_CBR_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN1_BIC_COE_SEL(x)			VAL_MASK(x, 2, 2)
+#define  V_WIN1_VSD_YRGB_GT4(x)			VAL_MASK(x, 1, 4)
+#define  V_WIN1_VSD_YRGB_GT2(x)			VAL_MASK(x, 1, 5)
+#define  V_WIN1_VSD_CBR_GT4(x)			VAL_MASK(x, 1, 6)
+#define  V_WIN1_VSD_CBR_GT2(x)			VAL_MASK(x, 1, 7)
+#define  V_WIN1_YRGB_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 8)
+#define  V_WIN1_CBR_AXI_GATHER_NUM(x)		VAL_MASK(x, 3, 12)
+#define  V_WIN1_LINE_LOAD_MODE(x)		VAL_MASK(x, 1, 15)
+#define  V_WIN1_YRGB_HOR_SCL_MODE(x)		VAL_MASK(x, 2, 16)
+#define  V_WIN1_YRGB_VER_SCL_MODE(x)		VAL_MASK(x, 2, 18)
+#define  V_WIN1_YRGB_HSD_MODE(x)		VAL_MASK(x, 2, 20)
+#define  V_WIN1_YRGB_VSU_MODE(x)		VAL_MASK(x, 1, 22)
+#define  V_WIN1_YRGB_VSD_MODE(x)		VAL_MASK(x, 1, 23)
+#define  V_WIN1_CBR_HOR_SCL_MODE(x)		VAL_MASK(x, 2, 24)
+#define  V_WIN1_CBR_VER_SCL_MODE(x)		VAL_MASK(x, 2, 26)
+#define  V_WIN1_CBR_HSD_MODE(x)			VAL_MASK(x, 2, 28)
+#define  V_WIN1_CBR_VSU_MODE(x)			VAL_MASK(x, 1, 30)
+#define  V_WIN1_CBR_VSD_MODE(x)			VAL_MASK(x, 1, 31)
+#define WIN1_COLOR_KEY			0x00000078
+#define  V_WIN1_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
+#define  V_WIN1_KEY_EN(x)			VAL_MASK(x, 1, 31)
+#define WIN1_VIR			0x0000007c
+#define  V_WIN1_VIR_STRIDE(x)			VAL_MASK(x, 16, 0)
+#define  V_WIN1_VIR_STRIDE_UV(x)		VAL_MASK(x, 16, 16)
+#define WIN1_YRGB_MST			0x00000080
+#define  V_WIN1_YRGB_MST(x)			VAL_MASK(x, 32, 0)
+#define WIN1_CBR_MST			0x00000084
+#define  V_WIN1_CBR_MST(x)			VAL_MASK(x, 32, 0)
+#define WIN1_ACT_INFO			0x00000088
+#define  V_WIN1_ACT_WIDTH(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN1_ACT_HEIGHT(x)			VAL_MASK(x, 13, 16)
+#define WIN1_DSP_INFO			0x0000008c
+#define  V_WIN1_DSP_WIDTH(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN1_DSP_HEIGHT(x)			VAL_MASK(x, 12, 16)
+#define WIN1_DSP_ST			0x00000090
+#define  V_WIN1_DSP_XST(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN1_DSP_YST(x)			VAL_MASK(x, 13, 16)
+#define WIN1_SCL_FACTOR_YRGB		0x00000094
+#define  V_WIN1_HS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 0)
+#define  V_WIN1_VS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 16)
+#define WIN1_SCL_FACTOR_CBR		0x00000098
+#define  V_WIN1_HS_FACTOR_CBR(x)		VAL_MASK(x, 16, 0)
+#define  V_WIN1_VS_FACTOR_CBR(x)		VAL_MASK(x, 16, 16)
+#define WIN1_SCL_OFFSET			0x0000009c
+#define  V_WIN1_HS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 0)
+#define  V_WIN1_HS_OFFSET_CBR(x)		VAL_MASK(x, 8, 8)
+#define  V_WIN1_VS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN1_VS_OFFSET_CBR(x)		VAL_MASK(x, 8, 24)
+#define WIN1_SRC_ALPHA_CTRL		0x000000a0
+#define  V_WIN1_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_WIN1_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN1_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
+#define  V_WIN1_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
+#define  V_WIN1_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
+#define  V_WIN1_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define  V_WIN1_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN1_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
+#define WIN1_DST_ALPHA_CTRL		0x000000a4
+#define  V_WIN1_DSP_M0_RESERVED(x)		VAL_MASK(x, 6, 0)
+#define  V_WIN1_DST_FACTOR_M0(x)		VAL_MASK(x, 3, 6)
+#define WIN1_FADING_CTRL		0x000000a8
+#define  V_WIN1_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
+#define  V_WIN1_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
+#define  V_WIN1_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN1_FADING_EN(x)			VAL_MASK(x, 1, 24)
+#define WIN1_CTRL2			0x000000ac
+#define  V_WIN_RID_WIN1_YRGB(x)			VAL_MASK(x, 4, 0)
+#define  V_WIN_RID_WIN1_CBR(x)			VAL_MASK(x, 4, 4)
+#define WIN2_CTRL0			0x000000b0
+#define  V_WIN2_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_WIN2_INTERLACE_READ(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN2_CSC_MODE(x)			VAL_MASK(x, 2, 2)
+#define  V_WIN2_MST0_EN(x)			VAL_MASK(x, 1, 4)
+#define  V_WIN2_DATA_FMT0(x)			VAL_MASK(x, 2, 5)
+#define  V_WIN2_MST1_EN(x)			VAL_MASK(x, 1, 8)
+#define  V_WIN2_DATA_FMT1(x)			VAL_MASK(x, 2, 9)
+#define  V_WIN2_MST2_EN(x)			VAL_MASK(x, 1, 12)
+#define  V_WIN2_DATA_FMT2(x)			VAL_MASK(x, 2, 13)
+#define  V_WIN2_MST3_EN(x)			VAL_MASK(x, 1, 16)
+#define  V_WIN2_DATA_FMT3(x)			VAL_MASK(x, 2, 17)
+#define  V_WIN2_RB_SWAP0(x)			VAL_MASK(x, 1, 20)
+#define  V_WIN2_ALPHA_SWAP0(x)			VAL_MASK(x, 1, 21)
+#define  V_WIN2_ENDIAN_SWAP0(x)			VAL_MASK(x, 1, 22)
+#define  V_WIN2_RB_SWAP1(x)			VAL_MASK(x, 1, 23)
+#define  V_WIN2_ALPHA_SWAP1(x)			VAL_MASK(x, 1, 24)
+#define  V_WIN2_ENDIAN_SWAP1(x)			VAL_MASK(x, 1, 25)
+#define  V_WIN2_RB_SWAP2(x)			VAL_MASK(x, 1, 26)
+#define  V_WIN2_ALPHA_SWAP2(x)			VAL_MASK(x, 1, 27)
+#define  V_WIN2_ENDIAN_SWAP2(x)			VAL_MASK(x, 1, 28)
+#define  V_WIN2_RB_SWAP3(x)			VAL_MASK(x, 1, 29)
+#define  V_WIN2_ALPHA_SWAP3(x)			VAL_MASK(x, 1, 30)
+#define  V_WIN2_ENDIAN_SWAP3(x)			VAL_MASK(x, 1, 31)
+#define WIN2_CTRL1			0x000000b4
+#define  V_WIN2_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_WIN2_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 1)
+#define  V_WIN2_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
+#define  V_WIN2_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 4)
+#define  V_WIN2_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 8)
+#define  V_WIN2_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 14)
+#define  V_WIN2_Y_MIR_EN(x)			VAL_MASK(x, 1, 15)
+#define  V_WIN2_LUT_EN(x)			VAL_MASK(x, 1, 16)
+#define  V_WIN_RID_WIN2(x)			VAL_MASK(x, 4, 20)
+#define WIN2_VIR0_1			0x000000b8
+#define  V_WIN2_VIR_STRIDE0(x)			VAL_MASK(x, 16, 0)
+#define  V_WIN2_VIR_STRIDE1(x)			VAL_MASK(x, 16, 16)
+#define WIN2_VIR2_3			0x000000bc
+#define  V_WIN2_VIR_STRIDE2(x)			VAL_MASK(x, 16, 0)
+#define  V_WIN2_VIR_STRIDE3(x)			VAL_MASK(x, 16, 16)
+#define WIN2_MST0			0x000000c0
+#define  V_WIN2_MST0(x)				VAL_MASK(x, 32, 0)
+#define WIN2_DSP_INFO0			0x000000c4
+#define  V_WIN2_DSP_WIDTH0(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN2_DSP_HEIGHT0(x)			VAL_MASK(x, 12, 16)
+#define WIN2_DSP_ST0			0x000000c8
+#define  V_WIN2_DSP_XST0(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN2_DSP_YST0(x)			VAL_MASK(x, 13, 16)
+#define WIN2_COLOR_KEY			0x000000cc
+#define  V_WIN2_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
+#define  V_WIN2_KEY_EN(x)			VAL_MASK(x, 1, 24)
+#define WIN2_MST1			0x000000d0
+#define  V_WIN2_MST1(x)				VAL_MASK(x, 32, 0)
+#define WIN2_DSP_INFO1			0x000000d4
+#define  V_WIN2_DSP_WIDTH1(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN2_DSP_HEIGHT1(x)			VAL_MASK(x, 12, 16)
+#define WIN2_DSP_ST1			0x000000d8
+#define  V_WIN2_DSP_XST1(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN2_DSP_YST1(x)			VAL_MASK(x, 13, 16)
+#define WIN2_SRC_ALPHA_CTRL		0x000000dc
+#define  V_WIN2_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_WIN2_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN2_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
+#define  V_WIN2_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
+#define  V_WIN2_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
+#define  V_WIN2_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define  V_WIN2_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN2_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
+#define WIN2_MST2			0x000000e0
+#define  V_WIN2_MST2(x)				VAL_MASK(x, 32, 0)
+#define WIN2_DSP_INFO2			0x000000e4
+#define  V_WIN2_DSP_WIDTH2(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN2_DSP_HEIGHT2(x)			VAL_MASK(x, 12, 16)
+#define WIN2_DSP_ST2			0x000000e8
+#define  V_WIN2_DSP_XST2(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN2_DSP_YST2(x)			VAL_MASK(x, 13, 16)
+#define WIN2_DST_ALPHA_CTRL		0x000000ec
+#define  V_WIN2_DST_M0_RESERVED(x)		VAL_MASK(x, 6, 0)
+#define  V_WIN2_DST_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define WIN2_MST3			0x000000f0
+#define  V_WIN2_MST3(x)				VAL_MASK(x, 32, 0)
+#define WIN2_DSP_INFO3			0x000000f4
+#define  V_WIN2_DSP_WIDTH3(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN2_DSP_HEIGHT3(x)			VAL_MASK(x, 12, 16)
+#define WIN2_DSP_ST3			0x000000f8
+#define  V_WIN2_DSP_XST3(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN2_DSP_YST3(x)			VAL_MASK(x, 13, 16)
+#define WIN2_FADING_CTRL		0x000000fc
+#define  V_WIN2_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
+#define  V_WIN2_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
+#define  V_WIN2_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN2_FADING_EN(x)			VAL_MASK(x, 1, 24)
+#define WIN3_CTRL0			0x00000100
+#define  V_WIN3_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_WIN3_INTERLACE_READ(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN3_CSC_MODE(x)			VAL_MASK(x, 2, 2)
+#define  V_WIN3_MST0_EN(x)			VAL_MASK(x, 1, 4)
+#define  V_WIN3_DATA_FMT0(x)			VAL_MASK(x, 2, 5)
+#define  V_WIN3_MST1_EN(x)			VAL_MASK(x, 1, 8)
+#define  V_WIN3_DATA_FMT1(x)			VAL_MASK(x, 2, 9)
+#define  V_WIN3_MST2_EN(x)			VAL_MASK(x, 1, 12)
+#define  V_WIN3_DATA_FMT2(x)			VAL_MASK(x, 2, 13)
+#define  V_WIN3_MST3_EN(x)			VAL_MASK(x, 1, 16)
+#define  V_WIN3_DATA_FMT3(x)			VAL_MASK(x, 2, 17)
+#define  V_WIN3_RB_SWAP0(x)			VAL_MASK(x, 1, 20)
+#define  V_WIN3_ALPHA_SWAP0(x)			VAL_MASK(x, 1, 21)
+#define  V_WIN3_ENDIAN_SWAP0(x)			VAL_MASK(x, 1, 22)
+#define  V_WIN3_RB_SWAP1(x)			VAL_MASK(x, 1, 23)
+#define  V_WIN3_ALPHA_SWAP1(x)			VAL_MASK(x, 1, 24)
+#define  V_WIN3_ENDIAN_SWAP1(x)			VAL_MASK(x, 1, 25)
+#define  V_WIN3_RB_SWAP2(x)			VAL_MASK(x, 1, 26)
+#define  V_WIN3_ALPHA_SWAP2(x)			VAL_MASK(x, 1, 27)
+#define  V_WIN3_ENDIAN_SWAP2(x)			VAL_MASK(x, 1, 28)
+#define  V_WIN3_RB_SWAP3(x)			VAL_MASK(x, 1, 29)
+#define  V_WIN3_ALPHA_SWAP3(x)			VAL_MASK(x, 1, 30)
+#define  V_WIN3_ENDIAN_SWAP3(x)			VAL_MASK(x, 1, 31)
+#define WIN3_CTRL1			0x00000104
+#define  V_WIN3_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_WIN3_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 1)
+#define  V_WIN3_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
+#define  V_WIN3_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 4)
+#define  V_WIN3_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 8)
+#define  V_WIN3_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 14)
+#define  V_WIN3_Y_MIR_EN(x)			VAL_MASK(x, 1, 15)
+#define  V_WIN3_LUT_EN(x)			VAL_MASK(x, 1, 16)
+#define  V_WIN_RID_WIN3(x)			VAL_MASK(x, 4, 20)
+#define WIN3_VIR0_1			0x00000108
+#define  V_WIN3_VIR_STRIDE0(x)			VAL_MASK(x, 16, 0)
+#define  V_WIN3_VIR_STRIDE1(x)			VAL_MASK(x, 16, 16)
+#define WIN3_VIR2_3			0x0000010c
+#define  V_WIN3_VIR_STRIDE2(x)			VAL_MASK(x, 16, 0)
+#define  V_WIN3_VIR_STRIDE3(x)			VAL_MASK(x, 16, 16)
+#define WIN3_MST0			0x00000110
+#define  V_WIN3_MST0(x)				VAL_MASK(x, 32, 0)
+#define WIN3_DSP_INFO0			0x00000114
+#define  V_WIN3_DSP_WIDTH0(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN3_DSP_HEIGHT0(x)			VAL_MASK(x, 12, 16)
+#define WIN3_DSP_ST0			0x00000118
+#define  V_WIN3_DSP_XST0(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN3_DSP_YST0(x)			VAL_MASK(x, 13, 16)
+#define WIN3_COLOR_KEY			0x0000011c
+#define  V_WIN3_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
+#define  V_WIN3_KEY_EN(x)			VAL_MASK(x, 1, 24)
+#define WIN3_MST1			0x00000120
+#define  V_WIN3_MST1(x)				VAL_MASK(x, 32, 0)
+#define WIN3_DSP_INFO1			0x00000124
+#define  V_WIN3_DSP_WIDTH1(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN3_DSP_HEIGHT1(x)			VAL_MASK(x, 12, 16)
+#define WIN3_DSP_ST1			0x00000128
+#define  V_WIN3_DSP_XST1(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN3_DSP_YST1(x)			VAL_MASK(x, 13, 16)
+#define WIN3_SRC_ALPHA_CTRL		0x0000012c
+#define  V_WIN3_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_WIN3_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN3_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
+#define  V_WIN3_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
+#define  V_WIN3_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
+#define  V_WIN3_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define  V_WIN3_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN3_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
+#define WIN3_MST2			0x00000130
+#define  V_WIN3_MST2(x)				VAL_MASK(x, 32, 0)
+#define WIN3_DSP_INFO2			0x00000134
+#define  V_WIN3_DSP_WIDTH2(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN3_DSP_HEIGHT2(x)			VAL_MASK(x, 12, 16)
+#define WIN3_DSP_ST2			0x00000138
+#define  V_WIN3_DSP_XST2(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN3_DSP_YST2(x)			VAL_MASK(x, 13, 16)
+#define WIN3_DST_ALPHA_CTRL		0x0000013c
+#define  V_WIN3_DST_FACTOR_RESERVED(x)		VAL_MASK(x, 6, 0)
+#define  V_WIN3_DST_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define WIN3_MST3			0x00000140
+#define  V_WIN3_MST3(x)				VAL_MASK(x, 32, 0)
+#define WIN3_DSP_INFO3			0x00000144
+#define  V_WIN3_DSP_WIDTH3(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN3_DSP_HEIGHT3(x)			VAL_MASK(x, 12, 16)
+#define WIN3_DSP_ST3			0x00000148
+#define  V_WIN3_DSP_XST3(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN3_DSP_YST3(x)			VAL_MASK(x, 13, 16)
+#define WIN3_FADING_CTRL		0x0000014c
+#define  V_WIN3_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
+#define  V_WIN3_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
+#define  V_WIN3_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN3_FADING_EN(x)			VAL_MASK(x, 1, 24)
+#define HWC_CTRL0			0x00000150
+#define  V_HWC_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_HWC_DATA_FMT(x)			VAL_MASK(x, 3, 1)
+#define  V_HWC_MODE(x)				VAL_MASK(x, 1, 4)
+#define  V_HWC_SIZE(x)				VAL_MASK(x, 2, 5)
+#define  V_HWC_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
+#define  V_HWC_CSC_MODE(x)			VAL_MASK(x, 2, 10)
+#define  V_HWC_RB_SWAP(x)			VAL_MASK(x, 1, 12)
+#define  V_HWC_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
+#define  V_HWC_ENDIAN_SWAP(x)			VAL_MASK(x, 1, 14)
+#define HWC_CTRL1			0x00000154
+#define  V_HWC_AXI_GATHER_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_HWC_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 1)
+#define  V_HWC_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
+#define  V_HWC_AXI_GATHER_NUM(x)		VAL_MASK(x, 3, 4)
+#define  V_HWC_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 8)
+#define  V_HWC_RGB2YUV_EN(x)			VAL_MASK(x, 1, 13)
+#define  V_HWC_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 14)
+#define  V_HWC_Y_MIR_EN(x)			VAL_MASK(x, 1, 15)
+#define  V_HWC_LUT_EN(x)			VAL_MASK(x, 1, 16)
+#define  V_WIN_RID_HWC(x)			VAL_MASK(x, 4, 20)
+#define HWC_MST				0x00000158
+#define  V_HWC_MST(x)				VAL_MASK(x, 32, 0)
+#define HWC_DSP_ST			0x0000015c
+#define  V_HWC_DSP_XST(x)			VAL_MASK(x, 13, 0)
+#define  V_HWC_DSP_YST(x)			VAL_MASK(x, 13, 16)
+#define HWC_SRC_ALPHA_CTRL		0x00000160
+#define  V_HWC_SRC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_HWC_SRC_COLOR_MODE(x)		VAL_MASK(x, 1, 1)
+#define  V_HWC_SRC_ALPHA_MODE(x)		VAL_MASK(x, 1, 2)
+#define  V_HWC_SRC_BLEND_MODE(x)		VAL_MASK(x, 2, 3)
+#define  V_HWC_SRC_ALPHA_CAL_MODE(x)		VAL_MASK(x, 1, 5)
+#define  V_HWC_SRC_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define  V_HWC_SRC_GLOBAL_ALPHA(x)		VAL_MASK(x, 8, 16)
+#define  V_HWC_FADING_VALUE(x)			VAL_MASK(x, 8, 24)
+#define HWC_DST_ALPHA_CTRL		0x00000164
+#define  V_HWC_DST_M0_RESERVED(x)		VAL_MASK(x, 6, 0)
+#define  V_HWC_DST_FACTOR_MODE(x)		VAL_MASK(x, 3, 6)
+#define HWC_FADING_CTRL			0x00000168
+#define  V_HWC_FADING_OFFSET_R(x)		VAL_MASK(x, 8, 0)
+#define  V_HWC_FADING_OFFSET_G(x)		VAL_MASK(x, 8, 8)
+#define  V_HWC_FADING_OFFSET_B(x)		VAL_MASK(x, 8, 16)
+#define  V_HWC_FADING_EN(x)			VAL_MASK(x, 1, 24)
+#define HWC_RESERVED1			0x0000016c
+#define POST_DSP_HACT_INFO		0x00000170
+#define  V_DSP_HACT_END_POST(x)			VAL_MASK(x, 13, 0)
+#define  V_DSP_HACT_ST_POST(x)			VAL_MASK(x, 13, 16)
+#define POST_DSP_VACT_INFO		0x00000174
+#define  V_DSP_VACT_END_POST(x)			VAL_MASK(x, 13, 0)
+#define  V_DSP_VACT_ST_POST(x)			VAL_MASK(x, 13, 16)
+#define POST_SCL_FACTOR_YRGB		0x00000178
+#define  V_POST_HS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 0)
+#define  V_POST_VS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 16)
+#define POST_RESERVED			0x0000017c
+#define POST_SCL_CTRL			0x00000180
+#define  V_POST_HOR_SD_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_POST_VER_SD_EN(x)			VAL_MASK(x, 1, 1)
+#define  V_DSP_OUT_RGB_YUV(x)			VAL_MASK(x, 1, 2)
+#define POST_DSP_VACT_INFO_F1		0x00000184
+#define  V_DSP_VACT_END_POST(x)			VAL_MASK(x, 13, 0)
+#define  V_DSP_VACT_ST_POST(x)			VAL_MASK(x, 13, 16)
+#define DSP_HTOTAL_HS_END		0x00000188
+#define  V_DSP_HS_END(x)			VAL_MASK(x, 13, 0)
+#define  V_DSP_HTOTAL(x)			VAL_MASK(x, 13, 16)
+#define DSP_HACT_ST_END			0x0000018c
+#define  V_DSP_HACT_END(x)			VAL_MASK(x, 13, 0)
+#define  V_DSP_HACT_ST(x)			VAL_MASK(x, 13, 16)
+#define DSP_VTOTAL_VS_END		0x00000190
+#define  V_DSP_VS_END(x)			VAL_MASK(x, 13, 0)
+#define  V_SW_DSP_VTOTAL_IMD(x)			VAL_MASK(x, 1, 15)
+#define  V_DSP_VTOTAL(x)			VAL_MASK(x, 13, 16)
+#define DSP_VACT_ST_END			0x00000194
+#define  V_DSP_VACT_END(x)			VAL_MASK(x, 13, 0)
+#define  V_DSP_VACT_ST(x)			VAL_MASK(x, 13, 16)
+#define DSP_VS_ST_END_F1		0x00000198
+#define  V_DSP_VS_END_F1(x)			VAL_MASK(x, 13, 0)
+#define  V_DSP_VS_ST_F1(x)			VAL_MASK(x, 13, 16)
+#define DSP_VACT_ST_END_F1		0x0000019c
+#define  V_DSP_VACT_END_F1(x)			VAL_MASK(x, 13, 0)
+#define  V_DSP_VACT_ST_F1(x)			VAL_MASK(x, 13, 16)
+#define PWM_CTRL			0x000001a0
+#define  V_PWM_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_PWM_MODE(x)				VAL_MASK(x, 2, 1)
+#define  V_DUTY_POL(x)				VAL_MASK(x, 1, 3)
+#define  V_INACTIVE_POL(x)			VAL_MASK(x, 1, 4)
+#define  V_OUTPUT_MODE(x)			VAL_MASK(x, 1, 5)
+#define  V_LP_EN(x)				VAL_MASK(x, 1, 8)
+#define  V_CLK_SEL(x)				VAL_MASK(x, 1, 9)
+#define  V_PRESCALE(x)				VAL_MASK(x, 3, 12)
+#define  V_SCALE(x)				VAL_MASK(x, 8, 16)
+#define  V_RPT(x)				VAL_MASK(x, 8, 24)
+#define PWM_PERIOD_HPR			0x000001a4
+#define  V_PWM_PERIOD(x)			VAL_MASK(x, 32, 0)
+#define PWM_DUTY_LPR			0x000001a8
+#define  V_PWM_DUTY(x)				VAL_MASK(x, 32, 0)
+#define PWM_CNT				0x000001ac
+#define  V_PWM_CNT(x)				VAL_MASK(x, 32, 0)
+#define BCSH_COLOR_BAR			0x000001b0
+#define  V_BCSH_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_COLOR_BAR_Y(x)			VAL_MASK(x, 8, 8)
+#define  V_COLOR_BAR_U(x)			VAL_MASK(x, 8, 16)
+#define  V_COLOR_BAR_V(x)			VAL_MASK(x, 8, 24)
+#define BCSH_BCS			0x000001b4
+#define  V_BRIGHTNESS(x)			VAL_MASK(x, 8, 0)
+#define  V_CONTRAST(x)				VAL_MASK(x, 9, 8)
+#define  V_SAT_CON(x)				VAL_MASK(x, 10, 20)
+#define  V_OUT_MODE(x)				VAL_MASK(x, 2, 30)
+#define BCSH_H				0x000001b8
+#define  V_SIN_HUE(x)				VAL_MASK(x, 9, 0)
+#define  V_COS_HUE(x)				VAL_MASK(x, 9, 16)
+#define BCSH_CTRL			0x000001bc
+#define  V_BCSH_Y2R_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_BCSH_Y2R_CSC_MODE(x)			VAL_MASK(x, 2, 2)
+#define  V_BCSH_R2Y_EN(x)			VAL_MASK(x, 1, 4)
+#define  V_BCSH_R2Y_CSC_MODE(x)			VAL_MASK(x, 1, 6)
+#define CABC_CTRL0			0x000001c0
+#define  V_CABC_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_CABC_HANDLE_EN(x)			VAL_MASK(x, 1, 1)
+#define  V_PWM_CONFIG_MODE(x)			VAL_MASK(x, 2, 2)
+#define  V_CABC_CALC_PIXEL_NUM(x)		VAL_MASK(x, 23, 4)
+#define CABC_CTRL1			0x000001c4
+#define  V_CABC_LUT_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_CABC_TOTAL_NUM(x)			VAL_MASK(x, 23, 4)
+#define CABC_CTRL2			0x000001c8
+#define  V_CABC_STAGE_DOWN(x)			VAL_MASK(x, 8, 0)
+#define  V_CABC_STAGE_UP(x)			VAL_MASK(x, 9, 8)
+#define  V_CABC_STAGE_UP_MODE(x)		VAL_MASK(x, 1, 19)
+#define  V_MAX_SCALE_CFG_VALUE(x) 		VAL_MASK(x, 9, 20)
+#define  V_MAX_SCALE_CFG_ENABLE(x) 		VAL_MASK(x, 1, 31)
+#define CABC_CTRL3			0x000001cc
+#define  V_CABC_GLOBAL_DN(x)			VAL_MASK(x, 8, 0)
+#define  V_CABC_GLOBAL_DN_LIMIT_EN(x)		VAL_MASK(x, 1, 8)
+#define CABC_GAUSS_LINE0_0		0x000001d0
+#define  V_T_LINE0_0(x)				VAL_MASK(x, 8, 0)
+#define  V_T_LINE0_1(x)				VAL_MASK(x, 8, 8)
+#define  V_T_LINE0_2(x)				VAL_MASK(x, 8, 16)
+#define  V_T_LINE0_3(x)				VAL_MASK(x, 8, 24)
+#define CABC_GAUSS_LINE0_1		0x000001d4
+#define  V_T_LINE0_4(x)				VAL_MASK(x, 8, 0)
+#define  V_T_LINE0_5(x)				VAL_MASK(x, 8, 8)
+#define  V_T_LINE0_6(x)				VAL_MASK(x, 8, 16)
+#define CABC_GAUSS_LINE1_0		0x000001d8
+#define  V_T_LINE1_0(x)				VAL_MASK(x, 8, 0)
+#define  V_T_LINE1_1(x)				VAL_MASK(x, 8, 8)
+#define  V_T_LINE1_2(x)				VAL_MASK(x, 8, 16)
+#define  V_T_LINE1_3(x)				VAL_MASK(x, 8, 24)
+#define CABC_GAUSS_LINE1_1		0x000001dc
+#define  V_T_LINE1_4(x)				VAL_MASK(x, 8, 0)
+#define  V_T_LINE1_5(x)				VAL_MASK(x, 8, 8)
+#define  V_T_LINE1_6(x)				VAL_MASK(x, 8, 16)
+#define CABC_GAUSS_LINE2_0		0x000001e0
+#define  V_T_LINE2_0(x)				VAL_MASK(x, 8, 0)
+#define  V_T_LINE2_1(x)				VAL_MASK(x, 8, 8)
+#define  V_T_LINE2_2(x)				VAL_MASK(x, 8, 16)
+#define  V_T_LINE2_3(x)				VAL_MASK(x, 8, 24)
+#define CABC_GAUSS_LINE2_1		0x000001e4
+#define  V_T_LINE2_4(x)				VAL_MASK(x, 8, 0)
+#define  V_T_LINE2_5(x)				VAL_MASK(x, 8, 8)
+#define  V_T_LINE2_6(x)				VAL_MASK(x, 8, 16)
+#define FRC_LOWER01_0			0x000001e8
+#define  V_LOWER01_FRM0(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER01_FRM1(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER01_1			0x000001ec
+#define  V_LOWER01_FRM2(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER01_FRM3(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER10_0			0x000001f0
+#define  V_LOWER10_FRM0(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER10_FRM1(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER10_1			0x000001f4
+#define  V_LOWER10_FRM2(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER10_FRM3(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER11_0			0x000001f8
+#define  V_LOWER11_FRM0(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER11_FRM1(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER11_1			0x000001fc
+#define  V_LOWER11_FRM2(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER11_FRM3(x)			VAL_MASK(x, 16, 16)
+#define AFBCD0_CTRL			0x00000200
+#define  V_VOP_FBDC_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_VOP_FBDC_WIN_SEL(x)			VAL_MASK(x, 2, 1)
+#define  V_FBDC_RSTN(x)				VAL_MASK(x, 1, 3)
+#define  V_VOP_FBDC_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 4)
+#define  V_VOP_FBDC_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 9)
+#define  V_FBDC_RID(x)				VAL_MASK(x, 4, 12)
+#define  V_AFBCD_HREG_PIXEL_PACKING_FMT(x)	VAL_MASK(x, 5, 16)
+#define  V_AFBCD_HREG_BLOCK_SPLIT(x)		VAL_MASK(x, 1, 21)
+#define AFBCD0_HDR_PTR			0x00000204
+#define  V_AFBCD_HREG_HDR_PTR(x)		VAL_MASK(x, 32, 0)
+#define AFBCD0_PIC_SIZE			0x00000208
+#define  V_AFBCD_HREG_PIC_WIDTH(x)		VAL_MASK(x, 16, 0)
+#define  V_AFBCD_HREG_PIC_HEIGHT(x)		VAL_MASK(x, 16, 16)
+#define AFBCD0_STATUS			0x0000020c
+#define  V_AFBCD_HREG_IDLE_N(x)			VAL_MASK(x, 1, 0)
+#define  V_AFBCD_HREG_DEC_RESP(x)		VAL_MASK(x, 1, 1)
+#define  V_AFBCD_HREG_AXI_RRESP(x)		VAL_MASK(x, 1, 2)
+#define AFBCD1_CTRL			0x00000220
+#define  V_VOP_FBDC1_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_VOP_FBDC1_WIN_SEL(x)			VAL_MASK(x, 2, 1)
+#define  V_FBDC1_RSTN(x)				VAL_MASK(x, 1, 3)
+#define  V_VOP_FBDC1_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 4)
+#define  V_VOP_FBDC1_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 9)
+#define  V_FBDC1_RID(x)				VAL_MASK(x, 4, 12)
+#define  V_AFBCD1_HREG_PIXEL_PACKING_FMT(x)	VAL_MASK(x, 5, 16)
+#define  V_AFBCD1_HREG_BLOCK_SPLIT(x)		VAL_MASK(x, 1, 21)
+#define AFBCD1_HDR_PTR			0x00000224
+#define  V_AFBCD1_HREG_HDR_PTR(x)		VAL_MASK(x, 32, 0)
+#define AFBCD1_PIC_SIZE			0x00000228
+#define  V_AFBCD1_HREG_PIC_WIDTH(x)		VAL_MASK(x, 16, 0)
+#define  V_AFBCD1_HREG_PIC_HEIGHT(x)		VAL_MASK(x, 16, 16)
+#define AFBCD1_STATUS			0x0000022c
+#define  V_AFBCD1_HREG_IDLE_N(x)			VAL_MASK(x, 1, 0)
+#define  V_AFBCD1_HREG_DEC_RESP(x)		VAL_MASK(x, 1, 1)
+#define  V_AFBCD1_HREG_AXI_RRESP(x)		VAL_MASK(x, 1, 2)
+#define AFBCD2_CTRL			0x00000240
+#define  V_VOP_FBDC2_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_VOP_FBDC2_WIN_SEL(x)			VAL_MASK(x, 2, 1)
+#define  V_FBDC2_RSTN(x)				VAL_MASK(x, 1, 3)
+#define  V_VOP_FBDC2_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 4)
+#define  V_VOP_FBDC2_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 9)
+#define  V_FBDC2_RID(x)				VAL_MASK(x, 4, 12)
+#define  V_AFBCD2_HREG_PIXEL_PACKING_FMT(x)	VAL_MASK(x, 5, 16)
+#define  V_AFBCD2_HREG_BLOCK_SPLIT(x)		VAL_MASK(x, 1, 21)
+#define AFBCD2_HDR_PTR			0x00000244
+#define  V_AFBCD2_HREG_HDR_PTR(x)		VAL_MASK(x, 32, 0)
+#define AFBCD2_PIC_SIZE			0x00000248
+#define  V_AFBCD2_HREG_PIC_WIDTH(x)		VAL_MASK(x, 16, 0)
+#define  V_AFBCD2_HREG_PIC_HEIGHT(x)		VAL_MASK(x, 16, 16)
+#define AFBCD2_STATUS			0x0000024c
+#define  V_AFBCD2_HREG_IDLE_N(x)			VAL_MASK(x, 1, 0)
+#define  V_AFBCD2_HREG_DEC_RESP(x)		VAL_MASK(x, 1, 1)
+#define  V_AFBCD2_HREG_AXI_RRESP(x)		VAL_MASK(x, 1, 2)
+#define AFBCD3_CTRL			0x00000260
+#define  V_VOP_FBDC3_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_VOP_FBDC3_WIN_SEL(x)			VAL_MASK(x, 1, 1)
+#define  V_FBDC3_RSTN(x)				VAL_MASK(x, 1, 2)
+#define  V_VOP_FBDC3_AXI_MAX_OUTSTANDING_NUM(x)	VAL_MASK(x, 5, 3)
+#define  V_VOP_FBDC3_AXI_MAX_OUTSTANDING_EN(x)	VAL_MASK(x, 1, 8)
+#define  V_FBDC3_RID(x)				VAL_MASK(x, 4, 12)
+#define  V_AFBCD3_HREG_PIXEL_PACKING_FMT(x)	VAL_MASK(x, 5, 16)
+#define  V_AFBCD3_HREG_BLOCK_SPLIT(x)		VAL_MASK(x, 1, 21)
+#define AFBCD3_HDR_PTR			0x00000264
+#define  V_AFBCD3_HREG_HDR_PTR(x)		VAL_MASK(x, 32, 0)
+#define AFBCD3_PIC_SIZE			0x00000268
+#define  V_AFBCD3_HREG_PIC_WIDTH(x)		VAL_MASK(x, 16, 0)
+#define  V_AFBCD3_HREG_PIC_HEIGHT(x)		VAL_MASK(x, 16, 16)
+#define AFBCD3_STATUS			0x0000026c
+#define  V_AFBCD3_HREG_IDLE_N(x)			VAL_MASK(x, 1, 0)
+#define  V_AFBCD3_HREG_DEC_RESP(x)		VAL_MASK(x, 1, 1)
+#define  V_AFBCD3_HREG_AXI_RRESP(x)		VAL_MASK(x, 1, 2)
+#define INTR_EN0			0x00000280
+#define  V_INTR_EN_FS(x)			VAL_MASK(x, 1, 0)
+#define  V_INTR_EN_FS_NEW(x)			VAL_MASK(x, 1, 1)
+#define  V_INTR_EN_ADDR_SAME(x)			VAL_MASK(x, 1, 2)
+#define  V_INTR_EN_LINE_FLAG0(x)		VAL_MASK(x, 1, 3)
+#define  V_INTR_EN_LINE_FLAG1(x)		VAL_MASK(x, 1, 4)
+#define  V_INTR_EN_BUS_ERROR(x)			VAL_MASK(x, 1, 5)
+#define  V_INTR_EN_WIN0_EMPTY(x)		VAL_MASK(x, 1, 6)
+#define  V_INTR_EN_WIN1_EMPTY(x)		VAL_MASK(x, 1, 7)
+#define  V_INTR_EN_WIN2_EMPTY(x)		VAL_MASK(x, 1, 8)
+#define  V_INTR_EN_WIN3_EMPTY(x)		VAL_MASK(x, 1, 9)
+#define  V_INTR_EN_HWC_EMPTY(x)			VAL_MASK(x, 1, 10)
+#define  V_INTR_EN_POST_BUF_EMPTY(x)		VAL_MASK(x, 1, 11)
+/* rk3399 only */
+#define  V_INTR_EN_FS_FIELD(x)			VAL_MASK(x, 1, 12)
+/* rk322x only */
+#define  V_INTR_EN_PWM_GEN(x)			VAL_MASK(x, 1, 12)
+#define  V_INTR_EN_DSP_HOLD_VALID(x)		VAL_MASK(x, 1, 13)
+#define  V_INTR_EN_MMU(x)			VAL_MASK(x, 1, 14)
+#define  V_INTR_EN_DMA_FINISH(x)		VAL_MASK(x, 1, 15)
+#define  V_WRITE_MASK(x)			VAL_MASK(x, 16, 16)
+#define INTR_CLEAR0			0x00000284
+#define  V_INT_CLR_FS(x)			VAL_MASK(x, 1, 0)
+#define  V_INT_CLR_FS_NEW(x)			VAL_MASK(x, 1, 1)
+#define  V_INT_CLR_ADDR_SAME(x)			VAL_MASK(x, 1, 2)
+#define  V_INT_CLR_LINE_FLAG0(x)		VAL_MASK(x, 1, 3)
+#define  V_INT_CLR_LINE_FLAG1(x)		VAL_MASK(x, 1, 4)
+#define  V_INT_CLR_BUS_ERROR(x)			VAL_MASK(x, 1, 5)
+#define  V_INT_CLR_WIN0_EMPTY(x)		VAL_MASK(x, 1, 6)
+#define  V_INT_CLR_WIN1_EMPTY(x)		VAL_MASK(x, 1, 7)
+#define  V_INT_CLR_WIN2_EMPTY(x)		VAL_MASK(x, 1, 8)
+#define  V_INT_CLR_WIN3_EMPTY(x)		VAL_MASK(x, 1, 9)
+#define  V_INT_CLR_HWC_EMPTY(x)			VAL_MASK(x, 1, 10)
+#define  V_INT_CLR_POST_BUF_EMPTY(x)		VAL_MASK(x, 1, 11)
+/* rk3399 only */
+#define  V_INT_CLR_FS_FIELD(x)			VAL_MASK(x, 1, 12)
+/* rk322x only */
+#define  V_INT_CLR_PWM_GEN(x)			VAL_MASK(x, 1, 12)
+#define  V_INT_CLR_DSP_HOLD_VALID(x)		VAL_MASK(x, 1, 13)
+#define  V_INT_CLR_MMU(x)			VAL_MASK(x, 1, 14)
+#define  V_INT_CLR_DMA_FINISH(x)		VAL_MASK(x, 1, 15)
+#define  V_WRITE_MASK(x)			VAL_MASK(x, 16, 16)
+#define INTR_STATUS0			0x00000288
+#define  V_INT_STATUS_FS(x)			VAL_MASK(x, 1, 0)
+#define  V_INT_STATUS_FS_NEW(x)			VAL_MASK(x, 1, 1)
+#define  V_INT_STATUS_ADDR_SAME(x)		VAL_MASK(x, 1, 2)
+#define  V_INT_STATUS_LINE_FLAG0(x)		VAL_MASK(x, 1, 3)
+#define  V_INT_STATUS_LINE_FLAG1(x)		VAL_MASK(x, 1, 4)
+#define  V_INT_STATUS_BUS_ERROR(x)		VAL_MASK(x, 1, 5)
+#define  V_INT_STATUS_WIN0_EMPTY(x)		VAL_MASK(x, 1, 6)
+#define  V_INT_STATUS_WIN1_EMPTY(x)		VAL_MASK(x, 1, 7)
+#define  V_INT_STATUS_WIN2_EMPTY(x)		VAL_MASK(x, 1, 8)
+#define  V_INT_STATUS_WIN3_EMPTY(x)		VAL_MASK(x, 1, 9)
+#define  V_INT_STATUS_HWC_EMPTY(x)		VAL_MASK(x, 1, 10)
+#define  V_INT_STATUS_POST_BUF_EMPTY(x)		VAL_MASK(x, 1, 11)
+/* rk3399 only */
+#define  V_INT_STATUS_FS_FIELD(x)		VAL_MASK(x, 1, 12)
+/* rk322x only */
+#define  V_INT_STATUS_PWM_GEN(x)		VAL_MASK(x, 1, 12)
+#define  V_INT_STATUS_DSP_HOLD_VALID(x)		VAL_MASK(x, 1, 13)
+#define  V_INT_STATUS_MMU(x)			VAL_MASK(x, 1, 14)
+#define  V_INT_STATUS_DMA_FINISH(x)		VAL_MASK(x, 1, 15)
+#define INTR_RAW_STATUS0		0x0000028c
+#define  V_INT_RAW_STATUS_FS(x)			VAL_MASK(x, 1, 0)
+#define  V_INT_RAW_STATUS_FS_NEW(x)		VAL_MASK(x, 1, 1)
+#define  V_INT_RAW_STATUS_ADDR_SAME(x)		VAL_MASK(x, 1, 2)
+#define  V_INT_RAW_STATUS_LINE_FRAG0(x)		VAL_MASK(x, 1, 3)
+#define  V_INT_RAW_STATUS_LINE_FRAG1(x)		VAL_MASK(x, 1, 4)
+#define  V_INT_RAW_STATUS_BUS_ERROR(x)		VAL_MASK(x, 1, 5)
+#define  V_INT_RAW_STATUS_WIN0_EMPTY(x)		VAL_MASK(x, 1, 6)
+#define  V_INT_RAW_STATUS_WIN1_EMPTY(x)		VAL_MASK(x, 1, 7)
+#define  V_INT_RAW_STATUS_WIN2_EMPTY(x)		VAL_MASK(x, 1, 8)
+#define  V_INT_RAW_STATUS_WIN3_EMPTY(x)		VAL_MASK(x, 1, 9)
+#define  V_INT_RAW_STATUS_HWC_EMPTY(x)		VAL_MASK(x, 1, 10)
+#define  V_INT_RAW_STATUS_POST_BUF_EMPTY(x)	VAL_MASK(x, 1, 11)
+/* rk3399 only */
+#define  V_INT_RAW_STATUS_FS_FIELD(x)		VAL_MASK(x, 1, 12)
+/* rk322x only */
+#define  V_INT_RAW_STATUS_PWM_GEN(x)		VAL_MASK(x, 1, 12)
+#define  V_INT_RAW_STATUS_DSP_HOLD_VALID(x)	VAL_MASK(x, 1, 13)
+#define  V_INT_RAW_STATUS_MMU(x)		VAL_MASK(x, 1, 14)
+#define  V_INT_RAW_STATUS_DMA_FINISH(x)		VAL_MASK(x, 1, 15)
+#define INTR_EN1			0x00000290
+#define  V_INT_EN_FBCD0(x)			VAL_MASK(x, 1, 0)
+#define  V_INT_EN_FBCD1(x)			VAL_MASK(x, 1, 1)
+#define  V_INT_EN_FBCD2(x)			VAL_MASK(x, 1, 2)
+#define  V_INT_EN_FBCD3(x)			VAL_MASK(x, 1, 3)
+#define  V_INT_EN_AFBCD0_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 4)
+#define  V_INT_EN_AFBCD0_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 5)
+#define  V_INT_EN_AFBCD1_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 6)
+#define  V_INT_EN_AFBCD1_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 7)
+#define  V_INT_EN_AFBCD2_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 8)
+#define  V_INT_EN_AFBCD2_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 9)
+#define  V_INT_EN_AFBCD3_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 10)
+#define  V_INT_EN_AFBCD3_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 11)
+#define  V_INT_EN_WB_YRGB_FIFO_FULL(x)		VAL_MASK(x, 1, 12)
+#define  V_INT_EN_WB_UV_FIFO_FULL(x)		VAL_MASK(x, 1, 13)
+#define  V_INT_EN_WB_FINISH(x)			VAL_MASK(x, 1, 14)
+#define  V_INT_EN_VFP(x)			VAL_MASK(x, 1, 15)
+#define  V_WRITE_MASK(x)			VAL_MASK(x, 16, 16)
+#define INTR_CLEAR1			0x00000294
+#define  V_INT_CLR_FBCD0(x)			VAL_MASK(x, 1, 0)
+#define  V_INT_CLR_FBCD1(x)			VAL_MASK(x, 1, 1)
+#define  V_INT_CLR_FBCD2(x)			VAL_MASK(x, 1, 2)
+#define  V_INT_CLR_FBCD3(x)			VAL_MASK(x, 1, 3)
+#define  V_INT_CLR_AFBCD0_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 4)
+#define  V_INT_CLR_AFBCD0_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 5)
+#define  V_INT_CLR_AFBCD1_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 6)
+#define  V_INT_CLR_AFBCD1_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 7)
+#define  V_INT_CLR_AFBCD2_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 8)
+#define  V_INT_CLR_AFBCD2_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 9)
+#define  V_INT_CLR_AFBCD3_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 10)
+#define  V_INT_CLR_AFBCD3_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 11)
+#define  V_INT_CLR_WB_YRGB_FIFO_FULL(x)		VAL_MASK(x, 1, 12)
+#define  V_INT_CLR_WB_UV_FIFO_FULL(x)		VAL_MASK(x, 1, 13)
+#define  V_INT_CLR_WB_DMA_FINISH(x)		VAL_MASK(x, 1, 14)
+#define  V_INT_CLR_VFP(x)			VAL_MASK(x, 1, 15)
+#define INTR_STATUS1			0x00000298
+#define  V_INT_STATUS_FBCD0(x)			VAL_MASK(x, 1, 0)
+#define  V_INT_STATUS_FBCD1(x)			VAL_MASK(x, 1, 1)
+#define  V_INT_STATUS_FBCD2(x)			VAL_MASK(x, 1, 2)
+#define  V_INT_STATUS_FBCD3(x)			VAL_MASK(x, 1, 3)
+#define  V_INT_STATUS_AFBCD0_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 4)
+#define  V_INT_STATUS_AFBCD0_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 5)
+#define  V_INT_STATUS_AFBCD1_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 6)
+#define  V_INT_STATUS_AFBCD1_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 7)
+#define  V_INT_STATUS_AFBCD2_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 8)
+#define  V_INT_STATUS_AFBCD2_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 9)
+#define  V_INT_STATUS_AFBCD3_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 10)
+#define  V_INT_STATUS_AFBCD4_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 11)
+#define  V_INT_STATUS_WB_YRGB_FIFO_FULL(x)	VAL_MASK(x, 1, 12)
+#define  V_INT_STATUS_WB_UV_FIFO_FULL(x)	VAL_MASK(x, 1, 13)
+#define  V_INT_STATUS_WB_DMA_FINISH(x)		VAL_MASK(x, 1, 14)
+#define  V_INT_STATUS_VFP(x)			VAL_MASK(x, 1, 15)
+#define INTR_RAW_STATUS1		0x0000029c
+#define  V_INT_RAW_STATUS_FBCD0(x)		VAL_MASK(x, 1, 0)
+#define  V_INT_RAW_STATUS_FBCD1(x)		VAL_MASK(x, 1, 1)
+#define  V_INT_RAW_STATUS_FBCD2(x)		VAL_MASK(x, 1, 2)
+#define  V_INT_RAW_STATUS_FBCD3(x)		VAL_MASK(x, 1, 3)
+#define  V_INT_RAW_STATUS_AFBCD0_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 4)
+#define  V_INT_RAW_STATUS_AFBCD0_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 5)
+#define  V_INT_RAW_STATUS_AFBCD1_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 6)
+#define  V_INT_RAW_STATUS_AFBCD1_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 7)
+#define  V_INT_RAW_STATUS_AFBCD2_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 8)
+#define  V_INT_RAW_STATUS_AFBCD2_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 9)
+#define  V_INT_RAW_STATUS_AFBCD3_HREG_DEC_RESP(x)	VAL_MASK(x, 1, 10)
+#define  V_INT_RAW_STATUS_AFBCD3_HREG_AXI_RRESP(x)	VAL_MASK(x, 1, 11)
+#define  V_INT_RAW_STATUS_WB_YRGB_FIFO_FULL(x)	VAL_MASK(x, 1, 12)
+#define  V_INT_RAW_STATUS_WB_UV_FIFO_FULL(x)	VAL_MASK(x, 1, 13)
+#define  V_INT_RAW_STATUS_WB_DMA_FINISH(x)	VAL_MASK(x, 1, 14)
+#define  V_INT_RAW_STATUS_VFP(x)		VAL_MASK(x, 1, 15)
+#define LINE_FLAG			0x000002a0
+#define  V_DSP_LINE_FLAG_NUM_0(x)		VAL_MASK(x, 13, 0)
+#define  V_DSP_LINE_FLAG_NUM_1(x)		VAL_MASK(x, 13, 16)
+#define VOP_STATUS			0x000002a4
+#define  V_DSP_VCNT(x)				VAL_MASK(x, 13, 0)
+#define  V_MMU_IDLE(x)				VAL_MASK(x, 1, 16)
+#define  V_DMA_STOP_VALID(x)			VAL_MASK(x, 1, 17)
+#define BLANKING_VALUE			0x000002a8
+#define  V_BLANKING_VALUE(x)			VAL_MASK(x, 24, 0)
+#define  V_BLANKING_VALUE_CONFIG_EN(x)		VAL_MASK(x, 1, 24)
+#define MCU_BYPASS_PORT			0x000002ac
+#define WIN0_DSP_BG			0x000002b0
+#define  V_WIN0_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
+#define  V_WIN0_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
+#define  V_WIN0_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
+#define  V_WIN0_BG_EN(x)			VAL_MASK(x, 1, 31)
+#define WIN1_DSP_BG			0x000002b4
+#define  V_WIN1_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
+#define  V_WIN1_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
+#define  V_WIN1_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
+#define  V_WIN1_BG_EN(x)			VAL_MASK(x, 1, 31)
+#define WIN2_DSP_BG			0x000002b8
+#define  V_WIN2_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
+#define  V_WIN2_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
+#define  V_WIN2_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
+#define  V_WIN2_BG_EN(x)			VAL_MASK(x, 1, 31)
+#define WIN3_DSP_BG			0x000002bc
+#define  V_WIN3_DSP_BG_BLUE(x)			VAL_MASK(x, 10, 0)
+#define  V_WIN3_DSP_BG_GREEN(x)			VAL_MASK(x, 10, 10)
+#define  V_WIN3_DSP_BG_RED(x)			VAL_MASK(x, 10, 20)
+#define  V_WIN3_BG_EN(x)			VAL_MASK(x, 1, 31)
+#define YUV2YUV_WIN			0x000002c0
+#define  V_WIN0_YUV2YUV_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_WIN0_YUV2YUV_Y2R_EN(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN0_YUV2YUV_R2Y_EN(x)		VAL_MASK(x, 1, 2)
+#define  V_WIN0_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 3)
+#define  V_WIN0_YUV2YUV_Y2R_MODE(x)		VAL_MASK(x, 2, 4)
+#define  V_WIN0_YUV2YUV_R2Y_MODE(x)		VAL_MASK(x, 2, 6)
+#define  V_WIN1_YUV2YUV_EN(x)			VAL_MASK(x, 1, 8)
+#define  V_WIN1_YUV2YUV_Y2R_EN(x)		VAL_MASK(x, 1, 9)
+#define  V_WIN1_YUV2YUV_R2Y_EN(x)		VAL_MASK(x, 1, 10)
+#define  V_WIN1_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 11)
+#define  V_WIN1_YUV2YUV_Y2R_MODE(x)		VAL_MASK(x, 2, 12)
+#define  V_WIN1_YUV2YUV_R2Y_MODE(x)		VAL_MASK(x, 2, 14)
+#define  V_WIN2_YUV2YUV_EN(x)			VAL_MASK(x, 1, 16)
+#define  V_WIN2_YUV2YUV_R2Y_EN(x)		VAL_MASK(x, 1, 18)
+#define  V_WIN2_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 19)
+#define  V_WIN2_YUV2YUV_R2Y_MODE(x)		VAL_MASK(x, 2, 22)
+#define  V_WIN3_YUV2YUV_EN(x)			VAL_MASK(x, 1, 24)
+#define  V_WIN3_YUV2YUV_R2Y_EN(x)		VAL_MASK(x, 1, 26)
+#define  V_WIN3_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 27)
+#define  V_WIN3_YUV2YUV_R2Y_MODE(x)		VAL_MASK(x, 2, 30)
+#define YUV2YUV_POST			0x000002c4
+#define  V_YUV2YUV_POST_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_YUV2YUV_POST_Y2R_EN(x)		VAL_MASK(x, 1, 1)
+#define  V_YUV2YUV_POST_R2Y_EN(x)		VAL_MASK(x, 1, 2)
+#define  V_YUV2YUV_GAMMA_MODE(x)		VAL_MASK(x, 1, 3)
+#define  V_YUV2YUV_POST_Y2R_MODE(x)		VAL_MASK(x, 2, 4)
+#define  V_YUV2YUV_POST_R2Y_MODE(x)		VAL_MASK(x, 2, 6)
+#define AUTO_GATING_EN			0x000002cc
+#define  V_WIN0_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_WIN1_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN2_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 2)
+#define  V_WIN3_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 3)
+#define  V_HWC_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 4)
+#define  V_OVERLAY_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 5)
+#define  V_GAMMA_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 6)
+#define  V_CABC_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 7)
+#define  V_WB_ACLK_GATING_EN(x)			VAL_MASK(x, 1, 8)
+#define  V_PWM_PWMCLK_GATING_EN(x)		VAL_MASK(x, 1, 9)
+#define  V_DIRECT_PATH_ACLK_GATING_EN(x)	VAL_MASK(x, 1, 10)
+#define  V_FBCD0_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 12)
+#define  V_FBCD1_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 13)
+#define  V_FBCD2_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 14)
+#define  V_FBCD3_ACLK_GATING_EN(x)		VAL_MASK(x, 1, 15)
+#define DBG_PERF_LATENCY_CTRL0		0x00000300
+#define  V_RD_LATENCY_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_HAND_LATENCY_CLR(x)			VAL_MASK(x, 1, 1)
+#define  V_RD_LATENCY_MODE(x)			VAL_MASK(x, 1, 2)
+#define  V_RD_LATENCY_ID0(x)			VAL_MASK(x, 4, 4)
+#define  V_RD_LATENCY_THR(x)			VAL_MASK(x, 12, 8)
+#define  V_RD_LATENCY_ST_NUM(x)			VAL_MASK(x, 5, 20)
+#define DBG_PERF_RD_MAX_LATENCY_NUM0	0x00000304
+#define  V_RD_MAX_LATENCY_NUM_CH0(x)		VAL_MASK(x, 12, 0)
+#define  V_RD_LATENCY_OVERFLOW_CH0(x)		VAL_MASK(x, 1, 16)
+#define DBG_PERF_RD_LATENCY_THR_NUM0	0x00000308
+#define  V_RD_LATENCY_THR_NUM_CH0(x)		VAL_MASK(x, 24, 0)
+#define DBG_PERF_RD_LATENCY_SAMP_NUM0	0x0000030c
+#define  V_RD_LATENCY_SAMP_NUM_CH0(x)		VAL_MASK(x, 24, 0)
+#define DBG_CABC0			0x00000310
+#define DBG_CABC1			0x00000314
+#define DBG_CABC2			0x00000318
+#define  V_PWM_MUL_POST_VALUE(x)		VAL_MASK(x, 8, 8)
+#define DBG_CABC3			0x0000031c
+#define DBG_WIN0_REG0			0x00000320
+#define DBG_WIN0_REG1			0x00000324
+#define DBG_WIN0_REG2			0x00000328
+#define  V_DBG_WIN0_YRGB_CMD_LINE_CNT(x)	VAL_MASK(x, 13, 16)
+#define DBG_WIN0_RESERVED		0x0000032c
+#define DBG_WIN1_REG0			0x00000330
+#define DBG_WIN1_REG1			0x00000334
+#define DBG_WIN1_REG2			0x00000338
+#define DBG_WIN1_RESERVED		0x0000033c
+#define DBG_WIN2_REG0			0x00000340
+#define DBG_WIN2_REG1			0x00000344
+#define DBG_WIN2_REG2			0x00000348
+#define DBG_WIN2_REG3			0x0000034c
+#define DBG_WIN3_REG0			0x00000350
+#define DBG_WIN3_REG1			0x00000354
+#define DBG_WIN3_REG2			0x00000358
+#define DBG_WIN3_REG3			0x0000035c
+#define DBG_PRE_REG0			0x00000360
+#define DBG_PRE_RESERVED		0x00000364
+#define DBG_POST_REG0			0x00000368
+#define DBG_POST_REG1			0x0000036c
+#define  V_GAMMA_A2HCLK_CHANGE_DONE(x)		VAL_MASK(x, 1, 0)
+#define  V_WHICH_GAMMA_LUT_WORKING(x)		VAL_MASK(x, 1, 1)
+#define DBG_DATAO			0x00000370
+#define  V_SW_DATAO_SEL(x)			VAL_MASK(x, 2, 30)
+#define DBG_DATAO_2			0x00000374
+#define  V_VOP_DATA_O_2(x)			VAL_MASK(x, 30, 0)
+#define  V_SW_DATAO_SEL_2(x)			VAL_MASK(x, 2, 30)
+#define WIN0_CSC_COE			0x000003a0
+#define WIN1_CSC_COE			0x000003c0
+#define WIN2_CSC_COE			0x000003e0
+#define WIN3_CSC_COE			0x00000400
+#define HWC_CSC_COE			0x00000420
+#define BCSH_R2Y_CSC_COE		0x00000440
+#define BCSH_Y2R_CSC_COE		0x00000460
+#define POST_YUV2YUV_Y2R_COE		0x00000480
+#define POST_YUV2YUV_3x3_COE		0x000004a0
+#define POST_YUV2YUV_R2Y_COE		0x000004c0
+#define WIN0_YUV2YUV_Y2R		0x000004e0
+#define WIN0_YUV2YUV_R2R		0x00000500
+#define WIN0_YUV2YUV_R2Y		0x00000520
+#define WIN1_YUV2YUV_Y2R		0x00000540
+#define WIN1_YUV2YUV_R2R		0x00000560
+#define WIN1_YUV2YUV_R2Y		0x00000580
+#define WIN2_YUV2YUV_Y2R		0x000005a0
+#define WIN2_YUV2YUV_R2R		0x000005c0
+#define WIN2_YUV2YUV_R2Y		0x000005e0
+#define WIN3_YUV2YUV_Y2R		0x00000600
+#define WIN3_YUV2YUV_R2R		0x00000620
+#define WIN3_YUV2YUV_R2Y		0x00000640
+#define WIN2_LUT_ADDR			0x00001000
+#define  V_WIN2_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
+#define WIN3_LUT_ADDR			0x00001400
+#define  V_WIN3_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
+#define HWC_LUT_ADDR			0x00001800
+#define  V_HWC_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
+#define CABC_GAMMA_LUT_ADDR		0x00001c00
+#define  V_GAMMA_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
+#define GAMMA_LUT_ADDR			0x00002000
+#define  V_GAMMA_LUT_ADDR(x)			VAL_MASK(x, 32, 0)
+#define TVE				0x00003e00
+
+#define  INTR_FS			(1 << 0)
+#define  INTR_FS_NEW			(1 << 1)
+#define  INTR_ADDR_SAME			(1 << 2)
+#define  INTR_LINE_FLAG0		(1 << 3)
+#define  INTR_LINE_FLAG1		(1 << 4)
+#define  INTR_BUS_ERROR			(1 << 5)
+#define  INTR_WIN0_EMPTY		(1 << 6)
+#define  INTR_WIN1_EMPTY		(1 << 7)
+#define  INTR_WIN2_EMPTY		(1 << 8)
+#define  INTR_WIN3_EMPTY		(1 << 9)
+#define  INTR_HWC_EMPTY			(1 << 10)
+#define  INTR_POST_BUF_EMPTY		(1 << 11)
+/* rk322x */
+#define  INTR_PWM_GEN			(1 << 12)
+/* rk3399 */
+#define  INTR_FS_FIELD			(1 << 12)
+#define  INTR_DSP_HOLD_VALID		(1 << 13)
+#define  INTR_MMU			(1 << 14)
+#define  INTR_DMA_FINISH		(1 << 15)
+
+#define INTR_MASK (INTR_FS | INTR_FS_NEW | INTR_ADDR_SAME | INTR_LINE_FLAG0 | \
+			INTR_LINE_FLAG1 | INTR_BUS_ERROR | INTR_WIN0_EMPTY | \
+			INTR_WIN1_EMPTY | INTR_WIN2_EMPTY | INTR_WIN3_EMPTY | \
+			INTR_HWC_EMPTY | INTR_POST_BUF_EMPTY | INTR_PWM_GEN | \
+			INTR_DSP_HOLD_VALID | INTR_MMU | INTR_DMA_FINISH)
+
+#define  INTR1_FBCD0			(1 << 0)
+#define  INTR1_FBCD1			(1 << 1)
+#define  INTR1_FBCD2			(1 << 2)
+#define  INTR1_FBCD3			(1 << 3)
+#define  INTR1_AFBCD0_HREG_DEC_RESP	(1 << 4)
+#define  INTR1_AFBCD0_HREG_AXI_RRESP	(1 << 5)
+#define  INTR1_AFBCD1_HREG_DEC_RESP	(1 << 6)
+#define  INTR1_AFBCD1_HREG_AXI_RRESP	(1 << 7)
+#define  INTR1_AFBCD2_HREG_DEC_RESP	(1 << 8)
+#define  INTR1_AFBCD2_HREG_AXI_RRESP	(1 << 9)
+#define  INTR1_AFBCD3_HREG_DEC_RESP	(1 << 10)
+#define  INTR1_AFBCD3_HREG_AXI_RRESP	(1 << 11)
+#define  INTR1_WB_YRGB_FIFO_FULL	(1 << 12)
+#define  INTR1_WB_UV_FIFO_FULL		(1 << 13)
+#define  INTR1_WB_FINISH		(1 << 14)
+
+#define OUT_CCIR656_MODE_0              5
+#define OUT_CCIR656_MODE_1              6
+#define OUT_CCIR656_MODE_2              7
+
+#define AFBDC_RGB_COLOR_TRANSFORM	0
+#define AFBDC_YUV_COLOR_TRANSFORM	1
+
+enum cabc_stage_mode {
+	LAST_FRAME_PWM_VAL	= 0x0,
+	CUR_FRAME_PWM_VAL	= 0x1,
+	STAGE_BY_STAGE		= 0x2
+};
+
+enum {
+	VOP_RK322X,
+	VOP_RK3399,
+};
+
+enum {
+	VOP_WIN0,
+	VOP_WIN1,
+	VOP_WIN2,
+	VOP_WIN3,
+	VOP_HWC,
+	VOP_WIN_MAX,
+};
+
+struct vop_data {
+	int chip_type;
+	struct rk_lcdc_win *win;
+	int n_wins;
+};
+
+struct vop_device {
+	int id;
+	const struct vop_data *data;
+	struct rk_lcdc_driver driver;
+	struct device *dev;
+	struct rk_screen *screen;
+	struct regmap *grf_base;
+
+	void __iomem *regs;
+	void *regsbak;
+	u32 reg_phy_base;
+	u32 len;
+
+	int __iomem *dsp_lut_addr_base;
+	int __iomem *cabc_lut_addr_base;
+	/* one time only one process allowed to config the register */
+	spinlock_t reg_lock;
+
+	int prop;		/*used for primary or extended display device*/
+	bool pre_init;
+	bool pwr18;		/*if lcdc use 1.8v power supply*/
+	/*if aclk or hclk is closed ,acess to register is not allowed*/
+	bool clk_on;
+	/*active layer counter,when  atv_layer_cnt = 0,disable lcdc*/
+	u8 atv_layer_cnt;
+	/* point write back status */
+	bool wb_on;
+
+	unsigned int		irq;
+
+	struct clk		*hclk;		/*lcdc AHP clk*/
+	struct clk		*dclk;		/*lcdc dclk*/
+	struct clk		*aclk;		/*lcdc share memory frequency*/
+	struct clk		*hclk_noc;
+	struct clk		*aclk_noc;
+	u32 pixclock;
+
+	u32 standby;				/*1:standby,0:wrok*/
+	u32 iommu_status;
+	struct backlight_device *backlight;
+	struct clk		*pll_sclk;
+
+	/* lock vop irq reg */
+	spinlock_t irq_lock;
+	struct devfreq *devfreq;
+	struct devfreq_event_dev *devfreq_event_dev;
+	struct notifier_block dmc_nb;
+	int dmc_in_process;
+	int vop_switch_status;
+	wait_queue_head_t wait_dmc_queue;
+	wait_queue_head_t wait_vop_switch_queue;
+};
+
+static inline void vop_writel(struct vop_device *vop_dev, u32 offset, u32 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	*_pv = v;
+	writel_relaxed(v, vop_dev->regs + offset);
+}
+
+static inline u32 vop_readl(struct vop_device *vop_dev, u32 offset)
+{
+	u32 v;
+
+	v = readl_relaxed(vop_dev->regs + offset);
+	return v;
+}
+
+static inline u32 vop_readl_backup(struct vop_device *vop_dev, u32 offset)
+{
+	u32 v;
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	v = readl_relaxed(vop_dev->regs + offset);
+	*_pv = v;
+	return v;
+}
+
+static inline u32 vop_read_bit(struct vop_device *vop_dev, u32 offset, u64 v)
+{
+	u32 _v = readl_relaxed(vop_dev->regs + offset);
+
+	_v &= v >> 32;
+	v = (_v ? 1 : 0);
+	return v;
+}
+
+static inline void vop_set_bit(struct vop_device *vop_dev, u32 offset, u64 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) |= v >> 32;
+	writel_relaxed(*_pv, vop_dev->regs + offset);
+}
+
+static inline void vop_clr_bit(struct vop_device *vop_dev, u32 offset, u64 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) &= (~(v >> 32));
+	writel_relaxed(*_pv, vop_dev->regs + offset);
+}
+
+static inline void vop_msk_reg(struct vop_device *vop_dev, u32 offset, u64 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) &= (~(v >> 32));
+	(*_pv) |= (u32)v;
+	writel_relaxed(*_pv, vop_dev->regs + offset);
+}
+
+static inline void vop_msk_reg_nobak(struct vop_device *vop_dev,
+				     u32 offset, u64 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	writel_relaxed((*_pv & (~(v >> 32))) | (u32)v, vop_dev->regs + offset);
+}
+
+static inline void vop_mask_writel(struct vop_device *vop_dev, u32 offset,
+				   u32 mask, u32 v)
+{
+	v = mask << 16 | v;
+	writel_relaxed(v , vop_dev->regs + offset);
+}
+
+static inline void vop_cfg_done(struct vop_device *vop_dev)
+{
+	writel_relaxed(0x001f001f, vop_dev->regs + REG_CFG_DONE);
+	dsb(sy);
+}
+
+static inline int vop_grf_writel(struct regmap *base, u32 offset, u32 val)
+{
+	regmap_write(base, offset, val);
+	dsb(sy);
+
+	return 0;
+}
+
+static inline int vop_cru_writel(struct regmap *base, u32 offset, u32 val)
+{
+	regmap_write(base, offset, val);
+	dsb(sy);
+
+	return 0;
+}
+
+static inline int vop_cru_readl(struct regmap *base, u32 offset)
+{
+	u32 v;
+
+	regmap_read(base, offset, &v);
+
+	return v;
+}
+
+enum lb_mode {
+	LB_YUV_3840X5 = 0x0,
+	LB_YUV_2560X8 = 0x1,
+	LB_RGB_3840X2 = 0x2,
+	LB_RGB_2560X4 = 0x3,
+	LB_RGB_1920X5 = 0x4,
+	LB_RGB_1280X8 = 0x5
+};
+
+enum sacle_up_mode {
+	SCALE_UP_BIL = 0x0,
+	SCALE_UP_BIC = 0x1
+};
+
+enum scale_down_mode {
+	SCALE_DOWN_BIL = 0x0,
+	SCALE_DOWN_AVG = 0x1
+};
+
+/*ALPHA BLENDING MODE*/
+enum alpha_mode {               /*  Fs       Fd */
+	AB_USER_DEFINE     = 0x0,
+	AB_CLEAR	   = 0x1,/*  0          0*/
+	AB_SRC		   = 0x2,/*  1          0*/
+	AB_DST		   = 0x3,/*  0          1  */
+	AB_SRC_OVER	   = 0x4,/*  1		    1-As''*/
+	AB_DST_OVER	   = 0x5,/*  1-Ad''   1*/
+	AB_SRC_IN	   = 0x6,
+	AB_DST_IN	   = 0x7,
+	AB_SRC_OUT	   = 0x8,
+	AB_DST_OUT	   = 0x9,
+	AB_SRC_ATOP        = 0xa,
+	AB_DST_ATOP	   = 0xb,
+	XOR                = 0xc,
+	AB_SRC_OVER_GLOBAL = 0xd
+}; /*alpha_blending_mode*/
+
+enum src_alpha_mode {
+	AA_STRAIGHT	   = 0x0,
+	AA_INVERSE         = 0x1
+};/*src_alpha_mode*/
+
+enum global_alpha_mode {
+	AA_GLOBAL	  = 0x0,
+	AA_PER_PIX        = 0x1,
+	AA_PER_PIX_GLOBAL = 0x2
+};/*src_global_alpha_mode*/
+
+enum src_alpha_sel {
+	AA_SAT		= 0x0,
+	AA_NO_SAT	= 0x1
+};/*src_alpha_sel*/
+
+enum src_color_mode {
+	AA_SRC_PRE_MUL	       = 0x0,
+	AA_SRC_NO_PRE_MUL      = 0x1
+};/*src_color_mode*/
+
+enum factor_mode {
+	AA_ZERO			= 0x0,
+	AA_ONE			= 0x1,
+	AA_SRC			= 0x2,
+	AA_SRC_INVERSE          = 0x3,
+	AA_SRC_GLOBAL           = 0x4
+};/*src_factor_mode  &&  dst_factor_mode*/
+
+enum _vop_r2y_csc_mode {
+	VOP_R2Y_CSC_BT601 = 0,
+	VOP_R2Y_CSC_BT709,
+	VOP_R2Y_CSC_BT601_F,
+	VOP_R2Y_CSC_BT2020
+};
+
+enum _vop_y2r_csc_mode {
+	VOP_Y2R_CSC_MPEG = 0,
+	VOP_Y2R_CSC_JPEG,
+	VOP_Y2R_CSC_HD,
+	VOP_Y2R_CSC_BYPASS
+};
+enum _vop_format {
+	VOP_FORMAT_ARGB888 = 0,
+	VOP_FORMAT_RGB888,
+	VOP_FORMAT_RGB565,
+	VOP_FORMAT_YCBCR420 = 4,
+	VOP_FORMAT_YCBCR422,
+	VOP_FORMAT_YCBCR444
+};
+
+#define IS_YUV(x) ((x) >= VOP_FORMAT_YCBCR420)
+
+enum _vop_overlay_mode {
+	VOP_RGB_DOMAIN,
+	VOP_YUV_DOMAIN
+};
+
+struct alpha_config {
+	enum src_alpha_mode src_alpha_mode;       /*win0_src_alpha_m0*/
+	u32 src_global_alpha_val; /*win0_src_global_alpha*/
+	enum global_alpha_mode src_global_alpha_mode;/*win0_src_blend_m0*/
+	enum src_alpha_sel src_alpha_cal_m0;	 /*win0_src_alpha_cal_m0*/
+	enum src_color_mode src_color_mode;	 /*win0_src_color_m0*/
+	enum factor_mode src_factor_mode;	 /*win0_src_factor_m0*/
+	enum factor_mode dst_factor_mode;      /*win0_dst_factor_m0*/
+};
+
+struct lcdc_cabc_mode {
+	u32 pixel_num;			/* pixel precent number */
+	u16 stage_up;			/* up stride */
+	u16 stage_down;		/* down stride */
+	u16 global_su;
+};
+
+#define CUBIC_PRECISE  0
+#define CUBIC_SPLINE   1
+#define CUBIC_CATROM   2
+#define CUBIC_MITCHELL 3
+
+#define AFBDC_FMT_RGB565	0x0
+#define AFBDC_FMT_U8U8U8U8	0x5 /*ARGB888*/
+#define AFBDC_FMT_U8U8U8	0x4 /*RGBP888*/
+
+#define CUBIC_MODE_SELETION      CUBIC_PRECISE
+
+/*************************************************************/
+#define SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT   12   /* 4.12*/
+#define SCALE_FACTOR_BILI_DN_FIXPOINT(x)      \
+	((INT32)((x) * (1 << SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT   16   /* 0.16*/
+
+#define SCALE_FACTOR_AVRG_FIXPOINT_SHIFT   16   /*0.16*/
+#define SCALE_FACTOR_AVRG_FIXPOINT(x)      \
+	((INT32)((x) * (1 << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_BIC_FIXPOINT_SHIFT    16   /* 0.16*/
+#define SCALE_FACTOR_BIC_FIXPOINT(x)       \
+	((INT32)((x) * (1 << SCALE_FACTOR_BIC_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT    12  /*NONE SCALE,vsd_bil*/
+#define SCALE_FACTOR_VSDBIL_FIXPOINT_SHIFT     12  /*VER SCALE DOWN BIL*/
+
+/*********************************************************/
+
+/*#define GET_SCALE_FACTOR_BILI(src, dst)  \
+	((((src) - 1) << SCALE_FACTOR_BILI_FIXPOINT_SHIFT) / ((dst) - 1))*/
+/*#define GET_SCALE_FACTOR_BIC(src, dst)   \
+	((((src) - 1) << SCALE_FACTOR_BIC_FIXPOINT_SHIFT) / ((dst) - 1))*/
+/*modified by hpz*/
+#define GET_SCALE_FACTOR_BILI_DN(src, dst)  \
+	((((src) * 2 - 3) << (SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT - 1)) \
+	/ ((dst) - 1))
+#define GET_SCALE_FACTOR_BILI_UP(src, dst)  \
+	((((src) * 2 - 3) << (SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT - 1)) \
+	/ ((dst) - 1))
+#define GET_SCALE_FACTOR_BIC(src, dst)      \
+	((((src) * 2 - 3) << (SCALE_FACTOR_BIC_FIXPOINT_SHIFT - 1)) \
+	/ ((dst) - 1))
+
+/*********************************************************/
+/*NOTE: hardware in order to save resource , srch first to get interlace line
+(srch+vscalednmult-1)/vscalednmult; and do scale*/
+#define GET_SCALE_DN_ACT_HEIGHT(srch, vscalednmult) \
+	(((srch) + (vscalednmult) - 1) / (vscalednmult))
+
+/*#define VSKIP_MORE_PRECISE*/
+
+#ifdef VSKIP_MORE_PRECISE
+#define MIN_SCALE_FACTOR_AFTER_VSKIP        1.5f
+#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
+	(GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
+	(vscalednmult)), (dsth)))
+#else
+#define MIN_SCALE_FACTOR_AFTER_VSKIP        1
+#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
+	((GET_SCALE_DN_ACT_HEIGHT((srch) , (vscalednmult)) == (dsth)) \
+	? (GET_SCALE_FACTOR_BILI_DN((srch) , (dsth)) / (vscalednmult)) \
+	: (GET_SCALE_DN_ACT_HEIGHT((srch) , (vscalednmult)) == ((dsth) * 2)) \
+	?  GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT(((srch) - 1),\
+	(vscalednmult)) , (dsth)) : \
+	GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
+	(vscalednmult)) , (dsth)))
+
+#endif
+/*****************************************************************/
+
+/*scalefactor must >= dst/src, or pixels at end of line may be unused*/
+/*scalefactor must < dst/(src-1), or dst buffer may overflow*/
+/*avrg old code: ((((dst) << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT))\
+	/((src) - 1)) hxx_chgsrc*/
+/*modified by hpz:*/
+#define GET_SCALE_FACTOR_AVRG(src, dst)  ((((dst) << \
+	(SCALE_FACTOR_AVRG_FIXPOINT_SHIFT + 1))) / (2 * (src) - 1))
+
+/*************************************************************************/
+/*Scale Coordinate Accumulate, x.16*/
+#define SCALE_COOR_ACC_FIXPOINT_SHIFT     16
+#define SCALE_COOR_ACC_FIXPOINT_ONE (1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)
+#define SCALE_COOR_ACC_FIXPOINT(x) \
+	((INT32)((x)*(1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)))
+#define SCALE_COOR_ACC_FIXPOINT_REVERT(x) \
+	((((x) >> (SCALE_COOR_ACC_FIXPOINT_SHIFT - 1)) + 1) >> 1)
+
+#define SCALE_GET_COOR_ACC_FIXPOINT(scalefactor, factorfixpointshift)  \
+	((scalefactor) << \
+	(SCALE_COOR_ACC_FIXPOINT_SHIFT - (factorfixpointshift)))
+
+/************************************************************************/
+/*CoarsePart of Scale Coordinate Accumulate, used for pixel mult-add factor, 0.8*/
+#define SCALE_FILTER_FACTOR_FIXPOINT_SHIFT     8
+#define SCALE_FILTER_FACTOR_FIXPOINT_ONE       \
+	(1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)
+#define SCALE_FILTER_FACTOR_FIXPOINT(x)        \
+	((INT32)((x) * (1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)))
+#define SCALE_FILTER_FACTOR_FIXPOINT_REVERT(x) \
+	((((x) >> (SCALE_FILTER_FACTOR_FIXPOINT_SHIFT-1)) + 1) >> 1)
+
+#define SCALE_GET_FILTER_FACTOR_FIXPOINT(cooraccumulate, \
+	cooraccfixpointshift) \
+	(((cooraccumulate) >> \
+	((cooraccfixpointshift) - SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)) & \
+	(SCALE_FILTER_FACTOR_FIXPOINT_ONE - 1))
+
+#define SCALE_OFFSET_FIXPOINT_SHIFT            8
+#define SCALE_OFFSET_FIXPOINT(x)              \
+	((INT32)((x) * (1 << SCALE_OFFSET_FIXPOINT_SHIFT)))
+
+static inline u32 vop_get_hard_ware_vskiplines(u32 srch, u32 dsth)
+{
+	u32 vscalednmult;
+
+	if (srch >= (u32) (4 * dsth * MIN_SCALE_FACTOR_AFTER_VSKIP))
+		vscalednmult = 4;
+	else if (srch >= (u32) (2 * dsth * MIN_SCALE_FACTOR_AFTER_VSKIP))
+		vscalednmult = 2;
+	else
+		vscalednmult = 1;
+
+	return vscalednmult;
+}
+
+#endif
diff -Nupr a/drivers/video/rockchip/lcdc/rk3288_lcdc.c b/drivers/video/rockchip/lcdc/rk3288_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk3288_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3288_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,4238 @@
+/*
+ * drivers/video/rockchip/lcdc/rk3288_lcdc.c
+ *
+ * Copyright (C) 2014 ROCKCHIP, Inc.
+ *Author:hjc<hjc@rock-chips.com>
+ *This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/rockchip-iovmm.h>
+#include <asm/div64.h>
+#include <asm/uaccess.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/iomap.h>
+#include <linux/rockchip/grf.h>
+#include <linux/rockchip/common.h>
+#include <dt-bindings/clock/rk_system_status.h>
+
+#include "rk3288_lcdc.h"
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+
+static int dbg_thresd;
+module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
+
+#define DBG(level, x...) do {			\
+	if (unlikely(dbg_thresd >= level))	\
+		printk(KERN_INFO x); } while (0)
+
+static int rk3288_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv,
+				     bool enable);
+
+struct fb_info *rk_get_fb(int fb_id);
+/*#define WAIT_FOR_SYNC 1*/
+
+static int rk3288_lcdc_get_id(u32 phy_base)
+{
+	if (cpu_is_rk3288()) {
+		if (phy_base == 0xff930000)/*vop big*/
+			return 0;
+		else if (phy_base == 0xff940000)/*vop lit*/	
+			return 1;
+		else
+			return -EINVAL;
+	} else {
+		pr_err("un supported platform \n");
+		return -EINVAL;
+	}
+}
+
+static int rk3288_lcdc_set_lut(struct rk_lcdc_driver *dev_drv)
+{
+	int i,j;
+	int __iomem *c;
+	u32 v,r,g,b;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device,driver);
+	if (dev_drv->cur_screen->dsp_lut)
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
+			     v_DSP_LUT_EN(0));
+	if ((dev_drv->cur_screen->cabc_lut) &&
+	    (dev_drv->version == VOP_FULL_RK3288_V1_1))
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL1, m_CABC_LUT_EN,
+			     v_CABC_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	mdelay(25);
+	if (dev_drv->cur_screen->dsp_lut) {
+		for (i = 0; i < 256; i++) {
+			v = dev_drv->cur_screen->dsp_lut[i];
+			c = lcdc_dev->dsp_lut_addr_base + (i << 2);
+			b = (v & 0xff) << 2;
+			g = (v & 0xff00) << 4;
+			r = (v & 0xff0000) << 6;
+			v = r + g + b;
+			for (j = 0; j < 4; j++) {
+				writel_relaxed(v, c);
+				v += (1 + (1 << 10) + (1 << 20));
+				c++;
+			}
+		}
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
+			     v_DSP_LUT_EN(1));
+	}
+	if ((dev_drv->cur_screen->cabc_lut) &&
+	    (dev_drv->version == VOP_FULL_RK3288_V1_1)) {
+		for (i = 0; i < 128; i++) {
+			v = dev_drv->cur_screen->cabc_lut[i];
+			lcdc_writel(lcdc_dev, i * 4 + CABC_LUT_ADDR, v);
+		}
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL1, m_CABC_LUT_EN,
+			     v_CABC_LUT_EN(1));
+	}
+
+	return 0;
+
+}
+
+static int rk3288_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
+{
+#ifdef CONFIG_RK_FPGA
+	lcdc_dev->clk_on = 1;
+	return 0;
+#endif	
+	if (!lcdc_dev->clk_on) {
+		clk_prepare_enable(lcdc_dev->hclk);
+		clk_prepare_enable(lcdc_dev->dclk);
+		clk_prepare_enable(lcdc_dev->aclk);
+		clk_prepare_enable(lcdc_dev->pd);
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 1;
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int rk3288_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
+{
+#ifdef CONFIG_RK_FPGA
+	lcdc_dev->clk_on = 0;
+	return 0;
+#endif	
+	if (lcdc_dev->clk_on) {
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 0;
+		spin_unlock(&lcdc_dev->reg_lock);
+		mdelay(25);
+		clk_disable_unprepare(lcdc_dev->dclk);
+		clk_disable_unprepare(lcdc_dev->hclk);
+		clk_disable_unprepare(lcdc_dev->aclk);
+		clk_disable_unprepare(lcdc_dev->pd);
+	}
+
+	return 0;
+}
+
+static int rk3288_lcdc_disable_irq(struct lcdc_device *lcdc_dev)
+{	
+	u32 mask, val;
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		mask = m_DSP_HOLD_VALID_INTR_EN | m_FS_INTR_EN |
+			m_LINE_FLAG_INTR_EN | m_BUS_ERROR_INTR_EN;
+		val = v_DSP_HOLD_VALID_INTR_EN(0) | v_FS_INTR_EN(0) |
+			v_LINE_FLAG_INTR_EN(0) | v_BUS_ERROR_INTR_EN(0);
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, mask, val);
+
+		mask = m_DSP_HOLD_VALID_INTR_CLR | m_FS_INTR_CLR |
+			m_LINE_FLAG_INTR_CLR | m_LINE_FLAG_INTR_CLR;
+		val = v_DSP_HOLD_VALID_INTR_CLR(0) | v_FS_INTR_CLR(0) |
+			v_LINE_FLAG_INTR_CLR(0) | v_BUS_ERROR_INTR_CLR(0);
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, mask, val);
+
+		mask = m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN |
+			m_WIN2_EMPTY_INTR_EN | m_WIN3_EMPTY_INTR_EN |
+			m_HWC_EMPTY_INTR_EN | m_POST_BUF_EMPTY_INTR_EN |
+			m_POST_BUF_EMPTY_INTR_EN;
+		val = v_WIN0_EMPTY_INTR_EN(0) | v_WIN1_EMPTY_INTR_EN(0) |
+			v_WIN2_EMPTY_INTR_EN(0) | v_WIN3_EMPTY_INTR_EN(0) |
+			v_HWC_EMPTY_INTR_EN(0) | v_POST_BUF_EMPTY_INTR_EN(0) |
+			v_PWM_GEN_INTR_EN(0);
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, mask, val);
+
+		mask = m_WIN0_EMPTY_INTR_CLR | m_WIN1_EMPTY_INTR_CLR |
+			m_WIN2_EMPTY_INTR_CLR | m_WIN3_EMPTY_INTR_CLR |
+			m_HWC_EMPTY_INTR_CLR | m_POST_BUF_EMPTY_INTR_CLR |
+			m_POST_BUF_EMPTY_INTR_CLR;
+		val = v_WIN0_EMPTY_INTR_CLR(0) | v_WIN1_EMPTY_INTR_CLR(0) |
+			v_WIN2_EMPTY_INTR_CLR(0) | v_WIN3_EMPTY_INTR_CLR(0) |
+			v_HWC_EMPTY_INTR_CLR(0) | v_POST_BUF_EMPTY_INTR_CLR(0) |
+			v_PWM_GEN_INTR_CLR(0);
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, mask, val);		
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	mdelay(1);
+	return 0;
+}
+static int rk3288_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						struct lcdc_device,
+						driver);
+	int *cbase = (int *)lcdc_dev->regs;
+	int *regsbak = (int *)lcdc_dev->regsbak;
+	int i, j;
+
+	printk("back up reg:\n");
+	for (i = 0; i <= (0x200 >> 4); i++) {
+		printk("0x%04x: ",i*16);
+		for (j = 0; j < 4; j++)
+			printk("%08x  ", *(regsbak + i * 4 + j));
+		printk("\n");
+	}
+
+	printk("lcdc reg:\n");
+	for (i = 0; i <= (0x200 >> 4); i++) {
+		printk("0x%04x: ",i*16);
+		for (j = 0; j < 4; j++)
+			printk("%08x  ", readl_relaxed(cbase + i * 4 + j));
+		printk("\n");
+	}
+	return 0;
+
+}
+
+#define WIN_EN(id)		\
+static int win##id##_enable(struct lcdc_device *lcdc_dev, int en)	\
+{ \
+	u32 msk, val;							\
+	spin_lock(&lcdc_dev->reg_lock);					\
+	msk =  m_WIN##id##_EN;						\
+	val  =  v_WIN##id##_EN(en);					\
+	lcdc_msk_reg(lcdc_dev, WIN##id##_CTRL0, msk, val);		\
+	lcdc_cfg_done(lcdc_dev);					\
+	/*val = lcdc_read_bit(lcdc_dev, WIN##id##_CTRL0, msk);		\
+	while (val !=  (!!en))	{					\
+		val = lcdc_read_bit(lcdc_dev, WIN##id##_CTRL0, msk);	\
+	}*/								\
+	spin_unlock(&lcdc_dev->reg_lock);				\
+	return 0;							\
+}
+
+WIN_EN(0);
+WIN_EN(1);
+WIN_EN(2);
+WIN_EN(3);
+/*enable/disable win directly*/
+static int rk3288_lcdc_win_direct_en
+		(struct rk_lcdc_driver *drv, int win_id , int en)
+{
+	struct lcdc_device *lcdc_dev = container_of(drv,
+					struct lcdc_device, driver);
+	if (win_id == 0)
+		win0_enable(lcdc_dev, en);
+	else if (win_id == 1)
+		win1_enable(lcdc_dev, en);
+	else if (win_id == 2)
+		win2_enable(lcdc_dev, en);
+	else if (win_id == 3)
+		win3_enable(lcdc_dev, en);
+	else
+		dev_err(lcdc_dev->dev, "invalid win number:%d\n", win_id);
+	return 0;
+		
+}
+
+#define SET_WIN_ADDR(id) \
+static int set_win##id##_addr(struct lcdc_device *lcdc_dev, u32 addr) \
+{							\
+	u32 msk, val;					\
+	spin_lock(&lcdc_dev->reg_lock);			\
+	lcdc_writel(lcdc_dev,WIN##id##_YRGB_MST,addr);	\
+	msk =  m_WIN##id##_EN;				\
+	val  =  v_WIN0_EN(1);				\
+	lcdc_msk_reg(lcdc_dev, WIN##id##_CTRL0, msk,val);	\
+	lcdc_cfg_done(lcdc_dev);			\
+	spin_unlock(&lcdc_dev->reg_lock);		\
+	return 0;					\
+}
+
+SET_WIN_ADDR(0);
+SET_WIN_ADDR(1);
+int rk3288_lcdc_direct_set_win_addr
+		(struct rk_lcdc_driver *dev_drv, int win_id, u32 addr)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+				struct lcdc_device, driver);
+	if (win_id == 0)
+		set_win0_addr(lcdc_dev, addr);
+	else
+		set_win1_addr(lcdc_dev, addr);
+	
+	return 0;
+}
+
+static void lcdc_read_reg_defalut_cfg(struct lcdc_device *lcdc_dev)
+{
+	int reg = 0;
+	u32 val = 0;
+	struct rk_screen *screen = lcdc_dev->driver.cur_screen;
+	u32 h_pw_bp = screen->mode.hsync_len + screen->mode.left_margin;
+	u32 v_pw_bp = screen->mode.vsync_len + screen->mode.upper_margin;
+	u32 st_x, st_y;
+	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	memcpy(lcdc_dev->regsbak, lcdc_dev->regs, FRC_LOWER11_1);
+	for (reg = 0; reg < FRC_LOWER11_1; reg += 4) {
+		val = lcdc_readl(lcdc_dev, reg);
+		switch (reg) {
+		case VERSION_INFO:
+			lcdc_dev->driver.version = val;
+			break;
+			case WIN0_ACT_INFO:
+				win0->area[0].xact =
+					(val & m_WIN0_ACT_WIDTH) + 1;
+				win0->area[0].yact =
+					((val & m_WIN0_ACT_HEIGHT) >> 16) + 1;
+				break;
+			case WIN0_DSP_INFO:
+				win0->area[0].xsize =
+					(val & m_WIN0_DSP_WIDTH) + 1;
+				win0->area[0].ysize =
+					((val & m_WIN0_DSP_HEIGHT) >> 16) + 1;
+				break;
+			case WIN0_DSP_ST:
+				st_x = val & m_WIN0_DSP_XST;
+				st_y = (val & m_WIN0_DSP_YST) >> 16;
+				win0->area[0].xpos = st_x - h_pw_bp;
+				win0->area[0].ypos = st_y - v_pw_bp;
+				break;
+			case WIN0_CTRL0:
+				win0->state = val & m_WIN0_EN;
+				win0->area[0].fmt_cfg =
+					(val & m_WIN0_DATA_FMT) >> 1;
+				win0->fmt_10 = (val & m_WIN0_FMT_10) >> 4;
+				win0->area[0].format = win0->area[0].fmt_cfg;
+				break;
+			case WIN0_VIR:
+				win0->area[0].y_vir_stride =
+					val & m_WIN0_VIR_STRIDE;
+				win0->area[0].uv_vir_stride =
+					(val & m_WIN0_VIR_STRIDE_UV) >> 16;
+				if (win0->area[0].format == ARGB888)
+					win0->area[0].xvir =
+						win0->area[0].y_vir_stride;
+				else if (win0->area[0].format == RGB888)
+					win0->area[0].xvir =
+						win0->area[0].y_vir_stride * 4 / 3;
+				else if (win0->area[0].format == RGB565)
+					win0->area[0].xvir =
+						2 * win0->area[0].y_vir_stride;
+				else /* YUV */
+					win0->area[0].xvir =
+						4 * win0->area[0].y_vir_stride;
+				break;
+			case WIN0_YRGB_MST:
+				win0->area[0].smem_start = val;
+				break;
+			case WIN0_CBR_MST:
+				win0->area[0].cbr_start = val;
+				break;
+			case DSP_VACT_ST_END:
+				if (support_uboot_display()) {
+					screen->mode.yres =
+					(val & 0x1fff) - ((val >> 16) & 0x1fff);
+					win0->area[0].ypos =
+					st_y - ((val >> 16) & 0x1fff);
+				}
+				break;
+			case DSP_HACT_ST_END:
+				if (support_uboot_display()) {
+					screen->mode.xres =
+					(val & 0x1fff) - ((val >> 16) & 0x1fff);
+					win0->area[0].xpos =
+					st_x - ((val >> 16) & 0x1fff);
+				}
+				break;
+			default:
+				break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+}
+
+/********do basic init*********/
+static int rk3288_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
+{
+	int v;
+	u32 mask,val;
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+							   struct
+							   lcdc_device,
+						   driver);
+	if (lcdc_dev->pre_init)
+		return 0;
+
+	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
+	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
+	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
+	lcdc_dev->pd   = devm_clk_get(lcdc_dev->dev, "pd_lcdc");
+	
+	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||
+	    (IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk))) {
+		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
+			lcdc_dev->id);
+	}
+	if (!support_uboot_display())
+		rk_disp_pwr_enable(dev_drv);
+	rk3288_lcdc_clk_enable(lcdc_dev);
+
+	/*backup reg config at uboot*/
+	lcdc_read_reg_defalut_cfg(lcdc_dev);
+	v = 0;
+#ifndef CONFIG_RK_FPGA
+	if (lcdc_dev->pwr18 == true) {
+		v = 0x00010001;	/*bit14: 1,1.8v;0,3.3v*/
+		writel_relaxed(v, RK_GRF_VIRT + RK3288_GRF_IO_VSEL);
+	} else {
+		v = 0x00010000;
+		writel_relaxed(v, RK_GRF_VIRT + RK3288_GRF_IO_VSEL);
+	}
+#endif	
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE0_0,0x15110903);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE0_1,0x00030911);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE1_0,0x1a150b04);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE1_1,0x00040b15);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE2_0,0x15110903);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE2_1,0x00030911);
+
+	lcdc_writel(lcdc_dev,FRC_LOWER01_0,0x12844821);
+	lcdc_writel(lcdc_dev,FRC_LOWER01_1,0x21488412);
+	lcdc_writel(lcdc_dev,FRC_LOWER10_0,0xa55a9696);
+	lcdc_writel(lcdc_dev,FRC_LOWER10_1,0x5aa56969);
+	lcdc_writel(lcdc_dev,FRC_LOWER11_0,0xdeb77deb);
+	lcdc_writel(lcdc_dev,FRC_LOWER11_1,0xed7bb7de);
+
+	mask =  m_AUTO_GATING_EN;
+	val  =  v_AUTO_GATING_EN(0);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask,val);
+	lcdc_cfg_done(lcdc_dev);
+	/*disable win0 to workaround iommu pagefault */
+	/*if (dev_drv->iommu_enabled) */
+	/*      win0_enable(lcdc_dev, 0); */
+	lcdc_dev->pre_init = true;
+
+
+	return 0;
+}
+
+static void rk3288_lcdc_deint(struct lcdc_device *lcdc_dev)
+{
+
+	
+	rk3288_lcdc_disable_irq(lcdc_dev);
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_dev->clk_on = 0;
+		lcdc_set_bit(lcdc_dev, SYS_CTRL, m_STANDBY_EN);
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	mdelay(1);
+}
+static int rk3288_lcdc_post_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u32 mask, val;
+	u16 h_total,v_total;
+	u16 post_hsd_en,post_vsd_en;
+	u16 post_dsp_hact_st,post_dsp_hact_end;	
+	u16 post_dsp_vact_st,post_dsp_vact_end;
+	u16 post_dsp_vact_st_f1,post_dsp_vact_end_f1;
+	u16 post_h_fac,post_v_fac;
+
+	screen->post_dsp_stx = x_res * (100 - dev_drv->overscan.left) / 200;
+	screen->post_dsp_sty = y_res * (100 - dev_drv->overscan.top) / 200;
+	screen->post_xsize = x_res *
+		(dev_drv->overscan.left + dev_drv->overscan.right) / 200;
+	screen->post_ysize = y_res *
+		(dev_drv->overscan.top + dev_drv->overscan.bottom) / 200;
+	h_total = screen->mode.hsync_len+screen->mode.left_margin +
+		  x_res + screen->mode.right_margin;
+	v_total = screen->mode.vsync_len+screen->mode.upper_margin +
+		  y_res + screen->mode.lower_margin;
+
+	if(screen->post_dsp_stx + screen->post_xsize > x_res){		
+		dev_warn(lcdc_dev->dev, "post:stx[%d] + xsize[%d] > x_res[%d]\n",
+			screen->post_dsp_stx,screen->post_xsize,x_res);
+		screen->post_dsp_stx = x_res - screen->post_xsize;
+	}
+	if(screen->x_mirror == 0){
+		post_dsp_hact_st=screen->post_dsp_stx + 
+			screen->mode.hsync_len+screen->mode.left_margin;
+		post_dsp_hact_end = post_dsp_hact_st + screen->post_xsize;
+	}else{
+		post_dsp_hact_end = h_total - screen->mode.right_margin -
+					screen->post_dsp_stx;
+		post_dsp_hact_st = post_dsp_hact_end - screen->post_xsize;
+	}	
+	if((screen->post_xsize < x_res)&&(screen->post_xsize != 0)){
+		post_hsd_en = 1;
+		post_h_fac = 
+			GET_SCALE_FACTOR_BILI_DN(x_res , screen->post_xsize); 
+	}else{
+		post_hsd_en = 0;
+		post_h_fac = 0x1000;
+	}
+
+
+	if(screen->post_dsp_sty + screen->post_ysize > y_res){
+		dev_warn(lcdc_dev->dev, "post:sty[%d] + ysize[%d] > y_res[%d]\n",
+			screen->post_dsp_sty,screen->post_ysize,y_res);
+		screen->post_dsp_sty = y_res - screen->post_ysize;	
+	}
+	
+	if(screen->y_mirror == 0){
+		post_dsp_vact_st = screen->post_dsp_sty + 
+			screen->mode.vsync_len+screen->mode.upper_margin;
+		post_dsp_vact_end = post_dsp_vact_st + screen->post_ysize;
+	}else{
+		post_dsp_vact_end = v_total - screen->mode.lower_margin -
+					- screen->post_dsp_sty;
+		post_dsp_vact_st = post_dsp_vact_end - screen->post_ysize;
+	}
+	if((screen->post_ysize < y_res)&&(screen->post_ysize != 0)){
+		post_vsd_en = 1;
+		post_v_fac = GET_SCALE_FACTOR_BILI_DN(y_res, screen->post_ysize);		
+	}else{
+		post_vsd_en = 0;
+		post_v_fac = 0x1000;
+	}
+
+	if(screen->interlace == 1){
+		post_dsp_vact_st_f1  = v_total + post_dsp_vact_st;
+		post_dsp_vact_end_f1 = post_dsp_vact_st_f1 + screen->post_ysize;
+	}else{
+		post_dsp_vact_st_f1  = 0;
+		post_dsp_vact_end_f1 = 0;
+	}
+	DBG(1,"post:xsize=%d,ysize=%d,xpos=%d,ypos=%d,"
+	      "hsd_en=%d,h_fac=%d,vsd_en=%d,v_fac=%d\n",
+		screen->post_xsize,screen->post_ysize,screen->xpos,screen->ypos,
+		post_hsd_en,post_h_fac,post_vsd_en,post_v_fac);
+	mask = m_DSP_HACT_END_POST | m_DSP_HACT_ST_POST;
+	val = v_DSP_HACT_END_POST(post_dsp_hact_end) | 
+	      v_DSP_HACT_ST_POST(post_dsp_hact_st);
+	lcdc_msk_reg(lcdc_dev, POST_DSP_HACT_INFO, mask, val);
+
+	mask = m_DSP_VACT_END_POST | m_DSP_VACT_ST_POST;
+	val = v_DSP_VACT_END_POST(post_dsp_vact_end) | 
+	      v_DSP_VACT_ST_POST(post_dsp_vact_st);
+	lcdc_msk_reg(lcdc_dev, POST_DSP_VACT_INFO, mask, val);
+
+	mask = m_POST_HS_FACTOR_YRGB | m_POST_VS_FACTOR_YRGB;
+	val = v_POST_HS_FACTOR_YRGB(post_h_fac) |
+		v_POST_VS_FACTOR_YRGB(post_v_fac);
+	lcdc_msk_reg(lcdc_dev, POST_SCL_FACTOR_YRGB, mask, val);
+
+	mask = m_DSP_VACT_END_POST_F1 | m_DSP_VACT_ST_POST_F1;
+	val = v_DSP_VACT_END_POST_F1(post_dsp_vact_end_f1) |
+		v_DSP_VACT_ST_POST_F1(post_dsp_vact_st_f1);
+	lcdc_msk_reg(lcdc_dev, POST_DSP_VACT_INFO_F1, mask, val);
+
+	mask = m_POST_HOR_SD_EN | m_POST_VER_SD_EN;
+	val = v_POST_HOR_SD_EN(post_hsd_en) | v_POST_VER_SD_EN(post_vsd_en);
+	lcdc_msk_reg(lcdc_dev, POST_SCL_CTRL, mask, val);
+	return 0;
+}
+
+static int rk3288_lcdc_clr_key_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+							   struct
+							   lcdc_device,
+							   driver);
+	struct rk_lcdc_win *win;
+	u32  colorkey_r,colorkey_g,colorkey_b;
+	int i,key_val;
+	for(i=0;i<4;i++){
+		win = dev_drv->win[i];
+		key_val = win->color_key_val;
+		colorkey_r = (key_val & 0xff)<<2;
+		colorkey_g = ((key_val>>8)&0xff)<<12;
+		colorkey_b = ((key_val>>16)&0xff)<<22;
+		/*color key dither 565/888->aaa*/
+		key_val = colorkey_r | colorkey_g | colorkey_b;
+		switch(i){
+		case 0:
+			lcdc_writel(lcdc_dev, WIN0_COLOR_KEY, key_val);
+			break;
+		case 1:
+			lcdc_writel(lcdc_dev, WIN1_COLOR_KEY, key_val);
+			break;
+		case 2:
+			lcdc_writel(lcdc_dev, WIN2_COLOR_KEY, key_val);
+			break;
+		case 3:
+			lcdc_writel(lcdc_dev, WIN3_COLOR_KEY, key_val);
+			break;
+		default:
+			printk(KERN_WARNING "%s:un support win num:%d\n",
+				__func__,i);		
+			break;
+		}
+	}
+	return 0;
+}
+
+static int rk3288_lcdc_alpha_cfg(struct rk_lcdc_driver *dev_drv,int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+		container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	struct alpha_config alpha_config;
+
+	u32 mask, val;
+	int ppixel_alpha,global_alpha;
+	u32 src_alpha_ctl,dst_alpha_ctl;
+	ppixel_alpha = ((win->area[0].format == ARGB888) ||
+			(win->area[0].format == ABGR888)) ? 1 : 0;
+	global_alpha = (win->g_alpha_val == 0) ? 0 : 1; 
+	alpha_config.src_global_alpha_val = win->g_alpha_val;
+	win->alpha_mode = AB_SRC_OVER;
+	/*printk("%s,alpha_mode=%d,alpha_en=%d,ppixel_a=%d,gla_a=%d\n",
+		__func__,win->alpha_mode,win->alpha_en,ppixel_alpha,global_alpha);*/
+	switch(win->alpha_mode){
+	case AB_USER_DEFINE:
+		break;
+ 	case AB_CLEAR:
+		alpha_config.src_factor_mode=AA_ZERO;
+		alpha_config.dst_factor_mode=AA_ZERO;		
+		break;
+ 	case AB_SRC:
+		alpha_config.src_factor_mode=AA_ONE;
+		alpha_config.dst_factor_mode=AA_ZERO;
+		break;
+ 	case AB_DST:
+		alpha_config.src_factor_mode=AA_ZERO;
+		alpha_config.dst_factor_mode=AA_ONE;
+		break;
+ 	case AB_SRC_OVER:
+		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
+		if(global_alpha)
+			alpha_config.src_factor_mode=AA_SRC_GLOBAL;
+		else
+			alpha_config.src_factor_mode=AA_ONE;
+		alpha_config.dst_factor_mode=AA_SRC_INVERSE;		
+		break;
+ 	case AB_DST_OVER:
+		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode=AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode=AA_ONE;
+		break;
+ 	case AB_SRC_IN:
+		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode=AA_SRC;
+		alpha_config.dst_factor_mode=AA_ZERO;
+		break;
+ 	case AB_DST_IN:
+		alpha_config.src_factor_mode=AA_ZERO;
+		alpha_config.dst_factor_mode=AA_SRC;
+		break;
+ 	case AB_SRC_OUT:
+		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode=AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode=AA_ZERO;		
+		break;
+ 	case AB_DST_OUT:
+		alpha_config.src_factor_mode=AA_ZERO;
+		alpha_config.dst_factor_mode=AA_SRC_INVERSE;	
+		break;
+ 	case AB_SRC_ATOP:
+		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode=AA_SRC;
+		alpha_config.dst_factor_mode=AA_SRC_INVERSE;		
+		break;
+ 	case AB_DST_ATOP:
+		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode=AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode=AA_SRC;		
+		break;
+ 	case XOR:
+		alpha_config.src_color_mode=AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode=AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode=AA_SRC_INVERSE;			
+		break;	
+ 	case AB_SRC_OVER_GLOBAL:	
+		alpha_config.src_global_alpha_mode=AA_PER_PIX_GLOBAL;
+		alpha_config.src_color_mode=AA_SRC_NO_PRE_MUL;
+		alpha_config.src_factor_mode=AA_SRC_GLOBAL;
+		alpha_config.dst_factor_mode=AA_SRC_INVERSE;
+		break;
+	default:
+	    	pr_err("alpha mode error\n");
+      		break;		
+	}
+	if((ppixel_alpha == 1)&&(global_alpha == 1)){
+		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
+	}else if(ppixel_alpha == 1){
+		alpha_config.src_global_alpha_mode = AA_PER_PIX;
+	}else if(global_alpha == 1){
+		alpha_config.src_global_alpha_mode = AA_GLOBAL;
+	}else{
+		dev_warn(lcdc_dev->dev,"alpha_en should be 0\n");
+	}
+	alpha_config.src_alpha_mode = AA_STRAIGHT;
+	alpha_config.src_alpha_cal_m0 = AA_NO_SAT;
+
+	switch(win_id){
+	case 0:
+		src_alpha_ctl = 0x60;
+		dst_alpha_ctl = 0x64;
+		break;
+	case 1:
+		src_alpha_ctl = 0xa0;
+		dst_alpha_ctl = 0xa4;
+		break;
+	case 2:
+		src_alpha_ctl = 0xdc;
+		dst_alpha_ctl = 0xec;
+		break;
+	case 3:
+		src_alpha_ctl = 0x12c;
+		dst_alpha_ctl = 0x13c;
+		break;
+	}
+	mask = m_WIN0_DST_FACTOR_M0;
+	val  = v_WIN0_DST_FACTOR_M0(alpha_config.dst_factor_mode);
+	lcdc_msk_reg(lcdc_dev, dst_alpha_ctl, mask, val);
+	mask = m_WIN0_SRC_ALPHA_EN | m_WIN0_SRC_COLOR_M0 |
+		m_WIN0_SRC_ALPHA_M0 | m_WIN0_SRC_BLEND_M0 |
+		m_WIN0_SRC_ALPHA_CAL_M0 | m_WIN0_SRC_FACTOR_M0|
+		m_WIN0_SRC_GLOBAL_ALPHA;
+	val = v_WIN0_SRC_ALPHA_EN(1) | 
+		v_WIN0_SRC_COLOR_M0(alpha_config.src_color_mode) |
+		v_WIN0_SRC_ALPHA_M0(alpha_config.src_alpha_mode) |
+		v_WIN0_SRC_BLEND_M0(alpha_config.src_global_alpha_mode) |
+		v_WIN0_SRC_ALPHA_CAL_M0(alpha_config.src_alpha_cal_m0) |
+		v_WIN0_SRC_FACTOR_M0(alpha_config.src_factor_mode) |
+		v_WIN0_SRC_GLOBAL_ALPHA(alpha_config.src_global_alpha_val);
+	lcdc_msk_reg(lcdc_dev, src_alpha_ctl, mask, val);
+
+	return 0;
+}
+static int rk3288_lcdc_area_swap(struct rk_lcdc_win *win,int area_num)
+{
+	struct rk_lcdc_win_area area_temp;
+	switch(area_num){
+	case 2:
+		area_temp = win->area[0];
+		win->area[0] = win->area[1];
+		win->area[1] = area_temp;
+		break;
+	case 3:
+		area_temp = win->area[0];
+		win->area[0] = win->area[2];
+		win->area[2] = area_temp;
+		break;
+	case 4:
+		area_temp = win->area[0];
+		win->area[0] = win->area[3];
+		win->area[3] = area_temp;
+		
+		area_temp = win->area[1];
+		win->area[1] = win->area[2];
+		win->area[2] = area_temp;	
+		break;
+	default:
+		printk(KERN_WARNING "un supported area num!\n");
+		break;
+	}
+	return 0;
+}
+
+static int rk3288_win_area_check_var(int win_id,int area_num,struct rk_lcdc_win_area *area_pre,
+			struct rk_lcdc_win_area *area_now)
+{
+	if((area_pre->ypos >= area_now->ypos) ||
+		(area_pre->ypos+area_pre->ysize > area_now->ypos)){
+		area_now->state = 0;
+		pr_err("win[%d]:\n"
+			"area_pre[%d]:ypos[%d],ysize[%d]\n"
+			"area_now[%d]:ypos[%d],ysize[%d]\n",
+			win_id,
+			area_num-1,area_pre->ypos,area_pre->ysize,
+			area_num,  area_now->ypos,area_now->ysize);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int rk3288_win_0_1_reg_update(struct rk_lcdc_driver *dev_drv,int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	unsigned int mask, val, off;
+	off = win_id * 0x40;
+	if((win->win_lb_mode == 5) &&
+	   (dev_drv->version == VOP_FULL_RK3288_V1_0))
+		win->win_lb_mode = 4;
+
+	if(win->state == 1){
+		mask =  m_WIN0_EN | m_WIN0_DATA_FMT | m_WIN0_FMT_10 |
+			m_WIN0_LB_MODE | m_WIN0_RB_SWAP | m_WIN0_UV_SWAP;
+		val  =  v_WIN0_EN(win->state) |
+			v_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
+			v_WIN0_FMT_10(win->fmt_10) | 
+			v_WIN0_LB_MODE(win->win_lb_mode) | 
+			v_WIN0_RB_SWAP(win->area[0].swap_rb) |
+			v_WIN0_UV_SWAP(win->area[0].swap_uv);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0+off, mask,val);	
+	
+		mask =	m_WIN0_BIC_COE_SEL |
+			m_WIN0_VSD_YRGB_GT4 | m_WIN0_VSD_YRGB_GT2 |
+			m_WIN0_VSD_CBR_GT4 | m_WIN0_VSD_CBR_GT2 |
+			m_WIN0_YRGB_HOR_SCL_MODE | m_WIN0_YRGB_VER_SCL_MODE |
+			m_WIN0_YRGB_HSD_MODE | m_WIN0_YRGB_VSU_MODE |
+			m_WIN0_YRGB_VSD_MODE | m_WIN0_CBR_HOR_SCL_MODE |
+			m_WIN0_CBR_VER_SCL_MODE | m_WIN0_CBR_HSD_MODE |
+			m_WIN0_CBR_VSU_MODE | m_WIN0_CBR_VSD_MODE;
+		val =	v_WIN0_BIC_COE_SEL(win->bic_coe_el) |
+			v_WIN0_VSD_YRGB_GT4(win->vsd_yrgb_gt4) |
+			v_WIN0_VSD_YRGB_GT2(win->vsd_yrgb_gt2) |
+			v_WIN0_VSD_CBR_GT4(win->vsd_cbr_gt4) |
+			v_WIN0_VSD_CBR_GT2(win->vsd_cbr_gt2) |
+			v_WIN0_YRGB_HOR_SCL_MODE(win->yrgb_hor_scl_mode) |
+			v_WIN0_YRGB_VER_SCL_MODE(win->yrgb_ver_scl_mode) |
+			v_WIN0_YRGB_HSD_MODE(win->yrgb_hsd_mode) |
+			v_WIN0_YRGB_VSU_MODE(win->yrgb_vsu_mode) |
+			v_WIN0_YRGB_VSD_MODE(win->yrgb_vsd_mode) |
+			v_WIN0_CBR_HOR_SCL_MODE(win->cbr_hor_scl_mode) |
+			v_WIN0_CBR_VER_SCL_MODE(win->cbr_ver_scl_mode) |
+			v_WIN0_CBR_HSD_MODE(win->cbr_hsd_mode) |
+			v_WIN0_CBR_VSU_MODE(win->cbr_vsu_mode) |
+			v_WIN0_CBR_VSD_MODE(win->cbr_vsd_mode);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL1+off, mask,val);
+	
+		val =	v_WIN0_VIR_STRIDE(win->area[0].y_vir_stride) |
+			v_WIN0_VIR_STRIDE_UV(win->area[0].uv_vir_stride);	
+		lcdc_writel(lcdc_dev, WIN0_VIR+off, val);	
+		/*lcdc_writel(lcdc_dev, WIN0_YRGB_MST+off, win->area[0].y_addr); 
+		lcdc_writel(lcdc_dev, WIN0_CBR_MST+off, win->area[0].uv_addr);*/
+		val =	v_WIN0_ACT_WIDTH(win->area[0].xact) |
+			v_WIN0_ACT_HEIGHT(win->area[0].yact);
+		lcdc_writel(lcdc_dev, WIN0_ACT_INFO+off, val); 
+	
+		val =	v_WIN0_DSP_WIDTH(win->area[0].xsize) |
+			v_WIN0_DSP_HEIGHT(win->area[0].ysize);
+		lcdc_writel(lcdc_dev, WIN0_DSP_INFO+off, val); 
+	
+		val =	v_WIN0_DSP_XST(win->area[0].dsp_stx) |
+			v_WIN0_DSP_YST(win->area[0].dsp_sty);
+		lcdc_writel(lcdc_dev, WIN0_DSP_ST+off, val); 
+	
+		val =	v_WIN0_HS_FACTOR_YRGB(win->scale_yrgb_x) |
+			v_WIN0_VS_FACTOR_YRGB(win->scale_yrgb_y);
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB+off, val); 
+	
+		val =	v_WIN0_HS_FACTOR_CBR(win->scale_cbcr_x) |
+			v_WIN0_VS_FACTOR_CBR(win->scale_cbcr_y);
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR+off, val); 
+		if(win->alpha_en == 1)
+			rk3288_lcdc_alpha_cfg(dev_drv,win_id);
+		else{
+			mask = m_WIN0_SRC_ALPHA_EN;
+			val = v_WIN0_SRC_ALPHA_EN(0);
+			lcdc_msk_reg(lcdc_dev,WIN0_SRC_ALPHA_CTRL+off,mask,val);				
+		}
+		/*offset*/	
+	}else{
+		mask = m_WIN0_EN;
+		val = v_WIN0_EN(win->state);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0+off, mask,val); 
+	}
+	return 0;
+}
+
+static int rk3288_win_2_3_reg_update(struct rk_lcdc_driver *dev_drv,int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	struct rk_screen *screen = dev_drv->cur_screen;
+	unsigned int mask, val, off;
+	struct fb_info *fb0 = rk_get_fb(0);
+
+	off = (win_id-2) * 0x50;
+	if((screen->y_mirror == 1)&&(win->area_num > 1)){
+		rk3288_lcdc_area_swap(win,win->area_num);
+	}
+	
+	if(win->state == 1){
+		mask =  m_WIN2_EN | m_WIN2_DATA_FMT | m_WIN2_RB_SWAP;
+		val  =  v_WIN2_EN(1) |
+			v_WIN2_DATA_FMT(win->area[0].fmt_cfg) |
+			v_WIN2_RB_SWAP(win->area[0].swap_rb);
+		lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+		/*area 0*/
+		if(win->area[0].state == 1){
+			mask = m_WIN2_MST0_EN;
+			val  = v_WIN2_MST0_EN(win->area[0].state);
+			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+
+			mask = m_WIN2_VIR_STRIDE0;
+			val  = v_WIN2_VIR_STRIDE0(win->area[0].y_vir_stride);
+			lcdc_msk_reg(lcdc_dev,WIN2_VIR0_1+off,mask,val);
+
+			/*lcdc_writel(lcdc_dev,WIN2_MST0+off,win->area[0].y_addr);*/
+			val  = 	v_WIN2_DSP_WIDTH0(win->area[0].xsize) | 
+				v_WIN2_DSP_HEIGHT0(win->area[0].ysize);
+			lcdc_writel(lcdc_dev,WIN2_DSP_INFO0+off,val);
+			val  =	v_WIN2_DSP_XST0(win->area[0].dsp_stx) |
+				v_WIN2_DSP_YST0(win->area[0].dsp_sty);
+			lcdc_writel(lcdc_dev,WIN2_DSP_ST0+off,val);	
+		}else{
+			mask = m_WIN2_MST0_EN;
+			val  = v_WIN2_MST0_EN(0);
+			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+			lcdc_writel(lcdc_dev, WIN2_MST0 + off,
+				    fb0->fix.smem_start);
+		}
+		/*area 1*/
+		if(win->area[1].state == 1){
+			rk3288_win_area_check_var(win_id,1,&win->area[0],&win->area[1]);
+			
+			mask = m_WIN2_MST1_EN;
+			val  = v_WIN2_MST1_EN(win->area[1].state);
+			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+
+			mask = m_WIN2_VIR_STRIDE1;
+			val  = v_WIN2_VIR_STRIDE1(win->area[1].y_vir_stride);
+			lcdc_msk_reg(lcdc_dev,WIN2_VIR0_1+off,mask,val);
+
+			/*lcdc_writel(lcdc_dev,WIN2_MST1+off,win->area[1].y_addr);*/
+			val  = 	v_WIN2_DSP_WIDTH1(win->area[1].xsize) | 
+				v_WIN2_DSP_HEIGHT1(win->area[1].ysize);
+			lcdc_writel(lcdc_dev,WIN2_DSP_INFO1+off,val);
+			val  =	v_WIN2_DSP_XST1(win->area[1].dsp_stx) |
+				v_WIN2_DSP_YST1(win->area[1].dsp_sty);
+			lcdc_writel(lcdc_dev,WIN2_DSP_ST1+off,val);	
+		}else{
+			mask = m_WIN2_MST1_EN;
+			val  = v_WIN2_MST1_EN(0);
+			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+			lcdc_writel(lcdc_dev, WIN2_MST1 + off,
+				    fb0->fix.smem_start);
+		}
+		/*area 2*/
+		if(win->area[2].state == 1){
+			rk3288_win_area_check_var(win_id,2,&win->area[1],&win->area[2]);
+			
+			mask = m_WIN2_MST2_EN;
+			val  = v_WIN2_MST2_EN(win->area[2].state);
+			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+
+			mask = m_WIN2_VIR_STRIDE2;
+			val  = v_WIN2_VIR_STRIDE2(win->area[2].y_vir_stride);
+			lcdc_msk_reg(lcdc_dev,WIN2_VIR2_3+off,mask,val);
+
+			/*lcdc_writel(lcdc_dev,WIN2_MST2+off,win->area[2].y_addr);*/
+			val  = 	v_WIN2_DSP_WIDTH2(win->area[2].xsize) | 
+				v_WIN2_DSP_HEIGHT2(win->area[2].ysize);
+			lcdc_writel(lcdc_dev,WIN2_DSP_INFO2+off,val);
+			val  =	v_WIN2_DSP_XST2(win->area[2].dsp_stx) |
+				v_WIN2_DSP_YST2(win->area[2].dsp_sty);
+			lcdc_writel(lcdc_dev,WIN2_DSP_ST2+off,val);	
+		}else{
+			mask = m_WIN2_MST2_EN;
+			val  = v_WIN2_MST2_EN(0);
+			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+			lcdc_writel(lcdc_dev, WIN2_MST2 + off,
+				    fb0->fix.smem_start);
+		}
+		/*area 3*/
+		if(win->area[3].state == 1){
+			rk3288_win_area_check_var(win_id,3,&win->area[2],&win->area[3]);
+			
+			mask = m_WIN2_MST3_EN;
+			val  = v_WIN2_MST3_EN(win->area[3].state);
+			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+
+			mask = m_WIN2_VIR_STRIDE3;
+			val  = v_WIN2_VIR_STRIDE3(win->area[3].y_vir_stride);
+			lcdc_msk_reg(lcdc_dev,WIN2_VIR2_3+off,mask,val);
+
+			/*lcdc_writel(lcdc_dev,WIN2_MST3+off,win->area[3].y_addr);*/
+			val  = 	v_WIN2_DSP_WIDTH3(win->area[3].xsize) | 
+				v_WIN2_DSP_HEIGHT3(win->area[3].ysize);
+			lcdc_writel(lcdc_dev,WIN2_DSP_INFO3+off,val);
+			val  =	v_WIN2_DSP_XST3(win->area[3].dsp_stx) |
+				v_WIN2_DSP_YST3(win->area[3].dsp_sty);
+			lcdc_writel(lcdc_dev,WIN2_DSP_ST3+off,val);	
+		}else{
+			mask = m_WIN2_MST3_EN;
+			val  = v_WIN2_MST3_EN(0);
+			lcdc_msk_reg(lcdc_dev,WIN2_CTRL0+off,mask,val);
+			lcdc_writel(lcdc_dev, WIN2_MST3 + off,
+				    fb0->fix.smem_start);
+		}	
+
+		if(win->alpha_en == 1)
+			rk3288_lcdc_alpha_cfg(dev_drv,win_id);
+		else{
+			mask = m_WIN2_SRC_ALPHA_EN;
+			val = v_WIN2_SRC_ALPHA_EN(0);
+			lcdc_msk_reg(lcdc_dev,WIN2_SRC_ALPHA_CTRL+off,mask,val);				
+		}
+	}else{
+		mask =  m_WIN2_EN | m_WIN2_MST0_EN |
+			m_WIN2_MST0_EN | m_WIN2_MST2_EN |
+			m_WIN2_MST3_EN;
+		val  =  v_WIN2_EN(win->state) | v_WIN2_MST0_EN(0) |
+			v_WIN2_MST1_EN(0) | v_WIN2_MST2_EN(0) |
+			v_WIN2_MST3_EN(0);
+		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0+off, mask,val); 
+	}
+	return 0;
+}
+
+static int rk3288_lcdc_reg_update(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int timeout;
+	unsigned long flags;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
+			     v_STANDBY_EN(lcdc_dev->standby));
+		rk3288_win_0_1_reg_update(dev_drv,0);
+		rk3288_win_0_1_reg_update(dev_drv,1);
+		rk3288_win_2_3_reg_update(dev_drv,2);
+		rk3288_win_2_3_reg_update(dev_drv,3);
+		/*rk3288_lcdc_post_cfg(dev_drv);*/
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	/*if (dev_drv->wait_fs) {*/
+	if (0){
+		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,
+						      msecs_to_jiffies
+						      (dev_drv->cur_screen->ft +
+						       5));
+		if (!timeout && (!dev_drv->frame_done.done)) {
+			dev_warn(lcdc_dev->dev, "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
+	return 0;
+
+}
+
+static int rk3288_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
+{
+	memcpy((u8 *) lcdc_dev->regs, (u8 *) lcdc_dev->regsbak, 0x1fc);
+	return 0;
+}
+static int rk3288_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
+{
+	u32 mask,val;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	if (dev_drv->iommu_enabled) {
+		if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
+
+		if (likely(lcdc_dev->clk_on)) {
+			spin_lock(&lcdc_dev->reg_lock);
+			mask = m_MMU_EN;
+			val = v_MMU_EN(1);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			mask = m_AXI_MAX_OUTSTANDING_EN | m_AXI_OUTSTANDING_MAX_NUM;
+			val = v_AXI_OUTSTANDING_MAX_NUM(31) | v_AXI_MAX_OUTSTANDING_EN(1);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL1, mask, val);
+			spin_unlock(&lcdc_dev->reg_lock);
+	}
+			lcdc_dev->iommu_status = 1;
+			rockchip_iovmm_activate(dev_drv->dev);
+		}
+	}
+	return 0;
+}
+
+static int rk3288_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv, int reset_rate)
+{
+#ifdef CONFIG_RK_FPGA
+	return 0;
+#endif
+	int ret = 0,fps;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+        if (reset_rate)
+	        ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);/*set pll */
+	if (ret)
+		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
+	lcdc_dev->pixclock =
+		 div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
+	
+	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
+	screen->ft = 1000 / fps;
+	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
+		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
+	return 0;
+
+}
+
+static void rk3288_lcdc_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 bcsh_color_bar;
+
+	if (dev_drv->output_color == COLOR_RGB) {
+		bcsh_color_bar = lcdc_readl(lcdc_dev, BCSH_COLOR_BAR);
+		if (((bcsh_color_bar & m_BCSH_EN) == 1) ||
+		    (dev_drv->bcsh.enable == 1))/*bcsh enabled */
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
+				     v_BCSH_R2Y_EN(1) | v_BCSH_Y2R_EN(1));
+		else
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
+				     v_BCSH_R2Y_EN(0) | v_BCSH_Y2R_EN(0));
+	} else {	/* RGB2YUV */
+		lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+			     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
+			     v_BCSH_R2Y_EN(1) | v_BCSH_Y2R_EN(0));
+	}
+}
+
+static int rk3288_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
+				  u16 *yact, int *format, u32 *dsp_addr,
+				  int *ymirror)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	u32 val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+
+	val = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
+	*xact = (val & m_WIN0_ACT_WIDTH) + 1;
+	*yact = ((val & m_WIN0_ACT_HEIGHT)>>16) + 1;
+
+	val = lcdc_readl(lcdc_dev, WIN0_CTRL0);
+	*format = (val & m_WIN0_DATA_FMT) >> 1;
+	*dsp_addr = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
+
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk3288_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
+			      int format, u16 xact, u16 yact, u16 xvir,
+			      int ymirror)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	u32 val, mask;
+	struct rk_lcdc_win *win = dev_drv->win[0];
+	int swap = (format == RGB888) ? 1 : 0;
+
+	mask = m_WIN0_DATA_FMT | m_WIN0_RB_SWAP;
+	val = v_WIN0_DATA_FMT(format) | v_WIN0_RB_SWAP(swap);
+	lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
+
+	lcdc_msk_reg(lcdc_dev, WIN0_VIR, m_WIN0_VIR_STRIDE,
+			v_WIN0_VIR_STRIDE(xvir));
+	lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_WIN0_ACT_WIDTH(xact) |
+		    v_WIN0_ACT_HEIGHT(yact));
+
+	lcdc_writel(lcdc_dev, WIN0_YRGB_MST, rgb_mst);
+
+	lcdc_cfg_done(lcdc_dev);
+	win->state = 1;
+	win->last_state = 1;
+
+	return 0;
+}
+
+static int rk3288_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
+{
+	u16 face = 0;
+	u16 dclk_ddr = 0;
+	u32 v=0;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 hsync_len = screen->mode.hsync_len;
+	u16 left_margin = screen->mode.left_margin;
+	u16 right_margin = screen->mode.right_margin;
+	u16 vsync_len = screen->mode.vsync_len;
+	u16 upper_margin = screen->mode.upper_margin;
+	u16 lower_margin = screen->mode.lower_margin;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u32 mask, val;
+	u16 h_total,v_total;
+	int ret = 0;
+	int hdmi_dclk_out_en = 0;
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	
+	h_total = hsync_len + left_margin  + x_res + right_margin;
+	v_total = vsync_len + upper_margin + y_res + lower_margin;
+
+	screen->post_dsp_stx = x_res * (100 - screen->overscan.left) / 200;
+	screen->post_dsp_sty = y_res * (100 - screen->overscan.top) / 200;
+	screen->post_xsize = x_res * (screen->overscan.left + screen->overscan.right) / 200;
+	screen->post_ysize = y_res * (screen->overscan.top + screen->overscan.bottom) / 200;
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		switch (screen->face) {
+		case OUT_P565:
+			face = OUT_P565;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL | m_DITHER_UP_EN |
+			    m_PRE_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
+			    v_DITHER_DOWN_SEL(1) | v_DITHER_UP_EN(1) |
+			    v_PRE_DITHER_DOWN_EN(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_P666:
+			face = OUT_P666;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL | m_DITHER_UP_EN |
+			    m_PRE_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
+			    v_DITHER_DOWN_SEL(1) | v_DITHER_UP_EN(1) |
+			    v_PRE_DITHER_DOWN_EN(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_D888_P565:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL | m_DITHER_UP_EN |
+			    m_PRE_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
+			    v_DITHER_DOWN_SEL(1) | v_DITHER_UP_EN(1) |
+			    v_PRE_DITHER_DOWN_EN(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_D888_P666:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL | m_DITHER_UP_EN |
+			    m_PRE_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
+			    v_DITHER_DOWN_SEL(1) | v_DITHER_UP_EN(1) |
+			    v_PRE_DITHER_DOWN_EN(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_P888:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN |
+				m_PRE_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(1) |
+			    v_PRE_DITHER_DOWN_EN(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_YUV_420:
+			hdmi_dclk_out_en = 1;
+			face = OUT_YUV_420;
+			dclk_ddr = 1;
+			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN |
+				m_PRE_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(1) |
+			    v_PRE_DITHER_DOWN_EN(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_YUV_420_10BIT:
+			hdmi_dclk_out_en = 1;
+			face = OUT_YUV_420;
+			dclk_ddr = 1;
+			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN |
+				m_PRE_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(1) |
+			    v_PRE_DITHER_DOWN_EN(0);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_P101010:
+			face = OUT_P101010;
+			mask = m_DITHER_DOWN_EN | m_DITHER_UP_EN |
+				m_PRE_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0) | v_DITHER_UP_EN(1) |
+			    v_PRE_DITHER_DOWN_EN(0);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		default:
+			dev_err(lcdc_dev->dev,"un supported interface!\n");
+			break;
+		}
+		switch(screen->type){
+		case SCREEN_RGB:
+		case SCREEN_LVDS:
+		case SCREEN_DUAL_LVDS:
+		case SCREEN_LVDS_10BIT:
+		case SCREEN_DUAL_LVDS_10BIT:
+			mask = m_RGB_OUT_EN;
+			val = v_RGB_OUT_EN(1);
+			v = 1 << (3+16);
+			v |= (lcdc_dev->id << 3);
+		        break;
+		case SCREEN_HDMI:
+			if ((screen->face == OUT_P888) ||
+			    (screen->face == OUT_P101010))
+				face = OUT_P101010;/*RGB 101010 output*/
+			mask = m_HDMI_OUT_EN;
+			val = v_HDMI_OUT_EN(1);
+			break;
+		case SCREEN_MIPI:
+			mask = m_MIPI_OUT_EN;
+			val = v_MIPI_OUT_EN(1); 		
+			break;
+		case SCREEN_DUAL_MIPI:
+			mask = m_MIPI_OUT_EN | m_DOUB_CHANNEL_EN;
+			val = v_MIPI_OUT_EN(1) | v_DOUB_CHANNEL_EN(1); 	
+			break;
+		case SCREEN_EDP:
+			face = OUT_P101010;  /*RGB 101010 output*/
+			mask = m_EDP_OUT_EN;
+			val = v_EDP_OUT_EN(1);
+			break;
+		default:
+			mask = 0;
+			val = 0;
+			pr_info("unknow screen type: %d\n", screen->type);
+			break;
+		}
+		if (dev_drv->version == VOP_FULL_RK3288_V1_1) {
+			mask |= m_HDMI_DCLK_OUT_EN;
+			val |= v_HDMI_DCLK_OUT_EN(hdmi_dclk_out_en);
+		}
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+#ifndef CONFIG_RK_FPGA
+		writel_relaxed(v, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
+#endif		
+		mask = m_DSP_OUT_MODE | m_DSP_HSYNC_POL | m_DSP_VSYNC_POL |
+		       m_DSP_DEN_POL | m_DSP_DCLK_POL | m_DSP_BG_SWAP | 
+		       m_DSP_RB_SWAP | m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
+		       m_DSP_DUMMY_SWAP | m_DSP_OUT_ZERO | m_DSP_BLANK_EN | 
+		       m_DSP_BLACK_EN | m_DSP_X_MIR_EN | m_DSP_Y_MIR_EN |
+		       m_DSP_DCLK_DDR;
+		val = v_DSP_OUT_MODE(face) | v_DSP_HSYNC_POL(screen->pin_hsync) |
+		      v_DSP_VSYNC_POL(screen->pin_vsync) | 
+		      v_DSP_DEN_POL(screen->pin_den) | v_DSP_DCLK_POL(screen->pin_dclk) |
+		      v_DSP_BG_SWAP(screen->swap_gb) | v_DSP_RB_SWAP(screen->swap_rb) | 
+		      v_DSP_RG_SWAP(screen->swap_rg) | 
+		      v_DSP_DELTA_SWAP(screen->swap_delta) |
+		      v_DSP_DUMMY_SWAP(screen->swap_dumy) | v_DSP_OUT_ZERO(0) | 
+		      v_DSP_BLANK_EN(0) | v_DSP_BLACK_EN(0) |
+		      v_DSP_X_MIR_EN(screen->x_mirror) |
+		      v_DSP_Y_MIR_EN(screen->y_mirror) |
+		      v_DSP_DCLK_DDR(dclk_ddr);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+
+		mask = m_DSP_BG_BLUE | m_DSP_BG_GREEN | m_DSP_BG_RED;
+		val  = v_DSP_BG_BLUE(0) | v_DSP_BG_GREEN(0) | v_DSP_BG_RED(0);
+		lcdc_msk_reg(lcdc_dev, DSP_BG, mask, val);
+
+		mask = m_DSP_HS_PW | m_DSP_HTOTAL;
+		val = v_DSP_HS_PW(hsync_len) | v_DSP_HTOTAL(h_total);
+		lcdc_msk_reg(lcdc_dev, DSP_HTOTAL_HS_END, mask, val);
+
+		mask = m_DSP_HACT_END | m_DSP_HACT_ST;
+		val = v_DSP_HACT_END(hsync_len + left_margin + x_res) |
+		    v_DSP_HACT_ST(hsync_len + left_margin);
+		lcdc_msk_reg(lcdc_dev, DSP_HACT_ST_END, mask, val);
+
+		mask = m_DSP_VS_PW | m_DSP_VTOTAL;
+		val = v_DSP_VS_PW(vsync_len) | v_DSP_VTOTAL(v_total);
+		lcdc_msk_reg(lcdc_dev, DSP_VTOTAL_VS_END, mask, val);
+
+		mask = m_DSP_VACT_END | m_DSP_VACT_ST;
+		val = v_DSP_VACT_END(vsync_len + upper_margin + y_res) |
+		    v_DSP_VACT_ST(vsync_len + upper_margin);
+		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END, mask, val);
+
+		rk3288_lcdc_post_cfg(dev_drv);
+		mask = m_DSP_LINE_FLAG_NUM;
+		val = v_DSP_LINE_FLAG_NUM(vsync_len + upper_margin + y_res);
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, mask, val);
+		dev_drv->output_color = screen->color_mode;
+		if (dev_drv->version == VOP_FULL_RK3288_V1_1) {
+			rk3288_lcdc_bcsh_path_sel(dev_drv);
+		} else {
+			if (dev_drv->output_color != COLOR_RGB) {
+				pr_err("vop ver:%x,unsupport output color:%d\n",
+				       dev_drv->version, dev_drv->output_color);
+				ret = -1;
+			}
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	rk3288_lcdc_set_dclk(dev_drv, 1);
+	if (screen->type != SCREEN_HDMI && dev_drv->trsm_ops &&
+	    dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	if (screen->init)
+		screen->init();
+	
+	return ret;
+}
+
+/*enable layer,open:1,enable;0 disable*/
+static int win0_open(struct lcdc_device *lcdc_dev, bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt++;
+		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.win[0]->state = open;
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int win1_open(struct lcdc_device *lcdc_dev, bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt++;
+		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.win[1]->state = open;
+
+		/*if no layer used,disable lcdc*/
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int win2_open(struct lcdc_device *lcdc_dev, bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt++;
+		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.win[2]->state = open;
+
+		/*if no layer used,disable lcdc*/
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int win3_open(struct lcdc_device *lcdc_dev, bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev, "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt++;
+		} else if ((lcdc_dev->atv_layer_cnt > 0) && (!open)) {
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.win[3]->state = open;
+
+		/*if no layer used,disable lcdc*/
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev, "no layer is used,go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+static int rk3288_lcdc_enable_irq(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	u32 mask,val;
+	
+	mask = m_FS_INTR_CLR | m_FS_INTR_EN | m_LINE_FLAG_INTR_CLR |
+			    m_LINE_FLAG_INTR_EN | m_BUS_ERROR_INTR_CLR | 
+			    m_BUS_ERROR_INTR_EN;
+	val = v_FS_INTR_CLR(1) | v_FS_INTR_EN(1) | v_LINE_FLAG_INTR_CLR(1) |
+	    v_LINE_FLAG_INTR_EN(1) | v_BUS_ERROR_INTR_CLR(1) | v_BUS_ERROR_INTR_EN(0);
+	lcdc_msk_reg(lcdc_dev, INTR_CTRL0, mask, val);	
+#ifdef LCDC_IRQ_EMPTY_DEBUG
+		 mask = m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN | m_WIN2_EMPTY_INTR_EN |
+			 m_WIN3_EMPTY_INTR_EN |m_HWC_EMPTY_INTR_EN | m_POST_BUF_EMPTY_INTR_EN |
+			 m_PWM_GEN_INTR_EN;
+		 val = v_WIN0_EMPTY_INTR_EN(1) | v_WIN1_EMPTY_INTR_EN(1) | v_WIN2_EMPTY_INTR_EN(1) |
+			 v_WIN3_EMPTY_INTR_EN(1)| v_HWC_EMPTY_INTR_EN(1) | v_POST_BUF_EMPTY_INTR_EN(1) |
+			 v_PWM_GEN_INTR_EN(1);
+		 lcdc_msk_reg(lcdc_dev, INTR_CTRL1, mask, val);
+#endif 	
+	return 0;
+}
+
+static int rk3288_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
+			    bool open)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	int sys_status = (dev_drv->id == 0) ?
+			SYS_STATUS_LCDC0 : SYS_STATUS_LCDC1;
+
+	/*enable clk,when first layer open */
+	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
+		rockchip_set_system_status(sys_status);
+		rk3288_lcdc_pre_init(dev_drv);
+		rk3288_lcdc_clk_enable(lcdc_dev);
+		rk3288_lcdc_enable_irq(dev_drv);
+		if (dev_drv->iommu_enabled) {
+			if (!dev_drv->mmu_dev) {
+				dev_drv->mmu_dev =
+                                        rk_fb_get_sysmmu_device_by_compatible(dev_drv->mmu_dts_name);
+				if (dev_drv->mmu_dev) {
+					rk_fb_platform_set_sysmmu(dev_drv->mmu_dev,
+					                          dev_drv->dev);
+                                } else {
+					dev_err(dev_drv->dev,
+						"failed to get rockchip iommu device\n");
+					return -1;
+				}
+			}
+		}
+		rk3288_lcdc_reg_restore(lcdc_dev);
+		/*if (dev_drv->iommu_enabled)
+		   rk3368_lcdc_mmu_en(dev_drv); */
+		if ((support_uboot_display()&&(lcdc_dev->prop == PRMRY))) {
+			rk3288_lcdc_set_dclk(dev_drv, 0);
+			/* rk3288_lcdc_enable_irq(dev_drv); */
+		} else {
+			rk3288_load_screen(dev_drv, 1);
+		}
+		if (dev_drv->bcsh.enable)
+			rk3288_lcdc_set_bcsh(dev_drv, 1);
+		spin_lock(&lcdc_dev->reg_lock);
+		rk3288_lcdc_set_lut(dev_drv);
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	if (win_id == 0)
+		win0_open(lcdc_dev, open);
+	else if (win_id == 1)
+		win1_open(lcdc_dev, open);
+	else if (win_id == 2)
+		win2_open(lcdc_dev, open);
+	else if (win_id == 3)
+		win3_open(lcdc_dev, open);
+	else
+		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
+
+	/* when all layer closed,disable clk */
+	if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
+		rk3288_lcdc_disable_irq(lcdc_dev);
+		rk3288_lcdc_reg_update(dev_drv);
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev) {
+				rockchip_iovmm_deactivate(dev_drv->dev);
+				lcdc_dev->iommu_status = 0;
+			}
+		}
+		rk3288_lcdc_clk_disable(lcdc_dev);
+		rockchip_clear_system_status(sys_status);
+	}
+
+	return 0;
+}
+
+static int win0_display(struct lcdc_device *lcdc_dev,
+			struct rk_lcdc_win *win)
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = win->area[0].smem_start+win->area[0].y_offset;/*win->smem_start + win->y_offset;*/
+	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
+	DBG(2, "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x>>offset:%d\n",
+	    lcdc_dev->id, __func__, y_addr, uv_addr,win->area[0].y_offset);
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		win->area[0].y_addr = y_addr;
+		win->area[0].uv_addr = uv_addr;	
+		lcdc_writel(lcdc_dev, WIN0_YRGB_MST, win->area[0].y_addr); 
+		lcdc_writel(lcdc_dev, WIN0_CBR_MST, win->area[0].uv_addr);
+		/*lcdc_cfg_done(lcdc_dev);*/
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+
+}
+
+static int win1_display(struct lcdc_device *lcdc_dev,
+			struct rk_lcdc_win *win)
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
+	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",
+	    lcdc_dev->id, __func__, y_addr, uv_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		win->area[0].y_addr = y_addr;
+		win->area[0].uv_addr = uv_addr;	
+		lcdc_writel(lcdc_dev, WIN1_YRGB_MST, win->area[0].y_addr); 
+		lcdc_writel(lcdc_dev, WIN1_CBR_MST, win->area[0].uv_addr);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+
+	return 0;
+}
+
+static int win2_display(struct lcdc_device *lcdc_dev,
+			struct rk_lcdc_win *win)
+{
+	u32 i,y_addr;
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>\n",
+	    lcdc_dev->id, __func__, y_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)){
+		for(i=0;i<win->area_num;i++)
+			win->area[i].y_addr = 
+				win->area[i].smem_start + win->area[i].y_offset;
+			if (win->area[0].state)
+				lcdc_writel(lcdc_dev, WIN2_MST0,
+					    win->area[0].y_addr);
+			if (win->area[1].state)
+				lcdc_writel(lcdc_dev, WIN2_MST1,
+					    win->area[1].y_addr);
+			if (win->area[2].state)
+				lcdc_writel(lcdc_dev, WIN2_MST2,
+					    win->area[2].y_addr);
+			if (win->area[3].state)
+				lcdc_writel(lcdc_dev, WIN2_MST3,
+					    win->area[3].y_addr);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int win3_display(struct lcdc_device *lcdc_dev,
+			struct rk_lcdc_win *win)
+{
+	u32 i,y_addr;
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	DBG(2, "lcdc%d>>%s>>y_addr:0x%x>>\n",
+	    lcdc_dev->id, __func__, y_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)){
+		for(i=0;i<win->area_num;i++)
+			win->area[i].y_addr = 
+				win->area[i].smem_start + win->area[i].y_offset;
+			if (win->area[0].state)
+				lcdc_writel(lcdc_dev, WIN3_MST0,
+					    win->area[0].y_addr);
+			if (win->area[1].state)
+				lcdc_writel(lcdc_dev, WIN3_MST1,
+					    win->area[1].y_addr);
+			if (win->area[2].state)
+				lcdc_writel(lcdc_dev, WIN3_MST2,
+					    win->area[2].y_addr);
+			if (win->area[3].state)
+				lcdc_writel(lcdc_dev, WIN3_MST3,
+					    win->area[3].y_addr);
+		}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk3288_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+				struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	
+#if defined(WAIT_FOR_SYNC)
+	int timeout;
+	unsigned long flags;
+#endif
+	win = dev_drv->win[win_id];
+ 	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+ 	if(win_id == 0){
+		win0_display(lcdc_dev, win);
+	}else if(win_id == 1){
+		win1_display(lcdc_dev, win);
+	}else if(win_id == 2){
+		win2_display(lcdc_dev, win);
+	}else if(win_id == 3){
+		win3_display(lcdc_dev, win);
+	}else{
+		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
+		return -EINVAL;
+	}
+ 
+	/*this is the first frame of the system ,enable frame start interrupt */
+	if ((dev_drv->first_frame)) {
+		dev_drv->first_frame = 0;
+		rk3288_lcdc_enable_irq(dev_drv);
+	}
+#if defined(WAIT_FOR_SYNC)
+	spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+	init_completion(&dev_drv->frame_done);
+	spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+	timeout = wait_for_completion_timeout(&dev_drv->frame_done,
+					      msecs_to_jiffies(dev_drv->
+							       cur_screen->ft +
+							       5));
+	if (!timeout && (!dev_drv->frame_done.done)) {
+		dev_info(dev_drv->dev, "wait for new frame start time out!\n");
+		return -ETIMEDOUT;
+	}
+#endif 
+	return 0;
+}
+
+static int rk3288_lcdc_cal_scl_fac(struct rk_lcdc_win *win)
+{
+	u16 srcW;
+	u16 srcH;
+	u16 dstW;
+	u16 dstH;
+	u16 yrgb_srcW;
+	u16 yrgb_srcH;
+	u16 yrgb_dstW;
+	u16 yrgb_dstH;
+	u32 yrgb_vScaleDnMult;
+	u32 yrgb_xscl_factor;
+	u32 yrgb_yscl_factor;
+	u8  yrgb_vsd_bil_gt2=0;
+	u8  yrgb_vsd_bil_gt4=0;
+	
+	u16 cbcr_srcW;
+	u16 cbcr_srcH;
+	u16 cbcr_dstW;
+	u16 cbcr_dstH;	  
+	u32 cbcr_vScaleDnMult;
+	u32 cbcr_xscl_factor;
+	u32 cbcr_yscl_factor;
+	u8  cbcr_vsd_bil_gt2=0;
+	u8  cbcr_vsd_bil_gt4=0;
+	u8  yuv_fmt=0;
+
+
+	srcW = win->area[0].xact;
+	srcH = win->area[0].yact;
+	dstW = win->area[0].xsize;
+	dstH = win->area[0].ysize;
+
+	/*yrgb scl mode*/
+	yrgb_srcW = srcW;
+	yrgb_srcH = srcH;
+	yrgb_dstW = dstW;
+	yrgb_dstH = dstH;
+	if ((yrgb_dstW*8 <= yrgb_srcW) || (yrgb_dstH*8 <= yrgb_srcH)) {
+		pr_err("ERROR: yrgb scale exceed 8,"
+		       "srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
+		       yrgb_srcW,yrgb_srcH,yrgb_dstW,yrgb_dstH);
+	}
+	if(yrgb_srcW < yrgb_dstW){
+		win->yrgb_hor_scl_mode = SCALE_UP;
+    	}else if(yrgb_srcW > yrgb_dstW){
+        	win->yrgb_hor_scl_mode = SCALE_DOWN;
+    	}else{
+        	win->yrgb_hor_scl_mode = SCALE_NONE;
+    	}
+
+    	if(yrgb_srcH < yrgb_dstH){
+        	win->yrgb_ver_scl_mode = SCALE_UP;
+    	}else if (yrgb_srcH  > yrgb_dstH){
+        	win->yrgb_ver_scl_mode = SCALE_DOWN;
+    	}else{
+        	win->yrgb_ver_scl_mode = SCALE_NONE;
+    	}
+
+	/*cbcr scl mode*/
+	switch (win->area[0].format) {
+	case YUV422:
+	case YUV422_A:	
+		cbcr_srcW = srcW/2;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	case YUV420:
+	case YUV420_A:	
+		cbcr_srcW = srcW/2;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH/2;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	case YUV444:
+	case YUV444_A:	
+		cbcr_srcW = srcW;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	default:
+		cbcr_srcW = 0;
+	        cbcr_dstW = 0;
+	        cbcr_srcH = 0;
+	        cbcr_dstH = 0;
+		yuv_fmt = 0;
+		break;
+	}		
+	if (yuv_fmt) {
+		if ((cbcr_dstW*8 <= cbcr_srcW) || (cbcr_dstH*8 <= cbcr_srcH)) {
+			pr_err("ERROR: cbcr scale exceed 8,"
+		       "srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
+		       cbcr_srcW,cbcr_srcH,cbcr_dstW,cbcr_dstH);
+		}
+	}
+	
+	if(cbcr_srcW < cbcr_dstW){
+		win->cbr_hor_scl_mode = SCALE_UP;
+	}else if(cbcr_srcW > cbcr_dstW){
+		win->cbr_hor_scl_mode = SCALE_DOWN;
+	}else{
+		win->cbr_hor_scl_mode = SCALE_NONE;
+	}
+	
+	if(cbcr_srcH < cbcr_dstH){
+		win->cbr_ver_scl_mode = SCALE_UP;
+	}else if(cbcr_srcH > cbcr_dstH){
+		win->cbr_ver_scl_mode = SCALE_DOWN;
+	}else{
+		win->cbr_ver_scl_mode = SCALE_NONE;
+	}
+	DBG(1, "srcW:%d>>srcH:%d>>dstW:%d>>dstH:%d>>\n"
+	       "yrgb:src:W=%d>>H=%d,dst:W=%d>>H=%d,H_mode=%d,V_mode=%d\n"
+	       "cbcr:src:W=%d>>H=%d,dst:W=%d>>H=%d,H_mode=%d,V_mode=%d\n"
+		,srcW,srcH,dstW,dstH,yrgb_srcW,yrgb_srcH,yrgb_dstW,
+		yrgb_dstH,win->yrgb_hor_scl_mode,win->yrgb_ver_scl_mode,
+		cbcr_srcW,cbcr_srcH,cbcr_dstW,cbcr_dstH,
+		win->cbr_hor_scl_mode,win->cbr_ver_scl_mode);
+
+    /*line buffer mode*/
+	if ((win->area[0].format == YUV422) ||
+	    (win->area[0].format == YUV420) ||
+	    (win->area[0].format == YUV422_A) ||
+	    (win->area[0].format == YUV420_A)) {
+		if (win->cbr_hor_scl_mode == SCALE_DOWN) {
+            		if ((cbcr_dstW > 3840) || (cbcr_dstW == 0)) {
+                		pr_err("ERROR cbcr_dstW = %d\n",cbcr_dstW);                
+			} else if (cbcr_dstW > 2560) {
+                		win->win_lb_mode = LB_RGB_3840X2;
+			} else if (cbcr_dstW > 1920) {
+				if (win->yrgb_hor_scl_mode == SCALE_DOWN) {
+                    			if(yrgb_dstW > 3840){
+                        			pr_err("ERROR yrgb_dst_width exceeds 3840\n");
+		                    	}else if(yrgb_dstW > 2560){
+		                        	win->win_lb_mode = LB_RGB_3840X2;
+		                    	}else if(yrgb_dstW > 1920){
+		                        	win->win_lb_mode = LB_RGB_2560X4;
+		                    	}else{
+		                        	pr_err("ERROR never run here!yrgb_dstW<1920 ==> cbcr_dstW>1920\n");
+		                    	}
+				}
+			} else if (cbcr_dstW > 1280) {
+                		win->win_lb_mode = LB_YUV_3840X5;
+			} else {
+                		win->win_lb_mode = LB_YUV_2560X8;
+            		}            
+		} else { /*SCALE_UP or SCALE_NONE*/
+            		if ((cbcr_srcW > 3840) || (cbcr_srcW == 0)) {
+                		pr_err("ERROR cbcr_srcW = %d\n",cbcr_srcW);
+            		}else if(cbcr_srcW > 2560){                
+                		win->win_lb_mode = LB_RGB_3840X2;
+            		}else if(cbcr_srcW > 1920){
+                		if(win->yrgb_hor_scl_mode == SCALE_DOWN){
+                    			if(yrgb_dstW > 3840){
+                        			pr_err("ERROR yrgb_dst_width exceeds 3840\n");
+                    			}else if(yrgb_dstW > 2560){
+                        			win->win_lb_mode = LB_RGB_3840X2;
+                    			}else if(yrgb_dstW > 1920){
+                        			win->win_lb_mode = LB_RGB_2560X4;
+                    			}else{
+                        			pr_err("ERROR never run here!yrgb_dstW<1920 ==> cbcr_dstW>1920\n");
+                    			}
+                		}  
+            		}else if(cbcr_srcW > 1280){
+               			 win->win_lb_mode = LB_YUV_3840X5;
+            		}else{
+                		win->win_lb_mode = LB_YUV_2560X8;
+            		}            
+        	}
+    	}else {
+        	if(win->yrgb_hor_scl_mode == SCALE_DOWN){
+            		if ((yrgb_dstW > 3840) || (yrgb_dstW == 0)) {
+                		pr_err("ERROR yrgb_dstW = %d\n",yrgb_dstW);
+            		}else if(yrgb_dstW > 2560){
+                		win->win_lb_mode = LB_RGB_3840X2;
+            		}else if(yrgb_dstW > 1920){
+                		win->win_lb_mode = LB_RGB_2560X4;
+            		}else if(yrgb_dstW > 1280){
+                		win->win_lb_mode = LB_RGB_1920X5;
+            		}else{
+                		win->win_lb_mode = LB_RGB_1280X8;
+            		}            
+        	}else{ /*SCALE_UP or SCALE_NONE*/
+            		if ((yrgb_srcW > 3840) || (yrgb_srcW == 0)) {
+                		pr_err("ERROR yrgb_srcW = %d\n",yrgb_srcW);
+            		}else if(yrgb_srcW > 2560){
+                		win->win_lb_mode = LB_RGB_3840X2;
+            		}else if(yrgb_srcW > 1920){
+                		win->win_lb_mode = LB_RGB_2560X4;
+            		}else if(yrgb_srcW > 1280){
+                		win->win_lb_mode = LB_RGB_1920X5;
+            		}else{
+                		win->win_lb_mode = LB_RGB_1280X8;
+            		}            
+        	}
+    	}
+    	DBG(1,"win->win_lb_mode = %d;\n",win->win_lb_mode);
+
+	/*vsd/vsu scale ALGORITHM*/
+	win->yrgb_hsd_mode = SCALE_DOWN_BIL;/*not to specify*/
+	win->cbr_hsd_mode  = SCALE_DOWN_BIL;/*not to specify*/
+	win->yrgb_vsd_mode = SCALE_DOWN_BIL;/*not to specify*/
+	win->cbr_vsd_mode  = SCALE_DOWN_BIL;/*not to specify*/
+	switch(win->win_lb_mode){
+	    case LB_YUV_3840X5:
+	    case LB_YUV_2560X8:
+	    case LB_RGB_1920X5:
+	    case LB_RGB_1280X8: 	
+		win->yrgb_vsu_mode = SCALE_UP_BIC; 
+		win->cbr_vsu_mode  = SCALE_UP_BIC; 
+		break;
+	    case LB_RGB_3840X2:
+		if(win->yrgb_ver_scl_mode != SCALE_NONE) {
+		    pr_err("ERROR : not allow yrgb ver scale\n");
+		}
+		if(win->cbr_ver_scl_mode != SCALE_NONE) {
+		    pr_err("ERROR : not allow cbcr ver scale\n");
+		}	     	  
+		break;
+	    case LB_RGB_2560X4:
+		win->yrgb_vsu_mode = SCALE_UP_BIL; 
+		win->cbr_vsu_mode  = SCALE_UP_BIL; 	    
+		break;
+	    default:
+	    	printk(KERN_WARNING "%s:un supported win_lb_mode:%d\n",
+			__func__,win->win_lb_mode);	
+		break;
+	}
+	DBG(1,"yrgb:hsd=%d,vsd=%d,vsu=%d;cbcr:hsd=%d,vsd=%d,vsu=%d\n",
+	       win->yrgb_hsd_mode,win->yrgb_vsd_mode,win->yrgb_vsu_mode,
+	       win->cbr_hsd_mode,win->cbr_vsd_mode,win->cbr_vsu_mode);
+
+    	/*SCALE FACTOR*/
+    
+    	/*(1.1)YRGB HOR SCALE FACTOR*/
+    	switch(win->yrgb_hor_scl_mode){
+        case SCALE_NONE:
+        	yrgb_xscl_factor = (1<<SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+            	break;
+        case SCALE_UP  :
+            	yrgb_xscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcW, yrgb_dstW);
+            	break;
+        case SCALE_DOWN:
+            	switch(win->yrgb_hsd_mode)
+            	{
+                case SCALE_DOWN_BIL:
+                	yrgb_xscl_factor = GET_SCALE_FACTOR_BILI_DN(yrgb_srcW, yrgb_dstW);
+                    	break;
+                case SCALE_DOWN_AVG:
+                    	yrgb_xscl_factor = GET_SCALE_FACTOR_AVRG(yrgb_srcW, yrgb_dstW);
+                    	break;
+                default :
+			printk(KERN_WARNING "%s:un supported yrgb_hsd_mode:%d\n",
+				__func__,win->yrgb_hsd_mode);		
+                    	break;
+            	} 
+            	break;
+        default :
+		printk(KERN_WARNING "%s:un supported yrgb_hor_scl_mode:%d\n",
+				__func__,win->yrgb_hor_scl_mode);	
+            break;
+    	} /*win->yrgb_hor_scl_mode*/
+
+    	/*(1.2)YRGB VER SCALE FACTOR*/
+    	switch(win->yrgb_ver_scl_mode)
+    	{
+        case SCALE_NONE:
+            	yrgb_yscl_factor = (1<<SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+           	 break;
+        case SCALE_UP  :
+            	switch(win->yrgb_vsu_mode)
+            	{
+                case SCALE_UP_BIL:
+                    	yrgb_yscl_factor = GET_SCALE_FACTOR_BILI_UP(yrgb_srcH, yrgb_dstH);
+                    	break;
+                case SCALE_UP_BIC:
+                    	if(yrgb_srcH < 3){
+                        	pr_err("yrgb_srcH should be greater than 3 !!!\n");
+                    	}                    
+                    	yrgb_yscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcH, yrgb_dstH);
+                   	break;
+                default :
+			printk(KERN_WARNING "%s:un supported yrgb_vsu_mode:%d\n",
+				__func__,win->yrgb_vsu_mode);			
+                    	break;
+            }
+            break;
+        case SCALE_DOWN:
+            	switch(win->yrgb_vsd_mode)
+            	{
+                case SCALE_DOWN_BIL:
+                    	yrgb_vScaleDnMult = getHardWareVSkipLines(yrgb_srcH, yrgb_dstH);
+                    	yrgb_yscl_factor  = GET_SCALE_FACTOR_BILI_DN_VSKIP(yrgb_srcH, yrgb_dstH, yrgb_vScaleDnMult);                                 
+                    	if(yrgb_vScaleDnMult == 4){
+                        	yrgb_vsd_bil_gt4 = 1;
+                        	yrgb_vsd_bil_gt2 = 0;
+                    	}else if(yrgb_vScaleDnMult == 2){
+                        	yrgb_vsd_bil_gt4 = 0;
+                        	yrgb_vsd_bil_gt2 = 1;
+                    	}else{
+                        	yrgb_vsd_bil_gt4 = 0;
+                        	yrgb_vsd_bil_gt2 = 0;
+                    	}
+                    	break;
+                case SCALE_DOWN_AVG:
+                    	yrgb_yscl_factor = GET_SCALE_FACTOR_AVRG(yrgb_srcH, yrgb_dstH);
+                    	break;
+                default:
+			printk(KERN_WARNING "%s:un supported yrgb_vsd_mode:%d\n",
+				__func__,win->yrgb_vsd_mode);		
+                    	break;
+            	} /*win->yrgb_vsd_mode*/
+            	break;
+	default :
+		printk(KERN_WARNING "%s:un supported yrgb_ver_scl_mode:%d\n",
+			__func__,win->yrgb_ver_scl_mode);		
+            	break;
+    	}
+    	win->scale_yrgb_x = yrgb_xscl_factor;
+    	win->scale_yrgb_y = yrgb_yscl_factor;
+    	win->vsd_yrgb_gt4 = yrgb_vsd_bil_gt4;
+    	win->vsd_yrgb_gt2 = yrgb_vsd_bil_gt2;
+	DBG(1,"yrgb:h_fac=%d,v_fac=%d,gt4=%d,gt2=%d\n",yrgb_xscl_factor,
+		yrgb_yscl_factor,yrgb_vsd_bil_gt4,yrgb_vsd_bil_gt2);
+
+    	/*(2.1)CBCR HOR SCALE FACTOR*/
+    	switch(win->cbr_hor_scl_mode)
+    	{
+        case SCALE_NONE:
+            	cbcr_xscl_factor = (1<<SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+            	break;
+        case SCALE_UP  :
+            	cbcr_xscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcW, cbcr_dstW);
+            	break;
+        case SCALE_DOWN:
+            	switch(win->cbr_hsd_mode)
+            	{
+                case SCALE_DOWN_BIL:
+                    	cbcr_xscl_factor = GET_SCALE_FACTOR_BILI_DN(cbcr_srcW, cbcr_dstW);
+                    	break;
+                case SCALE_DOWN_AVG:
+                    	cbcr_xscl_factor = GET_SCALE_FACTOR_AVRG(cbcr_srcW, cbcr_dstW);
+                    	break;
+                default :
+			printk(KERN_WARNING "%s:un supported cbr_hsd_mode:%d\n",
+				__func__,win->cbr_hsd_mode);	
+                    	break;
+            	}
+            	break;
+        default :
+		printk(KERN_WARNING "%s:un supported cbr_hor_scl_mode:%d\n",
+			__func__,win->cbr_hor_scl_mode);	
+            	break;
+    	} /*win->cbr_hor_scl_mode*/
+
+    	/*(2.2)CBCR VER SCALE FACTOR*/
+    	switch(win->cbr_ver_scl_mode)
+    	{
+        case SCALE_NONE:
+            	cbcr_yscl_factor = (1<<SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+            	break;
+        case SCALE_UP  :
+            	switch(win->cbr_vsu_mode)
+            	{
+                case SCALE_UP_BIL:
+                    	cbcr_yscl_factor = GET_SCALE_FACTOR_BILI_UP(cbcr_srcH, cbcr_dstH);
+                    	break;
+                case SCALE_UP_BIC:
+                    	if(cbcr_srcH < 3) {
+                        	pr_err("cbcr_srcH should be greater than 3 !!!\n");
+                    	}                    
+                    	cbcr_yscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcH, cbcr_dstH);
+                    	break;
+                default :
+			printk(KERN_WARNING "%s:un supported cbr_vsu_mode:%d\n",
+				__func__,win->cbr_vsu_mode);		
+                    	break;
+            	}
+            	break;
+        case SCALE_DOWN:
+            	switch(win->cbr_vsd_mode)
+            	{
+                case SCALE_DOWN_BIL:
+                    	cbcr_vScaleDnMult = getHardWareVSkipLines(cbcr_srcH, cbcr_dstH);
+                    	cbcr_yscl_factor  = GET_SCALE_FACTOR_BILI_DN_VSKIP(cbcr_srcH, cbcr_dstH, cbcr_vScaleDnMult);                    
+                    	if(cbcr_vScaleDnMult == 4){
+                        	cbcr_vsd_bil_gt4 = 1;
+                        	cbcr_vsd_bil_gt2 = 0;
+                    	}else if(cbcr_vScaleDnMult == 2){
+                        	cbcr_vsd_bil_gt4 = 0;
+                        	cbcr_vsd_bil_gt2 = 1;
+                    	}else{
+                        	cbcr_vsd_bil_gt4 = 0;
+                        	cbcr_vsd_bil_gt2 = 0;
+                    	}
+                    	break;
+                case SCALE_DOWN_AVG:
+                    	cbcr_yscl_factor = GET_SCALE_FACTOR_AVRG(cbcr_srcH, cbcr_dstH);
+                    	break;
+                default :
+			printk(KERN_WARNING "%s:un supported cbr_vsd_mode:%d\n",
+				__func__,win->cbr_vsd_mode);		
+                    break;
+            	}
+            	break;
+        default :
+		printk(KERN_WARNING "%s:un supported cbr_ver_scl_mode:%d\n",
+			__func__,win->cbr_ver_scl_mode);			
+            	break;
+    	}
+    	win->scale_cbcr_x = cbcr_xscl_factor;
+    	win->scale_cbcr_y = cbcr_yscl_factor;
+   	win->vsd_cbr_gt4  = cbcr_vsd_bil_gt4;
+    	win->vsd_cbr_gt2  = cbcr_vsd_bil_gt2;	
+
+	DBG(1,"cbcr:h_fac=%d,v_fac=%d,gt4=%d,gt2=%d\n",cbcr_xscl_factor,
+		cbcr_yscl_factor,cbcr_vsd_bil_gt4,cbcr_vsd_bil_gt2);
+	return 0;
+}
+
+
+
+static int win0_set_par(struct lcdc_device *lcdc_dev,
+			struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	u32 xact,yact,xvir, yvir,xpos, ypos;
+	u8 fmt_cfg = 0, swap_rb, swap_uv = 0;
+	char fmt[9] = "NULL";
+
+	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
+	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on)){
+		rk3288_lcdc_cal_scl_fac(win);/*fac,lb,gt2,gt4*/
+		switch (win->area[0].format) {
+		case ARGB888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case XBGR888:
+		case ABGR888:
+			fmt_cfg = 0;
+			swap_rb = 1;
+			win->fmt_10 = 0;
+			break;
+		case RGB888:
+			fmt_cfg = 1;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case RGB565:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV422:
+			fmt_cfg = 5;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV420:	
+			fmt_cfg = 4;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV420_NV21:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			swap_uv = 1;
+			win->fmt_10 = 0;
+			break;	
+		case YUV444:	
+			fmt_cfg = 6;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+		case YUV422_A:
+			fmt_cfg = 5;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUV420_A:	
+			fmt_cfg = 4;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUV444_A:	
+			fmt_cfg = 6;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		default:
+			dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
+				__func__);
+			break;
+		}
+		win->area[0].fmt_cfg = fmt_cfg;
+		win->area[0].swap_rb = swap_rb;
+		win->area[0].dsp_stx = xpos;
+		win->area[0].dsp_sty = ypos;
+		win->area[0].swap_uv = swap_uv;
+		xact = win->area[0].xact;
+		yact = win->area[0].yact;
+		xvir = win->area[0].xvir;
+		yvir = win->area[0].yvir;
+	}
+	rk3288_win_0_1_reg_update(&lcdc_dev->driver,0);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
+		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
+		__func__, get_format_string(win->area[0].format, fmt), xact,
+		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
+	return 0;
+
+}
+
+static int win1_set_par(struct lcdc_device *lcdc_dev,
+			struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u8 fmt_cfg = 0, swap_rb, swap_uv = 0;
+	char fmt[9] = "NULL";
+
+	xpos = win->area[0].xpos + screen->mode.left_margin + screen->mode.hsync_len;
+	ypos = win->area[0].ypos + screen->mode.upper_margin + screen->mode.vsync_len;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		rk3288_lcdc_cal_scl_fac(win);/*fac,lb,gt2,gt4*/
+		switch (win->area[0].format) {
+		case ARGB888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case XBGR888:
+		case ABGR888:
+			fmt_cfg = 0;
+			swap_rb = 1;
+			win->fmt_10 = 0;
+			break;
+		case RGB888:
+			fmt_cfg = 1;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case RGB565:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV422:
+			fmt_cfg = 5;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV420:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV420_NV21:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			swap_uv = 1;
+			win->fmt_10 = 0;
+			break;
+		case YUV444:
+			fmt_cfg = 6;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV422_A:
+			fmt_cfg = 5;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUV420_A:	
+			fmt_cfg = 4;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUV444_A:	
+			fmt_cfg = 6;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;			
+		default:
+			dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
+				__func__);
+			break;
+		}
+		win->area[0].fmt_cfg = fmt_cfg;
+		win->area[0].swap_rb = swap_rb;
+		win->area[0].dsp_stx = xpos;
+		win->area[0].dsp_sty = ypos;
+		win->area[0].swap_uv = swap_uv;
+		xact = win->area[0].xact;
+		yact = win->area[0].yact;
+		xvir = win->area[0].xvir;
+		yvir = win->area[0].yvir;
+	}
+	rk3288_win_0_1_reg_update(&lcdc_dev->driver,1);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	DBG(1, "lcdc%d>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d\n"
+		">>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n", lcdc_dev->id,
+		__func__, get_format_string(win->area[0].format, fmt), xact,
+		yact, win->area[0].xsize, win->area[0].ysize, xvir, yvir, xpos, ypos);
+	return 0;
+
+}
+
+static int win2_set_par(struct lcdc_device *lcdc_dev,
+			struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	int i;
+	u8 fmt_cfg, swap_rb;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		for (i = 0; i < win->area_num; i++) {
+			switch (win->area[i].format) {
+			case ARGB888:
+				fmt_cfg = 0;
+				swap_rb = 0;
+				break;
+			case XBGR888:
+			case ABGR888:
+				fmt_cfg = 0;
+				swap_rb = 1;
+				break;
+			case RGB888:
+				fmt_cfg = 1;
+				swap_rb = 0;
+				break;
+			case RGB565:
+				fmt_cfg = 2;
+				swap_rb = 0;
+				break;
+			default:
+				dev_err(lcdc_dev->driver.dev, 
+					"%s:un supported format!\n",
+					__func__);
+				break;
+			}			
+			win->area[i].fmt_cfg = fmt_cfg;
+			win->area[i].swap_rb = swap_rb;
+			win->area[i].dsp_stx = win->area[i].xpos + 
+				screen->mode.left_margin +
+				screen->mode.hsync_len;
+			if (screen->y_mirror == 1) {
+				win->area[i].dsp_sty = screen->mode.yres -
+					win->area[i].ypos -
+					win->area[i].ysize + 
+					screen->mode.upper_margin +
+					screen->mode.vsync_len;
+			} else {
+				win->area[i].dsp_sty = win->area[i].ypos + 
+					screen->mode.upper_margin +
+					screen->mode.vsync_len;
+			}
+			if ((win->area[i].xact != win->area[i].xsize) ||
+			    (win->area[i].yact != win->area[i].ysize)) {
+                                pr_err("win[%d]->area[%d],not support scale\n",
+                                        win->id, i);
+                                pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
+                                        win->area[i].xact,win->area[i].yact,
+                                        win->area[i].xsize,win->area[i].ysize);
+                                win->area[i].xsize = win->area[i].xact;
+                                win->area[i].ysize = win->area[i].yact;
+			}
+		}
+	}
+	rk3288_win_2_3_reg_update(&lcdc_dev->driver,2);
+	spin_unlock(&lcdc_dev->reg_lock);	
+	return 0;
+}
+
+static int win3_set_par(struct lcdc_device *lcdc_dev,
+			struct rk_screen *screen, struct rk_lcdc_win *win)
+
+{
+	int i;
+	u8 fmt_cfg, swap_rb;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		for (i = 0; i < win->area_num; i++) {
+			switch (win->area[i].format) {
+			case ARGB888:
+				fmt_cfg = 0;
+				swap_rb = 0;
+				break;
+			case XBGR888:
+			case ABGR888:
+				fmt_cfg = 0;
+				swap_rb = 1;
+				break;
+			case RGB888:
+				fmt_cfg = 1;
+				swap_rb = 0;
+				break;
+			case RGB565:
+				fmt_cfg = 2;
+				swap_rb = 0;
+				break;
+			default:
+				dev_err(lcdc_dev->driver.dev, 
+					"%s:un supported format!\n",
+					__func__);
+				break;
+			}			
+			win->area[i].fmt_cfg = fmt_cfg;
+			win->area[i].swap_rb = swap_rb;
+			win->area[i].dsp_stx = win->area[i].xpos + 
+				screen->mode.left_margin +
+				screen->mode.hsync_len;
+			if (screen->y_mirror == 1) {
+				win->area[i].dsp_sty = screen->mode.yres -
+					win->area[i].ypos -
+					win->area[i].ysize + 
+					screen->mode.upper_margin +
+					screen->mode.vsync_len;
+			} else {
+				win->area[i].dsp_sty = win->area[i].ypos + 
+					screen->mode.upper_margin +
+					screen->mode.vsync_len;
+			}
+			if ((win->area[i].xact != win->area[i].xsize) ||
+			    (win->area[i].yact != win->area[i].ysize)) {
+				pr_err("win[%d]->area[%d],not support scale\n",
+				       win->id, i);
+				pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
+				       win->area[i].xact, win->area[i].yact,
+				       win->area[i].xsize, win->area[i].ysize);
+				win->area[i].xsize = win->area[i].xact;
+				win->area[i].ysize = win->area[i].yact;
+			}
+		}
+	}
+	rk3288_win_2_3_reg_update(&lcdc_dev->driver,3);
+	spin_unlock(&lcdc_dev->reg_lock);	
+	return 0;
+}
+
+static int rk3288_lcdc_set_par(struct rk_lcdc_driver *dev_drv,int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	win = dev_drv->win[win_id];
+
+	switch(win_id)
+	{
+	case 0:
+		win0_set_par(lcdc_dev, screen, win);
+		break;
+	case 1:
+		win1_set_par(lcdc_dev, screen, win);
+		break;	
+	case 2:
+		win2_set_par(lcdc_dev, screen, win);
+		break;
+	case 3:
+		win3_set_par(lcdc_dev, screen, win);
+		break;		
+	default:
+		dev_err(dev_drv->dev, "unsupported win number:%d\n", win_id);
+		break;	
+	}
+	return 0;
+}
+
+static int rk3288_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
+			     unsigned long arg, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+							   struct
+							   lcdc_device,
+							   driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	struct color_key_cfg clr_key_cfg;
+
+	switch (cmd) {
+	case RK_FBIOGET_PANEL_SIZE:
+		panel_size[0] = lcdc_dev->screen->mode.xres;
+		panel_size[1] = lcdc_dev->screen->mode.yres;
+		if (copy_to_user(argp, panel_size, 8))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_COLOR_KEY_CFG:
+		if (copy_from_user(&clr_key_cfg, argp,
+				   sizeof(struct color_key_cfg)))
+			return -EFAULT;
+		rk3288_lcdc_clr_key_cfg(dev_drv);
+		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
+			    clr_key_cfg.win0_color_key_cfg);
+		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
+			    clr_key_cfg.win1_color_key_cfg);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int rk3288_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
+{
+	u32 reg;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	if (dev_drv->suspend_flag)
+		return 0;
+	
+	dev_drv->suspend_flag = 1;
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+	
+	for (reg = MMU_DTE_ADDR; reg <= MMU_AUTO_GATING; reg +=4)
+			lcdc_readl(lcdc_dev, reg);
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLANK_EN,
+					v_DSP_BLANK_EN(1));
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_FS_INTR_CLR | m_LINE_FLAG_INTR_CLR,
+					v_FS_INTR_CLR(1) | v_LINE_FLAG_INTR_CLR(1));	
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_OUT_ZERO,
+			     		v_DSP_OUT_ZERO(1));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
+			    		v_STANDBY_EN(1));
+		lcdc_cfg_done(lcdc_dev);
+
+                if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	rk3288_lcdc_clk_disable(lcdc_dev);
+	rk_disp_pwr_disable(dev_drv);
+	return 0;
+}
+
+static int rk3288_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (!dev_drv->suspend_flag)
+		return 0;
+	rk_disp_pwr_enable(dev_drv);
+	dev_drv->suspend_flag = 0;
+
+	if (lcdc_dev->atv_layer_cnt) {
+		rk3288_lcdc_clk_enable(lcdc_dev);
+		rk3288_lcdc_reg_restore(lcdc_dev);
+
+		spin_lock(&lcdc_dev->reg_lock);
+		rk3288_lcdc_set_lut(dev_drv);
+
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(0));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
+			     v_STANDBY_EN(0));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLANK_EN,
+					v_DSP_BLANK_EN(0));	
+		lcdc_cfg_done(lcdc_dev);
+
+                if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_activate(dev_drv->dev);
+		}
+
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+
+	return 0;
+}
+
+static int rk3288_lcdc_blank(struct rk_lcdc_driver *dev_drv,
+			     int win_id, int blank_mode)
+{
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		rk3288_lcdc_early_resume(dev_drv);
+		break;
+	case FB_BLANK_NORMAL:	
+		rk3288_lcdc_early_suspend(dev_drv);
+		break;
+	default:
+		rk3288_lcdc_early_suspend(dev_drv);
+		break;
+	}
+
+	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
+
+	return 0;
+}
+
+static int rk3288_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
+                                           int win_id, int area_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+        u32 win_ctrl = 0;
+        u32 area_status = 0;
+
+        switch (win_id) {
+        case 0:
+                win_ctrl = lcdc_readl(lcdc_dev, WIN0_CTRL0);
+                area_status = win_ctrl & m_WIN0_EN;
+                break;
+        case 1:
+                win_ctrl = lcdc_readl(lcdc_dev, WIN1_CTRL0);
+                area_status = win_ctrl & m_WIN1_EN;
+                break;
+        case 2:
+                win_ctrl = lcdc_readl(lcdc_dev, WIN2_CTRL0);
+                if (area_id == 0)
+                        area_status = win_ctrl & m_WIN2_MST0_EN;
+                if (area_id == 1)
+                        area_status = win_ctrl & m_WIN2_MST1_EN;
+                if (area_id == 2)
+                        area_status = win_ctrl & m_WIN2_MST2_EN;
+                if (area_id == 3)
+                        area_status = win_ctrl & m_WIN2_MST3_EN;
+                break;
+        case 3:
+                win_ctrl = lcdc_readl(lcdc_dev, WIN3_CTRL0);
+                if (area_id == 0)
+                        area_status = win_ctrl & m_WIN3_MST0_EN;
+                if (area_id == 1)
+                        area_status = win_ctrl & m_WIN3_MST1_EN;
+                if (area_id == 2)
+                        area_status = win_ctrl & m_WIN3_MST2_EN;
+                if (area_id == 3)
+                        area_status = win_ctrl & m_WIN3_MST3_EN;
+                break;
+        case 4:
+                win_ctrl = lcdc_readl(lcdc_dev, HWC_CTRL0);
+                area_status = win_ctrl & m_HWC_EN;
+                break;
+        default:
+                pr_err("!!!%s,win[%d]area[%d],unsupport!!!\n",__func__,win_id,area_id);
+                break;
+        }
+	return area_status;
+}
+
+static int rk3288_lcdc_get_area_num(struct rk_lcdc_driver *dev_drv,
+				           unsigned int *area_support)
+{
+        area_support[0] = 1;
+        area_support[1] = 1;
+        area_support[2] = 4;
+        area_support[3] = 4;
+
+        return 0;
+}
+
+/*overlay will be do at regupdate*/
+static int rk3288_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	int i,ovl;
+	unsigned int mask, val;
+	int z_order_num=0;
+	int layer0_sel,layer1_sel,layer2_sel,layer3_sel;
+	if(swap == 0){
+		for(i=0;i<4;i++){
+			win = dev_drv->win[i];
+			if(win->state == 1){
+				z_order_num++;
+			}	
+		}
+		for(i=0;i<4;i++){
+			win = dev_drv->win[i];
+			if(win->state == 0)
+				win->z_order = z_order_num++;
+			switch(win->z_order){
+			case 0:
+				layer0_sel = win->id;
+				break;
+			case 1:
+				layer1_sel = win->id;
+				break;
+			case 2:
+				layer2_sel = win->id;
+				break;
+			case 3:
+				layer3_sel = win->id;
+				break;
+			default:
+				break;
+			}
+		}
+	}else{
+		layer0_sel = swap %10;;
+		layer1_sel = swap /10 % 10;
+		layer2_sel = swap / 100 %10;
+		layer3_sel = swap / 1000;
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on){
+		if(set){
+			mask = m_DSP_LAYER0_SEL | m_DSP_LAYER1_SEL |
+				m_DSP_LAYER2_SEL | m_DSP_LAYER3_SEL;
+			val  = v_DSP_LAYER0_SEL(layer0_sel) |
+				v_DSP_LAYER1_SEL(layer1_sel) |
+				v_DSP_LAYER2_SEL(layer2_sel) |
+				v_DSP_LAYER3_SEL(layer3_sel);
+			lcdc_msk_reg(lcdc_dev,DSP_CTRL1,mask,val);
+		}else{
+			layer0_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1, m_DSP_LAYER0_SEL);
+			layer1_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1, m_DSP_LAYER1_SEL);
+			layer2_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1, m_DSP_LAYER2_SEL);
+			layer3_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1, m_DSP_LAYER3_SEL);
+			ovl = layer3_sel*1000 + layer2_sel*100 + layer1_sel *10 + layer0_sel;
+		}
+	}else{
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+static ssize_t rk3288_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
+					 char *buf, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+							   struct
+							   lcdc_device,
+							   driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 hsync_len = screen->mode.hsync_len;
+	u16 left_margin = screen->mode.left_margin;
+	u16 vsync_len = screen->mode.vsync_len;
+	u16 upper_margin = screen->mode.upper_margin;
+	u32 h_pw_bp = hsync_len + left_margin;
+	u32 v_pw_bp = vsync_len + upper_margin;
+	u32 fmt_id;
+	char format_w0[9] = "NULL";
+	char format_w1[9] = "NULL";
+	char format_w2[9] = "NULL";
+	char format_w3[9] = "NULL";	
+	u32 win_ctrl,zorder,vir_info,act_info,dsp_info,dsp_st,y_factor,uv_factor;
+	u8 layer0_sel,layer1_sel,layer2_sel,layer3_sel;
+	u8 w0_state,w1_state,w2_state,w3_state;
+	u8 w2_0_state,w2_1_state,w2_2_state,w2_3_state;
+	u8 w3_0_state,w3_1_state,w3_2_state,w3_3_state;
+
+	u32 w0_vir_y,w0_vir_uv,w0_act_x,w0_act_y,w0_dsp_x,w0_dsp_y,w0_st_x=h_pw_bp,w0_st_y=v_pw_bp;
+	u32 w1_vir_y,w1_vir_uv,w1_act_x,w1_act_y,w1_dsp_x,w1_dsp_y,w1_st_x=h_pw_bp,w1_st_y=v_pw_bp;
+	u32 w0_y_h_fac,w0_y_v_fac,w0_uv_h_fac,w0_uv_v_fac;
+	u32 w1_y_h_fac,w1_y_v_fac,w1_uv_h_fac,w1_uv_v_fac;
+
+	u32 w2_0_vir_y,w2_1_vir_y,w2_2_vir_y,w2_3_vir_y;
+	u32 w2_0_dsp_x,w2_1_dsp_x,w2_2_dsp_x,w2_3_dsp_x;
+	u32 w2_0_dsp_y,w2_1_dsp_y,w2_2_dsp_y,w2_3_dsp_y;
+	u32 w2_0_st_x=h_pw_bp,w2_1_st_x=h_pw_bp,w2_2_st_x=h_pw_bp,w2_3_st_x=h_pw_bp;
+	u32 w2_0_st_y=v_pw_bp,w2_1_st_y=v_pw_bp,w2_2_st_y=v_pw_bp,w2_3_st_y=v_pw_bp;
+
+	u32 w3_0_vir_y,w3_1_vir_y,w3_2_vir_y,w3_3_vir_y;
+	u32 w3_0_dsp_x,w3_1_dsp_x,w3_2_dsp_x,w3_3_dsp_x;
+	u32 w3_0_dsp_y,w3_1_dsp_y,w3_2_dsp_y,w3_3_dsp_y;
+	u32 w3_0_st_x=h_pw_bp,w3_1_st_x=h_pw_bp,w3_2_st_x=h_pw_bp,w3_3_st_x=h_pw_bp;
+	u32 w3_0_st_y=v_pw_bp,w3_1_st_y=v_pw_bp,w3_2_st_y=v_pw_bp,w3_3_st_y=v_pw_bp;
+	u32 dclk_freq;
+
+	dclk_freq = screen->mode.pixclock;
+	/*rk3288_lcdc_reg_dump(dev_drv);*/
+
+	spin_lock(&lcdc_dev->reg_lock);		
+	if (lcdc_dev->clk_on) {
+		zorder = lcdc_readl(lcdc_dev, DSP_CTRL1);
+		layer0_sel = (zorder & m_DSP_LAYER0_SEL)>>8;
+		layer1_sel = (zorder & m_DSP_LAYER1_SEL)>>10;
+		layer2_sel = (zorder & m_DSP_LAYER2_SEL)>>12;
+		layer3_sel = (zorder & m_DSP_LAYER3_SEL)>>14;
+		/*WIN0*/
+		win_ctrl = lcdc_readl(lcdc_dev, WIN0_CTRL0);
+		w0_state = win_ctrl & m_WIN0_EN;
+		fmt_id = (win_ctrl & m_WIN0_DATA_FMT)>>1;
+		switch (fmt_id) {
+		case 0:
+			strcpy(format_w0, "ARGB888");
+			break;
+		case 1:
+			strcpy(format_w0, "RGB888");
+			break;
+		case 2:
+			strcpy(format_w0, "RGB565");
+			break;
+		case 4:
+			strcpy(format_w0, "YCbCr420");
+			break;
+		case 5:
+			strcpy(format_w0, "YCbCr422");
+			break;
+		case 6:
+			strcpy(format_w0, "YCbCr444");
+			break;
+		default:
+			strcpy(format_w0, "invalid\n");
+			break;
+		}
+		vir_info = lcdc_readl(lcdc_dev,WIN0_VIR);
+		act_info = lcdc_readl(lcdc_dev,WIN0_ACT_INFO);
+		dsp_info = lcdc_readl(lcdc_dev,WIN0_DSP_INFO);
+		dsp_st = lcdc_readl(lcdc_dev,WIN0_DSP_ST);
+		y_factor = lcdc_readl(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
+		uv_factor = lcdc_readl(lcdc_dev,WIN0_SCL_FACTOR_CBR);
+		w0_vir_y = vir_info & m_WIN0_VIR_STRIDE;
+		w0_vir_uv = (vir_info & m_WIN0_VIR_STRIDE_UV)>>16;
+		w0_act_x = (act_info & m_WIN0_ACT_WIDTH)+1;
+		w0_act_y = ((act_info & m_WIN0_ACT_HEIGHT)>>16)+1;
+		w0_dsp_x = (dsp_info & m_WIN0_DSP_WIDTH)+1;
+		w0_dsp_y = ((dsp_info & m_WIN0_DSP_HEIGHT)>>16)+1;
+		if (w0_state) {
+			w0_st_x = dsp_st & m_WIN0_DSP_XST;
+			w0_st_y = (dsp_st & m_WIN0_DSP_YST)>>16;
+		}
+		w0_y_h_fac = y_factor & m_WIN0_HS_FACTOR_YRGB;
+		w0_y_v_fac = (y_factor & m_WIN0_VS_FACTOR_YRGB)>>16;
+		w0_uv_h_fac = uv_factor & m_WIN0_HS_FACTOR_CBR;
+		w0_uv_v_fac = (uv_factor & m_WIN0_VS_FACTOR_CBR)>>16;
+
+		/*WIN1*/
+		win_ctrl = lcdc_readl(lcdc_dev, WIN1_CTRL0);
+		w1_state = win_ctrl & m_WIN1_EN;
+		fmt_id = (win_ctrl & m_WIN1_DATA_FMT)>>1;
+		switch (fmt_id) {
+		case 0:
+			strcpy(format_w1, "ARGB888");
+			break;
+		case 1:
+			strcpy(format_w1, "RGB888");
+			break;
+		case 2:
+			strcpy(format_w1, "RGB565");
+			break;
+		case 4:
+			strcpy(format_w1, "YCbCr420");
+			break;
+		case 5:
+			strcpy(format_w1, "YCbCr422");
+			break;
+		case 6:
+			strcpy(format_w1, "YCbCr444");
+			break;
+		default:
+			strcpy(format_w1, "invalid\n");
+			break;
+		}
+		vir_info = lcdc_readl(lcdc_dev,WIN1_VIR);
+		act_info = lcdc_readl(lcdc_dev,WIN1_ACT_INFO);
+		dsp_info = lcdc_readl(lcdc_dev,WIN1_DSP_INFO);
+		dsp_st = lcdc_readl(lcdc_dev,WIN1_DSP_ST);
+		y_factor = lcdc_readl(lcdc_dev,WIN1_SCL_FACTOR_YRGB);
+		uv_factor = lcdc_readl(lcdc_dev,WIN1_SCL_FACTOR_CBR);
+		w1_vir_y = vir_info & m_WIN1_VIR_STRIDE;
+		w1_vir_uv = (vir_info & m_WIN1_VIR_STRIDE_UV)>>16;
+		w1_act_x = (act_info & m_WIN1_ACT_WIDTH)+1;
+		w1_act_y = ((act_info & m_WIN1_ACT_HEIGHT)>>16)+1;
+		w1_dsp_x = (dsp_info & m_WIN1_DSP_WIDTH)+1;
+		w1_dsp_y =((dsp_info & m_WIN1_DSP_HEIGHT)>>16)+1;
+		if (w1_state) {
+			w1_st_x = dsp_st & m_WIN1_DSP_XST;
+			w1_st_y = (dsp_st & m_WIN1_DSP_YST)>>16;
+		}
+		w1_y_h_fac = y_factor & m_WIN1_HS_FACTOR_YRGB;
+		w1_y_v_fac = (y_factor & m_WIN1_VS_FACTOR_YRGB)>>16;
+		w1_uv_h_fac = uv_factor & m_WIN1_HS_FACTOR_CBR;
+		w1_uv_v_fac = (uv_factor & m_WIN1_VS_FACTOR_CBR)>>16;
+		/*WIN2*/
+		win_ctrl = lcdc_readl(lcdc_dev, WIN2_CTRL0);
+		w2_state = win_ctrl & m_WIN2_EN;
+		w2_0_state = (win_ctrl & m_WIN2_MST0_EN)>>4;
+		w2_1_state = (win_ctrl & m_WIN2_MST1_EN)>>5;
+		w2_2_state = (win_ctrl & m_WIN2_MST2_EN)>>6;
+		w2_3_state = (win_ctrl & m_WIN2_MST3_EN)>>7;	
+		vir_info = lcdc_readl(lcdc_dev,WIN2_VIR0_1);
+		w2_0_vir_y = vir_info & m_WIN2_VIR_STRIDE0;
+		w2_1_vir_y = (vir_info & m_WIN2_VIR_STRIDE1)>>16;
+		vir_info = lcdc_readl(lcdc_dev,WIN2_VIR2_3);
+		w2_2_vir_y = vir_info & m_WIN2_VIR_STRIDE2;
+		w2_3_vir_y = (vir_info & m_WIN2_VIR_STRIDE3)>>16;			
+		fmt_id = (win_ctrl & m_WIN2_DATA_FMT)>>1;
+		switch (fmt_id) {
+		case 0:
+			strcpy(format_w2, "ARGB888");
+			break;
+		case 1:
+			strcpy(format_w2, "RGB888");
+			break;
+		case 2:
+			strcpy(format_w2, "RGB565");
+			break;
+                case 4:
+                        strcpy(format_w2,"8bpp");
+                        break;
+                case 5:
+                        strcpy(format_w2,"4bpp");
+                        break;
+                case 6:
+                        strcpy(format_w2,"2bpp");
+                        break;
+                case 7:
+                        strcpy(format_w2,"1bpp");
+                        break;
+		default:
+			strcpy(format_w2, "invalid\n");
+			break;
+		} 
+		dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO0);
+		dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST0);
+		w2_0_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH0)+1;
+		w2_0_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT0)>>16)+1;
+		if (w2_0_state) {
+			w2_0_st_x = dsp_st & m_WIN2_DSP_XST0;
+			w2_0_st_y = (dsp_st & m_WIN2_DSP_YST0)>>16;
+		}
+		dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO1);
+		dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST1);
+		w2_1_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH1)+1;
+		w2_1_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT1)>>16)+1;
+		if (w2_1_state) {
+			w2_1_st_x = dsp_st & m_WIN2_DSP_XST1;
+			w2_1_st_y = (dsp_st & m_WIN2_DSP_YST1)>>16;
+		}
+		dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO2);
+		dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST2);
+		w2_2_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH2)+1;
+		w2_2_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT2)>>16)+1;
+		if (w2_2_state) {
+			w2_2_st_x = dsp_st & m_WIN2_DSP_XST2;
+			w2_2_st_y = (dsp_st & m_WIN2_DSP_YST2)>>16;
+		}
+		dsp_info = lcdc_readl(lcdc_dev,WIN2_DSP_INFO3);
+		dsp_st = lcdc_readl(lcdc_dev,WIN2_DSP_ST3);
+		w2_3_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH3)+1;
+		w2_3_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT3)>>16)+1;
+		if (w2_3_state) {
+			w2_3_st_x = dsp_st & m_WIN2_DSP_XST3;
+			w2_3_st_y = (dsp_st & m_WIN2_DSP_YST3)>>16;
+		}
+
+		/*WIN3*/
+		win_ctrl = lcdc_readl(lcdc_dev, WIN3_CTRL0);
+		w3_state = win_ctrl & m_WIN3_EN;
+		w3_0_state = (win_ctrl & m_WIN3_MST0_EN)>>4;
+		w3_1_state = (win_ctrl & m_WIN3_MST1_EN)>>5;
+		w3_2_state = (win_ctrl & m_WIN3_MST2_EN)>>6;
+		w3_3_state = (win_ctrl & m_WIN3_MST3_EN)>>7; 
+		vir_info = lcdc_readl(lcdc_dev,WIN3_VIR0_1);
+		w3_0_vir_y = vir_info & m_WIN3_VIR_STRIDE0;
+		w3_1_vir_y = (vir_info & m_WIN3_VIR_STRIDE1)>>16;
+		vir_info = lcdc_readl(lcdc_dev,WIN3_VIR2_3);
+		w3_2_vir_y = vir_info & m_WIN3_VIR_STRIDE2;
+		w3_3_vir_y = (vir_info & m_WIN3_VIR_STRIDE3)>>16;			
+		fmt_id = (win_ctrl & m_WIN3_DATA_FMT)>>1;
+		switch (fmt_id) {
+		case 0:
+			strcpy(format_w3, "ARGB888");
+			break;
+		case 1:
+			strcpy(format_w3, "RGB888");
+			break;
+		case 2:
+			strcpy(format_w3, "RGB565");
+			break;
+		case 4:
+			strcpy(format_w3,"8bpp");
+			break;
+		case 5:
+			strcpy(format_w3,"4bpp");
+			break;
+		case 6:
+			strcpy(format_w3,"2bpp");
+			break;
+		case 7:
+			strcpy(format_w3,"1bpp");
+			break;
+		default:
+			strcpy(format_w3, "invalid");
+			break;
+		} 
+		dsp_info = lcdc_readl(lcdc_dev,WIN3_DSP_INFO0);
+		dsp_st = lcdc_readl(lcdc_dev,WIN3_DSP_ST0);
+		w3_0_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH0)+1;
+		w3_0_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT0)>>16)+1;
+		if (w3_0_state) {
+			w3_0_st_x = dsp_st & m_WIN3_DSP_XST0;
+			w3_0_st_y = (dsp_st & m_WIN3_DSP_YST0)>>16;
+		}
+		
+		dsp_info = lcdc_readl(lcdc_dev,WIN3_DSP_INFO1);
+		dsp_st = lcdc_readl(lcdc_dev,WIN3_DSP_ST1);
+		w3_1_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH1)+1;
+		w3_1_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT1)>>16)+1;
+		if (w3_1_state) {
+			w3_1_st_x = dsp_st & m_WIN3_DSP_XST1;
+			w3_1_st_y = (dsp_st & m_WIN3_DSP_YST1)>>16;
+		}
+		
+		dsp_info = lcdc_readl(lcdc_dev,WIN3_DSP_INFO2);
+		dsp_st = lcdc_readl(lcdc_dev,WIN3_DSP_ST2);
+		w3_2_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH2)+1;
+		w3_2_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT2)>>16)+1;
+		if (w3_2_state) {
+			w3_2_st_x = dsp_st & m_WIN3_DSP_XST2;
+			w3_2_st_y = (dsp_st & m_WIN3_DSP_YST2)>>16;
+		}
+		
+		dsp_info = lcdc_readl(lcdc_dev,WIN3_DSP_INFO3);
+		dsp_st = lcdc_readl(lcdc_dev,WIN3_DSP_ST3);
+		w3_3_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH3)+1;
+		w3_3_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT3)>>16)+1;
+		if (w3_3_state) {
+			w3_3_st_x = dsp_st & m_WIN3_DSP_XST3;
+			w3_3_st_y = (dsp_st & m_WIN3_DSP_YST3)>>16;
+		}
+
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return snprintf(buf, PAGE_SIZE,
+			"z-order:\n"
+			"  layer3_sel_win[%d]\n"
+			"  layer2_sel_win[%d]\n"
+			"  layer1_sel_win[%d]\n"
+			"  layer0_sel_win[%d]\n"
+			"win0:\n"
+			"  state:%d, "
+			"  fmt:%s, "
+			"  y_vir:%d, "
+			"  uv_vir:%d\n"
+			"  xact:%4d, "
+			"  yact:%4d, "
+			"  dsp_x:%4d, "
+			"  dsp_y:%4d, "
+			"  x_st:%4d, "
+			"  y_st:%4d\n"
+			"  y_h_fac:%8d, "
+			"  y_v_fac:%8d, "
+			"  uv_h_fac:%8d, "
+			"  uv_v_fac:%8d\n"
+			"  y_addr: 0x%08x, "
+			"  uv_addr:0x%08x\n"
+			"win1:\n"
+			"  state:%d, "
+			"  fmt:%s, "
+			"  y_vir:%d, "
+			"  uv_vir:%d\n"
+			"  xact:%4d, "
+			"  yact:%4d, "
+			"  dsp_x:%4d, "
+			"  dsp_y:%4d, "
+			"  x_st:%4d, "
+			"  y_st:%4d\n"
+			"  y_h_fac:%8d, "
+			"  y_v_fac:%8d, "
+			"  uv_h_fac:%8d, "
+			"  uv_v_fac:%8d\n"
+			"  y_addr: 0x%08x, "
+			"  uv_addr:0x%08x\n"	
+			"win2:\n"
+			"  state:%d\n"
+			"  fmt:%s\n"
+			"  area0:"
+			"  state:%d,"
+			"  y_vir:%4d,"
+			"  dsp_x:%4d,"
+			"  dsp_y:%4d,"
+			"  x_st:%4d,"
+			"  y_st:%4d,"
+			"  addr:0x%08x\n"
+			"  area1:"
+			"  state:%d,"
+			"  y_vir:%4d,"
+			"  dsp_x:%4d,"
+			"  dsp_y:%4d,"
+			"  x_st:%4d,"
+			"  y_st:%4d,"
+			"  addr:0x%08x\n"
+			"  area2:"
+			"  state:%d,"
+			"  y_vir:%4d,"
+			"  dsp_x:%4d,"
+			"  dsp_y:%4d,"
+			"  x_st:%4d,"
+			"  y_st:%4d,"
+			"  addr:0x%08x\n"
+			"  area3:"
+			"  state:%d,"
+			"  y_vir:%4d,"
+			"  dsp_x:%4d,"
+			"  dsp_y:%4d,"
+			"  x_st:%4d,"
+			"  y_st:%4d,"
+			"  addr:0x%08x\n"
+			"win3:\n"
+			"  state:%d\n"
+			"  fmt:%s\n"
+			"  area0:"
+			"  state:%d,"
+			"  y_vir:%4d,"
+			"  dsp_x:%4d,"
+			"  dsp_y:%4d,"
+			"  x_st:%4d,"
+			"  y_st:%4d,"
+			"  addr:0x%08x\n"
+			"  area1:"
+			"  state:%d,"
+			"  y_vir:%4d,"
+			"  dsp_x:%4d,"
+			"  dsp_y:%4d,"
+			"  x_st:%4d,"
+			"  y_st:%4d "
+			"  addr:0x%08x\n"
+			"  area2:"
+			"  state:%d,"
+			"  y_vir:%4d,"
+			"  dsp_x:%4d,"
+			"  dsp_y:%4d,"
+			"  x_st:%4d,"
+			"  y_st:%4d,"
+			"  addr:0x%08x\n"
+			"  area3:"
+			"  state:%d,"
+			"  y_vir:%4d,"
+			"  dsp_x:%4d,"
+			"  dsp_y:%4d,"
+			"  x_st:%4d,"
+			"  y_st:%4d,"
+			"  addr:0x%08x\n",
+			layer3_sel,layer2_sel,layer1_sel,layer0_sel,
+			w0_state,format_w0,w0_vir_y,w0_vir_uv,w0_act_x,w0_act_y,
+			w0_dsp_x,w0_dsp_y,w0_st_x-h_pw_bp,w0_st_y-v_pw_bp,w0_y_h_fac,w0_y_v_fac,w0_uv_h_fac,
+			w0_uv_v_fac,lcdc_readl(lcdc_dev, WIN0_YRGB_MST),
+			lcdc_readl(lcdc_dev, WIN0_CBR_MST),
+
+			w1_state,format_w1,w1_vir_y,w1_vir_uv,w1_act_x,w1_act_y,
+			w1_dsp_x,w1_dsp_y,w1_st_x-h_pw_bp,w1_st_y-v_pw_bp,w1_y_h_fac,w1_y_v_fac,w1_uv_h_fac,
+			w1_uv_v_fac,lcdc_readl(lcdc_dev, WIN1_YRGB_MST),
+			lcdc_readl(lcdc_dev, WIN1_CBR_MST),			
+
+			w2_state,format_w2,
+			w2_0_state,w2_0_vir_y,w2_0_dsp_x,w2_0_dsp_y,
+			w2_0_st_x-h_pw_bp,w2_0_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN2_MST0),
+
+			w2_1_state,w2_1_vir_y,w2_1_dsp_x,w2_1_dsp_y,
+			w2_1_st_x-h_pw_bp,w2_1_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN2_MST1),
+
+			w2_2_state,w2_2_vir_y,w2_2_dsp_x,w2_2_dsp_y,
+			w2_2_st_x-h_pw_bp,w2_2_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN2_MST2),
+
+			w2_3_state,w2_3_vir_y,w2_3_dsp_x,w2_3_dsp_y,
+			w2_3_st_x-h_pw_bp,w2_3_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN2_MST3),
+			
+			w3_state,format_w3,
+			w3_0_state,w3_0_vir_y,w3_0_dsp_x,w3_0_dsp_y,
+			w3_0_st_x-h_pw_bp,w3_0_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN3_MST0),
+
+			w3_1_state,w3_1_vir_y,w3_1_dsp_x,w3_1_dsp_y,
+			w3_1_st_x-h_pw_bp,w3_1_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN3_MST1),
+
+			w3_2_state,w3_2_vir_y,w3_2_dsp_x,w3_2_dsp_y,
+			w3_2_st_x-h_pw_bp,w3_2_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN3_MST2),
+
+			w3_3_state,w3_3_vir_y,w3_3_dsp_x,w3_3_dsp_y,
+			w3_3_st_x-h_pw_bp,w3_3_st_y-v_pw_bp,lcdc_readl(lcdc_dev, WIN3_MST3)
+	);
+			
+}
+
+static int rk3288_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+	u32 pixclock;
+	u32 x_total, y_total;
+	if (set) {
+		if (fps == 0) {
+			dev_info(dev_drv->dev, "unsupport set fps=0\n");
+			return 0;
+		}
+		ft = div_u64(1000000000000llu, fps);
+		x_total =
+		    screen->mode.upper_margin + screen->mode.lower_margin +
+		    screen->mode.yres + screen->mode.vsync_len;
+		y_total =
+		    screen->mode.left_margin + screen->mode.right_margin +
+		    screen->mode.xres + screen->mode.hsync_len;
+		dev_drv->pixclock = div_u64(ft, x_total * y_total);
+		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+	}
+
+	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	dev_drv->pixclock = lcdc_dev->pixclock = pixclock;
+	fps = rk_fb_calc_fps(lcdc_dev->screen, pixclock);
+	screen->ft = 1000 / fps;	/*one frame time in ms */
+
+	if (set)
+		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
+			 clk_get_rate(lcdc_dev->dclk), fps);
+
+	return fps;
+}
+
+static int rk3288_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
+{
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (order == FB_DEFAULT_ORDER)
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3;
+	dev_drv->fb3_win_id = order / 1000;
+	dev_drv->fb2_win_id = (order / 100) % 10;
+	dev_drv->fb1_win_id = (order / 10) % 10;
+	dev_drv->fb0_win_id = order % 10;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return 0;
+}
+
+static int rk3288_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
+				  const char *id)
+{
+	int win_id = 0;
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (!strcmp(id, "fb0") || !strcmp(id, "fb4"))
+		win_id = dev_drv->fb0_win_id;
+	else if (!strcmp(id, "fb1") || !strcmp(id, "fb5"))
+		win_id = dev_drv->fb1_win_id;
+	else if (!strcmp(id, "fb2") || !strcmp(id, "fb6"))
+		win_id = dev_drv->fb2_win_id;
+	else if (!strcmp(id, "fb3") || !strcmp(id, "fb7"))
+		win_id = dev_drv->fb3_win_id;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return win_id;
+}
+
+static int rk3288_set_dsp_lut(struct rk_lcdc_driver *dev_drv, int *lut)
+{
+	int i,j;
+	int __iomem *c;
+	int v, r, g, b;
+	int ret = 0;
+
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN, v_DSP_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	mdelay(25);
+	if (dev_drv->cur_screen->dsp_lut) {
+		for (i = 0; i < 256; i++) {
+			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
+			c = lcdc_dev->dsp_lut_addr_base + (i << 2);
+			b = (v & 0xff) << 2;
+			g = (v & 0xff00) << 4;
+			r = (v & 0xff0000) << 6;
+			v = r + g + b;
+			for (j = 0; j < 4; j++) {
+				writel_relaxed(v, c);
+				v += (1 + (1 << 10) + (1 << 20)) ;
+				c++;
+			}
+		}
+	} else {
+		dev_err(dev_drv->dev, "no buffer to backup lut data!\n");
+		ret = -1;
+	}
+	
+	do{
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN, v_DSP_LUT_EN(1));
+		lcdc_cfg_done(lcdc_dev);
+	}while(!lcdc_read_bit(lcdc_dev,DSP_CTRL1,m_DSP_LUT_EN));
+	return ret;
+}
+
+static int rk3288_lcdc_config_done(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int i;
+	unsigned int mask, val;
+	struct rk_lcdc_win *win = NULL;
+	struct fb_info *fb0 = rk_get_fb(0);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
+			     v_STANDBY_EN(lcdc_dev->standby));
+	for (i=0;i<4;i++) {
+		win = dev_drv->win[i];
+		if ((win->state == 0)&&(win->last_state == 1)) {
+			switch (win->id) {
+			case 0:
+				if (dev_drv->version == VOP_FULL_RK3288_V1_0)
+					lcdc_writel(lcdc_dev, WIN0_CTRL1, 0x0);
+				mask =  m_WIN0_EN;
+				val  =  v_WIN0_EN(0);
+				lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask,val);	
+				break;
+			case 1:
+				if (dev_drv->version == VOP_FULL_RK3288_V1_0)
+					lcdc_writel(lcdc_dev, WIN1_CTRL1, 0x0);
+				mask =  m_WIN1_EN;
+				val  =  v_WIN1_EN(0);
+				lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask,val);		
+				break;
+			case 2:
+				mask =  m_WIN2_EN | m_WIN2_MST0_EN | m_WIN2_MST1_EN |
+					m_WIN2_MST2_EN | m_WIN2_MST3_EN;
+				val  =  v_WIN2_EN(0) | v_WIN2_MST0_EN(0) | v_WIN2_MST1_EN(0) |
+					v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
+				lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask,val);			
+				lcdc_writel(lcdc_dev,WIN2_DSP_INFO0,0);
+				lcdc_writel(lcdc_dev,WIN2_DSP_INFO1,0);
+				lcdc_writel(lcdc_dev,WIN2_DSP_INFO2,0);
+				lcdc_writel(lcdc_dev,WIN2_DSP_INFO3,0);
+				lcdc_writel(lcdc_dev,WIN2_MST0, fb0->fix.smem_start);
+				lcdc_writel(lcdc_dev,WIN2_MST1, fb0->fix.smem_start);
+				lcdc_writel(lcdc_dev,WIN2_MST2, fb0->fix.smem_start);
+				lcdc_writel(lcdc_dev,WIN2_MST3, fb0->fix.smem_start);
+				break;
+			case 3:
+				mask =  m_WIN3_EN | m_WIN3_MST0_EN | m_WIN3_MST1_EN |
+					m_WIN3_MST2_EN | m_WIN3_MST3_EN;
+				val  =  v_WIN3_EN(0) | v_WIN3_MST0_EN(0) |  v_WIN3_MST1_EN(0) |
+					v_WIN3_MST2_EN(0) | v_WIN3_MST3_EN(0);
+				lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask,val);
+				lcdc_writel(lcdc_dev,WIN3_DSP_INFO0,0);
+				lcdc_writel(lcdc_dev,WIN3_DSP_INFO1,0);
+				lcdc_writel(lcdc_dev,WIN3_DSP_INFO2,0);
+				lcdc_writel(lcdc_dev,WIN3_DSP_INFO3,0);
+				lcdc_writel(lcdc_dev,WIN3_MST0, fb0->fix.smem_start);
+				lcdc_writel(lcdc_dev,WIN3_MST1, fb0->fix.smem_start);
+				lcdc_writel(lcdc_dev,WIN3_MST2, fb0->fix.smem_start);
+				lcdc_writel(lcdc_dev,WIN3_MST3, fb0->fix.smem_start);
+				break;
+			default:
+				break;
+			}
+		}	
+		win->last_state = win->state;
+	}
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+
+static int rk3288_lcdc_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	spin_lock(&lcdc_dev->reg_lock);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_EN,
+		     v_DIRECT_PATH_EN(open));
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk3288_lcdc_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+					struct lcdc_device, driver);
+	spin_lock(&lcdc_dev->reg_lock);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_DIRECT_PATCH_SEL,
+		     v_DIRECT_PATCH_SEL(win_id));
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+
+}
+
+static int rk3288_lcdc_dpi_status(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int ovl;
+	spin_lock(&lcdc_dev->reg_lock);
+	ovl = lcdc_read_bit(lcdc_dev, SYS_CTRL, m_DIRECT_PATH_EN);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return ovl;
+}
+static int rk3288_lcdc_set_irq_to_cpu(struct rk_lcdc_driver * dev_drv,int enable)
+{
+       struct lcdc_device *lcdc_dev =
+                                container_of(dev_drv,struct lcdc_device,driver);
+       if (enable)
+               enable_irq(lcdc_dev->irq);
+       else
+               disable_irq(lcdc_dev->irq);
+       return 0;
+}
+
+int rk3288_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 int_reg;
+	int ret;
+
+	if (lcdc_dev->clk_on &&(!dev_drv->suspend_flag)){
+		int_reg = lcdc_readl(lcdc_dev, INTR_CTRL0);
+		if (int_reg & m_LINE_FLAG_INTR_STS) {
+			lcdc_dev->driver.frame_time.last_framedone_t =
+					lcdc_dev->driver.frame_time.framedone_t;
+			lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
+			lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_LINE_FLAG_INTR_CLR,
+				     v_LINE_FLAG_INTR_CLR(1));
+			ret = RK_LF_STATUS_FC;
+		} else
+			ret = RK_LF_STATUS_FR;
+	} else {
+		ret = RK_LF_STATUS_NC;
+	}
+
+	return ret;
+}
+
+static int rk3288_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
+				    unsigned int dsp_addr[][4])
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
+		dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_YRGB_MST);
+		dsp_addr[2][0] = lcdc_readl(lcdc_dev, WIN2_MST0);
+		dsp_addr[2][1] = lcdc_readl(lcdc_dev, WIN2_MST1);
+		dsp_addr[2][2] = lcdc_readl(lcdc_dev, WIN2_MST2);
+		dsp_addr[2][3] = lcdc_readl(lcdc_dev, WIN2_MST3);
+		dsp_addr[3][0] = lcdc_readl(lcdc_dev, WIN3_MST0);
+		dsp_addr[3][1] = lcdc_readl(lcdc_dev, WIN3_MST1);
+		dsp_addr[3][2] = lcdc_readl(lcdc_dev, WIN3_MST2);
+		dsp_addr[3][3] = lcdc_readl(lcdc_dev, WIN3_MST3);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk3288_lcdc_set_dsp_cabc(struct rk_lcdc_driver *dev_drv,
+				    int mode, int calc, int up,
+				    int down, int global)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u32 total_pixel, calc_pixel, stage_up, stage_down;
+	u32 pixel_num, global_dn;
+	u32 mask = 0, val = 0;
+
+	if (dev_drv->version != VOP_FULL_RK3288_V1_1) {
+		pr_err("vop version:%x, not supoort cabc\n", dev_drv->version);
+		return 0;
+	}
+	if (!screen->cabc_lut) {
+		pr_err("screen cabc lut not config, so not open cabc\n");
+		return 0;
+	}
+	dev_drv->cabc_mode = mode;
+	if (!dev_drv->cabc_mode) {
+		spin_lock(&lcdc_dev->reg_lock);
+		if (lcdc_dev->clk_on) {
+			lcdc_msk_reg(lcdc_dev, CABC_CTRL0,
+				     m_CABC_HANDLE_EN | m_CABC_EN,
+				     v_CABC_EN(0) | v_CABC_HANDLE_EN(0));
+			lcdc_cfg_done(lcdc_dev);
+		}
+		pr_info("mode = 0, close cabc\n");
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+
+	total_pixel = screen->mode.xres * screen->mode.yres;
+	pixel_num = 1000 - calc;
+	calc_pixel = (total_pixel * pixel_num) / 1000;
+	stage_up = up;
+	stage_down = down;
+	global_dn = global;
+	pr_info("enable cabc:mode=%d, calc=%d, up=%d, down=%d, global=%d\n",
+		mode, calc, stage_up, stage_down, global_dn);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		mask = m_CABC_EN | m_CABC_HANDLE_EN | m_PWM_CONFIG_MODE |
+			m_CABC_CALC_PIXEL_NUM;
+		val = v_CABC_EN(1) | v_CABC_HANDLE_EN(1) |
+			v_PWM_CONFIG_MODE(STAGE_BY_STAGE) |
+			v_CABC_CALC_PIXEL_NUM(calc_pixel);
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL0, mask, val);
+
+		mask = m_CABC_LUT_EN | m_CABC_TOTAL_PIXEL_NUM;
+		val = v_CABC_LUT_EN(1) | v_CABC_TOTAL_PIXEL_NUM(total_pixel);
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL1, mask, val);
+
+		mask = m_CABC_STAGE_DOWN | m_CABC_STAGE_UP |
+			m_CABC_STAGE_MODE | m_MAX_SCALE_CFG_VALUE |
+			m_MAX_SCALE_CFG_ENABLE;
+		val = v_CABC_STAGE_DOWN(stage_down) |
+			v_CABC_STAGE_UP(stage_up) |
+			v_CABC_STAGE_MODE(0) | v_MAX_SCALE_CFG_VALUE(1) |
+			v_MAX_SCALE_CFG_ENABLE(0);
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL2, mask, val);
+
+		mask = m_CABC_GLOBAL_DN | m_CABC_GLOBAL_DN_LIMIT_EN;
+		val = v_CABC_GLOBAL_DN(global_dn) |
+			v_CABC_GLOBAL_DN_LIMIT_EN(1);
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL3, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+/*
+	a:[-30~0]:
+	    sin_hue = sin(a)*256 +0x100;
+	    cos_hue = cos(a)*256;
+	a:[0~30]
+	    sin_hue = sin(a)*256;
+	    cos_hue = cos(a)*256;
+*/
+static int rk3288_lcdc_get_bcsh_hue(struct rk_lcdc_driver *dev_drv,bcsh_hue_mode mode)
+{
+
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val;
+			
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		val = lcdc_readl(lcdc_dev, BCSH_H);
+		switch(mode){
+		case H_SIN:
+			val &= m_BCSH_SIN_HUE;
+			break;
+		case H_COS:
+			val &= m_BCSH_COS_HUE;
+			val >>= 16;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return val;
+}
+
+
+static int rk3288_lcdc_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,int sin_hue, int cos_hue)
+{
+
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		mask = m_BCSH_SIN_HUE | m_BCSH_COS_HUE;
+		val = v_BCSH_SIN_HUE(sin_hue) | v_BCSH_COS_HUE(cos_hue);
+		lcdc_msk_reg(lcdc_dev, BCSH_H, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}	
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static int rk3288_lcdc_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,bcsh_bcs_mode mode,int value)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on) {
+		switch (mode) {
+		case BRIGHTNESS:
+		/*from 0 to 255,typical is 128*/
+			if (value < 0x80)
+				value += 0x80;
+			else if (value >= 0x80)
+				value = value - 0x80;
+			mask =  m_BCSH_BRIGHTNESS;
+			val = v_BCSH_BRIGHTNESS(value);
+			break;
+		case CONTRAST:
+		/*from 0 to 510,typical is 256*/
+			mask =  m_BCSH_CONTRAST;
+			val =  v_BCSH_CONTRAST(value);
+			break;
+		case SAT_CON:
+		/*from 0 to 1015,typical is 256*/
+			mask = m_BCSH_SAT_CON;
+			val = v_BCSH_SAT_CON(value);
+			break;
+		default:
+			break;
+		}
+		lcdc_msk_reg(lcdc_dev, BCSH_BCS, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return val;
+}
+
+static int rk3288_lcdc_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv,bcsh_bcs_mode mode)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on) {
+		val = lcdc_readl(lcdc_dev, BCSH_BCS);
+		switch (mode) {
+		case BRIGHTNESS:
+			val &= m_BCSH_BRIGHTNESS;
+			if(val > 0x80)
+				val -= 0x80;
+			else
+				val += 0x80;
+			break;
+		case CONTRAST:
+			val &= m_BCSH_CONTRAST;
+			val >>= 8;
+			break;
+		case SAT_CON:
+			val &= m_BCSH_SAT_CON;
+			val >>= 20;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return val;
+}
+
+
+static int rk3288_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (open) {
+			lcdc_writel(lcdc_dev,BCSH_COLOR_BAR,0x1);
+			lcdc_writel(lcdc_dev,BCSH_BCS,0xd0010000);
+			lcdc_writel(lcdc_dev,BCSH_H,0x01000000);
+			dev_drv->bcsh.enable = 1;
+		} else {
+			mask = m_BCSH_EN;
+			val = v_BCSH_EN(0);
+			lcdc_msk_reg(lcdc_dev, BCSH_COLOR_BAR, mask, val);
+			dev_drv->bcsh.enable = 0;
+		}
+		if (dev_drv->version == VOP_FULL_RK3288_V1_1)
+			rk3288_lcdc_bcsh_path_sel(dev_drv);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk3288_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv,
+				     bool enable)
+{
+	if (!enable || !dev_drv->bcsh.enable) {
+		rk3288_lcdc_open_bcsh(dev_drv, false);
+		return 0;
+	}
+
+	if (dev_drv->bcsh.brightness <= 255 ||
+	    dev_drv->bcsh.contrast <= 510 ||
+	    dev_drv->bcsh.sat_con <= 1015 ||
+	    (dev_drv->bcsh.sin_hue <= 511 && dev_drv->bcsh.cos_hue <= 511)) {
+		rk3288_lcdc_open_bcsh(dev_drv, true);
+		if (dev_drv->bcsh.brightness <= 255)
+			rk3288_lcdc_set_bcsh_bcs(dev_drv, BRIGHTNESS,
+						 dev_drv->bcsh.brightness);
+		if (dev_drv->bcsh.contrast <= 510)
+			rk3288_lcdc_set_bcsh_bcs(dev_drv, CONTRAST,
+						 dev_drv->bcsh.contrast);
+		if (dev_drv->bcsh.sat_con <= 1015)
+			rk3288_lcdc_set_bcsh_bcs(dev_drv, SAT_CON,
+						 dev_drv->bcsh.sat_con);
+		if (dev_drv->bcsh.sin_hue <= 511 &&
+		    dev_drv->bcsh.cos_hue <= 511)
+			rk3288_lcdc_set_bcsh_hue(dev_drv,
+						 dev_drv->bcsh.sin_hue,
+						 dev_drv->bcsh.cos_hue);
+	}
+	return 0;
+}
+
+static int rk3288_lcdc_set_overscan(struct rk_lcdc_driver *dev_drv,
+				    struct overscan *overscan)
+{
+	struct lcdc_device *lcdc_dev =
+		container_of(dev_drv, struct lcdc_device, driver);
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	rk3288_lcdc_post_cfg(dev_drv);
+
+	return 0;
+}
+
+static struct rk_lcdc_win lcdc_win[] = {
+	[0] = {
+	       .name = "win0",
+	       .id = 0,
+	       .support_3d = false,
+	       },
+	[1] = {
+	       .name = "win1",
+	       .id = 1,
+	       .support_3d = false,
+	       },
+	[2] = {
+	       .name = "win2",
+	       .id = 2,
+	       .support_3d = false,
+	       },
+	[3] = {
+	       .name = "win3",
+	       .id = 3,
+	       .support_3d = false,
+	       },	       
+};
+
+static int rk3288_lcdc_extern_func(struct rk_lcdc_driver *dev_drv, int cmd)
+{
+	struct lcdc_device *lcdc_dev =
+		container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	if (unlikely(!vop_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, vop_dev->clk_on);
+		return 0;
+	}
+
+	switch (cmd) {
+	case SET_DSP_MIRROR:
+		mask = m_DSP_X_MIR_EN | m_DSP_Y_MIR_EN;
+		val = v_DSP_X_MIR_EN(screen->x_mirror) |
+		      v_DSP_Y_MIR_EN(screen->y_mirror);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+		pr_info("%s: xmirror: %d, ymirror: %d\n",
+			__func__, dev_drv->cur_screen->x_mirror,
+			dev_drv->cur_screen->y_mirror);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static struct rk_lcdc_drv_ops lcdc_drv_ops = {
+	.open 			= rk3288_lcdc_open,
+	.win_direct_en		= rk3288_lcdc_win_direct_en,
+	.load_screen 		= rk3288_load_screen,
+	.get_dspbuf_info	= rk3288_get_dspbuf_info,
+	.post_dspbuf		= rk3288_post_dspbuf,
+	.set_par 		= rk3288_lcdc_set_par,
+	.pan_display 		= rk3288_lcdc_pan_display,
+	.direct_set_addr 	= rk3288_lcdc_direct_set_win_addr,
+	.lcdc_reg_update	= rk3288_lcdc_reg_update,
+	.blank 			= rk3288_lcdc_blank,
+	.ioctl 			= rk3288_lcdc_ioctl,
+	.suspend 		= rk3288_lcdc_early_suspend,
+	.resume 		= rk3288_lcdc_early_resume,
+	.get_win_state 		= rk3288_lcdc_get_win_state,
+	.area_support_num = rk3288_lcdc_get_area_num,
+	.ovl_mgr 		= rk3288_lcdc_ovl_mgr,
+	.get_disp_info 		= rk3288_lcdc_get_disp_info,
+	.fps_mgr 		= rk3288_lcdc_fps_mgr,
+	.fb_get_win_id 		= rk3288_lcdc_get_win_id,
+	.fb_win_remap 		= rk3288_fb_win_remap,
+	.set_dsp_lut 		= rk3288_set_dsp_lut,
+	.poll_vblank 		= rk3288_lcdc_poll_vblank,
+	.dpi_open 		= rk3288_lcdc_dpi_open,
+	.dpi_win_sel 		= rk3288_lcdc_dpi_win_sel,
+	.dpi_status 		= rk3288_lcdc_dpi_status,
+	.get_dsp_addr 		= rk3288_lcdc_get_dsp_addr,
+	.set_dsp_cabc		= rk3288_lcdc_set_dsp_cabc,
+	.set_dsp_bcsh_hue 	= rk3288_lcdc_set_bcsh_hue,
+	.set_dsp_bcsh_bcs 	= rk3288_lcdc_set_bcsh_bcs,
+	.get_dsp_bcsh_hue 	= rk3288_lcdc_get_bcsh_hue,
+	.get_dsp_bcsh_bcs 	= rk3288_lcdc_get_bcsh_bcs,
+	.open_bcsh		= rk3288_lcdc_open_bcsh,
+	.dump_reg 		= rk3288_lcdc_reg_dump,
+	.cfg_done		= rk3288_lcdc_config_done,
+	.set_irq_to_cpu  	= rk3288_lcdc_set_irq_to_cpu,
+	.mmu_en    = rk3288_lcdc_mmu_en,
+	.set_overscan   	= rk3288_lcdc_set_overscan,
+
+};
+
+#ifdef LCDC_IRQ_DEBUG
+static int rk3288_lcdc_parse_irq(struct lcdc_device *lcdc_dev,unsigned int reg_val)
+{
+	if (reg_val & m_WIN0_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_WIN0_EMPTY_INTR_CLR,
+			     v_WIN0_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev,"win0 empty irq!");
+	}else if (reg_val & m_WIN1_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_WIN1_EMPTY_INTR_CLR,
+			     v_WIN1_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev,"win1 empty irq!");
+	}else if (reg_val & m_WIN2_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_WIN2_EMPTY_INTR_CLR,
+			     v_WIN2_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev,"win2 empty irq!");
+	}else if (reg_val & m_WIN3_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_WIN3_EMPTY_INTR_CLR,
+			     v_WIN3_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev,"win3 empty irq!");
+	}else if (reg_val & m_HWC_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_HWC_EMPTY_INTR_CLR,
+			     v_HWC_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev,"HWC empty irq!");
+	}else if (reg_val & m_POST_BUF_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_POST_BUF_EMPTY_INTR_CLR,
+			     v_POST_BUF_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev,"post buf empty irq!");
+	}else if (reg_val & m_PWM_GEN_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL1, m_PWM_GEN_INTR_CLR,
+			     v_PWM_GEN_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev,"PWM gen irq!");
+	}
+
+	return 0;
+}
+#endif
+
+static irqreturn_t rk3288_lcdc_isr(int irq, void *dev_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    (struct lcdc_device *)dev_id;
+	ktime_t timestamp = ktime_get();
+	u32 intr0_reg;
+
+	intr0_reg = lcdc_readl(lcdc_dev, INTR_CTRL0);
+
+	if(intr0_reg & m_FS_INTR_STS){
+		timestamp = ktime_get();
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_FS_INTR_CLR,
+			     v_FS_INTR_CLR(1));
+		/*if(lcdc_dev->driver.wait_fs){	*/
+		if (0) {
+			spin_lock(&(lcdc_dev->driver.cpl_lock));
+			complete(&(lcdc_dev->driver.frame_done));
+			spin_unlock(&(lcdc_dev->driver.cpl_lock));
+		}
+		lcdc_dev->driver.vsync_info.timestamp = timestamp;
+		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
+
+	}else if(intr0_reg & m_LINE_FLAG_INTR_STS){
+		lcdc_dev->driver.frame_time.last_framedone_t =
+				lcdc_dev->driver.frame_time.framedone_t;
+		lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_LINE_FLAG_INTR_CLR,
+			     v_LINE_FLAG_INTR_CLR(1));
+	}else if(intr0_reg & m_BUS_ERROR_INTR_STS){
+		lcdc_msk_reg(lcdc_dev, INTR_CTRL0, m_BUS_ERROR_INTR_CLR,
+			     v_BUS_ERROR_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev,"buf_error_int!");
+	}
+
+	/* for win empty debug */
+#ifdef LCDC_IRQ_EMPTY_DEBUG
+	intr1_reg = lcdc_readl(lcdc_dev, INTR_CTRL1);
+	if (intr1_reg != 0) {
+		rk3288_lcdc_parse_irq(lcdc_dev,intr1_reg);
+	}
+#endif
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_PM)
+static int rk3288_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk3288_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define rk3288_lcdc_suspend NULL
+#define rk3288_lcdc_resume  NULL
+#endif
+
+static int rk3288_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
+{
+	struct device_node *np = lcdc_dev->dev->of_node;
+	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
+	int val;
+
+	if (of_property_read_u32(np, "rockchip,prop", &val))
+		lcdc_dev->prop = PRMRY;	/*default set it as primary */
+	else
+		lcdc_dev->prop = val;
+
+	if (of_property_read_u32(np, "rockchip,mirror", &val))
+		dev_drv->rotate_mode = NO_MIRROR;
+	else
+		dev_drv->rotate_mode = val;
+
+	if (of_property_read_u32(np, "rockchip,cabc_mode", &val))
+		dev_drv->cabc_mode = 0;	/* default set close cabc */
+	else
+		dev_drv->cabc_mode = val;
+
+	if (of_property_read_u32(np, "rockchip,pwr18", &val))
+		lcdc_dev->pwr18 = false;	/*default set it as 3.xv power supply */
+	else
+		lcdc_dev->pwr18 = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
+		dev_drv->fb_win_map = FB_DEFAULT_ORDER;
+	else
+		dev_drv->fb_win_map = val;
+
+	if (of_property_read_u32(np, "rockchip,bcsh-en", &val))
+		dev_drv->bcsh.enable = false;
+	else
+		dev_drv->bcsh.enable = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,brightness", &val))
+		dev_drv->bcsh.brightness = 0xffff;
+	else
+		dev_drv->bcsh.brightness = val;
+
+	if (of_property_read_u32(np, "rockchip,contrast", &val))
+		dev_drv->bcsh.contrast = 0xffff;
+	else
+		dev_drv->bcsh.contrast = val;
+
+	if (of_property_read_u32(np, "rockchip,sat-con", &val))
+		dev_drv->bcsh.sat_con = 0xffff;
+	else
+		dev_drv->bcsh.sat_con = val;
+
+	if (of_property_read_u32(np, "rockchip,hue", &val)) {
+		dev_drv->bcsh.sin_hue = 0xffff;
+		dev_drv->bcsh.cos_hue = 0xffff;
+	} else {
+		dev_drv->bcsh.sin_hue = val & 0xff;
+		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
+	}
+
+	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
+		dev_drv->iommu_enabled = 0;
+	else
+		dev_drv->iommu_enabled = val;
+
+	if (of_property_read_u32(np, "rockchip,dsp_mode", &val))
+		dev_drv->dsp_mode = DEFAULT_MODE;
+	else
+		dev_drv->dsp_mode = val;
+
+	return 0;
+}
+
+static int rk3288_lcdc_probe(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = NULL;
+	struct rk_lcdc_driver *dev_drv;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	int prop;
+	int ret = 0;
+
+	/*if the primary lcdc has not registered ,the extend
+	   lcdc register later */
+	of_property_read_u32(np, "rockchip,prop", &prop);
+	if (prop == EXTEND) {
+		if (!is_prmry_rk_lcdc_registered())
+			return -EPROBE_DEFER;
+	}
+	lcdc_dev = devm_kzalloc(dev,
+				sizeof(struct lcdc_device), GFP_KERNEL);
+	if (!lcdc_dev) {
+		dev_err(&pdev->dev, "rk3288 lcdc device kmalloc fail!");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->dev = dev;
+	rk3288_lcdc_parse_dt(lcdc_dev);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+	lcdc_dev->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lcdc_dev->regs))
+		return PTR_ERR(lcdc_dev->regs);
+
+	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
+	if (IS_ERR(lcdc_dev->regsbak))
+		return PTR_ERR(lcdc_dev->regsbak);
+	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + GAMMA_LUT_ADDR);
+	lcdc_dev->id = rk3288_lcdc_get_id(lcdc_dev->reg_phy_base);
+	if (lcdc_dev->id < 0) {
+		dev_err(&pdev->dev, "no such lcdc device!\n");
+		return -ENXIO;
+	}
+	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
+	dev_drv = &lcdc_dev->driver;
+	dev_drv->dev = dev;
+	dev_drv->prop = prop;
+	dev_drv->id = lcdc_dev->id;
+	dev_drv->ops = &lcdc_drv_ops;
+	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
+	spin_lock_init(&lcdc_dev->reg_lock);
+
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if (lcdc_dev->irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
+			lcdc_dev->id);
+		return -ENXIO;
+	}
+
+	ret = devm_request_irq(dev, lcdc_dev->irq, rk3288_lcdc_isr,
+			       IRQF_DISABLED | IRQF_SHARED, dev_name(dev), lcdc_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
+			lcdc_dev->irq, ret);
+		return ret;
+	}
+
+	if (dev_drv->iommu_enabled) {
+		if(lcdc_dev->id == 0){
+			strcpy(dev_drv->mmu_dts_name, VOPB_IOMMU_COMPATIBLE_NAME);
+		}else{
+			strcpy(dev_drv->mmu_dts_name, VOPL_IOMMU_COMPATIBLE_NAME);
+		}
+	}
+
+	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
+	if (ret < 0) {
+		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
+		return ret;
+	}
+	lcdc_dev->screen = dev_drv->screen0;
+	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
+		lcdc_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
+
+	return 0;
+}
+
+static int rk3288_lcdc_remove(struct platform_device *pdev)
+{
+
+	return 0;
+}
+
+static void rk3288_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+
+	rk3288_lcdc_deint(lcdc_dev);
+	rk_disp_pwr_disable(&lcdc_dev->driver);
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk3288_lcdc_dt_ids[] = {
+	{.compatible = "rockchip,rk3288-lcdc",},
+	{}
+};
+#endif
+
+static struct platform_driver rk3288_lcdc_driver = {
+	.probe = rk3288_lcdc_probe,
+	.remove = rk3288_lcdc_remove,
+	.driver = {
+		   .name = "rk3288-lcdc",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rk3288_lcdc_dt_ids),
+		   },
+	.suspend = rk3288_lcdc_suspend,
+	.resume = rk3288_lcdc_resume,
+	.shutdown = rk3288_lcdc_shutdown,
+};
+
+static int __init rk3288_lcdc_module_init(void)
+{
+	return platform_driver_register(&rk3288_lcdc_driver);
+}
+
+static void __exit rk3288_lcdc_module_exit(void)
+{
+	platform_driver_unregister(&rk3288_lcdc_driver);
+}
+
+fs_initcall(rk3288_lcdc_module_init);
+module_exit(rk3288_lcdc_module_exit);
+
+
diff -Nupr a/drivers/video/rockchip/lcdc/rk3288_lcdc.h b/drivers/video/rockchip/lcdc/rk3288_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk3288_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3288_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1474 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef RK3288_LCDC_H_
+#define RK3288_LCDC_H_
+
+#include<linux/rk_fb.h>
+#include<linux/io.h>
+#include<linux/clk.h>
+
+
+/*******************register definition**********************/
+
+#define REG_CFG_DONE            	(0x0000)
+#define VERSION_INFO            	(0x0004)
+#define m_RTL_VERSION 			(0xffff<<0)
+#define m_FPGA_VERSION			(0xffff<<16)
+#define VOP_FULL_RK3288_V1_0		0x03007236
+#define VOP_FULL_RK3288_V1_1		0x0a050a01
+#define SYS_CTRL                	(0x0008)
+#define v_DIRECT_PATH_EN(x)     	(((x)&1)<<0)
+#define v_DIRECT_PATCH_SEL(x)   	(((x)&3)<<1)
+#define v_DOUB_CHANNEL_EN(x)    	(((x)&1)<<3)
+#define v_DOUB_CH_OVERLAP_NUM(x)        (((x)&0xf)<<4)
+#define v_EDPI_HALT_EN(x)    		(((x)&1)<<8)
+#define v_EDPI_WMS_MODE(x)              (((x)&1)<<9)
+#define v_EDPI_WMS_FS(x)                (((x)&1)<<10)
+#define v_HDMI_DCLK_OUT_EN(x)		(((x)&1)<<11)
+#define v_RGB_OUT_EN(x)                 (((x)&1)<<12)
+#define v_HDMI_OUT_EN(x)                (((x)&1)<<13)
+#define v_EDP_OUT_EN(x)                 (((x)&1)<<14)
+#define v_MIPI_OUT_EN(x)                (((x)&1)<<15)
+#define v_DMA_BURST_LENGTH(x) 		(((x)&3)<<18)
+#define v_MMU_EN(x)    	        	(((x)&1)<<20)
+#define v_DMA_STOP(x)                   (((x)&1)<<21)
+#define v_STANDBY_EN(x)      		(((x)&1)<<22)
+#define v_AUTO_GATING_EN(x)   		(((x)&1)<<23)
+
+#define m_DIRECT_PATH_EN     	        (1<<0)
+#define m_DIRECT_PATCH_SEL  		(3<<1)
+#define m_DOUB_CHANNEL_EN    		(1<<3)
+#define m_DOUB_CH_OVERLAP_NUM           (0xf<<4)
+#define m_EDPI_HALT_EN       		(1<<8)
+#define m_EDPI_WMS_MODE                 (1<<9)
+#define m_EDPI_WMS_FS                   (1<<10)
+#define m_HDMI_DCLK_OUT_EN		(1<<11)
+#define m_RGB_OUT_EN                    (1<<12)
+#define m_HDMI_OUT_EN                   (1<<13)
+#define m_EDP_OUT_EN                    (1<<14)
+#define m_MIPI_OUT_EN                   (1<<15)
+#define m_DMA_BURST_LENGTH    		(3<<18)
+#define m_MMU_EN       	        	(1<<20)
+#define m_DMA_STOP			(1<<21)
+#define m_STANDBY_EN      		(1<<22)
+#define m_AUTO_GATING_EN      		(1<<23)
+#define SYS_CTRL1            		(0x000c)
+#define v_NOC_HURRY_EN(x)               (((x)&0x1 )<<0 ) 
+#define v_NOC_HURRY_VALUE(x)            (((x)&0x3 )<<1 )
+#define v_NOC_HURRY_THRESHOLD(x)        (((x)&0x3f)<<3 )
+#define v_NOC_QOS_EN(x)                 (((x)&0x1 )<<9 )
+#define v_NOC_WIN_QOS(x)                (((x)&0x3 )<<10)
+#define v_AXI_MAX_OUTSTANDING_EN(x)     (((x)&0x1 )<<12)
+#define v_AXI_OUTSTANDING_MAX_NUM(x)    (((x)&0x1f)<<13)
+
+#define m_NOC_HURRY_EN                  (0x1 <<0 )
+#define m_NOC_HURRY_VALUE               (0x3 <<1 )
+#define m_NOC_HURRY_THRESHOLD           (0x3f<<3 )
+#define m_NOC_QOS_EN                    (0x1 <<9 )
+#define m_NOC_WIN_QOS                   (0x3 <<10)
+#define m_AXI_MAX_OUTSTANDING_EN        (0x1 <<12)
+#define m_AXI_OUTSTANDING_MAX_NUM       (0x1f<<13)
+
+#define DSP_CTRL0               	(0x0010)
+#define v_DSP_OUT_MODE(x)       	(((x)&0x0f)<<0)
+#define v_DSP_HSYNC_POL(x)      	(((x)&1)<<4)
+#define v_DSP_VSYNC_POL(x)      	(((x)&1)<<5)
+#define v_DSP_DEN_POL(x)        	(((x)&1)<<6)
+#define v_DSP_DCLK_POL(x)       	(((x)&1)<<7)
+#define v_DSP_DCLK_DDR(x)       	(((x)&1)<<8)
+#define v_DSP_DDR_PHASE(x)      	(((x)&1)<<9)
+#define v_DSP_INTERLACE(x)      	(((x)&1)<<10)
+#define v_DSP_FIELD_POL(x)      	(((x)&1)<<11)
+#define v_DSP_BG_SWAP(x)        	(((x)&1)<<12)
+#define v_DSP_RB_SWAP(x)        	(((x)&1)<<13)
+#define v_DSP_RG_SWAP(x)        	(((x)&1)<<14)
+#define v_DSP_DELTA_SWAP(x)     	(((x)&1)<<15)
+#define v_DSP_DUMMY_SWAP(x)     	(((x)&1)<<16)
+#define v_DSP_OUT_ZERO(x)       	(((x)&1)<<17)
+#define v_DSP_BLANK_EN(x)       	(((x)&1)<<18)
+#define v_DSP_BLACK_EN(x)       	(((x)&1)<<19)
+#define v_DSP_CCIR656_AVG(x)    	(((x)&1)<<20)
+#define v_DSP_YUV_CLIP(x)       	(((x)&1)<<21)
+#define v_DSP_X_MIR_EN(x)       	(((x)&1)<<22)
+#define v_DSP_Y_MIR_EN(x)       	(((x)&1)<<23)
+#define m_DSP_OUT_MODE       		(0x0f<<0)
+#define m_DSP_HSYNC_POL       		(1<<4)
+#define m_DSP_VSYNC_POL       		(1<<5)
+#define m_DSP_DEN_POL       		(1<<6)
+#define m_DSP_DCLK_POL        		(1<<7)
+#define m_DSP_DCLK_DDR      		(1<<8)
+#define m_DSP_DDR_PHASE      		(1<<9)
+#define m_DSP_INTERLACE      		(1<<10)
+#define m_DSP_FIELD_POL      		(1<<11)
+#define m_DSP_BG_SWAP       		(1<<12)
+#define m_DSP_RB_SWAP       		(1<<13)
+#define m_DSP_RG_SWAP        		(1<<14)
+#define m_DSP_DELTA_SWAP      		(1<<15)
+#define m_DSP_DUMMY_SWAP       		(1<<16)
+#define m_DSP_OUT_ZERO       		(1<<17)
+#define m_DSP_BLANK_EN     		(1<<18)
+#define m_DSP_BLACK_EN      		(1<<19)
+#define m_DSP_CCIR656_AVG     		(1<<20)
+#define m_DSP_YUV_CLIP      		(1<<21)
+#define m_DSP_X_MIR_EN      		(1<<22)
+#define m_DSP_Y_MIR_EN      		(1<<23)
+
+#define DSP_CTRL1 			(0x0014)
+#define v_DSP_LUT_EN(x)         	(((x)&1)<<0)
+#define v_PRE_DITHER_DOWN_EN(x) 	(((x)&1)<<1)
+#define v_DITHER_DOWN_EN(x)     	(((x)&1)<<2)
+#define v_DITHER_DOWN_MODE(x)   	(((x)&1)<<3)
+#define v_DITHER_DOWN_SEL(x)    	(((x)&1)<<4)
+#define v_DITHER_UP_EN(x)		(((x)&1)<<6)
+#define v_DSP_LAYER0_SEL(x)		(((x)&3)<<8)
+#define v_DSP_LAYER1_SEL(x)		(((x)&3)<<10)
+#define v_DSP_LAYER2_SEL(x)		(((x)&3)<<12)
+#define v_DSP_LAYER3_SEL(x)		(((x)&3)<<14)
+#define m_DSP_LUT_EN          		(1<<0)
+#define m_PRE_DITHER_DOWN_EN  		(1<<1)
+#define m_DITHER_DOWN_EN      		(1<<2)
+#define m_DITHER_DOWN_MODE   		(1<<3)
+#define m_DITHER_DOWN_SEL    		(1<<4)
+#define m_DITHER_UP_EN			(1<<6)
+#define m_DSP_LAYER0_SEL		(3<<8)
+#define m_DSP_LAYER1_SEL		(3<<10)
+#define m_DSP_LAYER2_SEL		(3<<12)
+#define m_DSP_LAYER3_SEL		(3<<14)
+
+#define DSP_BG 				(0x0018)
+#define v_DSP_BG_BLUE(x)        	(((x<<2)&0x3ff)<<0)
+#define v_DSP_BG_GREEN(x)       	(((x<<2)&0x3ff)<<10)
+#define v_DSP_BG_RED(x)         	(((x<<2)&0x3ff)<<20)
+#define m_DSP_BG_BLUE        		(0x3ff<<0)
+#define m_DSP_BG_GREEN      		(0x3ff<<10)
+#define m_DSP_BG_RED        		(0x3ff<<20)
+
+#define MCU_CTRL 	        	(0x001c)
+#define v_MCU_PIX_TOTAL(x)      	(((x)&0x3f)<<0)
+#define v_MCU_CS_PST(x)         	(((x)&0xf)<<6)
+#define v_MCU_CS_PEND(x)        	(((x)&0x3f)<<10)
+#define v_MCU_RW_PST(x)         	(((x)&0xf)<<16)
+#define v_MCU_RW_PEND(x)        	(((x)&0x3f)<<20)
+#define v_MCU_CLK_SEL(x)        	(((x)&1)<<26)   
+#define v_MCU_HOLD_MODE(x)      	(((x)&1)<<27)
+#define v_MCU_FRAME_ST(x)       	(((x)&1)<<28)
+#define v_MCU_RS(x)         		(((x)&1)<<29)
+#define v_MCU_BYPASS(x)         	(((x)&1)<<30)
+#define v_MCU_TYPE(x)            	(((x)&1)<<31)
+#define m_MCU_PIX_TOTAL       		(0x3f<<0)
+#define m_MCU_CS_PST          		(0xf<<6)
+#define m_MCU_CS_PEND        		(0x3f<<10)
+#define m_MCU_RW_PST          		(0xf<<16)
+#define m_MCU_RW_PEND         		(0x3f<<20)
+#define m_MCU_CLK_SEL         		(1<<26)   
+#define m_MCU_HOLD_MODE       		(1<<27)
+#define m_MCU_FRAME_ST        		(1<<28)
+#define m_MCU_RS          		(1<<29)
+#define m_MCU_BYPASS          		(1<<30)
+#define m_MCU_TYPE           		((u32)1<<31)
+
+#define INTR_CTRL0 			(0x0020)
+#define v_DSP_HOLD_VALID_INTR_STS(x)    (((x)&1)<<0)
+#define v_FS_INTR_STS(x)        	(((x)&1)<<1)
+#define v_LINE_FLAG_INTR_STS(x) 	(((x)&1)<<2)
+#define v_BUS_ERROR_INTR_STS(x) 	(((x)&1)<<3)
+#define v_DSP_HOLD_VALID_INTR_EN(x)  	(((x)&1)<<4)
+#define v_FS_INTR_EN(x)         	(((x)&1)<<5)
+#define v_LINE_FLAG_INTR_EN(x)  	(((x)&1)<<6)
+#define v_BUS_ERROR_INTR_EN(x)        	(((x)&1)<<7)
+#define v_DSP_HOLD_VALID_INTR_CLR(x)    (((x)&1)<<8)
+#define v_FS_INTR_CLR(x)        	(((x)&1)<<9)
+#define v_LINE_FLAG_INTR_CLR(x)        	(((x)&1)<<10)
+#define v_BUS_ERROR_INTR_CLR(x)        	(((x)&1)<<11)
+#define v_DSP_LINE_FLAG_NUM(x)        	(((x)&0xfff)<<12)
+
+#define m_DSP_HOLD_VALID_INTR_STS     	(1<<0)
+#define m_FS_INTR_STS         		(1<<1)
+#define m_LINE_FLAG_INTR_STS  		(1<<2)
+#define m_BUS_ERROR_INTR_STS 		(1<<3)
+#define m_DSP_HOLD_VALID_INTR_EN   	(1<<4)
+#define m_FS_INTR_EN         		(1<<5)
+#define m_LINE_FLAG_INTR_EN 		(1<<6)
+#define m_BUS_ERROR_INTR_EN         	(1<<7)
+#define m_DSP_HOLD_VALID_INTR_CLR     	(1<<8)
+#define m_FS_INTR_CLR       		(1<<9)
+#define m_LINE_FLAG_INTR_CLR         	(1<<10)
+#define m_BUS_ERROR_INTR_CLR         	(1<<11)
+#define m_DSP_LINE_FLAG_NUM         	(0xfff<<12)
+
+#define INTR_CTRL1 			(0x0024)
+#define v_WIN0_EMPTY_INTR_STS(x)	(((x)&1)<<0)
+#define v_WIN1_EMPTY_INTR_STS(x)	(((x)&1)<<1)
+#define v_WIN2_EMPTY_INTR_STS(x)	(((x)&1)<<2)
+#define v_WIN3_EMPTY_INTR_STS(x)	(((x)&1)<<3)
+#define v_HWC_EMPTY_INTR_STS(x)		(((x)&1)<<4)
+#define v_POST_BUF_EMPTY_INTR_STS(x)	(((x)&1)<<5)
+#define v_PWM_GEN_INTR_STS(x)		(((x)&1)<<6)
+#define v_WIN0_EMPTY_INTR_EN(x)		(((x)&1)<<8)
+#define v_WIN1_EMPTY_INTR_EN(x)		(((x)&1)<<9)
+#define v_WIN2_EMPTY_INTR_EN(x)		(((x)&1)<<10)
+#define v_WIN3_EMPTY_INTR_EN(x)		(((x)&1)<<11)
+#define v_HWC_EMPTY_INTR_EN(x)		(((x)&1)<<12)
+#define v_POST_BUF_EMPTY_INTR_EN(x)	(((x)&1)<<13)
+#define v_PWM_GEN_INTR_EN(x)		(((x)&1)<<14)
+#define v_WIN0_EMPTY_INTR_CLR(x)	(((x)&1)<<16)
+#define v_WIN1_EMPTY_INTR_CLR(x)	(((x)&1)<<17)
+#define v_WIN2_EMPTY_INTR_CLR(x)	(((x)&1)<<18)
+#define v_WIN3_EMPTY_INTR_CLR(x)	(((x)&1)<<19)
+#define v_HWC_EMPTY_INTR_CLR(x)		(((x)&1)<<20)
+#define v_POST_BUF_EMPTY_INTR_CLR(x)	(((x)&1)<<21)
+#define v_PWM_GEN_INTR_CLR(x)		(((x)&1)<<22)
+
+#define m_WIN0_EMPTY_INTR_STS 		(1<<0)
+#define m_WIN1_EMPTY_INTR_STS 		(1<<1)
+#define m_WIN2_EMPTY_INTR_STS 		(1<<2)
+#define m_WIN3_EMPTY_INTR_STS 		(1<<3)
+#define m_HWC_EMPTY_INTR_STS 		(1<<4)
+#define m_POST_BUF_EMPTY_INTR_STS 	(1<<5)
+#define m_PWM_GEN_INTR_STS 		(1<<6)
+#define m_WIN0_EMPTY_INTR_EN 		(1<<8)
+#define m_WIN1_EMPTY_INTR_EN 		(1<<9)
+#define m_WIN2_EMPTY_INTR_EN 		(1<<10)
+#define m_WIN3_EMPTY_INTR_EN 		(1<<11)
+#define m_HWC_EMPTY_INTR_EN 		(1<<12)
+#define m_POST_BUF_EMPTY_INTR_EN 	(1<<13)
+#define m_PWM_GEN_INTR_EN 		(1<<14)
+#define m_WIN0_EMPTY_INTR_CLR 		(1<<16)
+#define m_WIN1_EMPTY_INTR_CLR 		(1<<17)
+#define m_WIN2_EMPTY_INTR_CLR 		(1<<18)
+#define m_WIN3_EMPTY_INTR_CLR 		(1<<19)
+#define m_HWC_EMPTY_INTR_CLR 		(1<<20)
+#define m_POST_BUF_EMPTY_INTR_CLR 	(1<<21)
+#define m_PWM_GEN_INTR_CLR 		(1<<22)
+
+/*win0 register*/
+#define WIN0_CTRL0 			(0x0030)
+#define v_WIN0_EN(x)			(((x)&1)<<0)
+#define v_WIN0_DATA_FMT(x)		(((x)&7)<<1)
+#define v_WIN0_FMT_10(x)		(((x)&1)<<4)
+#define v_WIN0_LB_MODE(x)		(((x)&7)<<5)
+#define v_WIN0_INTERLACE_READ(x)	(((x)&1)<<8)
+#define v_WIN0_NO_OUTSTANDING(x)	(((x)&1)<<9)
+#define v_WIN0_CSC_MODE(x)		(((x)&3)<<10)
+#define v_WIN0_RB_SWAP(x)		(((x)&1)<<12)
+#define v_WIN0_ALPHA_SWAP(x)		(((x)&1)<<13)
+#define v_WIN0_MID_SWAP(x)		(((x)&1)<<14)
+#define v_WIN0_UV_SWAP(x)		(((x)&1)<<15)
+#define v_WIN0_PPAS_ZERO_EN(x)		(((x)&1)<<16)
+#define v_WIN0_YRGB_DEFLICK(x)		(((x)&1)<<18)
+#define v_WIN0_CBR_DEFLICK(x)		(((x)&1)<<19)
+#define v_WIN0_YUV_CLIP(x)		(((x)&1)<<20)
+
+#define m_WIN0_EN 			(1<<0)
+#define m_WIN0_DATA_FMT 		(7<<1)
+#define m_WIN0_FMT_10 			(1<<4)
+#define m_WIN0_LB_MODE 			(7<<5)
+#define m_WIN0_INTERLACE_READ		(1<<8)
+#define m_WIN0_NO_OUTSTANDING 		(1<<9)
+#define m_WIN0_CSC_MODE 		(3<<10)
+#define m_WIN0_RB_SWAP 			(1<<12)
+#define m_WIN0_ALPHA_SWAP 		(1<<13)
+#define m_WIN0_MID_SWAP 		(1<<14)
+#define m_WIN0_UV_SWAP 			(1<<15)
+#define m_WIN0_PPAS_ZERO_EN     	(1<<16)
+#define m_WIN0_YRGB_DEFLICK 		(1<<18)
+#define m_WIN0_CBR_DEFLICK 		(1<<19)
+#define m_WIN0_YUV_CLIP 		(1<<20)
+
+#define WIN0_CTRL1 			(0x0034)
+#define v_WIN0_YRGB_AXI_GATHER_EN(x)	(((x)&1)<<0)
+#define v_WIN0_CBR_AXI_GATHER_EN(x)	(((x)&1)<<1)
+#define v_WIN0_BIC_COE_SEL(x)           (((x)&3)<<2)
+#define v_WIN0_VSD_YRGB_GT4(x)          (((x)&1)<<4)
+#define v_WIN0_VSD_YRGB_GT2(x)          (((x)&1)<<5)
+#define v_WIN0_VSD_CBR_GT4(x)           (((x)&1)<<6)
+#define v_WIN0_VSD_CBR_GT2(x)           (((x)&1)<<7)
+#define v_WIN0_YRGB_AXI_GATHER_NUM(x)	(((x)&0xf)<<8)
+#define v_WIN0_CBR_AXI_GATHER_NUM(x)	(((x)&7)<<12)
+#define v_WIN0_LINE_LOAD_MODE(x)	(((x)&1)<<15)
+#define v_WIN0_YRGB_HOR_SCL_MODE(x)	(((x)&3)<<16)
+#define v_WIN0_YRGB_VER_SCL_MODE(x)	(((x)&3)<<18)
+#define v_WIN0_YRGB_HSD_MODE(x)		(((x)&3)<<20)
+#define v_WIN0_YRGB_VSU_MODE(x)		(((x)&1)<<22)
+#define v_WIN0_YRGB_VSD_MODE(x)		(((x)&1)<<23)
+#define v_WIN0_CBR_HOR_SCL_MODE(x)	(((x)&3)<<24)
+#define v_WIN0_CBR_VER_SCL_MODE(x)	(((x)&3)<<26)
+#define v_WIN0_CBR_HSD_MODE(x)		(((x)&3)<<28)
+#define v_WIN0_CBR_VSU_MODE(x)		(((x)&1)<<30)
+#define v_WIN0_CBR_VSD_MODE(x)		(((x)&1)<<31)
+
+#define m_WIN0_YRGB_AXI_GATHER_EN   	(1<<0)
+#define m_WIN0_CBR_AXI_GATHER_EN        (1<<1)
+#define m_WIN0_BIC_COE_SEL              (3<<2)
+#define m_WIN0_VSD_YRGB_GT4             (1<<4)
+#define m_WIN0_VSD_YRGB_GT2             (1<<5)
+#define m_WIN0_VSD_CBR_GT4              (1<<6)
+#define m_WIN0_VSD_CBR_GT2              (1<<7)
+#define m_WIN0_YRGB_AXI_GATHER_NUM	(0xf<<8)
+#define m_WIN0_CBR_AXI_GATHER_NUM	(7<<12)
+#define m_WIN0_LINE_LOAD_MODE		(1<<15)
+#define m_WIN0_YRGB_HOR_SCL_MODE	(3<<16)
+#define m_WIN0_YRGB_VER_SCL_MODE	(3<<18)
+#define m_WIN0_YRGB_HSD_MODE		(3<<20)
+#define m_WIN0_YRGB_VSU_MODE		(1<<22)
+#define m_WIN0_YRGB_VSD_MODE		(1<<23)
+#define m_WIN0_CBR_HOR_SCL_MODE		(3<<24)
+#define m_WIN0_CBR_VER_SCL_MODE		(3<<26)
+#define m_WIN0_CBR_HSD_MODE		(3<<28)
+#define m_WIN0_CBR_VSU_MODE		((u32)1<<30)
+#define m_WIN0_CBR_VSD_MODE		((u32)1<<31)
+
+#define WIN0_COLOR_KEY			(0x0038)
+#define v_WIN0_COLOR_KEY(x)		(((x)&0x3fffffff)<<0)
+#define v_WIN0_COLOR_KEY_EN(x)		(((x)&1)<<31)
+#define m_WIN0_COLOR_KEY		(0x3fffffff<<0)
+#define m_WIN0_COLOR_KEY_EN		((u32)1<<31)
+
+#define WIN0_VIR 			(0x003c)
+#define v_WIN0_VIR_STRIDE(x)		(((x)&0x3fff)<<0)
+#define v_WIN0_VIR_STRIDE_UV(x)		(((x)&0x3fff)<<16)
+#define m_WIN0_VIR_STRIDE		(0x3fff<<0)
+#define m_WIN0_VIR_STRIDE_UV    	(0x3fff<<16)
+
+#define WIN0_YRGB_MST 			(0x0040)
+#define WIN0_CBR_MST 	        	(0x0044)
+#define WIN0_ACT_INFO 			(0x0048)
+#define v_WIN0_ACT_WIDTH(x)		(((x-1)&0x1fff)<<0)
+#define v_WIN0_ACT_HEIGHT(x)		(((x-1)&0x1fff)<<16)
+#define m_WIN0_ACT_WIDTH 		(0x1fff<<0)
+#define m_WIN0_ACT_HEIGHT 		(0x1fff<<16)
+
+#define WIN0_DSP_INFO 			(0x004c)
+#define v_WIN0_DSP_WIDTH(x)		(((x-1)&0xfff)<<0)
+#define v_WIN0_DSP_HEIGHT(x)		(((x-1)&0xfff)<<16)
+#define m_WIN0_DSP_WIDTH 		(0xfff<<0)
+#define m_WIN0_DSP_HEIGHT 		(0xfff<<16)
+
+#define WIN0_DSP_ST 			(0x0050)
+#define v_WIN0_DSP_XST(x)		(((x)&0x1fff)<<0)
+#define v_WIN0_DSP_YST(x)		(((x)&0x1fff)<<16)
+#define m_WIN0_DSP_XST 			(0x1fff<<0)
+#define m_WIN0_DSP_YST 			(0x1fff<<16)
+
+#define WIN0_SCL_FACTOR_YRGB 		(0x0054)
+#define v_WIN0_HS_FACTOR_YRGB(x)	(((x)&0xffff)<<0)
+#define v_WIN0_VS_FACTOR_YRGB(x)	(((x)&0xffff)<<16)
+#define m_WIN0_HS_FACTOR_YRGB		(0xffff<<0)
+#define m_WIN0_VS_FACTOR_YRGB		((u32)0xffff<<16)
+
+#define WIN0_SCL_FACTOR_CBR 		(0x0058)
+#define v_WIN0_HS_FACTOR_CBR(x)		(((x)&0xffff)<<0)
+#define v_WIN0_VS_FACTOR_CBR(x)		(((x)&0xffff)<<16)
+#define m_WIN0_HS_FACTOR_CBR		(0xffff<<0)
+#define m_WIN0_VS_FACTOR_CBR		((u32)0xffff<<16)
+
+#define WIN0_SCL_OFFSET 		(0x005c)
+#define v_WIN0_HS_OFFSET_YRGB(x)	(((x)&0xff)<<0)
+#define v_WIN0_HS_OFFSET_CBR(x)		(((x)&0xff)<<8)
+#define v_WIN0_VS_OFFSET_YRGB(x)	(((x)&0xff)<<16)
+#define v_WIN0_VS_OFFSET_CBR(x)		(((x)&0xff)<<24)
+
+#define m_WIN0_HS_OFFSET_YRGB		(0xff<<0)
+#define m_WIN0_HS_OFFSET_CBR		(0xff<<8)
+#define m_WIN0_VS_OFFSET_YRGB		(0xff<<16)
+#define m_WIN0_VS_OFFSET_CBR		((u32)0xff<<24)
+
+#define WIN0_SRC_ALPHA_CTRL 		(0x0060)
+#define v_WIN0_SRC_ALPHA_EN(x)		(((x)&1)<<0)
+#define v_WIN0_SRC_COLOR_M0(x)		(((x)&1)<<1)
+#define v_WIN0_SRC_ALPHA_M0(x)		(((x)&1)<<2)
+#define v_WIN0_SRC_BLEND_M0(x)		(((x)&3)<<3)
+#define v_WIN0_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
+#define v_WIN0_SRC_FACTOR_M0(x)		(((x)&7)<<6)
+#define v_WIN0_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
+#define v_WIN0_FADING_VALUE(x)          (((x)&0xff)<<24)
+
+#define m_WIN0_SRC_ALPHA_EN 		(1<<0)
+#define m_WIN0_SRC_COLOR_M0 		(1<<1)
+#define m_WIN0_SRC_ALPHA_M0 		(1<<2)
+#define m_WIN0_SRC_BLEND_M0		(3<<3)
+#define m_WIN0_SRC_ALPHA_CAL_M0		(1<<5)
+#define m_WIN0_SRC_FACTOR_M0		(7<<6)
+#define m_WIN0_SRC_GLOBAL_ALPHA		(0xff<<16)
+#define m_WIN0_FADING_VALUE		(0xff<<24)
+
+#define WIN0_DST_ALPHA_CTRL 		(0x0064)
+#define v_WIN0_DST_FACTOR_M0(x)		(((x)&7)<<6)
+#define m_WIN0_DST_FACTOR_M0		(7<<6)
+ 
+#define WIN0_FADING_CTRL 		(0x0068)
+#define v_WIN0_FADING_OFFSET_R(x)	(((x)&0xff)<<0)
+#define v_WIN0_FADING_OFFSET_G(x)	(((x)&0xff)<<8)
+#define v_WIN0_FADING_OFFSET_B(x)	(((x)&0xff)<<16)
+#define v_WIN0_FADING_EN(x)		(((x)&1)<<24)
+
+#define m_WIN0_FADING_OFFSET_R 		(0xff<<0)
+#define m_WIN0_FADING_OFFSET_G 		(0xff<<8)
+#define m_WIN0_FADING_OFFSET_B 		(0xff<<16)
+#define m_WIN0_FADING_EN		(1<<24)
+
+/*win1 register*/
+#define WIN1_CTRL0 			(0x0070)
+#define v_WIN1_EN(x)			(((x)&1)<<0)
+#define v_WIN1_DATA_FMT(x)		(((x)&7)<<1)
+#define v_WIN1_FMT_10(x)		(((x)&1)<<4)
+#define v_WIN1_LB_MODE(x)		(((x)&7)<<5)
+#define v_WIN1_INTERLACE_READ_MODE(x)	(((x)&1)<<8)
+#define v_WIN1_NO_OUTSTANDING(x)	(((x)&1)<<9)
+#define v_WIN1_CSC_MODE(x)		(((x)&3)<<10)
+#define v_WIN1_RB_SWAP(x)		(((x)&1)<<12)
+#define v_WIN1_ALPHA_SWAP(x)		(((x)&1)<<13)
+#define v_WIN1_MID_SWAP(x)		(((x)&1)<<14)
+#define v_WIN1_UV_SWAP(x)		(((x)&1)<<15)
+#define v_WIN1_PPAS_ZERO_EN(x)		(((x)&1)<<16)
+#define v_WIN1_YRGB_DEFLICK(x)		(((x)&1)<<18)
+#define v_WIN1_CBR_DEFLICK(x)		(((x)&1)<<19)
+#define v_WIN1_YUV_CLIP(x)		(((x)&1)<<20)
+
+#define m_WIN1_EN			(1<<0)
+#define m_WIN1_DATA_FMT			(7<<1)
+#define m_WIN1_FMT_10			(1<<4)
+#define m_WIN1_LB_MODE			(7<<5)
+#define m_WIN1_INTERLACE_READ_MODE 	(1<<8)
+#define m_WIN1_NO_OUTSTANDING 		(1<<9)
+#define m_WIN1_CSC_MODE 		(3<<10)
+#define m_WIN1_RB_SWAP 			(1<<12)
+#define m_WIN1_ALPHA_SWAP 		(1<<13)
+#define m_WIN1_MID_SWAP 		(1<<14)
+#define m_WIN1_UV_SWAP 			(1<<15)
+#define m_WIN1_PPAS_ZERO_EN             (1<<16)
+#define m_WIN1_YRGB_DEFLICK 		(1<<18)
+#define m_WIN1_CBR_DEFLICK 		(1<<19)
+#define m_WIN1_YUV_CLIP 		(1<<20)
+
+#define WIN1_CTRL1 			(0x0074)
+#define v_WIN1_YRGB_AXI_GATHER_EN(x)	(((x)&1)<<0)
+#define v_WIN1_CBR_AXI_GATHER_EN(x)	(((x)&1)<<1)
+#define v_WIN1_BIC_COE_SEL(x)           (((x)&3)<<2)
+#define v_WIN1_VSD_YRGB_GT4(x)          (((x)&1)<<4)
+#define v_WIN1_VSD_YRGB_GT2(x)          (((x)&1)<<5)
+#define v_WIN1_VSD_CBR_GT4(x)           (((x)&1)<<6)
+#define v_WIN1_VSD_CBR_GT2(x)           (((x)&1)<<7)
+#define v_WIN1_YRGB_AXI_GATHER_NUM(x)	(((x)&0xf)<<8)
+#define v_WIN1_CBR_AXI_GATHER_NUM(x)	(((x)&7)<<12)
+#define v_WIN1_LINE_LOAD_MODE(x)	(((x)&1)<<15)
+#define v_WIN1_YRGB_HOR_SCL_MODE(x)	(((x)&3)<<16)
+#define v_WIN1_YRGB_VER_SCL_MODE(x)	(((x)&3)<<18)
+#define v_WIN1_YRGB_HSD_MODE(x)		(((x)&3)<<20)
+#define v_WIN1_YRGB_VSU_MODE(x)		(((x)&1)<<22)
+#define v_WIN1_YRGB_VSD_MODE(x)		(((x)&1)<<23)
+#define v_WIN1_CBR_HOR_SCL_MODE(x)	(((x)&3)<<24)
+#define v_WIN1_CBR_VER_SCL_MODE(x)	(((x)&3)<<26)
+#define v_WIN1_CBR_HSD_MODE(x)		(((x)&3)<<28)
+#define v_WIN1_CBR_VSU_MODE(x)		(((x)&1)<<30)
+#define v_WIN1_CBR_VSD_MODE(x)		(((x)&1)<<31)
+
+#define m_WIN1_YRGB_AXI_GATHER_EN	(1<<0)
+#define m_WIN1_CBR_AXI_GATHER_EN	(1<<1)
+#define m_WIN1_BIC_COE_SEL              (3<<2)
+#define m_WIN1_VSD_YRGB_GT4             (1<<4)
+#define m_WIN1_VSD_YRGB_GT2             (1<<5)
+#define m_WIN1_VSD_CBR_GT4              (1<<6)
+#define m_WIN1_VSD_CBR_GT2              (1<<7)
+#define m_WIN1_YRGB_AXI_GATHER_NUM	(0xf<<8)
+#define m_WIN1_CBR_AXI_GATHER_NUM	(7<<12)
+#define m_WIN1_LINE_LOAD_MODE		(1<<15)
+#define m_WIN1_YRGB_HOR_SCL_MODE	(3<<16)
+#define m_WIN1_YRGB_VER_SCL_MODE	(3<<18)
+#define m_WIN1_YRGB_HSD_MODE		(3<<20)
+#define m_WIN1_YRGB_VSU_MODE		(1<<22)
+#define m_WIN1_YRGB_VSD_MODE		(1<<23)
+#define m_WIN1_CBR_HOR_SCL_MODE		(3<<24)
+#define m_WIN1_CBR_VER_SCL_MODE		(3<<26)
+#define m_WIN1_CBR_HSD_MODE		(3<<28)
+#define m_WIN1_CBR_VSU_MODE		(1<<30)
+#define m_WIN1_CBR_VSD_MODE		((u32)1<<31)
+
+#define WIN1_COLOR_KEY 			(0x0078)
+#define v_WIN1_COLOR_KEY(x)		(((x)&0x3fffffff)<<0)
+#define v_WIN1_COLOR_KEY_EN(x)		(((x)&1)<<31)
+#define m_WIN1_COLOR_KEY		(0x3fffffff<<0)
+#define m_WIN1_COLOR_KEY_EN		((u32)1<<31)
+
+#define WIN1_VIR 			(0x007c)
+#define v_WIN1_VIR_STRIDE(x)		(((x)&0x3fff)<<0)
+#define v_WIN1_VIR_STRIDE_UV(x)		(((x)&0x3fff)<<16)
+#define m_WIN1_VIR_STRIDE 		(0x3fff<<0)
+#define m_WIN1_VIR_STRIDE_UV 		(0x3fff<<16)
+
+#define WIN1_YRGB_MST 			(0x0080)
+#define WIN1_CBR_MST 			(0x0084)
+#define WIN1_ACT_INFO 			(0x0088)
+#define v_WIN1_ACT_WIDTH(x)		(((x-1)&0x1fff)<<0)
+#define v_WIN1_ACT_HEIGHT(x)		(((x-1)&0x1fff)<<16)
+#define m_WIN1_ACT_WIDTH		(0x1fff<<0)
+#define m_WIN1_ACT_HEIGHT		(0x1fff<<16)
+
+#define WIN1_DSP_INFO 			(0x008c)
+#define v_WIN1_DSP_WIDTH(x)		(((x-1)&0xfff)<<0)
+#define v_WIN1_DSP_HEIGHT(x)		(((x-1)&0xfff)<<16)
+#define m_WIN1_DSP_WIDTH 		(0xfff<<0)
+#define m_WIN1_DSP_HEIGHT 		(0xfff<<16)
+
+#define WIN1_DSP_ST 			(0x0090)
+#define v_WIN1_DSP_XST(x)		(((x)&0x1fff)<<0)
+#define v_WIN1_DSP_YST(x)		(((x)&0x1fff)<<16)
+#define m_WIN1_DSP_XST 			(0x1fff<<0)
+#define m_WIN1_DSP_YST 			(0x1fff<<16)
+
+#define WIN1_SCL_FACTOR_YRGB 		(0x0094)
+#define v_WIN1_HS_FACTOR_YRGB(x)	(((x)&0xffff)<<0)
+#define v_WIN1_VS_FACTOR_YRGB(x)	(((x)&0xffff)<<16)
+#define m_WIN1_HS_FACTOR_YRGB 		(0xffff<<0)
+#define m_WIN1_VS_FACTOR_YRGB 		((u32)0xffff<<16)
+
+#define WIN1_SCL_FACTOR_CBR 		(0x0098)
+#define v_WIN1_HS_FACTOR_CBR(x)		(((x)&0xffff)<<0)
+#define v_WIN1_VS_FACTOR_CBR(x)		(((x)&0xffff)<<16)
+#define m_WIN1_HS_FACTOR_CBR		(0xffff<<0)
+#define m_WIN1_VS_FACTOR_CBR		((u32)0xffff<<16)
+
+#define WIN1_SCL_OFFSET 		(0x009c)
+#define v_WIN1_HS_OFFSET_YRGB(x)	(((x)&0xff)<<0)
+#define v_WIN1_HS_OFFSET_CBR(x)		(((x)&0xff)<<8)
+#define v_WIN1_VS_OFFSET_YRGB(x)	(((x)&0xff)<<16)
+#define v_WIN1_VS_OFFSET_CBR(x)		(((x)&0xff)<<24)
+
+#define m_WIN1_HS_OFFSET_YRGB		(0xff<<0)
+#define m_WIN1_HS_OFFSET_CBR		(0xff<<8)
+#define m_WIN1_VS_OFFSET_YRGB		(0xff<<16)
+#define m_WIN1_VS_OFFSET_CBR		((u32)0xff<<24)
+
+#define WIN1_SRC_ALPHA_CTRL 		(0x00a0)
+#define v_WIN1_SRC_ALPHA_EN(x)		(((x)&1)<<0)
+#define v_WIN1_SRC_COLOR_M0(x)		(((x)&1)<<1)
+#define v_WIN1_SRC_ALPHA_M0(x)		(((x)&1)<<2)
+#define v_WIN1_SRC_BLEND_M0(x)		(((x)&3)<<3)
+#define v_WIN1_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
+#define v_WIN1_SRC_FACTOR_M0(x)		(((x)&7)<<6)
+#define v_WIN1_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
+#define v_WIN1_FADING_VALUE(x)          (((x)&0xff)<<24)
+
+#define m_WIN1_SRC_ALPHA_EN 		(1<<0)
+#define m_WIN1_SRC_COLOR_M0 		(1<<1)
+#define m_WIN1_SRC_ALPHA_M0 		(1<<2)
+#define m_WIN1_SRC_BLEND_M0		(3<<3)
+#define m_WIN1_SRC_ALPHA_CAL_M0		(1<<5)
+#define m_WIN1_SRC_FACTOR_M0		(7<<6)
+#define m_WIN1_SRC_GLOBAL_ALPHA		(0xff<<16)
+#define m_WIN1_FADING_VALUE		(0xff<<24)
+
+#define WIN1_DST_ALPHA_CTRL 		(0x00a4)
+#define v_WIN1_DST_FACTOR_M0(x)		(((x)&7)<<6)
+#define m_WIN1_DST_FACTOR_M0		(7<<6)
+
+#define WIN1_FADING_CTRL 		(0x00a8)
+#define v_WIN1_FADING_OFFSET_R(x)	(((x)&0xff)<<0)
+#define v_WIN1_FADING_OFFSET_G(x)	(((x)&0xff)<<8)
+#define v_WIN1_FADING_OFFSET_B(x)	(((x)&0xff)<<16)
+#define v_WIN1_FADING_EN(x)		(((x)&1)<<24)
+
+#define m_WIN1_FADING_OFFSET_R 		(0xff<<0)
+#define m_WIN1_FADING_OFFSET_G 		(0xff<<8)
+#define m_WIN1_FADING_OFFSET_B 		(0xff<<16)
+#define m_WIN1_FADING_EN		(1<<24)
+
+/*win2 register*/
+#define WIN2_CTRL0 			(0x00b0)
+#define v_WIN2_EN(x)			(((x)&1)<<0)
+#define v_WIN2_DATA_FMT(x)		(((x)&7)<<1)
+#define v_WIN2_MST0_EN(x)		(((x)&1)<<4)
+#define v_WIN2_MST1_EN(x)		(((x)&1)<<5)
+#define v_WIN2_MST2_EN(x)		(((x)&1)<<6)
+#define v_WIN2_MST3_EN(x)		(((x)&1)<<7)
+#define v_WIN2_INTERLACE_READ(x)	(((x)&1)<<8)
+#define v_WIN2_NO_OUTSTANDING(x)	(((x)&1)<<9)
+#define v_WIN2_CSC_MODE(x)		(((x)&1)<<10)
+#define v_WIN2_RB_SWAP(x)		(((x)&1)<<12)
+#define v_WIN2_ALPHA_SWAP(x)		(((x)&1)<<13)
+#define v_WIN2_ENDIAN_MODE(x)		(((x)&1)<<14)
+#define v_WIN2_LUT_EN(x)		(((x)&1)<<18)
+
+#define m_WIN2_EN 			(1<<0)
+#define m_WIN2_DATA_FMT 		(7<<1)
+#define m_WIN2_MST0_EN 			(1<<4)
+#define m_WIN2_MST1_EN 			(1<<5)
+#define m_WIN2_MST2_EN 			(1<<6)
+#define m_WIN2_MST3_EN 			(1<<7)
+#define m_WIN2_INTERLACE_READ 		(1<<8)
+#define m_WIN2_NO_OUTSTANDING 		(1<<9)
+#define m_WIN2_CSC_MODE 		(1<<10)
+#define m_WIN2_RB_SWAP 			(1<<12)
+#define m_WIN2_ALPHA_SWAP 		(1<<13)
+#define m_WIN2_ENDIAN_MODE 		(1<<14)
+#define m_WIN2_LUT_EN 			(1<<18)
+
+#define WIN2_CTRL1 			(0x00b4)
+#define v_WIN2_AXI_GATHER_EN(x)		(((x)&1)<<0)
+#define v_WIN2_AXI_GATHER_NUM(x)	(((x)&0xf)<<4)
+#define m_WIN2_AXI_GATHER_EN		(1<<0)
+#define m_WIN2_AXI_GATHER_NUM		(0xf<<4)
+
+#define WIN2_VIR0_1 			(0x00b8)
+#define v_WIN2_VIR_STRIDE0(x)		(((x)&0x1fff)<<0)
+#define v_WIN2_VIR_STRIDE1(x)		(((x)&0x1fff)<<16)
+#define m_WIN2_VIR_STRIDE0		(0x1fff<<0)
+#define m_WIN2_VIR_STRIDE1		(0x1fff<<16)
+
+#define WIN2_VIR2_3 			(0x00bc)
+#define v_WIN2_VIR_STRIDE2(x)		(((x)&0x1fff)<<0)
+#define v_WIN2_VIR_STRIDE3(x)		(((x)&0x1fff)<<16)
+#define m_WIN2_VIR_STRIDE2		(0x1fff<<0)
+#define m_WIN2_VIR_STRIDE3		(0x1fff<<16)
+
+#define WIN2_MST0 			(0x00c0)
+#define WIN2_DSP_INFO0 			(0x00c4)
+#define v_WIN2_DSP_WIDTH0(x)		(((x-1)&0xfff)<<0)
+#define v_WIN2_DSP_HEIGHT0(x)		(((x-1)&0xfff)<<16)
+#define m_WIN2_DSP_WIDTH0		(0xfff<<0)
+#define m_WIN2_DSP_HEIGHT0		(0xfff<<16)
+
+#define WIN2_DSP_ST0 			(0x00c8)
+#define v_WIN2_DSP_XST0(x)		(((x)&0x1fff)<<0)
+#define v_WIN2_DSP_YST0(x)		(((x)&0x1fff)<<16)
+#define m_WIN2_DSP_XST0			(0x1fff<<0)
+#define m_WIN2_DSP_YST0			(0x1fff<<16)
+
+#define WIN2_COLOR_KEY 			(0x00cc)
+#define v_WIN2_COLOR_KEY(x)		(((x)&0xffffff)<<0)
+#define v_WIN2_KEY_EN(x)		(((x)&1)<<24)
+#define m_WIN2_COLOR_KEY		(0xffffff<<0)
+#define m_WIN2_KEY_EN			((u32)1<<24)
+
+
+#define WIN2_MST1               	(0x00d0) 
+#define WIN2_DSP_INFO1 			(0x00d4)
+#define v_WIN2_DSP_WIDTH1(x)		(((x-1)&0xfff)<<0)
+#define v_WIN2_DSP_HEIGHT1(x)		(((x-1)&0xfff)<<16)
+
+#define m_WIN2_DSP_WIDTH1		(0xfff<<0)
+#define m_WIN2_DSP_HEIGHT1		(0xfff<<16)
+
+#define WIN2_DSP_ST1 	        	(0x00d8)
+#define v_WIN2_DSP_XST1(x)		(((x)&0x1fff)<<0)
+#define v_WIN2_DSP_YST1(x)		(((x)&0x1fff)<<16)
+
+#define m_WIN2_DSP_XST1			(0x1fff<<0)
+#define m_WIN2_DSP_YST1			(0x1fff<<16)
+
+#define WIN2_SRC_ALPHA_CTRL 		(0x00dc)
+#define v_WIN2_SRC_ALPHA_EN(x)		(((x)&1)<<0)
+#define v_WIN2_SRC_COLOR_M0(x)		(((x)&1)<<1)
+#define v_WIN2_SRC_ALPHA_M0(x)		(((x)&1)<<2)
+#define v_WIN2_SRC_BLEND_M0(x)		(((x)&3)<<3)
+#define v_WIN2_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
+#define v_WIN2_SRC_FACTOR_M0(x)		(((x)&7)<<6)
+#define v_WIN2_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
+#define v_WIN2_FADING_VALUE(x)          (((x)&0xff)<<24)
+
+
+#define m_WIN2_SRC_ALPHA_EN 		(1<<0)
+#define m_WIN2_SRC_COLOR_M0 		(1<<1)
+#define m_WIN2_SRC_ALPHA_M0 		(1<<2)
+#define m_WIN2_SRC_BLEND_M0		(3<<3)
+#define m_WIN2_SRC_ALPHA_CAL_M0		(1<<5)
+#define m_WIN2_SRC_FACTOR_M0		(7<<6)
+#define m_WIN2_SRC_GLOBAL_ALPHA		(0xff<<16)
+#define m_WIN2_FADING_VALUE		(0xff<<24)
+
+#define WIN2_MST2 			(0x00e0)
+#define WIN2_DSP_INFO2 			(0x00e4)
+#define v_WIN2_DSP_WIDTH2(x)		(((x-1)&0xfff)<<0)
+#define v_WIN2_DSP_HEIGHT2(x)		(((x-1)&0xfff)<<16)
+
+#define m_WIN2_DSP_WIDTH2 		(0xfff<<0)
+#define m_WIN2_DSP_HEIGHT2 		(0xfff<<16)
+
+
+#define WIN2_DSP_ST2 			(0x00e8)
+#define v_WIN2_DSP_XST2(x)		(((x)&0x1fff)<<0)
+#define v_WIN2_DSP_YST2(x)		(((x)&0x1fff)<<16)
+#define m_WIN2_DSP_XST2 		(0x1fff<<0)
+#define m_WIN2_DSP_YST2 		(0x1fff<<16)
+
+#define WIN2_DST_ALPHA_CTRL 		(0x00ec)
+#define v_WIN2_DST_FACTOR_M0(x)		(((x)&7)<<6)
+#define m_WIN2_DST_FACTOR_M0		(7<<6)
+
+#define WIN2_MST3 			(0x00f0)
+#define WIN2_DSP_INFO3 			(0x00f4)
+#define v_WIN2_DSP_WIDTH3(x)		(((x-1)&0xfff)<<0)
+#define v_WIN2_DSP_HEIGHT3(x)		(((x-1)&0xfff)<<16)
+#define m_WIN2_DSP_WIDTH3		(0xfff<<0)
+#define m_WIN2_DSP_HEIGHT3		(0xfff<<16)
+
+#define WIN2_DSP_ST3 			(0x00f8)
+#define v_WIN2_DSP_XST3(x)		(((x)&0x1fff)<<0)
+#define v_WIN2_DSP_YST3(x)		(((x)&0x1fff)<<16)
+#define m_WIN2_DSP_XST3 		(0x1fff<<0)
+#define m_WIN2_DSP_YST3 		(0x1fff<<16)
+
+#define WIN2_FADING_CTRL 		(0x00fc)
+#define v_WIN2_FADING_OFFSET_R(x)	(((x)&0xff)<<0)
+#define v_WIN2_FADING_OFFSET_G(x)	(((x)&0xff)<<8)
+#define v_WIN2_FADING_OFFSET_B(x)	(((x)&0xff)<<16)
+#define v_WIN2_FADING_EN(x)		(((x)&1)<<24)
+
+#define m_WIN2_FADING_OFFSET_R 		(0xff<<0)
+#define m_WIN2_FADING_OFFSET_G 		(0xff<<8)
+#define m_WIN2_FADING_OFFSET_B 		(0xff<<16)
+#define m_WIN2_FADING_EN		(1<<24)
+
+/*win3 register*/
+#define WIN3_CTRL0 			(0x0100)
+#define v_WIN3_EN(x)			(((x)&1)<<0)
+#define v_WIN3_DATA_FMT(x)		(((x)&7)<<1)
+#define v_WIN3_MST0_EN(x)		(((x)&1)<<4)
+#define v_WIN3_MST1_EN(x)		(((x)&1)<<5)
+#define v_WIN3_MST2_EN(x)		(((x)&1)<<6)
+#define v_WIN3_MST3_EN(x)		(((x)&1)<<7)
+#define v_WIN3_INTERLACE_READ(x)	(((x)&1)<<8)
+#define v_WIN3_NO_OUTSTANDING(x)	(((x)&1)<<9)
+#define v_WIN3_CSC_MODE(x)		(((x)&1)<<10)
+#define v_WIN3_RB_SWAP(x)		(((x)&1)<<12)
+#define v_WIN3_ALPHA_SWAP(x)		(((x)&1)<<13)
+#define v_WIN3_ENDIAN_MODE(x)		(((x)&1)<<14)
+#define v_WIN3_LUT_EN(x)		(((x)&1)<<18)
+
+#define m_WIN3_EN 			(1<<0)
+#define m_WIN3_DATA_FMT 		(7<<1)
+#define m_WIN3_MST0_EN 			(1<<4)
+#define m_WIN3_MST1_EN 			(1<<5)
+#define m_WIN3_MST2_EN 			(1<<6)
+#define m_WIN3_MST3_EN 			(1<<7)
+#define m_WIN3_INTERLACE_READ 		(1<<8)
+#define m_WIN3_NO_OUTSTANDING 		(1<<9)
+#define m_WIN3_CSC_MODE 		(1<<10)
+#define m_WIN3_RB_SWAP 			(1<<12)
+#define m_WIN3_ALPHA_SWAP 		(1<<13)
+#define m_WIN3_ENDIAN_MODE 		(1<<14)
+#define m_WIN3_LUT_EN 			(1<<18)
+
+
+#define WIN3_CTRL1 			(0x0104)
+#define v_WIN3_AXI_GATHER_EN(x)		(((x)&1)<<0)
+#define v_WIN3_AXI_GATHER_NUM(x)	(((x)&0xf)<<4)
+#define m_WIN3_AXI_GATHER_EN 		(1<<0)
+#define m_WIN3_AXI_GATHER_NUM 		(0xf<<4)
+
+#define WIN3_VIR0_1 			(0x0108)
+#define v_WIN3_VIR_STRIDE0(x)		(((x)&0x1fff)<<0)
+#define v_WIN3_VIR_STRIDE1(x)		(((x)&0x1fff)<<16)
+#define m_WIN3_VIR_STRIDE0 		(0x1fff<<0)
+#define m_WIN3_VIR_STRIDE1 		(0x1fff<<16)
+
+#define WIN3_VIR2_3 			(0x010c)
+#define v_WIN3_VIR_STRIDE2(x)		(((x)&0x1fff)<<0)
+#define v_WIN3_VIR_STRIDE3(x)		(((x)&0x1fff)<<16)
+#define m_WIN3_VIR_STRIDE2		(0x1fff<<0)
+#define m_WIN3_VIR_STRIDE3		(0x1fff<<16)
+
+#define WIN3_MST0 	        	(0x0110)
+#define WIN3_DSP_INFO0 			(0x0114)
+#define v_WIN3_DSP_WIDTH0(x)		(((x-1)&0xfff)<<0)
+#define v_WIN3_DSP_HEIGHT0(x)		(((x-1)&0xfff)<<16)
+#define m_WIN3_DSP_WIDTH0 		(0xfff<<0)
+#define m_WIN3_DSP_HEIGHT0 		(0xfff<<16)
+
+#define WIN3_DSP_ST0 			(0x0118)
+#define v_WIN3_DSP_XST0(x)		(((x)&0x1fff)<<0)
+#define v_WIN3_DSP_YST0(x)		(((x)&0x1fff)<<16)
+#define m_WIN3_DSP_XST0			(0x1fff<<0)
+#define m_WIN3_DSP_YST0			(0x1fff<<16)
+
+#define WIN3_COLOR_KEY 			(0x011c)
+#define v_WIN3_COLOR_KEY(x)		(((x)&0xffffff)<<0)
+#define v_WIN3_KEY_EN(x)		(((x)&1)<<24)
+#define m_WIN3_COLOR_KEY		(0xffffff<<0)
+#define m_WIN3_KEY_EN			((u32)1<<24)
+
+#define WIN3_MST1 			(0x0120)
+#define WIN3_DSP_INFO1 			(0x0124)
+#define v_WIN3_DSP_WIDTH1(x)		(((x-1)&0xfff)<<0)
+#define v_WIN3_DSP_HEIGHT1(x)		(((x-1)&0xfff)<<16)
+#define m_WIN3_DSP_WIDTH1 		(0xfff<<0)
+#define m_WIN3_DSP_HEIGHT1 		(0xfff<<16)
+
+#define WIN3_DSP_ST1 			(0x0128)
+#define v_WIN3_DSP_XST1(x)		(((x)&0x1fff)<<0)
+#define v_WIN3_DSP_YST1(x)		(((x)&0x1fff)<<16)
+#define m_WIN3_DSP_XST1			(0x1fff<<0)
+#define m_WIN3_DSP_YST1			(0x1fff<<16)
+
+#define WIN3_SRC_ALPHA_CTRL 		(0x012c)
+#define v_WIN3_SRC_ALPHA_EN(x)		(((x)&1)<<0)
+#define v_WIN3_SRC_COLOR_M0(x)		(((x)&1)<<1)
+#define v_WIN3_SRC_ALPHA_M0(x)		(((x)&1)<<2)
+#define v_WIN3_SRC_BLEND_M0(x)		(((x)&3)<<3)
+#define v_WIN3_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
+#define v_WIN3_SRC_FACTOR_M0(x)		(((x)&7)<<6)
+#define v_WIN3_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
+#define v_WIN3_FADING_VALUE(x)          (((x)&0xff)<<24)
+
+#define m_WIN3_SRC_ALPHA_EN 		(1<<0)
+#define m_WIN3_SRC_COLOR_M0 		(1<<1)
+#define m_WIN3_SRC_ALPHA_M0 		(1<<2)
+#define m_WIN3_SRC_BLEND_M0		(3<<3)
+#define m_WIN3_SRC_ALPHA_CAL_M0		(1<<5)
+#define m_WIN3_SRC_FACTOR_M0		(7<<6)
+#define m_WIN3_SRC_GLOBAL_ALPHA		(0xff<<16)
+#define m_WIN3_FADING_VALUE		(0xff<<24)
+
+#define WIN3_MST2 			(0x0130)
+#define WIN3_DSP_INFO2 			(0x0134)
+#define v_WIN3_DSP_WIDTH2(x)		(((x-1)&0xfff)<<0)
+#define v_WIN3_DSP_HEIGHT2(x)		(((x-1)&0xfff)<<16)
+#define m_WIN3_DSP_WIDTH2		(0xfff<<0)
+#define m_WIN3_DSP_HEIGHT2		(0xfff<<16)
+
+#define WIN3_DSP_ST2 			(0x0138)
+#define v_WIN3_DSP_XST2(x)		(((x)&0x1fff)<<0)
+#define v_WIN3_DSP_YST2(x)		(((x)&0x1fff)<<16)
+#define m_WIN3_DSP_XST2			(0x1fff<<0)
+#define m_WIN3_DSP_YST2			(0x1fff<<16)
+
+#define WIN3_DST_ALPHA_CTRL 		(0x013c)
+#define v_WIN3_DST_FACTOR_M0(x)		(((x)&7)<<6)
+#define m_WIN3_DST_FACTOR_M0		(7<<6)
+
+
+#define WIN3_MST3 			(0x0140)
+#define WIN3_DSP_INFO3 			(0x0144)
+#define v_WIN3_DSP_WIDTH3(x)		(((x-1)&0xfff)<<0)
+#define v_WIN3_DSP_HEIGHT3(x)		(((x-1)&0xfff)<<16)
+#define m_WIN3_DSP_WIDTH3		(0xfff<<0)
+#define m_WIN3_DSP_HEIGHT3		(0xfff<<16)
+
+#define WIN3_DSP_ST3 			(0x0148)
+#define v_WIN3_DSP_XST3(x)		(((x)&0x1fff)<<0)
+#define v_WIN3_DSP_YST3(x)		(((x)&0x1fff)<<16)
+#define m_WIN3_DSP_XST3			(0x1fff<<0)
+#define m_WIN3_DSP_YST3			(0x1fff<<16)
+
+#define WIN3_FADING_CTRL 		(0x014c)
+#define v_WIN3_FADING_OFFSET_R(x)	(((x)&0xff)<<0)
+#define v_WIN3_FADING_OFFSET_G(x)	(((x)&0xff)<<8)
+#define v_WIN3_FADING_OFFSET_B(x)	(((x)&0xff)<<16)
+#define v_WIN3_FADING_EN(x)		(((x)&1)<<24)
+
+#define m_WIN3_FADING_OFFSET_R 		(0xff<<0)
+#define m_WIN3_FADING_OFFSET_G 		(0xff<<8)
+#define m_WIN3_FADING_OFFSET_B 		(0xff<<16)
+#define m_WIN3_FADING_EN		(1<<24)
+
+
+/*hwc register*/
+#define HWC_CTRL0 			(0x0150)
+#define v_HWC_EN(x)			(((x)&1)<<0)
+#define v_HWC_DATA_FMT(x)		(((x)&7)<<1)
+#define v_HWC_MODE(x)			(((x)&1)<<4)
+#define v_HWC_SIZE(x)			(((x)&3)<<5)
+#define v_HWC_INTERLACE_READ(x)		(((x)&1)<<8)
+#define v_HWC_NO_OUTSTANDING(x)		(((x)&1)<<9)
+#define v_HWC_CSC_MODE(x)		(((x)&1)<<10)
+#define v_HWC_RB_SWAP(x)		(((x)&1)<<12)
+#define v_HWC_ALPHA_SWAP(x)		(((x)&1)<<13)
+#define v_HWC_ENDIAN_MODE(x)		(((x)&1)<<14)
+#define v_HWC_LUT_EN(x)			(((x)&1)<<18)
+
+#define m_HWC_EN			(1<<0)
+#define m_HWC_DATA_FMT			(7<<1)
+#define m_HWC_MODE			(1<<4)
+#define m_HWC_SIZE			(3<<5)
+#define m_HWC_INTERLACE_READ 		(1<<8)
+#define m_HWC_NO_OUTSTANDING		(1<<9)
+#define m_HWC_CSC_MODE			(1<<10)
+#define m_HWC_RB_SWAP			(1<<12)
+#define m_HWC_ALPHA_SWAP		(1<<13)
+#define m_HWC_ENDIAN_MODE		(1<<14)
+#define m_HWC_LUT_EN			(1<<18)
+
+
+#define HWC_CTRL1 			(0x0154)
+#define v_HWC_AXI_GATHER_EN(x)		(((x)&1)<<0)
+#define v_HWC_AXI_GATHER_NUM(x)		(((x)&7)<<4)
+#define m_HWC_AXI_GATHER_EN		(1<<0)
+#define m_HWC_AXI_GATHER_NUM		(7<<4)
+
+#define HWC_MST 			(0x0158)
+#define HWC_DSP_ST 			(0x015c)
+#define v_HWC_DSP_XST(x)		(((x)&0x1fff)<<0)
+#define v_HWC_DSP_YST(x)		(((x)&0x1fff)<<16)
+#define m_HWC_DSP_XST			(0x1fff<<0)
+#define m_HWC_DSP_YST			(0x1fff<<16)
+
+#define HWC_SRC_ALPHA_CTRL		(0x0160)
+#define v_HWC_SRC_ALPHA_EN(x)		(((x)&1)<<0)
+#define v_HWC_SRC_COLOR_M0(x)		(((x)&1)<<1)
+#define v_HWC_SRC_ALPHA_M0(x)		(((x)&1)<<2)
+#define v_HWC_SRC_BLEND_M0(x)		(((x)&3)<<3)
+#define v_HWC_SRC_ALPHA_CAL_M0(x)	(((x)&1)<<5)
+#define v_HWC_SRC_FACTOR_M0(x)		(((x)&7)<<6)
+#define v_HWC_SRC_GLOBAL_ALPHA(x)	(((x)&0xff)<<16)
+#define v_HWC_FADING_VALUE(x)           (((x)&0xff)<<24)
+
+#define m_HWC_SRC_ALPHA_EN 		(1<<0)
+#define m_HWC_SRC_COLOR_M0 		(1<<1)
+#define m_HWC_SRC_ALPHA_M0 		(1<<2)
+#define m_HWC_SRC_BLEND_M0		(3<<3)
+#define m_HWC_SRC_ALPHA_CAL_M0		(1<<5)
+#define m_HWC_SRC_FACTOR_M0		(7<<6)
+#define m_HWC_SRC_GLOBAL_ALPHA		(0xff<<16)
+#define m_HWC_FADING_VALUE		(0xff<<24)
+
+#define HWC_DST_ALPHA_CTRL 		(0x0164)
+#define v_HWC_DST_FACTOR_M0(x)		(((x)&7)<<6)
+#define m_HWC_DST_FACTOR_M0		(7<<6)
+
+
+#define HWC_FADING_CTRL 		(0x0168)
+#define v_HWC_FADING_OFFSET_R(x)        (((x)&0xff)<<0)
+#define v_HWC_FADING_OFFSET_G(x)        (((x)&0xff)<<8)
+#define v_HWC_FADING_OFFSET_B(x)        (((x)&0xff)<<16)
+#define v_HWC_FADING_EN(x)	        (((x)&1)<<24)
+
+#define m_HWC_FADING_OFFSET_R 	        (0xff<<0)
+#define m_HWC_FADING_OFFSET_G 	        (0xff<<8)
+#define m_HWC_FADING_OFFSET_B 	        (0xff<<16)
+#define m_HWC_FADING_EN                 (1<<24)
+
+/*post process register*/
+#define POST_DSP_HACT_INFO 		(0x0170)
+#define v_DSP_HACT_END_POST(x)		(((x)&0x1fff)<<0)
+#define v_DSP_HACT_ST_POST(x)		(((x)&0x1fff)<<16)
+#define m_DSP_HACT_END_POST		(0x1fff<<0)
+#define m_DSP_HACT_ST_POST		(0x1fff<<16)
+
+#define POST_DSP_VACT_INFO 		(0x0174)
+#define v_DSP_VACT_END_POST(x)		(((x)&0x1fff)<<0)
+#define v_DSP_VACT_ST_POST(x)		(((x)&0x1fff)<<16)
+#define m_DSP_VACT_END_POST		(0x1fff<<0)
+#define m_DSP_VACT_ST_POST		(0x1fff<<16)
+
+#define POST_SCL_FACTOR_YRGB 		(0x0178)
+#define v_POST_HS_FACTOR_YRGB(x)	(((x)&0xffff)<<0)
+#define v_POST_VS_FACTOR_YRGB(x)	(((x)&0xffff)<<16)
+#define m_POST_HS_FACTOR_YRGB		(0xffff<<0)
+#define m_POST_VS_FACTOR_YRGB		(0xffff<<16)
+
+#define POST_SCL_CTRL 			(0x0180)
+#define v_POST_HOR_SD_EN(x)		(((x)&1)<<0)
+#define v_POST_VER_SD_EN(x)		(((x)&1)<<1)
+
+#define m_POST_HOR_SD_EN		(0x1<<0)
+#define m_POST_VER_SD_EN		(0x1<<1)
+
+#define POST_DSP_VACT_INFO_F1 		(0x0184)
+#define v_DSP_VACT_END_POST_F1(x)       (((x)&0x1fff)<<0)
+#define v_DSP_VACT_ST_POST_F1(x)        (((x)&0x1fff)<<16)
+
+#define m_DSP_VACT_END_POST_F1          (0x1fff<<0)
+#define m_DSP_VACT_ST_POST_F1           (0x1fff<<16)
+
+#define DSP_HTOTAL_HS_END 		(0x0188)
+#define v_DSP_HS_PW(x)			(((x)&0x1fff)<<0)
+#define v_DSP_HTOTAL(x)			(((x)&0x1fff)<<16)
+#define m_DSP_HS_PW			(0x1fff<<0)
+#define m_DSP_HTOTAL			(0x1fff<<16)
+
+#define DSP_HACT_ST_END 		(0x018c)
+#define v_DSP_HACT_END(x)		(((x)&0x1fff)<<0)
+#define v_DSP_HACT_ST(x)		(((x)&0x1fff)<<16)
+#define m_DSP_HACT_END			(0x1fff<<0)
+#define m_DSP_HACT_ST			(0x1fff<<16)
+
+#define DSP_VTOTAL_VS_END 		(0x0190)
+#define v_DSP_VS_PW(x)			(((x)&0x1fff)<<0)
+#define v_DSP_VTOTAL(x)			(((x)&0x1fff)<<16)
+#define m_DSP_VS_PW			(0x1fff<<0)
+#define m_DSP_VTOTAL			(0x1fff<<16)
+
+#define DSP_VACT_ST_END 		(0x0194)
+#define v_DSP_VACT_END(x)		(((x)&0x1fff)<<0)
+#define v_DSP_VACT_ST(x)		(((x)&0x1fff)<<16)
+#define m_DSP_VACT_END			(0x1fff<<0)
+#define m_DSP_VACT_ST			(0x1fff<<16)
+
+#define DSP_VS_ST_END_F1 		(0x0198)
+#define v_DSP_VS_END_F1(x)		(((x)&0x1fff)<<0)
+#define v_DSP_VS_ST_F1(x)		(((x)&0x1fff)<<16)
+#define m_DSP_VS_END_F1			(0x1fff<<0)
+#define m_DSP_VS_ST_F1			(0x1fff<<16)
+
+#define DSP_VACT_ST_END_F1 		(0x019c)
+#define v_DSP_VACT_END_F1(x)		(((x)&0x1fff)<<0)
+#define v_DSP_VAC_ST_F1(x)		(((x)&0x1fff)<<16)
+#define m_DSP_VACT_END_F1		(0x1fff<<0)
+#define m_DSP_VAC_ST_F1			(0x1fff<<16)
+
+
+/*pwm register*/
+#define PWM_CTRL 			(0x01a0)
+#define v_PWM_EN(x)			(((x)&1)<<0)
+#define v_PWM_MODE(x)		        (((x)&3)<<1)
+
+#define v_DUTY_POL(x)		        (((x)&1)<<3)
+#define v_INACTIVE_POL(x)		(((x)&1)<<4)
+#define v_OUTPUT_MODE(x)		(((x)&1)<<5)
+#define v_BL_EN(x)			(((x)&1)<<8)
+#define v_CLK_SEL(x)		        (((x)&1)<<9)
+#define v_PRESCALE(x)		        (((x)&7)<<12)
+#define v_SCALE(x)			(((x)&0xff)<<16)
+#define v_RPT(x)			(((x)&0xff)<<24)
+
+#define m_PWM_EN			(1<<0)
+#define m_PWM_MODE			(3<<1)
+
+#define m_DUTY_POL			(1<<3)
+#define m_INACTIVE_POL		        (1<<4)
+#define m_OUTPUT_MODE		        (1<<5)
+#define m_BL_EN			        (1<<8)
+#define m_CLK_SEL			(1<<9)
+#define m_PRESCALE			(7<<12)
+#define m_SCALE		        	(0xff<<16)
+#define m_RPT		           	((u32)0xff<<24)
+
+#define PWM_PERIOD_HPR 			(0x01a4)
+#define PWM_DUTY_LPR  			(0x01a8)
+#define PWM_CNT 			(0x01ac)
+
+/*BCSH register*/
+#define BCSH_COLOR_BAR 			(0x01b0)
+#define v_BCSH_EN(x)			(((x)&1)<<0)
+#define v_BCSH_COLOR_BAR_Y(x)		(((x)&0x3ff)<<2)
+#define v_BCSH_COLOR_BAR_U(x)		(((x)&0x3ff)<<12)
+#define v_BCSH_COLOR_BAR_V(x)		(((x)&0x3ff)<<22)
+
+#define m_BCSH_EN			(1<<0)
+#define m_BCSH_COLOR_BAR_Y		(0x3ff<<2)
+#define m_BCSH_COLOR_BAR_U		(0x3ff<<12)
+#define m_BCSH_COLOR_BAR_V		((u32)0x3ff<<22)
+
+#define BCSH_BCS 			(0x01b4)
+#define v_BCSH_BRIGHTNESS(x)		(((x)&0xff)<<0)	
+#define v_BCSH_CONTRAST(x)		(((x)&0x1ff)<<8)	
+#define v_BCSH_SAT_CON(x)		(((x)&0x3ff)<<20)	
+#define v_BCSH_OUT_MODE(x)		(((x)&0x3)<<30)	
+
+#define m_BCSH_BRIGHTNESS		(0xff<<0)	
+#define m_BCSH_CONTRAST			(0x1ff<<8)
+#define m_BCSH_SAT_CON			(0x3ff<<20)	
+#define m_BCSH_OUT_MODE			((u32)0x3<<30)	
+
+
+#define BCSH_H 				(0x01b8) 
+#define v_BCSH_SIN_HUE(x)		(((x)&0x1ff)<<0)
+#define v_BCSH_COS_HUE(x)		(((x)&0x1ff)<<16)
+
+#define m_BCSH_SIN_HUE			(0x1ff<<0)
+#define m_BCSH_COS_HUE			(0x1ff<<16)
+
+#define BCSH_CTRL			(0x01bc)
+#define v_BCSH_Y2R_EN(x)		(((x)&0x1)<<0)
+#define v_BCSH_R2Y_EN(x)		(((x)&0x1)<<4)
+#define m_BCSH_Y2R_EN			(0x1<<0)
+#define m_BCSH_R2Y_EN			(0x1<<4)
+
+#define CABC_CTRL0			(0x01c0)
+#define v_CABC_EN(x)				(((x)&1)<<0)
+#define v_CABC_HANDLE_EN(x)			(((x)&1)<<1)
+#define v_PWM_CONFIG_MODE(x)			(((x)&3)<<2)
+#define v_CABC_CALC_PIXEL_NUM(x)		(((x)&0x7fffff)<<4)
+#define m_CABC_EN				(1<<0)
+#define m_CABC_HANDLE_EN			(1<<1)
+#define m_PWM_CONFIG_MODE			(3<<2)
+#define m_CABC_CALC_PIXEL_NUM			(0x7fffff<<4)
+
+#define CABC_CTRL1			(0x01c4)
+#define v_CABC_LUT_EN(x)			(((x)&1)<<0)
+#define v_CABC_TOTAL_PIXEL_NUM(x)		(((x)&0x7fffff)<<4)
+#define m_CABC_LUT_EN				(1<<0)
+#define m_CABC_TOTAL_PIXEL_NUM			(0x7fffff<<4)
+
+#define CABC_GAUSS_LINE0_0 		(0x01c8)
+#define CABC_GAUSS_LINE0_1 		(0x01cc)
+#define CABC_GAUSS_LINE1_0 		(0x01d0)
+#define CABC_GAUSS_LINE1_1 		(0x01d4)
+#define CABC_GAUSS_LINE2_0 		(0x01d8)
+#define CABC_GAUSS_LINE2_1 		(0x01dc)
+
+/*FRC register*/
+#define FRC_LOWER01_0 			(0x01e0)
+#define FRC_LOWER01_1 			(0x01e4)
+#define FRC_LOWER10_0 			(0x01e8)
+#define FRC_LOWER10_1 			(0x01ec)
+#define FRC_LOWER11_0 			(0x01f0)
+#define FRC_LOWER11_1 			(0x01f4)
+
+#define CABC_CTRL2			(0x01f8)
+#define v_CABC_STAGE_DOWN(x)			(((x)&0xff)<<0)
+#define v_CABC_STAGE_UP(x)			(((x)&0x1ff)<<8)
+#define v_CABC_STAGE_MODE(x)			(((x)&1)<<19)
+#define v_MAX_SCALE_CFG_VALUE(x)		(((x)&0x1ff)<<20)
+#define v_MAX_SCALE_CFG_ENABLE(x)		(((x)&1)<<31)
+#define m_CABC_STAGE_DOWN			(0xff<<0)
+#define m_CABC_STAGE_UP				(0x1ff<<8)
+#define m_CABC_STAGE_MODE			(1<<19)
+#define m_MAX_SCALE_CFG_VALUE			(0x1ff<<20)
+#define m_MAX_SCALE_CFG_ENABLE			(1<<31)
+
+#define CABC_CTRL3			(0x01fc)
+#define v_CABC_GLOBAL_DN(x)			(((x)&0xff)<<0)
+#define v_CABC_GLOBAL_DN_LIMIT_EN(x)		(((x)&1)<<8)
+#define m_CABC_GLOBAL_DN			(0xff<<0)
+#define m_CABC_GLOBAL_DN_LIMIT_EN		(1<<8)
+
+#define MMU_DTE_ADDR			(0x0300)
+#define v_MMU_DTE_ADDR(x)		(((x)&0xffffffff)<<0)
+#define m_MMU_DTE_ADDR			(0xffffffff<<0)
+
+#define MMU_STATUS			(0x0304)
+#define v_PAGING_ENABLED(x)		(((x)&1)<<0)
+#define v_PAGE_FAULT_ACTIVE(x)		(((x)&1)<<1)
+#define v_STAIL_ACTIVE(x)		(((x)&1)<<2)
+#define v_MMU_IDLE(x)			(((x)&1)<<3)
+#define v_REPLAY_BUFFER_EMPTY(x)	(((x)&1)<<4)
+#define v_PAGE_FAULT_IS_WRITE(x)	(((x)&1)<<5)
+#define v_PAGE_FAULT_BUS_ID(x)		(((x)&0x1f)<<6)
+#define m_PAGING_ENABLED		(1<<0)
+#define m_PAGE_FAULT_ACTIVE		(1<<1)
+#define m_STAIL_ACTIVE			(1<<2)
+#define m_MMU_IDLE			(1<<3)
+#define m_REPLAY_BUFFER_EMPTY		(1<<4)
+#define m_PAGE_FAULT_IS_WRITE		(1<<5)
+#define m_PAGE_FAULT_BUS_ID		(0x1f<<6)
+
+#define MMU_COMMAND			(0x0308)
+#define v_MMU_CMD(x)			(((x)&0x3)<<0)
+#define m_MMU_CMD			(0x3<<0)
+
+#define MMU_PAGE_FAULT_ADDR		(0x030c)
+#define v_PAGE_FAULT_ADDR(x)		(((x)&0xffffffff)<<0)
+#define m_PAGE_FAULT_ADDR		(0xffffffff<<0)
+
+#define MMU_ZAP_ONE_LINE		(0x0310)
+#define v_MMU_ZAP_ONE_LINE(x)		(((x)&0xffffffff)<<0)
+#define m_MMU_ZAP_ONE_LINE		(0xffffffff<<0)
+
+#define MMU_INT_RAWSTAT			(0x0314)
+#define v_PAGE_FAULT_RAWSTAT(x)		(((x)&1)<<0)
+#define v_READ_BUS_ERROR_RAWSTAT(x)	(((x)&1)<<1)
+#define m_PAGE_FAULT_RAWSTAT		(1<<0)
+#define m_READ_BUS_ERROR_RAWSTAT	(1<<1)
+
+#define MMU_INT_CLEAR			(0x0318)
+#define v_PAGE_FAULT_CLEAR(x)		(((x)&1)<<0)
+#define v_READ_BUS_ERROR_CLEAR(x)	(((x)&1)<<1)
+#define m_PAGE_FAULT_CLEAR		(1<<0)
+#define m_READ_BUS_ERROR_CLEAR		(1<<1)
+
+#define MMU_INT_MASK			(0x031c)
+#define v_PAGE_FAULT_MASK(x)		(((x)&1)<<0)
+#define v_READ_BUS_ERROR_MASK(x)	(((x)&1)<<1)
+#define m_PAGE_FAULT_MASK		(1<<0)
+#define m_READ_BUS_ERROR_MASK		(1<<1)
+
+#define MMU_INT_STATUS			(0x0320)
+#define v_PAGE_FAULT_STATUS(x)		(((x)&1)<<0)
+#define v_READ_BUS_ERROR_STATUS(x)	(((x)&1)<<1)
+#define m_PAGE_FAULT_STATUS		(1<<0)
+#define m_READ_BUS_ERROR_STATUS		(1<<1)
+
+#define MMU_AUTO_GATING			(0x0324)
+#define v_MMU_AUTO_GATING(x)		(((x)&1)<<0)
+#define m_MMU_AUTO_GATING		(1<<0)
+
+#define WIN2_LUT_ADDR 			(0x0400)
+#define WIN3_LUT_ADDR  			(0x0800)
+#define HWC_LUT_ADDR   			(0x0c00)
+#define GAMMA_LUT_ADDR 			(0x1000)
+#define CABC_LUT_ADDR			(0x2000)
+#define MCU_BYPASS_WPORT 		(0x2200) 
+#define MCU_BYPASS_RPORT 		(0x2300)
+
+#define PWM_MODE_ONE_SHOT		(0x0)
+#define PWM_MODE_CONTINUOUS		(0x1)
+#define PWM_MODE_CAPTURE		(0x2)
+enum lb_mode {
+    LB_YUV_3840X5 = 0x0,
+    LB_YUV_2560X8 = 0x1,
+    LB_RGB_3840X2 = 0x2,
+    LB_RGB_2560X4 = 0x3,
+    LB_RGB_1920X5 = 0x4,
+    LB_RGB_1280X8 = 0x5 
+};
+
+enum sacle_up_mode {
+    SCALE_UP_BIL = 0x0,
+    SCALE_UP_BIC = 0x1
+};
+
+enum scale_down_mode {
+    SCALE_DOWN_BIL = 0x0,
+    SCALE_DOWN_AVG = 0x1
+};
+
+/*ALPHA BLENDING MODE*/
+enum alpha_mode {               /*  Fs       Fd */
+	AB_USER_DEFINE     = 0x0,
+	AB_CLEAR    	   = 0x1,/*  0          0*/
+	AB_SRC      	   = 0x2,/*  1          0*/
+	AB_DST    	   = 0x3,/*  0          1  */
+	AB_SRC_OVER   	   = 0x4,/*  1   	    1-As''*/
+	AB_DST_OVER    	   = 0x5,/*  1-Ad''   1*/
+	AB_SRC_IN    	   = 0x6,
+	AB_DST_IN    	   = 0x7,
+	AB_SRC_OUT    	   = 0x8,
+	AB_DST_OUT    	   = 0x9,
+	AB_SRC_ATOP        = 0xa,
+	AB_DST_ATOP    	   = 0xb,
+	XOR                = 0xc,
+	AB_SRC_OVER_GLOBAL = 0xd
+}; /*alpha_blending_mode*/
+
+enum src_alpha_mode {
+	AA_STRAIGHT	   = 0x0,
+	AA_INVERSE         = 0x1
+};/*src_alpha_mode*/
+
+enum global_alpha_mode {
+	AA_GLOBAL 	  = 0x0,
+	AA_PER_PIX        = 0x1,
+	AA_PER_PIX_GLOBAL = 0x2
+};/*src_global_alpha_mode*/
+
+enum src_alpha_sel {
+	AA_SAT		= 0x0,
+	AA_NO_SAT	= 0x1
+};/*src_alpha_sel*/
+
+enum src_color_mode {
+	AA_SRC_PRE_MUL	       = 0x0,
+	AA_SRC_NO_PRE_MUL      = 0x1
+};/*src_color_mode*/
+
+enum factor_mode {
+	AA_ZERO			= 0x0,
+	AA_ONE   	   	= 0x1,
+	AA_SRC			= 0x2,
+	AA_SRC_INVERSE          = 0x3,
+	AA_SRC_GLOBAL           = 0x4
+};/*src_factor_mode  &&  dst_factor_mode*/
+
+enum cabc_stage_mode {
+	LAST_FRAME_PWM_VAL	= 0x0,
+	CUR_FRAME_PWM_VAL	= 0x1,
+	STAGE_BY_STAGE		= 0x2
+};
+
+struct lcdc_device{
+	int id;
+	struct rk_lcdc_driver driver;
+	struct device *dev;
+	struct rk_screen *screen;
+
+	void __iomem *regs;
+	void *regsbak;			/*back up reg*/
+	u32 reg_phy_base;       	/* physical basic address of lcdc register*/
+	u32 len;               		/* physical map length of lcdc register*/
+	spinlock_t  reg_lock;		/*one time only one process allowed to config the register*/
+	
+	int __iomem *dsp_lut_addr_base;
+
+
+	int prop;			/*used for primary or extended display device*/
+	bool pre_init;
+	bool pwr18;			/*if lcdc use 1.8v power supply*/
+	bool clk_on;			/*if aclk or hclk is closed ,acess to register is not allowed*/
+	u8 atv_layer_cnt;		/*active layer counter,when  atv_layer_cnt = 0,disable lcdc*/
+	
+
+	unsigned int		irq;
+
+	struct clk		*pd;				/*lcdc power domain*/
+	struct clk		*hclk;				/*lcdc AHP clk*/
+	struct clk		*dclk;				/*lcdc dclk*/
+	struct clk		*aclk;				/*lcdc share memory frequency*/
+	u32 pixclock;	
+
+	u32 standby;						/*1:standby,0:wrok*/
+	u32 iommu_status;
+};
+
+struct alpha_config{
+	enum src_alpha_mode src_alpha_mode;       /*win0_src_alpha_m0*/
+	u32 src_global_alpha_val; /*win0_src_global_alpha*/
+	enum global_alpha_mode src_global_alpha_mode;/*win0_src_blend_m0*/
+	enum src_alpha_sel src_alpha_cal_m0;	 /*win0_src_alpha_cal_m0*/
+	enum src_color_mode src_color_mode;	 /*win0_src_color_m0*/
+	enum factor_mode src_factor_mode;	 /*win0_src_factor_m0*/
+	enum factor_mode dst_factor_mode;      /*win0_dst_factor_m0*/
+};
+
+struct lcdc_cabc_mode {
+	u32 pixel_num;			/* pixel precent number */
+	u16 stage_up;			/* up stride */
+	u16 stage_down;		/* down stride */
+};
+
+static inline void lcdc_writel(struct lcdc_device *lcdc_dev,u32 offset,u32 v)
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);	
+	*_pv = v;
+	writel_relaxed(v,lcdc_dev->regs+offset);	
+}
+
+static inline u32 lcdc_readl(struct lcdc_device *lcdc_dev,u32 offset)
+{
+	u32 v;
+	v = readl_relaxed(lcdc_dev->regs+offset);
+	return v;
+}
+
+static inline u32 lcdc_read_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk) 
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;
+	u32 _v = readl_relaxed(lcdc_dev->regs+offset); 
+	_pv += (offset >> 2);
+	*_pv = _v;
+       _v &= msk;
+       return (_v?1:0);   
+}
+
+static inline void  lcdc_set_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk) 
+{
+	u32* _pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);				
+	(*_pv) |= msk;				
+	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
+} 
+
+static inline void lcdc_clr_bit(struct lcdc_device *lcdc_dev,u32 offset,u32 msk)
+{
+	u32* _pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);				
+	(*_pv) &= (~msk);				
+	writel_relaxed(*_pv,lcdc_dev->regs + offset); 
+} 
+
+static inline void  lcdc_msk_reg(struct lcdc_device *lcdc_dev,u32 offset,u32 msk,u32 v)
+{
+	u32 *_pv = (u32*)lcdc_dev->regsbak;	
+	_pv += (offset >> 2);			
+	(*_pv) &= (~msk);				
+	(*_pv) |= v;				
+	writel_relaxed(*_pv,lcdc_dev->regs+offset);	
+}
+
+static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev) 
+{
+	writel_relaxed(0x01,lcdc_dev->regs+REG_CFG_DONE); 
+	dsb();	
+} 
+
+#define CUBIC_PRECISE  0
+#define CUBIC_SPLINE   1
+#define CUBIC_CATROM   2
+#define CUBIC_MITCHELL 3
+
+#define CUBIC_MODE_SELETION      CUBIC_PRECISE
+
+/*****************************************************************************************************/
+#define SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT   12   /* 4.12*/
+#define SCALE_FACTOR_BILI_DN_FIXPOINT(x)      ((INT32)((x)*(1 << SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT   16   /* 0.16*/
+
+#define SCALE_FACTOR_AVRG_FIXPOINT_SHIFT   16   /*0.16*/
+#define SCALE_FACTOR_AVRG_FIXPOINT(x)      ((INT32)((x)*(1 << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_BIC_FIXPOINT_SHIFT    16   /* 0.16*/
+#define SCALE_FACTOR_BIC_FIXPOINT(x)       ((INT32)((x)*(1 << SCALE_FACTOR_BIC_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT    12  /*NONE SCALE,vsd_bil*/
+#define SCALE_FACTOR_VSDBIL_FIXPOINT_SHIFT     12  /*VER SCALE DOWN BIL*/
+
+/*****************************************************************************************************/
+
+/*#define GET_SCALE_FACTOR_BILI(src, dst) ((((src) - 1) << SCALE_FACTOR_BILI_FIXPOINT_SHIFT) / ((dst) - 1))*/
+/*#define GET_SCALE_FACTOR_BIC(src, dst)  ((((src) - 1) << SCALE_FACTOR_BIC_FIXPOINT_SHIFT) / ((dst) - 1))*/
+/*modified by hpz*/
+#define GET_SCALE_FACTOR_BILI_DN(src, dst)  ((((src)*2 - 3) << (SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT-1)) / ((dst) - 1))
+#define GET_SCALE_FACTOR_BILI_UP(src, dst)  ((((src)*2 - 3) << (SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT-1)) / ((dst) - 1))
+#define GET_SCALE_FACTOR_BIC(src, dst)      ((((src)*2 - 3) << (SCALE_FACTOR_BIC_FIXPOINT_SHIFT-1)) / ((dst) - 1))
+
+/*****************************************************************/
+/*NOTE: hardware, srcH (srcH+vScaleDnMult-1)/vScaleDnMult; */
+#define GET_SCALE_DN_ACT_HEIGHT(srcH, vScaleDnMult) (((srcH)+(vScaleDnMult)-1)/(vScaleDnMult))
+
+/*#define VSKIP_MORE_PRECISE*/
+
+#ifdef VSKIP_MORE_PRECISE
+#define MIN_SCALE_FACTOR_AFTER_VSKIP        1.5f
+#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srcH, dstH, vScaleDnMult) \
+            (GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srcH), (vScaleDnMult)), (dstH)))
+#else
+#define MIN_SCALE_FACTOR_AFTER_VSKIP        1
+#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srcH, dstH, vScaleDnMult) \
+            ((GET_SCALE_DN_ACT_HEIGHT((srcH), (vScaleDnMult)) == (dstH))\
+                            ? (GET_SCALE_FACTOR_BILI_DN((srcH), (dstH))/(vScaleDnMult))\
+                            : GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srcH), (vScaleDnMult)), (dstH)))
+#endif
+/*****************************************************************/
+
+
+/*ScaleFactor must >= dst/src, or pixels at end of line may be unused*/
+/*ScaleFactor must < dst/(src-1), or dst buffer may overflow*/
+/*avrg old code:       ((((dst) << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT))/((src) - 1)) hxx_chgsrc*/
+/*modified by hpz:*/
+#define GET_SCALE_FACTOR_AVRG(src, dst)  ((((dst) << (SCALE_FACTOR_AVRG_FIXPOINT_SHIFT+1)))/(2*(src) - 1))
+
+/*****************************************************************************************************/
+/*Scale Coordinate Accumulate, x.16*/
+#define SCALE_COOR_ACC_FIXPOINT_SHIFT     16
+#define SCALE_COOR_ACC_FIXPOINT_ONE       (1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)
+#define SCALE_COOR_ACC_FIXPOINT(x)        ((INT32)((x)*(1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)))
+#define SCALE_COOR_ACC_FIXPOINT_REVERT(x) ((((x) >> (SCALE_COOR_ACC_FIXPOINT_SHIFT-1)) + 1) >> 1)
+
+#define SCALE_GET_COOR_ACC_FIXPOINT(scaleFactor, factorFixpointShift)  \
+        ((scaleFactor) << (SCALE_COOR_ACC_FIXPOINT_SHIFT - (factorFixpointShift)))
+
+
+/*****************************************************************************************************/
+/*CoarsePart of Scale Coordinate Accumulate, used for pixel mult-add factor, 0.8*/
+#define SCALE_FILTER_FACTOR_FIXPOINT_SHIFT     8
+#define SCALE_FILTER_FACTOR_FIXPOINT_ONE       (1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)
+#define SCALE_FILTER_FACTOR_FIXPOINT(x)        ((INT32)((x)*(1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)))
+#define SCALE_FILTER_FACTOR_FIXPOINT_REVERT(x) ((((x) >> (SCALE_FILTER_FACTOR_FIXPOINT_SHIFT-1)) + 1) >> 1)
+
+#define SCALE_GET_FILTER_FACTOR_FIXPOINT(coorAccumulate, coorAccFixpointShift) \
+  (((coorAccumulate)>>((coorAccFixpointShift)-SCALE_FILTER_FACTOR_FIXPOINT_SHIFT))&(SCALE_FILTER_FACTOR_FIXPOINT_ONE-1))
+
+#define SCALE_OFFSET_FIXPOINT_SHIFT            8
+#define SCALE_OFFSET_FIXPOINT(x)              ((INT32)((x)*(1 << SCALE_OFFSET_FIXPOINT_SHIFT)))
+
+u32 getHardWareVSkipLines(u32 srcH, u32 dstH)
+{
+    u32 vScaleDnMult;
+
+    if(srcH >= (u32)(4*dstH*MIN_SCALE_FACTOR_AFTER_VSKIP))
+    {
+        vScaleDnMult = 4;
+    }
+    else if(srcH >= (u32)(2*dstH*MIN_SCALE_FACTOR_AFTER_VSKIP))
+    {
+        vScaleDnMult = 2;
+    }
+    else
+    {
+        vScaleDnMult = 1;
+    }
+
+    return vScaleDnMult;
+}
+#endif
diff -Nupr a/drivers/video/rockchip/lcdc/rk3368_lcdc.c b/drivers/video/rockchip/lcdc/rk3368_lcdc.c
--- a/drivers/video/rockchip/lcdc/rk3368_lcdc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3368_lcdc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,5229 @@
+/*
+ * drivers/video/rockchip/lcdc/rk3368_lcdc.c
+ *
+ * Copyright (C) 2014 ROCKCHIP, Inc.
+ *Author:hjc<hjc@rock-chips.com>
+ *This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/rockchip-iovmm.h>
+#include <asm/div64.h>
+#include <linux/uaccess.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/grf.h>
+#include <dt-bindings/clock/rk_system_status.h>
+
+#include "rk3368_lcdc.h"
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+/*#define CONFIG_RK_FPGA 1*/
+
+static int dbg_thresd;
+module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
+
+#define DBG(level, x...) do {			\
+	if (unlikely(dbg_thresd >= level))	\
+		pr_info(x);\
+	} while (0)
+
+#define EARLY_TIME 500 /*us*/
+static struct rk_lcdc_win lcdc_win[] = {
+	[0] = {
+		.name = "win0",
+		.id = 0,
+		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_SCALE |
+					SUPPORT_YUV,
+		.property.max_input_x = 4096,
+		.property.max_input_y = 2304
+		},
+	[1] = {
+		.name = "win1",
+		.id = 1,
+		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_SCALE |
+					SUPPORT_YUV,
+		.property.max_input_x = 4096,
+		.property.max_input_y = 2304
+		},
+	[2] = {
+		.name = "win2",
+		.id = 2,
+		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_MULTI_AREA,
+		.property.max_input_x = 4096,
+		.property.max_input_y = 2304
+		},
+	[3] = {
+		.name = "win3",
+		.id = 3,
+		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_MULTI_AREA,
+		.property.max_input_x = 4096,
+		.property.max_input_y = 2304
+		},
+	[4] = {
+		.name = "hwc",
+		.id = 4,
+		.property.feature = SUPPORT_WIN_IDENTIFY | SUPPORT_HWC_LAYER,
+		.property.max_input_x = 128,
+		.property.max_input_y = 128
+		},
+};
+
+static int rk3368_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable);
+
+/*#define WAIT_FOR_SYNC 1*/
+u32 rk3368_get_hard_ware_vskiplines(u32 srch, u32 dsth)
+{
+	u32 vscalednmult;
+
+	if (srch >= (u32) (4 * dsth * MIN_SCALE_FACTOR_AFTER_VSKIP))
+		vscalednmult = 4;
+	else if (srch >= (u32) (2 * dsth * MIN_SCALE_FACTOR_AFTER_VSKIP))
+		vscalednmult = 2;
+	else
+		vscalednmult = 1;
+
+	return vscalednmult;
+}
+
+
+static int rk3368_set_cabc_lut(struct rk_lcdc_driver *dev_drv, int *cabc_lut)
+{
+	int i;
+	int __iomem *c;
+	u32 v;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	lcdc_msk_reg(lcdc_dev, CABC_CTRL1, m_CABC_LUT_EN,
+		     v_CABC_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	mdelay(25);
+	for (i = 0; i < 128; i++) {
+		v = cabc_lut[i];
+		c = lcdc_dev->cabc_lut_addr_base + i;
+		writel_relaxed(v, c);
+	}
+	lcdc_msk_reg(lcdc_dev, CABC_CTRL1, m_CABC_LUT_EN,
+		     v_CABC_LUT_EN(1));
+	return 0;
+}
+
+
+static int rk3368_lcdc_set_lut(struct rk_lcdc_driver *dev_drv, int *dsp_lut)
+{
+	int i;
+	int __iomem *c;
+	u32 v;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
+		     v_DSP_LUT_EN(0));
+	lcdc_cfg_done(lcdc_dev);
+	mdelay(25);
+	for (i = 0; i < 256; i++) {
+		v = dsp_lut[i];
+		c = lcdc_dev->dsp_lut_addr_base + i;
+		writel_relaxed(v, c);
+	}
+	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
+		     v_DSP_LUT_EN(1));
+
+	return 0;
+}
+
+static int rk3368_lcdc_clk_enable(struct lcdc_device *lcdc_dev)
+{
+#ifdef CONFIG_RK_FPGA
+	lcdc_dev->clk_on = 1;
+	return 0;
+#endif
+	if (!lcdc_dev->clk_on) {
+		clk_prepare_enable(lcdc_dev->hclk);
+		clk_prepare_enable(lcdc_dev->dclk);
+		clk_prepare_enable(lcdc_dev->aclk);
+		if (lcdc_dev->pd)
+			clk_prepare_enable(lcdc_dev->pd);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		pm_runtime_get_sync(lcdc_dev->dev);
+#endif
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 1;
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int rk3368_lcdc_clk_disable(struct lcdc_device *lcdc_dev)
+{
+#ifdef CONFIG_RK_FPGA
+	lcdc_dev->clk_on = 0;
+	return 0;
+#endif
+	if (lcdc_dev->clk_on) {
+		spin_lock(&lcdc_dev->reg_lock);
+		lcdc_dev->clk_on = 0;
+		spin_unlock(&lcdc_dev->reg_lock);
+		mdelay(25);
+		if (lcdc_dev->pd)
+			clk_disable_unprepare(lcdc_dev->pd);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		pm_runtime_put(lcdc_dev->dev);
+#endif
+		clk_disable_unprepare(lcdc_dev->dclk);
+		clk_disable_unprepare(lcdc_dev->hclk);
+		clk_disable_unprepare(lcdc_dev->aclk);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused
+	rk3368_lcdc_disable_irq(struct lcdc_device *lcdc_dev)
+{
+	u32 mask, val;
+	u32 intr_en_reg, intr_clr_reg;
+
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+		intr_clr_reg = INTR_CLEAR_RK3366;
+		intr_en_reg = INTR_EN_RK3366;
+	} else {
+		intr_clr_reg = INTR_CLEAR_RK3368;
+		intr_en_reg = INTR_EN_RK3368;
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		mask = m_FS_INTR_EN | m_FS_NEW_INTR_EN |
+		    m_ADDR_SAME_INTR_EN | m_LINE_FLAG0_INTR_EN |
+		    m_LINE_FLAG1_INTR_EN | m_BUS_ERROR_INTR_EN |
+		    m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN |
+		    m_WIN2_EMPTY_INTR_EN | m_WIN3_EMPTY_INTR_EN |
+		    m_HWC_EMPTY_INTR_EN | m_POST_BUF_EMPTY_INTR_EN |
+		    m_PWM_GEN_INTR_EN | m_DSP_HOLD_VALID_INTR_EN;
+		val = v_FS_INTR_EN(0) | v_FS_NEW_INTR_EN(0) |
+		    v_ADDR_SAME_INTR_EN(0) |
+		    v_LINE_FLAG0_INTR_EN(0) | v_LINE_FLAG1_INTR_EN(0) |
+		    v_BUS_ERROR_INTR_EN(0) | v_WIN0_EMPTY_INTR_EN(0) |
+		    v_WIN1_EMPTY_INTR_EN(0) | v_WIN2_EMPTY_INTR_EN(0) |
+		    v_WIN3_EMPTY_INTR_EN(0) | v_HWC_EMPTY_INTR_EN(0) |
+		    v_POST_BUF_EMPTY_INTR_EN(0) |
+		    v_PWM_GEN_INTR_EN(0) | v_DSP_HOLD_VALID_INTR_EN(0);
+		lcdc_msk_reg(lcdc_dev, intr_en_reg, mask, val);
+
+		mask = m_FS_INTR_CLR | m_FS_NEW_INTR_CLR |
+		    m_ADDR_SAME_INTR_CLR | m_LINE_FLAG0_INTR_CLR |
+		    m_LINE_FLAG1_INTR_CLR | m_BUS_ERROR_INTR_CLR |
+		    m_WIN0_EMPTY_INTR_CLR | m_WIN1_EMPTY_INTR_CLR |
+		    m_WIN2_EMPTY_INTR_CLR | m_WIN3_EMPTY_INTR_CLR |
+		    m_HWC_EMPTY_INTR_CLR | m_POST_BUF_EMPTY_INTR_CLR |
+		    m_PWM_GEN_INTR_CLR | m_DSP_HOLD_VALID_INTR_CLR;
+		val = v_FS_INTR_CLR(1) | v_FS_NEW_INTR_CLR(1) |
+		    v_ADDR_SAME_INTR_CLR(1) |
+		    v_LINE_FLAG0_INTR_CLR(1) | v_LINE_FLAG1_INTR_CLR(1) |
+		    v_BUS_ERROR_INTR_CLR(1) | v_WIN0_EMPTY_INTR_CLR(1) |
+		    v_WIN1_EMPTY_INTR_CLR(1) | v_WIN2_EMPTY_INTR_CLR(1) |
+		    v_WIN3_EMPTY_INTR_CLR(1) | v_HWC_EMPTY_INTR_CLR(1) |
+		    v_POST_BUF_EMPTY_INTR_CLR(1) |
+		    v_PWM_GEN_INTR_CLR(1) | v_DSP_HOLD_VALID_INTR_CLR(1);
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	mdelay(1);
+	return 0;
+}
+
+static int rk3368_lcdc_reg_dump(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int *cbase = (int *)lcdc_dev->regs;
+	int *regsbak = (int *)lcdc_dev->regsbak;
+	int i, j, val;
+	char dbg_message[30];
+	char buf[10];
+
+	pr_info("lcd back up reg:\n");
+	memset(dbg_message, 0, sizeof(dbg_message));
+	memset(buf, 0, sizeof(buf));
+	for (i = 0; i <= (0x200 >> 4); i++) {
+		val = sprintf(dbg_message, "0x%04x: ", i * 16);
+		for (j = 0; j < 4; j++) {
+			val = sprintf(buf, "%08x  ", *(regsbak + i * 4 + j));
+			strcat(dbg_message, buf);
+		}
+		pr_info("%s\n", dbg_message);
+		memset(dbg_message, 0, sizeof(dbg_message));
+		memset(buf, 0, sizeof(buf));
+	}
+
+	pr_info("lcdc reg:\n");
+	for (i = 0; i <= (0x200 >> 4); i++) {
+		val = sprintf(dbg_message, "0x%04x: ", i * 16);
+		for (j = 0; j < 4; j++) {
+			sprintf(buf, "%08x  ",
+				readl_relaxed(cbase + i * 4 + j));
+			strcat(dbg_message, buf);
+		}
+		pr_info("%s\n", dbg_message);
+		memset(dbg_message, 0, sizeof(dbg_message));
+		memset(buf, 0, sizeof(buf));
+	}
+
+	return 0;
+}
+
+#define WIN_EN(id)		\
+static int win##id##_enable(struct lcdc_device *lcdc_dev, int en)	\
+{ \
+	u32 msk, val;							\
+	spin_lock(&lcdc_dev->reg_lock);					\
+	msk =  m_WIN##id##_EN;						\
+	val  =  v_WIN##id##_EN(en);					\
+	lcdc_msk_reg(lcdc_dev, WIN##id##_CTRL0, msk, val);		\
+	lcdc_cfg_done(lcdc_dev);					\
+	spin_unlock(&lcdc_dev->reg_lock);				\
+	return 0;							\
+}
+
+WIN_EN(0);
+WIN_EN(1);
+WIN_EN(2);
+WIN_EN(3);
+/*enable/disable win directly*/
+static int rk3368_lcdc_win_direct_en(struct rk_lcdc_driver *drv,
+				     int win_id, int en)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(drv, struct lcdc_device, driver);
+	if (win_id == 0)
+		win0_enable(lcdc_dev, en);
+	else if (win_id == 1)
+		win1_enable(lcdc_dev, en);
+	else if (win_id == 2)
+		win2_enable(lcdc_dev, en);
+	else if (win_id == 3)
+		win3_enable(lcdc_dev, en);
+	else
+		dev_err(lcdc_dev->dev, "invalid win number:%d\n", win_id);
+	return 0;
+}
+
+#define SET_WIN_ADDR(id) \
+static int set_win##id##_addr(struct lcdc_device *lcdc_dev, u32 addr) \
+{							\
+	u32 msk, val;					\
+	spin_lock(&lcdc_dev->reg_lock);			\
+	lcdc_writel(lcdc_dev, WIN##id##_YRGB_MST, addr);	\
+	msk =  m_WIN##id##_EN;				\
+	val  =  v_WIN0_EN(1);				\
+	lcdc_msk_reg(lcdc_dev, WIN##id##_CTRL0, msk, val);	\
+	lcdc_cfg_done(lcdc_dev);			\
+	spin_unlock(&lcdc_dev->reg_lock);		\
+	return 0;					\
+}
+
+SET_WIN_ADDR(0);
+SET_WIN_ADDR(1);
+int rk3368_lcdc_direct_set_win_addr(struct rk_lcdc_driver *dev_drv,
+				    int win_id, u32 addr)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	if (win_id == 0)
+		set_win0_addr(lcdc_dev, addr);
+	else
+		set_win1_addr(lcdc_dev, addr);
+
+	return 0;
+}
+
+static void lcdc_read_reg_defalut_cfg(struct lcdc_device *lcdc_dev)
+{
+	int reg = 0;
+	u32 val = 0;
+	struct rk_screen *screen = lcdc_dev->driver.cur_screen;
+	u32 h_pw_bp = screen->mode.hsync_len + screen->mode.left_margin;
+	u32 v_pw_bp = screen->mode.vsync_len + screen->mode.upper_margin;
+	u32 st_x = 0, st_y = 0;
+	struct rk_lcdc_win *win0 = lcdc_dev->driver.win[0];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	for (reg = 0; reg < SCAN_LINE_NUM; reg += 4) {
+		val = lcdc_readl_backup(lcdc_dev, reg);
+		switch (reg) {
+		case VERSION_INFO:
+			lcdc_dev->soc_type = val;
+			break;
+		case WIN0_ACT_INFO:
+			win0->area[0].xact = (val & m_WIN0_ACT_WIDTH) + 1;
+			win0->area[0].yact =
+			    ((val & m_WIN0_ACT_HEIGHT) >> 16) + 1;
+			break;
+		case WIN0_DSP_INFO:
+			win0->area[0].xsize = (val & m_WIN0_DSP_WIDTH) + 1;
+			win0->area[0].ysize =
+			    ((val & m_WIN0_DSP_HEIGHT) >> 16) + 1;
+			break;
+		case WIN0_DSP_ST:
+			st_x = val & m_WIN0_DSP_XST;
+			st_y = (val & m_WIN0_DSP_YST) >> 16;
+			win0->area[0].xpos = st_x - h_pw_bp;
+			win0->area[0].ypos = st_y - v_pw_bp;
+			break;
+		case WIN0_CTRL0:
+			win0->state = val & m_WIN0_EN;
+			win0->area[0].fmt_cfg = (val & m_WIN0_DATA_FMT) >> 1;
+			win0->fmt_10 = (val & m_WIN0_FMT_10) >> 4;
+			win0->area[0].format = win0->area[0].fmt_cfg;
+			break;
+		case WIN0_VIR:
+			win0->area[0].y_vir_stride = val & m_WIN0_VIR_STRIDE;
+			win0->area[0].uv_vir_stride =
+			    (val & m_WIN0_VIR_STRIDE_UV) >> 16;
+			if (win0->area[0].format == ARGB888)
+				win0->area[0].xvir = win0->area[0].y_vir_stride;
+			else if (win0->area[0].format == RGB888)
+				win0->area[0].xvir =
+				    win0->area[0].y_vir_stride * 4 / 3;
+			else if (win0->area[0].format == RGB565)
+				win0->area[0].xvir =
+				    2 * win0->area[0].y_vir_stride;
+			else	/* YUV */
+				win0->area[0].xvir =
+				    4 * win0->area[0].y_vir_stride;
+			break;
+		case WIN0_YRGB_MST:
+			win0->area[0].smem_start = val;
+			break;
+		case WIN0_CBR_MST:
+			win0->area[0].cbr_start = val;
+			break;
+		case DSP_VACT_ST_END:
+			if (support_uboot_display()) {
+				screen->mode.yres =
+				(val & 0x1fff) - ((val >> 16) & 0x1fff);
+				win0->area[0].ypos =
+				st_y - ((val >> 16) & 0x1fff);
+			}
+			break;
+		case DSP_HACT_ST_END:
+			if (support_uboot_display()) {
+				screen->mode.xres =
+				(val & 0x1fff) - ((val >> 16) & 0x1fff);
+				win0->area[0].xpos =
+				st_x - ((val >> 16) & 0x1fff);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+}
+
+/********do basic init*********/
+static int rk3368_lcdc_pre_init(struct rk_lcdc_driver *dev_drv)
+{
+	u32 mask, val;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	if (lcdc_dev->pre_init)
+		return 0;
+
+	lcdc_dev->hclk = devm_clk_get(lcdc_dev->dev, "hclk_lcdc");
+	lcdc_dev->aclk = devm_clk_get(lcdc_dev->dev, "aclk_lcdc");
+	lcdc_dev->dclk = devm_clk_get(lcdc_dev->dev, "dclk_lcdc");
+	if ((IS_ERR(lcdc_dev->aclk)) || (IS_ERR(lcdc_dev->dclk)) ||
+	    (IS_ERR(lcdc_dev->hclk))) {
+		dev_err(lcdc_dev->dev, "failed to get lcdc%d clk source\n",
+			lcdc_dev->id);
+	}
+
+	lcdc_dev->pd = devm_clk_get(lcdc_dev->dev, "pd_lcdc");
+	if (IS_ERR(lcdc_dev->pd)) {
+		dev_err(lcdc_dev->dev, "failed to get lcdc%d pdclk source\n",
+			lcdc_dev->id);
+		lcdc_dev->pd = NULL;
+	}
+
+	if (!support_uboot_display())
+		rk_disp_pwr_enable(dev_drv);
+	rk3368_lcdc_clk_enable(lcdc_dev);
+
+	/*backup reg config at uboot */
+	lcdc_read_reg_defalut_cfg(lcdc_dev);
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
+		lcdc_grf_writel(lcdc_dev->grf_base, RK3366_GRF_IO_VSEL,
+				RK3366_GRF_VOP_IOVOL_SEL(lcdc_dev->pwr18));
+	else
+		lcdc_grf_writel(lcdc_dev->pmugrf_base,
+				PMUGRF_SOC_CON0_VOP,
+				RK3368_GRF_VOP_IOVOL_SEL(lcdc_dev->pwr18));
+
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE0_0,0x15110903);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE0_1,0x00030911);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE1_0,0x1a150b04);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE1_1,0x00040b15);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE2_0,0x15110903);
+	lcdc_writel(lcdc_dev,CABC_GAUSS_LINE2_1,0x00030911);
+
+	lcdc_writel(lcdc_dev, FRC_LOWER01_0, 0x12844821);
+	lcdc_writel(lcdc_dev, FRC_LOWER01_1, 0x21488412);
+	lcdc_writel(lcdc_dev, FRC_LOWER10_0, 0xa55a9696);
+	lcdc_writel(lcdc_dev, FRC_LOWER10_1, 0x5aa56969);
+	lcdc_writel(lcdc_dev, FRC_LOWER11_0, 0xdeb77deb);
+	lcdc_writel(lcdc_dev, FRC_LOWER11_1, 0xed7bb7de);
+
+	mask = m_AUTO_GATING_EN;
+	val = v_AUTO_GATING_EN(0);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+	mask = m_DITHER_UP_EN;
+	val = v_DITHER_UP_EN(1);
+	lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+	lcdc_cfg_done(lcdc_dev);
+	/*disable win0 to workaround iommu pagefault */
+	/*if (dev_drv->iommu_enabled) */
+	/*      win0_enable(lcdc_dev, 0); */
+	lcdc_dev->pre_init = true;
+
+	return 0;
+}
+
+static void rk3368_lcdc_deint(struct lcdc_device *lcdc_dev)
+{
+	u32 mask, val;
+
+	if (lcdc_dev->clk_on) {
+		rk3368_lcdc_disable_irq(lcdc_dev);
+		spin_lock(&lcdc_dev->reg_lock);
+		mask = m_WIN0_EN;
+		val = v_WIN0_EN(0);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
+		lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
+
+		mask = m_WIN2_EN | m_WIN2_MST0_EN |
+			m_WIN2_MST1_EN |
+			m_WIN2_MST2_EN | m_WIN2_MST3_EN;
+		val = v_WIN2_EN(0) | v_WIN2_MST0_EN(0) |
+			v_WIN2_MST1_EN(0) |
+			v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
+		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
+		lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+		spin_unlock(&lcdc_dev->reg_lock);
+		mdelay(50);
+	}
+}
+
+static int rk3368_lcdc_post_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u32 mask, val;
+	u16 h_total, v_total;
+	u16 post_hsd_en, post_vsd_en;
+	u16 post_dsp_hact_st, post_dsp_hact_end;
+	u16 post_dsp_vact_st, post_dsp_vact_end;
+	u16 post_dsp_vact_st_f1, post_dsp_vact_end_f1;
+	u16 post_h_fac, post_v_fac;
+
+	screen->post_dsp_stx = x_res * (100 - dev_drv->overscan.left) / 200;
+	screen->post_dsp_sty = y_res * (100 - dev_drv->overscan.top) / 200;
+	screen->post_xsize = x_res *
+	    (dev_drv->overscan.left + dev_drv->overscan.right) / 200;
+	screen->post_ysize = y_res *
+	    (dev_drv->overscan.top + dev_drv->overscan.bottom) / 200;
+
+	h_total = screen->mode.hsync_len + screen->mode.left_margin +
+	    x_res + screen->mode.right_margin;
+	v_total = screen->mode.vsync_len + screen->mode.upper_margin +
+	    y_res + screen->mode.lower_margin;
+
+	if (screen->post_dsp_stx + screen->post_xsize > x_res) {
+		dev_warn(lcdc_dev->dev, "post:stx[%d]+xsize[%d]>x_res[%d]\n",
+			 screen->post_dsp_stx, screen->post_xsize, x_res);
+		screen->post_dsp_stx = x_res - screen->post_xsize;
+	}
+	if (screen->x_mirror == 0) {
+		post_dsp_hact_st = screen->post_dsp_stx +
+		    screen->mode.hsync_len + screen->mode.left_margin;
+		post_dsp_hact_end = post_dsp_hact_st + screen->post_xsize;
+	} else {
+		post_dsp_hact_end = h_total - screen->mode.right_margin -
+		    screen->post_dsp_stx;
+		post_dsp_hact_st = post_dsp_hact_end - screen->post_xsize;
+	}
+	if ((screen->post_xsize < x_res) && (screen->post_xsize != 0)) {
+		post_hsd_en = 1;
+		post_h_fac =
+		    GET_SCALE_FACTOR_BILI_DN(x_res, screen->post_xsize);
+	} else {
+		post_hsd_en = 0;
+		post_h_fac = 0x1000;
+	}
+
+	if (screen->post_dsp_sty + screen->post_ysize > y_res) {
+		dev_warn(lcdc_dev->dev, "post:sty[%d]+ysize[%d]> y_res[%d]\n",
+			 screen->post_dsp_sty, screen->post_ysize, y_res);
+		screen->post_dsp_sty = y_res - screen->post_ysize;
+	}
+
+	if ((screen->post_ysize < y_res) && (screen->post_ysize != 0)) {
+		post_vsd_en = 1;
+		post_v_fac = GET_SCALE_FACTOR_BILI_DN(y_res,
+						      screen->post_ysize);
+	} else {
+		post_vsd_en = 0;
+		post_v_fac = 0x1000;
+	}
+
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		post_dsp_vact_st = screen->post_dsp_sty / 2 +
+					screen->mode.vsync_len +
+					screen->mode.upper_margin;
+		post_dsp_vact_end = post_dsp_vact_st +
+					screen->post_ysize / 2;
+
+		post_dsp_vact_st_f1 = screen->mode.vsync_len +
+				      screen->mode.upper_margin +
+				      y_res/2 +
+				      screen->mode.lower_margin +
+				      screen->mode.vsync_len +
+				      screen->mode.upper_margin +
+				      screen->post_dsp_sty / 2 +
+				      1;
+		post_dsp_vact_end_f1 = post_dsp_vact_st_f1 +
+					screen->post_ysize/2;
+	} else {
+		if (screen->y_mirror == 0) {
+			post_dsp_vact_st = screen->post_dsp_sty +
+			    screen->mode.vsync_len +
+			    screen->mode.upper_margin;
+			post_dsp_vact_end = post_dsp_vact_st +
+				screen->post_ysize;
+		} else {
+			post_dsp_vact_end = v_total -
+				screen->mode.lower_margin -
+			    screen->post_dsp_sty;
+			post_dsp_vact_st = post_dsp_vact_end -
+				screen->post_ysize;
+		}
+		post_dsp_vact_st_f1 = 0;
+		post_dsp_vact_end_f1 = 0;
+	}
+	DBG(1, "post:xsize=%d,ysize=%d,xpos=%d",
+	    screen->post_xsize, screen->post_ysize, screen->xpos);
+	DBG(1, ",ypos=%d,hsd_en=%d,h_fac=%d,vsd_en=%d,v_fac=%d\n",
+	    screen->ypos, post_hsd_en, post_h_fac, post_vsd_en, post_v_fac);
+	mask = m_DSP_HACT_END_POST | m_DSP_HACT_ST_POST;
+	val = v_DSP_HACT_END_POST(post_dsp_hact_end) |
+	    v_DSP_HACT_ST_POST(post_dsp_hact_st);
+	lcdc_msk_reg(lcdc_dev, POST_DSP_HACT_INFO, mask, val);
+
+	mask = m_DSP_VACT_END_POST | m_DSP_VACT_ST_POST;
+	val = v_DSP_VACT_END_POST(post_dsp_vact_end) |
+	    v_DSP_VACT_ST_POST(post_dsp_vact_st);
+	lcdc_msk_reg(lcdc_dev, POST_DSP_VACT_INFO, mask, val);
+
+	mask = m_POST_HS_FACTOR_YRGB | m_POST_VS_FACTOR_YRGB;
+	val = v_POST_HS_FACTOR_YRGB(post_h_fac) |
+	    v_POST_VS_FACTOR_YRGB(post_v_fac);
+	lcdc_msk_reg(lcdc_dev, POST_SCL_FACTOR_YRGB, mask, val);
+
+	mask = m_DSP_VACT_END_POST_F1 | m_DSP_VACT_ST_POST_F1;
+	val = v_DSP_VACT_END_POST_F1(post_dsp_vact_end_f1) |
+	    v_DSP_VACT_ST_POST_F1(post_dsp_vact_st_f1);
+	lcdc_msk_reg(lcdc_dev, POST_DSP_VACT_INFO_F1, mask, val);
+
+	mask = m_POST_HOR_SD_EN | m_POST_VER_SD_EN;
+	val = v_POST_HOR_SD_EN(post_hsd_en) | v_POST_VER_SD_EN(post_vsd_en);
+	lcdc_msk_reg(lcdc_dev, POST_SCL_CTRL, mask, val);
+	return 0;
+}
+
+static int rk3368_lcdc_clr_key_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win;
+	u32 colorkey_r, colorkey_g, colorkey_b;
+	int i, key_val;
+
+	for (i = 0; i < 4; i++) {
+		win = dev_drv->win[i];
+		key_val = win->color_key_val;
+		colorkey_r = (key_val & 0xff) << 2;
+		colorkey_g = ((key_val >> 8) & 0xff) << 12;
+		colorkey_b = ((key_val >> 16) & 0xff) << 22;
+		/*color key dither 565/888->aaa */
+		key_val = colorkey_r | colorkey_g | colorkey_b;
+		switch (i) {
+		case 0:
+			lcdc_writel(lcdc_dev, WIN0_COLOR_KEY, key_val);
+			break;
+		case 1:
+			lcdc_writel(lcdc_dev, WIN1_COLOR_KEY, key_val);
+			break;
+		case 2:
+			lcdc_writel(lcdc_dev, WIN2_COLOR_KEY, key_val);
+			break;
+		case 3:
+			lcdc_writel(lcdc_dev, WIN3_COLOR_KEY, key_val);
+			break;
+		default:
+			pr_info("%s:un support win num:%d\n",
+				__func__, i);
+			break;
+		}
+	}
+	return 0;
+}
+
+static int rk3368_lcdc_alpha_cfg(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	struct alpha_config alpha_config;
+	u32 mask, val;
+	int ppixel_alpha = 0, global_alpha = 0, i;
+	u32 src_alpha_ctl = 0, dst_alpha_ctl = 0;
+
+	memset(&alpha_config, 0, sizeof(struct alpha_config));
+	for (i = 0; i < win->area_num; i++) {
+		ppixel_alpha |= ((win->area[i].format == ARGB888) ||
+				 (win->area[i].format == FBDC_ARGB_888) ||
+				 (win->area[i].format == FBDC_ABGR_888) ||
+				 (win->area[i].format == ABGR888)) ? 1 : 0;
+	}
+	global_alpha = (win->g_alpha_val == 0) ? 0 : 1;
+	alpha_config.src_global_alpha_val = win->g_alpha_val;
+	win->alpha_mode = AB_SRC_OVER;
+	switch (win->alpha_mode) {
+	case AB_USER_DEFINE:
+		break;
+	case AB_CLEAR:
+		alpha_config.src_factor_mode = AA_ZERO;
+		alpha_config.dst_factor_mode = AA_ZERO;
+		break;
+	case AB_SRC:
+		alpha_config.src_factor_mode = AA_ONE;
+		alpha_config.dst_factor_mode = AA_ZERO;
+		break;
+	case AB_DST:
+		alpha_config.src_factor_mode = AA_ZERO;
+		alpha_config.dst_factor_mode = AA_ONE;
+		break;
+	case AB_SRC_OVER:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		if (global_alpha)
+			alpha_config.src_factor_mode = AA_SRC_GLOBAL;
+		else
+			alpha_config.src_factor_mode = AA_ONE;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	case AB_DST_OVER:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode = AA_ONE;
+		break;
+	case AB_SRC_IN:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC;
+		alpha_config.dst_factor_mode = AA_ZERO;
+		break;
+	case AB_DST_IN:
+		alpha_config.src_factor_mode = AA_ZERO;
+		alpha_config.dst_factor_mode = AA_SRC;
+		break;
+	case AB_SRC_OUT:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode = AA_ZERO;
+		break;
+	case AB_DST_OUT:
+		alpha_config.src_factor_mode = AA_ZERO;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	case AB_SRC_ATOP:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	case AB_DST_ATOP:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode = AA_SRC;
+		break;
+	case XOR:
+		alpha_config.src_color_mode = AA_SRC_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_INVERSE;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	case AB_SRC_OVER_GLOBAL:
+		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
+		alpha_config.src_color_mode = AA_SRC_NO_PRE_MUL;
+		alpha_config.src_factor_mode = AA_SRC_GLOBAL;
+		alpha_config.dst_factor_mode = AA_SRC_INVERSE;
+		break;
+	default:
+		pr_err("alpha mode error\n");
+		break;
+	}
+	if ((ppixel_alpha == 1) && (global_alpha == 1))
+		alpha_config.src_global_alpha_mode = AA_PER_PIX_GLOBAL;
+	else if (ppixel_alpha == 1)
+		alpha_config.src_global_alpha_mode = AA_PER_PIX;
+	else if (global_alpha == 1)
+		alpha_config.src_global_alpha_mode = AA_GLOBAL;
+	else
+		dev_warn(lcdc_dev->dev, "alpha_en should be 0\n");
+	alpha_config.src_alpha_mode = AA_STRAIGHT;
+	alpha_config.src_alpha_cal_m0 = AA_NO_SAT;
+
+	switch (win_id) {
+	case 0:
+		src_alpha_ctl = 0x60;
+		dst_alpha_ctl = 0x64;
+		break;
+	case 1:
+		src_alpha_ctl = 0xa0;
+		dst_alpha_ctl = 0xa4;
+		break;
+	case 2:
+		src_alpha_ctl = 0xdc;
+		dst_alpha_ctl = 0xec;
+		break;
+	case 3:
+		src_alpha_ctl = 0x12c;
+		dst_alpha_ctl = 0x13c;
+		break;
+	case 4:
+		src_alpha_ctl = 0x160;
+		dst_alpha_ctl = 0x164;
+		break;
+	}
+	mask = m_WIN0_DST_FACTOR_M0;
+	val = v_WIN0_DST_FACTOR_M0(alpha_config.dst_factor_mode);
+	lcdc_msk_reg(lcdc_dev, dst_alpha_ctl, mask, val);
+	mask = m_WIN0_SRC_ALPHA_EN | m_WIN0_SRC_COLOR_M0 |
+	    m_WIN0_SRC_ALPHA_M0 | m_WIN0_SRC_BLEND_M0 |
+	    m_WIN0_SRC_ALPHA_CAL_M0 | m_WIN0_SRC_FACTOR_M0 |
+	    m_WIN0_SRC_GLOBAL_ALPHA;
+	val = v_WIN0_SRC_ALPHA_EN(1) |
+	    v_WIN0_SRC_COLOR_M0(alpha_config.src_color_mode) |
+	    v_WIN0_SRC_ALPHA_M0(alpha_config.src_alpha_mode) |
+	    v_WIN0_SRC_BLEND_M0(alpha_config.src_global_alpha_mode) |
+	    v_WIN0_SRC_ALPHA_CAL_M0(alpha_config.src_alpha_cal_m0) |
+	    v_WIN0_SRC_FACTOR_M0(alpha_config.src_factor_mode) |
+	    v_WIN0_SRC_GLOBAL_ALPHA(alpha_config.src_global_alpha_val);
+	lcdc_msk_reg(lcdc_dev, src_alpha_ctl, mask, val);
+
+	return 0;
+}
+
+static int rk3368_lcdc_area_xst(struct rk_lcdc_win *win, int area_num)
+{
+	struct rk_lcdc_win_area area_temp;
+	int i, j;
+
+	for (i = 0; i < area_num; i++) {
+		for (j = i + 1; j < area_num; j++) {
+			if (win->area[i].dsp_stx >  win->area[j].dsp_stx) {
+				memcpy(&area_temp, &win->area[i],
+				       sizeof(struct rk_lcdc_win_area));
+				memcpy(&win->area[i], &win->area[j],
+				       sizeof(struct rk_lcdc_win_area));
+				memcpy(&win->area[j], &area_temp,
+				       sizeof(struct rk_lcdc_win_area));
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int __maybe_unused
+	rk3368_lcdc_area_swap(struct rk_lcdc_win *win, int area_num)
+{
+	struct rk_lcdc_win_area area_temp;
+
+	switch (area_num) {
+	case 2:
+		area_temp = win->area[0];
+		win->area[0] = win->area[1];
+		win->area[1] = area_temp;
+		break;
+	case 3:
+		area_temp = win->area[0];
+		win->area[0] = win->area[2];
+		win->area[2] = area_temp;
+		break;
+	case 4:
+		area_temp = win->area[0];
+		win->area[0] = win->area[3];
+		win->area[3] = area_temp;
+
+		area_temp = win->area[1];
+		win->area[1] = win->area[2];
+		win->area[2] = area_temp;
+		break;
+	default:
+		pr_info("un supported area num!\n");
+		break;
+	}
+	return 0;
+}
+
+static int __maybe_unused
+rk3368_win_area_check_var(int win_id, int area_num,
+			  struct rk_lcdc_win_area *area_pre,
+			  struct rk_lcdc_win_area *area_now)
+{
+	if ((area_pre->xpos > area_now->xpos) ||
+	    ((area_pre->xpos + area_pre->xsize > area_now->xpos) &&
+	     (area_pre->ypos + area_pre->ysize > area_now->ypos))) {
+		area_now->state = 0;
+		pr_err("win[%d]:\n"
+		       "area_pre[%d]:xpos[%d],xsize[%d],ypos[%d],ysize[%d]\n"
+		       "area_now[%d]:xpos[%d],xsize[%d],ypos[%d],ysize[%d]\n",
+		       win_id,
+		       area_num - 1, area_pre->xpos, area_pre->xsize,
+		       area_pre->ypos, area_pre->ysize,
+		       area_num, area_now->xpos, area_now->xsize,
+		       area_now->ypos, area_now->ysize);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int __maybe_unused rk3368_get_fbdc_idle(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val, i;
+
+	for (i = 0; i < 100; i++) {
+		val = lcdc_readl(lcdc_dev, IFBDC_DEBUG0);
+		val &= m_DBG_IFBDC_IDLE;
+		if (val)
+			continue;
+		else
+			mdelay(10);
+	};
+	return val;
+}
+
+static int rk3368_fbdc_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	u32 mask, val;
+
+	if (lcdc_dev->soc_type != VOP_FULL_RK3368) {
+		pr_err("soc: 0x%08x not support FBDC\n", lcdc_dev->soc_type);
+		return 0;
+	}
+	mask = m_IFBDC_CTRL_FBDC_COR_EN |
+	    m_IFBDC_CTRL_FBDC_WIN_SEL | m_IFBDC_CTRL_FBDC_ROTATION_MODE |
+	    m_IFBDC_CTRL_FBDC_FMT | m_IFBDC_CTRL_WIDTH_RATIO;
+	val = v_IFBDC_CTRL_FBDC_COR_EN(win->area[0].fbdc_cor_en) |
+	    v_IFBDC_CTRL_FBDC_WIN_SEL(win->id) |
+	    v_IFBDC_CTRL_FBDC_ROTATION_MODE((win->xmirror &&
+					     win->ymirror) << 1) |
+	    v_IFBDC_CTRL_FBDC_FMT(win->area[0].fbdc_fmt_cfg) |
+	    v_IFBDC_CTRL_WIDTH_RATIO(win->area[0].fbdc_dsp_width_ratio);
+	lcdc_msk_reg(lcdc_dev, IFBDC_CTRL, mask, val);
+
+	mask = m_IFBDC_TILES_NUM;
+	val = v_IFBDC_TILES_NUM(win->area[0].fbdc_num_tiles);
+	lcdc_msk_reg(lcdc_dev, IFBDC_TILES_NUM, mask, val);
+
+	mask = m_IFBDC_MB_SIZE_WIDTH | m_IFBDC_MB_SIZE_HEIGHT;
+	val = v_IFBDC_MB_SIZE_WIDTH(win->area[0].fbdc_mb_width) |
+	    v_IFBDC_MB_SIZE_HEIGHT(win->area[0].fbdc_mb_height);
+	lcdc_msk_reg(lcdc_dev, IFBDC_MB_SIZE, mask, val);
+
+	mask = m_IFBDC_CMP_INDEX_INIT;
+	val = v_IFBDC_CMP_INDEX_INIT(win->area[0].fbdc_cmp_index_init);
+	lcdc_msk_reg(lcdc_dev, IFBDC_CMP_INDEX_INIT, mask, val);
+
+	mask = m_IFBDC_MB_VIR_WIDTH;
+	val = v_IFBDC_MB_VIR_WIDTH(win->area[0].fbdc_mb_vir_width);
+	lcdc_msk_reg(lcdc_dev, IFBDC_MB_VIR_WIDTH, mask, val);
+
+	return 0;
+}
+
+static int rk3368_init_fbdc_config(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	u8 fbdc_dsp_width_ratio = 0;
+	u16 fbdc_mb_vir_width = 0, fbdc_mb_vir_height = 0;
+	u16 fbdc_mb_width = 0, fbdc_mb_height = 0;
+	u16 fbdc_mb_xst = 0, fbdc_mb_yst = 0, fbdc_num_tiles = 0;
+	u16 fbdc_cmp_index_init = 0;
+	u8 mb_w_size = 0, mb_h_size = 0;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (screen->mode.flag & FB_VMODE_INTERLACED) {
+		dev_err(lcdc_dev->dev, "unsupport fbdc+interlace!\n");
+		return 0;
+	}
+
+	if (lcdc_dev->soc_type != VOP_FULL_RK3368) {
+		pr_err("soc: 0x%08x not support FBDC\n", lcdc_dev->soc_type);
+		return 0;
+	}
+	switch (win->area[0].fmt_cfg) {
+	case VOP_FORMAT_ARGB888:
+		fbdc_dsp_width_ratio = 0;
+		mb_w_size = 16;
+		break;
+	case VOP_FORMAT_RGB888:
+		fbdc_dsp_width_ratio = 0;
+		mb_w_size = 16;
+		break;
+	case VOP_FORMAT_RGB565:
+		fbdc_dsp_width_ratio = 1;
+		mb_w_size = 32;
+		break;
+	default:
+		dev_err(lcdc_dev->dev,
+			"in fbdc mode,unsupport fmt:%d!\n",
+			win->area[0].fmt_cfg);
+		break;
+	}
+	mb_h_size = 4;
+
+	/*macro block xvir and yvir */
+	if ((win->area[0].xvir % mb_w_size == 0) &&
+	    (win->area[0].yvir % mb_h_size == 0)) {
+		fbdc_mb_vir_width = win->area[0].xvir / mb_w_size;
+		fbdc_mb_vir_height = win->area[0].yvir / mb_h_size;
+	} else {
+		pr_err("fbdc fmt[%d]:", win->area[0].fmt_cfg);
+		pr_err("xvir[%d]/yvir[%d] should %d/%d pix align!\n",
+		       win->area[0].xvir, win->area[0].yvir,
+		       mb_w_size, mb_h_size);
+	}
+	/*macro block xact and yact */
+	if ((win->area[0].xact % mb_w_size == 0) &&
+	    (win->area[0].yact % mb_h_size == 0)) {
+		fbdc_mb_width = win->area[0].xact / mb_w_size;
+		fbdc_mb_height = win->area[0].yact / mb_h_size;
+	} else {
+		pr_err("fbdc fmt[%d]:", win->area[0].fmt_cfg);
+		pr_err("xact[%d]/yact[%d] should %d/%d pix align!\n",
+		       win->area[0].xact, win->area[0].yact,
+		       mb_w_size, mb_h_size);
+	}
+	/*macro block xoff and yoff */
+	if ((win->area[0].xoff % mb_w_size == 0) &&
+	    (win->area[0].yoff % mb_h_size == 0)) {
+		fbdc_mb_xst = win->area[0].xoff / mb_w_size;
+		fbdc_mb_yst = win->area[0].yoff / mb_h_size;
+	} else {
+		pr_err("fbdc fmt[%d]:", win->area[0].fmt_cfg);
+		pr_err("xoff[%d]/yoff[%d] should %d/%d pix align!\n",
+		       win->area[0].xoff, win->area[0].yoff,
+		       mb_w_size, mb_h_size);
+	}
+
+	/*FBDC tiles */
+	fbdc_num_tiles = fbdc_mb_vir_width * fbdc_mb_vir_height;
+
+	/*
+	   switch (fbdc_rotation_mode)  {
+	   case FBDC_ROT_NONE:
+	   fbdc_cmp_index_init =
+	   (fbdc_mb_yst*fbdc_mb_vir_width) +  fbdc_mb_xst;
+	   break;
+	   case FBDC_X_MIRROR:
+	   fbdc_cmp_index_init =
+	   (fbdc_mb_yst*fbdc_mb_vir_width) + (fbdc_mb_xst+
+	   (fbdc_mb_width-1));
+	   break;
+	   case FBDC_Y_MIRROR:
+	   fbdc_cmp_index_init =
+	   ((fbdc_mb_yst+(fbdc_mb_height-1))*fbdc_mb_vir_width)  +
+	   fbdc_mb_xst;
+	   break;
+	   case FBDC_ROT_180:
+	   fbdc_cmp_index_init =
+	   ((fbdc_mb_yst+(fbdc_mb_height-1))*fbdc_mb_vir_width) +
+	   (fbdc_mb_xst+(fbdc_mb_width-1));
+	   break;
+	   }
+	 */
+	if (win->xmirror && win->ymirror && ((win_id == 2) || (win_id == 3))) {
+		fbdc_cmp_index_init =
+		    ((fbdc_mb_yst + (fbdc_mb_height - 1)) * fbdc_mb_vir_width) +
+		    (fbdc_mb_xst + (fbdc_mb_width - 1));
+	} else {
+		fbdc_cmp_index_init =
+		    (fbdc_mb_yst * fbdc_mb_vir_width) + fbdc_mb_xst;
+	}
+	/*fbdc fmt maybe need to change*/
+	win->area[0].fbdc_dsp_width_ratio = fbdc_dsp_width_ratio;
+	win->area[0].fbdc_mb_vir_width = fbdc_mb_vir_width;
+	win->area[0].fbdc_mb_vir_height = fbdc_mb_vir_height;
+	win->area[0].fbdc_mb_width = fbdc_mb_width;
+	win->area[0].fbdc_mb_height = fbdc_mb_height;
+	win->area[0].fbdc_mb_xst = fbdc_mb_xst;
+	win->area[0].fbdc_mb_yst = fbdc_mb_yst;
+	win->area[0].fbdc_num_tiles = fbdc_num_tiles;
+	win->area[0].fbdc_cmp_index_init = fbdc_cmp_index_init;
+
+	return 0;
+}
+
+static int rk3368_lcdc_axi_gather_cfg(struct lcdc_device *lcdc_dev,
+				      struct rk_lcdc_win *win)
+{
+	u32 mask, val;
+	u16 yrgb_gather_num = 3;
+	u16 cbcr_gather_num = 1;
+
+	switch (win->area[0].format) {
+	case ARGB888:
+	case XBGR888:
+	case XRGB888:
+	case ABGR888:
+	case FBDC_ARGB_888:
+	case FBDC_RGBX_888:
+	case FBDC_ABGR_888:
+		yrgb_gather_num = 3;
+		break;
+	case RGB888:
+	case RGB565:
+	case BGR888:
+	case BGR565:
+	case FBDC_RGB_565:
+		yrgb_gather_num = 2;
+		break;
+	case YUV444:
+	case YUV422:
+	case YUV420:
+	case YUV420_NV21:
+		yrgb_gather_num = 1;
+		cbcr_gather_num = 2;
+		break;
+	default:
+		dev_err(lcdc_dev->driver.dev, "%s:un supported format!\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	if ((win->id == 0) || (win->id == 1)) {
+		mask = m_WIN0_YRGB_AXI_GATHER_EN | m_WIN0_CBR_AXI_GATHER_EN |
+			m_WIN0_YRGB_AXI_GATHER_NUM | m_WIN0_CBR_AXI_GATHER_NUM;
+		val = v_WIN0_YRGB_AXI_GATHER_EN(1) |
+			v_WIN0_CBR_AXI_GATHER_EN(1) |
+			v_WIN0_YRGB_AXI_GATHER_NUM(yrgb_gather_num) |
+			v_WIN0_CBR_AXI_GATHER_NUM(cbcr_gather_num);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL1 + (win->id * 0x40),
+			     mask, val);
+	} else if ((win->id == 2) || (win->id == 3)) {
+		mask = m_WIN2_AXI_GATHER_EN | m_WIN2_AXI_GATHER_NUM;
+		val = v_WIN2_AXI_GATHER_EN(1) |
+			v_WIN2_AXI_GATHER_NUM(yrgb_gather_num);
+		lcdc_msk_reg(lcdc_dev, WIN2_CTRL1 + ((win->id - 2) * 0x50),
+			     mask, val);
+	} else if (win->id == 4) {
+		mask = m_HWC_AXI_GATHER_EN | m_HWC_AXI_GATHER_NUM;
+		val = v_HWC_AXI_GATHER_EN(1) |
+			v_HWC_AXI_GATHER_NUM(yrgb_gather_num);
+		lcdc_msk_reg(lcdc_dev, HWC_CTRL1, mask, val);
+	}
+	return 0;
+}
+
+static void rk3368_lcdc_csc_mode(struct lcdc_device *lcdc_dev,
+				 struct rk_lcdc_win *win)
+{
+	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
+		switch (win->area[0].fmt_cfg) {
+		case VOP_FORMAT_ARGB888:
+		case VOP_FORMAT_RGB888:
+		case VOP_FORMAT_RGB565:
+			if ((screen->mode.xres < 1280) &&
+			    (screen->mode.yres < 720)) {
+				win->csc_mode = VOP_R2Y_CSC_BT601;
+			} else {
+				win->csc_mode = VOP_R2Y_CSC_BT709;
+			}
+			break;
+		default:
+			break;
+		}
+	} else if (dev_drv->overlay_mode == VOP_RGB_DOMAIN) {
+		switch (win->area[0].fmt_cfg) {
+		case VOP_FORMAT_YCBCR420:
+			if ((win->id == 0) || (win->id == 1))
+				win->csc_mode = VOP_Y2R_CSC_MPEG;
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static int rk3368_win_0_1_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	unsigned int mask, val, off;
+
+	off = win_id * 0x40;
+	/*if(win->win_lb_mode == 5)
+	   win->win_lb_mode = 4;
+	   for rk3288 to fix hw bug? */
+
+	if (win->state == 1) {
+		rk3368_lcdc_csc_mode(lcdc_dev, win);
+		rk3368_lcdc_axi_gather_cfg(lcdc_dev, win);
+		if (win->area[0].fbdc_en)
+			rk3368_fbdc_reg_update(&lcdc_dev->driver, win_id);
+		mask = m_WIN0_EN | m_WIN0_DATA_FMT | m_WIN0_FMT_10 |
+			m_WIN0_LB_MODE | m_WIN0_RB_SWAP | m_WIN0_X_MIRROR |
+			m_WIN0_Y_MIRROR | m_WIN0_CSC_MODE | m_WIN0_UV_SWAP;
+		val = v_WIN0_EN(win->state) |
+			v_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
+			v_WIN0_FMT_10(win->fmt_10) |
+			v_WIN0_LB_MODE(win->win_lb_mode) |
+			v_WIN0_RB_SWAP(win->area[0].swap_rb) |
+			v_WIN0_X_MIRROR(win->xmirror) |
+			v_WIN0_Y_MIRROR(win->ymirror) |
+			v_WIN0_CSC_MODE(win->csc_mode) |
+			v_WIN0_UV_SWAP(win->area[0].swap_uv);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0 + off, mask, val);
+
+		mask = m_WIN0_BIC_COE_SEL |
+		    m_WIN0_VSD_YRGB_GT4 | m_WIN0_VSD_YRGB_GT2 |
+		    m_WIN0_VSD_CBR_GT4 | m_WIN0_VSD_CBR_GT2 |
+		    m_WIN0_YRGB_HOR_SCL_MODE | m_WIN0_YRGB_VER_SCL_MODE |
+		    m_WIN0_YRGB_HSD_MODE | m_WIN0_YRGB_VSU_MODE |
+		    m_WIN0_YRGB_VSD_MODE | m_WIN0_CBR_HOR_SCL_MODE |
+		    m_WIN0_CBR_VER_SCL_MODE | m_WIN0_CBR_HSD_MODE |
+		    m_WIN0_CBR_VSU_MODE | m_WIN0_CBR_VSD_MODE;
+		val = v_WIN0_BIC_COE_SEL(win->bic_coe_el) |
+		    v_WIN0_VSD_YRGB_GT4(win->vsd_yrgb_gt4) |
+		    v_WIN0_VSD_YRGB_GT2(win->vsd_yrgb_gt2) |
+		    v_WIN0_VSD_CBR_GT4(win->vsd_cbr_gt4) |
+		    v_WIN0_VSD_CBR_GT2(win->vsd_cbr_gt2) |
+		    v_WIN0_YRGB_HOR_SCL_MODE(win->yrgb_hor_scl_mode) |
+		    v_WIN0_YRGB_VER_SCL_MODE(win->yrgb_ver_scl_mode) |
+		    v_WIN0_YRGB_HSD_MODE(win->yrgb_hsd_mode) |
+		    v_WIN0_YRGB_VSU_MODE(win->yrgb_vsu_mode) |
+		    v_WIN0_YRGB_VSD_MODE(win->yrgb_vsd_mode) |
+		    v_WIN0_CBR_HOR_SCL_MODE(win->cbr_hor_scl_mode) |
+		    v_WIN0_CBR_VER_SCL_MODE(win->cbr_ver_scl_mode) |
+		    v_WIN0_CBR_HSD_MODE(win->cbr_hsd_mode) |
+		    v_WIN0_CBR_VSU_MODE(win->cbr_vsu_mode) |
+		    v_WIN0_CBR_VSD_MODE(win->cbr_vsd_mode);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL1 + off, mask, val);
+		val = v_WIN0_VIR_STRIDE(win->area[0].y_vir_stride) |
+		    v_WIN0_VIR_STRIDE_UV(win->area[0].uv_vir_stride);
+		lcdc_writel(lcdc_dev, WIN0_VIR + off, val);
+		/*lcdc_writel(lcdc_dev, WIN0_YRGB_MST+off,
+				win->area[0].y_addr);
+		   lcdc_writel(lcdc_dev, WIN0_CBR_MST+off,
+				win->area[0].uv_addr); */
+		val = v_WIN0_ACT_WIDTH(win->area[0].xact) |
+		    v_WIN0_ACT_HEIGHT(win->area[0].yact);
+		lcdc_writel(lcdc_dev, WIN0_ACT_INFO + off, val);
+
+		val = v_WIN0_DSP_WIDTH(win->area[0].xsize) |
+		    v_WIN0_DSP_HEIGHT(win->area[0].ysize);
+		lcdc_writel(lcdc_dev, WIN0_DSP_INFO + off, val);
+
+		val = v_WIN0_DSP_XST(win->area[0].dsp_stx) |
+		    v_WIN0_DSP_YST(win->area[0].dsp_sty);
+		lcdc_writel(lcdc_dev, WIN0_DSP_ST + off, val);
+
+		val = v_WIN0_HS_FACTOR_YRGB(win->scale_yrgb_x) |
+		    v_WIN0_VS_FACTOR_YRGB(win->scale_yrgb_y);
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_YRGB + off, val);
+
+		val = v_WIN0_HS_FACTOR_CBR(win->scale_cbcr_x) |
+		    v_WIN0_VS_FACTOR_CBR(win->scale_cbcr_y);
+		lcdc_writel(lcdc_dev, WIN0_SCL_FACTOR_CBR + off, val);
+		if (win->alpha_en == 1) {
+			rk3368_lcdc_alpha_cfg(dev_drv, win_id);
+		} else {
+			mask = m_WIN0_SRC_ALPHA_EN;
+			val = v_WIN0_SRC_ALPHA_EN(0);
+			lcdc_msk_reg(lcdc_dev, WIN0_SRC_ALPHA_CTRL + off,
+				     mask, val);
+		}
+
+		if (dev_drv->cur_screen->mode.vmode & FB_VMODE_INTERLACED) {
+			mask = m_WIN0_YRGB_DEFLICK | m_WIN0_CBR_DEFLICK;
+			if (win->area[0].yact == 2 * win->area[0].ysize)
+				val = v_WIN0_YRGB_DEFLICK(0) |
+					v_WIN0_CBR_DEFLICK(0);
+			else
+				val = v_WIN0_YRGB_DEFLICK(1) |
+					v_WIN0_CBR_DEFLICK(1);
+			lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
+		}
+	} else {
+		mask = m_WIN0_EN;
+		val = v_WIN0_EN(win->state);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0 + off, mask, val);
+	}
+	return 0;
+}
+
+static int rk3368_win_2_3_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	unsigned int mask, val, off;
+
+	off = (win_id - 2) * 0x50;
+	rk3368_lcdc_area_xst(win, win->area_num);
+
+	if (win->state == 1) {
+		rk3368_lcdc_csc_mode(lcdc_dev, win);
+		rk3368_lcdc_axi_gather_cfg(lcdc_dev, win);
+		if (win->area[0].fbdc_en)
+			rk3368_fbdc_reg_update(&lcdc_dev->driver, win_id);
+
+		mask = m_WIN2_EN | m_WIN2_CSC_MODE;
+		val = v_WIN2_EN(1) | v_WIN1_CSC_MODE(win->csc_mode);
+		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+		/*area 0 */
+		if (win->area[0].state == 1) {
+			mask = m_WIN2_MST0_EN | m_WIN2_DATA_FMT0 |
+			    m_WIN2_RB_SWAP0;
+			val = v_WIN2_MST0_EN(win->area[0].state) |
+			    v_WIN2_DATA_FMT0(win->area[0].fmt_cfg) |
+			    v_WIN2_RB_SWAP0(win->area[0].swap_rb);
+			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+
+			mask = m_WIN2_VIR_STRIDE0;
+			val = v_WIN2_VIR_STRIDE0(win->area[0].y_vir_stride);
+			lcdc_msk_reg(lcdc_dev, WIN2_VIR0_1 + off, mask, val);
+
+			/*lcdc_writel(lcdc_dev,WIN2_MST0+off,
+			   win->area[0].y_addr); */
+			val = v_WIN2_DSP_WIDTH0(win->area[0].xsize) |
+			    v_WIN2_DSP_HEIGHT0(win->area[0].ysize);
+			lcdc_writel(lcdc_dev, WIN2_DSP_INFO0 + off, val);
+			val = v_WIN2_DSP_XST0(win->area[0].dsp_stx) |
+			    v_WIN2_DSP_YST0(win->area[0].dsp_sty);
+			lcdc_writel(lcdc_dev, WIN2_DSP_ST0 + off, val);
+		} else {
+			mask = m_WIN2_MST0_EN;
+			val = v_WIN2_MST0_EN(0);
+			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+		}
+		/*area 1 */
+		if (win->area[1].state == 1) {
+			/*rk3368_win_area_check_var(win_id, 1,
+						  &win->area[0], &win->area[1]);
+			*/
+
+			mask = m_WIN2_MST1_EN | m_WIN2_DATA_FMT1 |
+			    m_WIN2_RB_SWAP1;
+			val = v_WIN2_MST1_EN(win->area[1].state) |
+			    v_WIN2_DATA_FMT1(win->area[1].fmt_cfg) |
+			    v_WIN2_RB_SWAP1(win->area[1].swap_rb);
+			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+
+			mask = m_WIN2_VIR_STRIDE1;
+			val = v_WIN2_VIR_STRIDE1(win->area[1].y_vir_stride);
+			lcdc_msk_reg(lcdc_dev, WIN2_VIR0_1 + off, mask, val);
+
+			/*lcdc_writel(lcdc_dev,WIN2_MST1+off,
+			   win->area[1].y_addr); */
+			val = v_WIN2_DSP_WIDTH1(win->area[1].xsize) |
+			    v_WIN2_DSP_HEIGHT1(win->area[1].ysize);
+			lcdc_writel(lcdc_dev, WIN2_DSP_INFO1 + off, val);
+			val = v_WIN2_DSP_XST1(win->area[1].dsp_stx) |
+			    v_WIN2_DSP_YST1(win->area[1].dsp_sty);
+			lcdc_writel(lcdc_dev, WIN2_DSP_ST1 + off, val);
+		} else {
+			mask = m_WIN2_MST1_EN;
+			val = v_WIN2_MST1_EN(0);
+			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+		}
+		/*area 2 */
+		if (win->area[2].state == 1) {
+			/*rk3368_win_area_check_var(win_id, 2,
+						  &win->area[1], &win->area[2]);
+			*/
+
+			mask = m_WIN2_MST2_EN | m_WIN2_DATA_FMT2 |
+			    m_WIN2_RB_SWAP2;
+			val = v_WIN2_MST2_EN(win->area[2].state) |
+			    v_WIN2_DATA_FMT2(win->area[2].fmt_cfg) |
+			    v_WIN2_RB_SWAP2(win->area[2].swap_rb);
+			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+
+			mask = m_WIN2_VIR_STRIDE2;
+			val = v_WIN2_VIR_STRIDE2(win->area[2].y_vir_stride);
+			lcdc_msk_reg(lcdc_dev, WIN2_VIR2_3 + off, mask, val);
+
+			/*lcdc_writel(lcdc_dev,WIN2_MST2+off,
+			   win->area[2].y_addr); */
+			val = v_WIN2_DSP_WIDTH2(win->area[2].xsize) |
+			    v_WIN2_DSP_HEIGHT2(win->area[2].ysize);
+			lcdc_writel(lcdc_dev, WIN2_DSP_INFO2 + off, val);
+			val = v_WIN2_DSP_XST2(win->area[2].dsp_stx) |
+			    v_WIN2_DSP_YST2(win->area[2].dsp_sty);
+			lcdc_writel(lcdc_dev, WIN2_DSP_ST2 + off, val);
+		} else {
+			mask = m_WIN2_MST2_EN;
+			val = v_WIN2_MST2_EN(0);
+			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+		}
+		/*area 3 */
+		if (win->area[3].state == 1) {
+			/*rk3368_win_area_check_var(win_id, 3,
+						  &win->area[2], &win->area[3]);
+			*/
+
+			mask = m_WIN2_MST3_EN | m_WIN2_DATA_FMT3 |
+			    m_WIN2_RB_SWAP3;
+			val = v_WIN2_MST3_EN(win->area[3].state) |
+			    v_WIN2_DATA_FMT3(win->area[3].fmt_cfg) |
+			    v_WIN2_RB_SWAP3(win->area[3].swap_rb);
+			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+
+			mask = m_WIN2_VIR_STRIDE3;
+			val = v_WIN2_VIR_STRIDE3(win->area[3].y_vir_stride);
+			lcdc_msk_reg(lcdc_dev, WIN2_VIR2_3 + off, mask, val);
+
+			/*lcdc_writel(lcdc_dev,WIN2_MST3+off,
+			   win->area[3].y_addr); */
+			val = v_WIN2_DSP_WIDTH3(win->area[3].xsize) |
+			    v_WIN2_DSP_HEIGHT3(win->area[3].ysize);
+			lcdc_writel(lcdc_dev, WIN2_DSP_INFO3 + off, val);
+			val = v_WIN2_DSP_XST3(win->area[3].dsp_stx) |
+			    v_WIN2_DSP_YST3(win->area[3].dsp_sty);
+			lcdc_writel(lcdc_dev, WIN2_DSP_ST3 + off, val);
+		} else {
+			mask = m_WIN2_MST3_EN;
+			val = v_WIN2_MST3_EN(0);
+			lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+		}
+
+		if (win->alpha_en == 1) {
+			rk3368_lcdc_alpha_cfg(dev_drv, win_id);
+		} else {
+			mask = m_WIN2_SRC_ALPHA_EN;
+			val = v_WIN2_SRC_ALPHA_EN(0);
+			lcdc_msk_reg(lcdc_dev, WIN2_SRC_ALPHA_CTRL + off,
+				     mask, val);
+		}
+	} else {
+		mask = m_WIN2_EN | m_WIN2_MST0_EN |
+		    m_WIN2_MST0_EN | m_WIN2_MST2_EN | m_WIN2_MST3_EN;
+		val = v_WIN2_EN(win->state) | v_WIN2_MST0_EN(0) |
+		    v_WIN2_MST1_EN(0) | v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
+		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0 + off, mask, val);
+	}
+	return 0;
+}
+
+static int rk3368_hwc_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	unsigned int mask, val, hwc_size = 0;
+
+	if (win->state == 1) {
+		rk3368_lcdc_csc_mode(lcdc_dev, win);
+		rk3368_lcdc_axi_gather_cfg(lcdc_dev, win);
+		mask = m_HWC_EN | m_HWC_DATA_FMT |
+		    m_HWC_RB_SWAP | m_WIN0_CSC_MODE;
+		val = v_HWC_EN(1) | v_HWC_DATA_FMT(win->area[0].fmt_cfg) |
+		    v_HWC_RB_SWAP(win->area[0].swap_rb) |
+		    v_WIN0_CSC_MODE(win->csc_mode);
+		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
+
+		if ((win->area[0].xsize == 32) && (win->area[0].ysize == 32))
+			hwc_size = 0;
+		else if ((win->area[0].xsize == 64) &&
+			 (win->area[0].ysize == 64))
+			hwc_size = 1;
+		else if ((win->area[0].xsize == 96) &&
+			 (win->area[0].ysize == 96))
+			hwc_size = 2;
+		else if ((win->area[0].xsize == 128) &&
+			 (win->area[0].ysize == 128))
+			hwc_size = 3;
+		else
+			dev_err(lcdc_dev->dev, "un supported hwc size!\n");
+
+		mask = m_HWC_SIZE;
+		val = v_HWC_SIZE(hwc_size);
+		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
+
+		mask = m_HWC_DSP_XST | m_HWC_DSP_YST;
+		val = v_HWC_DSP_XST(win->area[0].dsp_stx) |
+		    v_HWC_DSP_YST(win->area[0].dsp_sty);
+		lcdc_msk_reg(lcdc_dev, HWC_DSP_ST, mask, val);
+
+		if (win->alpha_en == 1) {
+			rk3368_lcdc_alpha_cfg(dev_drv, win_id);
+		} else {
+			mask = m_WIN2_SRC_ALPHA_EN;
+			val = v_WIN2_SRC_ALPHA_EN(0);
+			lcdc_msk_reg(lcdc_dev, WIN2_SRC_ALPHA_CTRL, mask, val);
+		}
+	} else {
+		mask = m_HWC_EN;
+		val = v_HWC_EN(win->state);
+		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
+	}
+	return 0;
+}
+
+static int rk3368_lcdc_layer_update_regs(struct lcdc_device *lcdc_dev,
+					 struct rk_lcdc_win *win)
+{
+	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
+	int timeout;
+	unsigned long flags;
+
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
+			     v_STANDBY_EN(lcdc_dev->standby));
+		if ((win->id == 0) || (win->id == 1))
+			rk3368_win_0_1_reg_update(dev_drv, win->id);
+		else if ((win->id == 2) || (win->id == 3))
+			rk3368_win_2_3_reg_update(dev_drv, win->id);
+		else if (win->id == 4)
+			rk3368_hwc_reg_update(dev_drv, win->id);
+		/*rk3368_lcdc_post_cfg(dev_drv); */
+		lcdc_cfg_done(lcdc_dev);
+	}
+
+	/*if (dev_drv->wait_fs) { */
+	if (0) {
+		spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+		timeout =
+		    wait_for_completion_timeout(&dev_drv->frame_done,
+						msecs_to_jiffies
+						(dev_drv->cur_screen->ft + 5));
+		if (!timeout && (!dev_drv->frame_done.done)) {
+			dev_warn(lcdc_dev->dev,
+				 "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	DBG(2, "%s for lcdc%d\n", __func__, lcdc_dev->id);
+	return 0;
+}
+
+static int rk3368_lcdc_reg_restore(struct lcdc_device *lcdc_dev)
+{
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
+		memcpy((u8 *)lcdc_dev->regs, (u8 *)lcdc_dev->regsbak, 0x2a4);
+	else
+		memcpy((u8 *)lcdc_dev->regs, (u8 *)lcdc_dev->regsbak, 0x270);
+
+	return 0;
+}
+
+static int __maybe_unused rk3368_lcdc_mmu_en(struct rk_lcdc_driver *dev_drv)
+{
+	u32 mask, val;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	if (dev_drv->iommu_enabled) {
+		if (!lcdc_dev->iommu_status && dev_drv->mmu_dev) {
+			if (likely(lcdc_dev->clk_on)) {
+				mask = m_MMU_EN;
+				val = v_MMU_EN(1);
+				lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+				mask = m_AXI_MAX_OUTSTANDING_EN |
+					m_AXI_OUTSTANDING_MAX_NUM;
+				val = v_AXI_OUTSTANDING_MAX_NUM(31) |
+					v_AXI_MAX_OUTSTANDING_EN(1);
+				lcdc_msk_reg(lcdc_dev, SYS_CTRL1, mask, val);
+			}
+			lcdc_dev->iommu_status = 1;
+			rockchip_iovmm_activate(dev_drv->dev);
+		}
+	}
+	return 0;
+}
+
+static int rk3368_lcdc_set_dclk(struct rk_lcdc_driver *dev_drv, int reset_rate)
+{
+	int ret = 0, fps = 0;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+#ifdef CONFIG_RK_FPGA
+	return 0;
+#endif
+	if (reset_rate)
+		ret = clk_set_rate(lcdc_dev->dclk, screen->mode.pixclock);
+	if (ret)
+		dev_err(dev_drv->dev, "set lcdc%d dclk failed\n", lcdc_dev->id);
+	lcdc_dev->pixclock =
+	    div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	lcdc_dev->driver.pixclock = lcdc_dev->pixclock;
+
+	fps = rk_fb_calc_fps(screen, lcdc_dev->pixclock);
+	screen->ft = 1000 / fps;
+	dev_info(lcdc_dev->dev, "%s: dclk:%lu>>fps:%d ",
+		 lcdc_dev->driver.name, clk_get_rate(lcdc_dev->dclk), fps);
+	return 0;
+}
+
+static int rk3368_config_timing(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 hsync_len = screen->mode.hsync_len;
+	u16 left_margin = screen->mode.left_margin;
+	u16 right_margin = screen->mode.right_margin;
+	u16 vsync_len = screen->mode.vsync_len;
+	u16 upper_margin = screen->mode.upper_margin;
+	u16 lower_margin = screen->mode.lower_margin;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u32 mask, val;
+	u16 h_total, v_total;
+	u16 vact_end_f1, vact_st_f1, vs_end_f1, vs_st_f1;
+	u32 frame_time;
+	u32 line_flag_reg;
+
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
+		line_flag_reg = LINE_FLAG_RK3366;
+	else
+		line_flag_reg = LINE_FLAG_RK3368;
+
+	h_total = hsync_len + left_margin + x_res + right_margin;
+	v_total = vsync_len + upper_margin + y_res + lower_margin;
+	frame_time = 1000 * v_total * h_total / (screen->mode.pixclock / 1000);
+	mask = m_DSP_HS_PW | m_DSP_HTOTAL;
+	val = v_DSP_HS_PW(hsync_len) | v_DSP_HTOTAL(h_total);
+	lcdc_msk_reg(lcdc_dev, DSP_HTOTAL_HS_END, mask, val);
+
+	mask = m_DSP_HACT_END | m_DSP_HACT_ST;
+	val = v_DSP_HACT_END(hsync_len + left_margin + x_res) |
+	    v_DSP_HACT_ST(hsync_len + left_margin);
+	lcdc_msk_reg(lcdc_dev, DSP_HACT_ST_END, mask, val);
+
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		/* First Field Timing */
+		mask = m_DSP_VS_PW | m_DSP_VTOTAL;
+		val = v_DSP_VS_PW(vsync_len) |
+		    v_DSP_VTOTAL(2 * (vsync_len + upper_margin +
+				      lower_margin) + y_res + 1);
+		lcdc_msk_reg(lcdc_dev, DSP_VTOTAL_VS_END, mask, val);
+
+		mask = m_DSP_VACT_END | m_DSP_VACT_ST;
+		val = v_DSP_VACT_END(vsync_len + upper_margin + y_res / 2) |
+		    v_DSP_VACT_ST(vsync_len + upper_margin);
+		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END, mask, val);
+
+		/* Second Field Timing */
+		mask = m_DSP_VS_ST_F1 | m_DSP_VS_END_F1;
+		vs_st_f1 = vsync_len + upper_margin + y_res / 2 + lower_margin;
+		vs_end_f1 = 2 * vsync_len + upper_margin + y_res / 2 +
+		    lower_margin;
+		val = v_DSP_VS_ST_F1(vs_st_f1) | v_DSP_VS_END_F1(vs_end_f1);
+		lcdc_msk_reg(lcdc_dev, DSP_VS_ST_END_F1, mask, val);
+
+		mask = m_DSP_VACT_END_F1 | m_DSP_VAC_ST_F1;
+		vact_end_f1 = 2 * (vsync_len + upper_margin) + y_res +
+		    lower_margin + 1;
+		vact_st_f1 = 2 * (vsync_len + upper_margin) + y_res / 2 +
+		    lower_margin + 1;
+		val =
+		    v_DSP_VACT_END_F1(vact_end_f1) |
+		    v_DSP_VAC_ST_F1(vact_st_f1);
+		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END_F1, mask, val);
+
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+			     m_DSP_INTERLACE | m_DSP_FIELD_POL,
+			     v_DSP_INTERLACE(1) | v_DSP_FIELD_POL(0));
+		if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+			if (y_res <= 576)
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+					     m_SW_CORE_DCLK_SEL,
+					     v_SW_CORE_DCLK_SEL(1));
+			else
+				lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+					     m_SW_CORE_DCLK_SEL,
+					     v_SW_CORE_DCLK_SEL(0));
+		}
+		mask =
+		    m_WIN0_INTERLACE_READ | m_WIN0_YRGB_DEFLICK |
+		    m_WIN0_CBR_DEFLICK;
+		val =
+		    v_WIN0_INTERLACE_READ(1) | v_WIN0_YRGB_DEFLICK(0) |
+		    v_WIN0_CBR_DEFLICK(0);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
+
+		mask =
+		    m_WIN1_INTERLACE_READ | m_WIN1_YRGB_DEFLICK |
+		    m_WIN1_CBR_DEFLICK;
+		val =
+		    v_WIN1_INTERLACE_READ(1) | v_WIN1_YRGB_DEFLICK(0) |
+		    v_WIN1_CBR_DEFLICK(0);
+		lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
+
+		mask = m_WIN2_INTERLACE_READ;
+		val = v_WIN2_INTERLACE_READ(1);
+		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
+
+		mask = m_WIN3_INTERLACE_READ;
+		val = v_WIN3_INTERLACE_READ(1);
+		lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
+
+		mask = m_HWC_INTERLACE_READ;
+		val = v_HWC_INTERLACE_READ(1);
+		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
+
+		mask = m_DSP_LINE_FLAG0_NUM | m_DSP_LINE_FLAG1_NUM;
+		val =
+		    v_DSP_LINE_FLAG0_NUM(vact_end_f1) |
+		    v_DSP_LINE_FLAG1_NUM(vact_end_f1 -
+					 EARLY_TIME * v_total / frame_time);
+		lcdc_msk_reg(lcdc_dev, line_flag_reg, mask, val);
+	} else {
+		mask = m_DSP_VS_PW | m_DSP_VTOTAL;
+		val = v_DSP_VS_PW(vsync_len) | v_DSP_VTOTAL(v_total);
+		lcdc_msk_reg(lcdc_dev, DSP_VTOTAL_VS_END, mask, val);
+
+		mask = m_DSP_VACT_END | m_DSP_VACT_ST;
+		val = v_DSP_VACT_END(vsync_len + upper_margin + y_res) |
+		    v_DSP_VACT_ST(vsync_len + upper_margin);
+		lcdc_msk_reg(lcdc_dev, DSP_VACT_ST_END, mask, val);
+
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+			     m_DSP_INTERLACE | m_DSP_FIELD_POL,
+			     v_DSP_INTERLACE(0) | v_DSP_FIELD_POL(0));
+		if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0,
+				     m_SW_CORE_DCLK_SEL,
+				     v_SW_CORE_DCLK_SEL(0));
+		}
+		mask =
+		    m_WIN0_INTERLACE_READ | m_WIN0_YRGB_DEFLICK |
+		    m_WIN0_CBR_DEFLICK;
+		val =
+		    v_WIN0_INTERLACE_READ(0) | v_WIN0_YRGB_DEFLICK(0) |
+		    v_WIN0_CBR_DEFLICK(0);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
+
+		mask =
+		    m_WIN1_INTERLACE_READ | m_WIN1_YRGB_DEFLICK |
+		    m_WIN1_CBR_DEFLICK;
+		val =
+		    v_WIN1_INTERLACE_READ(0) | v_WIN1_YRGB_DEFLICK(0) |
+		    v_WIN1_CBR_DEFLICK(0);
+		lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
+
+		mask = m_WIN2_INTERLACE_READ;
+		val = v_WIN2_INTERLACE_READ(0);
+		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
+
+		mask = m_WIN3_INTERLACE_READ;
+		val = v_WIN3_INTERLACE_READ(0);
+		lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
+
+		mask = m_HWC_INTERLACE_READ;
+		val = v_HWC_INTERLACE_READ(0);
+		lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
+
+		mask = m_DSP_LINE_FLAG0_NUM | m_DSP_LINE_FLAG1_NUM;
+		val = v_DSP_LINE_FLAG0_NUM(vsync_len + upper_margin + y_res) |
+			v_DSP_LINE_FLAG1_NUM(vsync_len + upper_margin + y_res -
+					     EARLY_TIME * v_total / frame_time);
+		lcdc_msk_reg(lcdc_dev, line_flag_reg, mask, val);
+	}
+	rk3368_lcdc_post_cfg(dev_drv);
+	return 0;
+}
+
+static void rk3368_lcdc_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 bcsh_ctrl;
+
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_OVERLAY_MODE,
+		     v_OVERLAY_MODE(dev_drv->overlay_mode));
+	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
+		if (IS_YUV_COLOR(dev_drv->output_color))	/* bypass */
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     m_BCSH_Y2R_EN | m_BCSH_R2Y_EN,
+				     v_BCSH_Y2R_EN(0) | v_BCSH_R2Y_EN(0));
+		else		/* YUV2RGB */
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     m_BCSH_Y2R_EN | m_BCSH_Y2R_CSC_MODE |
+				     m_BCSH_R2Y_EN,
+				     v_BCSH_Y2R_EN(1) |
+				     v_BCSH_Y2R_CSC_MODE(VOP_Y2R_CSC_MPEG) |
+				     v_BCSH_R2Y_EN(0));
+	} else {		/* overlay_mode=VOP_RGB_DOMAIN */
+		/* bypass  --need check,if bcsh close? */
+		if (dev_drv->output_color == COLOR_RGB) {
+			bcsh_ctrl = lcdc_readl(lcdc_dev, BCSH_CTRL);
+			if (((bcsh_ctrl & m_BCSH_EN) == 1) ||
+			    (dev_drv->bcsh.enable == 1))/*bcsh enabled */
+				lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+					     m_BCSH_R2Y_EN |
+					     m_BCSH_Y2R_EN,
+					     v_BCSH_R2Y_EN(1) |
+					     v_BCSH_Y2R_EN(1));
+			else
+				lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+					     m_BCSH_R2Y_EN | m_BCSH_Y2R_EN,
+					     v_BCSH_R2Y_EN(0) |
+					     v_BCSH_Y2R_EN(0));
+		} else		/* RGB2YUV */
+			lcdc_msk_reg(lcdc_dev, BCSH_CTRL,
+				     m_BCSH_R2Y_EN |
+				     m_BCSH_R2Y_CSC_MODE | m_BCSH_Y2R_EN,
+				     v_BCSH_R2Y_EN(1) |
+				     v_BCSH_R2Y_CSC_MODE(VOP_Y2R_CSC_MPEG) |
+				     v_BCSH_Y2R_EN(0));
+	}
+}
+
+static int rk3368_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
+				  u16 *yact, int *format, u32 *dsp_addr,
+				  int *ymirror)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	u32 val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+
+	val = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
+	*xact = (val & m_WIN0_ACT_WIDTH) + 1;
+	*yact = ((val & m_WIN0_ACT_HEIGHT)>>16) + 1;
+
+	val = lcdc_readl(lcdc_dev, WIN0_CTRL0);
+	*format = (val & m_WIN0_DATA_FMT) >> 1;
+	*ymirror = (val & m_WIN0_Y_MIRROR) >> 22;
+	*dsp_addr = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
+
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk3368_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
+			      int format, u16 xact, u16 yact, u16 xvir,
+			      int ymirror)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	u32 val, mask;
+	struct rk_lcdc_win *win = dev_drv->win[0];
+	int swap = (format == RGB888) ? 1 : 0;
+
+	mask = m_WIN0_DATA_FMT | m_WIN0_RB_SWAP | m_WIN0_Y_MIRROR;
+	val = v_WIN0_DATA_FMT(format) | v_WIN0_RB_SWAP(swap) |
+		v_WIN0_Y_MIRROR(ymirror);
+	lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
+
+	lcdc_msk_reg(lcdc_dev, WIN0_VIR, m_WIN0_VIR_STRIDE,
+		     v_WIN0_VIR_STRIDE(xvir));
+	lcdc_writel(lcdc_dev, WIN0_ACT_INFO, v_WIN0_ACT_WIDTH(xact) |
+		    v_WIN0_ACT_HEIGHT(yact));
+
+	lcdc_writel(lcdc_dev, WIN0_YRGB_MST, rgb_mst);
+
+	lcdc_cfg_done(lcdc_dev);
+	if (format == RGB888)
+		win->area[0].format = BGR888;
+	else
+		win->area[0].format = format;
+
+	win->ymirror = ymirror;
+	win->state = 1;
+	win->last_state = 1;
+
+	return 0;
+}
+
+static int lcdc_reset(struct rk_lcdc_driver *dev_drv, bool initscreen)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+	u32 __maybe_unused v;
+	if (!lcdc_dev->standby && initscreen && (dev_drv->first_frame != 1)) {
+		mdelay(150);
+		mask = m_WIN0_EN;
+		val = v_WIN0_EN(0);
+		lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
+		lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
+
+		mask = m_WIN2_EN | m_WIN2_MST0_EN |
+			m_WIN2_MST1_EN |
+			m_WIN2_MST2_EN | m_WIN2_MST3_EN;
+		val = v_WIN2_EN(0) | v_WIN2_MST0_EN(0) |
+			v_WIN2_MST1_EN(0) |
+			v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
+		lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
+		lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
+		mask = m_HDMI_OUT_EN;
+		val = v_HDMI_OUT_EN(0);
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+		mdelay(50);
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN, v_STANDBY_EN(1));
+		writel_relaxed(0, lcdc_dev->regs + REG_CFG_DONE);
+		mdelay(50);
+#ifdef VOP_RESET
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+		lcdc_cru_writel(lcdc_dev->cru_base, 0x0318,
+				(1 << 4)  | (1 << 5)  | (1 << 6) |
+				(1 << 20) | (1 << 21) | (1 << 22));
+		udelay(100);
+		v = lcdc_cru_readl(lcdc_dev->cru_base, 0x0318);
+		pr_info("cru read = 0x%x\n", v);
+		lcdc_cru_writel(lcdc_dev->cru_base, 0x0318,
+				(0 << 4)  | (0 << 5)  | (0 << 6) |
+				(1 << 20) | (1 << 21) | (1 << 22));
+		mdelay(100);
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_activate(dev_drv->dev);
+		}
+		mdelay(50);
+		rk3368_lcdc_reg_restore(lcdc_dev);
+		mdelay(50);
+#endif
+	}
+	return 0;
+}
+
+static int rk3368_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
+{
+	u16 face = 0;
+	u16 dclk_ddr = 0;
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u32 mask = 0, val = 0;
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+
+	if (!lcdc_dev->standby && initscreen && (dev_drv->first_frame != 1))
+		flush_kthread_worker(&dev_drv->update_regs_worker);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+#if 0
+		if (!lcdc_dev->standby && !initscreen) {
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
+				     v_STANDBY_EN(1));
+			lcdc_cfg_done(lcdc_dev);
+			mdelay(50);
+		}
+#else
+	lcdc_reset(dev_drv, initscreen);
+#endif
+		switch (screen->face) {
+		case OUT_P565:
+			face = OUT_P565;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
+			    v_DITHER_DOWN_SEL(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_P666:
+			face = OUT_P666;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
+			    v_DITHER_DOWN_SEL(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_D888_P565:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0) |
+			    v_DITHER_DOWN_SEL(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_D888_P666:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE |
+			    m_DITHER_DOWN_SEL;
+			val = v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1) |
+			    v_DITHER_DOWN_SEL(1);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_P888:
+			face = OUT_P888;
+			mask = m_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_YUV_420:
+			/*yuv420 output prefer yuv domain overlay */
+			face = OUT_YUV_420;
+			dclk_ddr = 1;
+			mask = m_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_S888:
+			face = OUT_S888;
+			mask = m_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_S888DUMY:
+			face = OUT_S888DUMY;
+			mask = m_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		case OUT_CCIR656:
+			if (screen->color_mode == COLOR_RGB)
+				dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+			else
+				dev_drv->overlay_mode = VOP_YUV_DOMAIN;
+			face = OUT_CCIR656_MODE_0;
+			mask = m_DITHER_DOWN_EN;
+			val = v_DITHER_DOWN_EN(0);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+			break;
+		default:
+			dev_err(lcdc_dev->dev, "un supported interface!\n");
+			break;
+		}
+		switch (screen->type) {
+		case SCREEN_RGB:
+			mask = m_RGB_OUT_EN;
+			val = v_RGB_OUT_EN(1);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			mask = m_RGB_LVDS_HSYNC_POL | m_RGB_LVDS_VSYNC_POL |
+			    m_RGB_LVDS_DEN_POL | m_RGB_LVDS_DCLK_POL;
+			val = v_RGB_LVDS_HSYNC_POL(screen->pin_hsync) |
+			    v_RGB_LVDS_VSYNC_POL(screen->pin_vsync) |
+			    v_RGB_LVDS_DEN_POL(screen->pin_den) |
+			    v_RGB_LVDS_DCLK_POL(screen->pin_dclk);
+			if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+				lcdc_grf_writel(lcdc_dev->grf_base,
+						RK3366_GRF_SOC_CON5,
+						RGB_SOURCE_SEL(dev_drv->id));
+				lcdc_grf_writel(lcdc_dev->grf_base,
+						RK3366_GRF_SOC_CON0,
+						RGB_DATA_PLANA);
+			}
+			break;
+		case SCREEN_LVDS:
+			mask = m_RGB_OUT_EN;
+			val = v_RGB_OUT_EN(1);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			mask = m_RGB_LVDS_HSYNC_POL | m_RGB_LVDS_VSYNC_POL |
+			    m_RGB_LVDS_DEN_POL | m_RGB_LVDS_DCLK_POL;
+			val = v_RGB_LVDS_HSYNC_POL(screen->pin_hsync) |
+			    v_RGB_LVDS_VSYNC_POL(screen->pin_vsync) |
+			    v_RGB_LVDS_DEN_POL(screen->pin_den) |
+			    v_RGB_LVDS_DCLK_POL(screen->pin_dclk);
+			if (lcdc_dev->soc_type == VOP_FULL_RK3366)
+				lcdc_grf_writel(lcdc_dev->grf_base,
+						RK3366_GRF_SOC_CON0,
+						LVDS_SOURCE_SEL(dev_drv->id));
+			break;
+		case SCREEN_HDMI:
+			if (screen->color_mode == COLOR_RGB)
+				dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+			else
+				dev_drv->overlay_mode = VOP_YUV_DOMAIN;
+			mask = m_HDMI_OUT_EN  | m_RGB_OUT_EN;
+			val = v_HDMI_OUT_EN(1) | v_RGB_OUT_EN(0);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			mask = m_HDMI_HSYNC_POL | m_HDMI_VSYNC_POL |
+			    m_HDMI_DEN_POL | m_HDMI_DCLK_POL;
+			val = v_HDMI_HSYNC_POL(screen->pin_hsync) |
+			    v_HDMI_VSYNC_POL(screen->pin_vsync) |
+			    v_HDMI_DEN_POL(screen->pin_den) |
+			    v_HDMI_DCLK_POL(screen->pin_dclk);
+			if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+				lcdc_grf_writel(lcdc_dev->grf_base,
+						RK3366_GRF_SOC_CON0,
+						HDMI_SOURCE_SEL(dev_drv->id));
+			}
+			break;
+		case SCREEN_MIPI:
+			mask = m_MIPI_OUT_EN  | m_RGB_OUT_EN;
+			val = v_MIPI_OUT_EN(1) | v_RGB_OUT_EN(0);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			mask = m_MIPI_HSYNC_POL | m_MIPI_VSYNC_POL |
+			    m_MIPI_DEN_POL | m_MIPI_DCLK_POL;
+			val = v_MIPI_HSYNC_POL(screen->pin_hsync) |
+			    v_MIPI_VSYNC_POL(screen->pin_vsync) |
+			    v_MIPI_DEN_POL(screen->pin_den) |
+			    v_MIPI_DCLK_POL(screen->pin_dclk);
+			if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+				lcdc_grf_writel(lcdc_dev->grf_base,
+						RK3366_GRF_SOC_CON0,
+						MIPI_SOURCE_SEL(dev_drv->id));
+			}
+			break;
+		case SCREEN_DUAL_MIPI:
+			mask = m_MIPI_OUT_EN | m_DOUB_CHANNEL_EN  |
+				m_RGB_OUT_EN;
+			val = v_MIPI_OUT_EN(1) | v_DOUB_CHANNEL_EN(1) |
+				v_RGB_OUT_EN(0);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+			mask = m_MIPI_HSYNC_POL | m_MIPI_VSYNC_POL |
+			    m_MIPI_DEN_POL | m_MIPI_DCLK_POL;
+			val = v_MIPI_HSYNC_POL(screen->pin_hsync) |
+			    v_MIPI_VSYNC_POL(screen->pin_vsync) |
+			    v_MIPI_DEN_POL(screen->pin_den) |
+			    v_MIPI_DCLK_POL(screen->pin_dclk);
+			break;
+		case SCREEN_EDP:
+			face = OUT_P888;	/*RGB 888 output */
+
+			mask = m_EDP_OUT_EN | m_RGB_OUT_EN;
+			val = v_EDP_OUT_EN(1) | v_RGB_OUT_EN(0);
+			lcdc_msk_reg(lcdc_dev, SYS_CTRL, mask, val);
+
+			mask = m_EDP_HSYNC_POL | m_EDP_VSYNC_POL |
+			    m_EDP_DEN_POL | m_EDP_DCLK_POL;
+			val = v_EDP_HSYNC_POL(screen->pin_hsync) |
+			    v_EDP_VSYNC_POL(screen->pin_vsync) |
+			    v_EDP_DEN_POL(screen->pin_den) |
+			    v_EDP_DCLK_POL(screen->pin_dclk);
+			break;
+		}
+		/*hsync vsync den dclk polo,dither */
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+		mask = m_DSP_OUT_MODE | m_DSP_DCLK_DDR | m_DSP_BG_SWAP |
+		    m_DSP_RB_SWAP | m_DSP_RG_SWAP | m_DSP_DELTA_SWAP |
+		    m_DSP_DUMMY_SWAP | m_DSP_OUT_ZERO | m_DSP_BLANK_EN |
+		    m_DSP_BLACK_EN | m_DSP_X_MIR_EN | m_DSP_Y_MIR_EN;
+		val = v_DSP_OUT_MODE(face) | v_DSP_DCLK_DDR(dclk_ddr) |
+		    v_DSP_BG_SWAP(screen->swap_gb) |
+		    v_DSP_RB_SWAP(screen->swap_rb) |
+		    v_DSP_RG_SWAP(screen->swap_rg) |
+		    v_DSP_DELTA_SWAP(screen->swap_delta) |
+		    v_DSP_DUMMY_SWAP(screen->swap_dumy) | v_DSP_OUT_ZERO(0) |
+		    v_DSP_BLANK_EN(0) | v_DSP_BLACK_EN(0) |
+		    v_DSP_X_MIR_EN(screen->x_mirror) |
+		    v_DSP_Y_MIR_EN(screen->y_mirror);
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, mask, val);
+		/*BG color */
+		mask = m_DSP_BG_BLUE | m_DSP_BG_GREEN | m_DSP_BG_RED;
+		if (dev_drv->overlay_mode == VOP_YUV_DOMAIN)
+			val = v_DSP_BG_BLUE(0x80) | v_DSP_BG_GREEN(0x10) |
+				v_DSP_BG_RED(0x80);
+		else
+			val = v_DSP_BG_BLUE(0) | v_DSP_BG_GREEN(0) |
+				v_DSP_BG_RED(0);
+		lcdc_msk_reg(lcdc_dev, DSP_BG, mask, val);
+		dev_drv->output_color = screen->color_mode;
+		if (screen->dsp_lut == NULL)
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
+				     v_DSP_LUT_EN(0));
+		else
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, m_DSP_LUT_EN,
+				     v_DSP_LUT_EN(1));
+		rk3368_lcdc_bcsh_path_sel(dev_drv);
+		rk3368_config_timing(dev_drv);
+		if (lcdc_dev->soc_type == VOP_FULL_RK3366)
+			lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	rk3368_lcdc_set_dclk(dev_drv, 1);
+	if (screen->type != SCREEN_HDMI &&
+	    screen->type != SCREEN_TVOUT &&
+	    dev_drv->trsm_ops &&
+	    dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	if (screen->init)
+		screen->init();
+	/*if (!lcdc_dev->standby)
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL,
+			m_STANDBY_EN, v_STANDBY_EN(0));*/
+	return 0;
+}
+
+
+/*enable layer,open:1,enable;0 disable*/
+static void rk3368_lcdc_layer_enable(struct lcdc_device *lcdc_dev,
+				     unsigned int win_id, bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on) &&
+	    lcdc_dev->driver.win[win_id]->state != open) {
+		if (open) {
+			if (!lcdc_dev->atv_layer_cnt) {
+				dev_info(lcdc_dev->dev,
+					 "wakeup from standby!\n");
+				lcdc_dev->standby = 0;
+			}
+			lcdc_dev->atv_layer_cnt |= (1 << win_id);
+		} else {
+			if (lcdc_dev->atv_layer_cnt & (1 << win_id))
+				lcdc_dev->atv_layer_cnt &= ~(1 << win_id);
+		}
+		lcdc_dev->driver.win[win_id]->state = open;
+		if (!open) {
+			/*rk3368_lcdc_reg_update(dev_drv);*/
+			rk3368_lcdc_layer_update_regs
+			(lcdc_dev, lcdc_dev->driver.win[win_id]);
+			lcdc_cfg_done(lcdc_dev);
+		}
+		/*if no layer used,disable lcdc */
+		if (!lcdc_dev->atv_layer_cnt) {
+			dev_info(lcdc_dev->dev,
+				 "no layer is used,go to standby!\n");
+			lcdc_dev->standby = 1;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+}
+
+static int rk3368_lcdc_enable_irq(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	u32 mask, val;
+	/*struct rk_screen *screen = dev_drv->cur_screen; */
+	u32 intr_en_reg, intr_clr_reg;
+
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+		intr_clr_reg = INTR_CLEAR_RK3366;
+		intr_en_reg = INTR_EN_RK3366;
+	} else {
+		intr_clr_reg = INTR_CLEAR_RK3368;
+		intr_en_reg = INTR_EN_RK3368;
+	}
+
+	mask = m_FS_INTR_CLR | m_FS_NEW_INTR_CLR | m_LINE_FLAG0_INTR_CLR |
+	    m_LINE_FLAG1_INTR_CLR;
+	val = v_FS_INTR_CLR(1) | v_FS_NEW_INTR_CLR(1) |
+	    v_LINE_FLAG0_INTR_CLR(1) | v_LINE_FLAG1_INTR_CLR(1);
+	lcdc_msk_reg(lcdc_dev, intr_clr_reg, mask, val);
+
+	mask = m_FS_INTR_EN | m_LINE_FLAG0_INTR_EN |
+		m_BUS_ERROR_INTR_EN | m_LINE_FLAG1_INTR_EN;
+	val = v_FS_INTR_EN(1) | v_LINE_FLAG0_INTR_EN(1) |
+	    v_BUS_ERROR_INTR_EN(1) | v_LINE_FLAG1_INTR_EN(0);
+	lcdc_msk_reg(lcdc_dev, intr_en_reg, mask, val);
+#ifdef LCDC_IRQ_EMPTY_DEBUG
+	mask = m_WIN0_EMPTY_INTR_EN | m_WIN1_EMPTY_INTR_EN |
+	    m_WIN2_EMPTY_INTR_EN |
+	    m_WIN3_EMPTY_INTR_EN | m_HWC_EMPTY_INTR_EN |
+	    m_POST_BUF_EMPTY_INTR_EN | m_PWM_GEN_INTR_EN;
+	val = v_WIN0_EMPTY_INTR_EN(1) | v_WIN1_EMPTY_INTR_EN(1) |
+	    v_WIN2_EMPTY_INTR_EN(1) |
+	    v_WIN3_EMPTY_INTR_EN(1) | v_HWC_EMPTY_INTR_EN(1) |
+	    v_POST_BUF_EMPTY_INTR_EN(1) | v_PWM_GEN_INTR_EN(1);
+	lcdc_msk_reg(lcdc_dev, intr_en_reg, mask, val);
+#endif
+	return 0;
+}
+
+static int rk3368_lcdc_open(struct rk_lcdc_driver *dev_drv, int win_id,
+			    bool open)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	/*enable clk,when first layer open */
+	if ((open) && (!lcdc_dev->atv_layer_cnt)) {
+		/*rockchip_set_system_status(sys_status);*/
+		rk3368_lcdc_pre_init(dev_drv);
+		rk3368_lcdc_clk_enable(lcdc_dev);
+		rk3368_lcdc_enable_irq(dev_drv);
+		if (dev_drv->iommu_enabled) {
+			if (!dev_drv->mmu_dev) {
+				dev_drv->mmu_dev =
+				    rk_fb_get_sysmmu_device_by_compatible
+				    (dev_drv->mmu_dts_name);
+				if (dev_drv->mmu_dev) {
+					rk_fb_platform_set_sysmmu
+					    (dev_drv->mmu_dev, dev_drv->dev);
+				} else {
+					dev_err(dev_drv->dev,
+						"fail get rk iommu device\n");
+					return -1;
+				}
+			}
+			/*if (dev_drv->mmu_dev)
+			   rockchip_iovmm_activate(dev_drv->dev); */
+		}
+		rk3368_lcdc_reg_restore(lcdc_dev);
+		/*if (dev_drv->iommu_enabled)
+		   rk3368_lcdc_mmu_en(dev_drv); */
+		if ((support_uboot_display() && (lcdc_dev->prop == PRMRY))) {
+			rk3368_lcdc_set_dclk(dev_drv, 0);
+			/*rk3368_lcdc_enable_irq(dev_drv);*/
+		} else {
+			rk3368_load_screen(dev_drv, 1);
+		}
+		if (dev_drv->bcsh.enable)
+			rk3368_lcdc_set_bcsh(dev_drv, 1);
+		spin_lock(&lcdc_dev->reg_lock);
+		if (dev_drv->cur_screen->dsp_lut)
+			rk3368_lcdc_set_lut(dev_drv,
+					    dev_drv->cur_screen->dsp_lut);
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	if (win_id < ARRAY_SIZE(lcdc_win))
+		rk3368_lcdc_layer_enable(lcdc_dev, win_id, open);
+	else
+		dev_err(lcdc_dev->dev, "invalid win id:%d\n", win_id);
+
+
+	/* when all layer closed,disable clk */
+	/*if ((!open) && (!lcdc_dev->atv_layer_cnt)) {
+	   rk3368_lcdc_disable_irq(lcdc_dev);
+	   rk3368_lcdc_reg_update(dev_drv);
+	   if (dev_drv->iommu_enabled) {
+	   if (dev_drv->mmu_dev)
+	   rockchip_iovmm_deactivate(dev_drv->dev);
+	   }
+	   rk3368_lcdc_clk_disable(lcdc_dev);
+	   #ifndef CONFIG_RK_FPGA
+	   rockchip_clear_system_status(sys_status);
+	   #endif
+	   } */
+	dev_drv->first_frame = 0;
+	return 0;
+}
+
+static int win_0_1_display(struct lcdc_device *lcdc_dev,
+			   struct rk_lcdc_win *win)
+{
+	u32 y_addr;
+	u32 uv_addr;
+	unsigned int off;
+
+	off = win->id * 0x40;
+	/*win->smem_start + win->y_offset; */
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	uv_addr = win->area[0].cbr_start + win->area[0].c_offset;
+	DBG(2, "lcdc[%d]:win[%d]>>:y_addr:0x%x>>uv_addr:0x%x",
+	    lcdc_dev->id, win->id, y_addr, uv_addr);
+	DBG(2, ">>y_offset:0x%x>>c_offset=0x%x\n",
+	    win->area[0].y_offset, win->area[0].c_offset);
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		win->area[0].y_addr = y_addr;
+		win->area[0].uv_addr = uv_addr;
+		lcdc_writel(lcdc_dev, WIN0_YRGB_MST + off, win->area[0].y_addr);
+		lcdc_writel(lcdc_dev, WIN0_CBR_MST + off, win->area[0].uv_addr);
+		if (win->area[0].fbdc_en == 1)
+			lcdc_writel(lcdc_dev, IFBDC_BASE_ADDR,
+				    win->area[0].y_addr);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int win_2_3_display(struct lcdc_device *lcdc_dev,
+			   struct rk_lcdc_win *win)
+{
+	u32 i, y_addr;
+	unsigned int off;
+
+	off = (win->id - 2) * 0x50;
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	DBG(2, "lcdc[%d]:win[%d]:", lcdc_dev->id, win->id);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		for (i = 0; i < win->area_num; i++) {
+			DBG(2, "area[%d]:yaddr:0x%x>>offset:0x%x>>\n",
+			    i, win->area[i].y_addr, win->area[i].y_offset);
+			win->area[i].y_addr =
+			    win->area[i].smem_start + win->area[i].y_offset;
+			}
+		lcdc_writel(lcdc_dev, WIN2_MST0 + off, win->area[0].y_addr);
+		lcdc_writel(lcdc_dev, WIN2_MST1 + off, win->area[1].y_addr);
+		lcdc_writel(lcdc_dev, WIN2_MST2 + off, win->area[2].y_addr);
+		lcdc_writel(lcdc_dev, WIN2_MST3 + off, win->area[3].y_addr);
+		if (win->area[0].fbdc_en == 1)
+			lcdc_writel(lcdc_dev, IFBDC_BASE_ADDR,
+				    win->area[0].y_addr);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int hwc_display(struct lcdc_device *lcdc_dev, struct rk_lcdc_win *win)
+{
+	u32 y_addr;
+
+	y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	DBG(2, "lcdc[%d]:hwc>>%s>>y_addr:0x%x>>\n",
+	    lcdc_dev->id, __func__, y_addr);
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		win->area[0].y_addr = y_addr;
+		lcdc_writel(lcdc_dev, HWC_MST, win->area[0].y_addr);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk3368_lcdc_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+#if defined(WAIT_FOR_SYNC)
+	int timeout;
+	unsigned long flags;
+#endif
+	win = dev_drv->win[win_id];
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	if (win_id == 0) {
+		win_0_1_display(lcdc_dev, win);
+	} else if (win_id == 1) {
+		win_0_1_display(lcdc_dev, win);
+	} else if (win_id == 2) {
+		win_2_3_display(lcdc_dev, win);
+	} else if (win_id == 3) {
+		win_2_3_display(lcdc_dev, win);
+	} else if (win_id == 4) {
+		hwc_display(lcdc_dev, win);
+	} else {
+		dev_err(dev_drv->dev, "invalid win number:%d!\n", win_id);
+		return -EINVAL;
+	}
+
+#if defined(WAIT_FOR_SYNC)
+	spin_lock_irqsave(&dev_drv->cpl_lock, flags);
+	init_completion(&dev_drv->frame_done);
+	spin_unlock_irqrestore(&dev_drv->cpl_lock, flags);
+	timeout =
+	    wait_for_completion_timeout(&dev_drv->frame_done,
+					msecs_to_jiffies(dev_drv->
+							 cur_screen->ft + 5));
+	if (!timeout && (!dev_drv->frame_done.done)) {
+		dev_info(dev_drv->dev, "wait for new frame start time out!\n");
+		return -ETIMEDOUT;
+	}
+#endif
+	return 0;
+}
+
+static int rk3368_lcdc_cal_scl_fac(struct rk_lcdc_win *win,
+				   struct rk_screen *screen)
+{
+	u16 srcW = 0;
+	u16 srcH = 0;
+	u16 dstW = 0;
+	u16 dstH = 0;
+	u16 yrgb_srcW = 0;
+	u16 yrgb_srcH = 0;
+	u16 yrgb_dstW = 0;
+	u16 yrgb_dstH = 0;
+	u32 yrgb_vscalednmult = 0;
+	u32 yrgb_xscl_factor = 0;
+	u32 yrgb_yscl_factor = 0;
+	u8 yrgb_vsd_bil_gt2 = 0;
+	u8 yrgb_vsd_bil_gt4 = 0;
+
+	u16 cbcr_srcW = 0;
+	u16 cbcr_srcH = 0;
+	u16 cbcr_dstW = 0;
+	u16 cbcr_dstH = 0;
+	u32 cbcr_vscalednmult = 0;
+	u32 cbcr_xscl_factor = 0;
+	u32 cbcr_yscl_factor = 0;
+	u8 cbcr_vsd_bil_gt2 = 0;
+	u8 cbcr_vsd_bil_gt4 = 0;
+	u8 yuv_fmt = 0;
+
+	srcW = win->area[0].xact;
+	if ((screen->mode.vmode & FB_VMODE_INTERLACED) &&
+	    (win->area[0].yact == 2 * win->area[0].ysize)) {
+		srcH = win->area[0].yact / 2;
+		yrgb_vsd_bil_gt2 = 1;
+		cbcr_vsd_bil_gt2 = 1;
+	} else {
+		srcH = win->area[0].yact;
+	}
+	dstW = win->area[0].xsize;
+	dstH = win->area[0].ysize;
+
+	/*yrgb scl mode */
+	yrgb_srcW = srcW;
+	yrgb_srcH = srcH;
+	yrgb_dstW = dstW;
+	yrgb_dstH = dstH;
+	if ((yrgb_dstW * 8 <= yrgb_srcW) || (yrgb_dstH * 8 <= yrgb_srcH)) {
+		pr_err("ERROR: yrgb scale exceed 8,");
+		pr_err("srcW=%d,srcH=%d,dstW=%d,dstH=%d\n",
+		       yrgb_srcW, yrgb_srcH, yrgb_dstW, yrgb_dstH);
+	}
+	if (yrgb_srcW < yrgb_dstW)
+		win->yrgb_hor_scl_mode = SCALE_UP;
+	else if (yrgb_srcW > yrgb_dstW)
+		win->yrgb_hor_scl_mode = SCALE_DOWN;
+	else
+		win->yrgb_hor_scl_mode = SCALE_NONE;
+
+	if (yrgb_srcH < yrgb_dstH)
+		win->yrgb_ver_scl_mode = SCALE_UP;
+	else if (yrgb_srcH > yrgb_dstH)
+		win->yrgb_ver_scl_mode = SCALE_DOWN;
+	else
+		win->yrgb_ver_scl_mode = SCALE_NONE;
+
+	/*cbcr scl mode */
+	switch (win->area[0].format) {
+	case YUV422:
+	case YUV422_A:
+		cbcr_srcW = srcW / 2;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	case YUV420:
+	case YUV420_A:
+	case YUV420_NV21:
+		cbcr_srcW = srcW / 2;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH / 2;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	case YUV444:
+	case YUV444_A:
+		cbcr_srcW = srcW;
+		cbcr_dstW = dstW;
+		cbcr_srcH = srcH;
+		cbcr_dstH = dstH;
+		yuv_fmt = 1;
+		break;
+	default:
+		cbcr_srcW = 0;
+		cbcr_dstW = 0;
+		cbcr_srcH = 0;
+		cbcr_dstH = 0;
+		yuv_fmt = 0;
+		break;
+	}
+	if (yuv_fmt) {
+		if ((cbcr_dstW * 8 <= cbcr_srcW) ||
+		    (cbcr_dstH * 8 <= cbcr_srcH)) {
+			pr_err("ERROR: cbcr scale exceed 8,");
+			pr_err("srcW=%d,srcH=%d,dstW=%d,dstH=%d\n", cbcr_srcW,
+			       cbcr_srcH, cbcr_dstW, cbcr_dstH);
+		}
+	}
+
+	if (cbcr_srcW < cbcr_dstW)
+		win->cbr_hor_scl_mode = SCALE_UP;
+	else if (cbcr_srcW > cbcr_dstW)
+		win->cbr_hor_scl_mode = SCALE_DOWN;
+	else
+		win->cbr_hor_scl_mode = SCALE_NONE;
+
+	if (cbcr_srcH < cbcr_dstH)
+		win->cbr_ver_scl_mode = SCALE_UP;
+	else if (cbcr_srcH > cbcr_dstH)
+		win->cbr_ver_scl_mode = SCALE_DOWN;
+	else
+		win->cbr_ver_scl_mode = SCALE_NONE;
+
+	/*DBG(1, "srcW:%d>>srcH:%d>>dstW:%d>>dstH:%d>>\n"
+	    "yrgb:src:W=%d>>H=%d,dst:W=%d>>H=%d,H_mode=%d,V_mode=%d\n"
+	    "cbcr:src:W=%d>>H=%d,dst:W=%d>>H=%d,H_mode=%d,V_mode=%d\n", srcW,
+	    srcH, dstW, dstH, yrgb_srcW, yrgb_srcH, yrgb_dstW, yrgb_dstH,
+	    win->yrgb_hor_scl_mode, win->yrgb_ver_scl_mode, cbcr_srcW,
+	    cbcr_srcH, cbcr_dstW, cbcr_dstH, win->cbr_hor_scl_mode,
+	    win->cbr_ver_scl_mode);*/
+
+	/*line buffer mode */
+	if ((win->area[0].format == YUV422) ||
+	    (win->area[0].format == YUV420) ||
+	    (win->area[0].format == YUV420_NV21) ||
+	    (win->area[0].format == YUV422_A) ||
+	    (win->area[0].format == YUV420_A)) {
+		if (win->cbr_hor_scl_mode == SCALE_DOWN) {
+			if ((cbcr_dstW > VOP_INPUT_MAX_WIDTH / 2) ||
+			    (cbcr_dstW == 0))
+				pr_err("ERROR cbcr_dstW = %d,exceeds 2048\n",
+				       cbcr_dstW);
+			else if (cbcr_dstW > 1280)
+				win->win_lb_mode = LB_YUV_3840X5;
+			else
+				win->win_lb_mode = LB_YUV_2560X8;
+		} else {	/*SCALE_UP or SCALE_NONE */
+			if ((cbcr_srcW > VOP_INPUT_MAX_WIDTH / 2) ||
+			    (cbcr_srcW == 0))
+				pr_err("ERROR cbcr_srcW = %d,exceeds 2048\n",
+				       cbcr_srcW);
+			else if (cbcr_srcW > 1280)
+				win->win_lb_mode = LB_YUV_3840X5;
+			else
+				win->win_lb_mode = LB_YUV_2560X8;
+		}
+	} else {
+		if (win->yrgb_hor_scl_mode == SCALE_DOWN) {
+			if ((yrgb_dstW > VOP_INPUT_MAX_WIDTH) ||
+			    (yrgb_dstW == 0))
+				pr_err("ERROR yrgb_dstW = %d\n", yrgb_dstW);
+			else if (yrgb_dstW > 2560)
+				win->win_lb_mode = LB_RGB_3840X2;
+			else if (yrgb_dstW > 1920)
+				win->win_lb_mode = LB_RGB_2560X4;
+			else if (yrgb_dstW > 1280)
+				win->win_lb_mode = LB_RGB_1920X5;
+			else
+				win->win_lb_mode = LB_RGB_1280X8;
+		} else {	/*SCALE_UP or SCALE_NONE */
+			if ((yrgb_srcW > VOP_INPUT_MAX_WIDTH) ||
+			    (yrgb_srcW == 0))
+				pr_err("ERROR yrgb_srcW = %d\n", yrgb_srcW);
+			else if (yrgb_srcW > 2560)
+				win->win_lb_mode = LB_RGB_3840X2;
+			else if (yrgb_srcW > 1920)
+				win->win_lb_mode = LB_RGB_2560X4;
+			else if (yrgb_srcW > 1280)
+				win->win_lb_mode = LB_RGB_1920X5;
+			else
+				win->win_lb_mode = LB_RGB_1280X8;
+		}
+	}
+	DBG(1, "win->win_lb_mode = %d;\n", win->win_lb_mode);
+
+	/*vsd/vsu scale ALGORITHM */
+	win->yrgb_hsd_mode = SCALE_DOWN_BIL;	/*not to specify */
+	win->cbr_hsd_mode = SCALE_DOWN_BIL;	/*not to specify */
+	win->yrgb_vsd_mode = SCALE_DOWN_BIL;	/*not to specify */
+	win->cbr_vsd_mode = SCALE_DOWN_BIL;	/*not to specify */
+	switch (win->win_lb_mode) {
+	case LB_YUV_3840X5:
+	case LB_YUV_2560X8:
+	case LB_RGB_1920X5:
+	case LB_RGB_1280X8:
+		win->yrgb_vsu_mode = SCALE_UP_BIC;
+		win->cbr_vsu_mode = SCALE_UP_BIC;
+		break;
+	case LB_RGB_3840X2:
+		if (win->yrgb_ver_scl_mode != SCALE_NONE)
+			pr_err("ERROR : not allow yrgb ver scale\n");
+		if (win->cbr_ver_scl_mode != SCALE_NONE)
+			pr_err("ERROR : not allow cbcr ver scale\n");
+		break;
+	case LB_RGB_2560X4:
+		win->yrgb_vsu_mode = SCALE_UP_BIL;
+		win->cbr_vsu_mode = SCALE_UP_BIL;
+		break;
+	default:
+		pr_info("%s:un supported win_lb_mode:%d\n",
+			__func__, win->win_lb_mode);
+		break;
+	}
+	if (win->ymirror == 1)
+		win->yrgb_vsd_mode = SCALE_DOWN_BIL;
+
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		/*interlace mode must bill */
+		win->yrgb_vsd_mode = SCALE_DOWN_BIL;
+		win->cbr_vsd_mode = SCALE_DOWN_BIL;
+	}
+	if ((win->yrgb_ver_scl_mode == SCALE_DOWN) &&
+	    (win->area[0].fbdc_en == 1)) {
+		/*in this pattern,use bil mode,not support souble scd,
+		use avg mode, support double scd, but aclk should be
+		bigger than dclk,aclk>>dclk */
+		if (yrgb_srcH >= 2 * yrgb_dstH) {
+			pr_err("ERROR : fbdc mode,not support y scale down:");
+			pr_err("srcH[%d] > 2 *dstH[%d]\n",
+			       yrgb_srcH, yrgb_dstH);
+		}
+	}
+	DBG(1, "yrgb:hsd=%d,vsd=%d,vsu=%d;cbcr:hsd=%d,vsd=%d,vsu=%d\n",
+	    win->yrgb_hsd_mode, win->yrgb_vsd_mode, win->yrgb_vsu_mode,
+	    win->cbr_hsd_mode, win->cbr_vsd_mode, win->cbr_vsu_mode);
+
+	/*SCALE FACTOR */
+
+	/*(1.1)YRGB HOR SCALE FACTOR */
+	switch (win->yrgb_hor_scl_mode) {
+	case SCALE_NONE:
+		yrgb_xscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+		break;
+	case SCALE_UP:
+		yrgb_xscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcW, yrgb_dstW);
+		break;
+	case SCALE_DOWN:
+		switch (win->yrgb_hsd_mode) {
+		case SCALE_DOWN_BIL:
+			yrgb_xscl_factor =
+			    GET_SCALE_FACTOR_BILI_DN(yrgb_srcW, yrgb_dstW);
+			break;
+		case SCALE_DOWN_AVG:
+			yrgb_xscl_factor =
+			    GET_SCALE_FACTOR_AVRG(yrgb_srcW, yrgb_dstW);
+			break;
+		default:
+			pr_info(
+				"%s:un supported yrgb_hsd_mode:%d\n", __func__,
+			       win->yrgb_hsd_mode);
+			break;
+		}
+		break;
+	default:
+		pr_info("%s:un supported yrgb_hor_scl_mode:%d\n",
+			__func__, win->yrgb_hor_scl_mode);
+		break;
+	}			/*win->yrgb_hor_scl_mode */
+
+	/*(1.2)YRGB VER SCALE FACTOR */
+	switch (win->yrgb_ver_scl_mode) {
+	case SCALE_NONE:
+		yrgb_yscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+		break;
+	case SCALE_UP:
+		switch (win->yrgb_vsu_mode) {
+		case SCALE_UP_BIL:
+			yrgb_yscl_factor =
+			    GET_SCALE_FACTOR_BILI_UP(yrgb_srcH, yrgb_dstH);
+			break;
+		case SCALE_UP_BIC:
+			if (yrgb_srcH < 3) {
+				pr_err("yrgb_srcH should be");
+				pr_err(" greater than 3 !!!\n");
+			}
+			yrgb_yscl_factor = GET_SCALE_FACTOR_BIC(yrgb_srcH,
+								yrgb_dstH);
+			break;
+		default:
+			pr_info("%s:un support yrgb_vsu_mode:%d\n",
+				__func__, win->yrgb_vsu_mode);
+			break;
+		}
+		break;
+	case SCALE_DOWN:
+		switch (win->yrgb_vsd_mode) {
+		case SCALE_DOWN_BIL:
+			yrgb_vscalednmult =
+			    rk3368_get_hard_ware_vskiplines(yrgb_srcH,
+							    yrgb_dstH);
+			yrgb_yscl_factor =
+			    GET_SCALE_FACTOR_BILI_DN_VSKIP(yrgb_srcH, yrgb_dstH,
+							   yrgb_vscalednmult);
+			if (yrgb_yscl_factor >= 0x2000) {
+				pr_err("yrgb_yscl_factor should be ");
+				pr_err("less than 0x2000,yrgb_yscl_factor=%4x;\n",
+				       yrgb_yscl_factor);
+			}
+			if (yrgb_vscalednmult == 4) {
+				yrgb_vsd_bil_gt4 = 1;
+				yrgb_vsd_bil_gt2 = 0;
+			} else if (yrgb_vscalednmult == 2) {
+				yrgb_vsd_bil_gt4 = 0;
+				yrgb_vsd_bil_gt2 = 1;
+			} else {
+				yrgb_vsd_bil_gt4 = 0;
+				yrgb_vsd_bil_gt2 = 0;
+			}
+			break;
+		case SCALE_DOWN_AVG:
+			yrgb_yscl_factor = GET_SCALE_FACTOR_AVRG(yrgb_srcH,
+								 yrgb_dstH);
+			break;
+		default:
+			pr_info("%s:un support yrgb_vsd_mode:%d\n",
+				__func__, win->yrgb_vsd_mode);
+			break;
+		}		/*win->yrgb_vsd_mode */
+		break;
+	default:
+		pr_info("%s:un supported yrgb_ver_scl_mode:%d\n",
+			__func__, win->yrgb_ver_scl_mode);
+		break;
+	}
+	win->scale_yrgb_x = yrgb_xscl_factor;
+	win->scale_yrgb_y = yrgb_yscl_factor;
+	win->vsd_yrgb_gt4 = yrgb_vsd_bil_gt4;
+	win->vsd_yrgb_gt2 = yrgb_vsd_bil_gt2;
+	DBG(1, "yrgb:h_fac=%d, v_fac=%d,gt4=%d, gt2=%d\n", yrgb_xscl_factor,
+	    yrgb_yscl_factor, yrgb_vsd_bil_gt4, yrgb_vsd_bil_gt2);
+
+	/*(2.1)CBCR HOR SCALE FACTOR */
+	switch (win->cbr_hor_scl_mode) {
+	case SCALE_NONE:
+		cbcr_xscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+		break;
+	case SCALE_UP:
+		cbcr_xscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcW, cbcr_dstW);
+		break;
+	case SCALE_DOWN:
+		switch (win->cbr_hsd_mode) {
+		case SCALE_DOWN_BIL:
+			cbcr_xscl_factor =
+			    GET_SCALE_FACTOR_BILI_DN(cbcr_srcW, cbcr_dstW);
+			break;
+		case SCALE_DOWN_AVG:
+			cbcr_xscl_factor =
+			    GET_SCALE_FACTOR_AVRG(cbcr_srcW, cbcr_dstW);
+			break;
+		default:
+			pr_info("%s:un support cbr_hsd_mode:%d\n",
+				__func__, win->cbr_hsd_mode);
+			break;
+		}
+		break;
+	default:
+		pr_info("%s:un supported cbr_hor_scl_mode:%d\n",
+			__func__, win->cbr_hor_scl_mode);
+		break;
+	}			/*win->cbr_hor_scl_mode */
+
+	/*(2.2)CBCR VER SCALE FACTOR */
+	switch (win->cbr_ver_scl_mode) {
+	case SCALE_NONE:
+		cbcr_yscl_factor = (1 << SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT);
+		break;
+	case SCALE_UP:
+		switch (win->cbr_vsu_mode) {
+		case SCALE_UP_BIL:
+			cbcr_yscl_factor =
+			    GET_SCALE_FACTOR_BILI_UP(cbcr_srcH, cbcr_dstH);
+			break;
+		case SCALE_UP_BIC:
+			if (cbcr_srcH < 3) {
+				pr_err("cbcr_srcH should be ");
+				pr_err("greater than 3 !!!\n");
+			}
+			cbcr_yscl_factor = GET_SCALE_FACTOR_BIC(cbcr_srcH,
+								cbcr_dstH);
+			break;
+		default:
+			pr_info("%s:un support cbr_vsu_mode:%d\n",
+				__func__, win->cbr_vsu_mode);
+			break;
+		}
+		break;
+	case SCALE_DOWN:
+		switch (win->cbr_vsd_mode) {
+		case SCALE_DOWN_BIL:
+			cbcr_vscalednmult =
+			    rk3368_get_hard_ware_vskiplines(cbcr_srcH,
+							    cbcr_dstH);
+			cbcr_yscl_factor =
+			    GET_SCALE_FACTOR_BILI_DN_VSKIP(cbcr_srcH, cbcr_dstH,
+							   cbcr_vscalednmult);
+			if (cbcr_yscl_factor >= 0x2000) {
+				pr_err("cbcr_yscl_factor should be less ");
+				pr_err("than 0x2000,cbcr_yscl_factor=%4x;\n",
+				       cbcr_yscl_factor);
+			}
+
+			if (cbcr_vscalednmult == 4) {
+				cbcr_vsd_bil_gt4 = 1;
+				cbcr_vsd_bil_gt2 = 0;
+			} else if (cbcr_vscalednmult == 2) {
+				cbcr_vsd_bil_gt4 = 0;
+				cbcr_vsd_bil_gt2 = 1;
+			} else {
+				cbcr_vsd_bil_gt4 = 0;
+				cbcr_vsd_bil_gt2 = 0;
+			}
+			break;
+		case SCALE_DOWN_AVG:
+			cbcr_yscl_factor = GET_SCALE_FACTOR_AVRG(cbcr_srcH,
+								 cbcr_dstH);
+			break;
+		default:
+			pr_info("%s:un support cbr_vsd_mode:%d\n",
+				__func__, win->cbr_vsd_mode);
+			break;
+		}
+		break;
+	default:
+		pr_info("%s:un supported cbr_ver_scl_mode:%d\n",
+			__func__, win->cbr_ver_scl_mode);
+		break;
+	}
+	win->scale_cbcr_x = cbcr_xscl_factor;
+	win->scale_cbcr_y = cbcr_yscl_factor;
+	win->vsd_cbr_gt4 = cbcr_vsd_bil_gt4;
+	win->vsd_cbr_gt2 = cbcr_vsd_bil_gt2;
+
+	DBG(1, "cbcr:h_fac=%d,v_fac=%d,gt4=%d,gt2=%d\n", cbcr_xscl_factor,
+	    cbcr_yscl_factor, cbcr_vsd_bil_gt4, cbcr_vsd_bil_gt2);
+	return 0;
+}
+
+static int dsp_x_pos(int mirror_en, struct rk_screen *screen,
+		     struct rk_lcdc_win_area *area)
+{
+	int pos;
+
+	if (screen->x_mirror && mirror_en)
+		pr_err("not support both win and global mirror\n");
+
+	if ((!mirror_en) && (!screen->x_mirror))
+		pos = area->xpos + screen->mode.left_margin +
+			screen->mode.hsync_len;
+	else
+		pos = screen->mode.xres - area->xpos -
+			area->xsize + screen->mode.left_margin +
+			screen->mode.hsync_len;
+
+	return pos;
+}
+
+static int dsp_y_pos(int mirror_en, struct rk_screen *screen,
+		     struct rk_lcdc_win_area *area)
+{
+	int pos;
+
+	if (screen->y_mirror && mirror_en)
+		pr_err("not support both win and global mirror\n");
+	if (!(screen->mode.vmode & FB_VMODE_INTERLACED)) {
+		if ((!mirror_en) && (!screen->y_mirror))
+			pos = area->ypos + screen->mode.upper_margin +
+				screen->mode.vsync_len;
+		else
+			pos = screen->mode.yres - area->ypos -
+				area->ysize + screen->mode.upper_margin +
+				screen->mode.vsync_len;
+	} else {
+		pos = area->ypos / 2 + screen->mode.upper_margin +
+			screen->mode.vsync_len;
+		area->ysize /= 2;
+	}
+
+	return pos;
+}
+
+static int win_0_1_set_par(struct lcdc_device *lcdc_dev,
+			   struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	u32 xact = 0, yact = 0, xvir = 0, yvir = 0, xpos = 0, ypos = 0;
+	u8 fmt_cfg = 0, swap_rb = 0, swap_uv = 0;
+	char fmt[9] = "NULL";
+
+	xpos = dsp_x_pos(win->xmirror, screen, &win->area[0]);
+	ypos = dsp_y_pos(win->ymirror, screen, &win->area[0]);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		rk3368_lcdc_cal_scl_fac(win, screen);	/*fac,lb,gt2,gt4 */
+		switch (win->area[0].format) {
+		case FBDC_RGB_565:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].fbdc_fmt_cfg = 0x05;
+			break;
+		case FBDC_ARGB_888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].fbdc_fmt_cfg = 0x0c;
+			break;
+		case FBDC_ABGR_888:
+			fmt_cfg = 0;
+			swap_rb = 1;
+			win->fmt_10 = 0;
+			win->area[0].fbdc_fmt_cfg = 0x0c;
+			break;
+		case FBDC_RGBX_888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			win->area[0].fbdc_fmt_cfg = 0x3a;
+			break;
+		case ARGB888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case XBGR888:
+		case ABGR888:
+			fmt_cfg = 0;
+			swap_rb = 1;
+			win->fmt_10 = 0;
+			break;
+		case BGR888:
+			fmt_cfg = 1;
+			swap_rb = 1;
+			win->fmt_10 = 0;
+			break;
+		case RGB888:
+			fmt_cfg = 1;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case RGB565:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV422:
+			fmt_cfg = 5;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV420:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV420_NV21:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			swap_uv = 1;
+			win->fmt_10 = 0;
+			break;
+		case YUV444:
+			fmt_cfg = 6;
+			swap_rb = 0;
+			win->fmt_10 = 0;
+			break;
+		case YUV422_A:
+			fmt_cfg = 5;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUV420_A:
+			fmt_cfg = 4;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		case YUV444_A:
+			fmt_cfg = 6;
+			swap_rb = 0;
+			win->fmt_10 = 1;
+			break;
+		default:
+			dev_err(lcdc_dev->driver.dev, "%s:unsupport format!\n",
+				__func__);
+			break;
+		}
+		win->area[0].fmt_cfg = fmt_cfg;
+		win->area[0].swap_rb = swap_rb;
+		win->area[0].swap_uv = swap_uv;
+		win->area[0].dsp_stx = xpos;
+		win->area[0].dsp_sty = ypos;
+		xact = win->area[0].xact;
+		yact = win->area[0].yact;
+		xvir = win->area[0].xvir;
+		yvir = win->area[0].yvir;
+	}
+	if (win->area[0].fbdc_en)
+		rk3368_init_fbdc_config(&lcdc_dev->driver, win->id);
+	rk3368_win_0_1_reg_update(&lcdc_dev->driver, win->id);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	DBG(1, "lcdc[%d]:win[%d]\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
+	    lcdc_dev->id, win->id, get_format_string(win->area[0].format, fmt),
+	    xact, yact, win->area[0].xsize);
+	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+	    win->area[0].ysize, xvir, yvir, xpos, ypos);
+
+	return 0;
+}
+
+
+static int win_2_3_set_par(struct lcdc_device *lcdc_dev,
+			   struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	int i;
+	u8 fmt_cfg = 0, swap_rb = 0;
+	char fmt[9] = "NULL";
+
+	if (win->ymirror)
+		pr_err("win[%d] not support y mirror\n", win->id);
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		DBG(2, "lcdc[%d]:win[%d]>>\n>\n", lcdc_dev->id, win->id);
+		for (i = 0; i < win->area_num; i++) {
+			switch (win->area[i].format) {
+			case FBDC_RGB_565:
+				fmt_cfg = 2;
+				swap_rb = 0;
+				win->fmt_10 = 0;
+				win->area[0].fbdc_fmt_cfg = 0x05;
+				break;
+			case FBDC_ARGB_888:
+				fmt_cfg = 0;
+				swap_rb = 0;
+				win->fmt_10 = 0;
+				win->area[0].fbdc_fmt_cfg = 0x0c;
+				break;
+			case FBDC_ABGR_888:
+				fmt_cfg = 0;
+				swap_rb = 1;
+				win->fmt_10 = 0;
+				win->area[0].fbdc_fmt_cfg = 0x0c;
+				break;
+			case FBDC_RGBX_888:
+				fmt_cfg = 0;
+				swap_rb = 0;
+				win->fmt_10 = 0;
+				win->area[0].fbdc_fmt_cfg = 0x3a;
+				break;
+			case ARGB888:
+				fmt_cfg = 0;
+				swap_rb = 0;
+				break;
+			case XBGR888:
+			case ABGR888:
+				fmt_cfg = 0;
+				swap_rb = 1;
+				break;
+			case RGB888:
+				fmt_cfg = 1;
+				swap_rb = 0;
+				break;
+			case RGB565:
+				fmt_cfg = 2;
+				swap_rb = 0;
+				break;
+			default:
+				dev_err(lcdc_dev->driver.dev,
+					"%s:un supported format!\n", __func__);
+				break;
+			}
+			win->area[i].fmt_cfg = fmt_cfg;
+			win->area[i].swap_rb = swap_rb;
+			win->area[i].dsp_stx =
+					dsp_x_pos(win->xmirror, screen,
+						  &win->area[i]);
+			win->area[i].dsp_sty =
+					dsp_y_pos(win->ymirror, screen,
+						  &win->area[i]);
+			if (((win->area[i].xact != win->area[i].xsize) ||
+			     (win->area[i].yact != win->area[i].ysize)) &&
+			     !(screen->mode.vmode & FB_VMODE_INTERLACED)) {
+				pr_err("win[%d]->area[%d],not support scale\n",
+				       win->id, i);
+				pr_err("xact=%d,yact=%d,xsize=%d,ysize=%d\n",
+				       win->area[i].xact, win->area[i].yact,
+				       win->area[i].xsize, win->area[i].ysize);
+				win->area[i].xsize = win->area[i].xact;
+				win->area[i].ysize = win->area[i].yact;
+			}
+			DBG(2, "fmt:%s:xsize:%d>>ysize:%d>>xpos:%d>>ypos:%d\n",
+			    get_format_string(win->area[i].format, fmt),
+			    win->area[i].xsize, win->area[i].ysize,
+			    win->area[i].xpos, win->area[i].ypos);
+		}
+	}
+	if (win->area[0].fbdc_en)
+		rk3368_init_fbdc_config(&lcdc_dev->driver, win->id);
+	rk3368_win_2_3_reg_update(&lcdc_dev->driver, win->id);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int hwc_set_par(struct lcdc_device *lcdc_dev,
+		       struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	u32 xact = 0, yact = 0, xvir = 0, yvir = 0, xpos = 0, ypos = 0;
+	u8 fmt_cfg = 0, swap_rb = 0;
+	char fmt[9] = "NULL";
+
+	xpos = win->area[0].xpos + screen->mode.left_margin +
+	    screen->mode.hsync_len;
+	ypos = win->area[0].ypos + screen->mode.upper_margin +
+	    screen->mode.vsync_len;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		/*rk3368_lcdc_cal_scl_fac(win); *//*fac,lb,gt2,gt4 */
+		switch (win->area[0].format) {
+		case ARGB888:
+			fmt_cfg = 0;
+			swap_rb = 0;
+			break;
+		case XBGR888:
+		case ABGR888:
+			fmt_cfg = 0;
+			swap_rb = 1;
+			break;
+		case RGB888:
+			fmt_cfg = 1;
+			swap_rb = 0;
+			break;
+		case RGB565:
+			fmt_cfg = 2;
+			swap_rb = 0;
+			break;
+		default:
+			dev_err(lcdc_dev->driver.dev,
+				"%s:un supported format!\n", __func__);
+			break;
+		}
+		win->area[0].fmt_cfg = fmt_cfg;
+		win->area[0].swap_rb = swap_rb;
+		win->area[0].dsp_stx = xpos;
+		win->area[0].dsp_sty = ypos;
+		xact = win->area[0].xact;
+		yact = win->area[0].yact;
+		xvir = win->area[0].xvir;
+		yvir = win->area[0].yvir;
+	}
+	rk3368_hwc_reg_update(&lcdc_dev->driver, 4);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	DBG(1, "lcdc[%d]:hwc>>%s\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
+	    lcdc_dev->id, __func__, get_format_string(win->area[0].format, fmt),
+	    xact, yact, win->area[0].xsize);
+	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+	    win->area[0].ysize, xvir, yvir, xpos, ypos);
+	return 0;
+}
+
+static int rk3368_lcdc_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	win = dev_drv->win[win_id];
+	switch (win_id) {
+	case 0:
+		win_0_1_set_par(lcdc_dev, screen, win);
+		break;
+	case 1:
+		win_0_1_set_par(lcdc_dev, screen, win);
+		break;
+	case 2:
+		win_2_3_set_par(lcdc_dev, screen, win);
+		break;
+	case 3:
+		win_2_3_set_par(lcdc_dev, screen, win);
+		break;
+	case 4:
+		hwc_set_par(lcdc_dev, screen, win);
+		break;
+	default:
+		dev_err(dev_drv->dev, "unsupported win number:%d\n", win_id);
+		break;
+	}
+	return 0;
+}
+
+static int rk3368_lcdc_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
+			     unsigned long arg, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	struct color_key_cfg clr_key_cfg;
+
+	switch (cmd) {
+	case RK_FBIOGET_PANEL_SIZE:
+		panel_size[0] = lcdc_dev->screen->mode.xres;
+		panel_size[1] = lcdc_dev->screen->mode.yres;
+		if (copy_to_user(argp, panel_size, 8))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_COLOR_KEY_CFG:
+		if (copy_from_user(&clr_key_cfg, argp,
+				   sizeof(struct color_key_cfg)))
+			return -EFAULT;
+		rk3368_lcdc_clr_key_cfg(dev_drv);
+		lcdc_writel(lcdc_dev, WIN0_COLOR_KEY,
+			    clr_key_cfg.win0_color_key_cfg);
+		lcdc_writel(lcdc_dev, WIN1_COLOR_KEY,
+			    clr_key_cfg.win1_color_key_cfg);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int rk3368_lcdc_get_backlight_device(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev = container_of(dev_drv,
+						    struct lcdc_device, driver);
+	struct device_node *backlight;
+	struct property *prop;
+	u32 brightness_levels[256];
+	u32 length, max, last;
+
+	if (lcdc_dev->backlight)
+		return 0;
+	backlight = of_parse_phandle(lcdc_dev->dev->of_node, "backlight", 0);
+	if (backlight) {
+		lcdc_dev->backlight = of_find_backlight_by_node(backlight);
+		if (!lcdc_dev->backlight)
+			dev_info(lcdc_dev->dev, "No find backlight device\n");
+	} else {
+		dev_info(lcdc_dev->dev, "No find backlight device node\n");
+	}
+	prop = of_find_property(backlight, "brightness-levels", &length);
+	if (!prop)
+		return -EINVAL;
+	max = length / sizeof(u32);
+	last = max - 1;
+	if (!of_property_read_u32_array(backlight, "brightness-levels",
+					brightness_levels, max)) {
+		if (brightness_levels[0] > brightness_levels[last])
+			dev_drv->cabc_pwm_pol = 1;/*negative*/
+		else
+			dev_drv->cabc_pwm_pol = 0;/*positive*/
+	} else {
+		dev_info(lcdc_dev->dev, "Can not read brightness-levels value\n");
+	}
+	return 0;
+}
+
+static int rk3368_lcdc_early_suspend(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 intr_clr_reg;
+
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
+		intr_clr_reg = INTR_CLEAR_RK3366;
+	else
+		intr_clr_reg = INTR_CLEAR_RK3368;
+
+	if (dev_drv->suspend_flag)
+		return 0;
+	/* close the backlight */
+	/*rk3368_lcdc_get_backlight_device(dev_drv);
+	if (lcdc_dev->backlight) {
+		lcdc_dev->backlight->props.fb_blank = FB_BLANK_POWERDOWN;
+		backlight_update_status(lcdc_dev->backlight);
+	}*/
+
+	dev_drv->suspend_flag = 1;
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (likely(lcdc_dev->clk_on)) {
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLANK_EN,
+			     v_DSP_BLANK_EN(1));
+		lcdc_msk_reg(lcdc_dev,
+			     intr_clr_reg, m_FS_INTR_CLR | m_LINE_FLAG0_INTR_CLR,
+			     v_FS_INTR_CLR(1) | v_LINE_FLAG0_INTR_CLR(1));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(1));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN, v_STANDBY_EN(1));
+		lcdc_cfg_done(lcdc_dev);
+
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	rk3368_lcdc_clk_disable(lcdc_dev);
+	rk_disp_pwr_disable(dev_drv);
+	return 0;
+}
+
+static int rk3368_lcdc_early_resume(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (!dev_drv->suspend_flag)
+		return 0;
+	rk_disp_pwr_enable(dev_drv);
+
+	if (1/*lcdc_dev->atv_layer_cnt*/) {
+		rk3368_lcdc_clk_enable(lcdc_dev);
+		rk3368_lcdc_reg_restore(lcdc_dev);
+
+		spin_lock(&lcdc_dev->reg_lock);
+		if (dev_drv->cur_screen->dsp_lut)
+			rk3368_lcdc_set_lut(dev_drv,
+					    dev_drv->cur_screen->dsp_lut);
+		if (dev_drv->cur_screen->cabc_lut && dev_drv->cabc_mode)
+			rk3368_set_cabc_lut(dev_drv,
+					    dev_drv->cur_screen->cabc_lut);
+
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_OUT_ZERO,
+			     v_DSP_OUT_ZERO(0));
+		lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN, v_STANDBY_EN(0));
+		lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLANK_EN,
+			     v_DSP_BLANK_EN(0));
+		lcdc_cfg_done(lcdc_dev);
+
+		if (dev_drv->iommu_enabled) {
+			/* win address maybe effect after next frame start,
+			 * but mmu maybe effect right now, so we delay 50ms
+			 */
+			mdelay(50);
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_activate(dev_drv->dev);
+		}
+
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	dev_drv->suspend_flag = 0;
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+	mdelay(100);
+	return 0;
+}
+
+static int rk3368_lcdc_blank(struct rk_lcdc_driver *dev_drv,
+			     int win_id, int blank_mode)
+{
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		rk3368_lcdc_early_resume(dev_drv);
+		break;
+	case FB_BLANK_NORMAL:
+		rk3368_lcdc_early_suspend(dev_drv);
+		break;
+	default:
+		rk3368_lcdc_early_suspend(dev_drv);
+		break;
+	}
+
+	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
+
+	return 0;
+}
+
+static int rk3368_lcdc_get_win_state(struct rk_lcdc_driver *dev_drv,
+				     int win_id, int area_id)
+{
+	struct lcdc_device *lcdc_dev =
+		container_of(dev_drv, struct lcdc_device, driver);
+	u32 win_ctrl = 0;
+	u32 area_status = 0, state = 0;
+
+	switch (win_id) {
+	case 0:
+		win_ctrl = lcdc_readl(lcdc_dev, WIN0_CTRL0);
+		area_status = win_ctrl & m_WIN0_EN;
+		break;
+	case 1:
+		win_ctrl = lcdc_readl(lcdc_dev, WIN1_CTRL0);
+		area_status = win_ctrl & m_WIN1_EN;
+		break;
+	case 2:
+		win_ctrl = lcdc_readl(lcdc_dev, WIN2_CTRL0);
+		if (area_id == 0)
+			area_status = win_ctrl & (m_WIN2_MST0_EN | m_WIN2_EN);
+		if (area_id == 1)
+			area_status = win_ctrl & m_WIN2_MST1_EN;
+		if (area_id == 2)
+			area_status = win_ctrl & m_WIN2_MST2_EN;
+		if (area_id == 3)
+			area_status = win_ctrl & m_WIN2_MST3_EN;
+		break;
+	case 3:
+		win_ctrl = lcdc_readl(lcdc_dev, WIN3_CTRL0);
+		if (area_id == 0)
+			area_status = win_ctrl & (m_WIN3_MST0_EN | m_WIN3_EN);
+		if (area_id == 1)
+			area_status = win_ctrl & m_WIN3_MST1_EN;
+		if (area_id == 2)
+			area_status = win_ctrl & m_WIN3_MST2_EN;
+		if (area_id == 3)
+			area_status = win_ctrl & m_WIN3_MST3_EN;
+		break;
+	case 4:
+		win_ctrl = lcdc_readl(lcdc_dev, HWC_CTRL0);
+		area_status = win_ctrl & m_HWC_EN;
+		break;
+	default:
+		pr_err("!!!%s,win[%d]area[%d],unsupport!!!\n",
+		       __func__, win_id, area_id);
+		break;
+	}
+
+	state = (area_status > 0) ? 1 : 0;
+	return state;
+}
+
+static int rk3368_lcdc_get_area_num(struct rk_lcdc_driver *dev_drv,
+				    unsigned int *area_support)
+{
+	area_support[0] = 1;
+	area_support[1] = 1;
+	area_support[2] = 4;
+	area_support[3] = 4;
+
+	return 0;
+}
+
+/*overlay will be do at regupdate*/
+static int rk3368_lcdc_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_lcdc_win *win = NULL;
+	int i, ovl = 0;
+	unsigned int mask, val;
+	int z_order_num = 0;
+	int layer0_sel = 0, layer1_sel = 1, layer2_sel = 2, layer3_sel = 3;
+
+	if (swap == 0) {
+		for (i = 0; i < 4; i++) {
+			win = dev_drv->win[i];
+			if (win->state == 1)
+				z_order_num++;
+		}
+		for (i = 0; i < 4; i++) {
+			win = dev_drv->win[i];
+			if (win->state == 0)
+				win->z_order = z_order_num++;
+			switch (win->z_order) {
+			case 0:
+				layer0_sel = win->id;
+				break;
+			case 1:
+				layer1_sel = win->id;
+				break;
+			case 2:
+				layer2_sel = win->id;
+				break;
+			case 3:
+				layer3_sel = win->id;
+				break;
+			default:
+				break;
+			}
+		}
+	} else {
+		layer0_sel = swap % 10;
+		layer1_sel = swap / 10 % 10;
+		layer2_sel = swap / 100 % 10;
+		layer3_sel = swap / 1000;
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (set) {
+			mask = m_DSP_LAYER0_SEL | m_DSP_LAYER1_SEL |
+			    m_DSP_LAYER2_SEL | m_DSP_LAYER3_SEL;
+			val = v_DSP_LAYER0_SEL(layer0_sel) |
+			    v_DSP_LAYER1_SEL(layer1_sel) |
+			    v_DSP_LAYER2_SEL(layer2_sel) |
+			    v_DSP_LAYER3_SEL(layer3_sel);
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL1, mask, val);
+		} else {
+			layer0_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1,
+						   m_DSP_LAYER0_SEL);
+			layer1_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1,
+						   m_DSP_LAYER1_SEL);
+			layer2_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1,
+						   m_DSP_LAYER2_SEL);
+			layer3_sel = lcdc_read_bit(lcdc_dev, DSP_CTRL1,
+						   m_DSP_LAYER3_SEL);
+			ovl = layer3_sel * 1000 + layer2_sel * 100 +
+			    layer1_sel * 10 + layer0_sel;
+		}
+	} else {
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+static char *rk3368_lcdc_format_to_string(int format, char *fmt)
+{
+	if (!fmt)
+		return NULL;
+
+	switch (format) {
+	case 0:
+		strcpy(fmt, "ARGB888");
+		break;
+	case 1:
+		strcpy(fmt, "RGB888");
+		break;
+	case 2:
+		strcpy(fmt, "RGB565");
+		break;
+	case 4:
+		strcpy(fmt, "YCbCr420");
+		break;
+	case 5:
+		strcpy(fmt, "YCbCr422");
+		break;
+	case 6:
+		strcpy(fmt, "YCbCr444");
+		break;
+	default:
+		strcpy(fmt, "invalid\n");
+		break;
+	}
+	return fmt;
+}
+static ssize_t rk3368_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
+					 char *buf, int win_id)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 hsync_len = screen->mode.hsync_len;
+	u16 left_margin = screen->mode.left_margin;
+	u16 vsync_len = screen->mode.vsync_len;
+	u16 upper_margin = screen->mode.upper_margin;
+	u32 h_pw_bp = hsync_len + left_margin;
+	u32 v_pw_bp = vsync_len + upper_margin;
+	u32 fmt_id;
+	char format_w0[9] = "NULL";
+	char format_w1[9] = "NULL";
+	char format_w2_0[9] = "NULL";
+	char format_w2_1[9] = "NULL";
+	char format_w2_2[9] = "NULL";
+	char format_w2_3[9] = "NULL";
+	char format_w3_0[9] = "NULL";
+	char format_w3_1[9] = "NULL";
+	char format_w3_2[9] = "NULL";
+	char format_w3_3[9] = "NULL";
+	char dsp_buf[100];
+	u32 win_ctrl, zorder, vir_info, act_info, dsp_info, dsp_st;
+	u32 y_factor, uv_factor;
+	u8 layer0_sel, layer1_sel, layer2_sel, layer3_sel;
+	u8 w0_state, w1_state, w2_state, w3_state;
+	u8 w2_0_state, w2_1_state, w2_2_state, w2_3_state;
+	u8 w3_0_state, w3_1_state, w3_2_state, w3_3_state;
+
+	u32 w0_vir_y, w0_vir_uv, w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y;
+	u32 w0_st_x = h_pw_bp, w0_st_y = v_pw_bp;
+	u32 w1_vir_y, w1_vir_uv, w1_act_x, w1_act_y, w1_dsp_x, w1_dsp_y;
+	u32 w1_st_x = h_pw_bp, w1_st_y = v_pw_bp;
+	u32 w0_y_h_fac, w0_y_v_fac, w0_uv_h_fac, w0_uv_v_fac;
+	u32 w1_y_h_fac, w1_y_v_fac, w1_uv_h_fac, w1_uv_v_fac;
+
+	u32 w2_0_vir_y, w2_1_vir_y, w2_2_vir_y, w2_3_vir_y;
+	u32 w2_0_dsp_x, w2_1_dsp_x, w2_2_dsp_x, w2_3_dsp_x;
+	u32 w2_0_dsp_y, w2_1_dsp_y, w2_2_dsp_y, w2_3_dsp_y;
+	u32 w2_0_st_x = h_pw_bp, w2_1_st_x = h_pw_bp;
+	u32 w2_2_st_x = h_pw_bp, w2_3_st_x = h_pw_bp;
+	u32 w2_0_st_y = v_pw_bp, w2_1_st_y = v_pw_bp;
+	u32 w2_2_st_y = v_pw_bp, w2_3_st_y = v_pw_bp;
+
+	u32 w3_0_vir_y, w3_1_vir_y, w3_2_vir_y, w3_3_vir_y;
+	u32 w3_0_dsp_x, w3_1_dsp_x, w3_2_dsp_x, w3_3_dsp_x;
+	u32 w3_0_dsp_y, w3_1_dsp_y, w3_2_dsp_y, w3_3_dsp_y;
+	u32 w3_0_st_x = h_pw_bp, w3_1_st_x = h_pw_bp;
+	u32 w3_2_st_x = h_pw_bp, w3_3_st_x = h_pw_bp;
+	u32 w3_0_st_y = v_pw_bp, w3_1_st_y = v_pw_bp;
+	u32 w3_2_st_y = v_pw_bp, w3_3_st_y = v_pw_bp;
+	u32 dclk_freq;
+	int size = 0;
+
+	dclk_freq = screen->mode.pixclock;
+	/*rk3368_lcdc_reg_dump(dev_drv); */
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		zorder = lcdc_readl(lcdc_dev, DSP_CTRL1);
+		layer0_sel = (zorder & m_DSP_LAYER0_SEL) >> 8;
+		layer1_sel = (zorder & m_DSP_LAYER1_SEL) >> 10;
+		layer2_sel = (zorder & m_DSP_LAYER2_SEL) >> 12;
+		layer3_sel = (zorder & m_DSP_LAYER3_SEL) >> 14;
+		/*WIN0 */
+		win_ctrl = lcdc_readl(lcdc_dev, WIN0_CTRL0);
+		w0_state = win_ctrl & m_WIN0_EN;
+		fmt_id = (win_ctrl & m_WIN0_DATA_FMT) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w0);
+		vir_info = lcdc_readl(lcdc_dev, WIN0_VIR);
+		act_info = lcdc_readl(lcdc_dev, WIN0_ACT_INFO);
+		dsp_info = lcdc_readl(lcdc_dev, WIN0_DSP_INFO);
+		dsp_st = lcdc_readl(lcdc_dev, WIN0_DSP_ST);
+		y_factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_YRGB);
+		uv_factor = lcdc_readl(lcdc_dev, WIN0_SCL_FACTOR_CBR);
+		w0_vir_y = vir_info & m_WIN0_VIR_STRIDE;
+		w0_vir_uv = (vir_info & m_WIN0_VIR_STRIDE_UV) >> 16;
+		w0_act_x = (act_info & m_WIN0_ACT_WIDTH) + 1;
+		w0_act_y = ((act_info & m_WIN0_ACT_HEIGHT) >> 16) + 1;
+		w0_dsp_x = (dsp_info & m_WIN0_DSP_WIDTH) + 1;
+		w0_dsp_y = ((dsp_info & m_WIN0_DSP_HEIGHT) >> 16) + 1;
+		if (w0_state) {
+			w0_st_x = dsp_st & m_WIN0_DSP_XST;
+			w0_st_y = (dsp_st & m_WIN0_DSP_YST) >> 16;
+		}
+		w0_y_h_fac = y_factor & m_WIN0_HS_FACTOR_YRGB;
+		w0_y_v_fac = (y_factor & m_WIN0_VS_FACTOR_YRGB) >> 16;
+		w0_uv_h_fac = uv_factor & m_WIN0_HS_FACTOR_CBR;
+		w0_uv_v_fac = (uv_factor & m_WIN0_VS_FACTOR_CBR) >> 16;
+
+		/*WIN1 */
+		win_ctrl = lcdc_readl(lcdc_dev, WIN1_CTRL0);
+		w1_state = win_ctrl & m_WIN1_EN;
+		fmt_id = (win_ctrl & m_WIN1_DATA_FMT) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w1);
+		vir_info = lcdc_readl(lcdc_dev, WIN1_VIR);
+		act_info = lcdc_readl(lcdc_dev, WIN1_ACT_INFO);
+		dsp_info = lcdc_readl(lcdc_dev, WIN1_DSP_INFO);
+		dsp_st = lcdc_readl(lcdc_dev, WIN1_DSP_ST);
+		y_factor = lcdc_readl(lcdc_dev, WIN1_SCL_FACTOR_YRGB);
+		uv_factor = lcdc_readl(lcdc_dev, WIN1_SCL_FACTOR_CBR);
+		w1_vir_y = vir_info & m_WIN1_VIR_STRIDE;
+		w1_vir_uv = (vir_info & m_WIN1_VIR_STRIDE_UV) >> 16;
+		w1_act_x = (act_info & m_WIN1_ACT_WIDTH) + 1;
+		w1_act_y = ((act_info & m_WIN1_ACT_HEIGHT) >> 16) + 1;
+		w1_dsp_x = (dsp_info & m_WIN1_DSP_WIDTH) + 1;
+		w1_dsp_y = ((dsp_info & m_WIN1_DSP_HEIGHT) >> 16) + 1;
+		if (w1_state) {
+			w1_st_x = dsp_st & m_WIN1_DSP_XST;
+			w1_st_y = (dsp_st & m_WIN1_DSP_YST) >> 16;
+		}
+		w1_y_h_fac = y_factor & m_WIN1_HS_FACTOR_YRGB;
+		w1_y_v_fac = (y_factor & m_WIN1_VS_FACTOR_YRGB) >> 16;
+		w1_uv_h_fac = uv_factor & m_WIN1_HS_FACTOR_CBR;
+		w1_uv_v_fac = (uv_factor & m_WIN1_VS_FACTOR_CBR) >> 16;
+		/*WIN2 */
+		win_ctrl = lcdc_readl(lcdc_dev, WIN2_CTRL0);
+		w2_state = win_ctrl & m_WIN2_EN;
+		w2_0_state = (win_ctrl & 0x10) >> 4;
+		w2_1_state = (win_ctrl & 0x100) >> 8;
+		w2_2_state = (win_ctrl & 0x1000) >> 12;
+		w2_3_state = (win_ctrl & 0x10000) >> 16;
+		vir_info = lcdc_readl(lcdc_dev, WIN2_VIR0_1);
+		w2_0_vir_y = vir_info & m_WIN2_VIR_STRIDE0;
+		w2_1_vir_y = (vir_info & m_WIN2_VIR_STRIDE1) >> 16;
+		vir_info = lcdc_readl(lcdc_dev, WIN2_VIR2_3);
+		w2_2_vir_y = vir_info & m_WIN2_VIR_STRIDE2;
+		w2_3_vir_y = (vir_info & m_WIN2_VIR_STRIDE3) >> 16;
+
+		fmt_id = (win_ctrl & m_WIN2_DATA_FMT0) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w2_0);
+		fmt_id = (win_ctrl & m_WIN2_DATA_FMT1) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w2_1);
+		fmt_id = (win_ctrl & m_WIN2_DATA_FMT2) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w2_2);
+		fmt_id = (win_ctrl & m_WIN2_DATA_FMT3) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w2_3);
+
+		dsp_info = lcdc_readl(lcdc_dev, WIN2_DSP_INFO0);
+		dsp_st = lcdc_readl(lcdc_dev, WIN2_DSP_ST0);
+		w2_0_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH0) + 1;
+		w2_0_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT0) >> 16) + 1;
+		if (w2_0_state) {
+			w2_0_st_x = dsp_st & m_WIN2_DSP_XST0;
+			w2_0_st_y = (dsp_st & m_WIN2_DSP_YST0) >> 16;
+		}
+		dsp_info = lcdc_readl(lcdc_dev, WIN2_DSP_INFO1);
+		dsp_st = lcdc_readl(lcdc_dev, WIN2_DSP_ST1);
+		w2_1_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH1) + 1;
+		w2_1_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT1) >> 16) + 1;
+		if (w2_1_state) {
+			w2_1_st_x = dsp_st & m_WIN2_DSP_XST1;
+			w2_1_st_y = (dsp_st & m_WIN2_DSP_YST1) >> 16;
+		}
+		dsp_info = lcdc_readl(lcdc_dev, WIN2_DSP_INFO2);
+		dsp_st = lcdc_readl(lcdc_dev, WIN2_DSP_ST2);
+		w2_2_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH2) + 1;
+		w2_2_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT2) >> 16) + 1;
+		if (w2_2_state) {
+			w2_2_st_x = dsp_st & m_WIN2_DSP_XST2;
+			w2_2_st_y = (dsp_st & m_WIN2_DSP_YST2) >> 16;
+		}
+		dsp_info = lcdc_readl(lcdc_dev, WIN2_DSP_INFO3);
+		dsp_st = lcdc_readl(lcdc_dev, WIN2_DSP_ST3);
+		w2_3_dsp_x = (dsp_info & m_WIN2_DSP_WIDTH3) + 1;
+		w2_3_dsp_y = ((dsp_info & m_WIN2_DSP_HEIGHT3) >> 16) + 1;
+		if (w2_3_state) {
+			w2_3_st_x = dsp_st & m_WIN2_DSP_XST3;
+			w2_3_st_y = (dsp_st & m_WIN2_DSP_YST3) >> 16;
+		}
+
+		/*WIN3 */
+		win_ctrl = lcdc_readl(lcdc_dev, WIN3_CTRL0);
+		w3_state = win_ctrl & m_WIN3_EN;
+		w3_0_state = (win_ctrl & m_WIN3_MST0_EN) >> 4;
+		w3_1_state = (win_ctrl & m_WIN3_MST1_EN) >> 8;
+		w3_2_state = (win_ctrl & m_WIN3_MST2_EN) >> 12;
+		w3_3_state = (win_ctrl & m_WIN3_MST3_EN) >> 16;
+		vir_info = lcdc_readl(lcdc_dev, WIN3_VIR0_1);
+		w3_0_vir_y = vir_info & m_WIN3_VIR_STRIDE0;
+		w3_1_vir_y = (vir_info & m_WIN3_VIR_STRIDE1) >> 16;
+		vir_info = lcdc_readl(lcdc_dev, WIN3_VIR2_3);
+		w3_2_vir_y = vir_info & m_WIN3_VIR_STRIDE2;
+		w3_3_vir_y = (vir_info & m_WIN3_VIR_STRIDE3) >> 16;
+		fmt_id = (win_ctrl & m_WIN3_DATA_FMT0) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w3_0);
+		fmt_id = (win_ctrl & m_WIN3_DATA_FMT1) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w3_1);
+		fmt_id = (win_ctrl & m_WIN3_DATA_FMT2) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w3_2);
+		fmt_id = (win_ctrl & m_WIN3_DATA_FMT3) >> 1;
+		rk3368_lcdc_format_to_string(fmt_id, format_w3_3);
+		dsp_info = lcdc_readl(lcdc_dev, WIN3_DSP_INFO0);
+		dsp_st = lcdc_readl(lcdc_dev, WIN3_DSP_ST0);
+		w3_0_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH0) + 1;
+		w3_0_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT0) >> 16) + 1;
+		if (w3_0_state) {
+			w3_0_st_x = dsp_st & m_WIN3_DSP_XST0;
+			w3_0_st_y = (dsp_st & m_WIN3_DSP_YST0) >> 16;
+		}
+
+		dsp_info = lcdc_readl(lcdc_dev, WIN3_DSP_INFO1);
+		dsp_st = lcdc_readl(lcdc_dev, WIN3_DSP_ST1);
+		w3_1_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH1) + 1;
+		w3_1_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT1) >> 16) + 1;
+		if (w3_1_state) {
+			w3_1_st_x = dsp_st & m_WIN3_DSP_XST1;
+			w3_1_st_y = (dsp_st & m_WIN3_DSP_YST1) >> 16;
+		}
+
+		dsp_info = lcdc_readl(lcdc_dev, WIN3_DSP_INFO2);
+		dsp_st = lcdc_readl(lcdc_dev, WIN3_DSP_ST2);
+		w3_2_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH2) + 1;
+		w3_2_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT2) >> 16) + 1;
+		if (w3_2_state) {
+			w3_2_st_x = dsp_st & m_WIN3_DSP_XST2;
+			w3_2_st_y = (dsp_st & m_WIN3_DSP_YST2) >> 16;
+		}
+
+		dsp_info = lcdc_readl(lcdc_dev, WIN3_DSP_INFO3);
+		dsp_st = lcdc_readl(lcdc_dev, WIN3_DSP_ST3);
+		w3_3_dsp_x = (dsp_info & m_WIN3_DSP_WIDTH3) + 1;
+		w3_3_dsp_y = ((dsp_info & m_WIN3_DSP_HEIGHT3) >> 16) + 1;
+		if (w3_3_state) {
+			w3_3_st_x = dsp_st & m_WIN3_DSP_XST3;
+			w3_3_st_y = (dsp_st & m_WIN3_DSP_YST3) >> 16;
+		}
+
+	} else {
+		spin_unlock(&lcdc_dev->reg_lock);
+		return -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	size += snprintf(dsp_buf, 80,
+		"z-order:\n  win[%d]\n  win[%d]\n  win[%d]\n  win[%d]\n",
+		layer3_sel, layer2_sel, layer1_sel, layer0_sel);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	/*win0*/
+	size += snprintf(dsp_buf, 80,
+		 "win0:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
+		 w0_state, format_w0, w0_vir_y, w0_vir_uv);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
+		 w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
+		 w0_st_x-h_pw_bp, w0_st_y-v_pw_bp, w0_y_h_fac, w0_y_v_fac);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
+		 w0_uv_h_fac, w0_uv_v_fac, lcdc_readl(lcdc_dev, WIN0_YRGB_MST),
+		 lcdc_readl(lcdc_dev, WIN0_CBR_MST));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*win1*/
+	size += snprintf(dsp_buf, 80,
+		 "win1:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
+		 w1_state, format_w1, w1_vir_y, w1_vir_uv);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
+		 w1_act_x, w1_act_y, w1_dsp_x, w1_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
+		 w1_st_x-h_pw_bp, w1_st_y-v_pw_bp, w1_y_h_fac, w1_y_v_fac);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
+		 w1_uv_h_fac, w1_uv_v_fac, lcdc_readl(lcdc_dev, WIN1_YRGB_MST),
+		 lcdc_readl(lcdc_dev, WIN1_CBR_MST));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*win2*/
+	size += snprintf(dsp_buf, 80,
+		 "win2:\n  state:%d\n",
+		 w2_state);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	/*area 0*/
+	size += snprintf(dsp_buf, 80,
+		 "  area0: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w2_0_state, format_w2_0, w2_0_dsp_x, w2_0_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w2_0_st_x - h_pw_bp, w2_0_st_y - v_pw_bp,
+		 lcdc_readl(lcdc_dev, WIN2_MST0));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 1*/
+	size += snprintf(dsp_buf, 80,
+		 "  area1: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w2_1_state, format_w2_1, w2_1_dsp_x, w2_1_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w2_1_st_x - h_pw_bp, w2_1_st_y - v_pw_bp,
+		 lcdc_readl(lcdc_dev, WIN2_MST1));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 2*/
+	size += snprintf(dsp_buf, 80,
+		 "  area2: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w2_2_state, format_w2_2, w2_2_dsp_x, w2_2_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w2_2_st_x - h_pw_bp, w2_2_st_y - v_pw_bp,
+		 lcdc_readl(lcdc_dev, WIN2_MST2));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 3*/
+	size += snprintf(dsp_buf, 80,
+		 "  area3: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w2_3_state, format_w2_3, w2_3_dsp_x, w2_3_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w2_3_st_x - h_pw_bp, w2_3_st_y - v_pw_bp,
+		 lcdc_readl(lcdc_dev, WIN2_MST3));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*win3*/
+	size += snprintf(dsp_buf, 80,
+		 "win3:\n  state:%d\n",
+		 w3_state);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	/*area 0*/
+	size += snprintf(dsp_buf, 80,
+		 "  area0: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w3_0_state, format_w3_0, w3_0_dsp_x, w3_0_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w3_0_st_x - h_pw_bp, w3_0_st_y - v_pw_bp,
+		 lcdc_readl(lcdc_dev, WIN3_MST0));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 1*/
+	size += snprintf(dsp_buf, 80,
+		 "  area1: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w3_1_state, format_w3_1, w3_1_dsp_x, w3_1_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w3_1_st_x - h_pw_bp, w3_1_st_y - v_pw_bp,
+		 lcdc_readl(lcdc_dev, WIN3_MST1));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 2*/
+	size += snprintf(dsp_buf, 80,
+		 "  area2: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w3_2_state, format_w3_2, w3_2_dsp_x, w3_2_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w3_2_st_x - h_pw_bp, w3_2_st_y - v_pw_bp,
+		 lcdc_readl(lcdc_dev, WIN3_MST2));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/*area 3*/
+	size += snprintf(dsp_buf, 80,
+		 "  area3: state:%d, fmt:%7s, dsp_x:%4d, dsp_y:%4d,",
+		 w3_3_state, format_w3_3, w3_3_dsp_x, w3_3_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+	size += snprintf(dsp_buf, 80,
+		 " x_st:%4d, y_st:%4d, y_addr:0x%08x\n",
+		 w3_3_st_x - h_pw_bp, w3_3_st_y - v_pw_bp,
+		 lcdc_readl(lcdc_dev, WIN3_MST3));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	return size;
+}
+
+static int rk3368_lcdc_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps,
+			       bool set)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+	u32 pixclock;
+	u32 x_total, y_total;
+
+	if (set) {
+		if (fps == 0) {
+			dev_info(dev_drv->dev, "unsupport set fps=0\n");
+			return 0;
+		}
+		ft = div_u64(1000000000000llu, fps);
+		x_total =
+		    screen->mode.upper_margin + screen->mode.lower_margin +
+		    screen->mode.yres + screen->mode.vsync_len;
+		y_total =
+		    screen->mode.left_margin + screen->mode.right_margin +
+		    screen->mode.xres + screen->mode.hsync_len;
+		dev_drv->pixclock = div_u64(ft, x_total * y_total);
+		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+	}
+
+	pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	lcdc_dev->pixclock = pixclock;
+	dev_drv->pixclock = lcdc_dev->pixclock;
+	fps = rk_fb_calc_fps(screen, pixclock);
+	screen->ft = 1000 / fps;	/*one frame time in ms */
+
+	if (set)
+		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
+			 clk_get_rate(lcdc_dev->dclk), fps);
+
+	return fps;
+}
+
+static int rk3368_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
+{
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (order == FB_DEFAULT_ORDER)
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3_FB4_HWC;
+	dev_drv->fb4_win_id = order / 10000;
+	dev_drv->fb3_win_id = (order / 1000) % 10;
+	dev_drv->fb2_win_id = (order / 100) % 10;
+	dev_drv->fb1_win_id = (order / 10) % 10;
+	dev_drv->fb0_win_id = order % 10;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return 0;
+}
+
+static int rk3368_lcdc_get_win_id(struct rk_lcdc_driver *dev_drv,
+				  const char *id)
+{
+	int win_id = 0;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (!strcmp(id, "fb0") || !strcmp(id, "fb5"))
+		win_id = dev_drv->fb0_win_id;
+	else if (!strcmp(id, "fb1") || !strcmp(id, "fb6"))
+		win_id = dev_drv->fb1_win_id;
+	else if (!strcmp(id, "fb2") || !strcmp(id, "fb7"))
+		win_id = dev_drv->fb2_win_id;
+	else if (!strcmp(id, "fb3") || !strcmp(id, "fb8"))
+		win_id = dev_drv->fb3_win_id;
+	else if (!strcmp(id, "fb4") || !strcmp(id, "fb9"))
+		win_id = dev_drv->fb4_win_id;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return win_id;
+}
+
+static int rk3368_lcdc_config_done(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	int i;
+	unsigned int mask, val, fbdc_en = 0;
+	struct rk_lcdc_win *win = NULL;
+	u32 line_scane_num, dsp_vs_st_f1;
+
+	if (lcdc_dev->driver.cur_screen->mode.vmode & FB_VMODE_INTERLACED) {
+		dsp_vs_st_f1 = lcdc_readl(lcdc_dev, DSP_VS_ST_END_F1) >> 16;
+		for (i = 0; i < 1000; i++) {
+			line_scane_num =
+				lcdc_readl(lcdc_dev, SCAN_LINE_NUM) & 0x1fff;
+			if (line_scane_num > dsp_vs_st_f1 + 1)
+				udelay(50);
+			else
+				break;
+		}
+	}
+
+	spin_lock(&lcdc_dev->reg_lock);
+	rk3368_lcdc_post_cfg(dev_drv);
+	lcdc_msk_reg(lcdc_dev, SYS_CTRL, m_STANDBY_EN,
+		     v_STANDBY_EN(lcdc_dev->standby));
+	for (i = 0; i < 4; i++) {
+		win = dev_drv->win[i];
+		fbdc_en |= win->area[0].fbdc_en;
+		if ((win->state == 0) && (win->last_state == 1)) {
+			switch (win->id) {
+			case 0:
+				/*lcdc_writel(lcdc_dev,WIN0_CTRL1,0x0);
+				   for rk3288 to fix hw bug? */
+				mask = m_WIN0_EN;
+				val = v_WIN0_EN(0);
+				lcdc_msk_reg(lcdc_dev, WIN0_CTRL0, mask, val);
+				break;
+			case 1:
+				/*lcdc_writel(lcdc_dev,WIN1_CTRL1,0x0);
+				   for rk3288 to fix hw bug? */
+				mask = m_WIN1_EN;
+				val = v_WIN1_EN(0);
+				lcdc_msk_reg(lcdc_dev, WIN1_CTRL0, mask, val);
+				break;
+			case 2:
+				mask = m_WIN2_EN | m_WIN2_MST0_EN |
+				    m_WIN2_MST1_EN |
+				    m_WIN2_MST2_EN | m_WIN2_MST3_EN;
+				val = v_WIN2_EN(0) | v_WIN2_MST0_EN(0) |
+				    v_WIN2_MST1_EN(0) |
+				    v_WIN2_MST2_EN(0) | v_WIN2_MST3_EN(0);
+				lcdc_msk_reg(lcdc_dev, WIN2_CTRL0, mask, val);
+				break;
+			case 3:
+				mask = m_WIN3_EN | m_WIN3_MST0_EN |
+				    m_WIN3_MST1_EN |
+				    m_WIN3_MST2_EN | m_WIN3_MST3_EN;
+				val = v_WIN3_EN(0) | v_WIN3_MST0_EN(0) |
+				    v_WIN3_MST1_EN(0) |
+				    v_WIN3_MST2_EN(0) | v_WIN3_MST3_EN(0);
+				lcdc_msk_reg(lcdc_dev, WIN3_CTRL0, mask, val);
+				break;
+			case 4:
+				mask = m_HWC_EN;
+				val = v_HWC_EN(0);
+				lcdc_msk_reg(lcdc_dev, HWC_CTRL0, mask, val);
+				break;
+			default:
+				break;
+			}
+		}
+		win->last_state = win->state;
+	}
+	if (lcdc_dev->soc_type == VOP_FULL_RK3368) {
+		mask = m_IFBDC_CTRL_FBDC_EN;
+		val = v_IFBDC_CTRL_FBDC_EN(fbdc_en);
+		lcdc_msk_reg(lcdc_dev, IFBDC_CTRL, mask, val);
+	}
+	lcdc_cfg_done(lcdc_dev);
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk3368_lcdc_set_irq_to_cpu(struct rk_lcdc_driver *dev_drv,
+				      int enable)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	if (enable)
+		enable_irq(lcdc_dev->irq);
+	else
+		disable_irq(lcdc_dev->irq);
+	return 0;
+}
+
+int rk3368_lcdc_poll_vblank(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 int_reg_val;
+	int ret;
+	u32 intr_status_reg, intr_clear_reg;
+
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+		intr_status_reg = INTR_STATUS_RK3366;
+		intr_clear_reg = INTR_CLEAR_RK3366;
+	} else {
+		intr_status_reg = INTR_STATUS_RK3368;
+		intr_clear_reg = INTR_CLEAR_RK3368;
+	}
+
+	if (lcdc_dev->clk_on && (!dev_drv->suspend_flag)) {
+		int_reg_val = lcdc_readl(lcdc_dev, intr_status_reg);
+		if (int_reg_val & m_LINE_FLAG0_INTR_STS) {
+			lcdc_dev->driver.frame_time.last_framedone_t =
+			    lcdc_dev->driver.frame_time.framedone_t;
+			lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
+			lcdc_msk_reg(lcdc_dev, intr_clear_reg,
+				     m_LINE_FLAG0_INTR_CLR,
+				     v_LINE_FLAG0_INTR_CLR(1));
+			ret = RK_LF_STATUS_FC;
+		} else {
+			ret = RK_LF_STATUS_FR;
+		}
+	} else {
+		ret = RK_LF_STATUS_NC;
+	}
+
+	return ret;
+}
+
+static int rk3368_lcdc_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
+				    unsigned int dsp_addr[][4])
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		dsp_addr[0][0] = lcdc_readl(lcdc_dev, WIN0_YRGB_MST);
+		dsp_addr[1][0] = lcdc_readl(lcdc_dev, WIN1_YRGB_MST);
+		dsp_addr[2][0] = lcdc_readl(lcdc_dev, WIN2_MST0);
+		dsp_addr[2][1] = lcdc_readl(lcdc_dev, WIN2_MST1);
+		dsp_addr[2][2] = lcdc_readl(lcdc_dev, WIN2_MST2);
+		dsp_addr[2][3] = lcdc_readl(lcdc_dev, WIN2_MST3);
+		dsp_addr[3][0] = lcdc_readl(lcdc_dev, WIN3_MST0);
+		dsp_addr[3][1] = lcdc_readl(lcdc_dev, WIN3_MST1);
+		dsp_addr[3][2] = lcdc_readl(lcdc_dev, WIN3_MST2);
+		dsp_addr[3][3] = lcdc_readl(lcdc_dev, WIN3_MST3);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk3368_lcdc_set_dsp_cabc(struct rk_lcdc_driver *dev_drv,
+				    int mode, int calc, int up,
+				    int down, int global)
+{
+	struct lcdc_device *lcdc_dev =
+		container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u32 total_pixel, calc_pixel, stage_up, stage_down;
+	u32 pixel_num, global_dn;
+	u32 mask = 0, val = 0;
+	int *cabc_lut = NULL;
+
+	if (screen->type == SCREEN_HDMI && screen->type == SCREEN_TVOUT) {
+		pr_err("screen type is %d, not support cabc\n", screen->type);
+		return 0;
+	} else if (!screen->cabc_lut) {
+		pr_err("screen cabc lut not config, so not open cabc\n");
+		return 0;
+	} else {
+		cabc_lut = screen->cabc_lut;
+	}
+
+	if (mode == 0) {
+		spin_lock(&lcdc_dev->reg_lock);
+		if (lcdc_dev->clk_on) {
+			lcdc_msk_reg(lcdc_dev, CABC_CTRL0,
+				     m_CABC_EN, v_CABC_EN(0));
+			lcdc_cfg_done(lcdc_dev);
+		}
+		pr_info("mode = 0, close cabc\n");
+		dev_drv->cabc_mode = mode;
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	if (dev_drv->cabc_mode == 0)
+		rk3368_set_cabc_lut(dev_drv, dev_drv->cur_screen->cabc_lut);
+
+	total_pixel = screen->mode.xres * screen->mode.yres;
+	pixel_num = 1000 - calc;
+	calc_pixel = (total_pixel * pixel_num) / 1000;
+	stage_up = up;
+	stage_down = down;
+	global_dn = global;
+	pr_info("enable cabc:mode=%d, calc=%d, up=%d, down=%d, global=%d\n",
+		mode, calc, stage_up, stage_down, global_dn);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		mask = m_CABC_EN | m_CABC_HANDLE_EN | m_PWM_CONFIG_MODE |
+			m_CABC_CALC_PIXEL_NUM;
+		val = v_CABC_EN(1) | v_CABC_HANDLE_EN(1) |
+			v_PWM_CONFIG_MODE(STAGE_BY_STAGE) |
+			v_CABC_CALC_PIXEL_NUM(calc_pixel);
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL0, mask, val);
+
+		mask = m_CABC_LUT_EN | m_CABC_TOTAL_PIXEL_NUM;
+		val = v_CABC_LUT_EN(1) | v_CABC_TOTAL_PIXEL_NUM(total_pixel);
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL1, mask, val);
+
+		mask = m_CABC_STAGE_DOWN | m_CABC_STAGE_UP |
+			m_CABC_STAGE_MODE | m_MAX_SCALE_CFG_VALUE |
+			m_MAX_SCALE_CFG_ENABLE;
+		val = v_CABC_STAGE_DOWN(stage_down) |
+			v_CABC_STAGE_UP(stage_up) |
+			v_CABC_STAGE_MODE(0) | v_MAX_SCALE_CFG_VALUE(1) |
+			v_MAX_SCALE_CFG_ENABLE(0);
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL2, mask, val);
+
+		mask = m_CABC_GLOBAL_DN | m_CABC_GLOBAL_DN_LIMIT_EN;
+		val = v_CABC_GLOBAL_DN(global_dn) |
+			v_CABC_GLOBAL_DN_LIMIT_EN(1);
+		lcdc_msk_reg(lcdc_dev, CABC_CTRL3, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+		dev_drv->cabc_mode = mode;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+/*
+	a:[-30~0]:
+	    sin_hue = sin(a)*256 +0x100;
+	    cos_hue = cos(a)*256;
+	a:[0~30]
+	    sin_hue = sin(a)*256;
+	    cos_hue = cos(a)*256;
+*/
+static int rk3368_lcdc_get_bcsh_hue(struct rk_lcdc_driver *dev_drv,
+				    bcsh_hue_mode mode)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val = 0;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		val = lcdc_readl(lcdc_dev, BCSH_H);
+		switch (mode) {
+		case H_SIN:
+			val &= m_BCSH_SIN_HUE;
+			break;
+		case H_COS:
+			val &= m_BCSH_COS_HUE;
+			val >>= 16;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return val;
+}
+
+static int rk3368_lcdc_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,
+				    int sin_hue, int cos_hue)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		mask = m_BCSH_SIN_HUE | m_BCSH_COS_HUE;
+		val = v_BCSH_SIN_HUE(sin_hue) | v_BCSH_COS_HUE(cos_hue);
+		lcdc_msk_reg(lcdc_dev, BCSH_H, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static int rk3368_lcdc_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
+				    bcsh_bcs_mode mode, int value)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask = 0, val = 0;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		switch (mode) {
+		case BRIGHTNESS:
+			/*user: from 0 to 255,typical is 128,
+			 *vop,6bit: from 0 to 64, typical is 32*/
+			value /= 4;
+			if (value < 0x20)
+				value += 0x20;
+			else if (value >= 0x20)
+				value = value - 0x20;
+			mask = m_BCSH_BRIGHTNESS;
+			val = v_BCSH_BRIGHTNESS(value);
+			break;
+		case CONTRAST:
+			/*user: from 0 to 510,typical is 256
+			 *vop,9bit, from 0 to 511,typical is 256*/
+			value = 512 - value;
+			mask = m_BCSH_CONTRAST;
+			val = v_BCSH_CONTRAST(value);
+			break;
+		case SAT_CON:
+			/*from 0 to 1024,typical is 512
+			 *vop,9bit, from 0 to 512, typical is 256*/
+			value /= 2;
+			mask = m_BCSH_SAT_CON;
+			val = v_BCSH_SAT_CON(value);
+			break;
+		default:
+			break;
+		}
+		lcdc_msk_reg(lcdc_dev, BCSH_BCS, mask, val);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return val;
+}
+
+static int rk3368_lcdc_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
+				    bcsh_bcs_mode mode)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val = 0;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		val = lcdc_readl(lcdc_dev, BCSH_BCS);
+		switch (mode) {
+		case BRIGHTNESS:
+			val &= m_BCSH_BRIGHTNESS;
+			if (val >= 0x20)
+				val -= 0x20;
+			else
+				val += 0x20;
+			val <<= 2;
+			break;
+		case CONTRAST:
+			val &= m_BCSH_CONTRAST;
+			val >>= 8;
+			break;
+		case SAT_CON:
+			val &= m_BCSH_SAT_CON;
+			val >>= 20;
+			val <<= 1;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return val;
+}
+
+static int rk3368_lcdc_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 mask, val;
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if (lcdc_dev->clk_on) {
+		if (open) {
+			lcdc_writel(lcdc_dev, BCSH_COLOR_BAR, 0x1);
+			lcdc_writel(lcdc_dev, BCSH_BCS, 0xd0010000);
+			lcdc_writel(lcdc_dev, BCSH_H, 0x01000000);
+			dev_drv->bcsh.enable = 1;
+		} else {
+			mask = m_BCSH_EN;
+			val = v_BCSH_EN(0);
+			lcdc_msk_reg(lcdc_dev, BCSH_COLOR_BAR, mask, val);
+			dev_drv->bcsh.enable = 0;
+		}
+		rk3368_lcdc_bcsh_path_sel(dev_drv);
+		lcdc_cfg_done(lcdc_dev);
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	return 0;
+}
+
+static int rk3368_lcdc_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable)
+{
+	if (!enable || !dev_drv->bcsh.enable) {
+		rk3368_lcdc_open_bcsh(dev_drv, false);
+		return 0;
+	}
+
+	if (dev_drv->bcsh.brightness <= 255 ||
+	    dev_drv->bcsh.contrast <= 510 ||
+	    dev_drv->bcsh.sat_con <= 1015 ||
+	    (dev_drv->bcsh.sin_hue <= 511 && dev_drv->bcsh.cos_hue <= 511)) {
+		rk3368_lcdc_open_bcsh(dev_drv, true);
+		if (dev_drv->bcsh.brightness <= 255)
+			rk3368_lcdc_set_bcsh_bcs(dev_drv, BRIGHTNESS,
+						 dev_drv->bcsh.brightness);
+		if (dev_drv->bcsh.contrast <= 510)
+			rk3368_lcdc_set_bcsh_bcs(dev_drv, CONTRAST,
+						 dev_drv->bcsh.contrast);
+		if (dev_drv->bcsh.sat_con <= 1015)
+			rk3368_lcdc_set_bcsh_bcs(dev_drv, SAT_CON,
+						 dev_drv->bcsh.sat_con);
+		if (dev_drv->bcsh.sin_hue <= 511 &&
+		    dev_drv->bcsh.cos_hue <= 511)
+			rk3368_lcdc_set_bcsh_hue(dev_drv,
+						 dev_drv->bcsh.sin_hue,
+						 dev_drv->bcsh.cos_hue);
+	}
+	return 0;
+}
+
+static int __maybe_unused
+rk3368_lcdc_dsp_black(struct rk_lcdc_driver *dev_drv, int enable)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (enable) {
+		spin_lock(&lcdc_dev->reg_lock);
+		if (likely(lcdc_dev->clk_on)) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLACK_EN,
+				     v_DSP_BLACK_EN(1));
+			lcdc_cfg_done(lcdc_dev);
+		}
+		spin_unlock(&lcdc_dev->reg_lock);
+	} else {
+		spin_lock(&lcdc_dev->reg_lock);
+		if (likely(lcdc_dev->clk_on)) {
+			lcdc_msk_reg(lcdc_dev, DSP_CTRL0, m_DSP_BLACK_EN,
+				     v_DSP_BLACK_EN(0));
+
+			lcdc_cfg_done(lcdc_dev);
+		}
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+
+static int rk3368_lcdc_wait_frame_start(struct rk_lcdc_driver *dev_drv,
+					int enable)
+{
+	u32 line_scane_num, vsync_end, vact_end;
+	u32 interlace_mode;
+
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	if (0 == enable) {
+		interlace_mode = lcdc_read_bit(lcdc_dev, DSP_CTRL0,
+					       m_DSP_INTERLACE);
+		if (interlace_mode) {
+			vsync_end = lcdc_readl(lcdc_dev, DSP_VS_ST_END_F1) &
+					m_DSP_VS_END_F1;
+			vact_end = lcdc_readl(lcdc_dev, DSP_VACT_ST_END_F1) &
+					m_DSP_VACT_END_F1;
+		} else {
+			vsync_end = lcdc_readl(lcdc_dev, DSP_VTOTAL_VS_END) &
+					m_DSP_VS_PW;
+			vact_end = lcdc_readl(lcdc_dev, DSP_VACT_ST_END) &
+					m_DSP_VACT_END;
+		}
+		while (1) {
+			line_scane_num = lcdc_readl(lcdc_dev, SCAN_LINE_NUM) &
+					0x1fff;
+			if ((line_scane_num > vsync_end) &&
+			    (line_scane_num <= vact_end - 100))
+				break;
+		}
+		return 0;
+	} else if (1 == enable) {
+		line_scane_num = lcdc_readl(lcdc_dev, SCAN_LINE_NUM) & 0x1fff;
+		return line_scane_num;
+	}
+
+	return 0;
+}
+
+static int rk3368_lcdc_backlight_close(struct rk_lcdc_driver *dev_drv,
+				       int enable)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	rk3368_lcdc_get_backlight_device(dev_drv);
+
+	if (enable) {
+		/* close the backlight */
+		if (lcdc_dev->backlight) {
+			lcdc_dev->backlight->props.power = FB_BLANK_POWERDOWN;
+			backlight_update_status(lcdc_dev->backlight);
+		}
+		if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+			dev_drv->trsm_ops->disable();
+	} else {
+		if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+			dev_drv->trsm_ops->enable();
+		msleep(100);
+		/* open the backlight */
+		if (lcdc_dev->backlight) {
+			lcdc_dev->backlight->props.power = FB_BLANK_UNBLANK;
+			backlight_update_status(lcdc_dev->backlight);
+		}
+	}
+
+	return 0;
+}
+
+static int rk3368_lcdc_set_overscan(struct rk_lcdc_driver *dev_drv,
+				    struct overscan *overscan)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	/*rk3368_lcdc_post_cfg(dev_drv);*/
+
+	return 0;
+}
+
+static int rk3368_lcdc_extern_func(struct rk_lcdc_driver *dev_drv,
+				   int cmd)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	u32 val;
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+
+	switch (cmd) {
+	case GET_PAGE_FAULT:
+		val = lcdc_readl(lcdc_dev, MMU_INT_RAWSTAT);
+		if ((val & 0x1) == 1) {
+			if ((val & 0x2) == 1)
+				pr_info("val=0x%x,vop iommu bus error\n", val);
+			else
+				return 1;
+		}
+		break;
+	case CLR_PAGE_FAULT:
+		lcdc_writel(lcdc_dev, MMU_INT_CLEAR, 0x3);
+		break;
+	case UNMASK_PAGE_FAULT:
+		lcdc_writel(lcdc_dev, MMU_INT_MASK, 0x2);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int rk3368_lcdc_set_wb(struct rk_lcdc_driver *dev_drv)
+{
+	struct lcdc_device *lcdc_dev =
+	    container_of(dev_drv, struct lcdc_device, driver);
+	struct rk_fb_reg_wb_data *wb_data;
+	u32 src_w, src_h, dst_w, dst_h, fmt_cfg;
+	u32 xscale_en = 0, x_scale_fac = 0, y_throw = 0;
+	u32 csc_mode = 0, rgb2yuv = 0, dither_en = 0;
+
+	if (unlikely(!lcdc_dev->clk_on)) {
+		pr_info("%s,clk_on = %d\n", __func__, lcdc_dev->clk_on);
+		return 0;
+	}
+	wb_data = &dev_drv->wb_data;
+	if ((wb_data->xsize == 0) || (wb_data->ysize == 0))
+		return 0;
+
+	src_w = dev_drv->cur_screen->mode.xres;
+	src_h = dev_drv->cur_screen->mode.yres;
+	dst_w = wb_data->xsize;
+	dst_h = wb_data->ysize;
+	if (!IS_ALIGNED(dst_w, RK3366_WB_ALIGN))
+		pr_info("dst_w: %d not align 16 pixel\n", dst_w);
+
+	if (src_w > dst_w)
+		xscale_en = 1;
+	else if (src_w < dst_w)
+		dst_w = src_w;
+	else
+		xscale_en = 0;
+	if (wb_data->state && xscale_en)
+		x_scale_fac = GET_SCALE_FACTOR_BILI_DN(src_w, dst_w);
+	if ((src_h >= 2 * dst_h) && (dst_h != 0))
+		y_throw = 1;
+	else
+		y_throw = 0;
+	switch (wb_data->data_format) {
+	case XRGB888:
+	case XBGR888:
+		fmt_cfg = 0;
+		break;
+	case RGB888:
+	case BGR888:
+		fmt_cfg = 1;
+		break;
+	case RGB565:
+	case BGR565:
+		fmt_cfg = 2;
+		dither_en = 1;
+		break;
+	case YUV420:
+		fmt_cfg = 4;
+		if (dev_drv->overlay_mode == VOP_RGB_DOMAIN)
+			rgb2yuv = 1;
+		if ((src_w < 1280) && (src_h < 720))
+			csc_mode = VOP_R2Y_CSC_BT601;
+		else
+			csc_mode = VOP_R2Y_CSC_BT709;
+		break;
+	default:
+		fmt_cfg = 0;
+		pr_info("unsupport fmt: %d\n", wb_data->data_format);
+		break;
+	}
+	spin_lock(&lcdc_dev->reg_lock);
+	lcdc_msk_reg(lcdc_dev, WB_CTRL0,
+		     m_WB_EN | m_WB_FMT | m_WB_XPSD_BIL_EN |
+		     m_WB_YTHROW_EN | m_WB_RGB2YUV_EN | m_WB_RGB2YUV_MODE |
+		     m_WB_DITHER_EN,
+		     v_WB_EN(wb_data->state) | v_WB_FMT(fmt_cfg) |
+		     v_WB_XPSD_BIL_EN(xscale_en) |
+		     v_WB_YTHROW_EN(y_throw) | v_WB_RGB2YUV_EN(rgb2yuv) |
+		     v_WB_RGB2YUV_MODE(csc_mode) | v_WB_DITHER_EN(dither_en));
+	lcdc_msk_reg(lcdc_dev, WB_CTRL1,
+		     m_WB_WIDTH | m_WB_XPSD_BIL_FACTOR,
+		     v_WB_WIDTH(dst_w) |
+		     v_WB_XPSD_BIL_FACTOR(x_scale_fac));
+	lcdc_writel(lcdc_dev, WB_YRGB_MST, wb_data->smem_start);
+	lcdc_writel(lcdc_dev, WB_CBR_MST, wb_data->cbr_start);
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+}
+
+static struct rk_lcdc_drv_ops lcdc_drv_ops = {
+	.open = rk3368_lcdc_open,
+	.win_direct_en = rk3368_lcdc_win_direct_en,
+	.load_screen = rk3368_load_screen,
+	.get_dspbuf_info = rk3368_get_dspbuf_info,
+	.post_dspbuf = rk3368_post_dspbuf,
+	.set_par = rk3368_lcdc_set_par,
+	.pan_display = rk3368_lcdc_pan_display,
+	.direct_set_addr = rk3368_lcdc_direct_set_win_addr,
+	/*.lcdc_reg_update = rk3368_lcdc_reg_update,*/
+	.blank = rk3368_lcdc_blank,
+	.ioctl = rk3368_lcdc_ioctl,
+	.suspend = rk3368_lcdc_early_suspend,
+	.resume = rk3368_lcdc_early_resume,
+	.get_win_state = rk3368_lcdc_get_win_state,
+	.area_support_num = rk3368_lcdc_get_area_num,
+	.ovl_mgr = rk3368_lcdc_ovl_mgr,
+	.get_disp_info = rk3368_lcdc_get_disp_info,
+	.fps_mgr = rk3368_lcdc_fps_mgr,
+	.fb_get_win_id = rk3368_lcdc_get_win_id,
+	.fb_win_remap = rk3368_fb_win_remap,
+	.set_dsp_lut = rk3368_lcdc_set_lut,
+	.set_cabc_lut = rk3368_set_cabc_lut,
+	.poll_vblank = rk3368_lcdc_poll_vblank,
+	.get_dsp_addr = rk3368_lcdc_get_dsp_addr,
+	.set_dsp_cabc = rk3368_lcdc_set_dsp_cabc,
+	.set_dsp_bcsh_hue = rk3368_lcdc_set_bcsh_hue,
+	.set_dsp_bcsh_bcs = rk3368_lcdc_set_bcsh_bcs,
+	.get_dsp_bcsh_hue = rk3368_lcdc_get_bcsh_hue,
+	.get_dsp_bcsh_bcs = rk3368_lcdc_get_bcsh_bcs,
+	.open_bcsh = rk3368_lcdc_open_bcsh,
+	.dump_reg = rk3368_lcdc_reg_dump,
+	.cfg_done = rk3368_lcdc_config_done,
+	.set_irq_to_cpu = rk3368_lcdc_set_irq_to_cpu,
+	/*.dsp_black = rk3368_lcdc_dsp_black,*/
+	.backlight_close = rk3368_lcdc_backlight_close,
+	.mmu_en    = rk3368_lcdc_mmu_en,
+	.set_overscan   = rk3368_lcdc_set_overscan,
+	.extern_func	= rk3368_lcdc_extern_func,
+	.wait_frame_start = rk3368_lcdc_wait_frame_start,
+	.set_wb = rk3368_lcdc_set_wb,
+};
+
+#ifdef LCDC_IRQ_EMPTY_DEBUG
+static int rk3368_lcdc_parse_irq(struct lcdc_device *lcdc_dev,
+				 unsigned int intr_status)
+{
+	u32 intr_clr_reg;
+
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
+		intr_clr_reg = INTR_CLEAR_RK3366;
+	else
+		intr_clr_reg = INTR_CLEAR_RK3368;
+
+	if (intr_status & m_WIN0_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_WIN0_EMPTY_INTR_CLR,
+			     v_WIN0_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev, "win0 empty irq!");
+	} else if (intr_status & m_WIN1_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_WIN1_EMPTY_INTR_CLR,
+			     v_WIN1_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev, "win1 empty irq!");
+	} else if (intr_status & m_WIN2_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_WIN2_EMPTY_INTR_CLR,
+			     v_WIN2_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev, "win2 empty irq!");
+	} else if (intr_status & m_WIN3_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_WIN3_EMPTY_INTR_CLR,
+			     v_WIN3_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev, "win3 empty irq!");
+	} else if (intr_status & m_HWC_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_HWC_EMPTY_INTR_CLR,
+			     v_HWC_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev, "HWC empty irq!");
+	} else if (intr_status & m_POST_BUF_EMPTY_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_POST_BUF_EMPTY_INTR_CLR,
+			     v_POST_BUF_EMPTY_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev, "post buf empty irq!");
+	} else if (intr_status & m_PWM_GEN_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_PWM_GEN_INTR_CLR,
+			     v_PWM_GEN_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev, "PWM gen irq!");
+	}
+	return 0;
+}
+#endif
+
+static irqreturn_t rk3368_lcdc_isr(int irq, void *dev_id)
+{
+	struct lcdc_device *lcdc_dev = (struct lcdc_device *)dev_id;
+	ktime_t timestamp = ktime_get();
+	u32 intr_status;
+	u32 line_scane_num, dsp_vs_st_f1;
+	struct rk_screen *screen = lcdc_dev->driver.cur_screen;
+	u32 intr_en_reg, intr_clr_reg, intr_status_reg;
+
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366) {
+		intr_status_reg = INTR_STATUS_RK3366;
+		intr_clr_reg = INTR_CLEAR_RK3366;
+		intr_en_reg = INTR_EN_RK3366;
+	} else {
+		intr_status_reg = INTR_STATUS_RK3368;
+		intr_clr_reg = INTR_CLEAR_RK3368;
+		intr_en_reg = INTR_EN_RK3368;
+	}
+
+	intr_status = lcdc_readl(lcdc_dev, intr_status_reg);
+	if (intr_status & m_FS_INTR_STS) {
+		timestamp = ktime_get();
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_FS_INTR_CLR,
+			     v_FS_INTR_CLR(1));
+		line_scane_num = lcdc_readl(lcdc_dev, SCAN_LINE_NUM) & 0x1fff;
+		dsp_vs_st_f1 = lcdc_readl(lcdc_dev, DSP_VS_ST_END_F1) >> 16;
+		/*if(lcdc_dev->driver.wait_fs){ */
+		if (0) {
+			spin_lock(&(lcdc_dev->driver.cpl_lock));
+			complete(&(lcdc_dev->driver.frame_done));
+			spin_unlock(&(lcdc_dev->driver.cpl_lock));
+		}
+		lcdc_dev->driver.vsync_info.timestamp = timestamp;
+		if ((lcdc_dev->soc_type == VOP_FULL_RK3366) &&
+		    (lcdc_dev->driver.wb_data.state)) {
+			if (lcdc_read_bit(lcdc_dev, WB_CTRL0, m_WB_EN)) {
+				lcdc_msk_reg(lcdc_dev, WB_CTRL0,
+					     m_WB_EN, v_WB_EN(0));
+				lcdc_cfg_done(lcdc_dev);
+				lcdc_dev->driver.wb_data.state = 0;
+			}
+		}
+		wake_up_interruptible_all(&lcdc_dev->driver.vsync_info.wait);
+		if (!(screen->mode.vmode & FB_VMODE_INTERLACED) ||
+		    (line_scane_num >= dsp_vs_st_f1)) {
+			lcdc_dev->driver.vsync_info.timestamp = timestamp;
+			wake_up_interruptible_all(
+				&lcdc_dev->driver.vsync_info.wait);
+		}
+	} else if (intr_status & m_LINE_FLAG0_INTR_STS) {
+		lcdc_dev->driver.frame_time.last_framedone_t =
+			lcdc_dev->driver.frame_time.framedone_t;
+		lcdc_dev->driver.frame_time.framedone_t = cpu_clock(0);
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_LINE_FLAG0_INTR_CLR,
+			     v_LINE_FLAG0_INTR_CLR(1));
+	} else if (intr_status & m_LINE_FLAG1_INTR_STS) {
+		/*line flag1 */
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_LINE_FLAG1_INTR_CLR,
+			     v_LINE_FLAG1_INTR_CLR(1));
+	} else if (intr_status & m_FS_NEW_INTR_STS) {
+		/*new frame start */
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_FS_NEW_INTR_CLR,
+			     v_FS_NEW_INTR_CLR(1));
+	} else if (intr_status & m_BUS_ERROR_INTR_STS) {
+		lcdc_msk_reg(lcdc_dev, intr_clr_reg, m_BUS_ERROR_INTR_CLR,
+			     v_BUS_ERROR_INTR_CLR(1));
+		dev_warn(lcdc_dev->dev, "bus error!");
+	}
+
+	/* for win empty debug */
+#ifdef LCDC_IRQ_EMPTY_DEBUG
+	rk3368_lcdc_parse_irq(lcdc_dev, intr_status);
+#endif
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_PM)
+static int rk3368_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk3368_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define rk3368_lcdc_suspend NULL
+#define rk3368_lcdc_resume  NULL
+#endif
+
+static int rk3368_lcdc_parse_dt(struct lcdc_device *lcdc_dev)
+{
+	struct device_node *np = lcdc_dev->dev->of_node;
+	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
+	int val;
+
+	if (of_property_read_u32(np, "rockchip,prop", &val))
+		lcdc_dev->prop = PRMRY;	/*default set it as primary */
+	else
+		lcdc_dev->prop = val;
+
+	if (of_property_read_u32(np, "rockchip,mirror", &val))
+		dev_drv->rotate_mode = NO_MIRROR;
+	else
+		dev_drv->rotate_mode = val;
+
+	if (of_property_read_u32(np, "rockchip,cabc_mode", &val))
+		dev_drv->cabc_mode = 0;	/* default set close cabc */
+	else
+		dev_drv->cabc_mode = val;
+
+	if (of_property_read_u32(np, "rockchip,pwr18", &val))
+		/*default set it as 3.xv power supply */
+		lcdc_dev->pwr18 = false;
+	else
+		lcdc_dev->pwr18 = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
+		dev_drv->fb_win_map = FB_DEFAULT_ORDER;
+	else
+		dev_drv->fb_win_map = val;
+
+	if (of_property_read_u32(np, "rockchip,bcsh-en", &val))
+		dev_drv->bcsh.enable = false;
+	else
+		dev_drv->bcsh.enable = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,brightness", &val))
+		dev_drv->bcsh.brightness = 0xffff;
+	else
+		dev_drv->bcsh.brightness = val;
+
+	if (of_property_read_u32(np, "rockchip,contrast", &val))
+		dev_drv->bcsh.contrast = 0xffff;
+	else
+		dev_drv->bcsh.contrast = val;
+
+	if (of_property_read_u32(np, "rockchip,sat-con", &val))
+		dev_drv->bcsh.sat_con = 0xffff;
+	else
+		dev_drv->bcsh.sat_con = val;
+
+	if (of_property_read_u32(np, "rockchip,hue", &val)) {
+		dev_drv->bcsh.sin_hue = 0xffff;
+		dev_drv->bcsh.cos_hue = 0xffff;
+	} else {
+		dev_drv->bcsh.sin_hue = val & 0xff;
+		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
+	}
+
+	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
+		dev_drv->iommu_enabled = 0;
+	else
+		dev_drv->iommu_enabled = val;
+	return 0;
+}
+
+static int rk3368_lcdc_probe(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = NULL;
+	struct rk_lcdc_driver *dev_drv;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	int prop;
+	int ret = 0;
+
+	/*if the primary lcdc has not registered ,the extend
+	   lcdc register later */
+	of_property_read_u32(np, "rockchip,prop", &prop);
+	if (prop == EXTEND) {
+		if (!is_prmry_rk_lcdc_registered())
+			return -EPROBE_DEFER;
+	}
+	lcdc_dev = devm_kzalloc(dev, sizeof(struct lcdc_device), GFP_KERNEL);
+	if (!lcdc_dev) {
+		dev_err(&pdev->dev, "rk3368 lcdc device kmalloc fail!");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->dev = dev;
+	rk3368_lcdc_parse_dt(lcdc_dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	/* enable power domain */
+	pm_runtime_enable(dev);
+#endif
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+
+	lcdc_dev->regs = devm_ioremap(&pdev->dev, res->start,
+				      resource_size(res));
+	if (IS_ERR(lcdc_dev->regs))
+		return PTR_ERR(lcdc_dev->regs);
+	else
+		dev_info(dev, "lcdc_dev->regs=0x%lx\n", (long)lcdc_dev->regs);
+
+	lcdc_dev->regsbak = devm_kzalloc(dev, lcdc_dev->len, GFP_KERNEL);
+	if (IS_ERR(lcdc_dev->regsbak))
+		return PTR_ERR(lcdc_dev->regsbak);
+	lcdc_dev->dsp_lut_addr_base = (lcdc_dev->regs + GAMMA_LUT_ADDR);
+	lcdc_dev->cabc_lut_addr_base = (lcdc_dev->regs + CABC_GAMMA_LUT_ADDR);
+	lcdc_dev->grf_base =
+		syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(lcdc_dev->grf_base)) {
+		dev_err(&pdev->dev, "can't find lcdc grf property\n");
+		lcdc_dev->grf_base = NULL;
+	}
+	lcdc_dev->pmugrf_base =
+		syscon_regmap_lookup_by_phandle(np, "rockchip,pmugrf");
+	if (IS_ERR(lcdc_dev->pmugrf_base)) {
+		dev_err(&pdev->dev, "can't find lcdc pmu grf property\n");
+		lcdc_dev->pmugrf_base = NULL;
+	}
+
+	lcdc_dev->cru_base =
+		syscon_regmap_lookup_by_phandle(np, "rockchip,cru");
+	if (IS_ERR(lcdc_dev->cru_base)) {
+		dev_err(&pdev->dev, "can't find lcdc cru_base property\n");
+		lcdc_dev->cru_base = NULL;
+	}
+
+	lcdc_dev->id = 0;
+	dev_set_name(lcdc_dev->dev, "lcdc%d", lcdc_dev->id);
+	dev_drv = &lcdc_dev->driver;
+	dev_drv->dev = dev;
+	dev_drv->prop = prop;
+	dev_drv->id = lcdc_dev->id;
+	dev_drv->ops = &lcdc_drv_ops;
+	dev_drv->lcdc_win_num = ARRAY_SIZE(lcdc_win);
+	dev_drv->reserved_fb = 1;/*only need reserved 1 buffer*/
+	spin_lock_init(&lcdc_dev->reg_lock);
+
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if (lcdc_dev->irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ for lcdc%d\n",
+			lcdc_dev->id);
+		return -ENXIO;
+	}
+
+	ret = devm_request_irq(dev, lcdc_dev->irq, rk3368_lcdc_isr,
+			       IRQF_SHARED,
+			       dev_name(dev), lcdc_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n",
+			lcdc_dev->irq, ret);
+		return ret;
+	}
+
+	if (dev_drv->iommu_enabled) {
+		if (lcdc_dev->id == 0) {
+			strcpy(dev_drv->mmu_dts_name,
+			       VOPB_IOMMU_COMPATIBLE_NAME);
+		} else {
+			strcpy(dev_drv->mmu_dts_name,
+			       VOPL_IOMMU_COMPATIBLE_NAME);
+		}
+	}
+
+	ret = rk_fb_register(dev_drv, lcdc_win, lcdc_dev->id);
+	if (ret < 0) {
+		dev_err(dev, "register fb for lcdc%d failed!\n", lcdc_dev->id);
+		return ret;
+	}
+	if (lcdc_dev->soc_type == VOP_FULL_RK3366)
+		dev_drv->property.feature |= SUPPORT_WRITE_BACK;
+	else if (lcdc_dev->soc_type == VOP_FULL_RK3368)
+		dev_drv->property.feature |= SUPPORT_IFBDC;
+	dev_drv->property.feature |= SUPPORT_VOP_IDENTIFY |
+				SUPPORT_YUV420_OUTPUT;
+	dev_drv->property.max_output_x = 4096;
+	dev_drv->property.max_output_y = 2160;
+	lcdc_dev->screen = dev_drv->screen0;
+	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
+		 lcdc_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
+
+	return 0;
+}
+
+static int rk3368_lcdc_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void rk3368_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	struct rk_lcdc_driver *dev_drv = &lcdc_dev->driver;
+#if 1
+	dev_drv->suspend_flag = 1;
+	mdelay(100);
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+	kthread_stop(dev_drv->update_regs_thread);
+	rk3368_lcdc_deint(lcdc_dev);
+	/*if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();*/
+
+	rk3368_lcdc_clk_disable(lcdc_dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_disable(lcdc_dev->dev);
+#endif
+	rk_disp_pwr_disable(dev_drv);
+#else
+	rk3368_lcdc_early_suspend(&lcdc_dev->driver);
+	rk3368_lcdc_deint(lcdc_dev);
+#endif
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk3368_lcdc_dt_ids[] = {
+	{.compatible = "rockchip,rk3368-lcdc",},
+	{.compatible = "rockchip,rk3366-lcdc-big",},
+	{}
+};
+#endif
+
+static struct platform_driver rk3368_lcdc_driver = {
+	.probe = rk3368_lcdc_probe,
+	.remove = rk3368_lcdc_remove,
+	.driver = {
+		   .name = "rk3368-lcdc",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rk3368_lcdc_dt_ids),
+		   },
+	.suspend = rk3368_lcdc_suspend,
+	.resume = rk3368_lcdc_resume,
+	.shutdown = rk3368_lcdc_shutdown,
+};
+
+static int __init rk3368_lcdc_module_init(void)
+{
+	return platform_driver_register(&rk3368_lcdc_driver);
+}
+
+static void __exit rk3368_lcdc_module_exit(void)
+{
+	platform_driver_unregister(&rk3368_lcdc_driver);
+}
+
+fs_initcall(rk3368_lcdc_module_init);
+module_exit(rk3368_lcdc_module_exit);
diff -Nupr a/drivers/video/rockchip/lcdc/rk3368_lcdc.h b/drivers/video/rockchip/lcdc/rk3368_lcdc.h
--- a/drivers/video/rockchip/lcdc/rk3368_lcdc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk3368_lcdc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2158 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef RK3368_LCDC_H_
+#define RK3368_LCDC_H_
+
+#include<linux/rk_fb.h>
+#include<linux/io.h>
+#include<linux/clk.h>
+#include<linux/mfd/syscon.h>
+#include<linux/regmap.h>
+
+#define VOP_INPUT_MAX_WIDTH 4096 /*3840 for LINCOLN*/
+
+#define REG_CFG_DONE			(0x0000)
+#define VOP_CFG_DONE(x)				(((x)&1)<<0)
+#define WIN0_CFG_DONE(x)			(((x)&1)<<1)
+#define WIN1_CFG_DONE(x)			(((x)&1)<<2)
+#define WIN2_CFG_DONE(x)			(((x)&1)<<3)
+#define WIN3_CFG_DONE(x)			(((x)&1)<<4)
+#define HWC_CFG_DONE(x)				(((x)&1)<<5)
+#define IEP_CFG_DONE(x)				(((x)&1)<<6)
+#define FBDC_CFG_DONE(x)			(((x)&1)<<7)
+#define SYS_CFG_DONE(x)				(((x)&1)<<8)
+
+#define VOP_CFG_DONE_WMSK(x)			(((x)&1)<<(0+16))
+#define WIN0_CFG_DONE_WMSK(x)			(((x)&1)<<(1+16))
+#define WIN1_CFG_DONE_WMSK(x)			(((x)&1)<<(2+16))
+#define WIN2_CFG_DONE_WMSK(x)			(((x)&1)<<(3+16))
+#define WIN3_CFG_DONE_WMSK(x)			(((x)&1)<<(4+16))
+#define HWC_CFG_DONE_WMSK(x)			(((x)&1)<<(5+16))
+#define IEP_CFG_DONE_WMSK(x)			(((x)&1)<<(6+16))
+#define FBDC_CFG_DONE_WMSK(x)			(((x)&1)<<(7+16))
+#define SYS_CFG_DONE_WMSK(x)			(((x)&1)<<(8+16))
+
+#define VOP_REG_DONE		(VOP_CFG_DONE(1)  | VOP_CFG_DONE_WMSK(1))
+#define WIN0_REG_DONE		(WIN0_CFG_DONE(1) | WIN0_CFG_DONE_WMSK(1))
+#define WIN1_REG_DONE		(WIN1_CFG_DONE(1) | WIN1_CFG_DONE_WMSK(1))
+#define WIN2_REG_DONE		(WIN2_CFG_DONE(1) | WIN2_CFG_DONE_WMSK(1))
+#define WIN3_REG_DONE		(WIN3_CFG_DONE(1) | WIN3_CFG_DONE_WMSK(1))
+#define HWC_REG_DONE		(HWC_CFG_DONE(1)  | HWC_CFG_DONE_WMSK(1))
+#define IEP_REG_DONE		(IEP_CFG_DONE(1)  | IEP_CFG_DONE_WMSK(1))
+#define FBDC_REG_DONE		(FBDC_CFG_DONE(1) | FBDC_CFG_DONE_WMSK(1))
+#define SYS_REG_DONE		(SYS_CFG_DONE(1)  | SYS_CFG_DONE_WMSK(1))
+
+#define VERSION_INFO			(0x0004)
+#define m_RTL_VERSION			(0xffff<<0)
+#define m_FPGA_VERSION			(0xffff<<16)
+#define VOP_FULL_RK3368			0x03021223
+#define VOP_FULL_RK3366			0x03045635
+
+#define SYS_CTRL			(0x0008)
+#define v_DIRECT_PATH_EN(x)			(((x)&1)<<0)
+#define v_DIRECT_PATCH_SEL(x)			(((x)&3)<<1)
+#define v_DOUB_CHANNEL_EN(x)			(((x)&1)<<3)
+#define v_DOUB_CH_OVERLAP_NUM(x)		(((x)&0xf)<<4)
+#define v_EDPI_HALT_EN(x)			(((x)&1)<<8)
+#define v_EDPI_WMS_MODE(x)			(((x)&1)<<9)
+#define v_EDPI_WMS_FS(x)			(((x)&1)<<10)
+#define v_GLOBAL_REGDONE_EN(x)			(((x)&1)<<11)
+#define v_RGB_OUT_EN(x)				(((x)&1)<<12)
+#define v_HDMI_OUT_EN(x)			(((x)&1)<<13)
+#define v_EDP_OUT_EN(x)				(((x)&1)<<14)
+#define v_MIPI_OUT_EN(x)			(((x)&1)<<15)
+#define v_OVERLAY_MODE(x)			(((x)&1)<<16)
+#define v_FS_SAME_ADDR_MASK_EN(x)		(((x)&1)<<17)
+#define v_POST_LB_MODE(x)			(((x)&1)<<18)
+#define v_WIN23_PRI_OPT_MODE(x)			(((x)&1)<<19)
+#define v_MMU_EN(x)				(((x)&1)<<20)
+#define v_DMA_STOP(x)				(((x)&1)<<21)
+#define v_STANDBY_EN(x)				(((x)&1)<<22)
+#define v_AUTO_GATING_EN(x)			(((x)&1)<<23)
+
+#define m_DIRECT_PATH_EN			(1<<0)
+#define m_DIRECT_PATCH_SEL			(3<<1)
+#define m_DOUB_CHANNEL_EN			(1<<3)
+#define m_DOUB_CH_OVERLAP_NUM			(0xf<<4)
+#define m_EDPI_HALT_EN				(1<<8)
+#define m_EDPI_WMS_MODE				(1<<9)
+#define m_EDPI_WMS_FS				(1<<10)
+#define m_GLOBAL_REGDONE_EN			(1<<11)
+#define m_RGB_OUT_EN				(1<<12)
+#define m_HDMI_OUT_EN				(1<<13)
+#define m_EDP_OUT_EN				(1<<14)
+#define m_MIPI_OUT_EN				(1<<15)
+#define m_OVERLAY_MODE				(1<<16)
+#define m_FS_SAME_ADDR_MASK_EN			(1<<17)
+#define m_POST_LB_MODE				(1<<18)
+#define m_WIN23_PRI_OPT_MODE			(1<<19)
+#define m_MMU_EN				(1<<20)
+#define m_DMA_STOP				(1<<21)
+#define m_STANDBY_EN				(1<<22)
+#define m_AUTO_GATING_EN			(1<<23)
+
+#define SYS_CTRL1			(0x000c)
+#define v_NOC_HURRY_EN(x)			(((x)&0x1)<<0)
+#define v_NOC_HURRY_VALUE(x)			(((x)&0x3)<<1)
+#define v_NOC_HURRY_THRESHOLD(x)		(((x)&0x3f)<<3)
+#define v_NOC_QOS_EN(x)				(((x)&0x1)<<9)
+#define v_NOC_WIN_QOS(x)			(((x)&0x3)<<10)
+#define v_AXI_MAX_OUTSTANDING_EN(x)		(((x)&0x1)<<12)
+#define v_AXI_OUTSTANDING_MAX_NUM(x)		(((x)&0x1f)<<13)
+#define v_NOC_HURRY_W_MODE(x)			(((x)&0x3)<<20)
+
+#define m_NOC_HURRY_EN				(0x1<<0)
+#define m_NOC_HURRY_VALUE			(0x3<<1)
+#define m_NOC_HURRY_THRESHOLD			(0x3f<<3)
+#define m_NOC_QOS_EN				(0x1<<9)
+#define m_NOC_WIN_QOS				(0x3<<10)
+#define m_AXI_MAX_OUTSTANDING_EN		(0x1<<12)
+#define m_AXI_OUTSTANDING_MAX_NUM		(0x1f<<13)
+#define m_NOC_HURRY_W_MODE			(0x3<<20)
+
+#define DSP_CTRL0			(0x0010)
+#define v_DSP_OUT_MODE(x)			(((x)&0x0f)<<0)
+#define v_SW_CORE_DCLK_SEL(x)			(((x)&1)<<4)
+#define v_DSP_DCLK_DDR(x)			(((x)&1)<<8)
+#define v_DSP_DDR_PHASE(x)			(((x)&1)<<9)
+#define v_DSP_INTERLACE(x)			(((x)&1)<<10)
+#define v_DSP_FIELD_POL(x)			(((x)&1)<<11)
+#define v_DSP_BG_SWAP(x)			(((x)&1)<<12)
+#define v_DSP_RB_SWAP(x)			(((x)&1)<<13)
+#define v_DSP_RG_SWAP(x)			(((x)&1)<<14)
+#define v_DSP_DELTA_SWAP(x)			(((x)&1)<<15)
+#define v_DSP_DUMMY_SWAP(x)			(((x)&1)<<16)
+#define v_DSP_OUT_ZERO(x)			(((x)&1)<<17)
+#define v_DSP_BLANK_EN(x)			(((x)&1)<<18)
+#define v_DSP_BLACK_EN(x)			(((x)&1)<<19)
+#define v_DSP_CCIR656_AVG(x)			(((x)&1)<<20)
+#define v_DSP_YUV_CLIP(x)			(((x)&1)<<21)
+#define v_DSP_X_MIR_EN(x)			(((x)&1)<<22)
+#define v_DSP_Y_MIR_EN(x)			(((x)&1)<<23)
+#define m_DSP_OUT_MODE				(0x0f<<0)
+#define m_SW_CORE_DCLK_SEL			(1<<4)
+#define m_DSP_DCLK_DDR				(1<<8)
+#define m_DSP_DDR_PHASE				(1<<9)
+#define m_DSP_INTERLACE				(1<<10)
+#define m_DSP_FIELD_POL				(1<<11)
+#define m_DSP_BG_SWAP				(1<<12)
+#define m_DSP_RB_SWAP				(1<<13)
+#define m_DSP_RG_SWAP				(1<<14)
+#define m_DSP_DELTA_SWAP			(1<<15)
+#define m_DSP_DUMMY_SWAP			(1<<16)
+#define m_DSP_OUT_ZERO				(1<<17)
+#define m_DSP_BLANK_EN				(1<<18)
+#define m_DSP_BLACK_EN				(1<<19)
+#define m_DSP_CCIR656_AVG			(1<<20)
+#define m_DSP_YUV_CLIP				(1<<21)
+#define m_DSP_X_MIR_EN				(1<<22)
+#define m_DSP_Y_MIR_EN				(1<<23)
+
+#define DSP_CTRL1			(0x0014)
+#define v_DSP_LUT_EN(x)				(((x)&1)<<0)
+#define v_PRE_DITHER_DOWN_EN(x)			(((x)&1)<<1)
+#define v_DITHER_DOWN_EN(x)			(((x)&1)<<2)
+#define v_DITHER_DOWN_MODE(x)			(((x)&1)<<3)
+#define v_DITHER_DOWN_SEL(x)			(((x)&1)<<4)
+#define v_DITHER_UP_EN(x)			(((x)&1)<<6)
+#define v_DSP_LAYER0_SEL(x)			(((x)&3)<<8)
+#define v_DSP_LAYER1_SEL(x)			(((x)&3)<<10)
+#define v_DSP_LAYER2_SEL(x)			(((x)&3)<<12)
+#define v_DSP_LAYER3_SEL(x)			(((x)&3)<<14)
+
+#define v_RGB_LVDS_HSYNC_POL(x)			(((x)&1)<<16)
+#define v_RGB_LVDS_VSYNC_POL(x)			(((x)&1)<<17)
+#define v_RGB_LVDS_DEN_POL(x)			(((x)&1)<<18)
+#define v_RGB_LVDS_DCLK_POL(x)			(((x)&1)<<19)
+
+#define v_HDMI_HSYNC_POL(x)			(((x)&1)<<20)
+#define v_HDMI_VSYNC_POL(x)			(((x)&1)<<21)
+#define v_HDMI_DEN_POL(x)			(((x)&1)<<22)
+#define v_HDMI_DCLK_POL(x)			(((x)&1)<<23)
+
+#define v_EDP_HSYNC_POL(x)			(((x)&1)<<24)
+#define v_EDP_VSYNC_POL(x)			(((x)&1)<<25)
+#define v_EDP_DEN_POL(x)			(((x)&1)<<26)
+#define v_EDP_DCLK_POL(x)			(((x)&1)<<27)
+
+#define v_MIPI_HSYNC_POL(x)			(((x)&1)<<28)
+#define v_MIPI_VSYNC_POL(x)			(((x)&1)<<29)
+#define v_MIPI_DEN_POL(x)			(((x)&1)<<30)
+#define v_MIPI_DCLK_POL(x)			(((x)&1)<<31)
+
+#define m_DSP_LUT_EN				(1<<0)
+#define m_PRE_DITHER_DOWN_EN			(1<<1)
+#define m_DITHER_DOWN_EN			(1<<2)
+#define m_DITHER_DOWN_MODE			(1<<3)
+#define m_DITHER_DOWN_SEL			(1<<4)
+#define m_DITHER_UP_EN				(1<<6)
+#define m_DSP_LAYER0_SEL			(3<<8)
+#define m_DSP_LAYER1_SEL			(3<<10)
+#define m_DSP_LAYER2_SEL			(3<<12)
+#define m_DSP_LAYER3_SEL			(3<<14)
+
+#define m_RGB_LVDS_HSYNC_POL			(1<<16)
+#define m_RGB_LVDS_VSYNC_POL			(1<<17)
+#define m_RGB_LVDS_DEN_POL			(1<<18)
+#define m_RGB_LVDS_DCLK_POL			(1<<19)
+
+#define m_HDMI_HSYNC_POL			(1<<20)
+#define m_HDMI_VSYNC_POL			(1<<21)
+#define m_HDMI_DEN_POL				(1<<22)
+#define m_HDMI_DCLK_POL				(1<<23)
+
+#define m_EDP_HSYNC_POL				(1<<24)
+#define m_EDP_VSYNC_POL				(1<<25)
+#define m_EDP_DEN_POL				(1<<26)
+#define m_EDP_DCLK_POL				(1<<27)
+
+#define m_MIPI_HSYNC_POL			(1<<28)
+#define m_MIPI_VSYNC_POL			(1<<29)
+#define m_MIPI_DEN_POL				(1<<30)
+#define m_MIPI_DCLK_POL				(1<<31)
+
+#define DSP_BG				(0x0018)
+#define v_DSP_BG_BLUE(x)			(((x)&0xff) << 0)
+#define v_DSP_BG_GREEN(x)			(((x)&0xff) << 8)
+#define v_DSP_BG_RED(x)				(((x)&0xff) << 16)
+#define m_DSP_BG_BLUE				(0xff << 0)
+#define m_DSP_BG_GREEN				(0xff << 8)
+#define m_DSP_BG_RED				(0xff << 16)
+
+#define MCU_CTRL			(0x001c)
+#define v_MCU_PIX_TOTAL(x)			(((x)&0x3f)<<0)
+#define v_MCU_CS_PST(x)				(((x)&0xf)<<6)
+#define v_MCU_CS_PEND(x)			(((x)&0x3f)<<10)
+#define v_MCU_RW_PST(x)				(((x)&0xf)<<16)
+#define v_MCU_RW_PEND(x)			(((x)&0x3f)<<20)
+#define v_MCU_CLK_SEL(x)			(((x)&1)<<26)
+#define v_MCU_HOLD_MODE(x)			(((x)&1)<<27)
+#define v_MCU_FRAME_ST(x)			(((x)&1)<<28)
+#define v_MCU_RS(x)				(((x)&1)<<29)
+#define v_MCU_BYPASS(x)				(((x)&1)<<30)
+#define v_MCU_TYPE(x)				(((x)&1)<<31)
+#define m_MCU_PIX_TOTAL				(0x3f<<0)
+#define m_MCU_CS_PST				(0xf<<6)
+#define m_MCU_CS_PEND				(0x3f<<10)
+#define m_MCU_RW_PST				(0xf<<16)
+#define m_MCU_RW_PEND				(0x3f<<20)
+#define m_MCU_CLK_SEL				(1<<26)
+#define m_MCU_HOLD_MODE				(1<<27)
+#define m_MCU_FRAME_ST				(1<<28)
+#define m_MCU_RS				(1<<29)
+#define m_MCU_BYPASS				(1<<30)
+#define m_MCU_TYPE				((u32)1<<31)
+
+#define LINE_FLAG_RK3368		(0x0020)/*rk3368*/
+#define LINE_FLAG_RK3366		(0x02a0)/*rk3366*/
+#define m_DSP_LINE_FLAG0_NUM			(0x1fff<<0)
+#define m_DSP_LINE_FLAG1_NUM			(0x1fff<<16)
+#define v_DSP_LINE_FLAG0_NUM(x)			(((x)&0x1fff)<<0)
+#define v_DSP_LINE_FLAG1_NUM(x)			(((x)&0x1fff)<<16)
+
+#define INTR_EN_RK3368			(0x0024)/*for rk3368*/
+#define INTR_EN_RK3366			(0x0280)/*for rk3366*/
+#define v_FS_INTR_EN(x)				((((x)&1)<<0) | ((1<<(0+16))))
+#define v_FS_NEW_INTR_EN(x)			((((x)&1)<<1) | ((1<<(1+16))))
+#define v_ADDR_SAME_INTR_EN(x)			((((x)&1)<<2) | ((1<<(2+16))))
+#define v_LINE_FLAG0_INTR_EN(x)			((((x)&1)<<3) | ((1<<(3+16))))
+#define v_LINE_FLAG1_INTR_EN(x)			((((x)&1)<<4) | ((1<<(4+16))))
+#define v_BUS_ERROR_INTR_EN(x)			((((x)&1)<<5) | ((1<<(5+16))))
+#define v_WIN0_EMPTY_INTR_EN(x)			((((x)&1)<<6) | ((1<<(6+16))))
+#define v_WIN1_EMPTY_INTR_EN(x)			((((x)&1)<<7) | ((1<<(7+16))))
+#define v_WIN2_EMPTY_INTR_EN(x)			((((x)&1)<<8) | ((1<<(8+16))))
+#define v_WIN3_EMPTY_INTR_EN(x)			((((x)&1)<<9) | ((1<<(9+16))))
+#define v_HWC_EMPTY_INTR_EN(x)		((((x)&1)<<10) | ((1<<(10+16))))
+#define v_POST_BUF_EMPTY_INTR_EN(x)	((((x)&1)<<11) | ((1<<(11+16))))
+#define v_PWM_GEN_INTR_EN(x)		((((x)&1)<<12) | ((1<<(12+16))))
+#define v_DSP_HOLD_VALID_INTR_EN(x)	((((x)&1)<<13) | ((1<<(13+16))))
+#define v_INTR_MMU_EN(x)		((((x)&1)<<14) | ((1<<(14+16))))/*rk3366*/
+#define v_INTR_DMA_FINISH_EN(x)		((((x)&1)<<15) | ((1<<(15+16))))/*rk3366*/
+
+#define m_FS_INTR_EN				((1<<0) | ((1<<(0+16))))
+#define m_FS_NEW_INTR_EN			((1<<1) | ((1<<(1+16))))
+#define m_ADDR_SAME_INTR_EN			((1<<2) | ((1<<(2+16))))
+#define m_LINE_FLAG0_INTR_EN			((1<<3) | ((1<<(3+16))))
+#define m_LINE_FLAG1_INTR_EN			((1<<4) | ((1<<(4+16))))
+#define m_BUS_ERROR_INTR_EN			((1<<5) | ((1<<(5+16))))
+#define m_WIN0_EMPTY_INTR_EN			((1<<6) | ((1<<(6+16))))
+#define m_WIN1_EMPTY_INTR_EN			((1<<7) | ((1<<(7+16))))
+#define m_WIN2_EMPTY_INTR_EN			((1<<8) | ((1<<(8+16))))
+#define m_WIN3_EMPTY_INTR_EN			((1<<9) | ((1<<(9+16))))
+#define m_HWC_EMPTY_INTR_EN			((1<<10) | ((1<<(10+16))))
+#define m_POST_BUF_EMPTY_INTR_EN		((1<<11) | ((1<<(11+16))))
+#define m_PWM_GEN_INTR_EN			((1<<12) | ((1<<(12+16))))
+#define m_DSP_HOLD_VALID_INTR_EN		((1<<13) | ((1<<(13+16))))
+#define m_INTR_MMU_EN			((1<<14) | ((1<<(14+16))))/*rk3366*/
+#define m_INTR_DMA_FINISH_EN		((1<<15) | ((1<<(15+16))))/*rk3366*/
+
+#define INTR_CLEAR_RK3368		(0x0028)/*rk3368*/
+#define INTR_CLEAR_RK3366		(0x0284)/*rk3366*/
+#define v_FS_INTR_CLR(x)			((((x)&1)<<0) | (1<<(0+16)))
+#define v_FS_NEW_INTR_CLR(x)			((((x)&1)<<1) | (1<<(1+16)))
+#define v_ADDR_SAME_INTR_CLR(x)			((((x)&1)<<2) | (1<<(2+16)))
+#define v_LINE_FLAG0_INTR_CLR(x)		((((x)&1)<<3) | (1<<(3+16)))
+#define v_LINE_FLAG1_INTR_CLR(x)		((((x)&1)<<4) | (1<<(4+16)))
+#define v_BUS_ERROR_INTR_CLR(x)			((((x)&1)<<5) | (1<<(5+16)))
+#define v_WIN0_EMPTY_INTR_CLR(x)		((((x)&1)<<6) | (1<<(6+16)))
+#define v_WIN1_EMPTY_INTR_CLR(x)		((((x)&1)<<7) | (1<<(7+16)))
+#define v_WIN2_EMPTY_INTR_CLR(x)		((((x)&1)<<8) | (1<<(8+16)))
+#define v_WIN3_EMPTY_INTR_CLR(x)		((((x)&1)<<9) | (1<<(9+16)))
+#define v_HWC_EMPTY_INTR_CLR(x)			((((x)&1)<<10) | (1<<(10+16)))
+#define v_POST_BUF_EMPTY_INTR_CLR(x)		((((x)&1)<<11) | (1<<(11+16)))
+#define v_PWM_GEN_INTR_CLR(x)			((((x)&1)<<12) | (1<<(12+16)))
+#define v_DSP_HOLD_VALID_INTR_CLR(x)		((((x)&1)<<13) | (1<<(13+16)))
+#define v_INTR_MMU_CLR(x)			((((x)&1)<<14) | ((1<<(14+16))))/*rk3366*/
+#define v_INTR_DMA_FINISH_CLR(x)		((((x)&1)<<15) | ((1<<(15+16))))/*rk3366*/
+
+#define m_FS_INTR_CLR				((1<<0) | ((1<<(0+16))))
+#define m_FS_NEW_INTR_CLR			((1<<1) | ((1<<(1+16))))
+#define m_ADDR_SAME_INTR_CLR			((1<<2) | ((1<<(2+16))))
+#define m_LINE_FLAG0_INTR_CLR			((1<<3) | ((1<<(3+16))))
+#define m_LINE_FLAG1_INTR_CLR			((1<<4) | ((1<<(4+16))))
+#define m_BUS_ERROR_INTR_CLR			((1<<5) | ((1<<(5+16))))
+#define m_WIN0_EMPTY_INTR_CLR			((1<<6) | ((1<<(5+16))))
+#define m_WIN1_EMPTY_INTR_CLR			((1<<7) | ((1<<(7+16))))
+#define m_WIN2_EMPTY_INTR_CLR			((1<<8) | ((1<<(8+16))))
+#define m_WIN3_EMPTY_INTR_CLR			((1<<9) | ((1<<(9+16))))
+#define m_HWC_EMPTY_INTR_CLR			((1<<10) | ((1<<(10+16))))
+#define m_POST_BUF_EMPTY_INTR_CLR		((1<<11) | ((1<<(11+16))))
+#define m_PWM_GEN_INTR_CLR			((1<<12) | ((1<<(12+16))))
+#define m_DSP_HOLD_VALID_INTR_CLR		((1<<13) | ((1<<(13+16))))
+#define m_INTR_MMU_CLEAR			((1<<14) | ((1<<(14+16))))/*rk3366*/
+#define m_INTR_DMA_FINISH_CLEAR			((1<<15) | ((1<<(15+16))))/*rk3366*/
+
+#define INTR_STATUS_RK3368		(0x002c)/*rk3366*/
+#define INTR_STATUS_RK3366		(0x0288)/*rk3366*/
+#define m_FS_INTR_STS				(1<<0)
+#define m_FS_NEW_INTR_STS			(1<<1)
+#define m_ADDR_SAME_INTR_STS			(1<<2)
+#define m_LINE_FLAG0_INTR_STS			(1<<3)
+#define m_LINE_FLAG1_INTR_STS			(1<<4)
+#define m_BUS_ERROR_INTR_STS			(1<<5)
+#define m_WIN0_EMPTY_INTR_STS			(1<<6)
+#define m_WIN1_EMPTY_INTR_STS			(1<<7)
+#define m_WIN2_EMPTY_INTR_STS			(1<<8)
+#define m_WIN3_EMPTY_INTR_STS			(1<<9)
+#define m_HWC_EMPTY_INTR_STS			(1<<10)
+#define m_POST_BUF_EMPTY_INTR_STS		(1<<11)
+#define m_PWM_GEN_INTR_STS			(1<<12)
+#define m_DSP_HOLD_VALID_INTR_STS		(1<<13)
+#define m_INTR_MMU_STS				(1<<14)/*rk3366*/
+#define m_INTR_DMA_FINISH_STS			(1<<15)/*rk3366*/
+
+#define m_FS_INTR_RAWSTS			(1<<(0+16))
+#define m_FS_NEW_INTR_RAWSTS			(1<<(1+16))
+#define m_ADDR_SAME_INTR_RAWSTS			(1<<(2+16))
+#define m_LINE_FLAG0_INTR_RAWSTS		(1<<(3+16))
+#define m_LINE_FLAG1_INTR_RAWSTS		(1<<(4+16))
+#define m_BUS_ERROR_INTR_RAWSTS			(1<<(5+16))
+#define m_WIN0_EMPTY_INTR_RAWSTS		(1<<(6+16))
+#define m_WIN1_EMPTY_INTR_RAWSTS		(1<<(7+16))
+#define m_WIN2_EMPTY_INTR_RAWSTS		(1<<(8+16))
+#define m_WIN3_EMPTY_INTR_RAWSTS		(1<<(9+16))
+#define m_HWC_EMPTY_INTR_RAWSTS			(1<<(10+16))
+#define m_POST_BUF_EMPTY_INTR_RAWSTS		(1<<(11+16))
+#define m_PWM_GEN_INTR_RAWSTS			(1<<(12+16))
+#define m_DSP_HOLD_VALID_INTR_RAWSTS		(1<<(13+16))
+
+#define INTR_RAW_STATUS_RK3366		(0x028c)/*rk3366*/
+#define m_FS_INTR_RAWSTS_RK3366			(1<<0)/*rk3366*/
+#define m_FS_NEW_INTR_RAWSTS_RK3366		(1<<1)/*rk3366*/
+#define m_ADDR_SAME_INTR_RAWSTS_RK3366		(1<<2)/*rk3366*/
+#define m_LINE_FLAG0_INTR_RAWSTS_RK3366		(1<<3)/*rk3366*/
+#define m_LINE_FLAG1_INTR_RAWSTS_RK3366		(1<<4)/*rk3366*/
+#define m_BUS_ERROR_INTR_RAWSTS_RK3366		(1<<5)/*rk3366*/
+#define m_WIN0_EMPTY_INTR_RAWSTS_RK3366		(1<<6)/*rk3366*/
+#define m_WIN1_EMPTY_INTR_RAWSTS_RK3366		(1<<7)/*rk3366*/
+#define m_WIN2_EMPTY_INTR_RAWSTS_RK3366		(1<<8)/*rk3366*/
+#define m_WIN3_EMPTY_INTR_RAWSTS_RK3366		(1<<9)/*rk3366*/
+#define m_HWC_EMPTY_INTR_RAWSTS_RK3366		(1<<10)/*rk3366*/
+#define m_POST_BUF_EMPTY_INTR_RAWSTS_RK3366	(1<<11)/*rk3366*/
+#define m_PWM_GEN_INTR_RAWSTS_RK3366		(1<<12)/*rk3366*/
+#define m_DSP_HOLD_VALID_INTR_RAWSTS_RK3366	(1<<13)/*rk3366*/
+#define m_INTR_MMU_RAWSTS_RK3366		(1<<14)/*rk3366*/
+#define m_INTR_DMA_FINISH_RAWSTS_RK3366		(1<<15)/*rk3366*/
+
+/********************rk3366 write back register************************/
+#define WB_CTRL0			(0x0020)
+#define v_WB_EN(x)				(((x)&0x1)<<0)
+#define v_WB_FMT(x)				(((x)&0x7)<<1)
+#define v_WB_DITHER_EN(x)			(((x)&0x1)<<4)
+#define v_WB_RGB2YUV_EN(x)			(((x)&0x1)<<5)
+#define v_WB_RGB2YUV_MODE(x)			(((x)&0x1)<<6)
+#define v_WB_XPSD_BIL_EN(x)			(((x)&0x1)<<7)
+#define v_WB_YTHROW_EN(x)			(((x)&0x1)<<8)
+#define v_WB_YTHROW_MODE(x)			(((x)&0x1)<<9)
+#define v_WB_HANDSHAKE_MODE(x)			(((x)&0x1)<<11)
+#define v_WB_YRGB_ID(x)				(((x)&0xf)<<24)
+#define v_WB_UI_ID(x)				(((x)&0xf)<<28)
+#define m_WB_EN					(0x1<<0)
+#define m_WB_FMT				(0x7<<1)
+#define m_WB_DITHER_EN				(0x1<<4)
+#define m_WB_RGB2YUV_EN				(0x1<<5)
+#define m_WB_RGB2YUV_MODE			(0x1<<6)
+#define m_WB_XPSD_BIL_EN			(0x1<<7)
+#define m_WB_YTHROW_EN				(0x1<<8)
+#define m_WB_YTHROW_MODE			(0x1<<9)
+#define m_WB_HANDSHAKE_MODE			(0x1<<11)
+#define m_WB_YRGB_ID				(0xf<<24)
+#define m_WB_UI_ID				(0xf<<28)
+#define WB_CTRL1			(0x0024)
+#define v_WB_WIDTH(x)				(((x)&0xfff)<<0)
+#define v_WB_XPSD_BIL_FACTOR(x)			(((x)&0x3fff)<<16)
+#define m_WB_WIDTH				(0xfff<<0)
+#define m_WB_XPSD_BIL_FACTOR			(0x3fff<<16)
+#define WB_YRGB_MST                     (0x0028)
+#define WB_CBR_MST                      (0x002c)
+/********************rk3366 write back register************************/
+
+/*win0 register*/
+#define WIN0_CTRL0			(0x0030)
+#define v_WIN0_EN(x)				(((x)&1)<<0)
+#define v_WIN0_DATA_FMT(x)			(((x)&7)<<1)
+#define v_WIN0_FMT_10(x)			(((x)&1)<<4)
+#define v_WIN0_LB_MODE(x)			(((x)&7)<<5)
+#define v_WIN0_INTERLACE_READ(x)		(((x)&1)<<8)
+#define v_WIN0_NO_OUTSTANDING(x)		(((x)&1)<<9)
+#define v_WIN0_CSC_MODE(x)			(((x)&3)<<10)
+#define v_WIN0_RB_SWAP(x)			(((x)&1)<<12)
+#define v_WIN0_ALPHA_SWAP(x)			(((x)&1)<<13)
+#define v_WIN0_MID_SWAP(x)			(((x)&1)<<14)
+#define v_WIN0_UV_SWAP(x)			(((x)&1)<<15)
+#define v_WIN0_HW_PRE_MUL_EN(x)			(((x)&1)<<16)
+#define v_WIN0_YRGB_DEFLICK(x)			(((x)&1)<<18)
+#define v_WIN0_CBR_DEFLICK(x)			(((x)&1)<<19)
+#define v_WIN0_YUV_CLIP(x)			(((x)&1)<<20)
+#define v_WIN0_X_MIRROR(x)			(((x)&1)<<21)
+#define v_WIN0_Y_MIRROR(x)			(((x)&1)<<22)
+#define v_WIN0_AXI_MAX_OUTSTANDING_EN(x)	(((x)&1)<<24)
+#define v_WIN0_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<25)
+#define v_WIN0_DMA_BURST_LENGTH(x)		(((x)&0x3)<<30)
+
+#define m_WIN0_EN				(1<<0)
+#define m_WIN0_DATA_FMT				(7<<1)
+#define m_WIN0_FMT_10				(1<<4)
+#define m_WIN0_LB_MODE				(7<<5)
+#define m_WIN0_INTERLACE_READ			(1<<8)
+#define m_WIN0_NO_OUTSTANDING			(1<<9)
+#define m_WIN0_CSC_MODE				(3<<10)
+#define m_WIN0_RB_SWAP				(1<<12)
+#define m_WIN0_ALPHA_SWAP			(1<<13)
+#define m_WIN0_MID_SWAP				(1<<14)
+#define m_WIN0_UV_SWAP				(1<<15)
+#define m_WIN0_HW_PRE_MUL_EN			(1<<16)
+#define m_WIN0_YRGB_DEFLICK			(1<<18)
+#define m_WIN0_CBR_DEFLICK			(1<<19)
+#define m_WIN0_YUV_CLIP				(1<<20)
+#define m_WIN0_X_MIRROR				(1<<21)
+#define m_WIN0_Y_MIRROR				(1<<22)
+#define m_WIN0_AXI_MAX_OUTSTANDING_EN		(1<<24)
+#define m_WIN0_AXI_OUTSTANDING_MAX_NUM		(0x1f<<25)
+#define m_WIN0_DMA_BURST_LENGTH			(0x3<<30)
+
+#define WIN0_CTRL1			(0x0034)
+#define v_WIN0_YRGB_AXI_GATHER_EN(x)		(((x)&1)<<0)
+#define v_WIN0_CBR_AXI_GATHER_EN(x)		(((x)&1)<<1)
+#define v_WIN0_BIC_COE_SEL(x)			(((x)&3)<<2)
+#define v_WIN0_VSD_YRGB_GT4(x)			(((x)&1)<<4)
+#define v_WIN0_VSD_YRGB_GT2(x)			(((x)&1)<<5)
+#define v_WIN0_VSD_CBR_GT4(x)			(((x)&1)<<6)
+#define v_WIN0_VSD_CBR_GT2(x)			(((x)&1)<<7)
+#define v_WIN0_YRGB_AXI_GATHER_NUM(x)		(((x)&0xf)<<8)
+#define v_WIN0_CBR_AXI_GATHER_NUM(x)		(((x)&7)<<12)
+#define v_WIN0_LINE_LOAD_MODE(x)		(((x)&1)<<15)
+#define v_WIN0_YRGB_HOR_SCL_MODE(x)		(((x)&3)<<16)
+#define v_WIN0_YRGB_VER_SCL_MODE(x)		(((x)&3)<<18)
+#define v_WIN0_YRGB_HSD_MODE(x)			(((x)&3)<<20)
+#define v_WIN0_YRGB_VSU_MODE(x)			(((x)&1)<<22)
+#define v_WIN0_YRGB_VSD_MODE(x)			(((x)&1)<<23)
+#define v_WIN0_CBR_HOR_SCL_MODE(x)		(((x)&3)<<24)
+#define v_WIN0_CBR_VER_SCL_MODE(x)		(((x)&3)<<26)
+#define v_WIN0_CBR_HSD_MODE(x)			(((x)&3)<<28)
+#define v_WIN0_CBR_VSU_MODE(x)			(((x)&1)<<30)
+#define v_WIN0_CBR_VSD_MODE(x)			(((x)&1)<<31)
+
+#define m_WIN0_YRGB_AXI_GATHER_EN		(1<<0)
+#define m_WIN0_CBR_AXI_GATHER_EN		(1<<1)
+#define m_WIN0_BIC_COE_SEL			(3<<2)
+#define m_WIN0_VSD_YRGB_GT4			(1<<4)
+#define m_WIN0_VSD_YRGB_GT2			(1<<5)
+#define m_WIN0_VSD_CBR_GT4			(1<<6)
+#define m_WIN0_VSD_CBR_GT2			(1<<7)
+#define m_WIN0_YRGB_AXI_GATHER_NUM		(0xf<<8)
+#define m_WIN0_CBR_AXI_GATHER_NUM		(7<<12)
+#define m_WIN0_LINE_LOAD_MODE			(1<<15)
+#define m_WIN0_YRGB_HOR_SCL_MODE		(3<<16)
+#define m_WIN0_YRGB_VER_SCL_MODE		(3<<18)
+#define m_WIN0_YRGB_HSD_MODE			(3<<20)
+#define m_WIN0_YRGB_VSU_MODE			(1<<22)
+#define m_WIN0_YRGB_VSD_MODE			(1<<23)
+#define m_WIN0_CBR_HOR_SCL_MODE			(3<<24)
+#define m_WIN0_CBR_VER_SCL_MODE			(3<<26)
+#define m_WIN0_CBR_HSD_MODE			(3<<28)
+#define m_WIN0_CBR_VSU_MODE			((u32)1<<30)
+#define m_WIN0_CBR_VSD_MODE			((u32)1<<31)
+
+#define WIN0_COLOR_KEY			(0x0038)
+#define v_WIN0_COLOR_KEY(x)			(((x)&0x3fffffff)<<0)
+#define v_WIN0_COLOR_KEY_EN(x)			(((x)&1)<<31)
+#define m_WIN0_COLOR_KEY			(0x3fffffff<<0)
+#define m_WIN0_COLOR_KEY_EN			((u32)1<<31)
+
+#define WIN0_VIR			(0x003c)
+#define v_WIN0_VIR_STRIDE(x)			(((x)&0xffff)<<0)
+#define v_WIN0_VIR_STRIDE_UV(x)			(((x)&0xffff)<<16)
+#define m_WIN0_VIR_STRIDE			(0xffff<<0)
+#define m_WIN0_VIR_STRIDE_UV			(0xffff<<16)
+
+#define WIN0_YRGB_MST			(0x0040)
+#define WIN0_CBR_MST			(0x0044)
+#define WIN0_ACT_INFO			(0x0048)
+#define v_WIN0_ACT_WIDTH(x)			(((x-1)&0x1fff)<<0)
+#define v_WIN0_ACT_HEIGHT(x)			(((x-1)&0x1fff)<<16)
+#define m_WIN0_ACT_WIDTH			(0x1fff<<0)
+#define m_WIN0_ACT_HEIGHT			(0x1fff<<16)
+
+#define WIN0_DSP_INFO			(0x004c)
+#define v_WIN0_DSP_WIDTH(x)			(((x-1)&0xfff)<<0)
+#define v_WIN0_DSP_HEIGHT(x)			(((x-1)&0xfff)<<16)
+#define m_WIN0_DSP_WIDTH			(0xfff<<0)
+#define m_WIN0_DSP_HEIGHT			(0xfff<<16)
+
+#define WIN0_DSP_ST			(0x0050)
+#define v_WIN0_DSP_XST(x)			(((x)&0x1fff)<<0)
+#define v_WIN0_DSP_YST(x)			(((x)&0x1fff)<<16)
+#define m_WIN0_DSP_XST				(0x1fff<<0)
+#define m_WIN0_DSP_YST				(0x1fff<<16)
+
+#define WIN0_SCL_FACTOR_YRGB		(0x0054)
+#define v_WIN0_HS_FACTOR_YRGB(x)		(((x)&0xffff)<<0)
+#define v_WIN0_VS_FACTOR_YRGB(x)		(((x)&0xffff)<<16)
+#define m_WIN0_HS_FACTOR_YRGB			(0xffff<<0)
+#define m_WIN0_VS_FACTOR_YRGB			((u32)0xffff<<16)
+
+#define WIN0_SCL_FACTOR_CBR		(0x0058)
+#define v_WIN0_HS_FACTOR_CBR(x)			(((x)&0xffff)<<0)
+#define v_WIN0_VS_FACTOR_CBR(x)			(((x)&0xffff)<<16)
+#define m_WIN0_HS_FACTOR_CBR			(0xffff<<0)
+#define m_WIN0_VS_FACTOR_CBR			((u32)0xffff<<16)
+
+#define WIN0_SCL_OFFSET			(0x005c)
+#define v_WIN0_HS_OFFSET_YRGB(x)		(((x)&0xff)<<0)
+#define v_WIN0_HS_OFFSET_CBR(x)			(((x)&0xff)<<8)
+#define v_WIN0_VS_OFFSET_YRGB(x)		(((x)&0xff)<<16)
+#define v_WIN0_VS_OFFSET_CBR(x)			(((x)&0xff)<<24)
+
+#define m_WIN0_HS_OFFSET_YRGB			(0xff<<0)
+#define m_WIN0_HS_OFFSET_CBR			(0xff<<8)
+#define m_WIN0_VS_OFFSET_YRGB			(0xff<<16)
+#define m_WIN0_VS_OFFSET_CBR			((u32)0xff<<24)
+
+#define WIN0_SRC_ALPHA_CTRL		(0x0060)
+#define v_WIN0_SRC_ALPHA_EN(x)			(((x)&1)<<0)
+#define v_WIN0_SRC_COLOR_M0(x)			(((x)&1)<<1)
+#define v_WIN0_SRC_ALPHA_M0(x)			(((x)&1)<<2)
+#define v_WIN0_SRC_BLEND_M0(x)			(((x)&3)<<3)
+#define v_WIN0_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
+#define v_WIN0_SRC_FACTOR_M0(x)			(((x)&7)<<6)
+#define v_WIN0_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
+#define v_WIN0_FADING_VALUE(x)			(((x)&0xff)<<24)
+
+#define m_WIN0_SRC_ALPHA_EN			(1<<0)
+#define m_WIN0_SRC_COLOR_M0			(1<<1)
+#define m_WIN0_SRC_ALPHA_M0			(1<<2)
+#define m_WIN0_SRC_BLEND_M0			(3<<3)
+#define m_WIN0_SRC_ALPHA_CAL_M0			(1<<5)
+#define m_WIN0_SRC_FACTOR_M0			(7<<6)
+#define m_WIN0_SRC_GLOBAL_ALPHA			(0xff<<16)
+#define m_WIN0_FADING_VALUE			(0xff<<24)
+
+#define WIN0_DST_ALPHA_CTRL		(0x0064)
+#define v_WIN0_DST_FACTOR_M0(x)			(((x)&7)<<6)
+#define m_WIN0_DST_FACTOR_M0			(7<<6)
+
+#define WIN0_FADING_CTRL		(0x0068)
+#define v_WIN0_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
+#define v_WIN0_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
+#define v_WIN0_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
+#define v_WIN0_FADING_EN(x)			(((x)&1)<<24)
+
+#define m_WIN0_FADING_OFFSET_R			(0xff<<0)
+#define m_WIN0_FADING_OFFSET_G			(0xff<<8)
+#define m_WIN0_FADING_OFFSET_B			(0xff<<16)
+#define m_WIN0_FADING_EN			(1<<24)
+
+#define WIN0_CTRL2                     (0x006c)
+#define v_WIN_RID_WIN0_YRGB(x)			(((x)&0xf)<<0)
+#define v_WIN_RID_WIN0_CBR(x)			(((x)&0xf)<<4)
+#define m_WIN_RID_WIN0_YRGB			((0xf)<<0)
+#define m_WIN_RID_WIN0_CBR			((0xf)<<4)
+/*win1 register*/
+#define WIN1_CTRL0			(0x0070)
+#define v_WIN1_EN(x)				(((x)&1)<<0)
+#define v_WIN1_DATA_FMT(x)			(((x)&7)<<1)
+#define v_WIN1_FMT_10(x)			(((x)&1)<<4)
+#define v_WIN1_LB_MODE(x)			(((x)&7)<<5)
+#define v_WIN1_INTERLACE_READ(x)		(((x)&1)<<8)
+#define v_WIN1_NO_OUTSTANDING(x)		(((x)&1)<<9)
+#define v_WIN1_CSC_MODE(x)			(((x)&3)<<10)
+#define v_WIN1_RB_SWAP(x)			(((x)&1)<<12)
+#define v_WIN1_ALPHA_SWAP(x)			(((x)&1)<<13)
+#define v_WIN1_MID_SWAP(x)			(((x)&1)<<14)
+#define v_WIN1_UV_SWAP(x)			(((x)&1)<<15)
+#define v_WIN1_HW_PRE_MUL_EN(x)			(((x)&1)<<16)
+#define v_WIN1_YRGB_DEFLICK(x)			(((x)&1)<<18)
+#define v_WIN1_CBR_DEFLICK(x)			(((x)&1)<<19)
+#define v_WIN1_YUV_CLIP(x)			(((x)&1)<<20)
+#define v_WIN1_X_MIRROR(x)			(((x)&1)<<21)
+#define v_WIN1_Y_MIRROR(x)			(((x)&1)<<22)
+#define v_WIN1_AXI_MAX_OUTSTANDING_EN(x)	(((x)&1)<<24)
+#define v_WIN1_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<25)
+#define v_WIN1_DMA_BURST_LENGTH(x)		(((x)&0x3)<<30)
+#define m_WIN1_EN				(1<<0)
+#define m_WIN1_DATA_FMT				(7<<1)
+#define m_WIN1_FMT_10				(1<<4)
+#define m_WIN1_LB_MODE				(7<<5)
+#define m_WIN1_INTERLACE_READ			(1<<8)
+#define m_WIN1_NO_OUTSTANDING			(1<<9)
+#define m_WIN1_CSC_MODE				(3<<10)
+#define m_WIN1_RB_SWAP				(1<<12)
+#define m_WIN1_ALPHA_SWAP			(1<<13)
+#define m_WIN1_MID_SWAP				(1<<14)
+#define m_WIN1_UV_SWAP				(1<<15)
+#define m_WIN1_HW_PRE_MUL_EN			(1<<16)
+#define m_WIN1_YRGB_DEFLICK			(1<<18)
+#define m_WIN1_CBR_DEFLICK			(1<<19)
+#define m_WIN1_YUV_CLIP				(1<<20)
+#define m_WIN1_X_MIRROR				(1<<21)
+#define m_WIN1_Y_MIRROR				(1<<22)
+#define m_WIN1_AXI_MAX_OUTSTANDING_EN		(1<<24)
+#define m_WIN1_AXI_OUTSTANDING_MAX_NUM		(0x1f<<25)
+#define m_WIN1_DMA_BURST_LENGTH			(0x3<<30)
+
+#define WIN1_CTRL1			(0x0074)
+#define v_WIN1_YRGB_AXI_GATHER_EN(x)		(((x)&1)<<0)
+#define v_WIN1_CBR_AXI_GATHER_EN(x)		(((x)&1)<<1)
+#define v_WIN1_BIC_COE_SEL(x)			(((x)&3)<<2)
+#define v_WIN1_VSD_YRGB_GT4(x)			(((x)&1)<<4)
+#define v_WIN1_VSD_YRGB_GT2(x)			(((x)&1)<<5)
+#define v_WIN1_VSD_CBR_GT4(x)			(((x)&1)<<6)
+#define v_WIN1_VSD_CBR_GT2(x)			(((x)&1)<<7)
+#define v_WIN1_YRGB_AXI_GATHER_NUM(x)		(((x)&0xf)<<8)
+#define v_WIN1_CBR_AXI_GATHER_NUM(x)		(((x)&7)<<12)
+#define v_WIN1_LINE_LOAD_MODE(x)		(((x)&1)<<15)
+#define v_WIN1_YRGB_HOR_SCL_MODE(x)		(((x)&3)<<16)
+#define v_WIN1_YRGB_VER_SCL_MODE(x)		(((x)&3)<<18)
+#define v_WIN1_YRGB_HSD_MODE(x)			(((x)&3)<<20)
+#define v_WIN1_YRGB_VSU_MODE(x)			(((x)&1)<<22)
+#define v_WIN1_YRGB_VSD_MODE(x)			(((x)&1)<<23)
+#define v_WIN1_CBR_HOR_SCL_MODE(x)		(((x)&3)<<24)
+#define v_WIN1_CBR_VER_SCL_MODE(x)		(((x)&3)<<26)
+#define v_WIN1_CBR_HSD_MODE(x)			(((x)&3)<<28)
+#define v_WIN1_CBR_VSU_MODE(x)			(((x)&1)<<30)
+#define v_WIN1_CBR_VSD_MODE(x)			(((x)&1)<<31)
+
+#define m_WIN1_YRGB_AXI_GATHER_EN		(1<<0)
+#define m_WIN1_CBR_AXI_GATHER_EN		(1<<1)
+#define m_WIN1_BIC_COE_SEL			(3<<2)
+#define m_WIN1_VSD_YRGB_GT4			(1<<4)
+#define m_WIN1_VSD_YRGB_GT2			(1<<5)
+#define m_WIN1_VSD_CBR_GT4			(1<<6)
+#define m_WIN1_VSD_CBR_GT2			(1<<7)
+#define m_WIN1_YRGB_AXI_GATHER_NUM		(0xf<<8)
+#define m_WIN1_CBR_AXI_GATHER_NUM		(7<<12)
+#define m_WIN1_LINE_LOAD_MODE			(1<<15)
+#define m_WIN1_YRGB_HOR_SCL_MODE		(3<<16)
+#define m_WIN1_YRGB_VER_SCL_MODE		(3<<18)
+#define m_WIN1_YRGB_HSD_MODE			(3<<20)
+#define m_WIN1_YRGB_VSU_MODE			(1<<22)
+#define m_WIN1_YRGB_VSD_MODE			(1<<23)
+#define m_WIN1_CBR_HOR_SCL_MODE			(3<<24)
+#define m_WIN1_CBR_VER_SCL_MODE			(3<<26)
+#define m_WIN1_CBR_HSD_MODE			(3<<28)
+#define m_WIN1_CBR_VSU_MODE			(1<<30)
+#define m_WIN1_CBR_VSD_MODE			((u32)1<<31)
+
+#define WIN1_COLOR_KEY			(0x0078)
+#define v_WIN1_COLOR_KEY(x)			(((x)&0x3fffffff)<<0)
+#define v_WIN1_COLOR_KEY_EN(x)			(((x)&1)<<31)
+#define m_WIN1_COLOR_KEY			(0x3fffffff<<0)
+#define m_WIN1_COLOR_KEY_EN			((u32)1<<31)
+
+#define WIN1_VIR			(0x007c)
+#define v_WIN1_VIR_STRIDE(x)			(((x)&0xffff)<<0)
+#define v_WIN1_VIR_STRIDE_UV(x)			(((x)&0xffff)<<16)
+#define m_WIN1_VIR_STRIDE			(0xffff<<0)
+#define m_WIN1_VIR_STRIDE_UV			(0xffff<<16)
+
+#define WIN1_YRGB_MST			(0x0080)
+#define WIN1_CBR_MST			(0x0084)
+#define WIN1_ACT_INFO			(0x0088)
+#define v_WIN1_ACT_WIDTH(x)			(((x-1)&0x1fff)<<0)
+#define v_WIN1_ACT_HEIGHT(x)			(((x-1)&0x1fff)<<16)
+#define m_WIN1_ACT_WIDTH			(0x1fff<<0)
+#define m_WIN1_ACT_HEIGHT			(0x1fff<<16)
+
+#define WIN1_DSP_INFO			(0x008c)
+#define v_WIN1_DSP_WIDTH(x)			(((x-1)&0xfff)<<0)
+#define v_WIN1_DSP_HEIGHT(x)			(((x-1)&0xfff)<<16)
+#define m_WIN1_DSP_WIDTH			(0xfff<<0)
+#define m_WIN1_DSP_HEIGHT			(0xfff<<16)
+
+#define WIN1_DSP_ST			(0x0090)
+#define v_WIN1_DSP_XST(x)			(((x)&0x1fff)<<0)
+#define v_WIN1_DSP_YST(x)			(((x)&0x1fff)<<16)
+#define m_WIN1_DSP_XST				(0x1fff<<0)
+#define m_WIN1_DSP_YST				(0x1fff<<16)
+
+#define WIN1_SCL_FACTOR_YRGB		(0x0094)
+#define v_WIN1_HS_FACTOR_YRGB(x)		(((x)&0xffff)<<0)
+#define v_WIN1_VS_FACTOR_YRGB(x)		(((x)&0xffff)<<16)
+#define m_WIN1_HS_FACTOR_YRGB			(0xffff<<0)
+#define m_WIN1_VS_FACTOR_YRGB			((u32)0xffff<<16)
+
+#define WIN1_SCL_FACTOR_CBR		(0x0098)
+#define v_WIN1_HS_FACTOR_CBR(x)			(((x)&0xffff)<<0)
+#define v_WIN1_VS_FACTOR_CBR(x)			(((x)&0xffff)<<16)
+#define m_WIN1_HS_FACTOR_CBR			(0xffff<<0)
+#define m_WIN1_VS_FACTOR_CBR			((u32)0xffff<<16)
+
+#define WIN1_SCL_OFFSET			(0x009c)
+#define v_WIN1_HS_OFFSET_YRGB(x)		(((x)&0xff)<<0)
+#define v_WIN1_HS_OFFSET_CBR(x)			(((x)&0xff)<<8)
+#define v_WIN1_VS_OFFSET_YRGB(x)		(((x)&0xff)<<16)
+#define v_WIN1_VS_OFFSET_CBR(x)			(((x)&0xff)<<24)
+
+#define m_WIN1_HS_OFFSET_YRGB			(0xff<<0)
+#define m_WIN1_HS_OFFSET_CBR			(0xff<<8)
+#define m_WIN1_VS_OFFSET_YRGB			(0xff<<16)
+#define m_WIN1_VS_OFFSET_CBR			((u32)0xff<<24)
+
+#define WIN1_SRC_ALPHA_CTRL		(0x00a0)
+#define v_WIN1_SRC_ALPHA_EN(x)			(((x)&1)<<0)
+#define v_WIN1_SRC_COLOR_M0(x)			(((x)&1)<<1)
+#define v_WIN1_SRC_ALPHA_M0(x)			(((x)&1)<<2)
+#define v_WIN1_SRC_BLEND_M0(x)			(((x)&3)<<3)
+#define v_WIN1_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
+#define v_WIN1_SRC_FACTOR_M0(x)			(((x)&7)<<6)
+#define v_WIN1_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
+#define v_WIN1_FADING_VALUE(x)			(((x)&0xff)<<24)
+
+#define m_WIN1_SRC_ALPHA_EN			(1<<0)
+#define m_WIN1_SRC_COLOR_M0			(1<<1)
+#define m_WIN1_SRC_ALPHA_M0			(1<<2)
+#define m_WIN1_SRC_BLEND_M0			(3<<3)
+#define m_WIN1_SRC_ALPHA_CAL_M0			(1<<5)
+#define m_WIN1_SRC_FACTOR_M0			(7<<6)
+#define m_WIN1_SRC_GLOBAL_ALPHA			(0xff<<16)
+#define m_WIN1_FADING_VALUE			(0xff<<24)
+
+#define WIN1_DST_ALPHA_CTRL			(0x00a4)
+#define v_WIN1_DST_FACTOR_M0(x)			(((x)&7)<<6)
+#define m_WIN1_DST_FACTOR_M0			(7<<6)
+
+#define WIN1_FADING_CTRL		(0x00a8)
+#define v_WIN1_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
+#define v_WIN1_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
+#define v_WIN1_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
+#define v_WIN1_FADING_EN(x)			(((x)&1)<<24)
+
+#define m_WIN1_FADING_OFFSET_R			(0xff<<0)
+#define m_WIN1_FADING_OFFSET_G			(0xff<<8)
+#define m_WIN1_FADING_OFFSET_B			(0xff<<16)
+#define m_WIN1_FADING_EN			(1<<24)
+
+#define WIN1_CTRL2			(0xac)
+#define v_WIN_RID_WIN1_YRGB(x)			(((x)&0xf)<<0)
+#define v_WIN_RID_WIN1_CBR(x)			(((x)&0xf)<<4)
+#define m_WIN_RID_WIN1_YRGB			((0xf)<<0)
+#define m_WIN_RID_WIN1_CBR			((0xf)<<4)
+/*win2 register*/
+#define WIN2_CTRL0			(0x00b0)
+#define v_WIN2_EN(x)				(((x)&1)<<0)
+#define v_WIN2_INTERLACE_READ(x)		(((x)&1)<<1)
+#define v_WIN2_CSC_MODE(x)			(((x)&1)<<2)
+#define v_WIN2_MST0_EN(x)			(((x)&1)<<4)
+#define v_WIN2_DATA_FMT0(x)			(((x)&3)<<5)
+#define v_WIN2_MST1_EN(x)			(((x)&1)<<8)
+#define v_WIN2_DATA_FMT1(x)			(((x)&3)<<9)
+#define v_WIN2_MST2_EN(x)			(((x)&1)<<12)
+#define v_WIN2_DATA_FMT2(x)			(((x)&3)<<13)
+#define v_WIN2_MST3_EN(x)			(((x)&1)<<16)
+#define v_WIN2_DATA_FMT3(x)			(((x)&3)<<17)
+#define v_WIN2_RB_SWAP0(x)			(((x)&1)<<20)
+#define v_WIN2_ALPHA_SWAP0(x)			(((x)&1)<<21)
+#define v_WIN2_ENDIAN_SWAP0(x)			(((x)&1)<<22)
+#define v_WIN2_RB_SWAP1(x)			(((x)&1)<<23)
+#define v_WIN2_ALPHA_SWAP1(x)			(((x)&1)<<24)
+#define v_WIN2_ENDIAN_SWAP1(x)			(((x)&1)<<25)
+#define v_WIN2_RB_SWAP2(x)			(((x)&1)<<26)
+#define v_WIN2_ALPHA_SWAP2(x)			(((x)&1)<<27)
+#define v_WIN2_ENDIAN_SWAP2(x)			(((x)&1)<<28)
+#define v_WIN2_RB_SWAP3(x)			(((x)&1)<<29)
+#define v_WIN2_ALPHA_SWAP3(x)			(((x)&1)<<30)
+#define v_WIN2_ENDIAN_SWAP3(x)			(((x)&1)<<31)
+
+#define m_WIN2_EN				(1<<0)
+#define m_WIN2_INTERLACE_READ			(1<<1)
+#define m_WIN2_CSC_MODE				(1<<2)
+#define m_WIN2_MST0_EN				(1<<4)
+#define m_WIN2_DATA_FMT0			(3<<5)
+#define m_WIN2_MST1_EN				(1<<8)
+#define m_WIN2_DATA_FMT1			(3<<9)
+#define m_WIN2_MST2_EN				(1<<12)
+#define m_WIN2_DATA_FMT2			(3<<13)
+#define m_WIN2_MST3_EN				(1<<16)
+#define m_WIN2_DATA_FMT3			(3<<17)
+#define m_WIN2_RB_SWAP0				(1<<20)
+#define m_WIN2_ALPHA_SWAP0			(1<<21)
+#define m_WIN2_ENDIAN_SWAP0			(1<<22)
+#define m_WIN2_RB_SWAP1				(1<<23)
+#define m_WIN2_ALPHA_SWAP1			(1<<24)
+#define m_WIN2_ENDIAN_SWAP1			(1<<25)
+#define m_WIN2_RB_SWAP2				(1<<26)
+#define m_WIN2_ALPHA_SWAP2			(1<<27)
+#define m_WIN2_ENDIAN_SWAP2			(1<<28)
+#define m_WIN2_RB_SWAP3				(1<<29)
+#define m_WIN2_ALPHA_SWAP3			(1<<30)
+#define m_WIN2_ENDIAN_SWAP3			(1<<31)
+
+#define WIN2_CTRL1			(0x00b4)
+#define v_WIN2_AXI_GATHER_EN(x)			(((x)&1)<<0)
+#define v_WIN2_AXI_MAX_OUTSTANDING_EN(x)	(((x)&1)<<1)
+#define v_WIN2_DMA_BURST_LENGTH(x)	        (((x)&0x3)<<2)
+#define v_WIN2_AXI_GATHER_NUM(x)	        (((x)&0xf)<<4)
+#define v_WIN2_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<8)
+#define v_WIN2_RGB2YUV_EN(x)			(((x)&1)<<13)
+#define v_WIN2_NO_OUTSTANDING(x)		(((x)&1)<<14)
+#define v_WIN2_Y_MIR(x)			        (((x)&1)<<15)
+#define v_WIN2_LUT_EN(x)		        (((x)&1)<<16)
+#define v_WIN_RID_WIN2(x)	                (((x)&0xf)<<20)
+
+#define m_WIN2_AXI_GATHER_EN			(1<<0)
+#define m_WIN2_AXI_MAX_OUTSTANDING_EN		(1<<1)
+#define m_WIN2_DMA_BURST_LENGTH			(0x3<<2)
+#define m_WIN2_AXI_GATHER_NUM			(0xf<<4)
+#define m_WIN2_AXI_OUTSTANDING_MAX_NUM		(0x1f<<8)
+#define m_WIN2_RGB2YUV_EN			(1<<13)
+#define m_WIN2_NO_OUTSTANDING			(1<<14)
+#define m_WIN2_Y_MIR				(1<<15)
+#define m_WIN2_LUT_EN				(1<<16)
+#define m_WIN_RID_WIN2				(0xf<<20)
+
+#define WIN2_VIR0_1			(0x00b8)
+#define v_WIN2_VIR_STRIDE0(x)			(((x)&0xffff)<<0)
+#define v_WIN2_VIR_STRIDE1(x)			(((x)&0xffff)<<16)
+#define m_WIN2_VIR_STRIDE0			(((u32)0xffff)<<0)
+#define m_WIN2_VIR_STRIDE1			(((u32)0xffff)<<16)
+
+#define WIN2_VIR2_3			(0x00bc)
+#define v_WIN2_VIR_STRIDE2(x)			(((x)&0xffff)<<0)
+#define v_WIN2_VIR_STRIDE3(x)			(((x)&0xffff)<<16)
+#define m_WIN2_VIR_STRIDE2			(((u32)0xffff)<<0)
+#define m_WIN2_VIR_STRIDE3			(((u32)0xffff)<<16)
+
+#define WIN2_MST0			(0x00c0)
+#define WIN2_DSP_INFO0			(0x00c4)
+#define v_WIN2_DSP_WIDTH0(x)			(((x-1)&0xfff)<<0)
+#define v_WIN2_DSP_HEIGHT0(x)			(((x-1)&0xfff)<<16)
+#define m_WIN2_DSP_WIDTH0			(0xfff<<0)
+#define m_WIN2_DSP_HEIGHT0			(0xfff<<16)
+
+#define WIN2_DSP_ST0			(0x00c8)
+#define v_WIN2_DSP_XST0(x)			(((x)&0x1fff)<<0)
+#define v_WIN2_DSP_YST0(x)			(((x)&0x1fff)<<16)
+#define m_WIN2_DSP_XST0				(0x1fff<<0)
+#define m_WIN2_DSP_YST0				(0x1fff<<16)
+
+#define WIN2_COLOR_KEY			(0x00cc)
+#define v_WIN2_COLOR_KEY(x)			(((x)&0xffffff)<<0)
+#define v_WIN2_KEY_EN(x)			(((x)&1)<<24)
+#define m_WIN2_COLOR_KEY			(0xffffff<<0)
+#define m_WIN2_KEY_EN				((u32)1<<24)
+
+
+#define WIN2_MST1			(0x00d0)
+#define WIN2_DSP_INFO1			(0x00d4)
+#define v_WIN2_DSP_WIDTH1(x)			(((x-1)&0xfff)<<0)
+#define v_WIN2_DSP_HEIGHT1(x)			(((x-1)&0xfff)<<16)
+
+#define m_WIN2_DSP_WIDTH1			(0xfff<<0)
+#define m_WIN2_DSP_HEIGHT1			(0xfff<<16)
+
+#define WIN2_DSP_ST1			(0x00d8)
+#define v_WIN2_DSP_XST1(x)			(((x)&0x1fff)<<0)
+#define v_WIN2_DSP_YST1(x)			(((x)&0x1fff)<<16)
+#define m_WIN2_DSP_XST1				(0x1fff<<0)
+#define m_WIN2_DSP_YST1				(0x1fff<<16)
+
+#define WIN2_SRC_ALPHA_CTRL		(0x00dc)
+#define v_WIN2_SRC_ALPHA_EN(x)			(((x)&1)<<0)
+#define v_WIN2_SRC_COLOR_M0(x)			(((x)&1)<<1)
+#define v_WIN2_SRC_ALPHA_M0(x)			(((x)&1)<<2)
+#define v_WIN2_SRC_BLEND_M0(x)			(((x)&3)<<3)
+#define v_WIN2_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
+#define v_WIN2_SRC_FACTOR_M0(x)			(((x)&7)<<6)
+#define v_WIN2_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
+#define v_WIN2_FADING_VALUE(x)			(((x)&0xff)<<24)
+#define m_WIN2_SRC_ALPHA_EN			(1<<0)
+#define m_WIN2_SRC_COLOR_M0			(1<<1)
+#define m_WIN2_SRC_ALPHA_M0			(1<<2)
+#define m_WIN2_SRC_BLEND_M0			(3<<3)
+#define m_WIN2_SRC_ALPHA_CAL_M0			(1<<5)
+#define m_WIN2_SRC_FACTOR_M0			(7<<6)
+#define m_WIN2_SRC_GLOBAL_ALPHA			(0xff<<16)
+#define m_WIN2_FADING_VALUE			(0xff<<24)
+
+#define WIN2_MST2			(0x00e0)
+#define WIN2_DSP_INFO2			(0x00e4)
+#define v_WIN2_DSP_WIDTH2(x)			(((x-1)&0xfff)<<0)
+#define v_WIN2_DSP_HEIGHT2(x)			(((x-1)&0xfff)<<16)
+#define m_WIN2_DSP_WIDTH2			(0xfff<<0)
+#define m_WIN2_DSP_HEIGHT2			(0xfff<<16)
+
+#define WIN2_DSP_ST2			(0x00e8)
+#define v_WIN2_DSP_XST2(x)			(((x)&0x1fff)<<0)
+#define v_WIN2_DSP_YST2(x)			(((x)&0x1fff)<<16)
+#define m_WIN2_DSP_XST2				(0x1fff<<0)
+#define m_WIN2_DSP_YST2				(0x1fff<<16)
+
+#define WIN2_DST_ALPHA_CTRL		(0x00ec)
+#define v_WIN2_DST_FACTOR_M0(x)			(((x)&7)<<6)
+#define m_WIN2_DST_FACTOR_M0			(7<<6)
+
+#define WIN2_MST3			(0x00f0)
+#define WIN2_DSP_INFO3			(0x00f4)
+#define v_WIN2_DSP_WIDTH3(x)			(((x-1)&0xfff)<<0)
+#define v_WIN2_DSP_HEIGHT3(x)			(((x-1)&0xfff)<<16)
+#define m_WIN2_DSP_WIDTH3			(0xfff<<0)
+#define m_WIN2_DSP_HEIGHT3			(0xfff<<16)
+
+#define WIN2_DSP_ST3			(0x00f8)
+#define v_WIN2_DSP_XST3(x)			(((x)&0x1fff)<<0)
+#define v_WIN2_DSP_YST3(x)			(((x)&0x1fff)<<16)
+#define m_WIN2_DSP_XST3				(0x1fff<<0)
+#define m_WIN2_DSP_YST3				(0x1fff<<16)
+
+#define WIN2_FADING_CTRL		(0x00fc)
+#define v_WIN2_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
+#define v_WIN2_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
+#define v_WIN2_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
+#define v_WIN2_FADING_EN(x)			(((x)&1)<<24)
+
+#define m_WIN2_FADING_OFFSET_R			(0xff<<0)
+#define m_WIN2_FADING_OFFSET_G			(0xff<<8)
+#define m_WIN2_FADING_OFFSET_B			(0xff<<16)
+#define m_WIN2_FADING_EN			(1<<24)
+
+/*win3 register*/
+#define WIN3_CTRL0			(0x0100)
+#define v_WIN3_EN(x)				(((x)&1)<<0)
+#define v_WIN3_INTERLACE_READ(x)		(((x)&1)<<1)
+#define v_WIN3_CSC_MODE(x)			(((x)&1)<<2)
+#define v_WIN3_MST0_EN(x)			(((x)&1)<<4)
+#define v_WIN3_DATA_FMT0(x)			(((x)&3)<<5)
+#define v_WIN3_MST1_EN(x)			(((x)&1)<<8)
+#define v_WIN3_DATA_FMT1(x)			(((x)&3)<<9)
+#define v_WIN3_MST2_EN(x)			(((x)&1)<<12)
+#define v_WIN3_DATA_FMT2(x)			(((x)&3)<<13)
+#define v_WIN3_MST3_EN(x)			(((x)&1)<<16)
+#define v_WIN3_DATA_FMT3(x)			(((x)&3)<<17)
+#define v_WIN3_RB_SWAP0(x)			(((x)&1)<<20)
+#define v_WIN3_ALPHA_SWAP0(x)			(((x)&1)<<21)
+#define v_WIN3_ENDIAN_SWAP0(x)			(((x)&1)<<22)
+#define v_WIN3_RB_SWAP1(x)			(((x)&1)<<23)
+#define v_WIN3_ALPHA_SWAP1(x)			(((x)&1)<<24)
+#define v_WIN3_ENDIAN_SWAP1(x)			(((x)&1)<<25)
+#define v_WIN3_RB_SWAP2(x)			(((x)&1)<<26)
+#define v_WIN3_ALPHA_SWAP2(x)			(((x)&1)<<27)
+#define v_WIN3_ENDIAN_SWAP2(x)			(((x)&1)<<28)
+#define v_WIN3_RB_SWAP3(x)			(((x)&1)<<29)
+#define v_WIN3_ALPHA_SWAP3(x)			(((x)&1)<<30)
+#define v_WIN3_ENDIAN_SWAP3(x)			(((x)&1)<<31)
+
+#define m_WIN3_EN				(1<<0)
+#define m_WIN3_INTERLACE_READ			(1<<1)
+#define m_WIN3_CSC_MODE				(1<<2)
+#define m_WIN3_MST0_EN				(1<<4)
+#define m_WIN3_DATA_FMT0			(3<<5)
+#define m_WIN3_MST1_EN				(1<<8)
+#define m_WIN3_DATA_FMT1			(3<<9)
+#define m_WIN3_MST2_EN				(1<<12)
+#define m_WIN3_DATA_FMT2			(3<<13)
+#define m_WIN3_MST3_EN				(1<<16)
+#define m_WIN3_DATA_FMT3			(3<<17)
+#define m_WIN3_RB_SWAP0				(1<<20)
+#define m_WIN3_ALPHA_SWAP0			(1<<21)
+#define m_WIN3_ENDIAN_SWAP0			(1<<22)
+#define m_WIN3_RB_SWAP1				(1<<23)
+#define m_WIN3_ALPHA_SWAP1			(1<<24)
+#define m_WIN3_ENDIAN_SWAP1			(1<<25)
+#define m_WIN3_RB_SWAP2				(1<<26)
+#define m_WIN3_ALPHA_SWAP2			(1<<27)
+#define m_WIN3_ENDIAN_SWAP2			(1<<28)
+#define m_WIN3_RB_SWAP3				(1<<29)
+#define m_WIN3_ALPHA_SWAP3			(1<<30)
+#define m_WIN3_ENDIAN_SWAP3			(1<<31)
+
+#define WIN3_CTRL1			(0x0104)
+#define v_WIN3_AXI_GATHER_EN(x)		        (((x)&1)<<0)
+#define v_WIN3_AXI_MAX_OUTSTANDING_EN(x)	(((x)&1)<<1)
+#define v_WIN3_DMA_BURST_LENGTH(x)	        (((x)&0x3)<<2)
+#define v_WIN3_AXI_GATHER_NUM(x)	        (((x)&0xf)<<4)
+#define v_WIN3_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<8)
+#define v_WIN3_NO_OUTSTANDING(x)		(((x)&1)<<14)
+#define v_WIN3_Y_MIR(x)			        (((x)&1)<<15)
+#define v_WIN3_LUT_EN(x)		        (((x)&1)<<16)
+#define v_WIN_RID_WIN3(x)	                (((x)&0xf)<<20)
+
+#define m_WIN3_AXI_GATHER_EN			(1<<0)
+#define m_WIN3_AXI_MAX_OUTSTANDING_EN		(1<<1)
+#define m_WIN3_DMA_BURST_LENGTH			(0x3<<2)
+#define m_WIN3_AXI_GATHER_NUM			(0xf<<4)
+#define m_WIN3_AXI_OUTSTANDING_MAX_NUM		(0x1f<<8)
+#define m_WIN3_NO_OUTSTANDING			(1<<14)
+#define m_WIN3_Y_MIR				(1<<15)
+#define m_WIN3_LUT_EN				(1<<16)
+#define m_WIN_RID_WIN3				(0xf<<20)
+
+#define WIN3_VIR0_1			(0x0108)
+#define v_WIN3_VIR_STRIDE0(x)			(((x)&0xffff)<<0)
+#define v_WIN3_VIR_STRIDE1(x)			(((x)&0xffff)<<16)
+#define m_WIN3_VIR_STRIDE0			(0xffff<<0)
+#define m_WIN3_VIR_STRIDE1			(0xffff<<16)
+
+#define WIN3_VIR2_3			(0x010c)
+#define v_WIN3_VIR_STRIDE2(x)			(((x)&0xffff)<<0)
+#define v_WIN3_VIR_STRIDE3(x)			(((x)&0xffff)<<16)
+#define m_WIN3_VIR_STRIDE2			(0xffff<<0)
+#define m_WIN3_VIR_STRIDE3			(0xffff<<16)
+
+#define WIN3_MST0			(0x0110)
+#define WIN3_DSP_INFO0			(0x0114)
+#define v_WIN3_DSP_WIDTH0(x)			(((x-1)&0xfff)<<0)
+#define v_WIN3_DSP_HEIGHT0(x)			(((x-1)&0xfff)<<16)
+#define m_WIN3_DSP_WIDTH0			(0xfff<<0)
+#define m_WIN3_DSP_HEIGHT0			(0xfff<<16)
+
+#define WIN3_DSP_ST0			(0x0118)
+#define v_WIN3_DSP_XST0(x)			(((x)&0x1fff)<<0)
+#define v_WIN3_DSP_YST0(x)			(((x)&0x1fff)<<16)
+#define m_WIN3_DSP_XST0				(0x1fff<<0)
+#define m_WIN3_DSP_YST0				(0x1fff<<16)
+
+#define WIN3_COLOR_KEY			(0x011c)
+#define v_WIN3_COLOR_KEY(x)			(((x)&0xffffff)<<0)
+#define v_WIN3_KEY_EN(x)			(((x)&1)<<24)
+#define m_WIN3_COLOR_KEY			(0xffffff<<0)
+#define m_WIN3_KEY_EN				((u32)1<<24)
+
+#define WIN3_MST1			(0x0120)
+#define WIN3_DSP_INFO1			(0x0124)
+#define v_WIN3_DSP_WIDTH1(x)			(((x-1)&0xfff)<<0)
+#define v_WIN3_DSP_HEIGHT1(x)			(((x-1)&0xfff)<<16)
+#define m_WIN3_DSP_WIDTH1			(0xfff<<0)
+#define m_WIN3_DSP_HEIGHT1			(0xfff<<16)
+
+#define WIN3_DSP_ST1			(0x0128)
+#define v_WIN3_DSP_XST1(x)			(((x)&0x1fff)<<0)
+#define v_WIN3_DSP_YST1(x)			(((x)&0x1fff)<<16)
+#define m_WIN3_DSP_XST1				(0x1fff<<0)
+#define m_WIN3_DSP_YST1				(0x1fff<<16)
+
+#define WIN3_SRC_ALPHA_CTRL		(0x012c)
+#define v_WIN3_SRC_ALPHA_EN(x)			(((x)&1)<<0)
+#define v_WIN3_SRC_COLOR_M0(x)			(((x)&1)<<1)
+#define v_WIN3_SRC_ALPHA_M0(x)			(((x)&1)<<2)
+#define v_WIN3_SRC_BLEND_M0(x)			(((x)&3)<<3)
+#define v_WIN3_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
+#define v_WIN3_SRC_FACTOR_M0(x)			(((x)&7)<<6)
+#define v_WIN3_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
+#define v_WIN3_FADING_VALUE(x)			(((x)&0xff)<<24)
+
+#define m_WIN3_SRC_ALPHA_EN			(1<<0)
+#define m_WIN3_SRC_COLOR_M0			(1<<1)
+#define m_WIN3_SRC_ALPHA_M0			(1<<2)
+#define m_WIN3_SRC_BLEND_M0			(3<<3)
+#define m_WIN3_SRC_ALPHA_CAL_M0			(1<<5)
+#define m_WIN3_SRC_FACTOR_M0			(7<<6)
+#define m_WIN3_SRC_GLOBAL_ALPHA			(0xff<<16)
+#define m_WIN3_FADING_VALUE			(0xff<<24)
+
+#define WIN3_MST2			(0x0130)
+#define WIN3_DSP_INFO2			(0x0134)
+#define v_WIN3_DSP_WIDTH2(x)			(((x-1)&0xfff)<<0)
+#define v_WIN3_DSP_HEIGHT2(x)			(((x-1)&0xfff)<<16)
+#define m_WIN3_DSP_WIDTH2			(0xfff<<0)
+#define m_WIN3_DSP_HEIGHT2			(0xfff<<16)
+
+#define WIN3_DSP_ST2			(0x0138)
+#define v_WIN3_DSP_XST2(x)			(((x)&0x1fff)<<0)
+#define v_WIN3_DSP_YST2(x)			(((x)&0x1fff)<<16)
+#define m_WIN3_DSP_XST2				(0x1fff<<0)
+#define m_WIN3_DSP_YST2				(0x1fff<<16)
+
+#define WIN3_DST_ALPHA_CTRL		(0x013c)
+#define v_WIN3_DST_FACTOR_M0(x)			(((x)&7)<<6)
+#define m_WIN3_DST_FACTOR_M0			(7<<6)
+
+
+#define WIN3_MST3			(0x0140)
+#define WIN3_DSP_INFO3			(0x0144)
+#define v_WIN3_DSP_WIDTH3(x)			(((x-1)&0xfff)<<0)
+#define v_WIN3_DSP_HEIGHT3(x)			(((x-1)&0xfff)<<16)
+#define m_WIN3_DSP_WIDTH3		(0xfff<<0)
+#define m_WIN3_DSP_HEIGHT3		(0xfff<<16)
+
+#define WIN3_DSP_ST3			(0x0148)
+#define v_WIN3_DSP_XST3(x)			(((x)&0x1fff)<<0)
+#define v_WIN3_DSP_YST3(x)			(((x)&0x1fff)<<16)
+#define m_WIN3_DSP_XST3			(0x1fff<<0)
+#define m_WIN3_DSP_YST3			(0x1fff<<16)
+
+#define WIN3_FADING_CTRL		(0x014c)
+#define v_WIN3_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
+#define v_WIN3_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
+#define v_WIN3_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
+#define v_WIN3_FADING_EN(x)			(((x)&1)<<24)
+
+#define m_WIN3_FADING_OFFSET_R			(0xff<<0)
+#define m_WIN3_FADING_OFFSET_G			(0xff<<8)
+#define m_WIN3_FADING_OFFSET_B			(0xff<<16)
+#define m_WIN3_FADING_EN			(1<<24)
+
+
+/*hwc register*/
+#define HWC_CTRL0			(0x0150)
+#define v_HWC_EN(x)				(((x)&1)<<0)
+#define v_HWC_DATA_FMT(x)			(((x)&7)<<1)
+#define v_HWC_MODE(x)				(((x)&1)<<4)
+#define v_HWC_SIZE(x)				(((x)&3)<<5)
+#define v_HWC_INTERLACE_READ(x)			(((x)&1)<<8)
+#define v_HWC_CSC_MODE(x)			(((x)&1)<<10)
+#define v_HWC_RB_SWAP(x)			(((x)&1)<<12)
+#define v_HWC_ALPHA_SWAP(x)			(((x)&1)<<13)
+#define v_HWC_ENDIAN_SWAP(x)			(((x)&1)<<14)
+
+#define m_HWC_EN				(1<<0)
+#define m_HWC_DATA_FMT				(7<<1)
+#define m_HWC_MODE				(1<<4)
+#define m_HWC_SIZE				(3<<5)
+#define m_HWC_INTERLACE_READ			(1<<8)
+#define m_HWC_CSC_MODE				(1<<10)
+#define m_HWC_RB_SWAP				(1<<12)
+#define m_HWC_ALPHA_SWAP			(1<<13)
+#define m_HWC_ENDIAN_SWAP			(1<<14)
+
+
+#define HWC_CTRL1			(0x0154)
+#define v_HWC_AXI_GATHER_EN(x)		        (((x)&1)<<0)
+#define v_HWC_AXI_MAX_OUTSTANDING_EN(x)		(((x)&1)<<1)
+#define v_HWC_DMA_BURST_LENGTH(x)	        (((x)&0x3)<<2)
+#define v_HWC_AXI_GATHER_NUM(x)			(((x)&0x7)<<4)
+#define v_HWC_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<8)
+#define v_HWC_RGB2YUV_EN(x)			(((x)&1)<<13)
+#define v_HWC_NO_OUTSTANDING(x)			(((x)&1)<<14)
+#define v_HWC_Y_MIR(x)			        (((x)&1)<<15)
+#define v_HWC_LUT_EN(x)				(((x)&1)<<16)
+#define v_WIN_RID_HWC(x)	                (((x)&0xf)<<20)
+
+#define m_HWC_AXI_GATHER_EN			(1<<0)
+#define m_HWC_AXI_MAX_OUTSTANDING_EN		(1<<1)
+#define m_HWC_DMA_BURST_LENGTH			(0x3<<2)
+#define m_HWC_AXI_GATHER_NUM			(0x7<<4)
+#define m_HWC_AXI_OUTSTANDING_MAX_NUM		(0x1f<<8)
+#define m_HWC_RGB2YUV_EN			(1<<13)
+#define m_HWC_NO_OUTSTANDING			(1<<14)
+#define m_HWC_Y_MIR				(1<<15)
+#define m_HWC_LUT_EN				(1<<16)
+#define m_WIN_RID_HWC				(0xf<<20)
+
+#define HWC_MST				(0x0158)
+#define HWC_DSP_ST			(0x015c)
+#define v_HWC_DSP_XST(x)			(((x)&0x1fff)<<0)
+#define v_HWC_DSP_YST(x)			(((x)&0x1fff)<<16)
+#define m_HWC_DSP_XST				(0x1fff<<0)
+#define m_HWC_DSP_YST				(0x1fff<<16)
+
+#define HWC_SRC_ALPHA_CTRL		(0x0160)
+#define v_HWC_SRC_ALPHA_EN(x)			(((x)&1)<<0)
+#define v_HWC_SRC_COLOR_M0(x)			(((x)&1)<<1)
+#define v_HWC_SRC_ALPHA_M0(x)			(((x)&1)<<2)
+#define v_HWC_SRC_BLEND_M0(x)			(((x)&3)<<3)
+#define v_HWC_SRC_ALPHA_CAL_M0(x)		(((x)&1)<<5)
+#define v_HWC_SRC_FACTOR_M0(x)			(((x)&7)<<6)
+#define v_HWC_SRC_GLOBAL_ALPHA(x)		(((x)&0xff)<<16)
+#define v_HWC_FADING_VALUE(x)			(((x)&0xff)<<24)
+
+#define m_HWC_SRC_ALPHA_EN			(1<<0)
+#define m_HWC_SRC_COLOR_M0			(1<<1)
+#define m_HWC_SRC_ALPHA_M0			(1<<2)
+#define m_HWC_SRC_BLEND_M0			(3<<3)
+#define m_HWC_SRC_ALPHA_CAL_M0			(1<<5)
+#define m_HWC_SRC_FACTOR_M0			(7<<6)
+#define m_HWC_SRC_GLOBAL_ALPHA			(0xff<<16)
+#define m_HWC_FADING_VALUE			(0xff<<24)
+
+#define HWC_DST_ALPHA_CTRL		(0x0164)
+#define v_HWC_DST_FACTOR_M0(x)			(((x)&7)<<6)
+#define m_HWC_DST_FACTOR_M0			(7<<6)
+
+
+#define HWC_FADING_CTRL			(0x0168)
+#define v_HWC_FADING_OFFSET_R(x)		(((x)&0xff)<<0)
+#define v_HWC_FADING_OFFSET_G(x)		(((x)&0xff)<<8)
+#define v_HWC_FADING_OFFSET_B(x)		(((x)&0xff)<<16)
+#define v_HWC_FADING_EN(x)			(((x)&1)<<24)
+
+#define m_HWC_FADING_OFFSET_R			(0xff<<0)
+#define m_HWC_FADING_OFFSET_G			(0xff<<8)
+#define m_HWC_FADING_OFFSET_B			(0xff<<16)
+#define m_HWC_FADING_EN				(1<<24)
+
+/*post process register*/
+#define POST_DSP_HACT_INFO		(0x0170)
+#define v_DSP_HACT_END_POST(x)			(((x)&0x1fff)<<0)
+#define v_DSP_HACT_ST_POST(x)			(((x)&0x1fff)<<16)
+#define m_DSP_HACT_END_POST			(0x1fff<<0)
+#define m_DSP_HACT_ST_POST			(0x1fff<<16)
+
+#define POST_DSP_VACT_INFO		(0x0174)
+#define v_DSP_VACT_END_POST(x)			(((x)&0x1fff)<<0)
+#define v_DSP_VACT_ST_POST(x)			(((x)&0x1fff)<<16)
+#define m_DSP_VACT_END_POST			(0x1fff<<0)
+#define m_DSP_VACT_ST_POST			(0x1fff<<16)
+
+#define POST_SCL_FACTOR_YRGB		(0x0178)
+#define v_POST_HS_FACTOR_YRGB(x)		(((x)&0xffff)<<0)
+#define v_POST_VS_FACTOR_YRGB(x)		(((x)&0xffff)<<16)
+#define m_POST_HS_FACTOR_YRGB			(0xffff<<0)
+#define m_POST_VS_FACTOR_YRGB			(0xffff<<16)
+
+#define POST_SCL_CTRL			(0x0180)
+#define v_POST_HOR_SD_EN(x)			(((x)&1)<<0)
+#define v_POST_VER_SD_EN(x)			(((x)&1)<<1)
+
+#define m_POST_HOR_SD_EN			(0x1<<0)
+#define m_POST_VER_SD_EN			(0x1<<1)
+
+#define POST_DSP_VACT_INFO_F1		(0x0184)
+#define v_DSP_VACT_END_POST_F1(x)		(((x)&0x1fff)<<0)
+#define v_DSP_VACT_ST_POST_F1(x)		(((x)&0x1fff)<<16)
+
+#define m_DSP_VACT_END_POST_F1			(0x1fff<<0)
+#define m_DSP_VACT_ST_POST_F1			(0x1fff<<16)
+
+#define DSP_HTOTAL_HS_END		(0x0188)
+#define v_DSP_HS_PW(x)				(((x)&0x1fff)<<0)
+#define v_DSP_HTOTAL(x)				(((x)&0x1fff)<<16)
+#define m_DSP_HS_PW				(0x1fff<<0)
+#define m_DSP_HTOTAL				(0x1fff<<16)
+
+#define DSP_HACT_ST_END			(0x018c)
+#define v_DSP_HACT_END(x)			(((x)&0x1fff)<<0)
+#define v_DSP_HACT_ST(x)			(((x)&0x1fff)<<16)
+#define m_DSP_HACT_END				(0x1fff<<0)
+#define m_DSP_HACT_ST				(0x1fff<<16)
+
+#define DSP_VTOTAL_VS_END		(0x0190)
+#define v_DSP_VS_PW(x)				(((x)&0x1fff)<<0)
+#define v_DSP_VTOTAL(x)				(((x)&0x1fff)<<16)
+#define m_DSP_VS_PW				(0x1fff<<0)
+#define m_DSP_VTOTAL				(0x1fff<<16)
+
+#define DSP_VACT_ST_END			(0x0194)
+#define v_DSP_VACT_END(x)			(((x)&0x1fff)<<0)
+#define v_DSP_VACT_ST(x)			(((x)&0x1fff)<<16)
+#define m_DSP_VACT_END				(0x1fff<<0)
+#define m_DSP_VACT_ST				(0x1fff<<16)
+
+#define DSP_VS_ST_END_F1		(0x0198)
+#define v_DSP_VS_END_F1(x)			(((x)&0x1fff)<<0)
+#define v_DSP_VS_ST_F1(x)			(((x)&0x1fff)<<16)
+#define m_DSP_VS_END_F1				(0x1fff<<0)
+#define m_DSP_VS_ST_F1				(0x1fff<<16)
+
+#define DSP_VACT_ST_END_F1		(0x019c)
+#define v_DSP_VACT_END_F1(x)			(((x)&0x1fff)<<0)
+#define v_DSP_VAC_ST_F1(x)			(((x)&0x1fff)<<16)
+#define m_DSP_VACT_END_F1			(0x1fff<<0)
+#define m_DSP_VAC_ST_F1				(0x1fff<<16)
+
+
+/*pwm register*/
+#define PWM_CTRL			(0x01a0)
+#define v_PWM_EN(x)				(((x)&1)<<0)
+#define v_PWM_MODE(x)				(((x)&3)<<1)
+
+#define v_DUTY_POL(x)				(((x)&1)<<3)
+#define v_INACTIVE_POL(x)			(((x)&1)<<4)
+#define v_OUTPUT_MODE(x)			(((x)&1)<<5)
+#define v_BL_EN(x)				(((x)&1)<<8)
+#define v_CLK_SEL(x)				(((x)&1)<<9)
+#define v_PRESCALE(x)				(((x)&7)<<12)
+#define v_CABC_PWM_OUT_POL(x)			(((x)&1)<<15)
+#define v_SCALE(x)				(((x)&0xff)<<16)
+#define v_RPT(x)				(((x)&0xff)<<24)
+
+#define m_PWM_EN				(1<<0)
+#define m_PWM_MODE				(3<<1)
+
+#define m_DUTY_POL				(1<<3)
+#define m_INACTIVE_POL				(1<<4)
+#define m_OUTPUT_MODE				(1<<5)
+#define m_BL_EN					(1<<8)
+#define m_CLK_SEL				(1<<9)
+#define m_CABC_PWM_OUT_POL			(1<<15)
+
+#define m_PRESCALE				(7<<12)
+#define m_SCALE					(0xff<<16)
+#define m_RPT					((u32)0xff<<24)
+
+#define PWM_PERIOD_HPR				(0x01a4)
+#define PWM_DUTY_LPR				(0x01a8)
+#define PWM_CNT					(0x01ac)
+
+/*BCSH register*/
+#define BCSH_COLOR_BAR			(0x01b0)
+#define v_BCSH_EN(x)				(((x)&1)<<0)
+#define v_BCSH_COLOR_BAR_Y(x)			(((x)&0xff)<<8)
+#define v_BCSH_COLOR_BAR_U(x)			(((x)&0xff)<<16)
+#define v_BCSH_COLOR_BAR_V(x)			(((x)&0xff)<<24)
+#define m_BCSH_EN				(1<<0)
+#define m_BCSH_COLOR_BAR_Y			(0xff<<8)
+#define m_BCSH_COLOR_BAR_U			(0xff<<16)
+#define m_BCSH_COLOR_BAR_V			(0xff<<24)
+
+#define BCSH_BCS			(0x01b4)
+#define v_BCSH_BRIGHTNESS(x)			(((x)&0x3f)<<0)
+#define v_BCSH_CONTRAST(x)			(((x)&0x1ff)<<8)
+#define v_BCSH_SAT_CON(x)			(((x)&0x3ff)<<20)
+#define v_BCSH_OUT_MODE(x)			(((x)&0x3)<<30)
+#define m_BCSH_BRIGHTNESS			(0x3f<<0)
+#define m_BCSH_CONTRAST				(0x1ff<<8)
+#define m_BCSH_SAT_CON				(0x3ff<<20)
+#define m_BCSH_OUT_MODE				((u32)0x3<<30)
+
+#define BCSH_H				(0x01b8)
+#define v_BCSH_SIN_HUE(x)			(((x)&0x1ff)<<0)
+#define v_BCSH_COS_HUE(x)			(((x)&0x1ff)<<16)
+
+#define m_BCSH_SIN_HUE				(0x1ff<<0)
+#define m_BCSH_COS_HUE				(0x1ff<<16)
+
+#define BCSH_CTRL			(0x01bc)
+#define   m_BCSH_Y2R_EN				(0x1<<0)
+#define   m_BCSH_Y2R_CSC_MODE			(0x3<<2)
+#define   m_BCSH_R2Y_EN				(0x1<<4)
+#define   m_BCSH_R2Y_CSC_MODE			(0x1<<6)
+#define   v_BCSH_Y2R_EN(x)			(((x)&0x1)<<0)
+#define   v_BCSH_Y2R_CSC_MODE(x)		(((x)&0x3)<<2)
+#define   v_BCSH_R2Y_EN(x)			(((x)&0x1)<<4)
+#define   v_BCSH_R2Y_CSC_MODE(x)		(((x)&0x1)<<6)
+
+#define CABC_CTRL0			(0x01c0)
+#define v_CABC_EN(x)				(((x)&1)<<0)
+#define v_CABC_HANDLE_EN(x)			(((x)&1)<<1)
+#define v_PWM_CONFIG_MODE(x)			(((x)&3)<<2)
+#define v_CABC_CALC_PIXEL_NUM(x)		(((x)&0x7fffff)<<4)
+#define m_CABC_EN				(1<<0)
+#define m_CABC_HANDLE_EN			(1<<1)
+#define m_PWM_CONFIG_MODE			(3<<2)
+#define m_CABC_CALC_PIXEL_NUM			(0x7fffff<<4)
+
+#define CABC_CTRL1			(0x01c4)
+#define v_CABC_LUT_EN(x)			(((x)&1)<<0)
+#define v_CABC_TOTAL_PIXEL_NUM(x)		(((x)&0x7fffff)<<4)
+#define m_CABC_LUT_EN				(1<<0)
+#define m_CABC_TOTAL_PIXEL_NUM			(0x7fffff<<4)
+
+#define CABC_CTRL2			(0x01c8)
+#define v_CABC_STAGE_DOWN(x)			(((x)&0xff)<<0)
+#define v_CABC_STAGE_UP(x)			(((x)&0x1ff)<<8)
+#define v_CABC_STAGE_MODE(x)			(((x)&1)<<19)
+#define v_MAX_SCALE_CFG_VALUE(x)		(((x)&0x1ff)<<20)
+#define v_MAX_SCALE_CFG_ENABLE(x)		(((x)&1)<<31)
+#define m_CABC_STAGE_DOWN			(0xff<<0)
+#define m_CABC_STAGE_UP				(0x1ff<<8)
+#define m_CABC_STAGE_MODE			(1<<19)
+#define m_MAX_SCALE_CFG_VALUE			(0x1ff<<20)
+#define m_MAX_SCALE_CFG_ENABLE			(1<<31)
+
+#define CABC_CTRL3			(0x01cc)
+#define v_CABC_GLOBAL_DN(x)			(((x)&0xff)<<0)
+#define v_CABC_GLOBAL_DN_LIMIT_EN(x)		(((x)&1)<<8)
+#define m_CABC_GLOBAL_DN			(0xff<<0)
+#define m_CABC_GLOBAL_DN_LIMIT_EN		(1<<8)
+
+#define CABC_GAUSS_LINE0_0		(0x01d0)
+#define v_CABC_T_LINE0_0(x)			(((x)&0xff)<<0)
+#define v_CABC_T_LINE0_1(x)			(((x)&0xff)<<8)
+#define v_CABC_T_LINE0_2(x)			(((x)&0xff)<<16)
+#define v_CABC_T_LINE0_3(x)			(((x)&0xff)<<24)
+#define m_CABC_T_LINE0_0			(0xff<<0)
+#define m_CABC_T_LINE0_1			(0xff<<8)
+#define m_CABC_T_LINE0_2			(0xff<<16)
+#define m_CABC_T_LINE0_3			((u32)0xff<<24)
+
+#define CABC_GAUSS_LINE0_1		(0x01d4)
+#define v_CABC_T_LINE0_4(x)			(((x)&0xff)<<0)
+#define v_CABC_T_LINE0_5(x)			(((x)&0xff)<<8)
+#define v_CABC_T_LINE0_6(x)			(((x)&0xff)<<16)
+#define m_CABC_T_LINE0_4			(0xff<<0)
+#define m_CABC_T_LINE0_5			(0xff<<8)
+#define m_CABC_T_LINE0_6			(0xff<<16)
+
+
+#define CABC_GAUSS_LINE1_0		(0x01d8)
+#define v_CABC_T_LINE1_0(x)			(((x)&0xff)<<0)
+#define v_CABC_T_LINE1_1(x)			(((x)&0xff)<<8)
+#define v_CABC_T_LINE1_2(x)			(((x)&0xff)<<16)
+#define v_CABC_T_LINE1_3(x)			(((x)&0xff)<<24)
+#define m_CABC_T_LINE1_0			(0xff<<0)
+#define m_CABC_T_LINE1_1			(0xff<<8)
+#define m_CABC_T_LINE1_2			(0xff<<16)
+#define m_CABC_T_LINE1_3			((u32)0xff<<24)
+
+
+#define CABC_GAUSS_LINE1_1		(0x01dc)
+#define v_CABC_T_LINE1_4(x)			(((x)&0xff)<<0)
+#define v_CABC_T_LINE1_5(x)			(((x)&0xff)<<8)
+#define v_CABC_T_LINE1_6(x)			(((x)&0xff)<<16)
+#define m_CABC_T_LINE1_4			(0xff<<0)
+#define m_CABC_T_LINE1_5			(0xff<<8)
+#define m_CABC_T_LINE1_6			(0xff<<16)
+
+
+#define CABC_GAUSS_LINE2_0		(0x01e0)
+#define v_CABC_T_LINE2_0(x)			(((x)&0xff)<<0)
+#define v_CABC_T_LINE2_1(x)			(((x)&0xff)<<8)
+#define v_CABC_T_LINE2_2(x)			(((x)&0xff)<<16)
+#define v_CABC_T_LINE2_3(x)			(((x)&0xff)<<24)
+#define m_CABC_T_LINE2_0			(0xff<<0)
+#define m_CABC_T_LINE2_1			(0xff<<8)
+#define m_CABC_T_LINE2_2			(0xff<<16)
+#define m_CABC_T_LINE2_3			((u32)0xff<<24)
+
+
+#define CABC_GAUSS_LINE2_1		(0x01e4)
+#define v_CABC_T_LINE2_4(x)			(((x)&0xff)<<0)
+#define v_CABC_T_LINE2_5(x)			(((x)&0xff)<<8)
+#define v_CABC_T_LINE2_6(x)			(((x)&0xff)<<16)
+#define m_CABC_T_LINE2_4			(0xff<<0)
+#define m_CABC_T_LINE2_5			(0xff<<8)
+#define m_CABC_T_LINE2_6			(0xff<<16)
+
+/*FRC register*/
+#define FRC_LOWER01_0			(0x01e8)
+#define v_FRC_LOWER01_FRM0(x)			(((x)&0xffff)<<0)
+#define v_FRC_LOWER01_FRM1(x)			(((x)&0xffff)<<16)
+#define m_FRC_LOWER01_FRM0			(0xffff<<0)
+#define m_FRC_LOWER01_FRM1			((u32)0xffff<<16)
+
+#define FRC_LOWER01_1			(0x01ec)
+#define v_FRC_LOWER01_FRM2(x)			(((x)&0xffff)<<0)
+#define v_FRC_LOWER01_FRM3(x)			(((x)&0xffff)<<16)
+#define m_FRC_LOWER01_FRM2			(0xffff<<0)
+#define m_FRC_LOWER01_FRM3			((u32)0xffff<<16)
+
+
+#define FRC_LOWER10_0			(0x01f0)
+#define v_FRC_LOWER10_FRM0(x)			(((x)&0xffff)<<0)
+#define v_FRC_LOWER10_FRM1(x)			(((x)&0xffff)<<16)
+#define m_FRC_LOWER10_FRM0			(0xffff<<0)
+#define m_FRC_LOWER10_FRM1			((u32)0xffff<<16)
+
+
+#define FRC_LOWER10_1			(0x01f4)
+#define v_FRC_LOWER10_FRM2(x)			(((x)&0xffff)<<0)
+#define v_FRC_LOWER10_FRM3(x)			(((x)&0xffff)<<16)
+#define m_FRC_LOWER10_FRM2			(0xffff<<0)
+#define m_FRC_LOWER10_FRM3			((u32)0xffff<<16)
+
+
+#define FRC_LOWER11_0			(0x01f8)
+#define v_FRC_LOWER11_FRM0(x)			(((x)&0xffff)<<0)
+#define v_FRC_LOWER11_FRM1(x)			(((x)&0xffff)<<16)
+#define m_FRC_LOWER11_FRM0			(0xffff<<0)
+#define m_FRC_LOWER11_FRM1			((u32)0xffff<<16)
+
+
+#define FRC_LOWER11_1			(0x01fc)
+#define v_FRC_LOWER11_FRM2(x)			(((x)&0xffff)<<0)
+#define v_FRC_LOWER11_FRM3(x)			(((x)&0xffff)<<16)
+#define m_FRC_LOWER11_FRM2			(0xffff<<0)
+#define m_FRC_LOWER11_FRM3			((u32)0xffff<<16)
+
+#define IFBDC_CTRL			(0x0200)
+#define v_IFBDC_CTRL_FBDC_EN(x)		(((x)&0x1)<<0)
+#define v_IFBDC_CTRL_FBDC_COR_EN(x)		(((x)&0x1)<<1)
+#define v_IFBDC_CTRL_FBDC_WIN_SEL(x)		(((x)&0x3)<<2)
+#define v_IFBDC_CTRL_FBDC_ROTATION_MODE(x)	(((x)&0x7)<<4)
+#define v_IFBDC_CTRL_FBDC_FMT(x)		(((x)&0x7f)<<7)
+#define v_IFBDC_AXI_MAX_OUTSTANDING_EN(x)	(((x)&0x1)<<14)
+#define v_IFBDC_AXI_OUTSTANDING_MAX_NUM(x)	(((x)&0x1f)<<15)
+#define v_IFBDC_CTRL_WIDTH_RATIO(x)		(((x)&0x1)<<20)
+#define v_IFBDC_FRAME_RST_EN(x)			(((x)&0x1)<<21)
+#define v_IFBDC_ICTRL_NOTIFY(x)			(((x)&0x1)<<22)
+#define v_IFBDC_INVALIDATE_PENDING_O(x)		(((x)&0x1)<<23)
+#define v_IFBDC_RID(x)				(((x)&0xf)<<24)
+#define v_IFBDC_RSTN(x)				(((x)&0x1)<<28)
+
+#define m_IFBDC_CTRL_FBDC_EN			(0x1<<0)
+#define m_IFBDC_CTRL_FBDC_COR_EN		(0x1<<1)
+#define m_IFBDC_CTRL_FBDC_WIN_SEL		(0x3<<2)
+#define m_IFBDC_CTRL_FBDC_ROTATION_MODE		(0x7<<4)
+#define m_IFBDC_CTRL_FBDC_FMT			(0x7f<<7)
+#define m_IFBDC_AXI_MAX_OUTSTANDING_EN		(0x1<<14)
+#define m_IFBDC_AXI_OUTSTANDING_MAX_NUM		(0x1f<<15)
+#define m_IFBDC_CTRL_WIDTH_RATIO		(0x1<<20)
+#define m_IFBDC_FRAME_RST_EN			(0x1<<21)
+#define m_IFBDC_ICTRL_NOTIFY			(0x1<<22)
+#define m_IFBDC_INVALIDATE_PENDING_O		(0x1<<23)
+#define m_IFBDC_RID				(0xf<<24)
+#define m_IFBDC_RSTN				(0x1<<28)
+
+#define IFBDC_TILES_NUM			(0x0204)
+#define v_IFBDC_TILES_NUM(x)			(((x-1)&0x7fffff)<<0)
+#define m_IFBDC_TILES_NUM			(0x7fffff<<0)
+
+#define IFBDC_FRAME_RST_CYCLE		(0x0208)
+#define v_IFBDC_FRAME_RST_CYCLE(x)		(((x)&0x3ff)<<0)
+#define v_DMA_IFBDC_FRAME_RST_CYCLE(x)		(((x)&0x3ff)<<16)
+#define m_IFBDC_FRAME_RST_CYCLE			((0x3ff)<<0)
+#define m_DMA_IFBDC_FRAME_RST_CYCLE		((0x3ff)<<16)
+
+
+
+#define IFBDC_BASE_ADDR			(0x20c)
+#define v_IFBDC_BASE_ADDR(x)			(((x)&0xffffffff)<<0)
+#define m_IFBDC_BASE_ADDR			((0xffffffff)<<0)
+
+#define IFBDC_MB_SIZE			(0x210)
+#define  v_IFBDC_MB_SIZE_WIDTH(x)		(((x-1)&0x7f)<<0)
+#define  v_IFBDC_MB_SIZE_HEIGHT(x)		(((x-1)&0x1ff)<<16)
+#define  m_IFBDC_MB_SIZE_WIDTH			((0x7f)<<0)
+#define  m_IFBDC_MB_SIZE_HEIGHT			((0x1ff)<<16)
+
+
+#define IFBDC_CMP_INDEX_INIT		(0x0214)
+#define v_IFBDC_CMP_INDEX_INIT(x)               (((x)&0x7fffff) << 0)
+#define m_IFBDC_CMP_INDEX_INIT                  (0x7fffff<<0)
+
+#define IFBDC_MB_VIR_WIDTH		(0x220)
+#define  v_IFBDC_MB_VIR_WIDTH(x)		(((x)&0xff)<<0)
+#define  m_IFBDC_MB_VIR_WIDTH			((0xff)<<0)
+
+#define IFBDC_DEBUG0			(0x230)
+#define v_DBG_IFBDC_MB_Y_WCNT(x)		(((x)&0x1ff)<<0)
+#define v_DBG_IFBDC_IDLE(x)			(((x)&0x1)<<12)
+#define v_DBG_IFBDC_LB_RCNT(x)			(((x)&0x7FF)<<16)
+#define v_DBG_IFBDC_INVALIDATE_PENDING_I(x)	(((x)&0x1)<<28)
+
+#define m_DBG_IFBDC_MB_Y_WCNT			(0x1ff<<0)
+#define m_DBG_IFBDC_IDLE			(0x1<<12)
+#define m_DBG_IFBDC_LB_RCNT			(0x7FF<<16)
+#define m_DBG_IFBDC_INVALIDATE_PENDING_I	(0x1<<28)
+
+#define IFBDC_DEBUG1			(0x234)
+#define V_DBG_FBDC_CMP_TILE_INDEX(x)		(((x)&0x7fffff)<<0)
+#define m_DBG_FBDC_CMP_TILE_INDEX		(0x7fffff<<0)
+
+#define LATENCY_CTRL0			(0x250)
+#define  v_RD_LATENCY_EN(x)			(((x)&0x1)<<0)
+#define  v_HAND_LATENCY_CLR(x)			(((x)&0x1)<<1)
+#define  v_RD_LATENCY_MODE(x)			(((x)&0x1)<<2)
+#define  v_RD_LATENCY_ID0(x)			(((x)&0xf)<<4)
+#define  v_RD_LATENCY_THR(x)			(((x)&0xfff)<<8)
+#define  v_RD_LATENCY_ST_NUM(x)			(((x)&0x1f)<<20)
+#define  m_RD_LATENCY_EN			(0x1<<0)
+#define  m_HAND_LATENCY_CLR			(0x1<<1)
+#define  m_RD_LATENCY_MODE			(0x1<<2)
+#define  m_RD_LATENCY_ID0			(0xf<<4)
+#define  m_RD_LATENCY_THR			(0xfff<<8)
+#define  m_RD_LATENCY_ST_NUM			(0x1f<<20)
+
+#define RD_MAX_LATENCY_NUM0		(0x254)
+#define v_RD_MAX_LATENCY_NUM_CH0(x)		(((x)&0xFFF)<<0)
+#define v_RD_LATENCY_OVERFLOW_CH0(x)		(((x)&0x1)<<16)
+#define m_RD_MAX_LATENCY_NUM_CH0		(0xFFF<<0)
+#define m_RD_LATENCY_OVERFLOW_CH0		(0x1<<16)
+
+#define RD_LATENCY_THR_NUM0		(0x258)
+#define v_RD_LATENCY_THR_NUM_CH0(x)		(((x)&0xFFFFFF)<<0)
+#define m_RD_LATENCY_THR_NUM_CH0		(0xFFFFFF<<0)
+
+#define RD_LATENCY_SWAP_NUM0		(0x25c)
+#define v_RD_LATENCY_SAMP_NUM_CH0(x)		(((x)&0xFFFFFF)<<0)
+#define m_RD_LATENCY_SAMP_NUM_CH0		(0xFFFFFF<<0)
+
+#define VOP_STATUS                      0x000002a4
+#define v_VOP_DSP_VCNT(x)			(((x)&0x1FFF)<<0)
+#define v_VOP_MMU_IDLE(x)			(((x)&0x1)<<16)
+#define v_DMA_STOP_VALID(x)			(((x)&0x1)<<17)
+#define m_VOP_DSP_VCNT				(0x1FFF<<0)
+#define m_VOP_MMU_IDLE				(0x1<<16)
+#define m_DMA_STOP_VALID			(0x1<<17)
+
+#define BLANKING_VALUE                  0x02a8
+#define v_BLANKING_VALUE(x)			(((x)&0xFFFFFF)<<0)
+#define v_BLANKING_VALUE_CONFIG_EN(x)		(((x)&0x1)<<24)
+#define m_BLANKING_VALUE			(0xFFFFFF<<0)
+#define m_BLANKING_VALUE_CONFIG_EN		(0x1<<24)
+
+#define WIN0_DSP_BG_RK3368		(0x260)
+#define WIN0_DSP_BG_RK3366		(0x2b0)/*rk3366*/
+#define v_WIN0_DSP_BG_BLUE(x)			(((x)&0xff)<<0)
+#define v_WIN0_DSP_BG_GREEN(x)			(((x)&0xff)<<8)
+#define v_WIN0_DSP_BG_RED(x)			(((x)&0xff)<<16)
+#define v_WIN0_DSP_BG_EN(x)			(((x)&1)<<31)
+#define m_WIN0_DSP_BG_BLUE			(0xff<<0)
+#define m_WIN0_DSP_BG_GREEN			(0xff<<8)
+#define m_WIN0_DSP_BG_RED			(0xff<<16)
+#define m_WIN0_DSP_BG_EN			(0x1<<31)
+
+#define WIN1_DSP_BG_RK3368		(0x264)
+#define WIN1_DSP_BG_RK3366		(0x2b4)/*rk3366*/
+#define v_WIN1_DSP_BG_BLUE(x)			(((x)&0xff)<<0)
+#define v_WIN1_DSP_BG_GREEN(x)			(((x)&0xff)<<8)
+#define v_WIN1_DSP_BG_RED(x)			(((x)&0xff)<<16)
+#define v_WIN1_DSP_BG_EN(x)			(((x)&1)<<31)
+#define m_WIN1_DSP_BG_BLUE			(0xff<<0)
+#define m_WIN1_DSP_BG_GREEN			(0xff<<8)
+#define m_WIN1_DSP_BG_RED			(0xff<<16)
+#define m_WIN1_DSP_BG_EN			(0x1<<31)
+
+#define WIN2_DSP_BG_RK3368		(0x268)
+#define WIN2_DSP_BG_RK3366		(0x2b8)/*rk3366*/
+#define v_WIN2_DSP_BG_BLUE(x)			(((x)&0xff)<<0)
+#define v_WIN2_DSP_BG_GREEN(x)			(((x)&0xff)<<8)
+#define v_WIN2_DSP_BG_RED(x)			(((x)&0xff)<<16)
+#define v_WIN2_DSP_BG_EN(x)			(((x)&1)<<31)
+#define m_WIN2_DSP_BG_BLUE			(0xff<<0)
+#define m_WIN2_DSP_BG_GREEN			(0xff<<8)
+#define m_WIN2_DSP_BG_RED			(0xff<<16)
+#define m_WIN2_DSP_BG_EN			(0x1<<31)
+
+#define WIN3_DSP_BG_RK3368		(0x26c)
+#define WIN3_DSP_BG_RK3366		(0x2bC)/*rk3366*/
+#define v_WIN3_DSP_BG_BLUE(x)			(((x)&0xff)<<0)
+#define v_WIN3_DSP_BG_GREEN(x)			(((x)&0xff)<<8)
+#define v_WIN3_DSP_BG_RED(x)			(((x)&0xff)<<16)
+#define v_WIN3_DSP_BG_EN(x)			(((x)&1)<<31)
+#define m_WIN3_DSP_BG_BLUE			(0xff<<0)
+#define m_WIN3_DSP_BG_GREEN			(0xff<<8)
+#define m_WIN3_DSP_BG_RED			(0xff<<16)
+#define m_WIN3_DSP_BG_EN			(0x1<<31)
+
+#define SCAN_LINE_NUM			(0x270)
+#define CABC_DEBUG0			(0x274)
+#define CABC_DEBUG1			(0x278)
+#define CABC_DEBUG2			(0x27c)
+#define DBG_REG_000			(0x280)
+#define DBG_REG_001			(0x284)
+#define DBG_REG_002			(0x288)
+#define DBG_REG_003			(0x28c)
+#define DBG_REG_004			(0x290)
+#define DBG_REG_005			(0x294)
+#define DBG_REG_006			(0x298)
+#define DBG_REG_007			(0x29c)
+#define DBG_REG_008			(0x2a0)
+#define DBG_REG_016			(0x2c0)
+#define DBG_REG_017			(0x2c4)
+#define DBG_REG_018			(0x2c8)
+#define DBG_REG_019			(0x2cc)
+#define DBG_REG_020			(0x2d0)
+#define DBG_REG_021			(0x2d4)
+#define DBG_REG_022			(0x2d8)
+#define DBG_REG_023			(0x2dc)
+#define DBG_REG_028			(0x2f0)
+
+#define MMU_DTE_ADDR			(0x0300)
+#define v_MMU_DTE_ADDR(x)			(((x)&0xffffffff)<<0)
+#define m_MMU_DTE_ADDR				(0xffffffff<<0)
+
+#define MMU_STATUS			(0x0304)
+#define v_PAGING_ENABLED(x)			(((x)&1)<<0)
+#define v_PAGE_FAULT_ACTIVE(x)			(((x)&1)<<1)
+#define v_STAIL_ACTIVE(x)			(((x)&1)<<2)
+#define v_MMU_IDLE(x)				(((x)&1)<<3)
+#define v_REPLAY_BUFFER_EMPTY(x)		(((x)&1)<<4)
+#define v_PAGE_FAULT_IS_WRITE(x)		(((x)&1)<<5)
+#define v_PAGE_FAULT_BUS_ID(x)			(((x)&0x1f)<<6)
+#define m_PAGING_ENABLED			(1<<0)
+#define m_PAGE_FAULT_ACTIVE			(1<<1)
+#define m_STAIL_ACTIVE				(1<<2)
+#define m_MMU_IDLE				(1<<3)
+#define m_REPLAY_BUFFER_EMPTY			(1<<4)
+#define m_PAGE_FAULT_IS_WRITE			(1<<5)
+#define m_PAGE_FAULT_BUS_ID			(0x1f<<6)
+
+#define MMU_COMMAND			(0x0308)
+#define v_MMU_CMD(x)				(((x)&0x3)<<0)
+#define m_MMU_CMD			(0x3<<0)
+
+#define MMU_PAGE_FAULT_ADDR		(0x030c)
+#define v_PAGE_FAULT_ADDR(x)			(((x)&0xffffffff)<<0)
+#define m_PAGE_FAULT_ADDR			(0xffffffff<<0)
+
+#define MMU_ZAP_ONE_LINE		(0x0310)
+#define v_MMU_ZAP_ONE_LINE(x)			(((x)&0xffffffff)<<0)
+#define m_MMU_ZAP_ONE_LINE			(0xffffffff<<0)
+
+#define MMU_INT_RAWSTAT			(0x0314)
+#define v_PAGE_FAULT_RAWSTAT(x)			(((x)&1)<<0)
+#define v_READ_BUS_ERROR_RAWSTAT(x)		(((x)&1)<<1)
+#define m_PAGE_FAULT_RAWSTAT			(1<<0)
+#define m_READ_BUS_ERROR_RAWSTAT		(1<<1)
+
+#define MMU_INT_CLEAR			(0x0318)
+#define v_PAGE_FAULT_CLEAR(x)			(((x)&1)<<0)
+#define v_READ_BUS_ERROR_CLEAR(x)		(((x)&1)<<1)
+#define m_PAGE_FAULT_CLEAR			(1<<0)
+#define m_READ_BUS_ERROR_CLEAR			(1<<1)
+
+#define MMU_INT_MASK			(0x031c)
+#define v_PAGE_FAULT_MASK(x)			(((x)&1)<<0)
+#define v_READ_BUS_ERROR_MASK(x)		(((x)&1)<<1)
+#define m_PAGE_FAULT_MASK			(1<<0)
+#define m_READ_BUS_ERROR_MASK			(1<<1)
+
+#define MMU_INT_STATUS			(0x0320)
+#define v_PAGE_FAULT_STATUS(x)			(((x)&1)<<0)
+#define v_READ_BUS_ERROR_STATUS(x)		(((x)&1)<<1)
+#define m_PAGE_FAULT_STATUS			(1<<0)
+#define m_READ_BUS_ERROR_STATUS			(1<<1)
+
+#define MMU_AUTO_GATING			(0x0324)
+#define v_MMU_AUTO_GATING(x)			(((x)&1)<<0)
+#define m_MMU_AUTO_GATING			(1<<0)
+
+#define WIN2_LUT_ADDR			(0x0400)
+#define WIN3_LUT_ADDR			(0x0800)
+#define HWC_LUT_ADDR			(0x0c00)
+#define GAMMA_LUT_ADDR			(0x1000)
+#define CABC_GAMMA_LUT_ADDR		(0x1800)
+#define MCU_BYPASS_WPORT		(0x2200)
+#define MCU_BYPASS_RPORT		(0x2300)
+
+#define PMUGRF_SOC_CON0_VOP		(0x0100)
+
+#define RK3366_GRF_SOC_CON0		(0x0400)
+#define RK3366_GRF_SOC_CON5		(0x0414)
+
+#define OUT_CCIR656_MODE_0              5
+#define OUT_CCIR656_MODE_1              6
+#define OUT_CCIR656_MODE_2              7
+
+#define VOP_SOURCE_SEL(id, shift)	((id << shift) | 1 << (shift + 16))
+#define RGB_SOURCE_SEL(id)		VOP_SOURCE_SEL(id, 3)
+#define LVDS_SOURCE_SEL(id)		VOP_SOURCE_SEL(id, 0)
+#define MIPI_SOURCE_SEL(id)		VOP_SOURCE_SEL(id, 2)
+#define HDMI_SOURCE_SEL(id)		VOP_SOURCE_SEL(id, 1)
+
+#define RGB_DATA_PLANA			((2 << 6) | (3 << (6 + 16)))
+#define RGB_DATA_PLANB			((3 << 6) | (3 << (6 + 16)))
+
+#define RK3366_GRF_IO_VSEL		0x0900
+#define RK3366_GRF_VOP_IOVOL_SEL(x)	(((x) << 0) | (1 << (0 + 16)))
+#define RK3368_GRF_VOP_IOVOL_SEL(x)	(((x) << 5) | (1 << (5 + 16)))
+
+#define RK3366_WB_ALIGN			16
+
+enum lb_mode {
+	LB_YUV_3840X5 = 0x0,
+	LB_YUV_2560X8 = 0x1,
+	LB_RGB_3840X2 = 0x2,
+	LB_RGB_2560X4 = 0x3,
+	LB_RGB_1920X5 = 0x4,
+	LB_RGB_1280X8 = 0x5
+};
+
+enum sacle_up_mode {
+	SCALE_UP_BIL = 0x0,
+	SCALE_UP_BIC = 0x1
+};
+
+enum scale_down_mode {
+	SCALE_DOWN_BIL = 0x0,
+	SCALE_DOWN_AVG = 0x1
+};
+
+/*ALPHA BLENDING MODE*/
+enum alpha_mode {               /*  Fs       Fd */
+	AB_USER_DEFINE     = 0x0,
+	AB_CLEAR	   = 0x1,/*  0          0*/
+	AB_SRC		   = 0x2,/*  1          0*/
+	AB_DST		   = 0x3,/*  0          1  */
+	AB_SRC_OVER	   = 0x4,/*  1		    1-As''*/
+	AB_DST_OVER	   = 0x5,/*  1-Ad''   1*/
+	AB_SRC_IN	   = 0x6,
+	AB_DST_IN	   = 0x7,
+	AB_SRC_OUT	   = 0x8,
+	AB_DST_OUT	   = 0x9,
+	AB_SRC_ATOP        = 0xa,
+	AB_DST_ATOP	   = 0xb,
+	XOR                = 0xc,
+	AB_SRC_OVER_GLOBAL = 0xd
+}; /*alpha_blending_mode*/
+
+enum src_alpha_mode {
+	AA_STRAIGHT	   = 0x0,
+	AA_INVERSE         = 0x1
+};/*src_alpha_mode*/
+
+enum global_alpha_mode {
+	AA_GLOBAL	  = 0x0,
+	AA_PER_PIX        = 0x1,
+	AA_PER_PIX_GLOBAL = 0x2
+};/*src_global_alpha_mode*/
+
+enum src_alpha_sel {
+	AA_SAT		= 0x0,
+	AA_NO_SAT	= 0x1
+};/*src_alpha_sel*/
+
+enum src_color_mode {
+	AA_SRC_PRE_MUL	       = 0x0,
+	AA_SRC_NO_PRE_MUL      = 0x1
+};/*src_color_mode*/
+
+enum factor_mode {
+	AA_ZERO			= 0x0,
+	AA_ONE			= 0x1,
+	AA_SRC			= 0x2,
+	AA_SRC_INVERSE          = 0x3,
+	AA_SRC_GLOBAL           = 0x4
+};/*src_factor_mode  &&  dst_factor_mode*/
+
+enum _vop_r2y_csc_mode {
+	VOP_R2Y_CSC_BT601 = 0,
+	VOP_R2Y_CSC_BT709
+};
+
+enum _vop_y2r_csc_mode {
+	VOP_Y2R_CSC_MPEG = 0,
+	VOP_Y2R_CSC_JPEG,
+	VOP_Y2R_CSC_HD,
+	VOP_Y2R_CSC_BYPASS
+};
+enum _vop_format {
+	VOP_FORMAT_ARGB888 = 0,
+	VOP_FORMAT_RGB888,
+	VOP_FORMAT_RGB565,
+	VOP_FORMAT_YCBCR420 = 4,
+	VOP_FORMAT_YCBCR422,
+	VOP_FORMAT_YCBCR444
+};
+
+enum _vop_overlay_mode {
+	VOP_RGB_DOMAIN,
+	VOP_YUV_DOMAIN
+};
+
+enum cabc_stage_mode {
+	LAST_FRAME_PWM_VAL	= 0x0,
+	CUR_FRAME_PWM_VAL	= 0x1,
+	STAGE_BY_STAGE		= 0x2
+};
+
+struct lcdc_device {
+	int id;
+	u32 soc_type;
+	struct rk_lcdc_driver driver;
+	struct device *dev;
+	struct rk_screen *screen;
+
+	void __iomem *regs;
+	void *regsbak;		/*back up reg*/
+	u32 reg_phy_base;	/* physical basic address of lcdc register*/
+	struct regmap *grf_base;
+	struct regmap *pmugrf_base;
+	struct regmap *cru_base;
+	u32 len;		/* physical map length of lcdc register*/
+	/*one time only one process allowed to config the register*/
+	spinlock_t reg_lock;
+
+	int __iomem *dsp_lut_addr_base;
+	int __iomem *cabc_lut_addr_base;
+
+
+	int prop;		/*used for primary or extended display device*/
+	bool pre_init;
+	bool pwr18;		/*if lcdc use 1.8v power supply*/
+	/*if aclk or hclk is closed ,acess to register is not allowed*/
+	bool clk_on;
+	/*active layer counter,when  atv_layer_cnt = 0,disable lcdc*/
+	u8 atv_layer_cnt;
+
+
+	unsigned int		irq;
+
+	struct clk		*pd;		/*lcdc power domain*/
+	struct clk		*hclk;		/*lcdc AHP clk*/
+	struct clk		*dclk;		/*lcdc dclk*/
+	struct clk		*aclk;		/*lcdc share memory frequency*/
+	u32 pixclock;
+
+	u32 standby;				/*1:standby,0:wrok*/
+	u32 iommu_status;
+	struct backlight_device *backlight;
+	struct clk		*pll_sclk;
+};
+
+struct alpha_config {
+	enum src_alpha_mode src_alpha_mode;       /*win0_src_alpha_m0*/
+	u32 src_global_alpha_val; /*win0_src_global_alpha*/
+	enum global_alpha_mode src_global_alpha_mode;/*win0_src_blend_m0*/
+	enum src_alpha_sel src_alpha_cal_m0;	 /*win0_src_alpha_cal_m0*/
+	enum src_color_mode src_color_mode;	 /*win0_src_color_m0*/
+	enum factor_mode src_factor_mode;	 /*win0_src_factor_m0*/
+	enum factor_mode dst_factor_mode;      /*win0_dst_factor_m0*/
+};
+
+struct lcdc_cabc_mode {
+	u32 pixel_num;			/* pixel precent number */
+	u16 stage_up;			/* up stride */
+	u16 stage_down;		/* down stride */
+	u16 global_su;
+};
+
+static inline void lcdc_writel(struct lcdc_device *lcdc_dev, u32 offset, u32 v)
+{
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	*_pv = v;
+	writel_relaxed(v, lcdc_dev->regs + offset);
+}
+
+static inline u32 lcdc_readl(struct lcdc_device *lcdc_dev, u32 offset)
+{
+	u32 v;
+
+	v = readl_relaxed(lcdc_dev->regs + offset);
+	return v;
+}
+
+static inline u32 lcdc_readl_backup(struct lcdc_device *lcdc_dev, u32 offset)
+{
+	u32 v;
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	v = readl_relaxed(lcdc_dev->regs + offset);
+	*_pv = v;
+	return v;
+}
+
+static inline u32 lcdc_read_bit(struct lcdc_device *lcdc_dev,
+				u32 offset, u32 msk)
+{
+	u32 v;
+	u32 _v = readl_relaxed(lcdc_dev->regs + offset);
+
+	_v &= msk;
+	v = (_v ? 1 : 0);
+	return v;
+}
+
+static inline void  lcdc_set_bit(struct lcdc_device *lcdc_dev,
+				 u32 offset, u32 msk)
+{
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) |= msk;
+	writel_relaxed(*_pv, lcdc_dev->regs + offset);
+}
+
+static inline void lcdc_clr_bit(struct lcdc_device *lcdc_dev,
+				u32 offset, u32 msk)
+{
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) &= (~msk);
+	writel_relaxed(*_pv, lcdc_dev->regs + offset);
+}
+
+static inline void  lcdc_msk_reg(struct lcdc_device *lcdc_dev,
+				 u32 offset, u32 msk, u32 v)
+{
+	u32 *_pv = (u32 *)lcdc_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) &= (~msk);
+	(*_pv) |= v;
+	writel_relaxed(*_pv, lcdc_dev->regs + offset);
+        if (((lcdc_dev->soc_type == VOP_FULL_RK3366) && (offset == INTR_CLEAR_RK3366)) ||
+	    ((lcdc_dev->soc_type == VOP_FULL_RK3368) && (offset == INTR_CLEAR_RK3368)))
+                (*_pv) &= 0;
+}
+
+static inline void lcdc_cfg_done(struct lcdc_device *lcdc_dev)
+{
+	writel_relaxed(0x01, lcdc_dev->regs + REG_CFG_DONE);
+	dsb(sy);
+}
+
+static inline int lcdc_grf_writel(struct regmap *base,
+				  u32 offset, u32 val)
+{
+	if (base)
+		regmap_write(base, offset, val);
+	dsb(sy);
+
+	return 0;
+}
+
+static inline int lcdc_cru_writel(struct regmap *base,
+				  u32 offset, u32 val)
+{
+	if (base)
+		regmap_write(base, offset, val);
+	dsb(sy);
+
+	return 0;
+}
+
+static inline int lcdc_cru_readl(struct regmap *base,
+				  u32 offset)
+{
+	u32 v;
+	regmap_read(base, offset, &v);
+
+	return v;
+}
+
+#define CUBIC_PRECISE  0
+#define CUBIC_SPLINE   1
+#define CUBIC_CATROM   2
+#define CUBIC_MITCHELL 3
+
+#define FBDC_FMT_RGB565		0x5
+#define FBDC_FMT_U8U8U8U8	0xc /*ARGB888*/
+#define FBDC_FMT_U8U8U8		0x3a /*RGBP888*/
+
+#define CUBIC_MODE_SELETION      CUBIC_PRECISE
+
+/*************************************************************/
+#define SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT   12   /* 4.12*/
+#define SCALE_FACTOR_BILI_DN_FIXPOINT(x)      \
+	((INT32)((x) * (1 << SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT   16   /* 0.16*/
+
+#define SCALE_FACTOR_AVRG_FIXPOINT_SHIFT   16   /*0.16*/
+#define SCALE_FACTOR_AVRG_FIXPOINT(x)      \
+	((INT32)((x) * (1 << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_BIC_FIXPOINT_SHIFT    16   /* 0.16*/
+#define SCALE_FACTOR_BIC_FIXPOINT(x)       \
+	((INT32)((x) * (1 << SCALE_FACTOR_BIC_FIXPOINT_SHIFT)))
+
+#define SCALE_FACTOR_DEFAULT_FIXPOINT_SHIFT    12  /*NONE SCALE,vsd_bil*/
+#define SCALE_FACTOR_VSDBIL_FIXPOINT_SHIFT     12  /*VER SCALE DOWN BIL*/
+
+/*********************************************************/
+
+/*#define GET_SCALE_FACTOR_BILI(src, dst)  \
+	((((src) - 1) << SCALE_FACTOR_BILI_FIXPOINT_SHIFT) / ((dst) - 1))*/
+/*#define GET_SCALE_FACTOR_BIC(src, dst)   \
+	((((src) - 1) << SCALE_FACTOR_BIC_FIXPOINT_SHIFT) / ((dst) - 1))*/
+/*modified by hpz*/
+#define GET_SCALE_FACTOR_BILI_DN(src, dst)  \
+	((((src) * 2 - 3) << (SCALE_FACTOR_BILI_DN_FIXPOINT_SHIFT - 1)) \
+	/ ((dst) - 1))
+#define GET_SCALE_FACTOR_BILI_UP(src, dst)  \
+	((((src) * 2 - 3) << (SCALE_FACTOR_BILI_UP_FIXPOINT_SHIFT - 1)) \
+	/ ((dst) - 1))
+#define GET_SCALE_FACTOR_BIC(src, dst)      \
+	((((src) * 2 - 3) << (SCALE_FACTOR_BIC_FIXPOINT_SHIFT - 1)) \
+	/ ((dst) - 1))
+
+/*********************************************************/
+/*NOTE: hardware in order to save resource , srch first to get interlace line
+(srch+vscalednmult-1)/vscalednmult; and do scale*/
+#define GET_SCALE_DN_ACT_HEIGHT(srch, vscalednmult) \
+	(((srch) + (vscalednmult) - 1) / (vscalednmult))
+
+/*#define VSKIP_MORE_PRECISE*/
+
+#ifdef VSKIP_MORE_PRECISE
+#define MIN_SCALE_FACTOR_AFTER_VSKIP        1.5f
+#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
+	(GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
+	(vscalednmult)), (dsth)))
+#else
+#define MIN_SCALE_FACTOR_AFTER_VSKIP        1
+#if 0/*rk3288*/
+#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
+	((GET_SCALE_DN_ACT_HEIGHT((srch), (vscalednmult)) == (dsth))\
+		? (GET_SCALE_FACTOR_BILI_DN((srch),\
+		(dsth))/(vscalednmult))\
+		: GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
+		(vscalednmult)), (dsth)))
+#else/*rk3368*/
+#define GET_SCALE_FACTOR_BILI_DN_VSKIP(srch, dsth, vscalednmult) \
+	((GET_SCALE_DN_ACT_HEIGHT((srch) , (vscalednmult)) == (dsth)) \
+	? (GET_SCALE_FACTOR_BILI_DN((srch) , (dsth)) / (vscalednmult)) \
+	: (GET_SCALE_DN_ACT_HEIGHT((srch) , (vscalednmult)) == ((dsth) * 2)) \
+	?  GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT(((srch) - 1),\
+	(vscalednmult)) , (dsth)) : \
+	GET_SCALE_FACTOR_BILI_DN(GET_SCALE_DN_ACT_HEIGHT((srch),\
+	(vscalednmult)) , (dsth)))
+#endif
+
+
+#endif
+/*****************************************************************/
+
+
+/*scalefactor must >= dst/src, or pixels at end of line may be unused*/
+/*scalefactor must < dst/(src-1), or dst buffer may overflow*/
+/*avrg old code: ((((dst) << SCALE_FACTOR_AVRG_FIXPOINT_SHIFT))\
+	/((src) - 1)) hxx_chgsrc*/
+/*modified by hpz:*/
+#define GET_SCALE_FACTOR_AVRG(src, dst)  ((((dst) << \
+	(SCALE_FACTOR_AVRG_FIXPOINT_SHIFT + 1))) / (2 * (src) - 1))
+
+/*************************************************************************/
+/*Scale Coordinate Accumulate, x.16*/
+#define SCALE_COOR_ACC_FIXPOINT_SHIFT     16
+#define SCALE_COOR_ACC_FIXPOINT_ONE (1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)
+#define SCALE_COOR_ACC_FIXPOINT(x) \
+	((INT32)((x)*(1 << SCALE_COOR_ACC_FIXPOINT_SHIFT)))
+#define SCALE_COOR_ACC_FIXPOINT_REVERT(x) \
+	((((x) >> (SCALE_COOR_ACC_FIXPOINT_SHIFT - 1)) + 1) >> 1)
+
+#define SCALE_GET_COOR_ACC_FIXPOINT(scalefactor, factorfixpointshift)  \
+	((scalefactor) << \
+	(SCALE_COOR_ACC_FIXPOINT_SHIFT - (factorfixpointshift)))
+
+
+/************************************************************************/
+/*CoarsePart of Scale Coordinate Accumulate, used for pixel mult-add factor, 0.8*/
+#define SCALE_FILTER_FACTOR_FIXPOINT_SHIFT     8
+#define SCALE_FILTER_FACTOR_FIXPOINT_ONE       \
+	(1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)
+#define SCALE_FILTER_FACTOR_FIXPOINT(x)        \
+	((INT32)((x) * (1 << SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)))
+#define SCALE_FILTER_FACTOR_FIXPOINT_REVERT(x) \
+	((((x) >> (SCALE_FILTER_FACTOR_FIXPOINT_SHIFT-1)) + 1) >> 1)
+
+#define SCALE_GET_FILTER_FACTOR_FIXPOINT(cooraccumulate, \
+	cooraccfixpointshift) \
+	(((cooraccumulate) >> \
+	((cooraccfixpointshift) - SCALE_FILTER_FACTOR_FIXPOINT_SHIFT)) & \
+	(SCALE_FILTER_FACTOR_FIXPOINT_ONE - 1))
+
+#define SCALE_OFFSET_FIXPOINT_SHIFT            8
+#define SCALE_OFFSET_FIXPOINT(x)              \
+	((INT32)((x) * (1 << SCALE_OFFSET_FIXPOINT_SHIFT)))
+
+
+extern void rk_pwm_set(int bl_pwm_period, int bl_pwm_duty);
+extern void rk_pwm_get(int *bl_pwm_period, int *bl_pwm_duty);
+#endif
diff -Nupr a/drivers/video/rockchip/lcdc/rk_vop_lite.c b/drivers/video/rockchip/lcdc/rk_vop_lite.c
--- a/drivers/video/rockchip/lcdc/rk_vop_lite.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk_vop_lite.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2643 @@
+/*
+ * rockchip VOP(Video Output Processer) hardware driver.
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd.
+ * Author: WenLong Zhuang <daisen.zhuang@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
+#include <linux/rockchip-iovmm.h>
+#include <asm/div64.h>
+#include <linux/uaccess.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/grf.h>
+#include <dt-bindings/clock/rk_system_status.h>
+
+#include "rk_vop_lite.h"
+
+static int dbg_thresd;
+module_param(dbg_thresd, int, S_IRUGO | S_IWUSR);
+
+#define DBG(level, x...) do {			\
+	if (unlikely(dbg_thresd >= level))	\
+		pr_info(x);\
+	} while (0)
+
+#define to_vop_dev(drv) container_of(drv, struct vop_device, driver)
+
+static struct rk_lcdc_win vop_win[] = {
+	{ .name = "win0", .id = 0},
+	{ .name = "win1", .id = 1},
+	{ .name = "hwc",  .id = 2}
+};
+
+static int vop_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable);
+
+static int vop_clk_enable(struct vop_device *vop_dev)
+{
+	if (!vop_dev->clk_on) {
+		pm_runtime_get_sync(vop_dev->dev);
+
+		clk_enable(vop_dev->hclk);
+		clk_enable(vop_dev->aclk);
+		clk_enable(vop_dev->dclk);
+		spin_lock(&vop_dev->reg_lock);
+		vop_dev->clk_on = 1;
+		spin_unlock(&vop_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int vop_clk_disable(struct vop_device *vop_dev)
+{
+	if (vop_dev->clk_on) {
+		spin_lock(&vop_dev->reg_lock);
+		vop_dev->clk_on = 0;
+		spin_unlock(&vop_dev->reg_lock);
+		clk_disable(vop_dev->dclk);
+		clk_disable(vop_dev->aclk);
+		clk_disable(vop_dev->hclk);
+
+		pm_runtime_put(vop_dev->dev);
+	}
+
+	return 0;
+}
+
+static int vop_irq_enable(struct vop_device *vop_dev)
+{
+	u64 val;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_mask_writel(vop_dev, INTR_CLEAR, INTR_MASK, INTR_MASK);
+
+		val = INTR_FS0 | INTR_FS1 | INTR_LINE_FLAG0 | INTR_LINE_FLAG1 |
+			INTR_BUS_ERROR | INTR_WIN0_EMPTY | INTR_WIN1_EMPTY |
+			INTR_DSP_HOLD_VALID;
+		vop_mask_writel(vop_dev, INTR_EN, INTR_MASK, val);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_irq_disable(struct vop_device *vop_dev)
+{
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_writel(vop_dev, INTR_EN, 0xffff0000);
+		vop_writel(vop_dev, INTR_CLEAR, 0xffffffff);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_standby_enable(struct vop_device *vop_dev)
+{
+	u64 val;
+	int ret;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_dev->sync.stdbyfin.done = 0;
+
+		vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_BLANK_EN(1));
+		/*vop_mask_writel(vop_dev, INTR_CLEAR0, INTR_MASK, INTR_MASK);*/
+		val = V_IMD_VOP_STANDBY_EN(1) | V_IMD_VOP_DMA_STOP(1) |
+			V_IMD_DSP_OUT_ZERO(1);
+		vop_msk_reg(vop_dev, SYS_CTRL2, val);
+		vop_cfg_done(vop_dev);
+		spin_unlock(&vop_dev->reg_lock);
+
+		/* wait for standby hold valid */
+		ret = vop_completion_timeout_ms(&vop_dev->sync.stdbyfin,
+						vop_dev->sync.stdbyfin_to);
+		if (!ret) {
+			dev_err(vop_dev->dev,
+				"wait standby hold valid timeout %dms\n",
+				vop_dev->sync.stdbyfin_to);
+			return -ETIMEDOUT;
+		}
+	} else {
+		spin_unlock(&vop_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int vop_standby_disable(struct vop_device *vop_dev)
+{
+	u64 val;
+	int ret;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_dev->sync.frmst.done = 0;
+		val = V_IMD_VOP_STANDBY_EN(0) | V_IMD_VOP_DMA_STOP(0) |
+			V_IMD_DSP_OUT_ZERO(0);
+		vop_msk_reg(vop_dev, SYS_CTRL2, val);
+		vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_BLANK_EN(0));
+		vop_cfg_done(vop_dev);
+		spin_unlock(&vop_dev->reg_lock);
+
+		/* win address maybe effect after next frame start,
+		 * but mmu maybe effect right now, so need wait frame start
+		 */
+		ret = vop_completion_timeout_ms(&vop_dev->sync.frmst,
+						vop_dev->sync.frmst_to);
+		if (!ret) {
+			dev_err(vop_dev->dev, "wait frame start timeout %dms\n",
+				vop_dev->sync.frmst_to);
+			return -ETIMEDOUT;
+		}
+	} else {
+		spin_unlock(&vop_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static int vop_mmu_enable(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (!dev_drv->iommu_enabled || !dev_drv->mmu_dev) {
+		pr_debug("%s: VOP iommu is disabled or not find mmu dev\n",
+			 __func__);
+		return -ENODEV;
+	}
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		if (!vop_dev->iommu_status) {
+			vop_dev->iommu_status = 1;
+			rockchip_iovmm_activate(dev_drv->dev);
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_mmu_disable(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (!dev_drv->iommu_enabled || !dev_drv->mmu_dev) {
+		pr_debug("%s: VOP iommu is disabled or not find mmu dev\n",
+			 __func__);
+		return -ENODEV;
+	}
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		if (vop_dev->iommu_status) {
+			vop_dev->iommu_status = 0;
+			rockchip_iovmm_deactivate(dev_drv->dev);
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_reg_dump(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	int *cbase = (int *)vop_dev->regs;
+	int *regsbak = (int *)vop_dev->regsbak;
+	int i, j, val;
+	char dbg_message[30];
+	char buf[10];
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		pr_info("vop back up reg:\n");
+		memset(dbg_message, 0, sizeof(dbg_message));
+		memset(buf, 0, sizeof(buf));
+		for (i = 0; i <= (0x200 >> 4); i++) {
+			val = sprintf(dbg_message, "0x%04x: ", i * 16);
+			for (j = 0; j < 4; j++) {
+				val = sprintf(buf, "%08x  ",
+					      *(regsbak + i * 4 + j));
+				strcat(dbg_message, buf);
+			}
+			pr_info("%s\n", dbg_message);
+			memset(dbg_message, 0, sizeof(dbg_message));
+			memset(buf, 0, sizeof(buf));
+		}
+
+		pr_info("vop reg:\n");
+		for (i = 0; i <= (0x200 >> 4); i++) {
+			val = sprintf(dbg_message, "0x%04x: ", i * 16);
+			for (j = 0; j < 4; j++) {
+				sprintf(buf, "%08x  ",
+					readl_relaxed(cbase + i * 4 + j));
+				strcat(dbg_message, buf);
+			}
+			pr_info("%s\n", dbg_message);
+			memset(dbg_message, 0, sizeof(dbg_message));
+			memset(buf, 0, sizeof(buf));
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+#define WIN_EN(id)		\
+static int win##id##_enable(struct vop_device *vop_dev, int en)	\
+{ \
+	spin_lock(&vop_dev->reg_lock);					\
+	vop_msk_reg(vop_dev, WIN##id##_CTRL0, V_WIN##id##_EN((u64)en));	\
+	vop_cfg_done(vop_dev);						\
+	spin_unlock(&vop_dev->reg_lock);				\
+	return 0;							\
+}
+
+WIN_EN(0);
+WIN_EN(1);
+
+/*
+ * enable/disable win directly
+ */
+static int vop_win_direct_en(struct rk_lcdc_driver *drv,
+			     int win_id, int en)
+{
+	struct vop_device *vop_dev = to_vop_dev(drv);
+
+	if (win_id == 0)
+		win0_enable(vop_dev, en);
+	else if (win_id == 1)
+		win1_enable(vop_dev, en);
+	else
+		dev_err(vop_dev->dev, "invalid win number:%d\n", win_id);
+	return 0;
+}
+
+#define SET_WIN_ADDR(id) \
+static int set_win##id##_addr(struct vop_device *vop_dev, u32 addr) \
+{							\
+	spin_lock(&vop_dev->reg_lock);			\
+	vop_writel(vop_dev, WIN##id##_YRGB_MST, addr);	\
+	vop_msk_reg(vop_dev, WIN##id##_CTRL0, V_WIN##id##_EN(1));	\
+	vop_cfg_done(vop_dev);			\
+	spin_unlock(&vop_dev->reg_lock);		\
+	return 0;					\
+}
+
+SET_WIN_ADDR(0);
+SET_WIN_ADDR(1);
+
+static int vop_direct_set_win_addr(struct rk_lcdc_driver *dev_drv,
+				   int win_id, u32 addr)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (win_id == 0)
+		set_win0_addr(vop_dev, addr);
+	else
+		set_win1_addr(vop_dev, addr);
+
+	return 0;
+}
+
+static void vop_read_reg_default_cfg(struct vop_device *vop_dev)
+{
+	int reg = 0;
+	u32 val = 0;
+	struct rk_screen *screen = vop_dev->driver.cur_screen;
+	u32 h_pw_bp = screen->mode.hsync_len + screen->mode.left_margin;
+	u32 V_pw_bp = screen->mode.vsync_len + screen->mode.upper_margin;
+	u32 st_x, st_y;
+	struct rk_lcdc_win *win0 = vop_dev->driver.win[0];
+
+	spin_lock(&vop_dev->reg_lock);
+	for (reg = 0; reg < vop_dev->len; reg += 4) {
+		val = vop_readl_backup(vop_dev, reg);
+		switch (reg) {
+		case WIN0_ACT_INFO:
+			win0->area[0].xact = (val & MASK(WIN0_ACT_WIDTH)) + 1;
+			win0->area[0].yact =
+				((val & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
+			break;
+		case WIN0_DSP_INFO:
+			win0->area[0].xsize = (val & MASK(WIN0_DSP_WIDTH)) + 1;
+			win0->area[0].ysize =
+			    ((val & MASK(WIN0_DSP_HEIGHT)) >> 16) + 1;
+			break;
+		case WIN0_DSP_ST:
+			st_x = val & MASK(WIN0_DSP_XST);
+			st_y = (val & MASK(WIN0_DSP_YST)) >> 16;
+			win0->area[0].xpos = st_x - h_pw_bp;
+			win0->area[0].ypos = st_y - V_pw_bp;
+			break;
+		case WIN0_CTRL0:
+			win0->state = val & MASK(WIN0_EN);
+			win0->area[0].fmt_cfg =
+					(val & MASK(WIN0_DATA_FMT)) >> 1;
+			win0->area[0].format = win0->area[0].fmt_cfg;
+			break;
+		case WIN0_VIR:
+			win0->area[0].y_vir_stride =
+					val & MASK(WIN0_YRGB_VIR_STRIDE);
+			win0->area[0].uv_vir_stride =
+			    (val & MASK(WIN0_CBR_VIR_STRIDE)) >> 16;
+			if (win0->area[0].format == ARGB888)
+				win0->area[0].xvir = win0->area[0].y_vir_stride;
+			else if (win0->area[0].format == RGB888)
+				win0->area[0].xvir =
+				    win0->area[0].y_vir_stride * 4 / 3;
+			else if ((win0->area[0].format == RGB565) ||
+				 (win0->area[0].format == BGR565))
+				win0->area[0].xvir =
+				    2 * win0->area[0].y_vir_stride;
+			else
+				win0->area[0].xvir =
+				    4 * win0->area[0].y_vir_stride;
+			break;
+		case WIN0_YRGB_MST:
+			win0->area[0].smem_start = val;
+			break;
+		case WIN0_CBR_MST:
+			win0->area[0].cbr_start = val;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+}
+
+static int vop_pre_init(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (vop_dev->pre_init)
+		return 0;
+
+	if (dev_drv->iommu_enabled) {
+		dev_drv->mmu_dev = rk_fb_get_sysmmu_device_by_compatible(
+							dev_drv->mmu_dts_name);
+		if (dev_drv->mmu_dev)
+			rk_fb_platform_set_sysmmu(
+				dev_drv->mmu_dev, dev_drv->dev);
+		else
+			dev_err(dev_drv->dev, "fail get rk iommu device\n");
+	}
+
+	if (!support_uboot_display())
+		rk_disp_pwr_enable(dev_drv);
+
+	vop_clk_enable(vop_dev);
+
+	/* backup reg config at uboot */
+	vop_read_reg_default_cfg(vop_dev);
+
+	/* vop io voltage select-->0: 3.3v; 1: 1.8v */
+	if (vop_dev->pwr18 == 1)
+		vop_grf_writel(vop_dev->grf_base, GRF_IO_VSEL,
+			       V_VOP_IOVOL_SEL(1));
+	else
+		vop_grf_writel(vop_dev->grf_base, GRF_IO_VSEL,
+			       V_VOP_IOVOL_SEL(0));
+
+	vop_msk_reg(vop_dev, SYS_CTRL1, V_SW_AXI_MAX_OUTSTAND_EN(1) |
+		    V_SW_AXI_MAX_OUTSTAND_NUM(31));
+	vop_msk_reg(vop_dev, SYS_CTRL2, V_IMD_AUTO_GATING_EN(0));
+	vop_cfg_done(vop_dev);
+	vop_dev->pre_init = true;
+
+	return 0;
+}
+
+static void vop_deinit(struct vop_device *vop_dev)
+{
+	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
+
+	vop_standby_enable(vop_dev);
+	vop_irq_disable(vop_dev);
+	vop_mmu_disable(dev_drv);
+	vop_clk_disable(vop_dev);
+	clk_unprepare(vop_dev->dclk);
+	clk_unprepare(vop_dev->aclk);
+	clk_unprepare(vop_dev->hclk);
+	pm_runtime_disable(vop_dev->dev);
+}
+
+static void __maybe_unused
+vop_win_csc_mode(struct vop_device *vop_dev, struct rk_lcdc_win *win,
+		 int csc_mode)
+{
+	u64 val;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		if (win->id == 0) {
+			val = V_WIN0_CSC_MODE(csc_mode);
+			vop_msk_reg(vop_dev, WIN0_CTRL0, val);
+		} else if (win->id == 1) {
+			val = V_WIN1_CSC_MODE(csc_mode);
+			vop_msk_reg(vop_dev, WIN1_CTRL0, val);
+		} else {
+			dev_err(vop_dev->dev, "%s win%d unsupport csc mode",
+				__func__, win->id);
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+}
+
+static int vop_clr_key_cfg(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_lcdc_win *win;
+	int i;
+
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		win = dev_drv->win[i];
+		switch (i) {
+		case 0:
+			vop_writel(vop_dev, WIN0_COLOR_KEY, win->color_key_val);
+			break;
+		case 1:
+			vop_writel(vop_dev, WIN1_COLOR_KEY, win->color_key_val);
+			break;
+		default:
+			pr_info("%s:un support win num:%d\n",
+				__func__, i);
+			break;
+		}
+	}
+	return 0;
+}
+
+static int vop_alpha_cfg(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	u64 val;
+	int ppixel_alpha = 0;
+	int alpha_en = win->alpha_en;
+	int i;
+
+	if (!alpha_en) {
+		if (win_id == 0) {
+			val = V_WIN0_ALPHA_EN(0);
+			vop_msk_reg(vop_dev, WIN0_ALPHA_CTRL, val);
+		} else {
+			val = V_WIN1_ALPHA_EN(0);
+			vop_msk_reg(vop_dev, WIN1_ALPHA_CTRL, val);
+		}
+		return 0;
+	}
+
+	ppixel_alpha = ((win->area[0].format == ARGB888) ||
+			(win->area[0].format == ABGR888)) ? 1 : 0;
+
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		if (!dev_drv->win[i]->state)
+			continue;
+		if (win->z_order > dev_drv->win[i]->z_order)
+			break;
+	}
+
+	/*
+	 * The bottom layer not support ppixel_alpha mode.
+	 */
+	if (i == dev_drv->lcdc_win_num) {
+		ppixel_alpha = 0;
+		alpha_en = 0;
+	}
+
+	if (win_id == 0) {
+		val = V_WIN0_ALPHA_EN(alpha_en) |
+			V_WIN0_ALPHA_MODE(ppixel_alpha) |
+			V_WIN0_ALPHA_PRE_MUL(ppixel_alpha) |
+			V_WIN0_ALPHA_SAT_MODE(0);
+		vop_msk_reg(vop_dev, WIN0_ALPHA_CTRL, val);
+	} else if (win_id == 1) {
+		val = V_WIN1_ALPHA_EN(alpha_en) |
+			V_WIN1_ALPHA_MODE(ppixel_alpha) |
+			V_WIN1_ALPHA_PRE_MUL(ppixel_alpha) |
+			V_WIN1_ALPHA_SAT_MODE(0);
+		vop_msk_reg(vop_dev, WIN1_ALPHA_CTRL, val);
+	} else {
+		dev_err(vop_dev->dev, "%s: invalid win id=%d or unsupport\n",
+			__func__, win_id);
+	}
+
+	return 0;
+}
+
+static int vop_axi_gather_cfg(struct vop_device *vop_dev,
+			      struct rk_lcdc_win *win)
+{
+	u64 val;
+	u16 yrgb_gather_num = 3;
+	u16 cbcr_gather_num = 1;
+
+	switch (win->area[0].format) {
+	case ARGB888:
+	case XBGR888:
+	case ABGR888:
+	case XRGB888:
+		yrgb_gather_num = 3;
+		break;
+	case RGB888:
+	case RGB565:
+	case BGR888:
+	case BGR565:
+		yrgb_gather_num = 2;
+		break;
+	case YUV444:
+	case YUV422:
+	case YUV420:
+	case YUV420_A:
+	case YUV422_A:
+	case YUV444_A:
+	case YUV420_NV21:
+		yrgb_gather_num = 1;
+		cbcr_gather_num = 2;
+		break;
+	default:
+		dev_err(vop_dev->driver.dev, "%s:un supported format[%d]\n",
+			__func__, win->area[0].format);
+		return -EINVAL;
+	}
+
+	if (win->id == 0) {
+		val = V_WIN0_YRGB_AXI_GATHER_EN(1) |
+			V_WIN0_CBR_AXI_GATHER_EN(1) |
+			V_WIN0_YRGB_AXI_GATHER_NUM(yrgb_gather_num) |
+			V_WIN0_CBR_AXI_GATHER_NUM(cbcr_gather_num);
+		vop_msk_reg(vop_dev, WIN0_CTRL1, val);
+	} else if (win->id == 1) {
+		val = V_WIN1_AXI_GATHER_EN(1) |
+			V_WIN1_AXI_GATHER_NUM(yrgb_gather_num);
+		vop_msk_reg(vop_dev, WIN1_CTRL1, val);
+	}
+	return 0;
+}
+
+static int vop_win0_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	u64 val;
+
+	if (win->state == 1) {
+		vop_axi_gather_cfg(vop_dev, win);
+		val = V_WIN0_EN(win->state) |
+			V_WIN0_DATA_FMT(win->area[0].fmt_cfg) |
+			V_WIN0_RB_SWAP(win->area[0].swap_rb) |
+			V_WIN0_UV_SWAP(win->area[0].swap_uv);
+		if (dev_drv->cur_screen->mode.vmode & FB_VMODE_INTERLACED)
+			val |= V_WIN0_INTERLACE_READ(1);
+		else
+			val |= V_WIN0_INTERLACE_READ(0);
+		vop_msk_reg(vop_dev, WIN0_CTRL0, val);
+
+		val = V_WIN0_YRGB_VIR_STRIDE(win->area[0].y_vir_stride) |
+		    V_WIN0_CBR_VIR_STRIDE(win->area[0].uv_vir_stride);
+		vop_writel(vop_dev, WIN0_VIR, val);
+
+		val = V_WIN0_DSP_WIDTH(win->area[0].xsize - 1) |
+		    V_WIN0_DSP_HEIGHT(win->area[0].ysize - 1);
+		vop_writel(vop_dev, WIN0_DSP_INFO, val);
+
+		val = V_WIN0_DSP_XST(win->area[0].dsp_stx) |
+		    V_WIN0_DSP_YST(win->area[0].dsp_sty);
+		vop_writel(vop_dev, WIN0_DSP_ST, val);
+
+		/* only win0 support scale and yuv */
+		val = V_WIN0_ACT_WIDTH(win->area[0].xact - 1) |
+			V_WIN0_ACT_HEIGHT(win->area[0].yact - 1);
+		vop_writel(vop_dev, WIN0_ACT_INFO, val);
+
+		val = V_WIN0_HS_FACTOR_YRGB(win->scale_yrgb_x) |
+			V_WIN0_VS_FACTOR_YRGB(win->scale_yrgb_y);
+		vop_writel(vop_dev, WIN0_SCL_FACTOR_YRGB, val);
+
+		val = V_WIN0_HS_FACTOR_CBR(win->scale_cbcr_x) |
+			V_WIN0_VS_FACTOR_CBR(win->scale_cbcr_y);
+		vop_writel(vop_dev, WIN0_SCL_FACTOR_CBR, val);
+
+		if (win->area[0].y_addr > 0)
+			vop_writel(vop_dev, WIN0_YRGB_MST, win->area[0].y_addr);
+		if (win->area[0].uv_addr > 0)
+			vop_writel(vop_dev, WIN0_CBR_MST, win->area[0].uv_addr);
+
+		vop_alpha_cfg(dev_drv, win_id);
+	} else {
+		val = V_WIN0_EN(win->state);
+		vop_msk_reg(vop_dev, WIN0_CTRL0, val);
+	}
+
+	return 0;
+}
+
+static int vop_win1_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	u64 val;
+
+	if (win->state == 1) {
+		vop_axi_gather_cfg(vop_dev, win);
+		val = V_WIN1_EN(win->state) |
+			V_WIN1_DATA_FMT(win->area[0].fmt_cfg) |
+			V_WIN1_RB_SWAP(win->area[0].swap_rb);
+		if (dev_drv->cur_screen->mode.vmode & FB_VMODE_INTERLACED)
+			val |= V_WIN1_INTERLACE_READ(1);
+		vop_msk_reg(vop_dev, WIN1_CTRL0, val);
+
+		val = V_WIN1_VIR_STRIDE(win->area[0].y_vir_stride);
+		vop_writel(vop_dev, WIN1_VIR, val);
+
+		val = V_WIN1_DSP_WIDTH(win->area[0].xsize - 1) |
+		    V_WIN1_DSP_HEIGHT(win->area[0].ysize - 1);
+		vop_writel(vop_dev, WIN1_DSP_INFO, val);
+
+		val = V_WIN1_DSP_XST(win->area[0].dsp_stx) |
+		    V_WIN1_DSP_YST(win->area[0].dsp_sty);
+		vop_writel(vop_dev, WIN1_DSP_ST, val);
+
+		if (win->area[0].y_addr > 0)
+			vop_writel(vop_dev, WIN1_YRGB_MST, win->area[0].y_addr);
+
+		vop_alpha_cfg(dev_drv, win_id);
+	} else {
+		val = V_WIN1_EN(win->state);
+		vop_msk_reg(vop_dev, WIN1_CTRL0, val);
+	}
+
+	return 0;
+}
+
+static int vop_hwc_reg_update(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_lcdc_win *win = dev_drv->win[win_id];
+	unsigned int hwc_size = 0;
+	u64 val;
+
+	if (win->state == 1) {
+		vop_axi_gather_cfg(vop_dev, win);
+
+		if ((win->area[0].xsize == 32) && (win->area[0].ysize == 32))
+			hwc_size = 0;
+		else if ((win->area[0].xsize == 64) &&
+			 (win->area[0].ysize == 64))
+			hwc_size = 1;
+		else
+			dev_err(vop_dev->dev, "unsupported hwc size[%dx%d]!\n",
+				win->area[0].xsize, win->area[0].ysize);
+
+		val = V_HWC_EN(1) | V_HWC_SIZE(hwc_size);
+		vop_msk_reg(vop_dev, HWC_CTRL0, val);
+
+		val = V_HWC_DSP_XST(win->area[0].dsp_stx) |
+		    V_HWC_DSP_YST(win->area[0].dsp_sty);
+		vop_msk_reg(vop_dev, HWC_DSP_ST, val);
+
+		if (win->area[0].y_addr > 0)
+			vop_writel(vop_dev, HWC_MST, win->area[0].y_addr);
+	} else {
+		val = V_HWC_EN(win->state);
+		vop_msk_reg(vop_dev, HWC_CTRL0, val);
+	}
+
+	return 0;
+}
+
+static int vop_layer_update_regs(struct vop_device *vop_dev,
+				 struct rk_lcdc_win *win)
+{
+	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
+
+	vop_msk_reg(vop_dev, SYS_CTRL2,
+		    V_IMD_VOP_STANDBY_EN(vop_dev->standby));
+	if (win->id == 0)
+		vop_win0_reg_update(dev_drv, win->id);
+	else if (win->id == 1)
+		vop_win1_reg_update(dev_drv, win->id);
+	else if (win->id == 2)
+		vop_hwc_reg_update(dev_drv, win->id);
+	vop_cfg_done(vop_dev);
+
+	DBG(2, "%s for vop%d\n", __func__, vop_dev->id);
+	return 0;
+}
+
+static int vop_set_hwc_lut(struct rk_lcdc_driver *dev_drv,
+			   int *hwc_lut, int mode)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	int len = 256 * sizeof(u32);
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (!dev_drv->hwc_lut)
+		dev_drv->hwc_lut = devm_kzalloc(vop_dev->dev, len, GFP_KERNEL);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_msk_reg(vop_dev, HWC_CTRL0, V_HWC_LUT_EN(0));
+		vop_cfg_done(vop_dev);
+		mdelay(25);
+		for (i = 0; i < 256; i++) {
+			if (mode == 1)
+				dev_drv->hwc_lut[i] = hwc_lut[i];
+
+			v = dev_drv->hwc_lut[i];
+			c = vop_dev->hwc_lut_addr_base + (i << 2);
+			writel_relaxed(v, c);
+		}
+		vop_msk_reg(vop_dev, HWC_CTRL0, V_HWC_LUT_EN(1));
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_set_lut(struct rk_lcdc_driver *dev_drv, int *dsp_lut)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (!dsp_lut)
+		return 0;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_LUT_EN(0));
+		vop_cfg_done(vop_dev);
+		mdelay(25);
+		for (i = 0; i < 256; i++) {
+			v = dsp_lut[i];
+			c = vop_dev->dsp_lut_addr_base + (i << 2);
+			writel_relaxed(v, c);
+		}
+		vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_LUT_EN(1));
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_set_dclk(struct rk_lcdc_driver *dev_drv, int reset_rate)
+{
+	int ret = 0, fps = 0;
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (reset_rate)
+		ret = clk_set_rate(vop_dev->dclk, screen->mode.pixclock);
+	if (ret)
+		dev_err(dev_drv->dev, "set lcdc%d dclk[%d] failed\n",
+			vop_dev->id, screen->mode.pixclock);
+	vop_dev->pixclock =
+	    div_u64(1000000000000llu, clk_get_rate(vop_dev->dclk));
+	vop_dev->driver.pixclock = vop_dev->pixclock;
+
+	fps = rk_fb_calc_fps(screen, vop_dev->pixclock);
+	screen->ft = 1000 / fps;
+	dev_info(vop_dev->dev, "%s: dclk:%lu>>fps:%d ",
+		 vop_dev->driver.name, clk_get_rate(vop_dev->dclk), fps);
+	return 0;
+}
+
+static int vop_config_timing(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 hsync_len = screen->mode.hsync_len;
+	u16 left_margin = screen->mode.left_margin;
+	u16 right_margin = screen->mode.right_margin;
+	u16 vsync_len = screen->mode.vsync_len;
+	u16 upper_margin = screen->mode.upper_margin;
+	u16 lower_margin = screen->mode.lower_margin;
+	u16 x_res = screen->mode.xres;
+	u16 y_res = screen->mode.yres;
+	u64 val;
+	u16 h_total, v_total;
+	u16 vact_end_f1, vact_st_f1, vs_end_f1, vs_st_f1;
+
+	/* config timing reg valid immediately or after frame start */
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) /* after frame start */
+		vop_msk_reg(vop_dev, SYS_CTRL2, V_IMD_DSP_TIMING_IMD(1));
+	else /* timing reg valid immediately */
+		vop_msk_reg(vop_dev, SYS_CTRL2, V_IMD_DSP_TIMING_IMD(0));
+
+	h_total = hsync_len + left_margin + x_res + right_margin;
+	v_total = vsync_len + upper_margin + y_res + lower_margin;
+
+	val = V_DSP_HS_END(hsync_len) | V_DSP_HTOTAL(h_total);
+	vop_msk_reg(vop_dev, DSP_HTOTAL_HS_END, val);
+
+	val = V_DSP_HACT_END(hsync_len + left_margin + x_res) |
+	    V_DSP_HACT_ST(hsync_len + left_margin);
+	vop_msk_reg(vop_dev, DSP_HACT_ST_END, val);
+
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		/* First Field Timing */
+		val = V_DSP_VS_END(vsync_len) |
+		    V_DSP_VTOTAL(2 * (vsync_len + upper_margin +
+				      lower_margin) + y_res + 1);
+		vop_msk_reg(vop_dev, DSP_VTOTAL_VS_END, val);
+
+		val = V_DSP_VACT_END(vsync_len + upper_margin + y_res / 2) |
+		    V_DSP_VACT_ST(vsync_len + upper_margin);
+		vop_msk_reg(vop_dev, DSP_VACT_ST_END, val);
+
+		/* Second Field Timing */
+		vs_st_f1 = vsync_len + upper_margin + y_res / 2 + lower_margin;
+		vs_end_f1 = 2 * vsync_len + upper_margin + y_res / 2 +
+		    lower_margin;
+		val = V_DSP_VS_ST_F1(vs_st_f1) | V_DSP_VS_END_F1(vs_end_f1);
+		vop_msk_reg(vop_dev, DSP_VS_ST_END_F1, val);
+
+		vact_end_f1 = 2 * (vsync_len + upper_margin) + y_res +
+		    lower_margin + 1;
+		vact_st_f1 = 2 * (vsync_len + upper_margin) + y_res / 2 +
+		    lower_margin + 1;
+		val = V_DSP_VACT_END_F1(vact_end_f1) |
+			V_DSP_VACT_ST_F1(vact_st_f1);
+		vop_msk_reg(vop_dev, DSP_VACT_ST_END_F1, val);
+
+		val = V_DSP_LINE_FLAG0_NUM(lower_margin ?
+					   vact_end_f1 : vact_end_f1 - 1);
+
+		val |= V_DSP_LINE_FLAG1_NUM(lower_margin ?
+					    vact_end_f1 : vact_end_f1 - 1);
+		vop_msk_reg(vop_dev, LINE_FLAG, val);
+	} else {
+		val = V_DSP_VS_END(vsync_len) | V_DSP_VTOTAL(v_total);
+		vop_msk_reg(vop_dev, DSP_VTOTAL_VS_END, val);
+
+		val = V_DSP_VACT_END(vsync_len + upper_margin + y_res) |
+		    V_DSP_VACT_ST(vsync_len + upper_margin);
+		vop_msk_reg(vop_dev, DSP_VACT_ST_END, val);
+
+		val = V_DSP_LINE_FLAG0_NUM(vsync_len + upper_margin + y_res) |
+			V_DSP_LINE_FLAG1_NUM(vsync_len + upper_margin + y_res);
+		vop_msk_reg(vop_dev, LINE_FLAG, val);
+	}
+
+	return 0;
+}
+
+static int vop_config_source(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 val = 0;
+
+	switch (screen->type) {
+	case SCREEN_RGB:
+		vop_grf_writel(vop_dev->grf_base, GRF_SOC_CON5,
+			       V_RGB_VOP_SEL(dev_drv->id));
+		val = V_RGB_DCLK_EN(1) | V_RGB_DCLK_POL(screen->pin_dclk) |
+			V_RGB_HSYNC_POL(screen->pin_hsync) |
+			V_RGB_VSYNC_POL(screen->pin_vsync) |
+			V_RGB_DEN_POL(screen->pin_den);
+		break;
+	case SCREEN_HDMI:
+		vop_grf_writel(vop_dev->grf_base, GRF_SOC_CON0,
+			       V_HDMI_VOP_SEL(dev_drv->id));
+		val = V_HDMI_DCLK_EN(1) | V_HDMI_DCLK_POL(screen->pin_dclk) |
+			V_HDMI_HSYNC_POL(screen->pin_hsync) |
+			V_HDMI_VSYNC_POL(screen->pin_vsync) |
+			V_HDMI_DEN_POL(screen->pin_den);
+		break;
+	case SCREEN_LVDS:
+		vop_grf_writel(vop_dev->grf_base, GRF_SOC_CON0,
+			       V_LVDS_VOP_SEL(dev_drv->id));
+		val = V_LVDS_DCLK_EN(1) | V_LVDS_DCLK_POL(screen->pin_dclk) |
+			V_LVDS_HSYNC_POL(screen->pin_hsync) |
+			V_LVDS_VSYNC_POL(screen->pin_vsync) |
+			V_LVDS_DEN_POL(screen->pin_den);
+		break;
+	case SCREEN_MIPI:
+		vop_grf_writel(vop_dev->grf_base, GRF_SOC_CON0,
+			       V_DSI0_VOP_SEL(dev_drv->id));
+		val = V_MIPI_DCLK_EN(1) | V_MIPI_DCLK_POL(screen->pin_dclk) |
+			V_MIPI_HSYNC_POL(screen->pin_hsync) |
+			V_MIPI_VSYNC_POL(screen->pin_vsync) |
+			V_MIPI_DEN_POL(screen->pin_den);
+		break;
+	default:
+		dev_err(vop_dev->dev, "un supported interface[%d]!\n",
+			screen->type);
+		break;
+	}
+
+	val |= V_SW_CORE_CLK_SEL(!!screen->pixelrepeat);
+	if (screen->mode.vmode & FB_VMODE_INTERLACED)
+		val |= V_SW_HDMI_CLK_I_SEL(1);
+	else
+		val |= V_SW_HDMI_CLK_I_SEL(0);
+	vop_msk_reg(vop_dev, DSP_CTRL0, val);
+
+	return 0;
+}
+
+static int vop_config_interface(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 val = 0;
+
+	/* FRC dither down init */
+	if (screen->face != OUT_P888) {
+		vop_writel(vop_dev, FRC_LOWER01_0, 0x12844821);
+		vop_writel(vop_dev, FRC_LOWER01_1, 0x21488412);
+		vop_writel(vop_dev, FRC_LOWER10_0, 0xa55a9696);
+		vop_writel(vop_dev, FRC_LOWER10_1, 0x5aa56969);
+		vop_writel(vop_dev, FRC_LOWER11_0, 0xdeb77deb);
+		vop_writel(vop_dev, FRC_LOWER11_1, 0xed7bb7de);
+	}
+
+	switch (screen->face) {
+	case OUT_P888:
+		val = V_DSP_OUT_MODE(OUT_P888) | V_DITHER_DOWN(0);
+		break;
+	case OUT_P565:
+		val = V_DSP_OUT_MODE(OUT_P565) | V_DITHER_DOWN(1) |
+			V_DITHER_DOWN_MODE(DITHER_888_565) |
+			V_DITHER_DOWN_SEL(DITHER_SEL_FRC);
+		break;
+	case OUT_P666:
+		val = V_DSP_OUT_MODE(OUT_P666) | V_DITHER_DOWN(1) |
+			V_DITHER_DOWN_MODE(DITHER_888_666) |
+			V_DITHER_DOWN_SEL(DITHER_SEL_FRC);
+		break;
+	case OUT_D888_P565:
+		val = V_DSP_OUT_MODE(OUT_P888) | V_DITHER_DOWN(1) |
+			V_DITHER_DOWN_MODE(DITHER_888_565) |
+			V_DITHER_DOWN_SEL(DITHER_SEL_FRC);
+		break;
+	case OUT_D888_P666:
+		val = V_DSP_OUT_MODE(OUT_P888) | V_DITHER_DOWN(1) |
+			V_DITHER_DOWN_MODE(DITHER_888_666) |
+			V_DITHER_DOWN_SEL(DITHER_SEL_FRC);
+		break;
+	default:
+		dev_err(vop_dev->dev, "un supported screen face[%d]!\n",
+			screen->face);
+		break;
+	}
+
+	if (screen->mode.vmode & FB_VMODE_INTERLACED)
+		val |= V_DSP_INTERLACE(1) | V_INTERLACE_FIELD_POL(0);
+	else
+		val |= V_DSP_INTERLACE(0) | V_INTERLACE_FIELD_POL(0);
+
+	dev_drv->output_color = screen->color_mode;
+	if (screen->color_mode == COLOR_RGB)
+		dev_drv->overlay_mode = VOP_RGB_DOMAIN;
+	else
+		dev_drv->overlay_mode = VOP_YUV_DOMAIN;
+
+	val |= V_SW_OVERLAY_MODE(dev_drv->overlay_mode) |
+		V_DSP_BG_SWAP(screen->swap_gb) |
+		V_DSP_RB_SWAP(screen->swap_rb) |
+		V_DSP_RG_SWAP(screen->swap_rg) |
+		V_DSP_DELTA_SWAP(screen->swap_delta) |
+		V_DSP_DUMMY_SWAP(screen->swap_dumy) |
+		V_DSP_BLANK_EN(0) | V_DSP_BLACK_EN(0);
+	vop_msk_reg(vop_dev, DSP_CTRL2, val);
+
+	return 0;
+}
+
+static void vop_config_background(struct rk_lcdc_driver *dev_drv, int rgb)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u64 val;
+	int b = rgb & 0xff;
+	int g = (rgb >> 8) & 0xff;
+	int r = (rgb >> 16) & 0xff;
+
+	val = V_DSP_BG_BLUE(b) | V_DSP_BG_GREEN(g) | V_DSP_BG_RED(r);
+	vop_msk_reg(vop_dev, DSP_BG, val);
+}
+
+static void vop_bcsh_path_sel(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (dev_drv->overlay_mode == VOP_YUV_DOMAIN) {
+		if (IS_YUV_COLOR(dev_drv->output_color))	/* bypass */
+			vop_msk_reg(vop_dev, BCSH_CTRL,
+				    V_SW_BCSH_Y2R_EN(0) | V_SW_BCSH_R2Y_EN(0));
+		else		/* YUV2RGB */
+			vop_msk_reg(vop_dev, BCSH_CTRL, V_SW_BCSH_Y2R_EN(1) |
+				    V_SW_BCSH_Y2R_CSC_MODE(VOP_Y2R_CSC_MPEG) |
+				    V_SW_BCSH_R2Y_EN(0));
+	} else {
+		/* overlay_mode=VOP_RGB_DOMAIN */
+		/* bypass  --need check,if bcsh close? */
+		if (dev_drv->output_color == COLOR_RGB) {
+			if (dev_drv->bcsh.enable == 1)
+				vop_msk_reg(vop_dev, BCSH_CTRL,
+					    V_SW_BCSH_R2Y_EN(1) |
+					    V_SW_BCSH_Y2R_EN(1));
+			else
+				vop_msk_reg(vop_dev, BCSH_CTRL,
+					    V_SW_BCSH_R2Y_EN(0) |
+					    V_SW_BCSH_Y2R_EN(0));
+		} else {
+			/* RGB2YUV */
+			vop_msk_reg(vop_dev, BCSH_CTRL,
+				    V_SW_BCSH_R2Y_EN(1) |
+				    V_SW_BCSH_R2Y_CSC_MODE(VOP_Y2R_CSC_MPEG) |
+				    V_SW_BCSH_Y2R_EN(0));
+		}
+	}
+}
+
+static int vop_get_dspbuf_info(struct rk_lcdc_driver *dev_drv, u16 *xact,
+			       u16 *yact, int *format, u32 *dsp_addr,
+			       int *ymirror)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u32 val;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		val = vop_readl(vop_dev, WIN0_ACT_INFO);
+		*xact = (val & MASK(WIN0_ACT_WIDTH)) + 1;
+		*yact = ((val & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
+
+		val = vop_readl(vop_dev, WIN0_CTRL0);
+		*format = (val & MASK(WIN0_DATA_FMT)) >> 1;
+		*dsp_addr = vop_readl(vop_dev, WIN0_YRGB_MST);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_post_dspbuf(struct rk_lcdc_driver *dev_drv, u32 rgb_mst,
+			   int format, u16 xact, u16 yact, u16 xvir,
+			   int ymirror)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	int swap = (format == RGB888) ? 1 : 0;
+	u64 val;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		val = V_WIN0_DATA_FMT(format) | V_WIN0_RB_SWAP(swap);
+		vop_msk_reg(vop_dev, WIN0_CTRL0, val);
+
+		vop_msk_reg(vop_dev, WIN0_VIR, V_WIN0_YRGB_VIR_STRIDE(xvir));
+		vop_writel(vop_dev, WIN0_ACT_INFO, V_WIN0_ACT_WIDTH(xact - 1) |
+			   V_WIN0_ACT_HEIGHT(yact - 1));
+
+		vop_writel(vop_dev, WIN0_YRGB_MST, rgb_mst);
+
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static void vop_reg_restore(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	int len = FLAG_REG;
+
+	spin_lock(&vop_dev->reg_lock);
+
+	if (likely(vop_dev->clk_on))
+		memcpy(vop_dev->regs, vop_dev->regsbak, len);
+
+	spin_unlock(&vop_dev->reg_lock);
+
+	/* set screen GAMMA lut */
+	if (dev_drv->cur_screen && dev_drv->cur_screen->dsp_lut)
+		vop_set_lut(dev_drv, dev_drv->cur_screen->dsp_lut);
+
+	/* set hwc lut */
+	vop_set_hwc_lut(dev_drv, dev_drv->hwc_lut, 0);
+}
+
+static int vop_load_screen(struct rk_lcdc_driver *dev_drv, bool initscreen)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	/*if (!vop_dev->standby && initscreen && (dev_drv->first_frame != 1))*/
+	/*	flush_kthread_worker(&dev_drv->update_regs_worker);*/
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_config_interface(dev_drv);
+		vop_config_source(dev_drv);
+		vop_config_timing(dev_drv);
+		if (dev_drv->overlay_mode == VOP_YUV_DOMAIN)
+			vop_config_background(dev_drv, 0x801080);
+		else
+			vop_config_background(dev_drv, 0x000000);
+
+		vop_bcsh_path_sel(dev_drv);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	vop_set_dclk(dev_drv, 1);
+	if (screen->init)
+		screen->init();
+
+	return 0;
+}
+
+/*
+ * enable or disable layer according to win id
+ * @open: 1 enable; 0 disable
+ */
+static void vop_layer_enable(struct vop_device *vop_dev,
+			     unsigned int win_id, bool open)
+{
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on) &&
+	    vop_dev->driver.win[win_id]->state != open) {
+		if (open) {
+			if (!vop_dev->atv_layer_cnt) {
+				dev_info(vop_dev->dev,
+					 "wakeup from standby!\n");
+				vop_dev->standby = 0;
+			}
+			vop_dev->atv_layer_cnt |= (1 << win_id);
+		} else {
+			if (vop_dev->atv_layer_cnt & (1 << win_id))
+				vop_dev->atv_layer_cnt &= ~(1 << win_id);
+		}
+		vop_dev->driver.win[win_id]->state = open;
+		if (!open) {
+			vop_layer_update_regs(vop_dev,
+					      vop_dev->driver.win[win_id]);
+			vop_cfg_done(vop_dev);
+		}
+		/* if no layer used,disable lcdc */
+		if (!vop_dev->atv_layer_cnt) {
+			dev_info(vop_dev->dev,
+				 "no layer is used,go to standby!\n");
+			vop_dev->standby = 1;
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+}
+
+static int vop_open(struct rk_lcdc_driver *dev_drv, int win_id,
+		    bool open)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	/* enable clk,when first layer open */
+	if ((open) && (!vop_dev->atv_layer_cnt)) {
+		/* rockchip_set_system_status(sys_status); */
+		vop_pre_init(dev_drv);
+		vop_clk_enable(vop_dev);
+		vop_irq_enable(vop_dev);
+
+		if (support_uboot_display() && (vop_dev->prop == PRMRY)) {
+			vop_set_dclk(dev_drv, 0);
+		} else {
+			vop_load_screen(dev_drv, 1);
+			if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+				dev_drv->trsm_ops->enable();
+		}
+		if (dev_drv->bcsh.enable)
+			vop_set_bcsh(dev_drv, 1);
+
+		/* set screen GAMMA lut */
+		if (dev_drv->cur_screen && dev_drv->cur_screen->dsp_lut)
+			vop_set_lut(dev_drv, dev_drv->cur_screen->dsp_lut);
+	}
+
+	if (win_id < ARRAY_SIZE(vop_win))
+		vop_layer_enable(vop_dev, win_id, open);
+	else
+		dev_err(vop_dev->dev, "invalid win id:%d\n", win_id);
+
+	dev_drv->first_frame = 0;
+	return 0;
+}
+
+static int vop_pan_display(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+
+	if (win_id >= dev_drv->lcdc_win_num) {
+		dev_err(dev_drv->dev, "invalid win id:%d!\n", win_id);
+		return -EINVAL;
+	}
+
+	win = dev_drv->win[win_id];
+	win->area[0].y_addr = win->area[0].smem_start + win->area[0].y_offset;
+	/* only win0 support yuv format */
+	if (win_id == 0)
+		win->area[0].uv_addr =
+			win->area[0].cbr_start + win->area[0].c_offset;
+	else
+		win->area[0].uv_addr = 0;
+
+	DBG(2, "lcdc[%d]:win[%d]>>:y_addr:0x%x>>uv_addr:0x%x",
+	    vop_dev->id, win->id, win->area[0].y_addr, win->area[0].uv_addr);
+	DBG(2, ">>y_offset:0x%x>>c_offset=0x%x\n",
+	    win->area[0].y_offset, win->area[0].c_offset);
+	return 0;
+}
+
+static int win_0_1_set_par(struct vop_device *vop_dev,
+			   struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	char fmt[9] = "NULL";
+
+	win->area[0].dsp_stx = win->area[0].xpos + screen->mode.left_margin +
+				screen->mode.hsync_len;
+	if (screen->mode.vmode & FB_VMODE_INTERLACED) {
+		win->area[0].ysize /= 2;
+		win->area[0].dsp_sty = win->area[0].ypos / 2 +
+			screen->mode.upper_margin + screen->mode.vsync_len;
+	} else {
+		win->area[0].dsp_sty = win->area[0].ypos +
+			screen->mode.upper_margin + screen->mode.vsync_len;
+	}
+
+	win->scale_yrgb_x = CALSCALE(win->area[0].xact, win->area[0].xsize);
+	win->scale_yrgb_y = CALSCALE(win->area[0].yact, win->area[0].ysize);
+
+	switch (win->area[0].format) {
+	case ARGB888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 0;
+		break;
+	case XBGR888:
+	case ABGR888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 1;
+		break;
+	case RGB888:
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
+		win->area[0].swap_rb = 0;
+		break;
+	case RGB565:
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
+		win->area[0].swap_rb = 0;
+		break;
+	case XRGB888:
+		win->area[0].fmt_cfg = VOP_FORMAT_ARGB888;
+		win->area[0].swap_rb = 0;
+		break;
+	case BGR888:
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB888;
+		win->area[0].swap_rb = 1;
+		break;
+	case BGR565:
+		win->area[0].fmt_cfg = VOP_FORMAT_RGB565;
+		win->area[0].swap_rb = 1;
+		break;
+	case YUV422:
+		if (win->id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR422;
+			win->area[0].swap_rb = 0;
+			win->area[0].swap_uv = 0;
+			win->scale_cbcr_x = CALSCALE(win->area[0].xact / 2,
+						     win->area[0].xsize);
+			win->scale_cbcr_y = CALSCALE(win->area[0].yact,
+						     win->area[0].ysize);
+		} else {
+			dev_err(vop_dev->dev, "%s:win%d unsupport YUV format\n",
+				__func__, win->id);
+		}
+		break;
+	case YUV420:
+		if (win->id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
+			win->area[0].swap_rb = 0;
+			win->area[0].swap_uv = 0;
+			win->scale_cbcr_x = CALSCALE(win->area[0].xact / 2,
+						     win->area[0].xsize);
+			win->scale_cbcr_y = CALSCALE(win->area[0].yact / 2,
+						     win->area[0].ysize);
+		} else {
+			dev_err(vop_dev->dev, "%s:win%d unsupport YUV format\n",
+				__func__, win->id);
+		}
+
+		break;
+	case YUV420_NV21:
+		if (win->id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR420;
+			win->area[0].swap_rb = 0;
+			win->area[0].swap_uv = 1;
+			win->scale_cbcr_x = CALSCALE(win->area[0].xact / 2,
+						     win->area[0].xsize);
+			win->scale_cbcr_y = CALSCALE(win->area[0].yact / 2,
+						     win->area[0].ysize);
+		} else {
+			dev_err(vop_dev->dev, "%s:win%d unsupport YUV format\n",
+				__func__, win->id);
+		}
+		break;
+	case YUV444:
+		if (win->id == 0) {
+			win->area[0].fmt_cfg = VOP_FORMAT_YCBCR444;
+			win->area[0].swap_rb = 0;
+			win->area[0].swap_uv = 0;
+			win->scale_cbcr_x =
+				CALSCALE(win->area[0].xact, win->area[0].xsize);
+			win->scale_cbcr_y =
+				CALSCALE(win->area[0].yact, win->area[0].ysize);
+		} else {
+			dev_err(vop_dev->dev, "%s:win%d unsupport YUV format\n",
+				__func__, win->id);
+		}
+		break;
+	default:
+		dev_err(vop_dev->dev, "%s:unsupport format[%d]!\n",
+			__func__, win->area[0].format);
+		break;
+	}
+
+	DBG(1, "lcdc[%d]:win[%d]\n>>format:%s>>>xact:%d>>yact:%d>>xsize:%d",
+	    vop_dev->id, win->id, get_format_string(win->area[0].format, fmt),
+	    win->area[0].xact, win->area[0].yact, win->area[0].xsize);
+	DBG(1, ">>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+	    win->area[0].ysize, win->area[0].xvir, win->area[0].yvir,
+	    win->area[0].xpos, win->area[0].ypos);
+
+	return 0;
+}
+
+static int hwc_set_par(struct vop_device *vop_dev,
+		       struct rk_screen *screen, struct rk_lcdc_win *win)
+{
+	win->area[0].dsp_stx = win->area[0].xpos + screen->mode.left_margin +
+				screen->mode.hsync_len;
+	win->area[0].dsp_sty = win->area[0].ypos + screen->mode.upper_margin +
+				screen->mode.vsync_len;
+
+	DBG(1, "lcdc[%d]:hwc>>%s\n>>xsize:%d>>ysize:%d>>xpos:%d>>ypos:%d",
+	    vop_dev->id, __func__, win->area[0].xsize, win->area[0].ysize,
+	    win->area[0].xpos, win->area[0].ypos);
+	return 0;
+}
+
+static int vop_set_par(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	if (!screen) {
+		dev_err(dev_drv->dev, "screen is null!\n");
+		return -ENOENT;
+	}
+
+	switch (win_id) {
+	case 0:
+		win_0_1_set_par(vop_dev, screen, dev_drv->win[0]);
+		break;
+	case 1:
+		win_0_1_set_par(vop_dev, screen, dev_drv->win[1]);
+		break;
+	case 2:
+		hwc_set_par(vop_dev, screen, dev_drv->win[2]);
+		break;
+	default:
+		dev_err(dev_drv->dev, "%s: unsupported win id:%d\n",
+			__func__, win_id);
+		break;
+	}
+	return 0;
+}
+
+static int vop_ioctl(struct rk_lcdc_driver *dev_drv, unsigned int cmd,
+		     unsigned long arg, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	struct color_key_cfg clr_key_cfg;
+
+	switch (cmd) {
+	case RK_FBIOGET_PANEL_SIZE:
+		panel_size[0] = vop_dev->screen->mode.xres;
+		panel_size[1] = vop_dev->screen->mode.yres;
+		if (copy_to_user(argp, panel_size, 8))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_COLOR_KEY_CFG:
+		if (copy_from_user(&clr_key_cfg, argp,
+				   sizeof(struct color_key_cfg)))
+			return -EFAULT;
+		vop_clr_key_cfg(dev_drv);
+		vop_writel(vop_dev, WIN0_COLOR_KEY,
+			   clr_key_cfg.win0_color_key_cfg);
+		vop_writel(vop_dev, WIN1_COLOR_KEY,
+			   clr_key_cfg.win1_color_key_cfg);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int vop_get_backlight_device(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct device_node *backlight;
+	struct property *prop;
+	u32 *brightness_levels;
+	u32 length, max, last;
+
+	if (vop_dev->backlight)
+		return 0;
+	backlight = of_parse_phandle(vop_dev->dev->of_node, "backlight", 0);
+	if (backlight) {
+		vop_dev->backlight = of_find_backlight_by_node(backlight);
+		if (!vop_dev->backlight)
+			dev_info(vop_dev->dev, "No find backlight device\n");
+	} else {
+		dev_info(vop_dev->dev, "No find backlight device node\n");
+	}
+	prop = of_find_property(backlight, "brightness-levels", &length);
+	if (!prop)
+		return -EINVAL;
+	max = length / sizeof(u32);
+	last = max - 1;
+	brightness_levels = kmalloc(256, GFP_KERNEL);
+	if (brightness_levels)
+		return -ENOMEM;
+
+	if (!of_property_read_u32_array(backlight, "brightness-levels",
+					brightness_levels, max)) {
+		if (brightness_levels[0] > brightness_levels[last])
+			dev_drv->cabc_pwm_pol = 1;/*negative*/
+		else
+			dev_drv->cabc_pwm_pol = 0;/*positive*/
+	} else {
+		dev_info(vop_dev->dev,
+			 "Can not read brightness-levels value\n");
+	}
+
+	kfree(brightness_levels);
+
+	return 0;
+}
+
+static int vop_backlight_close(struct rk_lcdc_driver *dev_drv, int enable)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (dev_drv->suspend_flag)
+		return 0;
+
+	vop_get_backlight_device(dev_drv);
+
+	if (enable) {
+		/* close the backlight */
+		if (vop_dev->backlight) {
+			vop_dev->backlight->props.power = FB_BLANK_POWERDOWN;
+			backlight_update_status(vop_dev->backlight);
+		}
+		if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+			dev_drv->trsm_ops->disable();
+	} else {
+		if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+			dev_drv->trsm_ops->enable();
+		msleep(100);
+		/* open the backlight */
+		if (vop_dev->backlight) {
+			vop_dev->backlight->props.power = FB_BLANK_UNBLANK;
+			backlight_update_status(vop_dev->backlight);
+		}
+	}
+
+	return 0;
+}
+
+static int vop_early_suspend(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (dev_drv->suspend_flag)
+		return 0;
+
+	dev_drv->suspend_flag = 1;
+	smp_wmb();
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();
+
+	vop_standby_enable(vop_dev);
+	vop_mmu_disable(dev_drv);
+	vop_clk_disable(vop_dev);
+	rk_disp_pwr_disable(dev_drv);
+
+	return 0;
+}
+
+static int vop_early_resume(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (!dev_drv->suspend_flag)
+		return 0;
+
+	rk_disp_pwr_enable(dev_drv);
+	vop_clk_enable(vop_dev);
+	vop_reg_restore(dev_drv);
+	vop_standby_disable(vop_dev);
+	vop_mmu_enable(dev_drv);
+	dev_drv->suspend_flag = 0;
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->enable)
+		dev_drv->trsm_ops->enable();
+
+	return 0;
+}
+
+static int vop_blank(struct rk_lcdc_driver *dev_drv, int win_id, int blank_mode)
+{
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		vop_early_resume(dev_drv);
+		break;
+	case FB_BLANK_NORMAL:
+		vop_early_suspend(dev_drv);
+		break;
+	default:
+		vop_early_suspend(dev_drv);
+		break;
+	}
+
+	dev_info(dev_drv->dev, "blank mode:%d\n", blank_mode);
+
+	return 0;
+}
+
+static int vop_get_win_state(struct rk_lcdc_driver *dev_drv,
+			     int win_id, int area_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u32 area_status = 0, state = 0;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		switch (win_id) {
+		case 0:
+			area_status =
+				vop_read_bit(vop_dev, WIN0_CTRL0, V_WIN0_EN(0));
+			break;
+		case 1:
+			area_status =
+				vop_read_bit(vop_dev, WIN1_CTRL0, V_WIN1_EN(0));
+			break;
+		case 2:
+			area_status =
+				vop_read_bit(vop_dev, HWC_CTRL0, V_HWC_EN(0));
+			break;
+		default:
+			pr_err("%s: win[%d]area[%d],unsupport!!!\n",
+			       __func__, win_id, area_id);
+			break;
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	state = (area_status > 0) ? 1 : 0;
+	return state;
+}
+
+static int vop_get_area_num(struct rk_lcdc_driver *dev_drv,
+			    unsigned int *area_support)
+{
+	area_support[0] = 1;
+	area_support[1] = 1;
+
+	return 0;
+}
+
+static int vop_ovl_mgr(struct rk_lcdc_driver *dev_drv, int swap, bool set)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	int ovl;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		if (set) {
+			vop_msk_reg(vop_dev, DSP_CTRL2, V_DSP_WIN0_TOP(swap));
+			ovl = swap;
+		} else {
+			ovl =
+			    vop_read_bit(vop_dev, DSP_CTRL2, V_DSP_WIN0_TOP(0));
+		}
+	} else {
+		ovl = -EPERM;
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return ovl;
+}
+
+static char *vop_format_to_string(int format, char *fmt)
+{
+	if (!fmt)
+		return NULL;
+
+	switch (format) {
+	case 0:
+		strcpy(fmt, "ARGB888");
+		break;
+	case 1:
+		strcpy(fmt, "RGB888");
+		break;
+	case 2:
+		strcpy(fmt, "RGB565");
+		break;
+	case 4:
+		strcpy(fmt, "YCbCr420");
+		break;
+	case 5:
+		strcpy(fmt, "YCbCr422");
+		break;
+	case 6:
+		strcpy(fmt, "YCbCr444");
+		break;
+	default:
+		strcpy(fmt, "invalid\n");
+		break;
+	}
+	return fmt;
+}
+
+static ssize_t vop_get_disp_info(struct rk_lcdc_driver *dev_drv,
+				 char *buf, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u16 hsync_len = screen->mode.hsync_len;
+	u16 left_margin = screen->mode.left_margin;
+	u16 vsync_len = screen->mode.vsync_len;
+	u16 upper_margin = screen->mode.upper_margin;
+	u32 h_pw_bp = hsync_len + left_margin;
+	u32 v_pw_bp = vsync_len + upper_margin;
+	u32 fmt_id;
+	char format_w0[9] = "NULL";
+	char format_w1[9] = "NULL";
+	char dsp_buf[100];
+	u32 win_ctrl, ovl, vir_info, act_info, dsp_info, dsp_st;
+	u32 y_factor, uv_factor;
+	u8 w0_state, w1_state;
+
+	u32 w0_vir_y, w0_vir_uv, w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y;
+	u32 w0_st_x = h_pw_bp, w0_st_y = v_pw_bp;
+	u32 w1_vir_y, w1_dsp_x, w1_dsp_y;
+	u32 w1_st_x = h_pw_bp, w1_st_y = v_pw_bp;
+	u32 w0_y_h_fac, w0_y_v_fac, w0_uv_h_fac, w0_uv_v_fac;
+
+	u32 dclk_freq;
+	int size = 0;
+
+	dclk_freq = screen->mode.pixclock;
+	/*vop_reg_dump(dev_drv); */
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		ovl = vop_read_bit(vop_dev, DSP_CTRL2, V_DSP_WIN0_TOP(0));
+		/* WIN0 */
+		win_ctrl = vop_readl(vop_dev, WIN0_CTRL0);
+		w0_state = win_ctrl & MASK(WIN0_EN);
+		fmt_id = (win_ctrl & MASK(WIN0_DATA_FMT)) >> 1;
+		vop_format_to_string(fmt_id, format_w0);
+		vir_info = vop_readl(vop_dev, WIN0_VIR);
+		act_info = vop_readl(vop_dev, WIN0_ACT_INFO);
+		dsp_info = vop_readl(vop_dev, WIN0_DSP_INFO);
+		dsp_st = vop_readl(vop_dev, WIN0_DSP_ST);
+		y_factor = vop_readl(vop_dev, WIN0_SCL_FACTOR_YRGB);
+		uv_factor = vop_readl(vop_dev, WIN0_SCL_FACTOR_CBR);
+		w0_vir_y = vir_info & MASK(WIN0_YRGB_VIR_STRIDE);
+		w0_vir_uv = (vir_info & MASK(WIN0_CBR_VIR_STRIDE)) >> 16;
+		w0_act_x = (act_info & MASK(WIN0_ACT_WIDTH)) + 1;
+		w0_act_y = ((act_info & MASK(WIN0_ACT_HEIGHT)) >> 16) + 1;
+		w0_dsp_x = (dsp_info & MASK(WIN0_DSP_WIDTH)) + 1;
+		w0_dsp_y = ((dsp_info & MASK(WIN0_DSP_HEIGHT)) >> 16) + 1;
+		if (w0_state) {
+			w0_st_x = dsp_st & MASK(WIN0_DSP_XST);
+			w0_st_y = (dsp_st & MASK(WIN0_DSP_YST)) >> 16;
+		}
+		w0_y_h_fac = y_factor & MASK(WIN0_HS_FACTOR_YRGB);
+		w0_y_v_fac = (y_factor & MASK(WIN0_VS_FACTOR_YRGB)) >> 16;
+		w0_uv_h_fac = uv_factor & MASK(WIN0_HS_FACTOR_CBR);
+		w0_uv_v_fac = (uv_factor & MASK(WIN0_VS_FACTOR_CBR)) >> 16;
+
+		/* WIN1 */
+		win_ctrl = vop_readl(vop_dev, WIN1_CTRL0);
+		w1_state = win_ctrl & MASK(WIN1_EN);
+		fmt_id = (win_ctrl & MASK(WIN1_DATA_FMT)) >> 1;
+		vop_format_to_string(fmt_id, format_w1);
+		vir_info = vop_readl(vop_dev, WIN1_VIR);
+		dsp_info = vop_readl(vop_dev, WIN1_DSP_INFO);
+		dsp_st = vop_readl(vop_dev, WIN1_DSP_ST);
+		w1_vir_y = vir_info & MASK(WIN1_VIR_STRIDE);
+		w1_dsp_x = (dsp_info & MASK(WIN1_DSP_WIDTH)) + 1;
+		w1_dsp_y = ((dsp_info & MASK(WIN1_DSP_HEIGHT)) >> 16) + 1;
+		if (w1_state) {
+			w1_st_x = dsp_st & MASK(WIN1_DSP_XST);
+			w1_st_y = (dsp_st & MASK(WIN1_DSP_YST)) >> 16;
+		}
+	} else {
+		spin_unlock(&vop_dev->reg_lock);
+		return -EPERM;
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	/* win0 */
+	size += snprintf(dsp_buf, 80,
+		 "win0:\n  state:%d, fmt:%7s\n  y_vir:%4d, uv_vir:%4d,",
+		 w0_state, format_w0, w0_vir_y, w0_vir_uv);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 " x_act  :%5d, y_act  :%5d, dsp_x   :%5d, dsp_y   :%5d\n",
+		 w0_act_x, w0_act_y, w0_dsp_x, w0_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "  x_st :%4d, y_st  :%4d, y_h_fac:%5d, y_v_fac:%5d, ",
+		 w0_st_x - h_pw_bp, w0_st_y - v_pw_bp, w0_y_h_fac, w0_y_v_fac);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "uv_h_fac:%5d, uv_v_fac:%5d\n  y_addr:0x%08x,    uv_addr:0x%08x\n",
+		 w0_uv_h_fac, w0_uv_v_fac, vop_readl(vop_dev, WIN0_YRGB_MST),
+		 vop_readl(vop_dev, WIN0_CBR_MST));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/* win1 */
+	size += snprintf(dsp_buf, 80,
+		 "win1:\n  state:%d, fmt:%7s\n  y_vir:%4d,",
+		 w1_state, format_w1, w1_vir_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 " dsp_x   :%5d, dsp_y   :%5d\n",
+		 w1_dsp_x, w1_dsp_y);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "  x_st :%4d, y_st  :%4d, ",
+		 w1_st_x - h_pw_bp, w1_st_y - v_pw_bp);
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	size += snprintf(dsp_buf, 80,
+		 "y_addr:0x%08x\n",
+		 vop_readl(vop_dev, WIN1_YRGB_MST));
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	/* zorder */
+	size += snprintf(dsp_buf, 80,
+			 ovl ? "win0 on the top of win1\n" :
+				"win1 on the top of win0\n");
+	strcat(buf, dsp_buf);
+	memset(dsp_buf, 0, sizeof(dsp_buf));
+
+	return size;
+}
+
+static int vop_fps_mgr(struct rk_lcdc_driver *dev_drv, int fps, bool set)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+	u32 pixclock;
+	u32 x_total, y_total;
+
+	if (set) {
+		if (fps == 0) {
+			dev_info(dev_drv->dev, "unsupport set fps=0\n");
+			return 0;
+		}
+		ft = div_u64(1000000000000llu, fps);
+		x_total =
+		    screen->mode.upper_margin + screen->mode.lower_margin +
+		    screen->mode.yres + screen->mode.vsync_len;
+		y_total =
+		    screen->mode.left_margin + screen->mode.right_margin +
+		    screen->mode.xres + screen->mode.hsync_len;
+		dev_drv->pixclock = div_u64(ft, x_total * y_total);
+		dotclk = div_u64(1000000000000llu, dev_drv->pixclock);
+		ret = clk_set_rate(vop_dev->dclk, dotclk);
+	}
+
+	pixclock = div_u64(1000000000000llu, clk_get_rate(vop_dev->dclk));
+	vop_dev->pixclock = pixclock;
+	dev_drv->pixclock = vop_dev->pixclock;
+	fps = rk_fb_calc_fps(screen, pixclock);
+	screen->ft = 1000 / fps;	/*one frame time in ms */
+
+	if (set)
+		dev_info(dev_drv->dev, "%s:dclk:%lu,fps:%d\n", __func__,
+			 clk_get_rate(vop_dev->dclk), fps);
+
+	return fps;
+}
+
+static int vop_fb_win_remap(struct rk_lcdc_driver *dev_drv, u16 order)
+{
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (order == FB_DEFAULT_ORDER)
+		order = FB0_WIN0_FB1_WIN1_FB2_WIN2_FB3_WIN3_FB4_HWC;
+	dev_drv->fb4_win_id = order / 10000;
+	dev_drv->fb3_win_id = (order / 1000) % 10;
+	dev_drv->fb2_win_id = (order / 100) % 10;
+	dev_drv->fb1_win_id = (order / 10) % 10;
+	dev_drv->fb0_win_id = order % 10;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return 0;
+}
+
+static int vop_get_win_id(struct rk_lcdc_driver *dev_drv, const char *id)
+{
+	int win_id = 0;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	if (!strcmp(id, "fb0") || !strcmp(id, "fb5"))
+		win_id = dev_drv->fb0_win_id;
+	else if (!strcmp(id, "fb1") || !strcmp(id, "fb6"))
+		win_id = dev_drv->fb1_win_id;
+	else if (!strcmp(id, "fb2") || !strcmp(id, "fb7"))
+		win_id = dev_drv->fb2_win_id;
+	else if (!strcmp(id, "fb3") || !strcmp(id, "fb8"))
+		win_id = dev_drv->fb3_win_id;
+	else if (!strcmp(id, "fb4") || !strcmp(id, "fb9"))
+		win_id = dev_drv->fb4_win_id;
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return win_id;
+}
+
+static int vop_config_done(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	int i;
+	struct rk_lcdc_win *win = NULL;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+			win = dev_drv->win[i];
+			vop_layer_update_regs(vop_dev, win);
+		}
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_dpi_open(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_msk_reg(vop_dev, SYS_CTRL0, V_DIRECT_PATH_EN(open));
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_dpi_win_sel(struct rk_lcdc_driver *dev_drv, int win_id)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		vop_msk_reg(vop_dev, SYS_CTRL0,
+			    V_DIRECT_PATH_LAYER_SEL(win_id));
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	return 0;
+}
+
+static int vop_dpi_status(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	int status = 0;
+
+	spin_lock(&vop_dev->reg_lock);
+
+	if (likely(vop_dev->clk_on))
+		status = vop_read_bit(vop_dev, SYS_CTRL0, V_DIRECT_PATH_EN(0));
+
+	spin_unlock(&vop_dev->reg_lock);
+
+	return status;
+}
+
+static int vop_set_irq_to_cpu(struct rk_lcdc_driver *dev_drv, int enable)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (enable)
+		enable_irq(vop_dev->irq);
+	else
+		disable_irq(vop_dev->irq);
+	return 0;
+}
+
+static int vop_poll_vblank(struct rk_lcdc_driver *dev_drv)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u32 int_reg;
+	int ret;
+
+	if (vop_dev->clk_on && (!dev_drv->suspend_flag)) {
+		int_reg = vop_readl(vop_dev, INTR_STATUS);
+		if (int_reg & INTR_LINE_FLAG0) {
+			vop_dev->driver.frame_time.last_framedone_t =
+			    vop_dev->driver.frame_time.framedone_t;
+			vop_dev->driver.frame_time.framedone_t = cpu_clock(0);
+			vop_mask_writel(vop_dev, INTR_CLEAR, INTR_LINE_FLAG0,
+					INTR_LINE_FLAG0);
+			ret = RK_LF_STATUS_FC;
+		} else {
+			ret = RK_LF_STATUS_FR;
+		}
+	} else {
+		ret = RK_LF_STATUS_NC;
+	}
+
+	return ret;
+}
+
+static int vop_get_dsp_addr(struct rk_lcdc_driver *dev_drv,
+			    unsigned int dsp_addr[][4])
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		dsp_addr[0][0] = vop_readl(vop_dev, WIN0_YRGB_MST);
+		dsp_addr[1][0] = vop_readl(vop_dev, WIN1_YRGB_MST);
+		dsp_addr[2][0] = vop_readl(vop_dev, HWC_MST);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	return 0;
+}
+
+/*
+ * a:[-30~0]:
+ *	sin_hue = sin(a)*256 +0x100;
+ *	cos_hue = cos(a)*256;
+ * a:[0~30]
+ *	sin_hue = sin(a)*256;
+ *	cos_hue = cos(a)*256;
+ */
+static int vop_get_bcsh_hue(struct rk_lcdc_driver *dev_drv, bcsh_hue_mode mode)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u32 val = 0;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		val = vop_readl(vop_dev, BCSH_H);
+		switch (mode) {
+		case H_SIN:
+			val &= MASK(SIN_HUE);
+			val <<= 1;
+			break;
+		case H_COS:
+			val &= MASK(COS_HUE);
+			val >>= 8;
+			val <<= 1;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return val;
+}
+
+static int vop_set_bcsh_hue(struct rk_lcdc_driver *dev_drv,
+			    int sin_hue, int cos_hue)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u64 val;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		/*
+		 * config range is [0, 510), typical value is 256
+		 * register range is [0, 255], cos_hue typical value is 128
+		 * sin_hue typical value is 0
+		 */
+		val = V_SIN_HUE(sin_hue >> 1) | V_COS_HUE(cos_hue >> 1);
+		vop_msk_reg(vop_dev, BCSH_H, val);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_set_bcsh_bcs(struct rk_lcdc_driver *dev_drv,
+			    bcsh_bcs_mode mode, int value)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u64 val = 0;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		switch (mode) {
+		case BRIGHTNESS:
+			/*
+			 * user range is [0, 255], typical value is 128
+			 * register range is [-32, 31], typical value is 0
+			 */
+			value >>= 2; /* 0-->32-->63 for user, typical is 32 */
+			if (value < 0x20)
+				value += 0x20;
+			else if (value >= 0x20)
+				value = value - 0x20;
+			val = V_BRIGHTNESS(value);
+			break;
+		case CONTRAST:
+			/*
+			 * config range is [0, 510), typical value is 256
+			 * register range is [0, 255], typical value is 128
+			 */
+			value >>= 1;
+			val = V_CONTRAST(value);
+			break;
+		case SAT_CON:
+			/*
+			 * config range is [0, 1015], typical value is 512
+			 * register range is [0, 255], typical value is 128
+			 */
+			value >>= 2;
+			val = V_SAT_CON(value);
+			break;
+		default:
+			break;
+		}
+		vop_msk_reg(vop_dev, BCSH_BCS, val);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return val;
+}
+
+static int vop_get_bcsh_bcs(struct rk_lcdc_driver *dev_drv, bcsh_bcs_mode mode)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+	u64 val = 0;
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		val = vop_readl(vop_dev, BCSH_BCS);
+		switch (mode) {
+		case BRIGHTNESS:
+			val &= MASK(BRIGHTNESS);
+			if (val >= 0x20)
+				val -= 0x20;
+			else
+				val += 0x20;
+			val <<= 2;
+			break;
+		case CONTRAST:
+			val &= MASK(CONTRAST);
+			val >>= 8;
+			val <<= 1;
+			break;
+		case SAT_CON:
+			val &= MASK(SAT_CON);
+			val >>= 16;
+			val <<= 2;
+			break;
+		default:
+			break;
+		}
+	}
+	spin_unlock(&vop_dev->reg_lock);
+	return val;
+}
+
+static int vop_open_bcsh(struct rk_lcdc_driver *dev_drv, bool open)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	spin_lock(&vop_dev->reg_lock);
+	if (likely(vop_dev->clk_on)) {
+		if (open) {
+			vop_writel(vop_dev, BCSH_BCS,
+				   V_BRIGHTNESS(0x00) | V_CONTRAST(0x80) |
+				   V_SAT_CON(0x80));
+			vop_writel(vop_dev, BCSH_H,
+				   V_SIN_HUE(0x00) | V_COS_HUE(0x80));
+			vop_msk_reg(vop_dev, BCSH_CTRL, V_BCSH_EN(1) |
+				    V_VIDEO_MODE(BCSH_MODE_VIDEO));
+			dev_drv->bcsh.enable = 1;
+		} else {
+			vop_msk_reg(vop_dev, BCSH_CTRL, V_BCSH_EN(0));
+			dev_drv->bcsh.enable = 0;
+		}
+		vop_bcsh_path_sel(dev_drv);
+		vop_cfg_done(vop_dev);
+	}
+	spin_unlock(&vop_dev->reg_lock);
+
+	return 0;
+}
+
+static int vop_set_bcsh(struct rk_lcdc_driver *dev_drv, bool enable)
+{
+	if (!enable || !dev_drv->bcsh.enable) {
+		vop_open_bcsh(dev_drv, false);
+		return 0;
+	}
+
+	if (dev_drv->bcsh.brightness <= 255 ||
+	    dev_drv->bcsh.contrast < 510 ||
+	    dev_drv->bcsh.sat_con <= 1015 ||
+	    (dev_drv->bcsh.sin_hue < 510 && dev_drv->bcsh.cos_hue < 510)) {
+		vop_open_bcsh(dev_drv, true);
+		if (dev_drv->bcsh.brightness <= 255)
+			vop_set_bcsh_bcs(dev_drv, BRIGHTNESS,
+					 dev_drv->bcsh.brightness);
+		if (dev_drv->bcsh.contrast < 510)
+			vop_set_bcsh_bcs(dev_drv, CONTRAST,
+					 dev_drv->bcsh.contrast);
+		if (dev_drv->bcsh.sat_con <= 1015)
+			vop_set_bcsh_bcs(dev_drv, SAT_CON,
+					 dev_drv->bcsh.sat_con);
+		if (dev_drv->bcsh.sin_hue < 510 &&
+		    dev_drv->bcsh.cos_hue < 510)
+			vop_set_bcsh_hue(dev_drv, dev_drv->bcsh.sin_hue,
+					 dev_drv->bcsh.cos_hue);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused
+vop_dsp_black(struct rk_lcdc_driver *dev_drv, int enable)
+{
+	struct vop_device *vop_dev = to_vop_dev(dev_drv);
+
+	if (enable) {
+		spin_lock(&vop_dev->reg_lock);
+		if (likely(vop_dev->clk_on)) {
+			vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLACK_EN(1));
+			vop_cfg_done(vop_dev);
+		}
+		spin_unlock(&vop_dev->reg_lock);
+	} else {
+		spin_lock(&vop_dev->reg_lock);
+		if (likely(vop_dev->clk_on)) {
+			vop_msk_reg(vop_dev, DSP_CTRL0, V_DSP_BLACK_EN(0));
+			vop_cfg_done(vop_dev);
+		}
+		spin_unlock(&vop_dev->reg_lock);
+	}
+
+	return 0;
+}
+
+static struct rk_lcdc_drv_ops lcdc_drv_ops = {
+	.open = vop_open,
+	.win_direct_en = vop_win_direct_en,
+	.load_screen = vop_load_screen,
+	.get_dspbuf_info = vop_get_dspbuf_info,
+	.post_dspbuf = vop_post_dspbuf,
+	.set_par = vop_set_par,
+	.pan_display = vop_pan_display,
+	.direct_set_addr = vop_direct_set_win_addr,
+	.blank = vop_blank,
+	.ioctl = vop_ioctl,
+	.suspend = vop_early_suspend,
+	.resume = vop_early_resume,
+	.get_win_state = vop_get_win_state,
+	.area_support_num = vop_get_area_num,
+	.ovl_mgr = vop_ovl_mgr,
+	.get_disp_info = vop_get_disp_info,
+	.fps_mgr = vop_fps_mgr,
+	.fb_get_win_id = vop_get_win_id,
+	.fb_win_remap = vop_fb_win_remap,
+	.poll_vblank = vop_poll_vblank,
+	.dpi_open = vop_dpi_open,
+	.dpi_win_sel = vop_dpi_win_sel,
+	.dpi_status = vop_dpi_status,
+	.get_dsp_addr = vop_get_dsp_addr,
+	.set_dsp_bcsh_hue = vop_set_bcsh_hue,
+	.set_dsp_bcsh_bcs = vop_set_bcsh_bcs,
+	.get_dsp_bcsh_hue = vop_get_bcsh_hue,
+	.get_dsp_bcsh_bcs = vop_get_bcsh_bcs,
+	.open_bcsh = vop_open_bcsh,
+	.set_dsp_lut = vop_set_lut,
+	.set_hwc_lut = vop_set_hwc_lut,
+	.dump_reg = vop_reg_dump,
+	.cfg_done = vop_config_done,
+	.set_irq_to_cpu = vop_set_irq_to_cpu,
+	/*.dsp_black = vop_dsp_black,*/
+	.backlight_close = vop_backlight_close,
+	.mmu_en = vop_mmu_enable,
+};
+
+static irqreturn_t vop_isr(int irq, void *dev_id)
+{
+	struct vop_device *vop_dev = (struct vop_device *)dev_id;
+	ktime_t timestamp = ktime_get();
+	u32 intr_status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&vop_dev->irq_lock, flags);
+
+	intr_status = vop_readl(vop_dev, INTR_STATUS);
+	vop_mask_writel(vop_dev, INTR_CLEAR, INTR_MASK, intr_status);
+
+	spin_unlock_irqrestore(&vop_dev->irq_lock, flags);
+
+	intr_status &= 0xffff;	/* ignore raw status at 16~32bit */
+	/* This is expected for vop iommu irqs, since the irq is shared */
+	if (!intr_status)
+		return IRQ_NONE;
+
+	if (intr_status & INTR_FS0) {
+		timestamp = ktime_get();
+		vop_dev->driver.vsync_info.timestamp = timestamp;
+		wake_up_interruptible_all(&vop_dev->driver.vsync_info.wait);
+		complete(&vop_dev->sync.frmst);
+		intr_status &= ~INTR_FS0;
+	}
+
+	/* fs1 interrupt occur only when the address is different */
+	if (intr_status & INTR_FS1)
+		intr_status &= ~INTR_FS1;
+
+	if (intr_status & INTR_ADDR_SAME)
+		intr_status &= ~INTR_ADDR_SAME;
+
+	if (intr_status & INTR_DSP_HOLD_VALID) {
+		complete(&vop_dev->sync.stdbyfin);
+		intr_status &= ~INTR_DSP_HOLD_VALID;
+	}
+
+	if (intr_status & INTR_LINE_FLAG0)
+		intr_status &= ~INTR_LINE_FLAG0;
+
+	if (intr_status & INTR_LINE_FLAG1)
+		intr_status &= ~INTR_LINE_FLAG1;
+
+	if (intr_status & INTR_BUS_ERROR) {
+		intr_status &= ~INTR_BUS_ERROR;
+		dev_warn_ratelimited(vop_dev->dev, "bus error!");
+	}
+
+	if (intr_status & INTR_WIN0_EMPTY) {
+		intr_status &= ~INTR_WIN0_EMPTY;
+		dev_warn_ratelimited(vop_dev->dev, "intr win0 empty!");
+	}
+
+	if (intr_status & INTR_WIN1_EMPTY) {
+		intr_status &= ~INTR_WIN1_EMPTY;
+		dev_warn_ratelimited(vop_dev->dev, "intr win1 empty!");
+	}
+
+	if (intr_status & INTR_DMA_FINISH)
+		intr_status &= ~INTR_DMA_FINISH;
+
+	if (intr_status & INTR_MMU_STATUS)
+		intr_status &= ~INTR_MMU_STATUS;
+
+	if (intr_status)
+		dev_err(vop_dev->dev, "Unknown VOP IRQs: %#02x\n", intr_status);
+
+	return IRQ_HANDLED;
+}
+
+#if defined(CONFIG_PM)
+static int vop_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int vop_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define vop_suspend NULL
+#define vop_resume  NULL
+#endif
+
+static int vop_parse_dt(struct vop_device *vop_dev)
+{
+	struct device_node *np = vop_dev->dev->of_node;
+	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
+	int val;
+
+	if (of_property_read_u32(np, "rockchip,prop", &val))
+		vop_dev->prop = PRMRY;	/*default set it as primary */
+	else
+		vop_dev->prop = val;
+
+	if (of_property_read_u32(np, "rockchip,mirror", &val))
+		dev_drv->rotate_mode = NO_MIRROR;
+	else
+		dev_drv->rotate_mode = val;
+
+	if (of_property_read_u32(np, "rockchip,pwr18", &val))
+		/*default set it as 3.xv power supply */
+		vop_dev->pwr18 = false;
+	else
+		vop_dev->pwr18 = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,fb-win-map", &val))
+		dev_drv->fb_win_map = FB_DEFAULT_ORDER;
+	else
+		dev_drv->fb_win_map = val;
+
+	if (of_property_read_u32(np, "rockchip,bcsh-en", &val))
+		dev_drv->bcsh.enable = false;
+	else
+		dev_drv->bcsh.enable = (val ? true : false);
+
+	if (of_property_read_u32(np, "rockchip,brightness", &val))
+		dev_drv->bcsh.brightness = 0xffff;
+	else
+		dev_drv->bcsh.brightness = val;
+
+	if (of_property_read_u32(np, "rockchip,contrast", &val))
+		dev_drv->bcsh.contrast = 0xffff;
+	else
+		dev_drv->bcsh.contrast = val;
+
+	if (of_property_read_u32(np, "rockchip,sat-con", &val))
+		dev_drv->bcsh.sat_con = 0xffff;
+	else
+		dev_drv->bcsh.sat_con = val;
+
+	if (of_property_read_u32(np, "rockchip,hue", &val)) {
+		dev_drv->bcsh.sin_hue = 0xffff;
+		dev_drv->bcsh.cos_hue = 0xffff;
+	} else {
+		dev_drv->bcsh.sin_hue = val & 0xff;
+		dev_drv->bcsh.cos_hue = (val >> 8) & 0xff;
+	}
+
+	if (of_property_read_u32(np, "rockchip,iommu-enabled", &val))
+		dev_drv->iommu_enabled = 0;
+	else
+		dev_drv->iommu_enabled = val;
+
+	return 0;
+}
+
+static int vop_probe(struct platform_device *pdev)
+{
+	struct vop_device *vop_dev = NULL;
+	struct rk_lcdc_driver *dev_drv;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	int prop;
+	int ret = 0;
+
+	/*
+	 * if the primary lcdc has not registered ,the extend
+	 * lcdc register later
+	 */
+	of_property_read_u32(np, "rockchip,prop", &prop);
+	if (prop == EXTEND) {
+		if (!is_prmry_rk_lcdc_registered())
+			return -EPROBE_DEFER;
+	}
+
+	vop_dev = devm_kzalloc(dev, sizeof(struct vop_device), GFP_KERNEL);
+	if (!vop_dev)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, vop_dev);
+	vop_dev->dev = dev;
+	vop_parse_dt(vop_dev);
+
+	/* enable power domain */
+	pm_runtime_enable(dev);
+
+	vop_dev->hclk = devm_clk_get(vop_dev->dev, "hclk_lcdc");
+	if (IS_ERR(vop_dev->hclk)) {
+		dev_err(vop_dev->dev, "failed to get hclk source\n");
+		return PTR_ERR(vop_dev->hclk);
+	}
+
+	vop_dev->aclk = devm_clk_get(vop_dev->dev, "aclk_lcdc");
+	if (IS_ERR(vop_dev->aclk)) {
+		dev_err(vop_dev->dev, "failed to get aclk source\n");
+		return PTR_ERR(vop_dev->aclk);
+	}
+	vop_dev->dclk = devm_clk_get(vop_dev->dev, "dclk_lcdc");
+	if (IS_ERR(vop_dev->dclk)) {
+		dev_err(vop_dev->dev, "failed to get dclk source\n");
+		return PTR_ERR(vop_dev->dclk);
+	}
+
+	clk_prepare(vop_dev->hclk);
+	clk_prepare(vop_dev->aclk);
+	clk_prepare(vop_dev->dclk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	vop_dev->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(vop_dev->regs)) {
+		ret = PTR_ERR(vop_dev->regs);
+		goto err_exit;
+	}
+
+	vop_dev->reg_phy_base = res->start;
+	vop_dev->len = resource_size(res);
+	vop_dev->regsbak = devm_kzalloc(dev, vop_dev->len, GFP_KERNEL);
+	if (!vop_dev->regsbak) {
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+
+	vop_dev->hwc_lut_addr_base = (vop_dev->regs + HWC_LUT_ADDR);
+	vop_dev->dsp_lut_addr_base = (vop_dev->regs + GAMMA_LUT_ADDR);
+	vop_dev->grf_base = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(vop_dev->grf_base)) {
+		dev_err(vop_dev->dev, "ERROR!! can't find grf reg property\n");
+		vop_dev->grf_base = NULL;
+	}
+
+	vop_dev->id = 1;
+	dev_set_name(vop_dev->dev, "vop%d", vop_dev->id);
+	dev_drv = &vop_dev->driver;
+	dev_drv->dev = dev;
+	dev_drv->prop = prop;
+	dev_drv->id = vop_dev->id;
+	dev_drv->ops = &lcdc_drv_ops;
+	dev_drv->lcdc_win_num = ARRAY_SIZE(vop_win);
+	dev_drv->reserved_fb = 0;
+	spin_lock_init(&vop_dev->reg_lock);
+	spin_lock_init(&vop_dev->irq_lock);
+	init_completion(&vop_dev->sync.stdbyfin);
+	init_completion(&vop_dev->sync.frmst);
+	vop_dev->sync.stdbyfin_to = 50;	/* timeout 50 ms */
+	vop_dev->sync.frmst_to = 50;
+
+	vop_dev->irq = platform_get_irq(pdev, 0);
+	if (vop_dev->irq < 0) {
+		dev_err(dev, "cannot find IRQ for lcdc%d\n", vop_dev->id);
+		ret = vop_dev->irq;
+		goto err_exit;
+	}
+
+	ret = devm_request_irq(dev, vop_dev->irq, vop_isr,
+			       IRQF_SHARED,
+			       dev_name(dev), vop_dev);
+	if (ret) {
+		dev_err(dev, "cannot requeset irq %d - err %d\n",
+			vop_dev->irq, ret);
+		goto err_exit;
+	}
+
+	if (dev_drv->iommu_enabled)
+		strcpy(dev_drv->mmu_dts_name, VOPL_IOMMU_COMPATIBLE_NAME);
+
+	ret = rk_fb_register(dev_drv, vop_win, vop_dev->id);
+	if (ret < 0) {
+		dev_err(dev, "register fb for failed!\n");
+		goto err_exit;
+	}
+	vop_dev->screen = dev_drv->screen0;
+	dev_info(dev, "lcdc%d probe ok, iommu %s\n",
+		 vop_dev->id, dev_drv->iommu_enabled ? "enabled" : "disabled");
+
+	return 0;
+
+err_exit:
+	clk_unprepare(vop_dev->dclk);
+	clk_unprepare(vop_dev->aclk);
+	clk_unprepare(vop_dev->hclk);
+	pm_runtime_disable(dev);
+
+	return ret;
+}
+
+static int vop_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void vop_shutdown(struct platform_device *pdev)
+{
+	struct vop_device *vop_dev = platform_get_drvdata(pdev);
+	struct rk_lcdc_driver *dev_drv = &vop_dev->driver;
+
+	dev_drv->suspend_flag = 1;
+	smp_wmb();
+	flush_kthread_worker(&dev_drv->update_regs_worker);
+	kthread_stop(dev_drv->update_regs_thread);
+
+	if (dev_drv->trsm_ops && dev_drv->trsm_ops->disable)
+		dev_drv->trsm_ops->disable();
+
+	vop_deinit(vop_dev);
+	rk_disp_pwr_disable(dev_drv);
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id vop_dt_ids[] = {
+	{.compatible = "rockchip,rk3366-lcdc-lite",},
+	{}
+};
+#endif
+
+static struct platform_driver vop_driver = {
+	.probe = vop_probe,
+	.remove = vop_remove,
+	.driver = {
+		   .name = "rk-vop-lite",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(vop_dt_ids),
+		   },
+	.suspend = vop_suspend,
+	.resume = vop_resume,
+	.shutdown = vop_shutdown,
+};
+
+static int __init vop_module_init(void)
+{
+	return platform_driver_register(&vop_driver);
+}
+
+static void __exit vop_module_exit(void)
+{
+	platform_driver_unregister(&vop_driver);
+}
+
+fs_initcall(vop_module_init);
+module_exit(vop_module_exit);
diff -Nupr a/drivers/video/rockchip/lcdc/rk_vop_lite.h b/drivers/video/rockchip/lcdc/rk_vop_lite.h
--- a/drivers/video/rockchip/lcdc/rk_vop_lite.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/lcdc/rk_vop_lite.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,649 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef RK_VOPLITE_H_
+#define RK_VOPLITE_H_
+
+#include <linux/rk_fb.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+
+#define VOP_INPUT_MAX_WIDTH 2048
+
+/*
+ * Registers in this file
+ * REG_CFG_DONE: Register config done flag
+ * VERSION_INFO: Version for vop
+ * DSP_BG: Background color
+ * MCU_RESERVED: Reversed
+ * SYS_CTRL0: System control register0
+ * SYS_CTRL1: Axi Bus interface control register
+ * SYS_CTRL2: System control register for immediate reg
+ * DSP_CTRL0: Display control register0
+ * DSP_CTRL2: Display control register2
+ * VOP_STATUS: Some vop module status
+ * LINE_FLAG: Line flag config register
+ * INTR_EN: Interrupt enable register
+ * INTR_CLEAR: Interrupt clear register
+ * INTR_STATUS: Interrupt raw status and interrupt status
+ * WIN0_CTRL0: Win0 ctrl register0
+ * WIN0_CTRL1: Win0 ctrl register1
+ * WIN0_COLOR_KEY: Win0 color key register
+ * WIN0_VIR: Win0 virtual stride
+ * WIN0_YRGB_MST: Win0 YRGB memory start address
+ * WIN0_CBR_MST: Win0 Cbr memory start address
+ * WIN0_ACT_INFO: Win0 active window width/height
+ * WIN0_DSP_INFO: Win0 display width/height on panel
+ * WIN0_DSP_ST: Win0 display start point on panel
+ * WIN0_SCL_FACTOR_YRGB: Win0 YRGB scaling factor
+ * WIN0_SCL_FACTOR_CBR: Win0 Cbr scaling factor
+ * WIN0_SCL_OFFSET: Win0 scaling start point offset
+ * WIN0_ALPHA_CTRL: Win0 Blending control register
+ * WIN1_CTRL0: Win1 ctrl register0
+ * WIN1_CTRL1: Win1 ctrl register1
+ * WIN1_VIR: win1 virtual stride
+ * WIN1_YRGB_MST: Win1 frame buffer memory start address
+ * WIN1_DSP_INFO: Win1 display width/height on panel
+ * WIN1_DSP_ST: Win1 display start point on panel
+ * WIN1_COLOR_KEY: Win1 color key register
+ * WIN1_ALPHA_CTRL: Win1 Blending control register
+ * HWC_CTRL0: Hwc ctrl register0
+ * HWC_CTRL1: Hwc ctrl register1
+ * HWC_MST: Hwc memory start address
+ * HWC_DSP_ST: Hwc display start point on panel
+ * HWC_ALPHA_CTRL: Hwc blending control register
+ * DSP_HTOTAL_HS_END: Panel scanning horizontal width and hsync pulse end point
+ * DSP_HACT_ST_END: Panel active horizontal scanning start point and end point
+ * DSP_VTOTAL_VS_END: Panel scanning vertical height and vsync pulse end point
+ * DSP_VACT_ST_END: Panel active vertical scanning start point and end point
+ * DSP_VS_ST_END_F1: Vertical scanning start point and vsync pulse end point
+ *                   of even filed in interlace mode
+ * DSP_VACT_ST_END_F1: Vertical scanning active start point and end point of
+ *                     even filed in interlace mode
+ * BCSH_CTRL: BCSH contrl register
+ * BCSH_COLOR_BAR: Color bar config register
+ * BCSH_BCS: Brightness contrast saturation*contrast config register
+ * BCSH_H: Sin hue and cos hue config register
+ * FRC_LOWER01_0: FRC lookup table config register010
+ * FRC_LOWER01_1: FRC lookup table config register011
+ * FRC_LOWER10_0: FRC lookup table config register100
+ * FRC_LOWER10_1: FRC lookup table config register101
+ * FRC_LOWER11_0: FRC lookup table config register110
+ * FRC_LOWER11_1: FRC lookup table config register111
+ * DBG_REG_00:	Current line number of dsp timing
+ * BLANKING_VALUE: The value of vsync blanking
+ * FLAG_REG_FRM_VALID: Flag reg value after frame valid
+ * FLAG_REG: Flag reg value before frame valid
+ * HWC_LUT_ADDR: Hwc lut base address
+ * GAMMA_LUT_ADDR: GAMMA lut base address
+ */
+
+static inline u64 val_mask(int val, u64 msk, int shift)
+{
+	return (msk << (shift + 32)) | ((msk & val) << shift);
+}
+
+#define VAL_MASK(x, width, shift) val_mask(x, (1 << width) - 1, shift)
+
+#define MASK(x) (V_##x(0) >> 32)
+
+#define REG_CFG_DONE			0x00000000
+#define  V_REG_LOAD_GLOBAL_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_REG_LOAD_WIN0_EN(x)			VAL_MASK(x, 1, 1)
+#define  V_REG_LOAD_WIN1_EN(x)			VAL_MASK(x, 1, 2)
+#define  V_REG_LOAD_HWC_EN(x)			VAL_MASK(x, 1, 3)
+#define  V_REG_LOAD_IEP_EN(x)			VAL_MASK(x, 1, 4)
+#define  V_REG_LOAD_SYS_EN(x)			VAL_MASK(x, 1, 5)
+#define VERSION				0x00000004
+#define  V_BUILD(x)				VAL_MASK(x, 16, 0)
+#define  V_MINOR(x)				VAL_MASK(x, 8, 16)
+#define  V_MAJOR(x)				VAL_MASK(x, 8, 24)
+#define DSP_BG				0x00000008
+#define  V_DSP_BG_BLUE(x)			VAL_MASK(x, 8, 0)
+#define  V_DSP_BG_GREEN(x)			VAL_MASK(x, 8, 8)
+#define  V_DSP_BG_RED(x)			VAL_MASK(x, 8, 16)
+#define MCU_RESERVED			0x0000000c
+#define SYS_CTRL0			0x00000010
+#define  V_DIRECT_PATH_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_DIRECT_PATH_LAYER_SEL(x)		VAL_MASK(x, 1, 1)
+#define SYS_CTRL1			0x00000014
+#define  V_SW_NOC_QOS_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_SW_NOC_QOS_VALUE(x)			VAL_MASK(x, 2, 1)
+#define  V_SW_NOC_HURRY_EN(x)			VAL_MASK(x, 1, 4)
+#define  V_SW_NOC_HURRY_VALUE(x)		VAL_MASK(x, 2, 5)
+#define  V_SW_NOC_HURRY_THRESHOLD(x)		VAL_MASK(x, 4, 8)
+#define  V_SW_AXI_MAX_OUTSTAND_EN(x)		VAL_MASK(x, 1, 12)
+#define  V_SW_AXI_MAX_OUTSTAND_NUM(x)		VAL_MASK(x, 5, 16)
+#define SYS_CTRL2			0x00000018
+#define  V_IMD_AUTO_GATING_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_IMD_VOP_STANDBY_EN(x)		VAL_MASK(x, 1, 1)
+#define  V_IMD_VOP_DMA_STOP(x)			VAL_MASK(x, 1, 2)
+#define  V_IMD_DSP_OUT_ZERO(x)			VAL_MASK(x, 1, 3)
+#define  V_IMD_YUV_CLIP(x)			VAL_MASK(x, 1, 4)
+#define  V_IMD_DSP_DATA_OUT_MODE(x)		VAL_MASK(x, 1, 6)
+#define  V_SW_IO_PAD_CLK_SEL(x)			VAL_MASK(x, 1, 7)
+#define  V_IMD_DSP_TIMING_IMD(x)		VAL_MASK(x, 1, 12)
+#define  V_IMD_GLOBAL_REGDONE_EN(x)		VAL_MASK(x, 1, 13)
+#define  V_FS_ADDR_MASK_EN(x)			VAL_MASK(x, 1, 14)
+#define DSP_CTRL0			0x00000020
+#define  V_RGB_DCLK_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_RGB_DCLK_POL(x)			VAL_MASK(x, 1, 1)
+#define  V_RGB_HSYNC_POL(x)			VAL_MASK(x, 1, 2)
+#define  V_RGB_VSYNC_POL(x)			VAL_MASK(x, 1, 3)
+#define  V_RGB_DEN_POL(x)			VAL_MASK(x, 1, 4)
+#define  V_HDMI_DCLK_EN(x)			VAL_MASK(x, 1, 8)
+#define  V_HDMI_DCLK_POL(x)			VAL_MASK(x, 1, 9)
+#define  V_HDMI_HSYNC_POL(x)			VAL_MASK(x, 1, 10)
+#define  V_HDMI_VSYNC_POL(x)			VAL_MASK(x, 1, 11)
+#define  V_HDMI_DEN_POL(x)			VAL_MASK(x, 1, 12)
+#define  V_SW_CORE_CLK_SEL(x)			VAL_MASK(x, 1, 13)
+#define  V_SW_HDMI_CLK_I_SEL(x)			VAL_MASK(x, 1, 14)
+#define  V_LVDS_DCLK_EN(x)			VAL_MASK(x, 1, 16)
+#define  V_LVDS_DCLK_POL(x)			VAL_MASK(x, 1, 17)
+#define  V_LVDS_HSYNC_POL(x)			VAL_MASK(x, 1, 18)
+#define  V_LVDS_VSYNC_POL(x)			VAL_MASK(x, 1, 19)
+#define  V_LVDS_DEN_POL(x)			VAL_MASK(x, 1, 20)
+#define  V_MIPI_DCLK_EN(x)			VAL_MASK(x, 1, 24)
+#define  V_MIPI_DCLK_POL(x)			VAL_MASK(x, 1, 25)
+#define  V_MIPI_HSYNC_POL(x)			VAL_MASK(x, 1, 26)
+#define  V_MIPI_VSYNC_POL(x)			VAL_MASK(x, 1, 27)
+#define  V_MIPI_DEN_POL(x)			VAL_MASK(x, 1, 28)
+#define DSP_CTRL2			0x00000028
+#define  V_DSP_INTERLACE(x)			VAL_MASK(x, 1, 0)
+#define  V_INTERLACE_FIELD_POL(x)		VAL_MASK(x, 1, 1)
+#define  V_DITHER_UP(x)				VAL_MASK(x, 1, 2)
+#define  V_DSP_WIN0_TOP(x)			VAL_MASK(x, 1, 3)
+#define  V_SW_OVERLAY_MODE(x)			VAL_MASK(x, 1, 4)
+#define  V_DSP_LUT_EN(x)			VAL_MASK(x, 1, 5)
+#define  V_DITHER_DOWN_MODE(x)			VAL_MASK(x, 1, 6)
+#define  V_DITHER_DOWN_SEL(x)			VAL_MASK(x, 1, 7)
+#define  V_DITHER_DOWN(x)			VAL_MASK(x, 1, 8)
+#define  V_DSP_BG_SWAP(x)			VAL_MASK(x, 1, 9)
+#define  V_DSP_DELTA_SWAP(x)			VAL_MASK(x, 1, 10)
+#define  V_DSP_RB_SWAP(x)			VAL_MASK(x, 1, 11)
+#define  V_DSP_RG_SWAP(x)			VAL_MASK(x, 1, 12)
+#define  V_DSP_DUMMY_SWAP(x)			VAL_MASK(x, 1, 13)
+#define  V_DSP_BLANK_EN(x)			VAL_MASK(x, 1, 14)
+#define  V_DSP_BLACK_EN(x)			VAL_MASK(x, 1, 15)
+#define  V_DSP_OUT_MODE(x)			VAL_MASK(x, 4, 16)
+#define VOP_STATUS			0x0000002c
+#define  V_DSP_BLANKING_EN_ASYNC_AFF2(x)	VAL_MASK(x, 1, 0)
+#define  V_IDLE_MMU_FF1(x)			VAL_MASK(x, 1, 1)
+#define  V_INT_RAW_DMA_FINISH(x)		VAL_MASK(x, 1, 2)
+#define  V_DMA_STOP_VALID(x)			VAL_MASK(x, 1, 4)
+#define LINE_FLAG			0x00000030
+#define  V_DSP_LINE_FLAG0_NUM(x)		VAL_MASK(x, 12, 0)
+#define  V_DSP_LINE_FLAG1_NUM(x)		VAL_MASK(x, 12, 16)
+#define INTR_EN				0x00000034
+#define  V_FS0_INTR_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_FS1_INTR_EN(x)			VAL_MASK(x, 1, 1)
+#define  V_ADDR_SAME_INTR_EN(x)			VAL_MASK(x, 1, 2)
+#define  V_LINE_FLAG0_INTR_EN(x)		VAL_MASK(x, 1, 3)
+#define  V_LINE_FLAG1_INTR_EN(x)		VAL_MASK(x, 1, 4)
+#define  V_BUS_ERROR_INTR_EN(x)			VAL_MASK(x, 1, 5)
+#define  V_WIN0_EMPTY_INTR_EN(x)		VAL_MASK(x, 1, 6)
+#define  V_WIN1_EMPTY_INTR_EN(x)		VAL_MASK(x, 1, 7)
+#define  V_DSP_HOLD_VALID_INTR_EN(x)		VAL_MASK(x, 1, 8)
+#define  V_DMA_FRM_FSH_INTR_EN(x)		VAL_MASK(x, 1, 9)
+#define INTR_CLEAR			0x00000038
+#define  V_FS0_INTR_CLR(x)			VAL_MASK(x, 1, 0)
+#define  V_FS1_INTR_CLR(x)			VAL_MASK(x, 1, 1)
+#define  V_ADDR_SAME_INTR_CLR(x)		VAL_MASK(x, 1, 2)
+#define  V_LINE_FLAG0_INTR_CLR(x)		VAL_MASK(x, 1, 3)
+#define  V_LINE_FLAG1_INTR_CLR(x)		VAL_MASK(x, 1, 4)
+#define  V_BUS_ERROR_INTR_CLR(x)		VAL_MASK(x, 1, 5)
+#define  V_WIN0_EMPTY_INTR_CLR(x)		VAL_MASK(x, 1, 6)
+#define  V_WIN1_EMPTY_INTR_CLR(x)		VAL_MASK(x, 1, 7)
+#define  V_DSP_HOLD_VALID_INTR_CLR(x)		VAL_MASK(x, 1, 8)
+#define  V_DMA_FRM_FSH_INTR_CLR(x)		VAL_MASK(x, 1, 9)
+#define INTR_STATUS			0x0000003c
+#define  V_FS0_INTR_STS(x)			VAL_MASK(x, 1, 0)
+#define  V_FS1_INTR_STS(x)			VAL_MASK(x, 1, 1)
+#define  V_ADDR_SAME_INTR_STS(x)		VAL_MASK(x, 1, 2)
+#define  V_LINE_FLAG0_INTR_STS(x)		VAL_MASK(x, 1, 3)
+#define  V_LINE_FLAG1_INTR_STS(x)		VAL_MASK(x, 1, 4)
+#define  V_BUS_ERROR_INTR_STS(x)		VAL_MASK(x, 1, 5)
+#define  V_WIN0_EMPTY_INTR_STS(x)		VAL_MASK(x, 1, 6)
+#define  V_WIN1_EMPTY_INTR_STS(x)		VAL_MASK(x, 1, 7)
+#define  V_DSP_HOLD_VALID_INTR_STS(x)		VAL_MASK(x, 1, 8)
+#define  V_DMA_FRM_FSH_INTR_STS(x)		VAL_MASK(x, 1, 9)
+#define  V_MMU_INTR_STATUS(x)			VAL_MASK(x, 1, 15)
+#define  V_FS0_INTR_RAW_STS(x)			VAL_MASK(x, 1, 16)
+#define  V_FS1_INTR_RAW_STS(x)			VAL_MASK(x, 1, 17)
+#define  V_ADDR_SAME_INTR_RAW_STS(x)		VAL_MASK(x, 1, 18)
+#define  V_LINE_FLAG0_INTR_RAW_STS(x)		VAL_MASK(x, 1, 19)
+#define  V_LINE_FLAG1_INTR_RAW_STS(x)		VAL_MASK(x, 1, 20)
+#define  V_BUS_ERROR_INTR_RAW_STS(x)		VAL_MASK(x, 1, 21)
+#define  V_WIN0_EMPTY_INTR_RAW_STS(x)		VAL_MASK(x, 1, 22)
+#define  V_WIN1_EMPTY_INTR_RAW_STS(x)		VAL_MASK(x, 1, 23)
+#define  V_DSP_HOLD_VALID_INTR_RAW_STS(x)	VAL_MASK(x, 1, 24)
+#define  V_DMA_FRM_FSH_INTR_RAW_STS(x)		VAL_MASK(x, 1, 25)
+#define WIN0_CTRL0			0x00000050
+#define  V_WIN0_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_WIN0_DATA_FMT(x)			VAL_MASK(x, 3, 1)
+#define  V_WIN0_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
+#define  V_WIN0_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 9)
+#define  V_WIN0_CSC_MODE(x)			VAL_MASK(x, 2, 10)
+#define  V_WIN0_RB_SWAP(x)			VAL_MASK(x, 1, 12)
+#define  V_WIN0_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
+#define  V_WIN0_MID_SWAP(x)			VAL_MASK(x, 1, 14)
+#define  V_WIN0_UV_SWAP(x)			VAL_MASK(x, 1, 15)
+#define  V_WIN0_YRGB_DEFLICK(x)			VAL_MASK(x, 1, 18)
+#define  V_WIN0_CBR_DEFLICK(x)			VAL_MASK(x, 1, 19)
+#define WIN0_CTRL1			0x00000054
+#define  V_WIN0_YRGB_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_WIN0_CBR_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 1)
+#define  V_WIN0_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
+#define  V_WIN0_YRGB_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 4)
+#define  V_WIN0_CBR_AXI_GATHER_NUM(x)		VAL_MASK(x, 3, 8)
+#define  V_SW_WIN0_YRGB0_RID(x)			VAL_MASK(x, 4, 12)
+#define  V_SW_WIN0_CBR0_RID(x)			VAL_MASK(x, 4, 16)
+#define WIN0_COLOR_KEY			0x00000058
+#define  V_WIN0_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
+#define  V_WIN0_KEY_EN(x)			VAL_MASK(x, 1, 24)
+#define WIN0_VIR			0x0000005c
+#define  V_WIN0_YRGB_VIR_STRIDE(x)		VAL_MASK(x, 13, 0)
+#define  V_WIN0_CBR_VIR_STRIDE(x)		VAL_MASK(x, 13, 16)
+#define WIN0_YRGB_MST			0x00000060
+#define WIN0_CBR_MST			0x00000064
+#define WIN0_ACT_INFO			0x00000068
+#define  V_WIN0_ACT_WIDTH(x)			VAL_MASK(x, 13, 0)
+#define  V_WIN0_ACT_HEIGHT(x)			VAL_MASK(x, 13, 16)
+#define WIN0_DSP_INFO			0x0000006c
+#define  V_WIN0_DSP_WIDTH(x)			VAL_MASK(x, 11, 0)
+#define  V_WIN0_DSP_HEIGHT(x)			VAL_MASK(x, 11, 16)
+#define WIN0_DSP_ST			0x00000070
+#define  V_WIN0_DSP_XST(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN0_DSP_YST(x)			VAL_MASK(x, 12, 16)
+#define WIN0_SCL_FACTOR_YRGB		0x00000074
+#define  V_WIN0_HS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 0)
+#define  V_WIN0_VS_FACTOR_YRGB(x)		VAL_MASK(x, 16, 16)
+#define WIN0_SCL_FACTOR_CBR		0x00000078
+#define  V_WIN0_HS_FACTOR_CBR(x)		VAL_MASK(x, 16, 0)
+#define  V_WIN0_VS_FACTOR_CBR(x)		VAL_MASK(x, 16, 16)
+#define WIN0_SCL_OFFSET			0x0000007c
+#define  V_WIN0_HS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 0)
+#define  V_WIN0_HS_OFFSET_CBR(x)		VAL_MASK(x, 8, 8)
+#define  V_WIN0_VS_OFFSET_YRGB(x)		VAL_MASK(x, 8, 16)
+#define  V_WIN0_VS_OFFSET_CBR(x)		VAL_MASK(x, 8, 24)
+#define WIN0_ALPHA_CTRL			0x00000080
+#define  V_WIN0_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_WIN0_ALPHA_MODE(x)			VAL_MASK(x, 1, 1)
+#define  V_WIN0_ALPHA_PRE_MUL(x)		VAL_MASK(x, 1, 2)
+#define  V_WIN0_ALPHA_SAT_MODE(x)		VAL_MASK(x, 1, 3)
+#define  V_WIN0_ALPHA_VALUE(x)			VAL_MASK(x, 8, 4)
+#define WIN1_CTRL0			0x00000090
+#define  V_WIN1_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_WIN1_CSC_MODE(x)			VAL_MASK(x, 1, 2)
+#define  V_WIN1_DATA_FMT(x)			VAL_MASK(x, 3, 4)
+#define  V_WIN1_INTERLACE_READ(x)		VAL_MASK(x, 1, 8)
+#define  V_WIN1_NO_OUTSTANDING(x)		VAL_MASK(x, 1, 9)
+#define  V_WIN1_RB_SWAP(x)			VAL_MASK(x, 1, 12)
+#define  V_WIN1_ALPHA_SWAP(x)			VAL_MASK(x, 1, 13)
+#define  V_WIN1_ENDIAN_SWAP(x)			VAL_MASK(x, 1, 14)
+#define WIN1_CTRL1			0x00000094
+#define  V_WIN1_AXI_GATHER_EN(x)		VAL_MASK(x, 1, 0)
+#define  V_WIN1_DMA_BURST_LENGTH(x)		VAL_MASK(x, 2, 2)
+#define  V_WIN1_AXI_GATHER_NUM(x)		VAL_MASK(x, 4, 4)
+#define  V_SW_WIN1_RID(x)			VAL_MASK(x, 4, 8)
+#define WIN1_VIR			0x00000098
+#define  V_WIN1_VIR_STRIDE(x)			VAL_MASK(x, 13, 0)
+#define WIN1_YRGB_MST			0x000000a0
+#define WIN1_DSP_INFO			0x000000a4
+#define  V_WIN1_DSP_WIDTH(x)			VAL_MASK(x, 11, 0)
+#define  V_WIN1_DSP_HEIGHT(x)			VAL_MASK(x, 11, 16)
+#define WIN1_DSP_ST			0x000000a8
+#define  V_WIN1_DSP_XST(x)			VAL_MASK(x, 12, 0)
+#define  V_WIN1_DSP_YST(x)			VAL_MASK(x, 12, 16)
+#define WIN1_COLOR_KEY			0x000000ac
+#define  V_WIN1_KEY_COLOR(x)			VAL_MASK(x, 24, 0)
+#define  V_WIN1_KEY_EN(x)			VAL_MASK(x, 1, 24)
+#define WIN1_ALPHA_CTRL			0x000000bc
+#define  V_WIN1_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_WIN1_ALPHA_MODE(x)			VAL_MASK(x, 1, 1)
+#define  V_WIN1_ALPHA_PRE_MUL(x)		VAL_MASK(x, 1, 2)
+#define  V_WIN1_ALPHA_SAT_MODE(x)		VAL_MASK(x, 1, 3)
+#define  V_WIN1_ALPHA_VALUE(x)			VAL_MASK(x, 8, 4)
+#define HWC_CTRL0			0x000000e0
+#define  V_HWC_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_HWC_SIZE(x)				VAL_MASK(x, 1, 1)
+#define  V_HWC_LOAD_EN(x)			VAL_MASK(x, 1, 2)
+#define  V_HWC_LUT_EN(x)			VAL_MASK(x, 1, 3)
+#define  V_SW_HWC_RID(x)			VAL_MASK(x, 4, 4)
+#define HWC_CTRL1			0x000000e4
+#define HWC_MST				0x000000e8
+#define HWC_DSP_ST			0x000000ec
+#define  V_HWC_DSP_XST(x)			VAL_MASK(x, 12, 0)
+#define  V_HWC_DSP_YST(x)			VAL_MASK(x, 12, 16)
+#define HWC_ALPHA_CTRL			0x000000f0
+#define  V_HWC_ALPHA_EN(x)			VAL_MASK(x, 1, 0)
+#define  V_HWC_ALPHA_MODE(x)			VAL_MASK(x, 1, 1)
+#define  V_HWC_ALPHA_PRE_MUL(x)			VAL_MASK(x, 1, 2)
+#define  V_HWC_ALPHA_SAT_MODE(x)		VAL_MASK(x, 1, 3)
+#define  V_HWC_ALPHA_VALUE(x)			VAL_MASK(x, 8, 4)
+#define DSP_HTOTAL_HS_END		0x00000100
+#define  V_DSP_HS_END(x)			VAL_MASK(x, 12, 0)
+#define  V_DSP_HTOTAL(x)			VAL_MASK(x, 12, 16)
+#define DSP_HACT_ST_END			0x00000104
+#define  V_DSP_HACT_END(x)			VAL_MASK(x, 12, 0)
+#define  V_DSP_HACT_ST(x)			VAL_MASK(x, 12, 16)
+#define DSP_VTOTAL_VS_END		0x00000108
+#define  V_DSP_VS_END(x)			VAL_MASK(x, 12, 0)
+#define  V_DSP_VTOTAL(x)			VAL_MASK(x, 12, 16)
+#define DSP_VACT_ST_END			0x0000010c
+#define  V_DSP_VACT_END(x)			VAL_MASK(x, 12, 0)
+#define  V_DSP_VACT_ST(x)			VAL_MASK(x, 12, 16)
+#define DSP_VS_ST_END_F1		0x00000110
+#define  V_DSP_VS_END_F1(x)			VAL_MASK(x, 12, 0)
+#define  V_DSP_VS_ST_F1(x)			VAL_MASK(x, 12, 16)
+#define DSP_VACT_ST_END_F1		0x00000114
+#define  V_DSP_VACT_END_F1(x)			VAL_MASK(x, 12, 0)
+#define  V_DSP_VACT_ST_F1(x)			VAL_MASK(x, 12, 16)
+#define BCSH_CTRL			0x00000160
+#define  V_BCSH_EN(x)				VAL_MASK(x, 1, 0)
+#define  V_SW_BCSH_R2Y_CSC_MODE(x)		VAL_MASK(x, 1, 1)
+#define  V_VIDEO_MODE(x)			VAL_MASK(x, 2, 2)
+#define  V_SW_BCSH_Y2R_CSC_MODE(x)		VAL_MASK(x, 2, 4)
+#define  V_SW_BCSH_Y2R_EN(x)			VAL_MASK(x, 1, 6)
+#define  V_SW_BCSH_R2Y_EN(x)			VAL_MASK(x, 1, 7)
+#define BCSH_COL_BAR			0x00000164
+#define  V_COLOR_BAR_Y(x)			VAL_MASK(x, 8, 0)
+#define  V_COLOR_BAR_U(x)			VAL_MASK(x, 8, 8)
+#define  V_COLOR_BAR_V(x)			VAL_MASK(x, 8, 16)
+#define BCSH_BCS			0x00000168
+#define  V_BRIGHTNESS(x)			VAL_MASK(x, 6, 0)
+#define  V_CONTRAST(x)				VAL_MASK(x, 8, 8)
+#define  V_SAT_CON(x)				VAL_MASK(x, 9, 16)
+#define BCSH_H				0x0000016c
+#define  V_SIN_HUE(x)				VAL_MASK(x, 8, 0)
+#define  V_COS_HUE(x)				VAL_MASK(x, 8, 8)
+#define FRC_LOWER01_0			0x00000170
+#define  V_LOWER01_FRM0(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER01_FRM1(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER01_1			0x00000174
+#define  V_LOWER01_FRM2(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER01_FRM3(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER10_0			0x00000178
+#define  V_LOWER10_FRM0(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER10_FRM1(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER10_1			0x0000017c
+#define  V_LOWER10_FRM2(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER10_FRM3(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER11_0			0x00000180
+#define  V_LOWER11_FRM0(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER11_FRM1(x)			VAL_MASK(x, 16, 16)
+#define FRC_LOWER11_1			0x00000184
+#define  V_LOWER11_FRM2(x)			VAL_MASK(x, 16, 0)
+#define  V_LOWER11_FRM3(x)			VAL_MASK(x, 16, 16)
+#define DBG_REG_000			0x00000190
+#define BLANKING_VALUE			0x000001f4
+#define  V_SW_BLANKING_VALUE(x)			VAL_MASK(x, 24, 0)
+#define  V_BLANKING_VALUE_CONFIG_EN(x)		VAL_MASK(x, 1, 24)
+#define FLAG_REG_FRM_VALID		0x000001f8
+#define FLAG_REG			0x000001fc
+#define HWC_LUT_ADDR			0x00000600
+#define GAMMA_LUT_ADDR			0x00000a00
+#define MMU_DTE_ADDR			0x00000f00
+#define MMU_STATUS			0x00000f04
+#define  V_PAGING_ENABLED(x)			VAL_MASK(x, 1, 0)
+#define  V_PAGE_FAULT_ACTIVE(x)			VAL_MASK(x, 1, 1)
+#define  V_STAIL_ACTIVE(x)			VAL_MASK(x, 1, 2)
+#define  V_MMU_IDLE(x)				VAL_MASK(x, 1, 3)
+#define  V_REPLAY_BUFFER_EMPTY(x)		VAL_MASK(x, 1, 4)
+#define  V_PAGE_FAULT_IS_WRITE(x)		VAL_MASK(x, 1, 5)
+#define MMU_COMMAND			0x00000f08
+#define MMU_PAGE_FAULT_ADDR		0x00000f0c
+#define MMU_ZAP_ONE_LINE		0x00000f10
+#define MMU_INT_RAWSTAT			0x00000f14
+#define  V_PAGE_FAULT(x)			VAL_MASK(x, 1, 0)
+#define MMU_INT_CLEAR			0x00000f18
+#define  V_PAGE_FAULT(x)			VAL_MASK(x, 1, 0)
+#define MMU_INT_MASK			0x00000f1c
+#define  V_PAGE_FAULT(x)			VAL_MASK(x, 1, 0)
+#define MMU_INT_STATUS			0x00000f20
+#define  V_PAGE_FAULT(x)			VAL_MASK(x, 1, 0)
+#define MMU_AUTO_GATING			0x00000f24
+#define  V_MMU_AUTO_GATING(x)			VAL_MASK(x, 1, 0)
+#define MMU_CFG_DONE			0x00000f28
+
+#define INTR_FS0		BIT(0)
+#define INTR_FS1		BIT(1)
+#define INTR_ADDR_SAME		BIT(2)
+#define INTR_LINE_FLAG0		BIT(3)
+#define INTR_LINE_FLAG1		BIT(4)
+#define INTR_BUS_ERROR		BIT(5)
+#define INTR_WIN0_EMPTY		BIT(6)
+#define INTR_WIN1_EMPTY		BIT(7)
+#define INTR_DSP_HOLD_VALID	BIT(8)
+#define INTR_DMA_FINISH		BIT(9)
+#define INTR_MMU_STATUS		BIT(15)
+
+#define INTR_MASK (INTR_FS0 | INTR_FS1 | INTR_ADDR_SAME | INTR_LINE_FLAG0 | \
+			INTR_LINE_FLAG1 | INTR_BUS_ERROR | INTR_WIN0_EMPTY | \
+			INTR_WIN1_EMPTY | INTR_DSP_HOLD_VALID | INTR_DMA_FINISH)
+
+/* GRF register for VOP source select */
+#define GRF_WEN_SHIFT(x)	(BIT(x) << 16)
+
+#define GRF_SOC_CON0		0x0400
+#define V_LVDS_VOP_SEL(x)		(((x) << 0) | GRF_WEN_SHIFT(0))
+#define V_HDMI_VOP_SEL(x)		(((x) << 1) | GRF_WEN_SHIFT(1))
+#define V_DSI0_VOP_SEL(x)		(((x) << 2) | GRF_WEN_SHIFT(2))
+
+#define GRF_SOC_CON5		0x0414
+#define V_RGB_VOP_SEL(x)		(((x) << 4) | GRF_WEN_SHIFT(4))
+
+#define GRF_IO_VSEL		0x0900
+#define V_VOP_IOVOL_SEL(x)		(((x) << 0) | GRF_WEN_SHIFT(0))
+
+struct vop_sync_obj_s {
+	struct completion stdbyfin;	/* standby finish */
+	int stdbyfin_to;
+	struct completion frmst;	/* frame start */
+	int frmst_to;
+};
+
+struct vop_device {
+	int id;
+	struct rk_lcdc_driver driver;
+	struct device *dev;
+	struct rk_screen *screen;
+
+	void __iomem *regs;
+	void *regsbak;
+	u32 reg_phy_base;
+	u32 len;
+	void __iomem *hwc_lut_addr_base;
+	void __iomem *dsp_lut_addr_base;
+	struct regmap *grf_base;
+
+	/* one time only one process allowed to config the register */
+	spinlock_t reg_lock;
+
+	int prop;	/* used for primary or extended display device */
+	bool pre_init;
+	bool pwr18;	/* if lcdc use 1.8v power supply */
+	/* if aclk or hclk is closed, access to register is not allowed */
+	bool clk_on;
+	/* active layer counter,when atv_layer_cnt = 0,disable lcdc */
+	u8 atv_layer_cnt;
+
+	unsigned int		irq;
+
+	struct clk		*hclk;	/* lcdc AHP clk */
+	struct clk		*dclk;	/* lcdc dclk */
+	struct clk		*aclk;	/* lcdc share memory frequency */
+	u32 pixclock;
+
+	u32 standby;		/* 1:standby,0:wrok */
+	u32 iommu_status;
+	struct backlight_device *backlight;
+
+	/* lock vop irq reg */
+	spinlock_t irq_lock;
+	struct vop_sync_obj_s sync;
+};
+
+static inline int vop_completion_timeout_ms(struct completion *comp, int to)
+{
+	long jiffies = msecs_to_jiffies(to);
+
+	return wait_for_completion_timeout(comp, jiffies);
+}
+
+static inline void vop_writel(struct vop_device *vop_dev, u32 offset, u32 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	*_pv = v;
+	writel_relaxed(v, vop_dev->regs + offset);
+}
+
+static inline u32 vop_readl(struct vop_device *vop_dev, u32 offset)
+{
+	u32 v;
+
+	v = readl_relaxed(vop_dev->regs + offset);
+	return v;
+}
+
+static inline u32 vop_readl_backup(struct vop_device *vop_dev, u32 offset)
+{
+	u32 v;
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	v = readl_relaxed(vop_dev->regs + offset);
+	*_pv = v;
+	return v;
+}
+
+static inline u32 vop_read_bit(struct vop_device *vop_dev, u32 offset, u64 v)
+{
+	u32 _v = readl_relaxed(vop_dev->regs + offset);
+
+	_v &= v >> 32;
+	v = (_v ? 1 : 0);
+	return v;
+}
+
+static inline void vop_set_bit(struct vop_device *vop_dev, u32 offset, u64 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) |= v >> 32;
+	writel_relaxed(*_pv, vop_dev->regs + offset);
+}
+
+static inline void vop_clr_bit(struct vop_device *vop_dev, u32 offset, u64 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) &= (~(v >> 32));
+	writel_relaxed(*_pv, vop_dev->regs + offset);
+}
+
+static inline void vop_msk_reg(struct vop_device *vop_dev, u32 offset, u64 v)
+{
+	u32 *_pv = (u32 *)vop_dev->regsbak;
+
+	_pv += (offset >> 2);
+	(*_pv) &= (~(v >> 32));
+	(*_pv) |= (u32)v;
+	writel_relaxed(*_pv, vop_dev->regs + offset);
+}
+
+static inline void vop_mask_writel(struct vop_device *vop_dev, u32 offset,
+				   u32 mask, u32 v)
+{
+	v = mask << 16 | v;
+	writel_relaxed(v, vop_dev->regs + offset);
+}
+
+static inline void vop_cfg_done(struct vop_device *vop_dev)
+{
+	writel_relaxed(0x001f001f, vop_dev->regs + REG_CFG_DONE);
+	dsb(sy);
+}
+
+static inline int vop_grf_writel(struct regmap *base, u32 offset, u32 val)
+{
+	if (base)
+		regmap_write(base, offset, val);
+	dsb(sy);
+
+	return 0;
+}
+
+static inline int vop_cru_writel(struct regmap *base, u32 offset, u32 val)
+{
+	if (base)
+		regmap_write(base, offset, val);
+	dsb(sy);
+
+	return 0;
+}
+
+static inline int vop_cru_readl(struct regmap *base, u32 offset)
+{
+	u32 v;
+
+	if (base)
+		regmap_read(base, offset, &v);
+
+	return v;
+}
+
+enum dither_down_mode {
+	DITHER_888_565 = 0x0,
+	DITHER_888_666 = 0x1,
+};
+
+enum dither_down_sel {
+	DITHER_SEL_ALLEGRO = 0x0,
+	DITHER_SEL_FRC = 0x1,
+};
+
+enum _vop_r2y_csc_mode {
+	VOP_R2Y_CSC_BT601 = 0,
+	VOP_R2Y_CSC_BT709
+};
+
+enum _vop_y2r_csc_mode {
+	VOP_Y2R_CSC_MPEG = 0,
+	VOP_Y2R_CSC_HD,
+	VOP_Y2R_CSC_JPEG,
+	VOP_Y2R_CSC_BYPASS
+};
+
+enum _vop_format {
+	VOP_FORMAT_ARGB888 = 0,
+	VOP_FORMAT_RGB888,
+	VOP_FORMAT_RGB565,
+	VOP_FORMAT_YCBCR420 = 4,
+	VOP_FORMAT_YCBCR422,
+	VOP_FORMAT_YCBCR444
+};
+
+enum _bcsh_video_mode {
+	BCSH_MODE_BLACK = 0,
+	BCSH_MODE_BLUE,
+	BCSH_MODE_COLORBAR,
+	BCSH_MODE_VIDEO,
+};
+
+#define IS_YUV(x) ((x) >= VOP_FORMAT_YCBCR420)
+
+enum _vop_overlay_mode {
+	VOP_RGB_DOMAIN,
+	VOP_YUV_DOMAIN
+};
+
+/*************************************************************/
+#define CALSCALE(x, y)  \
+	(1 == (y) ? 0x1000 : ((((u32)((x) - 1)) * 0x1000) / ((y) - 1)))
+
+#endif
diff -Nupr a/drivers/video/rockchip/Makefile b/drivers/video/rockchip/Makefile
--- a/drivers/video/rockchip/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_ROCKCHIP_RGA) += rga/
+obj-$(CONFIG_ROCKCHIP_RGA2) += rga2/
+obj-$(CONFIG_FB_ROCKCHIP) += rk_fb.o rkfb_sysfs.o bmp_helper.o screen/
+obj-$(CONFIG_RK_TRSM) += transmitter/
+obj-$(CONFIG_FB_ROCKCHIP) += display-sys.o lcdc/
+obj-$(CONFIG_RK_HDMI) += hdmi/
+obj-$(CONFIG_IEP) += iep/
+obj-$(CONFIG_RK_TVENCODER) += tve/
+obj-$(CONFIG_RK_VCODEC) += vcodec/
+obj-$(CONFIG_ROCKCHIP_DP) += dp/
+obj-$(CONFIG_ROCKCHIP_MPP_SERVICE) += vpu/
diff -Nupr a/drivers/video/rockchip/rga/Kconfig b/drivers/video/rockchip/rga/Kconfig
--- a/drivers/video/rockchip/rga/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+menu "RGA"
+	depends on ARCH_ROCKCHIP
+
+config ROCKCHIP_RGA
+	tristate "ROCKCHIP_RGA"
+	help
+	  rk30 rga module.
+
+endmenu
diff -Nupr a/drivers/video/rockchip/rga/Makefile b/drivers/video/rockchip/rga/Makefile
--- a/drivers/video/rockchip/rga/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
+rga-y	:= rga_drv.o rga_mmu_info.o rga_reg_info.o RGA_API.o
+
+obj-$(CONFIG_ROCKCHIP_RGA)	+= rga.o
diff -Nupr a/drivers/video/rockchip/rga/RGA_API.c b/drivers/video/rockchip/rga/RGA_API.c
--- a/drivers/video/rockchip/rga/RGA_API.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/RGA_API.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,201 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#include <linux/memory.h>
+#include "RGA_API.h"
+#include "rga.h"
+//#include "rga_angle.h"
+
+#define IS_YUV_420(format) \
+     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
+      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP))
+
+#define IS_YUV_422(format) \
+     ((format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
+      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
+
+#define IS_YUV(format) \
+     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
+      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP) | \
+      (format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
+      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
+
+
+extern rga_service_info rga_service;
+
+
+void
+matrix_cal(const struct rga_req *msg, TILE_INFO *tile)
+{
+    uint64_t x_time, y_time;
+    uint64_t sina, cosa;
+
+    int s_act_w, s_act_h, d_act_w, d_act_h;
+
+    s_act_w = msg->src.act_w;
+    s_act_h = msg->src.act_h;
+    d_act_w = msg->dst.act_w;
+    d_act_h = msg->dst.act_h;
+
+    if (s_act_w == 1) s_act_w += 1;
+    if (s_act_h == 1) s_act_h += 1;
+    if (d_act_h == 1) d_act_h += 1;
+    if (d_act_w == 1) d_act_w += 1;
+
+    x_time = ((s_act_w - 1)<<16) / (d_act_w - 1);
+    y_time = ((s_act_h - 1)<<16) / (d_act_h - 1);
+
+    sina = msg->sina;
+    cosa = msg->cosa;
+
+    switch(msg->rotate_mode)
+    {
+        /* 16.16 x 16.16 */
+        /* matrix[] is 64 bit wide */
+        case 1 :
+            tile->matrix[0] =  cosa*x_time;
+            tile->matrix[1] = -sina*y_time;
+            tile->matrix[2] =  sina*x_time;
+            tile->matrix[3] =  cosa*y_time;
+            break;
+        case 2 :
+            tile->matrix[0] = -(x_time<<16);
+            tile->matrix[1] = 0;
+            tile->matrix[2] = 0;
+            tile->matrix[3] = (y_time<<16);
+            break;
+        case 3 :
+            tile->matrix[0] = (x_time<<16);
+            tile->matrix[1] = 0;
+            tile->matrix[2] = 0;
+            tile->matrix[3] = -(y_time<<16);
+            break;
+        default :
+            tile->matrix[0] =  (uint64_t)1<<32;
+            tile->matrix[1] =  0;
+            tile->matrix[2] =  0;
+            tile->matrix[3] =  (uint64_t)1<<32;
+            break;
+    }
+}
+
+
+int32_t RGA_gen_two_pro(struct rga_req *msg, struct rga_req *msg1)
+{
+
+    struct rga_req *mp;
+    uint32_t w_ratio, h_ratio;
+    uint32_t stride;
+
+    uint32_t daw, dah;
+    uint32_t pl;
+
+    daw = dah = 0;
+
+    mp = msg1;
+
+    if(msg->dst.act_w == 0)
+    {
+        printk("%s, [%d] rga dst act_w is zero\n", __FUNCTION__, __LINE__);
+        return -EINVAL;
+    }
+
+    if (msg->dst.act_h == 0)
+    {
+        printk("%s, [%d] rga dst act_w is zero\n", __FUNCTION__, __LINE__);
+        return -EINVAL;
+    }
+    w_ratio = (msg->src.act_w << 16) / msg->dst.act_w;
+    h_ratio = (msg->src.act_h << 16) / msg->dst.act_h;
+
+    memcpy(msg1, msg, sizeof(struct rga_req));
+
+    msg->dst.format = msg->src.format;
+
+    /*pre_scale_w cal*/
+    if ((w_ratio >= (2<<16)) && (w_ratio < (4<<16))) {
+        daw = (msg->src.act_w + 1) >> 1;
+        if((IS_YUV_420(msg->dst.format)) && (daw & 1)) {
+            daw -= 1;
+            msg->src.act_w = daw << 1;
+        }
+    }
+    else if ((w_ratio >= (4<<16)) && (w_ratio < (8<<16))) {
+        daw = (msg->src.act_w + 3) >> 2;
+        if((IS_YUV_420(msg->dst.format)) && (daw & 1)) {
+            daw -= 1;
+            msg->src.act_w = daw << 2;
+        }
+    }
+    else if ((w_ratio >= (8<<16)) && (w_ratio < (16<<16))) {
+        daw = (msg->src.act_w + 7) >> 3;
+        if((IS_YUV_420(msg->dst.format)) && (daw & 1)) {
+            daw -= 1;
+            msg->src.act_w = daw << 3;
+        }
+    }
+    else
+    {
+        daw = msg->src.act_w;
+    }
+
+    pl = (RGA_pixel_width_init(msg->src.format));
+    stride = (pl * daw + 3) & (~3);
+    msg->dst.act_w = daw;
+    msg->dst.vir_w = stride / pl;
+
+    /*pre_scale_h cal*/
+    if ((h_ratio >= (2<<16)) && (h_ratio < (4<<16))) {
+        dah = (msg->src.act_h + 1) >> 1;
+        if((IS_YUV(msg->dst.format)) && (dah & 1)) {
+            dah -= 1;
+            msg->src.act_h = dah << 1;
+        }
+    }
+    else if ((h_ratio >= (4<<16)) && (h_ratio < (8<<16))) {
+        dah = (msg->src.act_h + 3) >> 2;
+        if((IS_YUV(msg->dst.format)) && (dah & 1)) {
+            dah -= 1;
+            msg->src.act_h = dah << 2;
+
+        }
+    }
+    else if ((h_ratio >= (8<<16)) && (h_ratio < (16<<16))) {
+        dah = (msg->src.act_h + 7) >> 3;
+        if((IS_YUV(msg->dst.format)) && (dah & 1)) {
+            dah -= 1;
+            msg->src.act_h = dah << 3;
+        }
+    }
+    else
+    {
+        dah = msg->src.act_h;
+    }
+
+    msg->dst.act_h = dah;
+    msg->dst.vir_h = dah;
+
+    msg->dst.x_offset = 0;
+    msg->dst.y_offset = 0;
+
+    msg->dst.yrgb_addr = (unsigned long)rga_service.pre_scale_buf;
+    msg->dst.uv_addr = msg->dst.yrgb_addr + stride * dah;
+    msg->dst.v_addr = msg->dst.uv_addr + ((stride * dah) >> 1);
+
+    msg->render_mode = pre_scaling_mode;
+
+    msg1->src.yrgb_addr = msg->dst.yrgb_addr;
+    msg1->src.uv_addr = msg->dst.uv_addr;
+    msg1->src.v_addr = msg->dst.v_addr;
+
+    msg1->src.act_w = msg->dst.act_w;
+    msg1->src.act_h = msg->dst.act_h;
+    msg1->src.vir_w = msg->dst.vir_w;
+    msg1->src.vir_h = msg->dst.vir_h;
+
+    msg1->src.x_offset = 0;
+    msg1->src.y_offset = 0;
+
+    return 0;
+}
+
+
diff -Nupr a/drivers/video/rockchip/rga/RGA_API.h b/drivers/video/rockchip/rga/RGA_API.h
--- a/drivers/video/rockchip/rga/RGA_API.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/RGA_API.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RGA_API_H__
+#define __RGA_API_H__
+
+#include "rga_reg_info.h"
+#include "rga.h"
+
+#define ENABLE      1
+#define DISABLE     0
+
+int32_t RGA_gen_two_pro(struct rga_req *msg, struct rga_req *msg1);
+
+
+
+
+
+#endif
diff -Nupr a/drivers/video/rockchip/rga/rga_drv.c b/drivers/video/rockchip/rga/rga_drv.c
--- a/drivers/video/rockchip/rga/rga_drv.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/rga_drv.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1662 @@
+/*
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt) "rga: " fmt
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <asm/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+//#include <mach/io.h>
+//#include <mach/irqs.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/syscalls.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <asm/cacheflush.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/wakelock.h>
+#include <linux/dma-buf.h>
+#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#if defined(CONFIG_ION_ROCKCHIP)
+#include <linux/rockchip_ion.h>
+#endif
+
+
+#include "rga.h"
+#include "rga_reg_info.h"
+#include "rga_mmu_info.h"
+#include "RGA_API.h"
+
+#define RGA_TEST_CASE 0
+
+#define RGA_TEST 0
+#define RGA_TEST_TIME 0
+#define RGA_TEST_FLUSH_TIME 0
+#define RGA_INFO_BUS_ERROR 1
+
+#define PRE_SCALE_BUF_SIZE  2048*1024*4
+
+#define RGA_POWER_OFF_DELAY	4*HZ /* 4s */
+#define RGA_TIMEOUT_DELAY	2*HZ /* 2s */
+
+#define RGA_MAJOR		255
+
+#if defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026)
+#define RK30_RGA_PHYS		RK2928_RGA_PHYS
+#define RK30_RGA_SIZE		RK2928_RGA_SIZE
+#endif
+#define RGA_RESET_TIMEOUT	1000
+
+/* Driver information */
+#define DRIVER_DESC		"RGA Device Driver"
+#define DRIVER_NAME		"rga"
+
+
+ktime_t rga_start;
+ktime_t rga_end;
+
+rga_session rga_session_global;
+
+long (*rga_ioctl_kernel_p)(struct rga_req *);
+
+
+struct rga_drvdata {
+  	struct miscdevice miscdev;
+	struct device *dev;
+	void *rga_base;
+	int irq;
+
+	struct delayed_work power_off_work;
+	void (*rga_irq_callback)(int rga_retval);   //callback function used by aync call
+	struct wake_lock wake_lock;
+
+    struct clk *pd_rga;
+	struct clk *aclk_rga;
+    struct clk *hclk_rga;
+
+    //#if defined(CONFIG_ION_ROCKCHIP)
+    struct ion_client * ion_client;
+    //#endif
+	char *version;
+};
+
+static struct rga_drvdata *drvdata;
+rga_service_info rga_service;
+struct rga_mmu_buf_t rga_mmu_buf;
+
+
+#if defined(CONFIG_ION_ROCKCHIP)
+extern struct ion_client *rockchip_ion_client_create(const char * name);
+#endif
+
+static int rga_blit_async(rga_session *session, struct rga_req *req);
+static void rga_del_running_list(void);
+static void rga_del_running_list_timeout(void);
+static void rga_try_set_reg(void);
+
+
+/* Logging */
+#define RGA_DEBUG 1
+#if RGA_DEBUG
+#define DBG(format, args...) printk(KERN_DEBUG "%s: " format, DRIVER_NAME, ## args)
+#define ERR(format, args...) printk(KERN_ERR "%s: " format, DRIVER_NAME, ## args)
+#define WARNING(format, args...) printk(KERN_WARN "%s: " format, DRIVER_NAME, ## args)
+#define INFO(format, args...) printk(KERN_INFO "%s: " format, DRIVER_NAME, ## args)
+#else
+#define DBG(format, args...)
+#define ERR(format, args...)
+#define WARNING(format, args...)
+#define INFO(format, args...)
+#endif
+
+#if RGA_TEST
+static void print_info(struct rga_req *req)
+{
+	printk(KERN_ERR "src : yrgb_addr = %.lx, src.uv_addr = %.lx, src.v_addr = %.lx, format = %d\n",
+            req->src.yrgb_addr, req->src.uv_addr, req->src.v_addr, req->src.format);
+    printk("src : act_w = %d, act_h = %d, vir_w = %d, vir_h = %d\n",
+        req->src.act_w, req->src.act_h, req->src.vir_w, req->src.vir_h);
+    printk("src : x_off = %.8x y_off = %.8x\n", req->src.x_offset, req->src.y_offset);
+
+    printk("dst : yrgb_addr = %.8x, dst.uv_addr = %.8x, dst.v_addr = %.8x, format = %d\n",
+            req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr, req->dst.format);
+    printk("dst : x_off = %.8x y_off = %.8x\n", req->dst.x_offset, req->dst.y_offset);
+    printk("dst : act_w = %d, act_h = %d, vir_w = %d, vir_h = %d\n",
+        req->dst.act_w, req->dst.act_h, req->dst.vir_w, req->dst.vir_h);
+
+    printk("clip.xmin = %d, clip.xmax = %d. clip.ymin = %d, clip.ymax = %d\n",
+        req->clip.xmin, req->clip.xmax, req->clip.ymin, req->clip.ymax);
+
+    printk("mmu_flag = %.8x\n", req->mmu_info.mmu_flag);
+
+	printk(KERN_ERR "alpha_rop_flag = %.8x\n", req->alpha_rop_flag);
+	printk(KERN_ERR "alpha_rop_mode = %.8x\n", req->alpha_rop_mode);
+    //printk("PD_mode = %.8x\n", req->PD_mode);
+}
+#endif
+
+
+static inline void rga_write(u32 b, u32 r)
+{
+	__raw_writel(b, drvdata->rga_base + r);
+}
+
+static inline u32 rga_read(u32 r)
+{
+	return __raw_readl(drvdata->rga_base + r);
+}
+
+static void rga_soft_reset(void)
+{
+	u32 i;
+	u32 reg;
+
+	rga_write(1, RGA_SYS_CTRL); //RGA_SYS_CTRL
+
+	for(i = 0; i < RGA_RESET_TIMEOUT; i++)
+	{
+		reg = rga_read(RGA_SYS_CTRL) & 1; //RGA_SYS_CTRL
+
+		if(reg == 0)
+			break;
+
+		udelay(1);
+	}
+
+	if(i == RGA_RESET_TIMEOUT)
+		ERR("soft reset timeout.\n");
+}
+
+static void rga_dump(void)
+{
+	int running;
+    struct rga_reg *reg, *reg_tmp;
+    rga_session *session, *session_tmp;
+
+	running = atomic_read(&rga_service.total_running);
+	printk("rga total_running %d\n", running);
+
+    #if 0
+
+    /* Dump waiting list info */
+    if (!list_empty(&rga_service.waiting))
+    {
+        list_head	*next;
+
+        next = &rga_service.waiting;
+
+        printk("rga_service dump waiting list\n");
+
+        do
+        {
+            reg = list_entry(next->next, struct rga_reg, status_link);
+            running = atomic_read(&reg->session->task_running);
+            num_done = atomic_read(&reg->session->num_done);
+            printk("rga session pid %d, done %d, running %d\n", reg->session->pid, num_done, running);
+            next = next->next;
+        }
+        while(!list_empty(next));
+    }
+
+    /* Dump running list info */
+    if (!list_empty(&rga_service.running))
+    {
+        printk("rga_service dump running list\n");
+
+        list_head	*next;
+
+        next = &rga_service.running;
+        do
+        {
+            reg = list_entry(next->next, struct rga_reg, status_link);
+            running = atomic_read(&reg->session->task_running);
+            num_done = atomic_read(&reg->session->num_done);
+            printk("rga session pid %d, done %d, running %d:\n", reg->session->pid, num_done, running);
+            next = next->next;
+        }
+        while(!list_empty(next));
+    }
+    #endif
+
+	list_for_each_entry_safe(session, session_tmp, &rga_service.session, list_session)
+    {
+		printk("session pid %d:\n", session->pid);
+		running = atomic_read(&session->task_running);
+		printk("task_running %d\n", running);
+		list_for_each_entry_safe(reg, reg_tmp, &session->waiting, session_link)
+        {
+			printk("waiting register set 0x %.lu\n", (unsigned long)reg);
+		}
+		list_for_each_entry_safe(reg, reg_tmp, &session->running, session_link)
+        {
+			printk("running register set 0x %.lu\n", (unsigned long)reg);
+		}
+	}
+}
+
+static inline void rga_queue_power_off_work(void)
+{
+	queue_delayed_work(system_wq, &drvdata->power_off_work, RGA_POWER_OFF_DELAY);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga_power_on(void)
+{
+	static ktime_t last;
+	ktime_t now = ktime_get();
+
+	if (ktime_to_ns(ktime_sub(now, last)) > NSEC_PER_SEC) {
+		cancel_delayed_work_sync(&drvdata->power_off_work);
+		rga_queue_power_off_work();
+		last = now;
+	}
+	if (rga_service.enable)
+		return;
+
+	clk_prepare_enable(drvdata->aclk_rga);
+	clk_prepare_enable(drvdata->hclk_rga);
+	//clk_prepare_enable(drvdata->pd_rga);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_get_sync(drvdata->dev);
+#endif
+
+	wake_lock(&drvdata->wake_lock);
+	rga_service.enable = true;
+}
+
+/* Caller must hold rga_service.lock */
+static void rga_power_off(void)
+{
+	int total_running;
+
+	if (!rga_service.enable) {
+		return;
+	}
+
+	total_running = atomic_read(&rga_service.total_running);
+	if (total_running) {
+		pr_err("power off when %d task running!!\n", total_running);
+		mdelay(50);
+		pr_err("delay 50 ms for running task\n");
+		rga_dump();
+	}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_put(drvdata->dev);
+#endif
+
+	//clk_disable_unprepare(drvdata->pd_rga);
+	clk_disable_unprepare(drvdata->aclk_rga);
+	clk_disable_unprepare(drvdata->hclk_rga);
+	wake_unlock(&drvdata->wake_lock);
+	rga_service.enable = false;
+}
+
+static void rga_power_off_work(struct work_struct *work)
+{
+	if (mutex_trylock(&rga_service.lock)) {
+		rga_power_off();
+		mutex_unlock(&rga_service.lock);
+	} else {
+		/* Come back later if the device is busy... */
+
+		rga_queue_power_off_work();
+	}
+}
+
+static int rga_flush(rga_session *session, unsigned long arg)
+{
+    int ret = 0;
+    int ret_timeout;
+
+    #if RGA_TEST_FLUSH_TIME
+    ktime_t start;
+    ktime_t end;
+    start = ktime_get();
+    #endif
+
+    ret_timeout = wait_event_timeout(session->wait, atomic_read(&session->done), RGA_TIMEOUT_DELAY);
+
+	if (unlikely(ret_timeout < 0)) {
+		//pr_err("flush pid %d wait task ret %d\n", session->pid, ret);
+        mutex_lock(&rga_service.lock);
+        rga_del_running_list();
+        mutex_unlock(&rga_service.lock);
+        ret = ret_timeout;
+	} else if (0 == ret_timeout) {
+		//pr_err("flush pid %d wait %d task done timeout\n", session->pid, atomic_read(&session->task_running));
+        //printk("bus  = %.8x\n", rga_read(RGA_INT));
+        mutex_lock(&rga_service.lock);
+        rga_del_running_list_timeout();
+        rga_try_set_reg();
+        mutex_unlock(&rga_service.lock);
+		ret = -ETIMEDOUT;
+	}
+
+    #if RGA_TEST_FLUSH_TIME
+    end = ktime_get();
+    end = ktime_sub(end, start);
+    printk("one flush wait time %d\n", (int)ktime_to_us(end));
+    #endif
+
+	return ret;
+}
+
+
+static int rga_get_result(rga_session *session, unsigned long arg)
+{
+	//printk("rga_get_result %d\n",drvdata->rga_result);
+
+    int ret = 0;
+
+    int num_done;
+
+    num_done = atomic_read(&session->num_done);
+
+	if (unlikely(copy_to_user((void __user *)arg, &num_done, sizeof(int)))) {
+			printk("copy_to_user failed\n");
+			ret =  -EFAULT;
+		}
+	return ret;
+}
+
+
+static int rga_check_param(const struct rga_req *req)
+{
+	/*RGA can support up to 8192*8192 resolution in RGB format,but we limit the image size to 8191*8191 here*/
+	//check src width and height
+
+    if(!((req->render_mode == color_fill_mode) || (req->render_mode == line_point_drawing_mode)))
+    {
+    	if (unlikely((req->src.act_w <= 0) || (req->src.act_w > 8191) || (req->src.act_h <= 0) || (req->src.act_h > 8191)))
+        {
+    		printk("invalid source resolution act_w = %d, act_h = %d\n", req->src.act_w, req->src.act_h);
+    		return  -EINVAL;
+    	}
+    }
+
+    if(!((req->render_mode == color_fill_mode) || (req->render_mode == line_point_drawing_mode)))
+    {
+    	if (unlikely((req->src.vir_w <= 0) || (req->src.vir_w > 8191) || (req->src.vir_h <= 0) || (req->src.vir_h > 8191)))
+        {
+    		printk("invalid source resolution vir_w = %d, vir_h = %d\n", req->src.vir_w, req->src.vir_h);
+    		return  -EINVAL;
+    	}
+    }
+
+	//check dst width and height
+	if (unlikely((req->dst.act_w <= 0) || (req->dst.act_w > 2048) || (req->dst.act_h <= 0) || (req->dst.act_h > 2048)))
+    {
+		printk("invalid destination resolution act_w = %d, act_h = %d\n", req->dst.act_w, req->dst.act_h);
+		return	-EINVAL;
+	}
+
+    if (unlikely((req->dst.vir_w <= 0) || (req->dst.vir_w > 4096) || (req->dst.vir_h <= 0) || (req->dst.vir_h > 2048)))
+    {
+		printk("invalid destination resolution vir_w = %d, vir_h = %d\n", req->dst.vir_w, req->dst.vir_h);
+		return	-EINVAL;
+	}
+
+	//check src_vir_w
+	if(unlikely(req->src.vir_w < req->src.act_w)){
+		printk("invalid src_vir_w act_w = %d, vir_w = %d\n", req->src.act_w, req->src.vir_w);
+		return	-EINVAL;
+	}
+
+	//check dst_vir_w
+	if(unlikely(req->dst.vir_w < req->dst.act_w)){
+        if(req->rotate_mode != 1)
+        {
+		    printk("invalid dst_vir_w act_h = %d, vir_h = %d\n", req->dst.act_w, req->dst.vir_w);
+		    return	-EINVAL;
+        }
+	}
+
+	return 0;
+}
+
+static void rga_copy_reg(struct rga_reg *reg, uint32_t offset)
+{
+    uint32_t i;
+    uint32_t *cmd_buf;
+    uint32_t *reg_p;
+
+    if(atomic_read(&reg->session->task_running) != 0)
+    {
+        printk(KERN_ERR "task_running is no zero\n");
+    }
+
+    atomic_add(1, &rga_service.cmd_num);
+	atomic_add(1, &reg->session->task_running);
+
+    cmd_buf = (uint32_t *)rga_service.cmd_buff + offset*32;
+    reg_p = (uint32_t *)reg->cmd_reg;
+
+    for(i=0; i<32; i++)
+        cmd_buf[i] = reg_p[i];
+
+}
+
+
+static struct rga_reg * rga_reg_init(rga_session *session, struct rga_req *req)
+{
+    int32_t ret;
+	struct rga_reg *reg = kzalloc(sizeof(struct rga_reg), GFP_KERNEL);
+	if (NULL == reg) {
+		pr_err("kmalloc fail in rga_reg_init\n");
+		return NULL;
+	}
+
+    reg->session = session;
+	INIT_LIST_HEAD(&reg->session_link);
+	INIT_LIST_HEAD(&reg->status_link);
+
+    reg->MMU_base = NULL;
+
+    if (req->mmu_info.mmu_en)
+    {
+        ret = rga_set_mmu_info(reg, req);
+        if(ret < 0)
+        {
+            printk("%s, [%d] set mmu info error \n", __FUNCTION__, __LINE__);
+            if(reg != NULL)
+            {
+                kfree(reg);
+            }
+            return NULL;
+        }
+    }
+
+    if(RGA_gen_reg_info(req, (uint8_t *)reg->cmd_reg) == -1)
+    {
+        printk("gen reg info error\n");
+        if(reg != NULL)
+        {
+            kfree(reg);
+        }
+        return NULL;
+    }
+
+	reg->sg_src = req->sg_src;
+	reg->sg_dst = req->sg_dst;
+	reg->attach_src = req->attach_src;
+	reg->attach_dst = req->attach_dst;
+
+    mutex_lock(&rga_service.lock);
+	list_add_tail(&reg->status_link, &rga_service.waiting);
+	list_add_tail(&reg->session_link, &session->waiting);
+	mutex_unlock(&rga_service.lock);
+
+    return reg;
+}
+
+/* Caller must hold rga_service.lock */
+static void rga_reg_deinit(struct rga_reg *reg)
+{
+	list_del_init(&reg->session_link);
+	list_del_init(&reg->status_link);
+	kfree(reg);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga_reg_from_wait_to_run(struct rga_reg *reg)
+{
+	list_del_init(&reg->status_link);
+	list_add_tail(&reg->status_link, &rga_service.running);
+
+	list_del_init(&reg->session_link);
+	list_add_tail(&reg->session_link, &reg->session->running);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga_service_session_clear(rga_session *session)
+{
+	struct rga_reg *reg, *n;
+
+    list_for_each_entry_safe(reg, n, &session->waiting, session_link)
+    {
+		rga_reg_deinit(reg);
+	}
+
+    list_for_each_entry_safe(reg, n, &session->running, session_link)
+    {
+		rga_reg_deinit(reg);
+	}
+}
+
+/* Caller must hold rga_service.lock */
+static void rga_try_set_reg(void)
+{
+    struct rga_reg *reg ;
+
+    if (list_empty(&rga_service.running))
+    {
+        if (!list_empty(&rga_service.waiting))
+        {
+            /* RGA is idle */
+            reg = list_entry(rga_service.waiting.next, struct rga_reg, status_link);
+
+            rga_power_on();
+            udelay(1);
+
+            rga_copy_reg(reg, 0);
+            rga_reg_from_wait_to_run(reg);
+
+            #ifdef CONFIG_ARM
+            dmac_flush_range(&rga_service.cmd_buff[0], &rga_service.cmd_buff[32]);
+            outer_flush_range(virt_to_phys(&rga_service.cmd_buff[0]),virt_to_phys(&rga_service.cmd_buff[32]));
+            #elif defined(CONFIG_ARM64)
+            __dma_flush_range(&rga_service.cmd_buff[0], &rga_service.cmd_buff[32]);
+            #endif
+
+            rga_soft_reset();
+
+            rga_write(0x0, RGA_SYS_CTRL);
+            rga_write(0, RGA_MMU_CTRL);
+
+            /* CMD buff */
+            rga_write(virt_to_phys(rga_service.cmd_buff), RGA_CMD_ADDR);
+
+#if RGA_TEST
+            {
+                //printk(KERN_DEBUG "cmd_addr = %.8x\n", rga_read(RGA_CMD_ADDR));
+                uint32_t i;
+                uint32_t *p;
+                p = rga_service.cmd_buff;
+                printk("CMD_REG\n");
+                for (i=0; i<7; i++)
+                    printk("%.8x %.8x %.8x %.8x\n", p[0 + i*4], p[1+i*4], p[2 + i*4], p[3 + i*4]);
+                printk("%.8x %.8x\n", p[0 + i*4], p[1+i*4]);
+            }
+#endif
+
+            /* master mode */
+            rga_write((0x1<<2)|(0x1<<3), RGA_SYS_CTRL);
+
+            /* All CMD finish int */
+            rga_write(rga_read(RGA_INT)|(0x1<<10)|(0x1<<8), RGA_INT);
+
+            #if RGA_TEST_TIME
+            rga_start = ktime_get();
+            #endif
+
+            /* Start proc */
+            atomic_set(&reg->session->done, 0);
+            rga_write(0x1, RGA_CMD_CTRL);
+
+#if RGA_TEST
+            {
+                uint32_t i;
+                printk("CMD_READ_BACK_REG\n");
+                for (i=0; i<7; i++)
+                    printk("%.8x %.8x %.8x %.8x\n", rga_read(0x100 + i*16 + 0),
+                            rga_read(0x100 + i*16 + 4), rga_read(0x100 + i*16 + 8), rga_read(0x100 + i*16 + 12));
+                printk("%.8x %.8x\n", rga_read(0x100 + i*16 + 0), rga_read(0x100 + i*16 + 4));
+            }
+#endif
+        }
+    }
+}
+
+
+static int rga_put_dma_buf(struct rga_req *req, struct rga_reg *reg)
+{
+	struct dma_buf_attachment *attach = NULL;
+	struct sg_table *sgt = NULL;
+	struct dma_buf *dma_buf = NULL;
+
+	if (!req && !reg)
+		return -EINVAL;
+
+	attach = (!reg) ? req->attach_src : reg->attach_src;
+	sgt = (!reg) ? req->sg_src : reg->sg_src;
+	if (attach && sgt)
+		dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+	if (attach) {
+		dma_buf = attach->dmabuf;
+		dma_buf_detach(dma_buf, attach);
+		dma_buf_put(dma_buf);
+	}
+
+	attach = (!reg) ? req->attach_dst : reg->attach_dst;
+	sgt = (!reg) ? req->sg_dst : reg->sg_dst;
+	if (attach && sgt)
+		dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+	if (attach) {
+		dma_buf = attach->dmabuf;
+		dma_buf_detach(dma_buf, attach);
+		dma_buf_put(dma_buf);
+	}
+
+	return 0;
+}
+
+/* Caller must hold rga_service.lock */
+static void rga_del_running_list(void)
+{
+    struct rga_reg *reg;
+
+    while(!list_empty(&rga_service.running))
+    {
+        reg = list_entry(rga_service.running.next, struct rga_reg, status_link);
+
+        if(reg->MMU_len != 0)
+        {
+            if (rga_mmu_buf.back + reg->MMU_len > 2*rga_mmu_buf.size)
+                rga_mmu_buf.back = reg->MMU_len + rga_mmu_buf.size;
+            else
+                rga_mmu_buf.back += reg->MMU_len;
+        }
+
+		rga_put_dma_buf(NULL, reg);
+
+        atomic_sub(1, &reg->session->task_running);
+        atomic_sub(1, &rga_service.total_running);
+
+        if(list_empty(&reg->session->waiting))
+        {
+            atomic_set(&reg->session->done, 1);
+            wake_up(&reg->session->wait);
+        }
+
+        rga_reg_deinit(reg);
+    }
+}
+
+/* Caller must hold rga_service.lock */
+static void rga_del_running_list_timeout(void)
+{
+    struct rga_reg *reg;
+
+    while(!list_empty(&rga_service.running))
+    {
+        reg = list_entry(rga_service.running.next, struct rga_reg, status_link);
+        
+        if(reg->MMU_len != 0)
+        {
+            if (rga_mmu_buf.back + reg->MMU_len > 2*rga_mmu_buf.size)
+                rga_mmu_buf.back = reg->MMU_len + rga_mmu_buf.size;
+            else
+                rga_mmu_buf.back += reg->MMU_len;
+        }
+
+		rga_put_dma_buf(NULL, reg);
+
+        atomic_sub(1, &reg->session->task_running);
+        atomic_sub(1, &rga_service.total_running);
+
+        //printk("RGA soft reset for timeout process\n");
+        rga_soft_reset();
+
+
+        #if 0
+        printk("RGA_INT is %.8x\n", rga_read(RGA_INT));
+        printk("reg->session->task_running = %d\n", atomic_read(&reg->session->task_running));
+        printk("rga_service.total_running  = %d\n", atomic_read(&rga_service.total_running));
+
+        print_info(&reg->req);
+
+        {
+            uint32_t *p, i;
+            p = reg->cmd_reg;
+            for (i=0; i<7; i++)
+                printk("%.8x %.8x %.8x %.8x\n", p[0 + i*4], p[1+i*4], p[2 + i*4], p[3 + i*4]);
+
+        }
+        #endif
+
+        if(list_empty(&reg->session->waiting))
+        {
+            atomic_set(&reg->session->done, 1);
+            wake_up(&reg->session->wait);
+        }
+
+        rga_reg_deinit(reg);
+    }
+}
+
+/*
+static int rga_convert_dma_buf(struct rga_req *req)
+{
+	struct ion_handle *hdl;
+	ion_phys_addr_t phy_addr;
+	size_t len;
+    int ret;
+    uint32_t src_offset, dst_offset;
+
+    req->sg_src  = NULL;
+    req->sg_dst  = NULL;
+
+	  src_offset = req->line_draw_info.flag;
+	  dst_offset = req->line_draw_info.line_width;
+
+    if(req->src.yrgb_addr) {
+        hdl = ion_import_dma_buf(drvdata->ion_client, req->src.yrgb_addr);
+        if (IS_ERR(hdl)) {
+            ret = PTR_ERR(hdl);
+            printk("RGA2 ERROR ion buf handle\n");
+            return ret;
+        }
+        if ((req->mmu_info.mmu_flag >> 8) & 1) {
+            req->sg_src = ion_sg_table(drvdata->ion_client, hdl);
+            req->src.yrgb_addr = req->src.uv_addr;
+            req->src.uv_addr = req->src.yrgb_addr + (req->src.vir_w * req->src.vir_h);
+            req->src.v_addr = req->src.uv_addr + (req->src.vir_w * req->src.vir_h)/4;
+        }
+        else {
+            ion_phys(drvdata->ion_client, hdl, &phy_addr, &len);
+            req->src.yrgb_addr = phy_addr + src_offset;
+            req->src.uv_addr = req->src.yrgb_addr + (req->src.vir_w * req->src.vir_h);
+            req->src.v_addr = req->src.uv_addr + (req->src.vir_w * req->src.vir_h)/4;
+        }
+        ion_free(drvdata->ion_client, hdl);
+    }
+    else {
+        req->src.yrgb_addr = req->src.uv_addr;
+        req->src.uv_addr = req->src.yrgb_addr + (req->src.vir_w * req->src.vir_h);
+        req->src.v_addr = req->src.uv_addr + (req->src.vir_w * req->src.vir_h)/4;
+    }
+
+    if(req->dst.yrgb_addr) {
+        hdl = ion_import_dma_buf(drvdata->ion_client, req->dst.yrgb_addr);
+        if (IS_ERR(hdl)) {
+            ret = PTR_ERR(hdl);
+            printk("RGA2 ERROR ion buf handle\n");
+            return ret;
+        }
+        if ((req->mmu_info.mmu_flag >> 10) & 1) {
+            req->sg_dst = ion_sg_table(drvdata->ion_client, hdl);
+            req->dst.yrgb_addr = req->dst.uv_addr;
+            req->dst.uv_addr = req->dst.yrgb_addr + (req->dst.vir_w * req->dst.vir_h);
+            req->dst.v_addr = req->dst.uv_addr + (req->dst.vir_w * req->dst.vir_h)/4;
+        }
+        else {
+            ion_phys(drvdata->ion_client, hdl, &phy_addr, &len);
+            req->dst.yrgb_addr = phy_addr + dst_offset;
+            req->dst.uv_addr = req->dst.yrgb_addr + (req->dst.vir_w * req->dst.vir_h);
+            req->dst.v_addr = req->dst.uv_addr + (req->dst.vir_w * req->dst.vir_h)/4;
+        }
+        ion_free(drvdata->ion_client, hdl);
+    }
+    else {
+        req->dst.yrgb_addr = req->dst.uv_addr;
+        req->dst.uv_addr = req->dst.yrgb_addr + (req->dst.vir_w * req->dst.vir_h);
+        req->dst.v_addr = req->dst.uv_addr + (req->dst.vir_w * req->dst.vir_h)/4;
+    }
+
+    return 0;
+}
+*/
+
+static int rga_get_img_info(rga_img_info_t *img,
+			     u8 mmu_flag,
+			     struct sg_table **psgt,
+			     struct dma_buf_attachment **pattach)
+{
+	struct dma_buf_attachment *attach = NULL;
+	struct device *rga_dev = NULL;
+	struct sg_table *sgt = NULL;
+	struct dma_buf *dma_buf = NULL;
+	u32 vir_w, vir_h;
+	int yrgb_addr = -1;
+	int ret = 0;
+
+	rga_dev = drvdata->dev;
+	yrgb_addr = (int)img->yrgb_addr;
+	vir_w = img->vir_w;
+	vir_h = img->vir_h;
+
+	if (yrgb_addr > 0) {
+		dma_buf = dma_buf_get(img->yrgb_addr);
+		if (IS_ERR(dma_buf)) {
+			ret = -EINVAL;
+			pr_err("dma_buf_get fail fd[%d]\n", yrgb_addr);
+			return ret;
+		}
+
+		attach = dma_buf_attach(dma_buf, rga_dev);
+		if (IS_ERR(attach)) {
+			dma_buf_put(dma_buf);
+			ret = -EINVAL;
+			pr_err("Failed to attach dma_buf\n");
+			return ret;
+		}
+
+		*pattach = attach;
+		sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+		if (IS_ERR(sgt)) {
+			ret = -EINVAL;
+			pr_err("Failed to map src attachment\n");
+			goto err_get_sg;
+		}
+		if (!mmu_flag) {
+			ret = -EINVAL;
+			pr_err("Fix it please enable iommu flag\n");
+			goto err_get_sg;
+		}
+
+		if (mmu_flag) {
+			*psgt = sgt;
+			img->yrgb_addr = img->uv_addr;
+			img->uv_addr = img->yrgb_addr + (vir_w * vir_h);
+			img->v_addr = img->uv_addr + (vir_w * vir_h) / 4;
+		}
+	} else {
+		img->yrgb_addr = img->uv_addr;
+		img->uv_addr = img->yrgb_addr + (vir_w * vir_h);
+		img->v_addr = img->uv_addr + (vir_w * vir_h) / 4;
+	}
+
+	return ret;
+
+err_get_sg:
+	if (sgt)
+		dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+	if (attach) {
+		dma_buf = attach->dmabuf;
+		dma_buf_detach(dma_buf, attach);
+		*pattach = NULL;
+		dma_buf_put(dma_buf);
+	}
+	return ret;
+}
+
+static int rga_get_dma_buf(struct rga_req *req)
+{
+	struct dma_buf *dma_buf = NULL;
+	u8 mmu_flag = 0;
+	int ret = 0;
+
+	req->sg_src = NULL;
+	req->sg_dst = NULL;
+	req->attach_src = NULL;
+	req->attach_dst = NULL;
+	mmu_flag = (req->mmu_info.mmu_flag >> 8) & 1;
+	ret = rga_get_img_info(&req->src, mmu_flag, &req->sg_src,
+				&req->attach_src);
+	if (ret) {
+		pr_err("src:rga_get_img_info fail\n");
+		goto err_src;
+	}
+
+	mmu_flag = (req->mmu_info.mmu_flag >> 10) & 1;
+	ret = rga_get_img_info(&req->dst, mmu_flag, &req->sg_dst,
+				&req->attach_dst);
+	if (ret) {
+		pr_err("dst:rga_get_img_info fail\n");
+		goto err_dst;
+	}
+
+	return ret;
+
+err_dst:
+	if (req->sg_src && req->attach_src) {
+		dma_buf_unmap_attachment(req->attach_src,
+					 req->sg_src, DMA_BIDIRECTIONAL);
+		dma_buf = req->attach_src->dmabuf;
+		dma_buf_detach(dma_buf, req->attach_src);
+		dma_buf_put(dma_buf);
+	}
+err_src:
+
+	return ret;
+}
+
+static int rga_blit(rga_session *session, struct rga_req *req)
+{
+    int ret = -1;
+    int num = 0;
+    struct rga_reg *reg;
+
+	uint32_t saw, sah, daw, dah;
+
+	saw = req->src.act_w;
+	sah = req->src.act_h;
+	daw = req->dst.act_w;
+	dah = req->dst.act_h;
+
+    #if RGA_TEST
+    print_info(req);
+    #endif
+	if (rga_get_dma_buf(req)) {
+        printk("RGA : DMA buf copy error\n");
+        return -EFAULT;
+    }
+	req->render_mode &= (~RGA_BUF_GEM_TYPE_MASK);
+    do {
+			if (((saw >> 1) >= daw) || ((sah >> 1) >= dah)) {
+				pr_err("unsupported to scaling less than 1/2 \n");
+				goto err_put_dma_buf;
+			}
+
+			if (((daw >> 3) >= saw) || ((dah >> 3) >= daw)) {
+				pr_err("unsupported to scaling more than 8 \n");
+				goto err_put_dma_buf;
+			}
+
+
+            /* check value if legal */
+            ret = rga_check_param(req);
+        	if(ret == -EINVAL) {
+                printk("req argument is inval\n");
+				goto err_put_dma_buf;
+        	}
+
+            reg = rga_reg_init(session, req);
+            if(reg == NULL) {
+				pr_err("init reg fail\n");
+				goto err_put_dma_buf;
+            }
+
+            num = 1;
+
+			mutex_lock(&rga_service.lock);
+			atomic_add(num, &rga_service.total_running);
+			rga_try_set_reg();
+			mutex_unlock(&rga_service.lock);
+
+			return 0;
+	}
+    while(0);
+
+err_put_dma_buf:
+	rga_put_dma_buf(req, NULL);
+
+    return -EFAULT;
+}
+
+static int rga_blit_async(rga_session *session, struct rga_req *req)
+{
+	int ret = -1;
+
+    #if RGA_TEST
+    printk("*** rga_blit_async proc ***\n");
+    #endif
+
+    atomic_set(&session->done, 0);
+    ret = rga_blit(session, req);
+    return ret;
+}
+
+static int rga_blit_sync(rga_session *session, struct rga_req *req)
+{
+    int ret = -1;
+    int ret_timeout = 0;
+
+    #if RGA_TEST
+    printk("*** rga_blit_sync proc ***\n");
+    #endif
+
+    atomic_set(&session->done, 0);
+    ret = rga_blit(session, req);
+    if(ret < 0)
+        return ret;
+
+    ret_timeout = wait_event_timeout(session->wait, atomic_read(&session->done), RGA_TIMEOUT_DELAY);
+
+    if (unlikely(ret_timeout< 0)) {
+        mutex_lock(&rga_service.lock);
+        rga_del_running_list();
+        mutex_unlock(&rga_service.lock);
+        ret = ret_timeout;
+	}
+    else if (0 == ret_timeout) {
+        mutex_lock(&rga_service.lock);
+        rga_del_running_list_timeout();
+        rga_try_set_reg();
+        mutex_unlock(&rga_service.lock);
+		ret = -ETIMEDOUT;
+	}
+
+    #if RGA_TEST_TIME
+    rga_end = ktime_get();
+    rga_end = ktime_sub(rga_end, rga_start);
+    printk("sync one cmd end time %d\n", (int)ktime_to_us(rga_end));
+    #endif
+
+    return ret;
+}
+
+
+static long rga_ioctl(struct file *file, uint32_t cmd, unsigned long arg)
+{
+    struct rga_req req;
+	int ret = 0;
+    rga_session *session;
+
+	memset(&req, 0x0, sizeof(req));
+    mutex_lock(&rga_service.mutex);
+
+    session = (rga_session *)file->private_data;
+
+	if (NULL == session) {
+        printk("%s [%d] rga thread session is null\n",__FUNCTION__,__LINE__);
+        mutex_unlock(&rga_service.mutex);
+		return -EINVAL;
+	}
+
+    memset(&req, 0x0, sizeof(req));
+
+	switch (cmd) {
+		case RGA_BLIT_SYNC:
+    		if (unlikely(copy_from_user(&req, (struct rga_req*)arg, sizeof(struct rga_req))))
+            {
+        		ERR("copy_from_user failed\n");
+        		ret = -EFAULT;
+                break;
+        	}
+            ret = rga_blit_sync(session, &req);
+            break;
+		case RGA_BLIT_ASYNC:
+    		if (unlikely(copy_from_user(&req, (struct rga_req*)arg, sizeof(struct rga_req))))
+            {
+        		ERR("copy_from_user failed\n");
+        		ret = -EFAULT;
+                break;
+        	}
+
+            if((atomic_read(&rga_service.total_running) > 16))
+            {
+			    ret = rga_blit_sync(session, &req);
+            }
+            else
+            {
+                ret = rga_blit_async(session, &req);
+            }
+			break;
+		case RGA_FLUSH:
+			ret = rga_flush(session, arg);
+			break;
+        case RGA_GET_RESULT:
+            ret = rga_get_result(session, arg);
+            break;
+        case RGA_GET_VERSION:
+			if (!drvdata->version) {
+				drvdata->version = kzalloc(16, GFP_KERNEL);
+				if (!drvdata->version) {
+					ret = -ENOMEM;
+					break;
+				}
+				rga_power_on();
+				udelay(1);
+				if (rga_read(RGA_VERSION) == 0x02018632)
+					snprintf(drvdata->version, 16, "1.6");
+				else
+					snprintf(drvdata->version, 16, "1.003");
+			}
+
+			ret = copy_to_user((void *)arg, drvdata->version, 16);
+            break;
+		default:
+			ERR("unknown ioctl cmd!\n");
+			ret = -EINVAL;
+			break;
+	}
+
+	mutex_unlock(&rga_service.mutex);
+
+	return ret;
+}
+
+
+long rga_ioctl_kernel(struct rga_req *req)
+{
+	int ret = 0;
+    if (!rga_ioctl_kernel_p) {
+        printk("rga_ioctl_kernel_p is NULL\n");
+        return -1;
+    }
+    else {
+        ret = (*rga_ioctl_kernel_p)(req);
+	    return ret;
+    }
+}
+
+
+long rga_ioctl_kernel_imp(struct rga_req *req)
+{
+	int ret = 0;
+    rga_session *session;
+
+    mutex_lock(&rga_service.mutex);
+
+    session = &rga_session_global;
+
+	if (NULL == session) {
+        printk("%s [%d] rga thread session is null\n",__FUNCTION__,__LINE__);
+        mutex_unlock(&rga_service.mutex);
+		return -EINVAL;
+	}
+
+    ret = rga_blit_sync(session, req);
+
+	mutex_unlock(&rga_service.mutex);
+
+	return ret;
+}
+
+
+static int rga_open(struct inode *inode, struct file *file)
+{
+    rga_session *session = kzalloc(sizeof(rga_session), GFP_KERNEL);
+	if (NULL == session) {
+		pr_err("unable to allocate memory for rga_session.");
+		return -ENOMEM;
+	}
+
+	session->pid = current->pid;
+    //printk(KERN_DEBUG  "+");
+
+	INIT_LIST_HEAD(&session->waiting);
+	INIT_LIST_HEAD(&session->running);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	mutex_lock(&rga_service.lock);
+	list_add_tail(&session->list_session, &rga_service.session);
+	mutex_unlock(&rga_service.lock);
+	atomic_set(&session->task_running, 0);
+    atomic_set(&session->num_done, 0);
+
+	file->private_data = (void *)session;
+
+    //DBG("*** rga dev opened by pid %d *** \n", session->pid);
+	return nonseekable_open(inode, file);
+
+}
+
+static int rga_release(struct inode *inode, struct file *file)
+{
+    int task_running;
+	rga_session *session = (rga_session *)file->private_data;
+	if (NULL == session)
+		return -EINVAL;
+    //printk(KERN_DEBUG  "-");
+	task_running = atomic_read(&session->task_running);
+
+    if (task_running)
+    {
+		pr_err("rga_service session %d still has %d task running when closing\n", session->pid, task_running);
+		msleep(100);
+        /**/
+	}
+
+	wake_up(&session->wait);
+	mutex_lock(&rga_service.lock);
+	list_del(&session->list_session);
+	rga_service_session_clear(session);
+	kfree(session);
+	mutex_unlock(&rga_service.lock);
+
+    //DBG("*** rga dev close ***\n");
+	return 0;
+}
+
+static irqreturn_t rga_irq_thread(int irq, void *dev_id)
+{
+	mutex_lock(&rga_service.lock);
+	if (rga_service.enable) {
+		rga_del_running_list();
+		rga_try_set_reg();
+	}
+	mutex_unlock(&rga_service.lock);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rga_irq(int irq,  void *dev_id)
+{
+	/*clear INT */
+	rga_write(rga_read(RGA_INT) | (0x1<<6) | (0x1<<7) | (0x1<<4), RGA_INT);
+
+	return IRQ_WAKE_THREAD;
+}
+
+struct file_operations rga_fops = {
+	.owner		= THIS_MODULE,
+	.open		= rga_open,
+	.release	= rga_release,
+	.unlocked_ioctl		= rga_ioctl,
+};
+
+static struct miscdevice rga_dev ={
+    .minor = RGA_MAJOR,
+    .name  = "rga",
+    .fops  = &rga_fops,
+};
+
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rockchip_rga_dt_ids[] = {
+	{ .compatible = "rockchip,rk312x-rga", },
+	{},
+};
+#endif
+
+static int rga_drv_probe(struct platform_device *pdev)
+{
+	struct rga_drvdata *data;
+    struct resource *res;
+    //struct device_node *np = pdev->dev.of_node;
+	int ret = 0;
+
+	mutex_init(&rga_service.lock);
+	mutex_init(&rga_service.mutex);
+	atomic_set(&rga_service.total_running, 0);
+	rga_service.enable = false;
+
+    rga_ioctl_kernel_p = rga_ioctl_kernel_imp;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(struct rga_drvdata), GFP_KERNEL);
+	if(! data) {
+		ERR("failed to allocate driver data.\n");
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&data->power_off_work, rga_power_off_work);
+	wake_lock_init(&data->wake_lock, WAKE_LOCK_SUSPEND, "rga");
+
+	//data->pd_rga = devm_clk_get(&pdev->dev, "pd_rga");
+    data->aclk_rga = devm_clk_get(&pdev->dev, "aclk_rga");
+    data->hclk_rga = devm_clk_get(&pdev->dev, "hclk_rga");
+
+    /* map the registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->rga_base = devm_ioremap_resource(&pdev->dev, res);
+	if (!data->rga_base) {
+		ERR("rga ioremap failed\n");
+		ret = -ENOENT;
+		goto err_ioremap;
+	}
+
+	/* get the IRQ */
+	data->irq = ret = platform_get_irq(pdev, 0);
+	if (ret <= 0) {
+		ERR("failed to get rga irq resource (%d).\n", data->irq);
+		ret = data->irq;
+		goto err_irq;
+	}
+
+	/* request the IRQ */
+	//ret = request_threaded_irq(data->irq, rga_irq, rga_irq_thread, 0, "rga", pdev);
+    ret = devm_request_threaded_irq(&pdev->dev, data->irq, rga_irq, rga_irq_thread, 0, "rga", data);
+	if (ret)
+	{
+		ERR("rga request_irq failed (%d).\n", ret);
+		goto err_irq;
+	}
+
+	platform_set_drvdata(pdev, data);
+	data->dev = &pdev->dev;
+	drvdata = data;
+
+    #if defined(CONFIG_ION_ROCKCHIP)
+	data->ion_client = rockchip_ion_client_create("rga");
+	if (IS_ERR(data->ion_client)) {
+		dev_err(&pdev->dev, "failed to create ion client for rga");
+		return PTR_ERR(data->ion_client);
+	} else {
+		dev_info(&pdev->dev, "rga ion client create success!\n");
+	}
+    #endif
+
+	ret = misc_register(&rga_dev);
+	if(ret)
+	{
+		ERR("cannot register miscdev (%d)\n", ret);
+		goto err_misc_register;
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_enable(&pdev->dev);
+#endif
+
+	pr_info("Driver loaded succesfully\n");
+
+	return 0;
+
+err_misc_register:
+	free_irq(data->irq, pdev);
+err_irq:
+	iounmap(data->rga_base);
+err_ioremap:
+	wake_lock_destroy(&data->wake_lock);
+	//kfree(data);
+
+	return ret;
+}
+
+static int rga_drv_remove(struct platform_device *pdev)
+{
+	struct rga_drvdata *data = platform_get_drvdata(pdev);
+	DBG("%s [%d]\n",__FUNCTION__,__LINE__);
+
+	wake_lock_destroy(&data->wake_lock);
+	misc_deregister(&(data->miscdev));
+	free_irq(data->irq, &data->miscdev);
+	iounmap((void __iomem *)(data->rga_base));
+	kfree(data->version);
+
+	//clk_put(data->pd_rga);
+	devm_clk_put(&pdev->dev, data->aclk_rga);
+	devm_clk_put(&pdev->dev, data->hclk_rga);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_disable(&pdev->dev);
+#endif
+
+	//kfree(data);
+	return 0;
+}
+
+static struct platform_driver rga_driver = {
+	.probe		= rga_drv_probe,
+	.remove		= rga_drv_remove,
+	.driver		= {
+		.name	= "rga",
+		.of_match_table = of_match_ptr(rockchip_rga_dt_ids),
+	},
+};
+
+
+void rga_test_0(void);
+void rga_test_1(void);
+
+
+static int __init rga_init(void)
+{
+	int ret;
+    uint32_t *mmu_buf;
+    unsigned long *mmu_buf_virtual;
+    uint32_t i;
+    uint32_t *buf_p;
+    uint32_t *buf;
+
+    /* malloc pre scale mid buf mmu table */
+    mmu_buf = kzalloc(1024*8, GFP_KERNEL);
+    mmu_buf_virtual = kzalloc(1024*2*sizeof(unsigned long), GFP_KERNEL);
+    if(mmu_buf == NULL) {
+        printk(KERN_ERR "RGA get Pre Scale buff failed. \n");
+        return -1;
+    }
+	if (mmu_buf_virtual == NULL) {
+		return -1;
+	}
+
+    /* malloc 4 M buf */
+    for(i=0; i<1024; i++) {
+        buf_p = (uint32_t *)__get_free_page(GFP_KERNEL|__GFP_ZERO);
+        if(buf_p == NULL) {
+            printk(KERN_ERR "RGA init pre scale buf falied\n");
+            return -ENOMEM;
+        }
+        mmu_buf[i] = virt_to_phys((void *)((unsigned long)buf_p));
+        mmu_buf_virtual[i] = (unsigned long)buf_p;
+    }
+
+    rga_service.pre_scale_buf = (uint32_t *)mmu_buf;
+    rga_service.pre_scale_buf_virtual = (unsigned long *)mmu_buf_virtual;
+
+    buf_p = kmalloc(1024*256, GFP_KERNEL);
+    rga_mmu_buf.buf_virtual = buf_p;
+#if (defined(CONFIG_ARM) && defined(CONFIG_ARM_LPAE))
+    buf = (uint32_t *)(uint32_t)virt_to_phys((void *)((unsigned long)buf_p));
+#else
+    buf = (uint32_t *)virt_to_phys((void *)((unsigned long)buf_p));
+#endif
+    rga_mmu_buf.buf = buf;
+    rga_mmu_buf.front = 0;
+    rga_mmu_buf.back = 64*1024;
+    rga_mmu_buf.size = 64*1024;
+
+    rga_mmu_buf.pages = kmalloc((32768)* sizeof(struct page *), GFP_KERNEL);
+
+	if ((ret = platform_driver_register(&rga_driver)) != 0)
+	{
+        printk(KERN_ERR "Platform device register failed (%d).\n", ret);
+			return ret;
+	}
+
+    {
+        rga_session_global.pid = 0x0000ffff;
+        INIT_LIST_HEAD(&rga_session_global.waiting);
+        INIT_LIST_HEAD(&rga_session_global.running);
+        INIT_LIST_HEAD(&rga_session_global.list_session);
+
+        INIT_LIST_HEAD(&rga_service.waiting);
+	    INIT_LIST_HEAD(&rga_service.running);
+	    INIT_LIST_HEAD(&rga_service.done);
+	    INIT_LIST_HEAD(&rga_service.session);
+
+        init_waitqueue_head(&rga_session_global.wait);
+        //mutex_lock(&rga_service.lock);
+        list_add_tail(&rga_session_global.list_session, &rga_service.session);
+        //mutex_unlock(&rga_service.lock);
+        atomic_set(&rga_session_global.task_running, 0);
+        atomic_set(&rga_session_global.num_done, 0);
+    }
+
+
+
+    #if RGA_TEST_CASE
+    rga_test_0();
+    #endif
+
+	INFO("Module initialized.\n");
+
+	return 0;
+}
+
+static void __exit rga_exit(void)
+{
+    uint32_t i;
+
+    rga_power_off();
+
+    for(i=0; i<1024; i++)
+    {
+        if((unsigned long)rga_service.pre_scale_buf_virtual[i])
+        {
+            __free_page((void *)rga_service.pre_scale_buf_virtual[i]);
+        }
+    }
+
+    if(rga_service.pre_scale_buf != NULL) {
+        kfree((uint8_t *)rga_service.pre_scale_buf);
+    }
+
+    kfree(rga_mmu_buf.buf_virtual);
+
+    kfree(rga_mmu_buf.pages);
+
+	platform_driver_unregister(&rga_driver);
+}
+
+
+#if RGA_TEST_CASE
+
+extern struct fb_info * rk_get_fb(int fb_id);
+EXPORT_SYMBOL(rk_get_fb);
+
+extern void rk_direct_fb_show(struct fb_info * fbi);
+EXPORT_SYMBOL(rk_direct_fb_show);
+
+unsigned int src_buf[1920*1080];
+unsigned int dst_buf[1920*1080];
+//unsigned int tmp_buf[1920*1080 * 2];
+
+void rga_test_0(void)
+{
+    struct rga_req req;
+    rga_session session;
+    unsigned int *src, *dst;
+    uint32_t i, j;
+    uint8_t *p;
+    uint8_t t;
+    uint32_t *dst0, *dst1, *dst2;
+
+    struct fb_info *fb;
+
+    session.pid	= current->pid;
+	INIT_LIST_HEAD(&session.waiting);
+	INIT_LIST_HEAD(&session.running);
+	INIT_LIST_HEAD(&session.list_session);
+	init_waitqueue_head(&session.wait);
+	/* no need to protect */
+	list_add_tail(&session.list_session, &rga_service.session);
+	atomic_set(&session.task_running, 0);
+    atomic_set(&session.num_done, 0);
+	//file->private_data = (void *)session;
+
+    fb = rk_get_fb(0);
+
+    memset(&req, 0, sizeof(struct rga_req));
+    src = src_buf;
+    dst = dst_buf;
+
+    memset(src_buf, 0x80, 1024*600*4);
+
+    dmac_flush_range(&src_buf[0], &src_buf[1024*600]);
+    outer_flush_range(virt_to_phys(&src_buf[0]),virt_to_phys(&src_buf[1024*600]));
+
+
+    #if 0
+    memset(src_buf, 0x80, 800*480*4);
+    memset(dst_buf, 0xcc, 800*480*4);
+
+    dmac_flush_range(&dst_buf[0], &dst_buf[800*480]);
+    outer_flush_range(virt_to_phys(&dst_buf[0]),virt_to_phys(&dst_buf[800*480]));
+    #endif
+
+    dst0 = &dst_buf[0];
+    //dst1 = &dst_buf[1280*800*4];
+    //dst2 = &dst_buf[1280*800*4*2];
+
+    i = j = 0;
+
+    printk("\n********************************\n");
+    printk("************ RGA_TEST ************\n");
+    printk("********************************\n\n");
+
+    req.src.act_w = 1024;
+    req.src.act_h = 600;
+
+    req.src.vir_w = 1024;
+    req.src.vir_h = 600;
+    req.src.yrgb_addr = (uint32_t)virt_to_phys(src);
+    req.src.uv_addr = (uint32_t)(req.src.yrgb_addr + 1080*1920);
+    req.src.v_addr = (uint32_t)virt_to_phys(src);
+    req.src.format = RK_FORMAT_RGBA_8888;
+
+    req.dst.act_w = 600;
+    req.dst.act_h = 352;
+
+    req.dst.vir_w = 1280;
+    req.dst.vir_h = 800;
+    req.dst.x_offset = 600;
+    req.dst.y_offset = 0;
+
+    dst = dst0;
+
+    req.dst.yrgb_addr = ((uint32_t)virt_to_phys(dst));
+
+    //req.dst.format = RK_FORMAT_RGB_565;
+
+    req.clip.xmin = 0;
+    req.clip.xmax = 1279;
+    req.clip.ymin = 0;
+    req.clip.ymax = 799;
+
+    //req.render_mode = color_fill_mode;
+    //req.fg_color = 0x80ffffff;
+
+    req.rotate_mode = 1;
+    //req.scale_mode = 2;
+
+    //req.alpha_rop_flag = 0;
+    //req.alpha_rop_mode = 0x19;
+    //req.PD_mode = 3;
+
+    req.sina = 65536;
+    req.cosa = 0;
+
+    //req.mmu_info.mmu_flag = 0x21;
+    //req.mmu_info.mmu_en = 1;
+
+    //printk("src = %.8x\n", req.src.yrgb_addr);
+    //printk("src = %.8x\n", req.src.uv_addr);
+    //printk("dst = %.8x\n", req.dst.yrgb_addr);
+
+
+    rga_blit_sync(&session, &req);
+
+    #if 1
+    fb->var.bits_per_pixel = 32;
+
+    fb->var.xres = 1280;
+    fb->var.yres = 800;
+
+    fb->var.red.length = 8;
+    fb->var.red.offset = 0;
+    fb->var.red.msb_right = 0;
+
+    fb->var.green.length = 8;
+    fb->var.green.offset = 8;
+    fb->var.green.msb_right = 0;
+
+    fb->var.blue.length = 8;
+
+    fb->var.blue.offset = 16;
+    fb->var.blue.msb_right = 0;
+
+    fb->var.transp.length = 8;
+    fb->var.transp.offset = 24;
+    fb->var.transp.msb_right = 0;
+
+    fb->var.nonstd &= (~0xff);
+    fb->var.nonstd |= 1;
+
+    fb->fix.smem_start = virt_to_phys(dst);
+
+    rk_direct_fb_show(fb);
+    #endif
+
+}
+
+#endif
+fs_initcall(rga_init);
+module_exit(rga_exit);
+
+/* Module information */
+MODULE_AUTHOR("zsq@rock-chips.com");
+MODULE_DESCRIPTION("Driver for rga device");
+MODULE_LICENSE("GPL");
diff -Nupr a/drivers/video/rockchip/rga/rga.h b/drivers/video/rockchip/rga/rga.h
--- a/drivers/video/rockchip/rga/rga.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/rga.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,518 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RGA_DRIVER_H_
+#define _RGA_DRIVER_H_
+
+#include <linux/mutex.h>
+#include <linux/scatterlist.h>
+
+
+#define RGA_BLIT_SYNC	0x5017
+#define RGA_BLIT_ASYNC  0x5018
+#define RGA_FLUSH       0x5019
+#define RGA_GET_RESULT  0x501a
+#define RGA_GET_VERSION 0x501b
+
+
+#define RGA_REG_CTRL_LEN    0x8    /* 8  */
+#define RGA_REG_CMD_LEN     0x20   /* 32 */
+#define RGA_CMD_BUF_SIZE    0x700  /* 16*28*4 */
+
+#define RGA_OUT_OF_RESOURCES    -10
+#define RGA_MALLOC_ERROR        -11
+
+#define RGA_BUF_GEM_TYPE_MASK	0xC0
+
+#define rgaIS_ERROR(status)			(status < 0)
+#define rgaNO_ERROR(status)			(status >= 0)
+#define rgaIS_SUCCESS(status)		(status == 0)
+
+
+
+/* RGA process mode enum */
+enum
+{
+    bitblt_mode               = 0x0,
+    color_palette_mode        = 0x1,
+    color_fill_mode           = 0x2,
+    line_point_drawing_mode   = 0x3,
+    blur_sharp_filter_mode    = 0x4,
+    pre_scaling_mode          = 0x5,
+    update_palette_table_mode = 0x6,
+    update_patten_buff_mode   = 0x7,
+};
+
+
+enum
+{
+    rop_enable_mask          = 0x2,
+    dither_enable_mask       = 0x8,
+    fading_enable_mask       = 0x10,
+    PD_enbale_mask           = 0x20,
+};
+
+enum
+{
+    yuv2rgb_mode0            = 0x0,     /* BT.601 MPEG */
+    yuv2rgb_mode1            = 0x1,     /* BT.601 JPEG */
+    yuv2rgb_mode2            = 0x2,     /* BT.709      */
+};
+
+
+/* RGA rotate mode */
+enum
+{
+    rotate_mode0             = 0x0,     /* no rotate */
+    rotate_mode1             = 0x1,     /* rotate    */
+    rotate_mode2             = 0x2,     /* x_mirror  */
+    rotate_mode3             = 0x3,     /* y_mirror  */
+};
+
+enum
+{
+    color_palette_mode0      = 0x0,     /* 1K */
+    color_palette_mode1      = 0x1,     /* 2K */
+    color_palette_mode2      = 0x2,     /* 4K */
+    color_palette_mode3      = 0x3,     /* 8K */
+};
+
+
+
+/*
+//          Alpha    Red     Green   Blue
+{  4, 32, {{32,24,   8, 0,  16, 8,  24,16 }}, GGL_RGBA },   // RK_FORMAT_RGBA_8888
+{  4, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGBX_8888
+{  3, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGB_888
+{  4, 32, {{32,24,  24,16,  16, 8,   8, 0 }}, GGL_BGRA },   // RK_FORMAT_BGRA_8888
+{  2, 16, {{ 0, 0,  16,11,  11, 5,   5, 0 }}, GGL_RGB  },   // RK_FORMAT_RGB_565
+{  2, 16, {{ 1, 0,  16,11,  11, 6,   6, 1 }}, GGL_RGBA },   // RK_FORMAT_RGBA_5551
+{  2, 16, {{ 4, 0,  16,12,  12, 8,   8, 4 }}, GGL_RGBA },   // RK_FORMAT_RGBA_4444
+{  3, 24, {{ 0, 0,  24,16,  16, 8,   8, 0 }}, GGL_BGR  },   // RK_FORMAT_BGB_888
+
+*/
+enum
+{
+	RK_FORMAT_RGBA_8888    = 0x0,
+    RK_FORMAT_RGBX_8888    = 0x1,
+    RK_FORMAT_RGB_888      = 0x2,
+    RK_FORMAT_BGRA_8888    = 0x3,
+    RK_FORMAT_RGB_565      = 0x4,
+    RK_FORMAT_RGBA_5551    = 0x5,
+    RK_FORMAT_RGBA_4444    = 0x6,
+    RK_FORMAT_BGR_888      = 0x7,
+
+    RK_FORMAT_YCbCr_422_SP = 0x8,
+    RK_FORMAT_YCbCr_422_P  = 0x9,
+    RK_FORMAT_YCbCr_420_SP = 0xa,
+    RK_FORMAT_YCbCr_420_P  = 0xb,
+
+    RK_FORMAT_YCrCb_422_SP = 0xc,
+    RK_FORMAT_YCrCb_422_P  = 0xd,
+    RK_FORMAT_YCrCb_420_SP = 0xe,
+    RK_FORMAT_YCrCb_420_P  = 0xf,
+
+    RK_FORMAT_BPP1         = 0x10,
+    RK_FORMAT_BPP2         = 0x11,
+    RK_FORMAT_BPP4         = 0x12,
+    RK_FORMAT_BPP8         = 0x13,
+    RK_FORMAT_YCbCr_420_SP_10B = 0x20,
+    RK_FORMAT_YCrCb_420_SP_10B = 0x21,
+};
+
+
+typedef struct rga_img_info_t
+{
+    unsigned long yrgb_addr;      /* yrgb    mem addr         */
+    unsigned long uv_addr;        /* cb/cr   mem addr         */
+    unsigned long v_addr;         /* cr      mem addr         */
+    unsigned int format;         //definition by RK_FORMAT
+
+    unsigned short act_w;
+    unsigned short act_h;
+    unsigned short x_offset;
+    unsigned short y_offset;
+
+    unsigned short vir_w;
+    unsigned short vir_h;
+
+    unsigned short endian_mode; //for BPP
+    unsigned short alpha_swap;
+}
+rga_img_info_t;
+
+
+typedef struct mdp_img_act
+{
+    unsigned short w;         // width
+    unsigned short h;         // height
+    short x_off;     // x offset for the vir
+    short y_off;     // y offset for the vir
+}
+mdp_img_act;
+
+
+
+typedef struct RANGE
+{
+    unsigned short min;
+    unsigned short max;
+}
+RANGE;
+
+typedef struct POINT
+{
+    unsigned short x;
+    unsigned short y;
+}
+POINT;
+
+typedef struct RECT
+{
+    unsigned short xmin;
+    unsigned short xmax; // width - 1
+    unsigned short ymin;
+    unsigned short ymax; // height - 1
+} RECT;
+
+typedef struct RGB
+{
+    unsigned char r;
+    unsigned char g;
+    unsigned char b;
+    unsigned char res;
+}RGB;
+
+
+typedef struct MMU
+{
+    unsigned char mmu_en;
+    unsigned long base_addr;
+	uint32_t mmu_flag;
+
+	unsigned long src0_base_addr;
+	unsigned long src1_base_addr;
+	unsigned long dst_base_addr;
+	unsigned long els_base_addr;
+
+	u8 src0_mmu_flag;
+	u8 src1_mmu_flag;
+	u8 dst_mmu_flag;
+	u8 els_mmu_flag;
+} MMU;
+
+
+
+
+typedef struct COLOR_FILL
+{
+    short gr_x_a;
+    short gr_y_a;
+    short gr_x_b;
+    short gr_y_b;
+    short gr_x_g;
+    short gr_y_g;
+    short gr_x_r;
+    short gr_y_r;
+
+    //u8  cp_gr_saturation;
+}
+COLOR_FILL;
+
+typedef struct FADING
+{
+    uint8_t b;
+    uint8_t g;
+    uint8_t r;
+    uint8_t res;
+}
+FADING;
+
+
+typedef struct line_draw_t
+{
+    POINT start_point;              /* LineDraw_start_point                */
+    POINT end_point;                /* LineDraw_end_point                  */
+    uint32_t   color;               /* LineDraw_color                      */
+    uint32_t   flag;                /* (enum) LineDrawing mode sel         */
+    uint32_t   line_width;          /* range 1~16 */
+}
+line_draw_t;
+
+
+
+struct rga_req {
+    uint8_t render_mode;            /* (enum) process mode sel */
+
+    rga_img_info_t src;             /* src image info */
+    rga_img_info_t dst;             /* dst image info */
+    rga_img_info_t pat;             /* patten image info */
+
+    unsigned long rop_mask_addr;         /* rop4 mask addr */
+    unsigned long LUT_addr;              /* LUT addr */
+
+    RECT clip;                      /* dst clip window default value is dst_vir */
+                                    /* value from [0, w-1] / [0, h-1]*/
+
+    int32_t sina;                   /* dst angle  default value 0  16.16 scan from table */
+    int32_t cosa;                   /* dst angle  default value 0  16.16 scan from table */
+
+    uint16_t alpha_rop_flag;        /* alpha rop process flag           */
+                                    /* ([0] = 1 alpha_rop_enable)       */
+                                    /* ([1] = 1 rop enable)             */
+                                    /* ([2] = 1 fading_enable)          */
+                                    /* ([3] = 1 PD_enable)              */
+                                    /* ([4] = 1 alpha cal_mode_sel)     */
+                                    /* ([5] = 1 dither_enable)          */
+                                    /* ([6] = 1 gradient fill mode sel) */
+                                    /* ([7] = 1 AA_enable)              */
+
+    uint8_t  scale_mode;            /* 0 nearst / 1 bilnear / 2 bicubic */
+
+    uint32_t color_key_max;         /* color key max */
+    uint32_t color_key_min;         /* color key min */
+
+    uint32_t fg_color;              /* foreground color */
+    uint32_t bg_color;              /* background color */
+
+    COLOR_FILL gr_color;            /* color fill use gradient */
+
+    line_draw_t line_draw_info;
+
+    FADING fading;
+
+    uint8_t PD_mode;                /* porter duff alpha mode sel */
+
+    uint8_t alpha_global_value;     /* global alpha value */
+
+    uint16_t rop_code;              /* rop2/3/4 code  scan from rop code table*/
+
+    uint8_t bsfilter_flag;          /* [2] 0 blur 1 sharp / [1:0] filter_type*/
+
+    uint8_t palette_mode;           /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+
+    uint8_t yuv2rgb_mode;           /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+
+    uint8_t endian_mode;            /* 0/big endian 1/little endian*/
+
+    uint8_t rotate_mode;            /* (enum) rotate mode  */
+                                    /* 0x0,     no rotate  */
+                                    /* 0x1,     rotate     */
+                                    /* 0x2,     x_mirror   */
+                                    /* 0x3,     y_mirror   */
+
+    uint8_t color_fill_mode;        /* 0 solid color / 1 patten color */
+
+    MMU mmu_info;                   /* mmu information */
+
+    uint8_t  alpha_rop_mode;        /* ([0~1] alpha mode)       */
+                                    /* ([2~3] rop   mode)       */
+                                    /* ([4]   zero  mode en)    */
+                                    /* ([5]   dst   alpha mode) */
+
+    uint8_t  src_trans_mode;
+
+    struct sg_table *sg_src;
+	struct sg_table *sg_dst;
+	struct dma_buf_attachment *attach_src;
+	struct dma_buf_attachment *attach_dst;
+};
+
+
+typedef struct TILE_INFO
+{
+    int64_t matrix[4];
+
+    uint16_t tile_x_num;     /* x axis tile num / tile size is 8x8 pixel */
+    uint16_t tile_y_num;     /* y axis tile num */
+
+    int16_t dst_x_tmp;      /* dst pos x = (xstart - xoff) default value 0 */
+    int16_t dst_y_tmp;      /* dst pos y = (ystart - yoff) default value 0 */
+
+    uint16_t tile_w;
+    uint16_t tile_h;
+    int16_t tile_start_x_coor;
+    int16_t tile_start_y_coor;
+    int32_t tile_xoff;
+    int32_t tile_yoff;
+
+    int32_t tile_temp_xstart;
+    int32_t tile_temp_ystart;
+
+    /* src tile incr */
+    int32_t x_dx;
+    int32_t x_dy;
+    int32_t y_dx;
+    int32_t y_dy;
+
+    mdp_img_act dst_ctrl;
+
+}
+TILE_INFO;
+
+struct rga_mmu_buf_t {
+    int32_t front;
+    int32_t back;
+    int32_t size;
+    int32_t curr;
+    unsigned int *buf;
+    unsigned int *buf_virtual;
+
+    struct page **pages;
+};
+
+/**
+ * struct for process session which connect to rga
+ *
+ * @author ZhangShengqin (2012-2-15)
+ */
+typedef struct rga_session {
+	/* a linked list of data so we can access them for debugging */
+	struct list_head    list_session;
+	/* a linked list of register data waiting for process */
+	struct list_head    waiting;
+	/* a linked list of register data in processing */
+	struct list_head    running;
+	/* all coommand this thread done */
+    atomic_t            done;
+	wait_queue_head_t   wait;
+	pid_t           pid;
+	atomic_t        task_running;
+    atomic_t        num_done;
+} rga_session;
+
+struct rga_reg {
+    rga_session 		*session;
+	struct list_head	session_link;		/* link to rga service session */
+	struct list_head	status_link;		/* link to register set list */
+	uint32_t  sys_reg[RGA_REG_CTRL_LEN];
+    uint32_t  cmd_reg[RGA_REG_CMD_LEN];
+
+    uint32_t *MMU_base;
+    uint32_t MMU_len;
+    //atomic_t int_enable;
+
+    //struct rga_req      req;
+
+	struct sg_table *sg_src;
+	struct sg_table *sg_dst;
+
+	struct dma_buf_attachment *attach_src;
+	struct dma_buf_attachment *attach_dst;
+};
+
+
+
+typedef struct rga_service_info {
+    struct mutex	lock;
+    struct timer_list	timer;			/* timer for power off */
+    struct list_head	waiting;		/* link to link_reg in struct vpu_reg */
+    struct list_head	running;		/* link to link_reg in struct vpu_reg */
+    struct list_head	done;			/* link to link_reg in struct vpu_reg */
+    struct list_head	session;		/* link to list_session in struct vpu_session */
+    atomic_t		total_running;
+
+    struct rga_reg        *reg;
+
+    uint32_t            cmd_buff[28*8];/* cmd_buff for rga */
+    uint32_t            *pre_scale_buf;
+    unsigned long       *pre_scale_buf_virtual;
+	atomic_t            int_disable;     /* 0 int enable 1 int disable  */
+    atomic_t            cmd_num;
+	atomic_t src_format_swt;
+	int last_prc_src_format;
+	atomic_t            rga_working;
+    bool                enable;
+	u32 dev_mode;
+
+    //struct rga_req      req[10];
+
+    struct mutex	mutex;	// mutex
+} rga_service_info;
+
+
+
+#if defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026) || defined(CONFIG_ARCH_RK312x)
+#define RGA_BASE                 0x1010c000
+#elif defined(CONFIG_ARCH_RK30)
+#define RGA_BASE                 0x10114000
+#endif
+
+//General Registers
+#define RGA_SYS_CTRL             0x000
+#define RGA_CMD_CTRL             0x004
+#define RGA_CMD_ADDR             0x008
+#define RGA_STATUS               0x00c
+#define RGA_INT                  0x010
+#define RGA_AXI_ID               0x014
+#define RGA_MMU_STA_CTRL         0x018
+#define RGA_MMU_STA              0x01c
+#define RGA_VERSION              0x028
+
+//Command code start
+#define RGA_MODE_CTRL            0x100
+
+//Source Image Registers
+#define RGA_SRC_Y_MST            0x104
+#define RGA_SRC_CB_MST           0x108
+#define RGA_MASK_READ_MST        0x108  //repeat
+#define RGA_SRC_CR_MST           0x10c
+#define RGA_SRC_VIR_INFO         0x110
+#define RGA_SRC_ACT_INFO         0x114
+#define RGA_SRC_X_PARA           0x118
+#define RGA_SRC_Y_PARA           0x11c
+#define RGA_SRC_TILE_XINFO       0x120
+#define RGA_SRC_TILE_YINFO       0x124
+#define RGA_SRC_TILE_H_INCR      0x128
+#define RGA_SRC_TILE_V_INCR      0x12c
+#define RGA_SRC_TILE_OFFSETX     0x130
+#define RGA_SRC_TILE_OFFSETY     0x134
+#define RGA_SRC_BG_COLOR         0x138
+#define RGA_SRC_FG_COLOR         0x13c
+#define RGA_LINE_DRAWING_COLOR   0x13c  //repeat
+#define RGA_SRC_TR_COLOR0        0x140
+#define RGA_CP_GR_A              0x140  //repeat
+#define RGA_SRC_TR_COLOR1        0x144
+#define RGA_CP_GR_B              0x144  //repeat
+
+#define RGA_LINE_DRAW            0x148
+#define RGA_PAT_START_POINT      0x148  //repeat
+
+//Destination Image Registers
+#define RGA_DST_MST              0x14c
+#define RGA_LUT_MST              0x14c  //repeat
+#define RGA_PAT_MST              0x14c  //repeat
+#define RGA_LINE_DRAWING_MST     0x14c  //repeat
+
+#define RGA_DST_VIR_INFO         0x150
+
+#define RGA_DST_CTR_INFO         0x154
+#define RGA_LINE_DRAW_XY_INFO    0x154  //repeat
+
+//Alpha/ROP Registers
+#define RGA_ALPHA_CON            0x158
+
+#define RGA_PAT_CON              0x15c
+#define RGA_DST_VIR_WIDTH_PIX    0x15c  //repeat
+
+#define RGA_ROP_CON0             0x160
+#define RGA_CP_GR_G              0x160  //repeat
+#define RGA_PRESCL_CB_MST        0x160  //repeat
+
+#define RGA_ROP_CON1             0x164
+#define RGA_CP_GR_R              0x164  //repeat
+#define RGA_PRESCL_CR_MST        0x164  //repeat
+
+//MMU Register
+#define RGA_FADING_CON           0x168
+#define RGA_MMU_CTRL             0x168  //repeat
+
+#define RGA_MMU_TBL              0x16c  //repeat
+
+#define RGA_YUV_OUT_CFG          0x170
+#define RGA_DST_UV_MST           0x174
+
+
+#define RGA_BLIT_COMPLETE_EVENT 1
+
+long rga_ioctl_kernel(struct rga_req *req);
+
+#endif /*_RK29_IPP_DRIVER_H_*/
diff -Nupr a/drivers/video/rockchip/rga/rga_mmu_info.c b/drivers/video/rockchip/rga/rga_mmu_info.c
--- a/drivers/video/rockchip/rga/rga_mmu_info.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/rga_mmu_info.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1214 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/pagemap.h>
+#include <linux/seq_file.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/memory.h>
+#include <linux/dma-mapping.h>
+#include <asm/memory.h>
+#include <asm/atomic.h>
+#include <asm/cacheflush.h>
+#include "rga_mmu_info.h"
+#include <linux/delay.h>
+
+extern rga_service_info rga_service;
+extern struct rga_mmu_buf_t rga_mmu_buf;
+
+#define KERNEL_SPACE_VALID    0xc0000000
+
+static int rga_mmu_buf_get(struct rga_mmu_buf_t *t, uint32_t size)
+{
+    mutex_lock(&rga_service.lock);
+    t->front += size;
+    mutex_unlock(&rga_service.lock);
+
+    return 0;
+}
+
+static int rga_mmu_buf_get_try(struct rga_mmu_buf_t *t, uint32_t size)
+{
+	int ret = 0;
+
+	mutex_lock(&rga_service.lock);
+	if ((t->back - t->front) > t->size) {
+		if(t->front + size > t->back - t->size) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	} else {
+		if ((t->front + size) > t->back) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		if (t->front + size > t->size) {
+			if (size > (t->back - t->size)) {
+				ret = -ENOMEM;
+				goto out;
+			}
+			t->front = 0;
+		}
+	}
+
+out:
+	mutex_unlock(&rga_service.lock);
+	return ret;
+}
+
+static int rga_mem_size_cal(unsigned long Mem, uint32_t MemSize, unsigned long *StartAddr)
+{
+    unsigned long start, end;
+    uint32_t pageCount;
+
+    end = (Mem + (MemSize + PAGE_SIZE - 1)) >> PAGE_SHIFT;
+    start = Mem >> PAGE_SHIFT;
+    pageCount = end - start;
+    *StartAddr = start;
+    return pageCount;
+}
+
+static int rga_buf_size_cal(unsigned long yrgb_addr, unsigned long uv_addr, unsigned long v_addr,
+                                        int format, uint32_t w, uint32_t h, unsigned long *StartAddr )
+{
+    uint32_t size_yrgb = 0;
+    uint32_t size_uv = 0;
+    uint32_t size_v = 0;
+    uint32_t stride = 0;
+    unsigned long start, end;
+    uint32_t pageCount;
+
+    switch(format)
+    {
+        case RK_FORMAT_RGBA_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RK_FORMAT_RGBX_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RK_FORMAT_RGB_888 :
+            stride = (w * 3 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RK_FORMAT_BGRA_8888 :
+            size_yrgb = w*h*4;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RK_FORMAT_RGB_565 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RK_FORMAT_RGBA_5551 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RK_FORMAT_RGBA_4444 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RK_FORMAT_BGR_888 :
+            stride = (w*3 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+
+        /* YUV FORMAT */
+        case RK_FORMAT_YCbCr_422_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = stride * h;
+            start = MIN(yrgb_addr, uv_addr);
+
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RK_FORMAT_YCbCr_422_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * h);
+            size_v = ((stride >> 1) * h);
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start = start >> PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RK_FORMAT_YCbCr_420_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = (stride * (h >> 1));
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RK_FORMAT_YCbCr_420_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * (h >> 1));
+            size_v = ((stride >> 1) * (h >> 1));
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+
+        case RK_FORMAT_YCrCb_422_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = stride * h;
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RK_FORMAT_YCrCb_422_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * h);
+            size_v = ((stride >> 1) * h);
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+
+        case RK_FORMAT_YCrCb_420_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = (stride * (h >> 1));
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RK_FORMAT_YCrCb_420_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * (h >> 1));
+            size_v = ((stride >> 1) * (h >> 1));
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        #if 0
+        case RK_FORMAT_BPP1 :
+            break;
+        case RK_FORMAT_BPP2 :
+            break;
+        case RK_FORMAT_BPP4 :
+            break;
+        case RK_FORMAT_BPP8 :
+            break;
+        #endif
+        default :
+            pageCount = 0;
+            start = 0;
+            break;
+    }
+
+    *StartAddr = start;
+    return pageCount;
+}
+
+static int rga_MapUserMemory(struct page **pages,
+                                            uint32_t *pageTable,
+                                            unsigned long Memory,
+                                            uint32_t pageCount)
+{
+    int32_t result;
+    uint32_t i;
+    uint32_t status;
+    unsigned long Address;
+
+    status = 0;
+    Address = 0;
+
+    do {
+        down_read(&current->mm->mmap_sem);
+        result = get_user_pages(current,
+                current->mm,
+                Memory << PAGE_SHIFT,
+                pageCount,
+                1,
+                0,
+                pages,
+                NULL
+                );
+        up_read(&current->mm->mmap_sem);
+
+        #if 0
+        if(result <= 0 || result < pageCount)
+        {
+            status = 0;
+
+            for(i=0; i<pageCount; i++)
+            {
+                temp = armv7_va_to_pa((Memory + i) << PAGE_SHIFT);
+                if (temp == 0xffffffff)
+                {
+                    printk("rga find mmu phy ddr error\n ");
+                    status = RGA_OUT_OF_RESOURCES;
+                    break;
+                }
+
+                pageTable[i] = temp;
+            }
+
+            return status;
+        }
+        #else
+        if(result <= 0 || result < pageCount)
+        {
+            struct vm_area_struct *vma;
+
+            if (result>0) {
+			    down_read(&current->mm->mmap_sem);
+			    for (i = 0; i < result; i++)
+				    put_page(pages[i]);
+			    up_read(&current->mm->mmap_sem);
+		    }
+
+            for(i=0; i<pageCount; i++)
+            {
+                vma = find_vma(current->mm, (Memory + i) << PAGE_SHIFT);
+
+                if (vma)//&& (vma->vm_flags & VM_PFNMAP) )
+                {
+                    do
+                    {
+                        pte_t       * pte;
+                        spinlock_t  * ptl;
+                        unsigned long pfn;
+                        pgd_t * pgd;
+                        pud_t * pud;
+
+                        pgd = pgd_offset(current->mm, (Memory + i) << PAGE_SHIFT);
+
+                        if(pgd_val(*pgd) == 0)
+                        {
+                            //printk("rga pgd value is zero \n");
+                            break;
+                        }
+
+                        pud = pud_offset(pgd, (Memory + i) << PAGE_SHIFT);
+                        if (pud)
+                        {
+                            pmd_t * pmd = pmd_offset(pud, (Memory + i) << PAGE_SHIFT);
+                            if (pmd)
+                            {
+                                pte = pte_offset_map_lock(current->mm, pmd, (Memory + i) << PAGE_SHIFT, &ptl);
+                                if (!pte)
+                                {
+                                    pte_unmap_unlock(pte, ptl);
+                                    break;
+                                }
+                            }
+                            else
+                            {
+                                break;
+                            }
+                        }
+                        else
+                        {
+                            break;
+                        }
+
+                        pfn = pte_pfn(*pte);
+                        Address = ((pfn << PAGE_SHIFT) | (((unsigned long)((Memory + i) << PAGE_SHIFT)) & ~PAGE_MASK));
+                        pte_unmap_unlock(pte, ptl);
+                    }
+                    while (0);
+
+                    pageTable[i] = Address;
+                }
+                else
+                {
+                    status = RGA_OUT_OF_RESOURCES;
+                    break;
+                }
+            }
+
+            return status;
+        }
+        #endif
+
+        /* Fill the page table. */
+        for(i=0; i<pageCount; i++)
+        {
+            /* Get the physical address from page struct. */
+            pageTable[i] = page_to_phys(pages[i]);
+        }
+
+        down_read(&current->mm->mmap_sem);
+		for (i = 0; i < result; i++)
+			put_page(pages[i]);
+		up_read(&current->mm->mmap_sem);
+
+        return 0;
+    }
+    while(0);
+
+    return status;
+}
+
+static int rga_MapION(struct sg_table *sg,
+                               uint32_t *Memory,
+                               int32_t  pageCount,
+                               uint32_t offset)
+{
+    uint32_t i;
+    uint32_t status;
+    unsigned long Address;
+    uint32_t mapped_size = 0;
+    uint32_t len = 0;
+    struct scatterlist *sgl = sg->sgl;
+    uint32_t sg_num = 0;
+
+    status = 0;
+    Address = 0;
+    offset = offset >> PAGE_SHIFT;
+    if (offset != 0) {
+        do {
+            len += (sg_dma_len(sgl) >> PAGE_SHIFT);
+	        if (len == offset) {
+	    	    sg_num += 1;
+		    break;
+    	    }
+    	    else {
+                if (len > offset)
+                     break;
+    	    }
+                sg_num += 1;
+        }
+        while((sgl = sg_next(sgl)) && (mapped_size < pageCount) && (sg_num < sg->nents));
+
+        sgl = sg->sgl;
+    	len = 0;
+        do {
+            len += (sg_dma_len(sgl) >> PAGE_SHIFT);
+            sgl = sg_next(sgl);
+        }
+        while(--sg_num);
+
+        offset -= len;
+
+        len = sg_dma_len(sgl) >> PAGE_SHIFT;
+        Address = sg_phys(sgl);
+    	Address += offset;
+
+        for(i=offset; i<len; i++) {
+             Memory[i - offset] = Address + (i << PAGE_SHIFT);
+        }
+        mapped_size += (len - offset);
+        sg_num = 1;
+        sgl = sg_next(sgl);
+        do {
+            len = sg_dma_len(sgl) >> PAGE_SHIFT;
+            Address = sg_phys(sgl);
+
+            for(i=0; i<len; i++) {
+                Memory[mapped_size + i] = Address + (i << PAGE_SHIFT);
+            }
+
+            mapped_size += len;
+            sg_num += 1;
+        }
+        while((sgl = sg_next(sgl)) && (mapped_size < pageCount) && (sg_num < sg->nents));
+    }
+    else {
+        do {
+            len = sg_dma_len(sgl) >> PAGE_SHIFT;
+            Address = sg_phys(sgl);
+            for(i=0; i<len; i++) {
+                Memory[mapped_size + i] = Address + (i << PAGE_SHIFT);
+            }
+            mapped_size += len;
+            sg_num += 1;
+        }
+        while((sgl = sg_next(sgl)) && (mapped_size < pageCount) && (sg_num < sg->nents));
+    }
+    return 0;
+}
+
+
+static int rga_mmu_info_BitBlt_mode(struct rga_reg *reg, struct rga_req *req)
+{
+    int SrcMemSize, DstMemSize;
+    unsigned long SrcStart, DstStart;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p, *MMU_Base_phys;
+    int ret;
+    int status;
+    uint32_t uv_size, v_size;
+
+    struct page **pages = NULL;
+
+    MMU_Base = NULL;
+
+    SrcMemSize = 0;
+    DstMemSize = 0;
+
+    do {
+        /* cal src buf mmu info */
+        SrcMemSize = rga_buf_size_cal(req->src.yrgb_addr, req->src.uv_addr, req->src.v_addr,
+                                        req->src.format, req->src.vir_w, req->src.act_h + req->src.y_offset,
+                                        &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        /* cal dst buf mmu info */
+
+        DstMemSize = rga_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                        &DstStart);
+        if(DstMemSize == 0)
+            return -EINVAL;
+
+        /* Cal out the needed mem size */
+        SrcMemSize = (SrcMemSize + 15) & (~15);
+        DstMemSize = (DstMemSize + 15) & (~15);
+        AllSize = SrcMemSize + DstMemSize;
+
+        if (rga_mmu_buf_get_try(&rga_mmu_buf, AllSize + 16)) {
+            pr_err("RGA Get MMU mem failed\n");
+            status = RGA_MALLOC_ERROR;
+            break;
+        }
+
+        mutex_lock(&rga_service.lock);
+        MMU_Base = rga_mmu_buf.buf_virtual + (rga_mmu_buf.front & (rga_mmu_buf.size - 1));
+        MMU_Base_phys = rga_mmu_buf.buf + (rga_mmu_buf.front & (rga_mmu_buf.size - 1));
+        mutex_unlock(&rga_service.lock);
+
+        pages = rga_mmu_buf.pages;
+
+        if((req->mmu_info.mmu_flag >> 8) & 1) {
+            if (req->sg_src) {
+                ret = rga_MapION(req->sg_src, &MMU_Base[0], SrcMemSize, req->line_draw_info.flag);
+            }
+            else {
+                ret = rga_MapUserMemory(&pages[0], &MMU_Base[0], SrcStart, SrcMemSize);
+                if (ret < 0) {
+                    pr_err("rga map src memory failed\n");
+                    status = ret;
+                    break;
+                }
+            }
+        }
+        else {
+            MMU_p = MMU_Base;
+
+            if(req->src.yrgb_addr == (unsigned long)rga_service.pre_scale_buf) {
+                for(i=0; i<SrcMemSize; i++)
+                    MMU_p[i] = rga_service.pre_scale_buf[i];
+            }
+            else {
+                for(i=0; i<SrcMemSize; i++)
+                    MMU_p[i] = (uint32_t)((SrcStart + i) << PAGE_SHIFT);
+            }
+        }
+
+        if ((req->mmu_info.mmu_flag >> 10) & 1) {
+            if (req->sg_dst) {
+                ret = rga_MapION(req->sg_dst, &MMU_Base[SrcMemSize], DstMemSize, req->line_draw_info.line_width);
+            }
+            else {
+                ret = rga_MapUserMemory(&pages[SrcMemSize], &MMU_Base[SrcMemSize], DstStart, DstMemSize);
+                if (ret < 0) {
+                    pr_err("rga map dst memory failed\n");
+                    status = ret;
+                    break;
+                }
+            }
+        }
+        else {
+            MMU_p = MMU_Base + SrcMemSize;
+            for(i=0; i<DstMemSize; i++)
+                MMU_p[i] = (uint32_t)((DstStart + i) << PAGE_SHIFT);
+        }
+
+        MMU_Base[AllSize] = MMU_Base[AllSize-1];
+
+        /* zsq
+         * change the buf address in req struct
+         */
+
+        req->mmu_info.base_addr = (unsigned long)MMU_Base_phys >> 2;
+
+        uv_size = (req->src.uv_addr - (SrcStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+        v_size = (req->src.v_addr - (SrcStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK));
+        req->src.uv_addr = (req->src.uv_addr & (~PAGE_MASK)) | (uv_size << PAGE_SHIFT);
+        req->src.v_addr = (req->src.v_addr & (~PAGE_MASK)) | (v_size << PAGE_SHIFT);
+
+        uv_size = (req->dst.uv_addr - (DstStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+
+        req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK)) | (SrcMemSize << PAGE_SHIFT);
+        req->dst.uv_addr = (req->dst.uv_addr & (~PAGE_MASK)) | ((SrcMemSize + uv_size) << PAGE_SHIFT);
+
+        /* flush data to DDR */
+        #ifdef CONFIG_ARM
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        outer_flush_range(virt_to_phys(MMU_Base), virt_to_phys(MMU_Base + AllSize + 1));
+        #elif defined(CONFIG_ARM64)
+        __dma_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        #endif
+
+        rga_mmu_buf_get(&rga_mmu_buf, AllSize + 16);
+        reg->MMU_len = AllSize + 16;
+
+        status = 0;
+
+        return status;
+    }
+    while(0);
+
+    return status;
+}
+
+static int rga_mmu_info_color_palette_mode(struct rga_reg *reg, struct rga_req *req)
+{
+    int SrcMemSize, DstMemSize, CMDMemSize;
+    unsigned long SrcStart, DstStart, CMDStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base = NULL, *MMU_Base_phys = NULL;
+    uint32_t *MMU_p;
+    int ret, status;
+    uint32_t stride;
+
+    uint8_t shift;
+    uint16_t sw, byte_num;
+
+    shift = 3 - (req->palette_mode & 3);
+    sw = req->src.vir_w;
+    byte_num = sw >> shift;
+    stride = (byte_num + 3) & (~3);
+
+    do {
+        SrcMemSize = rga_mem_size_cal(req->src.yrgb_addr, stride, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        DstMemSize = rga_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                        &DstStart);
+        if(DstMemSize == 0) {
+            return -EINVAL;
+        }
+
+        CMDMemSize = rga_mem_size_cal((unsigned long)rga_service.cmd_buff, RGA_CMD_BUF_SIZE, &CMDStart);
+        if(CMDMemSize == 0) {
+            return -EINVAL;
+        }
+
+        SrcMemSize = (SrcMemSize + 15) & (~15);
+        DstMemSize = (DstMemSize + 15) & (~15);
+        CMDMemSize = (CMDMemSize + 15) & (~15);
+
+        AllSize = SrcMemSize + DstMemSize + CMDMemSize;
+
+        if (rga_mmu_buf_get_try(&rga_mmu_buf, AllSize + 16)) {
+            pr_err("RGA Get MMU mem failed\n");
+            status = RGA_MALLOC_ERROR;
+            break;
+        }
+
+        mutex_lock(&rga_service.lock);
+        MMU_Base = rga_mmu_buf.buf_virtual + (rga_mmu_buf.front & (rga_mmu_buf.size - 1));
+        MMU_Base_phys = rga_mmu_buf.buf + (rga_mmu_buf.front & (rga_mmu_buf.size - 1));
+        mutex_unlock(&rga_service.lock);
+
+        pages = rga_mmu_buf.pages;
+
+        /* map CMD addr */
+        for(i=0; i<CMDMemSize; i++) {
+            MMU_Base[i] = (uint32_t)virt_to_phys((uint32_t *)((CMDStart + i)<<PAGE_SHIFT));
+        }
+
+        /* map src addr */
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID) {
+            ret = rga_MapUserMemory(&pages[CMDMemSize], &MMU_Base[CMDMemSize], SrcStart, SrcMemSize);
+            if (ret < 0) {
+                pr_err("rga map src memory failed\n");
+                status = ret;
+                break;
+            }
+        }
+        else {
+            MMU_p = MMU_Base + CMDMemSize;
+
+            for(i=0; i<SrcMemSize; i++)
+            {
+                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
+            }
+        }
+
+        /* map dst addr */
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID) {
+            ret = rga_MapUserMemory(&pages[CMDMemSize + SrcMemSize], &MMU_Base[CMDMemSize + SrcMemSize], DstStart, DstMemSize);
+            if (ret < 0) {
+                pr_err("rga map dst memory failed\n");
+                status = ret;
+                break;
+            }
+        }
+        else {
+            MMU_p = MMU_Base + CMDMemSize + SrcMemSize;
+            for(i=0; i<DstMemSize; i++)
+                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((DstStart + i) << PAGE_SHIFT));
+        }
+
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+        req->mmu_info.base_addr = (virt_to_phys(MMU_Base)>>2);
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
+        req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK)) | ((CMDMemSize + SrcMemSize) << PAGE_SHIFT);
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        #ifdef CONFIG_ARM
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize + 1));
+        #elif defined(CONFIG_ARM64)
+        __dma_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        #endif
+
+        rga_mmu_buf_get(&rga_mmu_buf, AllSize + 16);
+        reg->MMU_len = AllSize + 16;
+
+        return status;
+
+    }
+    while(0);
+
+    return 0;
+}
+
+static int rga_mmu_info_color_fill_mode(struct rga_reg *reg, struct rga_req *req)
+{
+    int DstMemSize;
+    unsigned long DstStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p, *MMU_Base_phys;
+    int ret;
+    int status;
+
+    MMU_Base = NULL;
+
+    do {
+        DstMemSize = rga_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                        &DstStart);
+        if(DstMemSize == 0) {
+            return -EINVAL;
+        }
+
+        AllSize = (DstMemSize + 15) & (~15);
+
+        pages = rga_mmu_buf.pages;
+
+        if (rga_mmu_buf_get_try(&rga_mmu_buf, AllSize + 16)) {
+            pr_err("RGA Get MMU mem failed\n");
+            status = RGA_MALLOC_ERROR;
+            break;
+        }
+
+        mutex_lock(&rga_service.lock);
+        MMU_Base = rga_mmu_buf.buf_virtual + (rga_mmu_buf.front & (rga_mmu_buf.size - 1));
+        MMU_Base_phys = rga_mmu_buf.buf + (rga_mmu_buf.front & (rga_mmu_buf.size - 1));
+        mutex_unlock(&rga_service.lock);
+
+        if (req->dst.yrgb_addr < KERNEL_SPACE_VALID) {
+            if (req->sg_dst) {
+                ret = rga_MapION(req->sg_dst, &MMU_Base[0], DstMemSize, req->line_draw_info.line_width);
+            }
+            else {
+                ret = rga_MapUserMemory(&pages[0], &MMU_Base[0], DstStart, DstMemSize);
+                if (ret < 0) {
+                    pr_err("rga map dst memory failed\n");
+                    status = ret;
+                    break;
+                }
+            }
+        }
+        else {
+            MMU_p = MMU_Base;
+            for(i=0; i<DstMemSize; i++)
+                MMU_p[i] = (uint32_t)((DstStart + i) << PAGE_SHIFT);
+        }
+
+        MMU_Base[AllSize] = MMU_Base[AllSize - 1];
+
+        /* zsq
+         * change the buf address in req struct
+         */
+
+        req->mmu_info.base_addr = ((unsigned long)(MMU_Base_phys)>>2);
+        req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        #ifdef CONFIG_ARM
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize + 1));
+        #elif defined(CONFIG_ARM64)
+        __dma_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        #endif
+
+        rga_mmu_buf_get(&rga_mmu_buf, AllSize + 16);
+        reg->MMU_len = AllSize + 16;
+
+        return 0;
+    }
+    while(0);
+
+    return status;
+}
+
+
+static int rga_mmu_info_line_point_drawing_mode(struct rga_reg *reg, struct rga_req *req)
+{
+    return 0;
+}
+
+static int rga_mmu_info_blur_sharp_filter_mode(struct rga_reg *reg, struct rga_req *req)
+{
+    return 0;
+}
+
+
+
+static int rga_mmu_info_pre_scale_mode(struct rga_reg *reg, struct rga_req *req)
+{
+    int SrcMemSize, DstMemSize;
+    unsigned long SrcStart, DstStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p, *MMU_Base_phys;
+    int ret;
+    int status;
+    uint32_t uv_size, v_size;
+
+    MMU_Base = NULL;
+
+    do {
+        /* cal src buf mmu info */
+        SrcMemSize = rga_buf_size_cal(req->src.yrgb_addr, req->src.uv_addr, req->src.v_addr,
+                                        req->src.format, req->src.vir_w, req->src.vir_h,
+                                        &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        /* cal dst buf mmu info */
+        DstMemSize = rga_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                        &DstStart);
+        if(DstMemSize == 0) {
+            return -EINVAL;
+        }
+
+	    SrcMemSize = (SrcMemSize + 15) & (~15);
+	    DstMemSize = (DstMemSize + 15) & (~15);
+
+        AllSize = SrcMemSize + DstMemSize;
+
+        pages = rga_mmu_buf.pages;
+
+        if (rga_mmu_buf_get_try(&rga_mmu_buf, AllSize + 16)) {
+            pr_err("RGA Get MMU mem failed\n");
+            status = RGA_MALLOC_ERROR;
+            break;
+        }
+
+        mutex_lock(&rga_service.lock);
+        MMU_Base = rga_mmu_buf.buf_virtual + (rga_mmu_buf.front & (rga_mmu_buf.size - 1));
+        MMU_Base_phys = rga_mmu_buf.buf + (rga_mmu_buf.front & (rga_mmu_buf.size - 1));
+        mutex_unlock(&rga_service.lock);
+
+        /* map src pages */
+        if ((req->mmu_info.mmu_flag >> 8) & 1) {
+            if (req->sg_src) {
+                ret = rga_MapION(req->sg_src, &MMU_Base[0], SrcMemSize,req->line_draw_info.flag);
+            }
+            else {
+                ret = rga_MapUserMemory(&pages[0], &MMU_Base[0], SrcStart, SrcMemSize);
+                if (ret < 0) {
+                    pr_err("rga map src memory failed\n");
+                    status = ret;
+                    break;
+                }
+            }
+        }
+        else {
+            MMU_p = MMU_Base;
+
+            for(i=0; i<SrcMemSize; i++)
+                MMU_p[i] = (uint32_t)((SrcStart + i) << PAGE_SHIFT);
+        }
+
+        if((req->mmu_info.mmu_flag >> 10) & 1) {
+            if (req->sg_dst) {
+                ret = rga_MapION(req->sg_dst, &MMU_Base[SrcMemSize], DstMemSize, req->line_draw_info.line_width);
+            }
+            else {
+                ret = rga_MapUserMemory(&pages[SrcMemSize], &MMU_Base[SrcMemSize], DstStart, DstMemSize);
+                if (ret < 0) {
+                    pr_err("rga map dst memory failed\n");
+                    status = ret;
+                    break;
+                }
+            }
+        }
+        else
+        {
+            /* kernel space */
+            MMU_p = MMU_Base + SrcMemSize;
+
+            if(req->dst.yrgb_addr == (unsigned long)rga_service.pre_scale_buf) {
+                for(i=0; i<DstMemSize; i++)
+                    MMU_p[i] = rga_service.pre_scale_buf[i];
+            }
+            else {
+                for(i=0; i<DstMemSize; i++)
+                    MMU_p[i] = (uint32_t)((DstStart + i) << PAGE_SHIFT);
+            }
+        }
+
+        MMU_Base[AllSize] = MMU_Base[AllSize];
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+
+        req->mmu_info.base_addr = ((unsigned long)(MMU_Base_phys)>>2);
+
+        uv_size = (req->src.uv_addr - (SrcStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+        v_size = (req->src.v_addr - (SrcStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK));
+        req->src.uv_addr = (req->src.uv_addr & (~PAGE_MASK)) | (uv_size << PAGE_SHIFT);
+        req->src.v_addr = (req->src.v_addr & (~PAGE_MASK)) | (v_size << PAGE_SHIFT);
+
+        uv_size = (req->dst.uv_addr - (DstStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+        v_size = (req->dst.v_addr - (DstStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+
+        req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK)) | ((SrcMemSize) << PAGE_SHIFT);
+        req->dst.uv_addr = (req->dst.uv_addr & (~PAGE_MASK)) | ((SrcMemSize + uv_size) << PAGE_SHIFT);
+        req->dst.v_addr = (req->dst.v_addr & (~PAGE_MASK)) | ((SrcMemSize + v_size) << PAGE_SHIFT);
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        #ifdef CONFIG_ARM
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize + 1));
+        #elif defined(CONFIG_ARM64)
+        __dma_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        #endif
+
+	    rga_mmu_buf_get(&rga_mmu_buf, AllSize + 16);
+        reg->MMU_len = AllSize + 16;
+
+        return 0;
+    }
+    while(0);
+
+    return status;
+}
+
+
+static int rga_mmu_info_update_palette_table_mode(struct rga_reg *reg, struct rga_req *req)
+{
+    int SrcMemSize, CMDMemSize;
+    unsigned long SrcStart, CMDStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p;
+    int ret, status;
+
+    MMU_Base = NULL;
+
+    do {
+        /* cal src buf mmu info */
+        SrcMemSize = rga_mem_size_cal(req->src.yrgb_addr, req->src.vir_w * req->src.vir_h, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        /* cal cmd buf mmu info */
+        CMDMemSize = rga_mem_size_cal((unsigned long)rga_service.cmd_buff, RGA_CMD_BUF_SIZE, &CMDStart);
+        if(CMDMemSize == 0) {
+            return -EINVAL;
+        }
+
+        AllSize = SrcMemSize + CMDMemSize;
+
+        pages = kzalloc(AllSize * sizeof(struct page *), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc pages mem failed\n");
+            status = RGA_MALLOC_ERROR;
+            break;
+        }
+
+        MMU_Base = kzalloc((AllSize + 1)* sizeof(uint32_t), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc MMU_Base point failed\n");
+            status = RGA_MALLOC_ERROR;
+            break;
+        }
+
+        for(i=0; i<CMDMemSize; i++) {
+            MMU_Base[i] = (uint32_t)virt_to_phys((uint32_t *)((CMDStart + i) << PAGE_SHIFT));
+        }
+
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
+        {
+            ret = rga_MapUserMemory(&pages[CMDMemSize], &MMU_Base[CMDMemSize], SrcStart, SrcMemSize);
+            if (ret < 0) {
+                pr_err("rga map src memory failed\n");
+                return -EINVAL;
+            }
+        }
+        else
+        {
+            MMU_p = MMU_Base + CMDMemSize;
+
+                for(i=0; i<SrcMemSize; i++)
+                {
+                    MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
+                }
+        }
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+        req->mmu_info.base_addr = (virt_to_phys(MMU_Base) >> 2);
+
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        #ifdef CONFIG_ARM
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize));
+        #elif defined(CONFIG_ARM64)
+        __dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+        #endif
+
+
+        if (pages != NULL) {
+            /* Free the page table */
+            kfree(pages);
+        }
+
+        return 0;
+    }
+    while(0);
+
+    if (pages != NULL)
+        kfree(pages);
+
+    if (MMU_Base != NULL)
+        kfree(MMU_Base);
+
+    return status;
+}
+
+static int rga_mmu_info_update_patten_buff_mode(struct rga_reg *reg, struct rga_req *req)
+{
+    int SrcMemSize, CMDMemSize;
+    unsigned long SrcStart, CMDStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p;
+    int ret, status;
+
+    MMU_Base = MMU_p = 0;
+
+    do
+    {
+
+        /* cal src buf mmu info */
+        SrcMemSize = rga_mem_size_cal(req->pat.yrgb_addr, req->pat.vir_w * req->pat.vir_h * 4, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        /* cal cmd buf mmu info */
+        CMDMemSize = rga_mem_size_cal((unsigned long)rga_service.cmd_buff, RGA_CMD_BUF_SIZE, &CMDStart);
+        if(CMDMemSize == 0) {
+            return -EINVAL;
+        }
+
+        AllSize = SrcMemSize + CMDMemSize;
+
+        pages = kzalloc(AllSize * sizeof(struct page *), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc pages mem failed\n");
+            status = RGA_MALLOC_ERROR;
+            break;
+        }
+
+        MMU_Base = kzalloc(AllSize * sizeof(uint32_t), GFP_KERNEL);
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc MMU_Base point failed\n");
+            status = RGA_MALLOC_ERROR;
+            break;
+        }
+
+        for(i=0; i<CMDMemSize; i++) {
+            MMU_Base[i] = virt_to_phys((uint32_t *)((CMDStart + i) << PAGE_SHIFT));
+        }
+
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
+        {
+            ret = rga_MapUserMemory(&pages[CMDMemSize], &MMU_Base[CMDMemSize], SrcStart, SrcMemSize);
+            if (ret < 0) {
+                pr_err("rga map src memory failed\n");
+                status = ret;
+                break;
+            }
+        }
+        else
+        {
+            MMU_p = MMU_Base + CMDMemSize;
+
+            for(i=0; i<SrcMemSize; i++)
+            {
+                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
+            }
+        }
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+        req->mmu_info.base_addr = (virt_to_phys(MMU_Base) >> 2);
+
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        #ifdef CONFIG_ARM
+        dmac_flush_range(MMU_Base, (MMU_Base + AllSize));
+        outer_flush_range(virt_to_phys(MMU_Base),virt_to_phys(MMU_Base + AllSize));
+        #elif defined(CONFIG_ARM64)
+        __dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+        #endif
+
+        if (pages != NULL) {
+            /* Free the page table */
+            kfree(pages);
+        }
+
+        return 0;
+
+    }
+    while(0);
+
+    if (pages != NULL)
+        kfree(pages);
+
+    if (MMU_Base != NULL)
+        kfree(MMU_Base);
+
+    return status;
+}
+
+int rga_set_mmu_info(struct rga_reg *reg, struct rga_req *req)
+{
+    int ret;
+
+    switch (req->render_mode) {
+        case bitblt_mode :
+            ret = rga_mmu_info_BitBlt_mode(reg, req);
+            break;
+        case color_palette_mode :
+            ret = rga_mmu_info_color_palette_mode(reg, req);
+            break;
+        case color_fill_mode :
+            ret = rga_mmu_info_color_fill_mode(reg, req);
+            break;
+        case line_point_drawing_mode :
+            ret = rga_mmu_info_line_point_drawing_mode(reg, req);
+            break;
+        case blur_sharp_filter_mode :
+            ret = rga_mmu_info_blur_sharp_filter_mode(reg, req);
+            break;
+        case pre_scaling_mode :
+            ret = rga_mmu_info_pre_scale_mode(reg, req);
+            break;
+        case update_palette_table_mode :
+            ret = rga_mmu_info_update_palette_table_mode(reg, req);
+            break;
+        case update_patten_buff_mode :
+            ret = rga_mmu_info_update_patten_buff_mode(reg, req);
+            break;
+        default :
+            ret = -1;
+            break;
+    }
+
+    return ret;
+}
+
diff -Nupr a/drivers/video/rockchip/rga/rga_mmu_info.h b/drivers/video/rockchip/rga/rga_mmu_info.h
--- a/drivers/video/rockchip/rga/rga_mmu_info.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/rga_mmu_info.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RGA_MMU_INFO_H__
+#define __RGA_MMU_INFO_H__
+
+#include "rga.h"
+
+#ifndef MIN
+#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
+#endif
+
+
+int rga_set_mmu_info(struct rga_reg *reg, struct rga_req *req);
+
+
+#endif
+
+
diff -Nupr a/drivers/video/rockchip/rga/rga_reg_info.c b/drivers/video/rockchip/rga/rga_reg_info.c
--- a/drivers/video/rockchip/rga/rga_reg_info.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/rga_reg_info.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1587 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+//#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <asm/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+//#include <mach/io.h>
+//#include <mach/irqs.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/syscalls.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <asm/cacheflush.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/wakelock.h>
+
+#include "rga_reg_info.h"
+#include "rga_rop.h"
+#include "rga.h"
+
+
+/*************************************************************
+Func:
+    RGA_pixel_width_init
+Description:
+    select pixel_width form data format
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+unsigned char
+RGA_pixel_width_init(unsigned int format)
+{
+    unsigned char pixel_width;
+
+    pixel_width = 0;
+
+    switch(format)
+    {
+        /* RGB FORMAT */
+        case RK_FORMAT_RGBA_8888 :   pixel_width = 4;   break;
+        case RK_FORMAT_RGBX_8888 :   pixel_width = 4;   break;
+        case RK_FORMAT_RGB_888   :   pixel_width = 3;   break;
+        case RK_FORMAT_BGRA_8888 :   pixel_width = 4;   break;
+        case RK_FORMAT_RGB_565   :   pixel_width = 2;   break;
+        case RK_FORMAT_RGBA_5551 :   pixel_width = 2;   break;
+        case RK_FORMAT_RGBA_4444 :   pixel_width = 2;   break;
+        case RK_FORMAT_BGR_888   :   pixel_width = 3;   break;
+
+        /* YUV FORMAT */
+        case RK_FORMAT_YCbCr_422_SP :   pixel_width = 1;  break;
+        case RK_FORMAT_YCbCr_422_P  :   pixel_width = 1;  break;
+        case RK_FORMAT_YCbCr_420_SP :   pixel_width = 1;  break;
+        case RK_FORMAT_YCbCr_420_P  :   pixel_width = 1;  break;
+        case RK_FORMAT_YCrCb_422_SP :   pixel_width = 1;  break;
+        case RK_FORMAT_YCrCb_422_P  :   pixel_width = 1;  break;
+        case RK_FORMAT_YCrCb_420_SP :   pixel_width = 1;  break;
+        case RK_FORMAT_YCrCb_420_P :    pixel_width = 1;  break;
+        //case default :                  pixel_width = 0;  break;
+    }
+
+    return pixel_width;
+}
+
+/*************************************************************
+Func:
+    dst_ctrl_cal
+Description:
+    calculate dst act window position / width / height
+    and set the tile struct
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+void
+dst_ctrl_cal(const struct rga_req *msg, TILE_INFO *tile)
+{
+    u32 width   = msg->dst.act_w;
+    u32 height  = msg->dst.act_h;
+    s32 xoff    = msg->dst.x_offset;
+    s32 yoff    = msg->dst.y_offset;
+
+    s32 x0, y0, x1, y1, x2, y2;
+    s32 x00,y00,x10,y10,x20,y20;
+    s32 xx, xy, yx, yy;
+    s32 pos[8];
+
+    s32 xmax, xmin, ymax, ymin;
+
+    s32 sina = msg->sina; /* 16.16 */
+    s32 cosa = msg->cosa; /* 16.16 */
+
+    xmax = xmin = ymax = ymin = 0;
+
+    if((msg->rotate_mode == 0)||(msg->rotate_mode == 2)||(msg->rotate_mode == 3))
+    {
+        pos[0] = xoff;
+        pos[1] = yoff;
+
+        pos[2] = xoff;
+        pos[3] = yoff + height - 1;
+
+        pos[4] = xoff + width - 1;
+        pos[5] = yoff + height - 1;
+
+        pos[6] = xoff + width - 1;
+        pos[7] = yoff;
+
+        xmax = MIN(MAX(MAX(MAX(pos[0], pos[2]), pos[4]), pos[6]), msg->clip.xmax);
+        xmin = MAX(MIN(MIN(MIN(pos[0], pos[2]), pos[4]), pos[6]), msg->clip.xmin);
+
+        ymax = MIN(MAX(MAX(MAX(pos[1], pos[3]), pos[5]), pos[7]), msg->clip.ymax);
+        ymin = MAX(MIN(MIN(MIN(pos[1], pos[3]), pos[5]), pos[7]), msg->clip.ymin);
+
+        //printk("xmax = %d, xmin = %d, ymin = %d, ymax = %d\n", xmax, xmin, ymin, ymax);
+    }
+    else if(msg->rotate_mode == 1)
+    {
+        if((sina == 0) || (cosa == 0))
+        {
+            if((sina == 0) && (cosa == -65536))
+            {
+                /* 180 */
+                pos[0] = xoff - width + 1;
+                pos[1] = yoff - height + 1;
+
+                pos[2] = xoff - width  + 1;
+                pos[3] = yoff;
+
+                pos[4] = xoff;
+                pos[5] = yoff;
+
+                pos[6] = xoff;
+                pos[7] = yoff - height + 1;
+            }
+            else if((cosa == 0)&&(sina == 65536))
+            {
+                /* 90 */
+                pos[0] = xoff - height + 1;
+                pos[1] = yoff;
+
+                pos[2] = xoff - height + 1;
+                pos[3] = yoff + width - 1;
+
+                pos[4] = xoff;
+                pos[5] = yoff + width - 1;
+
+                pos[6] = xoff;
+                pos[7] = yoff;
+            }
+            else if((cosa == 0)&&(sina == -65536))
+            {
+                /* 270 */
+                pos[0] = xoff;
+                pos[1] = yoff - width + 1;
+
+                pos[2] = xoff;
+                pos[3] = yoff;
+
+                pos[4] = xoff + height - 1;
+                pos[5] = yoff;
+
+                pos[6] = xoff + height - 1;
+                pos[7] = yoff - width + 1;
+            }
+            else
+            {
+                /* 0 */
+                pos[0] = xoff;
+                pos[1] = yoff;
+
+                pos[2] = xoff;
+                pos[3] = yoff + height - 1;
+
+                pos[4] = xoff + width - 1;
+                pos[5] = yoff + height - 1;
+
+                pos[6] = xoff + width - 1;
+                pos[7] = yoff;
+            }
+
+            xmax = MIN(MAX(MAX(MAX(pos[0], pos[2]), pos[4]), pos[6]), msg->clip.xmax);
+            xmin = MAX(MIN(MIN(MIN(pos[0], pos[2]), pos[4]), pos[6]), msg->clip.xmin);
+
+            ymax = MIN(MAX(MAX(MAX(pos[1], pos[3]), pos[5]), pos[7]), msg->clip.ymax);
+            ymin = MAX(MIN(MIN(MIN(pos[1], pos[3]), pos[5]), pos[7]), msg->clip.ymin);
+        }
+        else
+        {
+            xx = msg->cosa;
+            xy = msg->sina;
+            yx = xy;
+            yy = xx;
+
+            x0 = width + xoff;
+            y0 = yoff;
+
+            x1 = xoff;
+            y1 = height + yoff;
+
+            x2 = width + xoff;
+            y2 = height + yoff;
+
+            pos[0] = xoff;
+            pos[1] = yoff;
+
+            pos[2] = x00 = (((x0 - xoff)*xx - (y0 - yoff)*xy)>>16) + xoff;
+            pos[3] = y00 = (((x0 - xoff)*yx + (y0 - yoff)*yy)>>16) + yoff;
+
+            pos[4] = x10 = (((x1 - xoff)*xx - (y1 - yoff)*xy)>>16) + xoff;
+            pos[5] = y10 = (((x1 - xoff)*yx + (y1 - yoff)*yy)>>16) + yoff;
+
+            pos[6] = x20 = (((x2 - xoff)*xx - (y2 - yoff)*xy)>>16) + xoff;
+            pos[7] = y20 = (((x2 - xoff)*yx + (y2 - yoff)*yy)>>16) + yoff;
+
+            xmax = MAX(MAX(MAX(x00, xoff), x10), x20) + 2;
+            xmin = MIN(MIN(MIN(x00, xoff), x10), x20) - 1;
+
+            ymax = MAX(MAX(MAX(y00, yoff), y10), y20) + 2;
+            ymin = MIN(MIN(MIN(y00, yoff), y10), y20) - 1;
+
+            xmax = MIN(xmax, msg->clip.xmax);
+            xmin = MAX(xmin, msg->clip.xmin);
+
+            ymax = MIN(ymax, msg->clip.ymax);
+            ymin = MAX(ymin, msg->clip.ymin);
+
+            //printk("xmin = %d, xmax = %d, ymin = %d, ymax = %d\n", xmin, xmax, ymin, ymax);
+        }
+    }
+
+    if ((xmax < xmin) || (ymax < ymin)) {
+        xmin = xmax;
+        ymin = ymax;
+    }
+
+    if ((xmin >= msg->dst.vir_w)||(xmax < 0)||(ymin >= msg->dst.vir_h)||(ymax < 0)) {
+        xmin = xmax = ymin = ymax = 0;
+    }
+
+    //printk("xmin = %d, xmax = %d, ymin = %d, ymax = %d\n", xmin, xmax, ymin, ymax);
+
+    tile->dst_ctrl.w = (xmax - xmin);
+    tile->dst_ctrl.h = (ymax - ymin);
+    tile->dst_ctrl.x_off = xmin;
+    tile->dst_ctrl.y_off = ymin;
+
+    //printk("tile->dst_ctrl.w = %x, tile->dst_ctrl.h = %x\n", tile->dst_ctrl.w, tile->dst_ctrl.h);
+
+    tile->tile_x_num = (xmax - xmin + 1 + 7)>>3;
+    tile->tile_y_num = (ymax - ymin + 1 + 7)>>3;
+
+    tile->dst_x_tmp = xmin - msg->dst.x_offset;
+    tile->dst_y_tmp = ymin - msg->dst.y_offset;
+}
+
+/*************************************************************
+Func:
+    src_tile_info_cal
+Description:
+    calculate src remap window position / width / height
+    and set the tile struct
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+void
+src_tile_info_cal(const struct rga_req *msg, TILE_INFO *tile)
+{
+    s32 x0, x1, x2, x3, y0, y1, y2, y3;
+
+    int64_t xx, xy, yx, yy;
+
+    int64_t pos[8];
+    int64_t epos[8];
+
+    int64_t x_dx, x_dy, y_dx, y_dy;
+    int64_t x_temp_start, y_temp_start;
+    int64_t xmax, xmin, ymax, ymin;
+
+    int64_t t_xoff, t_yoff;
+
+    xx = tile->matrix[0]; /* 32.32 */
+    xy = tile->matrix[1]; /* 32.32 */
+    yx = tile->matrix[2]; /* 32.32 */
+    yy = tile->matrix[3]; /* 32.32 */
+
+    if(msg->rotate_mode == 1)
+    {
+        x0 = tile->dst_x_tmp;
+        y0 = tile->dst_y_tmp;
+
+        x1 = x0;
+        y1 = y0 + 8;
+
+        x2 = x0 + 8;
+        y2 = y0 + 8;
+
+        x3 = x0 + 8;
+        y3 = y0;
+
+        pos[0] = (x0*xx + y0*yx);
+        pos[1] = (x0*xy + y0*yy);
+
+        pos[2] = (x1*xx + y1*yx);
+        pos[3] = (x1*xy + y1*yy);
+
+        pos[4] = (x2*xx + y2*yx);
+        pos[5] = (x2*xy + y2*yy);
+
+        pos[6] = (x3*xx + y3*yx);
+        pos[7] = (x3*xy + y3*yy);
+
+        y1 = y0 + 7;
+        x2 = x0 + 7;
+        y2 = y0 + 7;
+        x3 = x0 + 7;
+
+        epos[0] = pos[0];
+        epos[1] = pos[1];
+
+        epos[2] = (x1*xx + y1*yx);
+        epos[3] = (x1*xy + y1*yy);
+
+        epos[4] = (x2*xx + y2*yx);
+        epos[5] = (x2*xy + y2*yy);
+
+        epos[6] = (x3*xx + y3*yx);
+        epos[7] = (x3*xy + y3*yy);
+
+        x_dx = pos[6] - pos[0];
+        x_dy = pos[7] - pos[1];
+
+        y_dx = pos[2] - pos[0];
+        y_dy = pos[3] - pos[1];
+
+        tile->x_dx = (s32)(x_dx >> 22 );
+        tile->x_dy = (s32)(x_dy >> 22 );
+        tile->y_dx = (s32)(y_dx >> 22 );
+        tile->y_dy = (s32)(y_dy >> 22 );
+
+        x_temp_start = x0*xx + y0*yx;
+        y_temp_start = x0*xy + y0*yy;
+
+        xmax = (MAX(MAX(MAX(epos[0], epos[2]), epos[4]), epos[6]));
+        xmin = (MIN(MIN(MIN(epos[0], epos[2]), epos[4]), epos[6]));
+
+        ymax = (MAX(MAX(MAX(epos[1], epos[3]), epos[5]), epos[7]));
+        ymin = (MIN(MIN(MIN(epos[1], epos[3]), epos[5]), epos[7]));
+
+        t_xoff = (x_temp_start - xmin)>>18;
+        t_yoff = (y_temp_start - ymin)>>18;
+
+        tile->tile_xoff = (s32)t_xoff;
+        tile->tile_yoff = (s32)t_yoff;
+
+        tile->tile_w = (u16)((xmax - xmin)>>21); //.11
+        tile->tile_h = (u16)((ymax - ymin)>>21); //.11
+
+        tile->tile_start_x_coor = (s16)(xmin>>29); //.3
+        tile->tile_start_y_coor = (s16)(ymin>>29); //.3
+    }
+    else if (msg->rotate_mode == 2)
+    {
+        tile->x_dx = (s32)((8*xx)>>22);
+        tile->x_dy = 0;
+        tile->y_dx = 0;
+        tile->y_dy = (s32)((8*yy)>>22);
+
+        tile->tile_w = ABS((s32)((7*xx)>>21));
+        tile->tile_h = ABS((s32)((7*yy)>>21));
+
+        tile->tile_xoff = ABS((s32)((7*xx)>>18));
+        tile->tile_yoff = 0;
+
+        tile->tile_start_x_coor = (((msg->src.act_w - 1)<<11) - (tile->tile_w))>>8;
+        tile->tile_start_y_coor = 0;
+    }
+    else if (msg->rotate_mode == 3)
+    {
+        tile->x_dx = (s32)((8*xx)>>22);
+        tile->x_dy = 0;
+        tile->y_dx = 0;
+        tile->y_dy = (s32)((8*yy)>>22);
+
+        tile->tile_w = ABS((s32)((7*xx)>>21));
+        tile->tile_h = ABS((s32)((7*yy)>>21));
+
+        tile->tile_xoff = 0;
+        tile->tile_yoff = ABS((s32)((7*yy)>>18));
+
+        tile->tile_start_x_coor = 0;
+        tile->tile_start_y_coor = (((msg->src.act_h - 1)<<11) - (tile->tile_h))>>8;
+    }
+
+    if ((msg->scale_mode == 2)||(msg->alpha_rop_flag >> 7))
+    {
+        tile->tile_start_x_coor -= (1<<3);
+        tile->tile_start_y_coor -= (1<<3);
+        tile->tile_w += (2 << 11);
+        tile->tile_h += (2 << 11);
+        tile->tile_xoff += (1<<14);
+        tile->tile_yoff += (1<<14);
+    }
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_mode_ctrl
+Description:
+    fill mode ctrl reg info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+void
+RGA_set_mode_ctrl(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_MODE_CTL;
+    u32 reg = 0;
+
+    u8 src_rgb_pack = 0;
+    u8 src_format = 0;
+    u8 src_rb_swp = 0;
+    u8 src_a_swp = 0;
+    u8 src_cbcr_swp = 0;
+
+    u8 dst_rgb_pack = 0;
+    u8 dst_format = 0;
+    u8 dst_rb_swp = 0;
+    u8 dst_a_swp = 0;
+
+    bRGA_MODE_CTL = (u32 *)(base + RGA_MODE_CTRL_OFFSET);
+
+    reg = ((reg & (~m_RGA_MODE_CTRL_2D_RENDER_MODE)) | (s_RGA_MODE_CTRL_2D_RENDER_MODE(msg->render_mode)));
+
+    /* src info set */
+
+    if (msg->render_mode == color_palette_mode || msg->render_mode == update_palette_table_mode)
+    {
+        src_format = 0x10 | (msg->palette_mode & 3);
+    }
+    else
+    {
+        switch (msg->src.format)
+        {
+            case RK_FORMAT_RGBA_8888    : src_format = 0x0; break;
+            case RK_FORMAT_RGBA_4444    : src_format = 0x3; break;
+            case RK_FORMAT_RGBA_5551    : src_format = 0x2; break;
+            case RK_FORMAT_BGRA_8888    : src_format = 0x0; src_rb_swp = 0x1; break;
+            case RK_FORMAT_RGBX_8888    : src_format = 0x0; break;
+            case RK_FORMAT_RGB_565      : src_format = 0x1; break;
+            case RK_FORMAT_RGB_888      : src_format = 0x0; src_rgb_pack = 1; break;
+            case RK_FORMAT_BGR_888      : src_format = 0x0; src_rgb_pack = 1; src_rb_swp = 1; break;
+
+            case RK_FORMAT_YCbCr_422_SP : src_format = 0x4; break;
+            case RK_FORMAT_YCbCr_422_P  : src_format = 0x5; break;
+            case RK_FORMAT_YCbCr_420_SP : src_format = 0x6; break;
+            case RK_FORMAT_YCbCr_420_P  : src_format = 0x7; break;
+
+            case RK_FORMAT_YCrCb_422_SP : src_format = 0x4; src_cbcr_swp = 1; break;
+            case RK_FORMAT_YCrCb_422_P  : src_format = 0x5; src_cbcr_swp = 1; break;
+            case RK_FORMAT_YCrCb_420_SP : src_format = 0x6; src_cbcr_swp = 1; break;
+            case RK_FORMAT_YCrCb_420_P  : src_format = 0x7; src_cbcr_swp = 1; break;
+        }
+    }
+
+    src_a_swp = msg->src.alpha_swap & 1;
+
+    reg = ((reg & (~m_RGA_MODE_CTRL_SRC_RGB_PACK))      | (s_RGA_MODE_CTRL_SRC_RGB_PACK(src_rgb_pack)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_SRC_FORMAT))        | (s_RGA_MODE_CTRL_SRC_FORMAT(src_format)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_SRC_RB_SWAP))       | (s_RGA_MODE_CTRL_SRC_RB_SWAP(src_rb_swp)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_SRC_ALPHA_SWAP))    | (s_RGA_MODE_CTRL_SRC_ALPHA_SWAP(src_a_swp)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_SRC_UV_SWAP_MODE )) | (s_RGA_MODE_CTRL_SRC_UV_SWAP_MODE (src_cbcr_swp)));
+
+
+    /* YUV2RGB MODE */
+    reg = ((reg & (~m_RGA_MODE_CTRL_YUV2RGB_CON_MODE)) | (s_RGA_MODE_CTRL_YUV2RGB_CON_MODE(msg->yuv2rgb_mode)));
+
+    /* ROTATE MODE */
+    reg = ((reg & (~m_RGA_MODE_CTRL_ROTATE_MODE)) | (s_RGA_MODE_CTRL_ROTATE_MODE(msg->rotate_mode)));
+
+    /* SCALE MODE */
+    reg = ((reg & (~m_RGA_MODE_CTRL_SCALE_MODE)) | (s_RGA_MODE_CTRL_SCALE_MODE(msg->scale_mode)));
+
+    /* COLOR FILL MODE */
+    reg = ((reg & (~m_RGA_MODE_CTRL_PAT_SEL)) | (s_RGA_MODE_CTRL_PAT_SEL(msg->color_fill_mode)));
+
+
+    if ((msg->render_mode == update_palette_table_mode)||(msg->render_mode == update_patten_buff_mode))
+    {
+        dst_format = msg->pat.format;
+    }
+    else
+    {
+        dst_format = (u8)msg->dst.format;
+    }
+
+    /* dst info set */
+    switch (dst_format)
+    {
+        case RK_FORMAT_BGRA_8888 : dst_format = 0x0; dst_rb_swp = 0x1; break;
+        case RK_FORMAT_RGBA_4444 : dst_format = 0x3; break;
+        case RK_FORMAT_RGBA_5551 : dst_format = 0x2; break;
+        case RK_FORMAT_RGBA_8888 : dst_format = 0x0; break;
+        case RK_FORMAT_RGB_565   : dst_format = 0x1; break;
+        case RK_FORMAT_RGB_888   : dst_format = 0x0; dst_rgb_pack = 0x1; break;
+        case RK_FORMAT_BGR_888   : dst_format = 0x0; dst_rgb_pack = 0x1; dst_rb_swp = 1; break;
+        case RK_FORMAT_RGBX_8888 : dst_format = 0x0; break;
+    }
+
+    dst_a_swp = msg->dst.alpha_swap & 1;
+
+    reg = ((reg & (~m_RGA_MODE_CTRL_DST_FORMAT))       | (s_RGA_MODE_CTRL_DST_FORMAT(dst_format)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_DST_RGB_PACK))     | (s_RGA_MODE_CTRL_DST_RGB_PACK(dst_rgb_pack)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_DST_RB_SWAP))      | (s_RGA_MODE_CTRL_DST_RB_SWAP(dst_rb_swp)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_DST_ALPHA_SWAP))   | (s_RGA_MODE_CTRL_DST_ALPHA_SWAP(dst_a_swp)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_LUT_ENDIAN_MODE))  | (s_RGA_MODE_CTRL_LUT_ENDIAN_MODE(msg->endian_mode & 1)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_SRC_TRANS_MODE))   | (s_RGA_MODE_CTRL_SRC_TRANS_MODE(msg->src_trans_mode)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_ZERO_MODE_ENABLE)) | (s_RGA_MODE_CTRL_ZERO_MODE_ENABLE(msg->alpha_rop_mode >> 4)));
+    reg = ((reg & (~m_RGA_MODE_CTRL_DST_ALPHA_ENABLE)) | (s_RGA_MODE_CTRL_DST_ALPHA_ENABLE(msg->alpha_rop_mode >> 5)));
+
+    *bRGA_MODE_CTL = reg;
+
+}
+
+
+
+/*************************************************************
+Func:
+    RGA_set_src
+Description:
+    fill src relate reg info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+void
+RGA_set_src(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_SRC_VIR_INFO;
+    u32 *bRGA_SRC_ACT_INFO;
+    u32 *bRGA_SRC_Y_MST;
+    u32 *bRGA_SRC_CB_MST;
+    u32 *bRGA_SRC_CR_MST;
+
+    s16 x_off, y_off, stride;
+    s16 uv_x_off, uv_y_off, uv_stride;
+    u32 pixel_width;
+
+    uv_x_off = uv_y_off = uv_stride = 0;
+
+    bRGA_SRC_Y_MST = (u32 *)(base + RGA_SRC_Y_MST_OFFSET);
+    bRGA_SRC_CB_MST = (u32 *)(base + RGA_SRC_CB_MST_OFFSET);
+    bRGA_SRC_CR_MST = (u32 *)(base + RGA_SRC_CR_MST_OFFSET);
+    bRGA_SRC_VIR_INFO = (u32 *)(base + RGA_SRC_VIR_INFO_OFFSET);
+    bRGA_SRC_ACT_INFO = (u32 *)(base + RGA_SRC_ACT_INFO_OFFSET);
+
+    x_off  = msg->src.x_offset;
+    y_off  = msg->src.y_offset;
+
+    pixel_width = RGA_pixel_width_init(msg->src.format);
+
+    stride = ((msg->src.vir_w * pixel_width) + 3) & (~3);
+
+    switch(msg->src.format)
+    {
+        case RK_FORMAT_YCbCr_422_SP :
+            uv_stride = stride;
+            uv_x_off = x_off;
+            uv_y_off = y_off;
+            break;
+        case RK_FORMAT_YCbCr_422_P  :
+            uv_stride = stride >> 1;
+            uv_x_off = x_off >> 1;
+            uv_y_off = y_off;
+            break;
+        case RK_FORMAT_YCbCr_420_SP :
+            uv_stride = stride;
+            uv_x_off = x_off;
+            uv_y_off = y_off >> 1;
+            break;
+        case RK_FORMAT_YCbCr_420_P :
+            uv_stride = stride >> 1;
+            uv_x_off = x_off >> 1;
+            uv_y_off = y_off >> 1;
+            break;
+        case RK_FORMAT_YCrCb_422_SP :
+            uv_stride = stride;
+            uv_x_off = x_off;
+            uv_y_off = y_off;
+            break;
+        case RK_FORMAT_YCrCb_422_P  :
+            uv_stride = stride >> 1;
+            uv_x_off = x_off >> 1;
+            uv_y_off = y_off;
+            break;
+        case RK_FORMAT_YCrCb_420_SP :
+            uv_stride = stride;
+            uv_x_off = x_off;
+            uv_y_off = y_off >> 1;
+            break;
+        case RK_FORMAT_YCrCb_420_P :
+            uv_stride = stride >> 1;
+            uv_x_off = x_off >> 1;
+            uv_y_off = y_off >> 1;
+            break;
+    }
+
+
+    /* src addr set */
+    *bRGA_SRC_Y_MST = msg->src.yrgb_addr + (y_off * stride) + (x_off * pixel_width);
+    *bRGA_SRC_CB_MST = msg->src.uv_addr + uv_y_off * uv_stride + uv_x_off;
+    *bRGA_SRC_CR_MST = msg->src.v_addr + uv_y_off * uv_stride + uv_x_off;
+
+    if((msg->alpha_rop_flag >> 1) & 1)
+        *bRGA_SRC_CB_MST = (u32)msg->rop_mask_addr;
+
+    if (msg->render_mode == color_palette_mode)
+    {
+        u8 shift;
+        u16 sw, byte_num;
+        shift = 3 - (msg->palette_mode & 3);
+        sw = msg->src.vir_w;
+
+        byte_num = sw >> shift;
+        stride = (byte_num + 3) & (~3);
+    }
+
+    /* src act window / vir window set */
+    *bRGA_SRC_VIR_INFO = ((stride >> 2) | (msg->src.vir_h)<<16);
+    *bRGA_SRC_ACT_INFO = ((msg->src.act_w-1) | (msg->src.act_h-1)<<16);
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_dst
+Description:
+    fill dst relate reg info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+s32 RGA_set_dst(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_DST_MST;
+    u32 *bRGA_DST_UV_MST;
+    u32 *bRGA_DST_VIR_INFO;
+    u32 *bRGA_DST_CTR_INFO;
+    u32 *bRGA_PRESCL_CB_MST;
+    u32 *bRGA_PRESCL_CR_MST;
+    u32 *bRGA_YUV_OUT_CFG;
+
+    u32 reg = 0;
+
+    u8 pw;
+    s16 x_off = msg->dst.x_offset;
+    s16 y_off = msg->dst.y_offset;
+    u16 stride, rop_mask_stride;
+
+    bRGA_DST_MST = (u32 *)(base + RGA_DST_MST_OFFSET);
+    bRGA_DST_UV_MST = (u32 *)(base + RGA_DST_UV_MST_OFFSET);
+    bRGA_DST_VIR_INFO = (u32 *)(base + RGA_DST_VIR_INFO_OFFSET);
+    bRGA_DST_CTR_INFO = (u32 *)(base + RGA_DST_CTR_INFO_OFFSET);
+    bRGA_PRESCL_CB_MST = (u32 *)(base + RGA_PRESCL_CB_MST_OFFSET);
+    bRGA_PRESCL_CR_MST = (u32 *)(base + RGA_PRESCL_CR_MST_OFFSET);
+    bRGA_YUV_OUT_CFG = (u32 *)(base + RGA_YUV_OUT_CFG_OFFSET);
+
+    pw = RGA_pixel_width_init(msg->dst.format);
+
+    stride = (msg->dst.vir_w * pw + 3) & (~3);
+
+    *bRGA_DST_MST = (u32)msg->dst.yrgb_addr + (y_off * stride) + (x_off * pw);
+
+    *bRGA_DST_UV_MST = 0;
+    *bRGA_YUV_OUT_CFG = 0;
+
+	if (msg->rotate_mode == 1) {
+		if (msg->sina == 65536 && msg->cosa == 0) {
+			/* rotate 90 */
+			x_off = msg->dst.x_offset - msg->dst.act_h + 1;
+		} else if (msg->sina == 0 && msg->cosa == -65536) {
+			/* rotate 180 */
+			x_off = msg->dst.x_offset - msg->dst.act_w + 1;
+			y_off = msg->dst.y_offset - msg->dst.act_h + 1;
+		} else if (msg->sina == -65536 && msg->cosa == 0) {
+			/* totate 270 */
+			y_off = msg->dst.y_offset - msg->dst.act_w + 1;
+		}
+	}
+
+    switch(msg->dst.format)
+    {
+        case RK_FORMAT_YCbCr_422_SP :
+            *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off) * stride) + ((x_off) * pw);
+			*bRGA_DST_UV_MST = (u32)msg->dst.uv_addr + (y_off * stride) + x_off;
+			*bRGA_YUV_OUT_CFG |= (((msg->yuv2rgb_mode >> 4) & 3) << 4) | (0 << 3) | (0 << 1) | 1;
+            break;
+        case RK_FORMAT_YCbCr_422_P  :
+            *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off) * stride) + ((x_off>>1) * pw);
+            *bRGA_PRESCL_CR_MST = (u32)msg->dst.v_addr  + ((y_off) * stride) + ((x_off>>1) * pw);
+            break;
+        case RK_FORMAT_YCbCr_420_SP :
+            *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off>>1) * stride) + ((x_off) * pw);
+			*bRGA_DST_UV_MST = (u32)msg->dst.uv_addr + ((y_off>>1) * stride) + x_off;
+			*bRGA_YUV_OUT_CFG |= (((msg->yuv2rgb_mode >> 4) & 3) << 4) | (0 << 3) | (1 << 1) | 1;
+            break;
+        case RK_FORMAT_YCbCr_420_P :
+            *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off>>1) * stride) + ((x_off>>1) * pw);
+            *bRGA_PRESCL_CR_MST = (u32)msg->dst.v_addr  + ((y_off>>1) * stride) + ((x_off>>1) * pw);
+            break;
+        case RK_FORMAT_YCrCb_422_SP :
+            *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off) * stride) + ((x_off) * pw);
+			*bRGA_DST_UV_MST = (u32)msg->dst.uv_addr + (y_off * stride) + x_off;
+			*bRGA_YUV_OUT_CFG |= (((msg->yuv2rgb_mode >> 4) & 3) << 4) | (1 << 3) | (0 << 1) | 1;
+            break;
+        case RK_FORMAT_YCrCb_422_P  :
+            *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off) * stride) + ((x_off>>1) * pw);
+            *bRGA_PRESCL_CR_MST = (u32)msg->dst.v_addr  + ((y_off) * stride) + ((x_off>>1) * pw);
+            break;
+        case RK_FORMAT_YCrCb_420_SP :
+            *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off>>1) * stride) + ((x_off) * pw);
+			*bRGA_DST_UV_MST = (u32)msg->dst.uv_addr + ((y_off>>1) * stride) + x_off;
+			*bRGA_YUV_OUT_CFG |= (((msg->yuv2rgb_mode >> 4) & 3) << 4) | (1 << 3) | (1 << 1) | 1;
+            break;
+        case RK_FORMAT_YCrCb_420_P :
+            *bRGA_PRESCL_CB_MST = (u32)msg->dst.uv_addr + ((y_off>>1) * stride) + ((x_off>>1) * pw);
+            *bRGA_PRESCL_CR_MST = (u32)msg->dst.v_addr  + ((y_off>>1) * stride) + ((x_off>>1) * pw);
+            break;
+    }
+
+    rop_mask_stride = (((msg->src.vir_w + 7)>>3) + 3) & (~3);//not dst_vir.w,hxx,2011.7.21
+
+    reg = (stride >> 2) & 0xffff;
+    reg = reg | ((rop_mask_stride>>2) << 16);
+
+    #if defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3188)
+    //reg = reg | ((msg->alpha_rop_mode & 3) << 28);
+    reg = reg | (1 << 28);
+    #endif
+
+    if (msg->render_mode == line_point_drawing_mode)
+    {
+        reg &= 0xffff;
+        reg = reg | (msg->dst.vir_h << 16);
+    }
+
+    *bRGA_DST_VIR_INFO = reg;
+    *bRGA_DST_CTR_INFO = (msg->dst.act_w - 1) | ((msg->dst.act_h - 1) << 16);
+
+    if (msg->render_mode == pre_scaling_mode) {
+        *bRGA_YUV_OUT_CFG &= 0xfffffffe;
+    }
+
+    return 0;
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_alpha_rop
+Description:
+    fill alpha rop some relate reg bit
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+void
+RGA_set_alpha_rop(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_ALPHA_CON;
+    u32 *bRGA_ROP_CON0;
+    u32 *bRGA_ROP_CON1;
+    u32 reg = 0;
+    u32 rop_con0, rop_con1;
+
+    u8 rop_mode = (msg->alpha_rop_mode) & 3;
+    u8 alpha_mode = msg->alpha_rop_mode & 3;
+
+    rop_con0 = rop_con1 = 0;
+
+    bRGA_ALPHA_CON = (u32 *)(base + RGA_ALPHA_CON_OFFSET);
+
+    reg = ((reg & (~m_RGA_ALPHA_CON_ENABLE) )| (s_RGA_ALPHA_CON_ENABLE(msg->alpha_rop_flag & 1)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_A_OR_R_SEL)) | (s_RGA_ALPHA_CON_A_OR_R_SEL((msg->alpha_rop_flag >> 1) & 1)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_ALPHA_MODE)) | (s_RGA_ALPHA_CON_ALPHA_MODE(alpha_mode)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_PD_MODE)) | (s_RGA_ALPHA_CON_PD_MODE(msg->PD_mode)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_SET_CONSTANT_VALUE)) | (s_RGA_ALPHA_CON_SET_CONSTANT_VALUE(msg->alpha_global_value)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_PD_M_SEL)) | (s_RGA_ALPHA_CON_PD_M_SEL(msg->alpha_rop_flag >> 3)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_FADING_ENABLE)) | (s_RGA_ALPHA_CON_FADING_ENABLE(msg->alpha_rop_flag >> 2)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_ROP_MODE_SEL)) | (s_RGA_ALPHA_CON_ROP_MODE_SEL(rop_mode)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_CAL_MODE_SEL)) | (s_RGA_ALPHA_CON_CAL_MODE_SEL(msg->alpha_rop_flag >> 4)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_DITHER_ENABLE)) | (s_RGA_ALPHA_CON_DITHER_ENABLE(msg->alpha_rop_flag >> 5)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_GRADIENT_CAL_MODE)) | (s_RGA_ALPHA_CON_GRADIENT_CAL_MODE(msg->alpha_rop_flag >> 6)));
+    reg = ((reg & (~m_RGA_ALPHA_CON_AA_SEL)) | (s_RGA_ALPHA_CON_AA_SEL(msg->alpha_rop_flag >> 7)));
+
+    *bRGA_ALPHA_CON = reg;
+
+    if(rop_mode == 0) {
+        rop_con0 =  ROP3_code[(msg->rop_code & 0xff)];
+    }
+    else if(rop_mode == 1) {
+        rop_con0 =  ROP3_code[(msg->rop_code & 0xff)];
+    }
+    else if(rop_mode == 2) {
+        rop_con0 =  ROP3_code[(msg->rop_code & 0xff)];
+        rop_con1 =  ROP3_code[(msg->rop_code & 0xff00)>>8];
+    }
+
+    bRGA_ROP_CON0 = (u32 *)(base + RGA_ROP_CON0_OFFSET);
+    bRGA_ROP_CON1 = (u32 *)(base + RGA_ROP_CON1_OFFSET);
+
+    *bRGA_ROP_CON0 = (u32)rop_con0;
+    *bRGA_ROP_CON1 = (u32)rop_con1;
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_color
+Description:
+    fill color some relate reg bit
+    bg_color/fg_color
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+void
+RGA_set_color(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_SRC_TR_COLOR0;
+    u32 *bRGA_SRC_TR_COLOR1;
+    u32 *bRGA_SRC_BG_COLOR;
+    u32 *bRGA_SRC_FG_COLOR;
+
+
+    bRGA_SRC_BG_COLOR  = (u32 *)(base + RGA_SRC_BG_COLOR_OFFSET);
+    bRGA_SRC_FG_COLOR  = (u32 *)(base + RGA_SRC_FG_COLOR_OFFSET);
+
+    *bRGA_SRC_BG_COLOR = msg->bg_color;    /* 1bpp 0 */
+    *bRGA_SRC_FG_COLOR = msg->fg_color;    /* 1bpp 1 */
+
+    bRGA_SRC_TR_COLOR0 = (u32 *)(base + RGA_SRC_TR_COLOR0_OFFSET);
+    bRGA_SRC_TR_COLOR1 = (u32 *)(base + RGA_SRC_TR_COLOR1_OFFSET);
+
+    *bRGA_SRC_TR_COLOR0 = msg->color_key_min;
+    *bRGA_SRC_TR_COLOR1 = msg->color_key_max;
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_fading
+Description:
+    fill fading some relate reg bit
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+s32
+RGA_set_fading(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_FADING_CON;
+    u8 r, g, b;
+    u32 reg = 0;
+
+    bRGA_FADING_CON = (u32 *)(base + RGA_FADING_CON_OFFSET);
+
+    b = msg->fading.b;
+    g = msg->fading.g;
+    r = msg->fading.r;
+
+    reg = (r<<8) | (g<<16) | (b<<24) | reg;
+
+    *bRGA_FADING_CON = reg;
+
+    return 0;
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_pat
+Description:
+    fill patten some relate reg bit
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+s32
+RGA_set_pat(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_PAT_CON;
+    u32 *bRGA_PAT_START_POINT;
+    u32 reg = 0;
+
+    bRGA_PAT_START_POINT = (u32 *)(base + RGA_PAT_START_POINT_OFFSET);
+
+    bRGA_PAT_CON = (u32 *)(base + RGA_PAT_CON_OFFSET);
+
+    *bRGA_PAT_START_POINT = (msg->pat.act_w * msg->pat.y_offset) + msg->pat.x_offset;
+
+    reg = (msg->pat.act_w - 1) | ((msg->pat.act_h - 1) << 8) | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
+    *bRGA_PAT_CON = reg;
+
+    return 0;
+}
+
+
+
+
+/*************************************************************
+Func:
+    RGA_set_bitblt_reg_info
+Description:
+    fill bitblt mode relate ren info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+void
+RGA_set_bitblt_reg_info(u8 *base, const struct rga_req * msg, TILE_INFO *tile)
+{
+    u32 *bRGA_SRC_Y_MST;
+    u32 *bRGA_SRC_CB_MST;
+    u32 *bRGA_SRC_CR_MST;
+    u32 *bRGA_SRC_X_PARA;
+    u32 *bRGA_SRC_Y_PARA;
+    u32 *bRGA_SRC_TILE_XINFO;
+    u32 *bRGA_SRC_TILE_YINFO;
+    u32 *bRGA_SRC_TILE_H_INCR;
+    u32 *bRGA_SRC_TILE_V_INCR;
+    u32 *bRGA_SRC_TILE_OFFSETX;
+    u32 *bRGA_SRC_TILE_OFFSETY;
+
+    u32 *bRGA_DST_MST;
+    u32 *bRGA_DST_CTR_INFO;
+
+    s32 m0, m1, m2, m3;
+    s32 pos[8];
+    //s32 x_dx, x_dy, y_dx, y_dy;
+    s32 xmin, xmax, ymin, ymax;
+    s32 xp, yp;
+    u32 y_addr, u_addr, v_addr;
+    u32 pixel_width, stride;
+
+    u_addr = v_addr = 0;
+
+    /* src info */
+
+    bRGA_SRC_Y_MST = (u32 *)(base + RGA_SRC_Y_MST_OFFSET);
+    bRGA_SRC_CB_MST = (u32 *)(base + RGA_SRC_CB_MST_OFFSET);
+    bRGA_SRC_CR_MST = (u32 *)(base + RGA_SRC_CR_MST_OFFSET);
+
+    bRGA_SRC_X_PARA = (u32 *)(base + RGA_SRC_X_PARA_OFFSET);
+    bRGA_SRC_Y_PARA = (u32 *)(base + RGA_SRC_Y_PARA_OFFSET);
+
+    bRGA_SRC_TILE_XINFO = (u32 *)(base + RGA_SRC_TILE_XINFO_OFFSET);
+    bRGA_SRC_TILE_YINFO = (u32 *)(base + RGA_SRC_TILE_YINFO_OFFSET);
+    bRGA_SRC_TILE_H_INCR = (u32 *)(base + RGA_SRC_TILE_H_INCR_OFFSET);
+    bRGA_SRC_TILE_V_INCR = (u32 *)(base + RGA_SRC_TILE_V_INCR_OFFSET);
+    bRGA_SRC_TILE_OFFSETX = (u32 *)(base + RGA_SRC_TILE_OFFSETX_OFFSET);
+    bRGA_SRC_TILE_OFFSETY = (u32 *)(base + RGA_SRC_TILE_OFFSETY_OFFSET);
+
+    bRGA_DST_MST = (u32 *)(base + RGA_DST_MST_OFFSET);
+    bRGA_DST_CTR_INFO = (u32 *)(base + RGA_DST_CTR_INFO_OFFSET);
+
+    /* Matrix reg fill */
+    m0 = (s32)(tile->matrix[0] >> 18);
+    m1 = (s32)(tile->matrix[1] >> 18);
+    m2 = (s32)(tile->matrix[2] >> 18);
+    m3 = (s32)(tile->matrix[3] >> 18);
+
+    *bRGA_SRC_X_PARA = (m0 & 0xffff) | (m2 << 16);
+    *bRGA_SRC_Y_PARA = (m1 & 0xffff) | (m3 << 16);
+
+    /* src tile information setting */
+    if(msg->rotate_mode != 0)//add by hxx,2011.7.12,for rtl0707,when line scanning ,do not calc src tile info
+    {
+        *bRGA_SRC_TILE_XINFO = (tile->tile_start_x_coor & 0xffff) | (tile->tile_w << 16);
+        *bRGA_SRC_TILE_YINFO = (tile->tile_start_y_coor & 0xffff) | (tile->tile_h << 16);
+
+        *bRGA_SRC_TILE_H_INCR = ((tile->x_dx) & 0xffff) | ((tile->x_dy) << 16);
+        *bRGA_SRC_TILE_V_INCR = ((tile->y_dx) & 0xffff) | ((tile->y_dy) << 16);
+
+        *bRGA_SRC_TILE_OFFSETX = tile->tile_xoff;
+        *bRGA_SRC_TILE_OFFSETY = tile->tile_yoff;
+    }
+
+    pixel_width = RGA_pixel_width_init(msg->src.format);
+
+    stride = ((msg->src.vir_w * pixel_width) + 3) & (~3);
+
+    if ((msg->rotate_mode == 1)||(msg->rotate_mode == 2)||(msg->rotate_mode == 3))
+    {
+        pos[0] = tile->tile_start_x_coor<<8;
+        pos[1] = tile->tile_start_y_coor<<8;
+
+        pos[2] = pos[0];
+        pos[3] = pos[1] + tile->tile_h;
+
+        pos[4] = pos[0] + tile->tile_w;
+        pos[5] = pos[1] + tile->tile_h;
+
+        pos[6] = pos[0] + tile->tile_w;
+        pos[7] = pos[1];
+
+        pos[0] >>= 11;
+        pos[1] >>= 11;
+
+        pos[2] >>= 11;
+        pos[3] >>= 11;
+
+        pos[4] >>= 11;
+        pos[5] >>= 11;
+
+        pos[6] >>= 11;
+        pos[7] >>= 11;
+
+        xmax = (MAX(MAX(MAX(pos[0], pos[2]), pos[4]), pos[6]) + 1);
+        xmin = (MIN(MIN(MIN(pos[0], pos[2]), pos[4]), pos[6]));
+
+        ymax = (MAX(MAX(MAX(pos[1], pos[3]), pos[5]), pos[7]) + 1);
+        ymin = (MIN(MIN(MIN(pos[1], pos[3]), pos[5]), pos[7]));
+
+        xp = xmin + msg->src.x_offset;
+        yp = ymin + msg->src.y_offset;
+
+        if (!((xmax < 0)||(xmin > msg->src.act_w - 1)||(ymax < 0)||(ymin > msg->src.act_h - 1)))
+        {
+            xp = CLIP(xp, msg->src.x_offset, msg->src.x_offset + msg->src.act_w - 1);
+            yp = CLIP(yp, msg->src.y_offset, msg->src.y_offset + msg->src.act_h - 1);
+        }
+
+        switch(msg->src.format)
+        {
+            case RK_FORMAT_YCbCr_420_P :
+                y_addr = msg->src.yrgb_addr + yp*stride + xp;
+                u_addr = msg->src.uv_addr + (yp>>1)*(stride>>1) + (xp>>1);
+                v_addr = msg->src.v_addr  + (yp>>1)*(stride>>1) + (xp>>1);
+                break;
+            case RK_FORMAT_YCbCr_420_SP :
+                y_addr = msg->src.yrgb_addr + yp*stride + xp;
+                u_addr = msg->src.uv_addr + (yp>>1)*stride + ((xp>>1)<<1);
+                break;
+            case RK_FORMAT_YCbCr_422_P :
+                y_addr = msg->src.yrgb_addr + yp*stride + xp;
+                u_addr = msg->src.uv_addr + (yp)*(stride>>1) + (xp>>1);
+                v_addr = msg->src.v_addr  + (yp)*(stride>>1) + (xp>>1);
+                break;
+            case RK_FORMAT_YCbCr_422_SP:
+                y_addr = msg->src.yrgb_addr + yp*stride + xp;
+                u_addr = msg->src.uv_addr  + yp*stride + ((xp>>1)<<1);
+                break;
+            case RK_FORMAT_YCrCb_420_P :
+                y_addr = msg->src.yrgb_addr + yp*stride + xp;
+                u_addr = msg->src.uv_addr + (yp>>1)*(stride>>1) + (xp>>1);
+                v_addr = msg->src.v_addr  + (yp>>1)*(stride>>1) + (xp>>1);
+                break;
+            case RK_FORMAT_YCrCb_420_SP :
+                y_addr = msg->src.yrgb_addr + yp*stride + xp;
+                u_addr = msg->src.uv_addr + (yp>>1)*stride + ((xp>>1)<<1);
+                break;
+            case RK_FORMAT_YCrCb_422_P :
+                y_addr = msg->src.yrgb_addr + yp*stride + xp;
+                u_addr = msg->src.uv_addr + (yp)*(stride>>1) + (xp>>1);
+                v_addr = msg->src.v_addr  + (yp)*(stride>>1) + (xp>>1);
+                break;
+            case RK_FORMAT_YCrCb_422_SP:
+                y_addr = msg->src.yrgb_addr + yp*stride + xp;
+                u_addr = msg->src.uv_addr  + yp*stride + ((xp>>1)<<1);
+                break;
+            default :
+                y_addr = msg->src.yrgb_addr + yp*stride + xp*pixel_width;
+                break;
+        }
+
+        *bRGA_SRC_Y_MST = y_addr;
+        *bRGA_SRC_CB_MST = u_addr;
+        *bRGA_SRC_CR_MST = v_addr;
+    }
+
+    /*dst info*/
+    pixel_width = RGA_pixel_width_init(msg->dst.format);
+    stride = (msg->dst.vir_w * pixel_width + 3) & (~3);
+    *bRGA_DST_MST = (u32)msg->dst.yrgb_addr + (tile->dst_ctrl.y_off * stride) + (tile->dst_ctrl.x_off * pixel_width);
+    *bRGA_DST_CTR_INFO = (tile->dst_ctrl.w) | ((tile->dst_ctrl.h) << 16);
+
+    *bRGA_DST_CTR_INFO |= ((1<<29) | (1<<28));
+}
+
+
+
+
+/*************************************************************
+Func:
+    RGA_set_color_palette_reg_info
+Description:
+    fill color palette process some relate reg bit
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+void
+RGA_set_color_palette_reg_info(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_SRC_Y_MST;
+    u32 p;
+    s16 x_off, y_off;
+    u16 src_stride;
+    u8  shift;
+    u16 sw, byte_num;
+
+    x_off = msg->src.x_offset;
+    y_off = msg->src.y_offset;
+
+    sw = msg->src.vir_w;
+    shift = 3 - (msg->palette_mode & 3);
+    byte_num = sw >> shift;
+    src_stride = (byte_num + 3) & (~3);
+
+    p = msg->src.yrgb_addr;
+    p = p + (x_off>>shift) + y_off*src_stride;
+
+    bRGA_SRC_Y_MST = (u32 *)(base + RGA_SRC_Y_MST_OFFSET);
+    *bRGA_SRC_Y_MST = (u32)p;
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_color_fill_reg_info
+Description:
+    fill color fill process some relate reg bit
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+void
+RGA_set_color_fill_reg_info(u8 *base, const struct rga_req *msg)
+{
+
+    u32 *bRGA_CP_GR_A;
+    u32 *bRGA_CP_GR_B;
+    u32 *bRGA_CP_GR_G;
+    u32 *bRGA_CP_GR_R;
+
+    u32 *bRGA_PAT_CON;
+
+    bRGA_CP_GR_A = (u32 *)(base + RGA_CP_GR_A_OFFSET);
+    bRGA_CP_GR_B = (u32 *)(base + RGA_CP_GR_B_OFFSET);
+    bRGA_CP_GR_G = (u32 *)(base + RGA_CP_GR_G_OFFSET);
+    bRGA_CP_GR_R = (u32 *)(base + RGA_CP_GR_R_OFFSET);
+
+    bRGA_PAT_CON = (u32 *)(base + RGA_PAT_CON_OFFSET);
+
+    *bRGA_CP_GR_A = (msg->gr_color.gr_x_a & 0xffff) | (msg->gr_color.gr_y_a << 16);
+    *bRGA_CP_GR_B = (msg->gr_color.gr_x_b & 0xffff) | (msg->gr_color.gr_y_b << 16);
+    *bRGA_CP_GR_G = (msg->gr_color.gr_x_g & 0xffff) | (msg->gr_color.gr_y_g << 16);
+    *bRGA_CP_GR_R = (msg->gr_color.gr_x_r & 0xffff) | (msg->gr_color.gr_y_r << 16);
+
+    *bRGA_PAT_CON = (msg->pat.vir_w-1) | ((msg->pat.vir_h-1) << 8) | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
+
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_line_drawing_reg_info
+Description:
+    fill line drawing process some relate reg bit
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+s32 RGA_set_line_drawing_reg_info(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_LINE_DRAW;
+    u32 *bRGA_DST_VIR_INFO;
+    u32 *bRGA_LINE_DRAW_XY_INFO;
+    u32 *bRGA_LINE_DRAW_WIDTH;
+    u32 *bRGA_LINE_DRAWING_COLOR;
+    u32 *bRGA_LINE_DRAWING_MST;
+
+    u32  reg = 0;
+
+    s16 x_width, y_width;
+    u16 abs_x, abs_y, delta;
+    u16 stride;
+    u8 pw;
+    u32 start_addr;
+    u8 line_dir, dir_major, dir_semi_major;
+    u16 major_width;
+
+    bRGA_LINE_DRAW = (u32 *)(base + RGA_LINE_DRAW_OFFSET);
+    bRGA_DST_VIR_INFO = (u32 *)(base + RGA_DST_VIR_INFO_OFFSET);
+    bRGA_LINE_DRAW_XY_INFO = (u32 *)(base + RGA_LINE_DRAW_XY_INFO_OFFSET);
+    bRGA_LINE_DRAW_WIDTH = (u32 *)(base + RGA_LINE_DRAWING_WIDTH_OFFSET);
+    bRGA_LINE_DRAWING_COLOR = (u32 *)(base + RGA_LINE_DRAWING_COLOR_OFFSET);
+    bRGA_LINE_DRAWING_MST = (u32 *)(base + RGA_LINE_DRAWING_MST_OFFSET);
+
+    pw = RGA_pixel_width_init(msg->dst.format);
+
+    stride = (msg->dst.vir_w * pw + 3) & (~3);
+
+    start_addr = msg->dst.yrgb_addr
+                + (msg->line_draw_info.start_point.y * stride)
+                + (msg->line_draw_info.start_point.x * pw);
+
+    x_width = msg->line_draw_info.start_point.x - msg->line_draw_info.end_point.x;
+    y_width = msg->line_draw_info.start_point.y - msg->line_draw_info.end_point.y;
+
+    abs_x = abs(x_width);
+    abs_y = abs(y_width);
+
+    if (abs_x >= abs_y)
+    {
+        if (y_width > 0)
+            dir_semi_major = 1;
+        else
+            dir_semi_major = 0;
+
+        if (x_width > 0)
+            dir_major = 1;
+        else
+            dir_major = 0;
+
+        if((abs_x == 0)||(abs_y == 0))
+            delta = 0;
+        else
+            delta = (abs_y<<12)/abs_x;
+
+        if (delta >> 12)
+            delta -= 1;
+
+        major_width = abs_x;
+        line_dir = 0;
+    }
+    else
+    {
+        if (x_width > 0)
+            dir_semi_major = 1;
+        else
+            dir_semi_major = 0;
+
+        if (y_width > 0)
+            dir_major = 1;
+        else
+            dir_major = 0;
+
+        delta = (abs_x<<12)/abs_y;
+        major_width = abs_y;
+        line_dir = 1;
+    }
+
+    reg = (reg & (~m_RGA_LINE_DRAW_MAJOR_WIDTH))     | (s_RGA_LINE_DRAW_MAJOR_WIDTH(major_width));
+    reg = (reg & (~m_RGA_LINE_DRAW_LINE_DIRECTION))  | (s_RGA_LINE_DRAW_LINE_DIRECTION(line_dir));
+    reg = (reg & (~m_RGA_LINE_DRAW_LINE_WIDTH))      | (s_RGA_LINE_DRAW_LINE_WIDTH(msg->line_draw_info.line_width - 1));
+    reg = (reg & (~m_RGA_LINE_DRAW_INCR_VALUE))      | (s_RGA_LINE_DRAW_INCR_VALUE(delta));
+    reg = (reg & (~m_RGA_LINE_DRAW_DIR_SEMI_MAJOR))  | (s_RGA_LINE_DRAW_DIR_SEMI_MAJOR(dir_semi_major));
+    reg = (reg & (~m_RGA_LINE_DRAW_DIR_MAJOR))       | (s_RGA_LINE_DRAW_DIR_MAJOR(dir_major));
+    reg = (reg & (~m_RGA_LINE_DRAW_LAST_POINT))      | (s_RGA_LINE_DRAW_LAST_POINT(msg->line_draw_info.flag >> 1));
+    reg = (reg & (~m_RGA_LINE_DRAW_ANTI_ALISING))    | (s_RGA_LINE_DRAW_ANTI_ALISING(msg->line_draw_info.flag));
+
+    *bRGA_LINE_DRAW = reg;
+
+    reg = (msg->line_draw_info.start_point.x & 0xfff) | ((msg->line_draw_info.start_point.y & 0xfff) << 16);
+    *bRGA_LINE_DRAW_XY_INFO = reg;
+
+    *bRGA_LINE_DRAW_WIDTH = msg->dst.vir_w;
+
+    *bRGA_LINE_DRAWING_COLOR = msg->line_draw_info.color;
+
+    *bRGA_LINE_DRAWING_MST = (u32)start_addr;
+
+    return 0;
+}
+
+
+/*full*/
+s32
+RGA_set_filter_reg_info(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_BLUR_SHARP_INFO;
+    u32  reg = 0;
+
+    bRGA_BLUR_SHARP_INFO = (u32 *)(base + RGA_ALPHA_CON_OFFSET);
+
+    reg = *bRGA_BLUR_SHARP_INFO;
+
+    reg = ((reg & (~m_RGA_BLUR_SHARP_FILTER_TYPE)) | (s_RGA_BLUR_SHARP_FILTER_TYPE(msg->bsfilter_flag & 3)));
+    reg = ((reg & (~m_RGA_BLUR_SHARP_FILTER_MODE)) | (s_RGA_BLUR_SHARP_FILTER_MODE(msg->bsfilter_flag >>2)));
+
+    *bRGA_BLUR_SHARP_INFO = reg;
+
+    return 0;
+}
+
+
+/*full*/
+s32
+RGA_set_pre_scale_reg_info(u8 *base, const struct rga_req *msg)
+{
+   u32 *bRGA_PRE_SCALE_INFO;
+   u32 reg = 0;
+   u32 h_ratio = 0;
+   u32 v_ratio = 0;
+   u32 ps_yuv_flag = 0;
+   u32 src_width, src_height;
+   u32 dst_width, dst_height;
+
+   src_width = msg->src.act_w;
+   src_height = msg->src.act_h;
+
+   dst_width = msg->dst.act_w;
+   dst_height = msg->dst.act_h;
+
+   if((dst_width == 0) || (dst_height == 0))
+   {
+        printk("pre scale reg info error ratio is divide zero\n");
+        return -EINVAL;
+   }
+
+   h_ratio = (src_width <<16) / dst_width;
+   v_ratio = (src_height<<16) / dst_height;
+
+   if (h_ratio <= (1<<16))
+       h_ratio = 0;
+   else if (h_ratio <= (2<<16))
+       h_ratio = 1;
+   else if (h_ratio <= (4<<16))
+       h_ratio = 2;
+   else if (h_ratio <= (8<<16))
+       h_ratio = 3;
+
+   if (v_ratio <= (1<<16))
+       v_ratio = 0;
+   else if (v_ratio <= (2<<16))
+       v_ratio = 1;
+   else if (v_ratio <= (4<<16))
+       v_ratio = 2;
+   else if (v_ratio <= (8<<16))
+       v_ratio = 3;
+
+   if(msg->src.format == msg->dst.format)
+        ps_yuv_flag = 0;
+    else
+        ps_yuv_flag = 1;
+
+   bRGA_PRE_SCALE_INFO = (u32 *)(base + RGA_ALPHA_CON_OFFSET);
+
+   reg = *bRGA_PRE_SCALE_INFO;
+   reg = ((reg & (~m_RGA_PRE_SCALE_HOR_RATIO)) | (s_RGA_PRE_SCALE_HOR_RATIO((u8)h_ratio)));
+   reg = ((reg & (~m_RGA_PRE_SCALE_VER_RATIO)) | (s_RGA_PRE_SCALE_VER_RATIO((u8)v_ratio)));
+   reg = ((reg & (~m_RGA_PRE_SCALE_OUTPUT_FORMAT)) | (s_RGA_PRE_SCALE_OUTPUT_FORMAT(ps_yuv_flag)));
+
+   *bRGA_PRE_SCALE_INFO = reg;
+
+   return 0;
+}
+
+
+
+/*full*/
+int
+RGA_set_update_palette_table_reg_info(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_LUT_MST;
+
+    if (!msg->LUT_addr) {
+        return -1;
+    }
+
+    bRGA_LUT_MST  = (u32 *)(base + RGA_LUT_MST_OFFSET);
+
+    *bRGA_LUT_MST = (u32)msg->LUT_addr;
+
+    return 0;
+}
+
+
+
+/*full*/
+int
+RGA_set_update_patten_buff_reg_info(u8 *base, const struct rga_req *msg)
+{
+    u32 *bRGA_PAT_MST;
+    u32 *bRGA_PAT_CON;
+    u32 *bRGA_PAT_START_POINT;
+    u32 reg = 0;
+    rga_img_info_t *pat;
+
+    pat = (rga_img_info_t *)&msg->pat;
+
+    bRGA_PAT_START_POINT = (u32 *)(base + RGA_PAT_START_POINT_OFFSET);
+    bRGA_PAT_MST = (u32 *)(base + RGA_PAT_MST_OFFSET);
+    bRGA_PAT_CON = (u32 *)(base + RGA_PAT_CON_OFFSET);
+
+    if ( !pat->yrgb_addr ) {
+        return -1;
+    }
+    *bRGA_PAT_MST = (u32)pat->yrgb_addr;
+
+    if ((pat->vir_w > 256)||(pat->x_offset > 256)||(pat->y_offset > 256)) {
+        return -1;
+    }
+    *bRGA_PAT_START_POINT = (pat->vir_w * pat->y_offset) + pat->x_offset;
+
+    reg = (pat->vir_w-1) | ((pat->vir_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
+    *bRGA_PAT_CON = reg;
+
+    return 0;
+}
+
+
+/*************************************************************
+Func:
+    RGA_set_mmu_ctrl_reg_info
+Description:
+    fill mmu relate some reg info
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+
+s32
+RGA_set_mmu_ctrl_reg_info(u8 *base, const struct rga_req *msg)
+{
+    u32 *RGA_MMU_TLB, *RGA_MMU_CTRL_ADDR;
+    u32  mmu_addr;
+    u8   TLB_size, mmu_enable, src_flag, dst_flag, CMD_flag;
+    u32  reg = 0;
+
+    mmu_addr = (u32)msg->mmu_info.base_addr;
+    TLB_size = (msg->mmu_info.mmu_flag >> 4) & 0x3;
+    mmu_enable = msg->mmu_info.mmu_flag & 0x1;
+
+    src_flag = (msg->mmu_info.mmu_flag >> 1) & 0x1;
+    dst_flag = (msg->mmu_info.mmu_flag >> 2) & 0x1;
+    CMD_flag = (msg->mmu_info.mmu_flag >> 3) & 0x1;
+
+    RGA_MMU_TLB = (u32 *)(base + RGA_MMU_TLB_OFFSET);
+    RGA_MMU_CTRL_ADDR = (u32 *)(base + RGA_FADING_CON_OFFSET);
+
+    reg = ((reg & (~m_RGA_MMU_CTRL_TLB_ADDR)) | s_RGA_MMU_CTRL_TLB_ADDR(mmu_addr));
+    *RGA_MMU_TLB = reg;
+
+    reg = *RGA_MMU_CTRL_ADDR;
+    reg = ((reg & (~m_RGA_MMU_CTRL_PAGE_TABLE_SIZE)) | s_RGA_MMU_CTRL_PAGE_TABLE_SIZE(TLB_size));
+    reg = ((reg & (~m_RGA_MMU_CTRL_MMU_ENABLE)) | s_RGA_MMU_CTRL_MMU_ENABLE(mmu_enable));
+    reg = ((reg & (~m_RGA_MMU_CTRL_SRC_FLUSH)) | s_RGA_MMU_CTRL_SRC_FLUSH(1));
+    reg = ((reg & (~m_RGA_MMU_CTRL_DST_FLUSH)) | s_RGA_MMU_CTRL_DST_FLUSH(1));
+    reg = ((reg & (~m_RGA_MMU_CTRL_CMD_CHAN_FLUSH)) | s_RGA_MMU_CTRL_CMD_CHAN_FLUSH(1));
+    *RGA_MMU_CTRL_ADDR = reg;
+
+    return 0;
+}
+
+
+
+/*************************************************************
+Func:
+    RGA_gen_reg_info
+Description:
+    Generate RGA command reg list from rga_req struct.
+Author:
+    ZhangShengqin
+Date:
+    20012-2-2 10:59:25
+**************************************************************/
+int
+RGA_gen_reg_info(const struct rga_req *msg, unsigned char *base)
+{
+    TILE_INFO tile;
+
+    memset(base, 0x0, 28*4);
+    RGA_set_mode_ctrl(base, msg);
+
+    switch(msg->render_mode)
+    {
+        case bitblt_mode :
+            RGA_set_alpha_rop(base, msg);
+            RGA_set_src(base, msg);
+            RGA_set_dst(base, msg);
+            RGA_set_color(base, msg);
+            RGA_set_fading(base, msg);
+            RGA_set_pat(base, msg);
+            matrix_cal(msg, &tile);
+            dst_ctrl_cal(msg, &tile);
+            src_tile_info_cal(msg, &tile);
+            RGA_set_bitblt_reg_info(base, msg, &tile);
+            break;
+        case color_palette_mode :
+            RGA_set_src(base, msg);
+            RGA_set_dst(base, msg);
+            RGA_set_color(base, msg);
+            RGA_set_color_palette_reg_info(base, msg);
+            break;
+        case color_fill_mode :
+            RGA_set_alpha_rop(base, msg);
+            RGA_set_dst(base, msg);
+            RGA_set_color(base, msg);
+            RGA_set_pat(base, msg);
+            RGA_set_color_fill_reg_info(base, msg);
+            break;
+        case line_point_drawing_mode :
+            RGA_set_alpha_rop(base, msg);
+            RGA_set_dst(base, msg);
+            RGA_set_color(base, msg);
+            RGA_set_line_drawing_reg_info(base, msg);
+            break;
+        case blur_sharp_filter_mode :
+            RGA_set_src(base, msg);
+            RGA_set_dst(base, msg);
+            RGA_set_filter_reg_info(base, msg);
+            break;
+        case pre_scaling_mode :
+            RGA_set_src(base, msg);
+            RGA_set_dst(base, msg);
+            if(RGA_set_pre_scale_reg_info(base, msg) == -EINVAL)
+                return -1;
+            break;
+        case update_palette_table_mode :
+            if (RGA_set_update_palette_table_reg_info(base, msg)) {
+                return -1;
+            }
+			break;
+        case update_patten_buff_mode:
+            if (RGA_set_update_patten_buff_reg_info(base, msg)){
+                return -1;
+            }
+
+            break;
+    }
+
+    RGA_set_mmu_ctrl_reg_info(base, msg);
+
+    return 0;
+}
+
+
+
diff -Nupr a/drivers/video/rockchip/rga/rga_reg_info.h b/drivers/video/rockchip/rga/rga_reg_info.h
--- a/drivers/video/rockchip/rga/rga_reg_info.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/rga_reg_info.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,467 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __REG_INFO_H__
+#define __REG_INFO_H__
+
+
+//#include "chip_register.h"
+
+//#include "rga_struct.h"
+#include "rga.h"
+
+#ifndef MIN
+#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
+#endif
+
+#ifndef ABS
+#define ABS(X)              (((X) < 0) ? (-(X)) : (X))
+#endif
+
+#ifndef CLIP
+#define CLIP(x, a,  b)				((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x))
+#endif
+
+//RGA register map
+
+//General Registers
+#define rRGA_SYS_CTRL             (*(volatile uint32_t *)(RGA_BASE + RGA_SYS_CTRL))
+#define rRGA_CMD_CTRL             (*(volatile uint32_t *)(RGA_BASE + RGA_CMD_CTRL))
+#define rRGA_CMD_ADDR             (*(volatile uint32_t *)(RGA_BASE + RGA_CMD_ADDR))
+#define rRGA_STATUS               (*(volatile uint32_t *)(RGA_BASE + RGA_STATUS))
+#define rRGA_INT                  (*(volatile uint32_t *)(RGA_BASE + RGA_INT))
+#define rRGA_AXI_ID               (*(volatile uint32_t *)(RGA_BASE + RGA_AXI_ID))
+#define rRGA_MMU_STA_CTRL         (*(volatile uint32_t *)(RGA_BASE + RGA_MMU_STA_CTRL))
+#define rRGA_MMU_STA              (*(volatile uint32_t *)(RGA_BASE + RGA_MMU_STA))
+
+//Command code start
+#define rRGA_MODE_CTRL            (*(volatile uint32_t *)(RGA_BASE + RGA_MODE_CTRL))
+
+//Source Image Registers
+#define rRGA_SRC_Y_MST            (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_Y_MST))
+#define rRGA_SRC_CB_MST           (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_CB_MST))
+#define rRGA_MASK_READ_MST        (*(volatile uint32_t *)(RGA_BASE + RGA_MASK_READ_MST))  //repeat
+#define rRGA_SRC_CR_MST           (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_CR_MST))
+#define rRGA_SRC_VIR_INFO         (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_VIR_INFO))
+#define rRGA_SRC_ACT_INFO         (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_ACT_INFO))
+#define rRGA_SRC_X_PARA           (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_X_PARA))
+#define rRGA_SRC_Y_PARA           (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_Y_PARA))
+#define rRGA_SRC_TILE_XINFO       (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_TILE_XINFO))
+#define rRGA_SRC_TILE_YINFO       (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_TILE_YINFO))
+#define rRGA_SRC_TILE_H_INCR      (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_TILE_H_INCR))
+#define rRGA_SRC_TILE_V_INCR      (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_TILE_V_INCR))
+#define rRGA_SRC_TILE_OFFSETX     (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_TILE_OFFSETX))
+#define rRGA_SRC_TILE_OFFSETY     (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_TILE_OFFSETY))
+#define rRGA_SRC_BG_COLOR         (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_BG_COLOR))
+#define rRGA_SRC_FG_COLOR         (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_FG_COLOR))
+#define rRGA_LINE_DRAWING_COLOR   (*(volatile uint32_t *)(RGA_BASE + RGA_LINE_DRAWING_COLOR))  //repeat
+#define rRGA_SRC_TR_COLOR0        (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_TR_COLOR0))
+#define rRGA_CP_GR_A              (*(volatile uint32_t *)(RGA_BASE + RGA_CP_GR_A))  //repeat
+#define rRGA_SRC_TR_COLOR1        (*(volatile uint32_t *)(RGA_BASE + RGA_SRC_TR_COLOR1))
+#define rRGA_CP_GR_B              (*(volatile uint32_t *)(RGA_BASE + RGA_CP_GR_B))  //repeat
+
+#define rRGA_LINE_DRAW            (*(volatile uint32_t *)(RGA_BASE + RGA_LINE_DRAW))
+#define rRGA_PAT_START_POINT      (*(volatile uint32_t *)(RGA_BASE + RGA_PAT_START_POINT))  //repeat
+
+//Destination Image Registers
+#define rRGA_DST_MST              (*(volatile uint32_t *)(RGA_BASE + RGA_DST_MST))
+#define rRGA_LUT_MST              (*(volatile uint32_t *)(RGA_BASE + RGA_LUT_MST))  //repeat
+#define rRGA_PAT_MST              (*(volatile uint32_t *)(RGA_BASE + RGA_PAT_MST))  //repeat
+#define rRGA_LINE_DRAWING_MST     (*(volatile uint32_t *)(RGA_BASE + RGA_LINE_DRAWING_MST))  //repeat
+
+#define rRGA_DST_VIR_INFO         (*(volatile uint32_t *)(RGA_BASE + RGA_DST_VIR_INFO))
+
+#define rRGA_DST_CTR_INFO         (*(volatile uint32_t *)(RGA_BASE + RGA_DST_CTR_INFO))
+#define rRGA_LINE_DRAW_XY_INFO    (*(volatile uint32_t *)(RGA_BASE + RGA_LINE_DRAW_XY_INFO))  //repeat
+
+//Alpha/ROP Registers
+#define rRGA_ALPHA_CON            (*(volatile uint32_t *)(RGA_BASE + RGA_ALPHA_CON))
+#define rRGA_FADING_CON           (*(volatile uint32_t *)(RGA_BASE + RGA_FADING_CON))
+
+#define rRGA_PAT_CON              (*(volatile uint32_t *)(RGA_BASE + RGA_PAT_CON))
+#define rRGA_DST_VIR_WIDTH_PIX    (*(volatile uint32_t *)(RGA_BASE + RGA_DST_VIR_WIDTH_PIX))  //repeat
+
+#define rRGA_ROP_CON0             (*(volatile uint32_t *)(RGA_BASE + RGA_ROP_CON0))
+#define rRGA_CP_GR_G              (*(volatile uint32_t *)(RGA_BASE + RGA_CP_GR_G))  //repeat
+#define rRGA_PRESCL_CB_MST        (*(volatile uint32_t *)(RGA_BASE + RGA_PRESCL_CB_MST))  //repeat
+
+#define rRGA_ROP_CON1             (*(volatile uint32_t *)(RGA_BASE + RGA_ROP_CON1))
+#define rRGA_CP_GR_R              (*(volatile uint32_t *)(RGA_BASE + RGA_CP_GR_R))  //repeat
+#define rRGA_PRESCL_CR_MST        (*(volatile uint32_t *)(RGA_BASE + RGA_PRESCL_CR_MST))  //repeat
+
+//MMU Register
+#define rRGA_MMU_CTRL             (*(volatile uint32_t *)(RGA_BASE + RGA_MMU_CTRL))
+
+
+
+
+//-----------------------------------------------------------------
+//reg detail definition
+//-----------------------------------------------------------------
+/*RGA_SYS_CTRL*/
+#define m_RGA_SYS_CTRL_CMD_MODE                   ( 1<<2 )
+#define m_RGA_SYS_CTRL_OP_ST_SLV                  ( 1<<1 )
+#define m_RGA_sys_CTRL_SOFT_RESET                 ( 1<<0 )
+
+#define s_RGA_SYS_CTRL_CMD_MODE(x)                ( (x&0x1)<<2 )
+#define s_RGA_SYS_CTRL_OP_ST_SLV(x)               ( (x&0x1)<<1 )
+#define s_RGA_sys_CTRL_SOFT_RESET(x)              ( (x&0x1)<<0 )
+
+
+/*RGA_CMD_CTRL*/
+#define m_RGA_CMD_CTRL_CMD_INCR_NUM               ( 0x3ff<<3 )
+#define m_RGA_CMD_CTRL_CMD_STOP_MODE              (     1<<2 )
+#define m_RGA_CMD_CTRL_CMD_INCR_VALID             (     1<<1 )
+#define m_RGA_CMD_CTRL_CMD_LINE_FET_ST            (     1<<0 )
+
+#define s_RGA_CMD_CTRL_CMD_INCR_NUM(x)            ( (x&0x3ff)<<3 )
+#define s_RGA_CMD_CTRL_CMD_STOP_MODE(x)           (   (x&0x1)<<2 )
+#define s_RGA_CMD_CTRL_CMD_INCR_VALID(x)          (   (x&0x1)<<1 )
+#define s_RGA_CMD_CTRL_CMD_LINE_FET_ST(x)         (   (x*0x1)<<0 )
+
+
+/*RGA_STATUS*/
+#define m_RGA_CMD_STATUS_CMD_TOTAL_NUM            ( 0xfff<<20 )
+#define m_RGA_CMD_STATUS_NOW_CMD_NUM              ( 0xfff<<8  )
+#define m_RGA_CMD_STATUS_ENGINE_STATUS            (     1<<0  )
+
+
+/*RGA_INT*/
+#define m_RGA_INT_ALL_CMD_DONE_INT_EN             ( 1<<10 )
+#define m_RGA_INT_MMU_INT_EN                      ( 1<<9  )
+#define m_RGA_INT_ERROR_INT_EN                    ( 1<<8  )
+#define m_RGA_INT_NOW_CMD_DONE_INT_CLEAR          ( 1<<7  )
+#define m_RGA_INT_ALL_CMD_DONE_INT_CLEAR          ( 1<<6  )
+#define m_RGA_INT_MMU_INT_CLEAR                   ( 1<<5  )
+#define m_RGA_INT_ERROR_INT_CLEAR                 ( 1<<4  )
+#define m_RGA_INT_NOW_CMD_DONE_INT_FLAG           ( 1<<3  )
+#define m_RGA_INT_ALL_CMD_DONE_INT_FLAG           ( 1<<2  )
+#define m_RGA_INT_MMU_INT_FLAG                    ( 1<<1  )
+#define m_RGA_INT_ERROR_INT_FLAG                  ( 1<<0  )
+
+#define s_RGA_INT_ALL_CMD_DONE_INT_EN(x)          ( (x&0x1)<<10 )
+#define s_RGA_INT_MMU_INT_EN(x)                   ( (x&0x1)<<9  )
+#define s_RGA_INT_ERROR_INT_EN(x)                 ( (x&0x1)<<8  )
+#define s_RGA_INT_NOW_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<7  )
+#define s_RGA_INT_ALL_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<6  )
+#define s_RGA_INT_MMU_INT_CLEAR(x)                ( (x&0x1)<<5  )
+#define s_RGA_INT_ERROR_INT_CLEAR(x)              ( (x&0x1)<<4  )
+
+
+/*RGA_AXI_ID*/
+#define m_RGA_AXI_ID_MMU_READ                     ( 3<<30 )
+#define m_RGA_AXI_ID_MMU_WRITE                    ( 3<<28 )
+#define m_RGA_AXI_ID_MASK_READ                    ( 0xf<<24 )
+#define m_RGA_AXI_ID_CMD_FET                      ( 0xf<<20 )
+#define m_RGA_AXI_ID_DST_WRITE                    ( 0xf<<16 )
+#define m_RGA_AXI_ID_DST_READ                     ( 0xf<<12 )
+#define m_RGA_AXI_ID_SRC_CR_READ                  ( 0xf<<8  )
+#define m_RGA_AXI_ID_SRC_CB_READ                  ( 0xf<<4  )
+#define m_RGA_AXI_ID_SRC_Y_READ                   ( 0xf<<0  )
+
+#define s_RGA_AXI_ID_MMU_READ(x)                  ( (x&0x3)<<30 )
+#define s_RGA_AXI_ID_MMU_WRITE(x)                 ( (x&0x3)<<28 )
+#define s_RGA_AXI_ID_MASK_READ(x)                 ( (x&0xf)<<24 )
+#define s_RGA_AXI_ID_CMD_FET(x)                   ( (x&0xf)<<20 )
+#define s_RGA_AXI_ID_DST_WRITE(x)                 ( (x&0xf)<<16 )
+#define s_RGA_AXI_ID_DST_READ(x)                  ( (x&0xf)<<12 )
+#define s_RGA_AXI_ID_SRC_CR_READ(x)               ( (x&0xf)<<8  )
+#define s_RGA_AXI_ID_SRC_CB_READ(x)               ( (x&0xf)<<4  )
+#define s_RGA_AXI_ID_SRC_Y_READ(x)                ( (x&0xf)<<0  )
+
+
+/*RGA_MMU_STA_CTRL*/
+#define m_RGA_MMU_STA_CTRL_TLB_STA_CLEAR          ( 1<<3 )
+#define m_RGA_MMU_STA_CTRL_TLB_STA_RESUME         ( 1<<2 )
+#define m_RGA_MMU_STA_CTRL_TLB_STA_PAUSE          ( 1<<1 )
+#define m_RGA_MMU_STA_CTRL_TLB_STA_EN             ( 1<<0 )
+
+#define s_RGA_MMU_STA_CTRL_TLB_STA_CLEAR(x)       ( (x&0x1)<<3 )
+#define s_RGA_MMU_STA_CTRL_TLB_STA_RESUME(x)      ( (x&0x1)<<2 )
+#define s_RGA_MMU_STA_CTRL_TLB_STA_PAUSE(x)       ( (x&0x1)<<1 )
+#define s_RGA_MMU_STA_CTRL_TLB_STA_EN(x)          ( (x&0x1)<<0 )
+
+
+
+/* RGA_MODE_CTRL */
+#define m_RGA_MODE_CTRL_2D_RENDER_MODE            (  7<<0  )
+#define m_RGA_MODE_CTRL_SRC_RGB_PACK              (  1<<3  )
+#define m_RGA_MODE_CTRL_SRC_FORMAT                ( 15<<4  )
+#define m_RGA_MODE_CTRL_SRC_RB_SWAP               (  1<<8  )
+#define m_RGA_MODE_CTRL_SRC_ALPHA_SWAP            (  1<<9  )
+#define m_RGA_MODE_CTRL_SRC_UV_SWAP_MODE          (  1<<10 )
+#define m_RGA_MODE_CTRL_YUV2RGB_CON_MODE          (  3<<11 )
+#define m_RGA_MODE_CTRL_SRC_TRANS_MODE           (0x1f<<13 )
+#define m_RGA_MODE_CTRL_SRC_TR_MODE               (  1<<13 )
+#define m_RGA_MODE_CTRL_SRC_TR_R_EN               (  1<<14 )
+#define m_RGA_MODE_CTRL_SRC_TR_G_EN               (  1<<15 )
+#define m_RGA_MODE_CTRL_SRC_TR_B_EN               (  1<<16 )
+#define m_RGA_MODE_CTRL_SRC_TR_A_EN               (  1<<17 )
+#define m_RGA_MODE_CTRL_ROTATE_MODE               (  3<<18 )
+#define m_RGA_MODE_CTRL_SCALE_MODE                (  3<<20 )
+#define m_RGA_MODE_CTRL_PAT_SEL                   (  1<<22 )
+#define m_RGA_MODE_CTRL_DST_FORMAT                (  3<<23 )
+#define m_RGA_MODE_CTRL_DST_RGB_PACK              (  1<<25 )
+#define m_RGA_MODE_CTRL_DST_RB_SWAP               (  1<<26 )
+#define m_RGA_MODE_CTRL_DST_ALPHA_SWAP            (  1<<27 )
+#define m_RGA_MODE_CTRL_LUT_ENDIAN_MODE           (  1<<28 )
+#define m_RGA_MODE_CTRL_CMD_INT_ENABLE            (  1<<29 )
+#define m_RGA_MODE_CTRL_ZERO_MODE_ENABLE          (  1<<30 )
+#define m_RGA_MODE_CTRL_DST_ALPHA_ENABLE          (  1<<30 )
+
+
+
+#define s_RGA_MODE_CTRL_2D_RENDER_MODE(x)         (  (x&0x7)<<0  )
+#define s_RGA_MODE_CTRL_SRC_RGB_PACK(x)           (  (x&0x1)<<3  )
+#define s_RGA_MODE_CTRL_SRC_FORMAT(x)             (  (x&0xf)<<4  )
+#define s_RGA_MODE_CTRL_SRC_RB_SWAP(x)            (  (x&0x1)<<8  )
+#define s_RGA_MODE_CTRL_SRC_ALPHA_SWAP(x)         (  (x&0x1)<<9  )
+#define s_RGA_MODE_CTRL_SRC_UV_SWAP_MODE(x)       (  (x&0x1)<<10 )
+#define s_RGA_MODE_CTRL_YUV2RGB_CON_MODE(x)       (  (x&0x3)<<11 )
+#define s_RGA_MODE_CTRL_SRC_TRANS_MODE(x)         ( (x&0x1f)<<13 )
+#define s_RGA_MODE_CTRL_SRC_TR_MODE(x)            (  (x&0x1)<<13 )
+#define s_RGA_MODE_CTRL_SRC_TR_R_EN(x)            (  (x&0x1)<<14 )
+#define s_RGA_MODE_CTRL_SRC_TR_G_EN(x)            (  (x&0x1)<<15 )
+#define s_RGA_MODE_CTRL_SRC_TR_B_EN(x)            (  (x&0x1)<<16 )
+#define s_RGA_MODE_CTRL_SRC_TR_A_EN(x)            (  (x&0x1)<<17 )
+#define s_RGA_MODE_CTRL_ROTATE_MODE(x)            (  (x&0x3)<<18 )
+#define s_RGA_MODE_CTRL_SCALE_MODE(x)             (  (x&0x3)<<20 )
+#define s_RGA_MODE_CTRL_PAT_SEL(x)                (  (x&0x1)<<22 )
+#define s_RGA_MODE_CTRL_DST_FORMAT(x)             (  (x&0x3)<<23 )
+#define s_RGA_MODE_CTRL_DST_RGB_PACK(x)           (  (x&0x1)<<25 )
+#define s_RGA_MODE_CTRL_DST_RB_SWAP(x)            (  (x&0x1)<<26 )
+#define s_RGA_MODE_CTRL_DST_ALPHA_SWAP(x)         (  (x&0x1)<<27 )
+#define s_RGA_MODE_CTRL_LUT_ENDIAN_MODE(x)        (  (x&0x1)<<28 )
+#define s_RGA_MODE_CTRL_CMD_INT_ENABLE(x)         (  (x&0x1)<<29 )
+#define s_RGA_MODE_CTRL_ZERO_MODE_ENABLE(x)       (  (x&0x1)<<30 )
+#define s_RGA_MODE_CTRL_DST_ALPHA_ENABLE(x)       (  (x&0x1)<<31 )
+
+
+
+/* RGA_LINE_DRAW */
+#define m_RGA_LINE_DRAW_MAJOR_WIDTH            ( 0x7ff<<0 )
+#define m_RGA_LINE_DRAW_LINE_DIRECTION         (   0x1<<11)
+#define m_RGA_LINE_DRAW_LINE_WIDTH             (   0xf<<12)
+#define m_RGA_LINE_DRAW_INCR_VALUE             ( 0xfff<<16)
+#define m_RGA_LINE_DRAW_DIR_MAJOR              (   0x1<<28)
+#define m_RGA_LINE_DRAW_DIR_SEMI_MAJOR         (   0x1<<29)
+#define m_RGA_LINE_DRAW_LAST_POINT             (   0x1<<30)
+#define m_RGA_LINE_DRAW_ANTI_ALISING           (   0x1<<31)
+
+#define s_RGA_LINE_DRAW_MAJOR_WIDTH(x)            (((x)&0x7ff)<<0 )
+#define s_RGA_LINE_DRAW_LINE_DIRECTION(x)         (  ((x)&0x1)<<11)
+#define s_RGA_LINE_DRAW_LINE_WIDTH(x)             (  ((x)&0xf)<<12)
+#define s_RGA_LINE_DRAW_INCR_VALUE(x)             (((x)&0xfff)<<16)
+#define s_RGA_LINE_DRAW_DIR_MAJOR(x)              (  ((x)&0x1)<<28)
+#define s_RGA_LINE_DRAW_DIR_SEMI_MAJOR(x)         (  ((x)&0x1)<<29)
+#define s_RGA_LINE_DRAW_LAST_POINT(x)             (  ((x)&0x1)<<30)
+#define s_RGA_LINE_DRAW_ANTI_ALISING(x)           (  ((x)&0x1)<<31)
+
+
+/* RGA_ALPHA_CON */
+#define m_RGA_ALPHA_CON_ENABLE                  ( 0x1<<0 )
+#define m_RGA_ALPHA_CON_A_OR_R_SEL              ( 0x1<<1 )
+#define m_RGA_ALPHA_CON_ALPHA_MODE              ( 0x3<<2 )
+#define m_RGA_ALPHA_CON_PD_MODE                 ( 0xf<<4 )
+#define m_RGA_ALPHA_CON_SET_CONSTANT_VALUE      (0xff<<8 )
+#define m_RGA_ALPHA_CON_PD_M_SEL                ( 0x1<<16)
+#define m_RGA_ALPHA_CON_FADING_ENABLE           ( 0x1<<17)
+#define m_RGA_ALPHA_CON_ROP_MODE_SEL            ( 0x3<<18)
+#define m_RGA_ALPHA_CON_CAL_MODE_SEL            ( 0x1<<28)
+#define m_RGA_ALPHA_CON_DITHER_ENABLE           ( 0x1<<29)
+#define m_RGA_ALPHA_CON_GRADIENT_CAL_MODE       ( 0x1<<30)
+#define m_RGA_ALPHA_CON_AA_SEL                  ( 0x1<<31)
+
+#define s_RGA_ALPHA_CON_ENABLE(x)                  ( (x&0x1)<<0 )
+#define s_RGA_ALPHA_CON_A_OR_R_SEL(x)              ( (x&0x1)<<1 )
+#define s_RGA_ALPHA_CON_ALPHA_MODE(x)              ( (x&0x3)<<2 )
+#define s_RGA_ALPHA_CON_PD_MODE(x)                 ( (x&0xf)<<4 )
+#define s_RGA_ALPHA_CON_SET_CONSTANT_VALUE(x)      ((x&0xff)<<8 )
+#define s_RGA_ALPHA_CON_PD_M_SEL(x)                ( (x&0x1)<<16)
+#define s_RGA_ALPHA_CON_FADING_ENABLE(x)           ( (x&0x1)<<17)
+#define s_RGA_ALPHA_CON_ROP_MODE_SEL(x)            ( (x&0x3)<<18)
+#define s_RGA_ALPHA_CON_CAL_MODE_SEL(x)            ( (x&0x1)<<28)
+#define s_RGA_ALPHA_CON_DITHER_ENABLE(x)           ( (x&0x1)<<29)
+#define s_RGA_ALPHA_CON_GRADIENT_CAL_MODE(x)       ( (x&0x1)<<30)
+#define s_RGA_ALPHA_CON_AA_SEL(x)                  ( (x&0x1)<<31)
+
+
+/* blur sharp mode */
+#define m_RGA_BLUR_SHARP_FILTER_MODE                    (  0x1<<25 )
+#define m_RGA_BLUR_SHARP_FILTER_TYPE                    (  0x3<<26 )
+
+#define s_RGA_BLUR_SHARP_FILTER_MODE(x)                 ( (x&0x1)<<25 )
+#define s_RGA_BLUR_SHARP_FILTER_TYPE(x)                 ( (x&0x3)<<26 )
+
+
+/* pre scale mode */
+#define m_RGA_PRE_SCALE_HOR_RATIO                       ( 0x3 <<20 )
+#define m_RGA_PRE_SCALE_VER_RATIO                       ( 0x3 <<22 )
+#define m_RGA_PRE_SCALE_OUTPUT_FORMAT                   ( 0x1 <<24 )
+
+#define s_RGA_PRE_SCALE_HOR_RATIO(x)                    ( (x&0x3) <<20 )
+#define s_RGA_PRE_SCALE_VER_RATIO(x)                    ( (x&0x3) <<22 )
+#define s_RGA_PRE_SCALE_OUTPUT_FORMAT(x)                ( (x&0x1) <<24 )
+
+
+
+/* RGA_MMU_CTRL*/
+#define m_RGA_MMU_CTRL_TLB_ADDR                         ( 0xffffffff<<0)
+#define m_RGA_MMU_CTRL_PAGE_TABLE_SIZE                  ( 0x3<<4 )
+#define m_RGA_MMU_CTRL_MMU_ENABLE                       ( 0x1<<0 )
+#define m_RGA_MMU_CTRL_SRC_FLUSH                        ( 0x1<<1 )
+#define m_RGA_MMU_CTRL_DST_FLUSH                        ( 0x1<<2 )
+#define m_RGA_MMU_CTRL_CMD_CHAN_FLUSH                   ( 0x1<<3 )
+
+#define s_RGA_MMU_CTRL_TLB_ADDR(x)                      ((x&0xffffffff))
+#define s_RGA_MMU_CTRL_PAGE_TABLE_SIZE(x)               ((x&0x3)<<4)
+#define s_RGA_MMU_CTRL_MMU_ENABLE(x)                    ((x&0x1)<<0)
+#define s_RGA_MMU_CTRL_SRC_FLUSH(x)                     ((x&0x1)<<1)
+#define s_RGA_MMU_CTRL_DST_FLUSH(x)                     ((x&0x1)<<2)
+#define s_RGA_MMU_CTRL_CMD_CHAN_FLUSH(x)                ((x&0x1)<<3)
+
+#endif
+
+/*
+#define RGA_MODE_CTRL_OFFSET            0x0
+#define RGA_SRC_Y_MST_OFFSET            0x4
+#define RGA_SRC_CB_MST_OFFSET           0x8
+#define RGA_SRC_CR_MST_OFFSET           0xc
+#define RGA_SRC_VIR_INFO_OFFSET         0x10
+#define RGA_SRC_ACT_INFO_OFFSET         0x14
+#define RGA_SRC_X_PARA_OFFSET           0x18
+#define RGA_SRC_Y_PARA_OFFSET           0x1c
+#define RGA_SRC_TILE_XINFO_OFFSET       0x20
+#define RGA_SRC_TILE_YINFO_OFFSET       0x24
+#define RGA_SRC_TILE_H_INCR_OFFSET      0x28
+#define RGA_SRC_TILE_V_INCR_OFFSET      0x2c
+#define RGA_SRC_TILE_OFFSETX_OFFSET     0x30
+#define RGA_SRC_TILE_OFFSETY_OFFSET     0x34
+#define RGA_SRC_BG_COLOR_OFFSET         0x38
+
+#define RGA_SRC_FG_COLOR_OFFSET         0x3c
+#define RGA_LINE_DRAWING_COLOR_OFFSET   0x3c
+
+#define RGA_SRC_TR_COLOR0_OFFSET        0x40
+#define RGA_CP_GR_A_OFFSET              0x40  //repeat
+
+#define RGA_SRC_TR_COLOR1_OFFSET        0x44
+#define RGA_CP_GR_B_OFFSET              0x44  //repeat
+
+#define RGA_LINE_DRAW_OFFSET            0x48
+#define RGA_PAT_START_POINT_OFFSET      0x48  //repeat
+
+#define RGA_DST_MST_OFFSET              0x4c
+#define RGA_LUT_MST_OFFSET              0x4c  //repeat
+#define RGA_PAT_MST_OFFSET              0x4c  //repeat
+#define RGA_LINE_DRAWING_MST_OFFSET     0x4c  //repeat
+
+#define RGA_DST_VIR_INFO_OFFSET         0x50
+
+#define RGA_DST_CTR_INFO_OFFSET         0x54
+#define RGA_LINE_DRAW_XY_INFO_OFFSET    0x54  //repeat
+
+#define RGA_ALPHA_CON_OFFSET            0x58
+#define RGA_FADING_CON_OFFSET           0x5c
+
+#define RGA_PAT_CON_OFFSET              0x60
+#define RGA_LINE_DRAWING_WIDTH_OFFSET   0x60  //repeat
+
+#define RGA_ROP_CON0_OFFSET             0x64
+#define RGA_CP_GR_G_OFFSET              0x64  //repeat
+#define RGA_PRESCL_CB_MST_OFFSET        0x64  //repeat
+
+#define RGA_ROP_CON1_OFFSET             0x68
+#define RGA_CP_GR_R_OFFSET              0x68  //repeat
+#define RGA_PRESCL_CR_MST_OFFSET        0x68  //repeat
+
+#define RGA_MMU_CTRL_OFFSET             0x6c
+
+
+#define RGA_SYS_CTRL_OFFSET             0x000
+#define RGA_CMD_CTRL_OFFSET             0x004
+#define RGA_CMD_ADDR_OFFSET             0x008
+#define RGA_STATUS_OFFSET               0x00c
+#define RGA_INT_OFFSET                  0x010
+#define RGA_AXI_ID_OFFSET               0x014
+#define RGA_MMU_STA_CTRL_OFFSET         0x018
+#define RGA_MMU_STA_OFFSET              0x01c
+*/
+//hxx
+
+#define RGA_SYS_CTRL_OFFSET             (RGA_SYS_CTRL-0x100)
+#define RGA_CMD_CTRL_OFFSET             (RGA_CMD_CTRL-0x100)
+#define RGA_CMD_ADDR_OFFSET             (RGA_CMD_ADDR-0x100)
+#define RGA_STATUS_OFFSET               (RGA_STATUS-0x100)
+#define RGA_INT_OFFSET                  (RGA_INT-0x100)
+#define RGA_AXI_ID_OFFSET               (RGA_AXI_ID-0x100)
+#define RGA_MMU_STA_CTRL_OFFSET         (RGA_MMU_STA_CTRL-0x100)
+#define RGA_MMU_STA_OFFSET              (RGA_MMU_STA-0x100)
+
+#define RGA_MODE_CTRL_OFFSET            (RGA_MODE_CTRL-0x100)
+#define RGA_SRC_Y_MST_OFFSET            (RGA_SRC_Y_MST-0x100)
+#define RGA_SRC_CB_MST_OFFSET           (RGA_SRC_CB_MST-0x100)
+#define RGA_SRC_CR_MST_OFFSET           (RGA_SRC_CR_MST-0x100)
+#define RGA_SRC_VIR_INFO_OFFSET         (RGA_SRC_VIR_INFO-0x100)
+#define RGA_SRC_ACT_INFO_OFFSET         (RGA_SRC_ACT_INFO-0x100)
+#define RGA_SRC_X_PARA_OFFSET           (RGA_SRC_X_PARA-0x100)
+#define RGA_SRC_Y_PARA_OFFSET           (RGA_SRC_Y_PARA-0x100)
+#define RGA_SRC_TILE_XINFO_OFFSET       (RGA_SRC_TILE_XINFO-0x100)
+#define RGA_SRC_TILE_YINFO_OFFSET       (RGA_SRC_TILE_YINFO-0x100)
+#define RGA_SRC_TILE_H_INCR_OFFSET      (RGA_SRC_TILE_H_INCR-0x100)
+#define RGA_SRC_TILE_V_INCR_OFFSET      (RGA_SRC_TILE_V_INCR-0x100)
+#define RGA_SRC_TILE_OFFSETX_OFFSET     (RGA_SRC_TILE_OFFSETX-0x100)
+#define RGA_SRC_TILE_OFFSETY_OFFSET     (RGA_SRC_TILE_OFFSETY-0x100)
+#define RGA_SRC_BG_COLOR_OFFSET         (RGA_SRC_BG_COLOR-0x100)
+
+#define RGA_SRC_FG_COLOR_OFFSET         (RGA_SRC_FG_COLOR-0x100)
+#define RGA_LINE_DRAWING_COLOR_OFFSET   (RGA_LINE_DRAWING_COLOR-0x100)
+
+#define RGA_SRC_TR_COLOR0_OFFSET        (RGA_SRC_TR_COLOR0-0x100)
+#define RGA_CP_GR_A_OFFSET              (RGA_CP_GR_A-0x100)  //repeat
+
+#define RGA_SRC_TR_COLOR1_OFFSET        (RGA_SRC_TR_COLOR1-0x100)
+#define RGA_CP_GR_B_OFFSET              (RGA_CP_GR_B-0x100)  //repeat
+
+#define RGA_LINE_DRAW_OFFSET            (RGA_LINE_DRAW-0x100)
+#define RGA_PAT_START_POINT_OFFSET      (RGA_PAT_START_POINT-0x100)  //repeat
+
+#define RGA_DST_MST_OFFSET              (RGA_DST_MST-0x100)
+#define RGA_LUT_MST_OFFSET              (RGA_LUT_MST-0x100)  //repeat
+#define RGA_PAT_MST_OFFSET              (RGA_PAT_MST-0x100)  //repeat
+#define RGA_LINE_DRAWING_MST_OFFSET     (RGA_LINE_DRAWING_MST-0x100)  //repeat
+
+#define RGA_DST_VIR_INFO_OFFSET         (RGA_DST_VIR_INFO-0x100)
+
+#define RGA_DST_CTR_INFO_OFFSET         (RGA_DST_CTR_INFO-0x100)
+#define RGA_LINE_DRAW_XY_INFO_OFFSET    (RGA_LINE_DRAW_XY_INFO-0x100)  //repeat
+
+#define RGA_ALPHA_CON_OFFSET            (RGA_ALPHA_CON-0x100)
+
+#define RGA_PAT_CON_OFFSET              (RGA_PAT_CON-0x100)
+#define RGA_LINE_DRAWING_WIDTH_OFFSET   (RGA_DST_VIR_WIDTH_PIX-0x100)  //repeat
+
+#define RGA_ROP_CON0_OFFSET             (RGA_ROP_CON0-0x100)
+#define RGA_CP_GR_G_OFFSET              (RGA_CP_GR_G-0x100)  //repeat
+#define RGA_PRESCL_CB_MST_OFFSET        (RGA_PRESCL_CB_MST-0x100)  //repeat
+
+#define RGA_ROP_CON1_OFFSET             (RGA_ROP_CON1-0x100)
+#define RGA_CP_GR_R_OFFSET              (RGA_CP_GR_R-0x100)  //repeat
+#define RGA_PRESCL_CR_MST_OFFSET        (RGA_PRESCL_CR_MST-0x100)  //repeat
+
+#define RGA_FADING_CON_OFFSET           (RGA_FADING_CON-0x100)
+#define RGA_MMU_TLB_OFFSET              (RGA_MMU_TBL-0x100)
+
+#define RGA_YUV_OUT_CFG_OFFSET         (RGA_YUV_OUT_CFG-0x100)
+#define RGA_DST_UV_MST_OFFSET          (RGA_DST_UV_MST-0x100)
+
+
+
+void matrix_cal(const struct rga_req *msg, TILE_INFO *tile);
+
+
+int RGA_gen_reg_info(const struct rga_req *msg, unsigned char *base);
+uint8_t   RGA_pixel_width_init(uint32_t format);
+
diff -Nupr a/drivers/video/rockchip/rga/rga_rop.h b/drivers/video/rockchip/rga/rga_rop.h
--- a/drivers/video/rockchip/rga/rga_rop.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/rga_rop.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RGA_ROP_H__
+#define __RGA_ROP_H__
+
+unsigned int ROP3_code[256] =
+{
+    0x00000007, 0x00000451, 0x00006051, 0x00800051, 0x00007041, 0x00800041, 0x00804830, 0x000004f0,//0
+    0x00800765, 0x000004b0, 0x00000065, 0x000004f4, 0x00000075, 0x000004e6, 0x00804850, 0x00800005,
+
+    0x00006850, 0x00800050, 0x00805028, 0x00000568, 0x00804031, 0x00000471, 0x002b6071, 0x018037aa,//1
+    0x008007aa, 0x00036071, 0x00002c6a, 0x00803631, 0x00002d68, 0x00802721, 0x008002d0, 0x000006d0,
+
+    0x0080066e, 0x00000528, 0x00000066, 0x0000056c, 0x018007aa, 0x0002e06a, 0x00003471, 0x00834031,//2
+    0x00800631, 0x0002b471, 0x00006071, 0x008037aa, 0x000036d0, 0x008002d4, 0x00002d28, 0x000006d4,
+
+    0x0000006e, 0x00000565, 0x00003451, 0x00800006, 0x000034f0, 0x00834830, 0x00800348, 0x00000748,//3
+    0x00002f48, 0x0080034c, 0x000034b0, 0x0000074c, 0x00000031, 0x00834850, 0x000034e6, 0x00800071,
+
+    0x008006f4, 0x00000431, 0x018007a1, 0x00b6e870, 0x00000074, 0x0000046e, 0x00002561, 0x00802f28,//4
+    0x00800728, 0x0002a561, 0x000026c2, 0x008002c6, 0x00007068, 0x018035aa, 0x00002c2a, 0x000006c6,
+
+    0x0000006c, 0x00000475, 0x000024e2, 0x008036b0, 0x00804051, 0x00800004, 0x00800251, 0x00000651,
+    0x00002e4a, 0x0080024e, 0x00000028, 0x00824842, 0x000024a2, 0x0000064e, 0x000024f4, 0x00800068,//5
+
+    0x008006b0, 0x000234f0, 0x00002741, 0x00800345, 0x00003651, 0x00800255, 0x00000030, 0x00834051,
+    0x00a34842, 0x000002b0, 0x00800271, 0x0002b651, 0x00800368, 0x0002a741, 0x0000364e, 0x00806830,//6
+
+    0x00006870, 0x008037a2, 0x00003431, 0x00000745, 0x00002521, 0x00000655, 0x0000346e, 0x00800062,
+    0x008002f0, 0x000236d0, 0x000026d4, 0x00807028, 0x000036c6, 0x00806031, 0x008005aa, 0x00000671,//7
+
+    0x00800671, 0x000005aa, 0x00006031, 0x008036c6, 0x00007028, 0x00802e55, 0x008236d0, 0x000002f0,
+    0x00000070, 0x0080346e, 0x00800655, 0x00802521, 0x00800745, 0x00803431, 0x000037a2, 0x00806870,//8
+
+    0x00006830, 0x0080364e, 0x00822f48, 0x00000361, 0x0082b651, 0x00000271, 0x00800231, 0x002b4051,
+    0x00034051, 0x00800030, 0x0080026e, 0x00803651, 0x0080036c, 0x00802741, 0x008234f0, 0x000006b0,//9
+
+    0x00000068, 0x00802c75, 0x0080064e, 0x008024a2, 0x0002c04a, 0x00800021, 0x00800275, 0x00802e51,
+    0x00800651, 0x00000251, 0x00800000, 0x00004051, 0x000036b0, 0x008024e2, 0x00800475, 0x00000045,//a
+
+    0x008006c6, 0x00802c2a, 0x000035aa, 0x00807068, 0x008002f4, 0x008026c2, 0x00822d68, 0x00000728,
+    0x00002f28, 0x00802561, 0x0080046e, 0x00000046, 0x00836870, 0x000007a2, 0x00800431, 0x00004071,//b
+
+    0x00000071, 0x008034e6, 0x00034850, 0x00800031, 0x0080074c, 0x008034b0, 0x00800365, 0x00802f48,
+    0x00800748, 0x00000341, 0x000026a2, 0x008034f0, 0x00800002, 0x00005048, 0x00800565, 0x00000055,//c
+
+    0x008006d4, 0x00802d28, 0x008002e6, 0x008036d0, 0x000037aa, 0x00806071, 0x0082b471, 0x00000631,
+    0x00002e2a, 0x00803471, 0x00826862, 0x010007aa, 0x0080056c, 0x00000054, 0x00800528, 0x00005068,//d
+
+    0x008006d0, 0x000002d0, 0x00002721, 0x00802d68, 0x00003631, 0x00802c6a, 0x00836071, 0x000007aa,
+    0x010037aa, 0x00a36870, 0x00800471, 0x00004031, 0x00800568, 0x00005028, 0x00000050, 0x00800545,//e
+
+    0x00800001, 0x00004850, 0x008004e6, 0x0000004e, 0x008004f4, 0x0000004c, 0x008004b0, 0x00004870,
+    0x008004f0, 0x00004830, 0x00000048, 0x0080044e, 0x00000051, 0x008004d4, 0x00800451, 0x00800007,//f
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/rga/rga_type.h b/drivers/video/rockchip/rga/rga_type.h
--- a/drivers/video/rockchip/rga/rga_type.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga/rga_type.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RGA_TYPE_H__
+#define __RGA_TYPE_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+typedef  unsigned int     UWORD32;
+typedef  unsigned int     uint32;
+typedef  unsigned int     RK_U32;
+
+typedef  unsigned short   UWORD16;
+typedef  unsigned short   RK_U16;
+
+typedef  unsigned char    UBYTE;
+typedef  unsigned char    RK_U8;
+
+typedef  int              WORD32;
+typedef  int              RK_S32;
+
+typedef  short            WORD16;
+typedef  short            RK_S16;
+
+typedef  char             BYTE;
+typedef  char             RK_S8;
+
+
+#ifndef NULL
+#define NULL              0L
+#endif
+
+#ifndef TRUE
+#define TRUE              1L
+#endif
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* __RGA_TYPR_H__ */
+
diff -Nupr a/drivers/video/rockchip/rga2/Kconfig b/drivers/video/rockchip/rga2/Kconfig
--- a/drivers/video/rockchip/rga2/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+menu "RGA2"
+	depends on ARCH_ROCKCHIP
+
+config ROCKCHIP_RGA2
+	tristate "ROCKCHIP_RGA2"
+	help
+	  rk32 rga2 module.
+
+endmenu
diff -Nupr a/drivers/video/rockchip/rga2/Makefile b/drivers/video/rockchip/rga2/Makefile
--- a/drivers/video/rockchip/rga2/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
+rga2-y	:= rga2_drv.o rga2_mmu_info.o rga2_reg_info.o RGA2_API.o
+
+obj-$(CONFIG_ROCKCHIP_RGA2)	+= rga2.o
diff -Nupr a/drivers/video/rockchip/rga2/RGA2_API.c b/drivers/video/rockchip/rga2/RGA2_API.c
--- a/drivers/video/rockchip/rga2/RGA2_API.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/RGA2_API.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#include <linux/memory.h>
+#include "RGA2_API.h"
+#include "rga2.h"
+//#include "rga_angle.h"
+
+#define IS_YUV_420(format) \
+     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
+      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP))
+
+#define IS_YUV_422(format) \
+     ((format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
+      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
+
+#define IS_YUV(format) \
+     ((format == RK_FORMAT_YCbCr_420_P) | (format == RK_FORMAT_YCbCr_420_SP) | \
+      (format == RK_FORMAT_YCrCb_420_P) | (format == RK_FORMAT_YCrCb_420_SP) | \
+      (format == RK_FORMAT_YCbCr_422_P) | (format == RK_FORMAT_YCbCr_422_SP) | \
+      (format == RK_FORMAT_YCrCb_422_P) | (format == RK_FORMAT_YCrCb_422_SP))
+
+
+
diff -Nupr a/drivers/video/rockchip/rga2/RGA2_API.h b/drivers/video/rockchip/rga2/RGA2_API.h
--- a/drivers/video/rockchip/rga2/RGA2_API.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/RGA2_API.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RGA_API_H__
+#define __RGA_API_H__
+
+#include "rga2_reg_info.h"
+#include "rga2.h"
+
+#define ENABLE      1
+#define DISABLE     0
+
+
+
+#endif
diff -Nupr a/drivers/video/rockchip/rga2/rga2_drv.c b/drivers/video/rockchip/rga2/rga2_drv.c
--- a/drivers/video/rockchip/rga2/rga2_drv.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/rga2_drv.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1682 @@
+/*
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt) "rga: " fmt
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <asm/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/syscalls.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <asm/cacheflush.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/wakelock.h>
+#include <linux/scatterlist.h>
+#include <linux/rockchip_ion.h>
+#include <linux/version.h>
+#include <linux/pm_runtime.h>
+#include <linux/dma-buf.h>
+
+#include "rga2.h"
+#include "rga2_reg_info.h"
+#include "rga2_mmu_info.h"
+#include "RGA2_API.h"
+#include "rga2_rop.h"
+
+#if defined(CONFIG_RK_IOMMU) && defined(CONFIG_ION_ROCKCHIP)
+#define CONFIG_RGA_IOMMU
+#endif
+
+#define RGA2_TEST_FLUSH_TIME 0
+#define RGA2_INFO_BUS_ERROR 1
+#define RGA2_POWER_OFF_DELAY	4*HZ /* 4s */
+#define RGA2_TIMEOUT_DELAY	(HZ / 10) /* 100ms */
+#define RGA2_MAJOR		255
+#define RGA2_RESET_TIMEOUT	1000
+
+/* Driver information */
+#define DRIVER_DESC		"RGA2 Device Driver"
+#define DRIVER_NAME		"rga2"
+#define RGA2_VERSION   "2.000"
+
+ktime_t rga2_start;
+ktime_t rga2_end;
+int rga2_flag;
+int first_RGA2_proc;
+
+rga2_session rga2_session_global;
+long (*rga2_ioctl_kernel_p)(struct rga_req *);
+
+struct rga2_drvdata_t {
+	struct miscdevice miscdev;
+	struct device *dev;
+	void *rga_base;
+	int irq;
+
+	struct delayed_work power_off_work;
+	struct wake_lock wake_lock;
+	void (*rga_irq_callback)(int rga_retval);
+
+	struct clk *aclk_rga2;
+	struct clk *hclk_rga2;
+	struct clk *rga2;
+
+	struct ion_client * ion_client;
+	char version[16];
+};
+
+struct rga2_drvdata_t *rga2_drvdata;
+struct rga2_service_info rga2_service;
+struct rga2_mmu_buf_t rga2_mmu_buf;
+
+static int rga2_blit_async(rga2_session *session, struct rga2_req *req);
+static void rga2_del_running_list(void);
+static void rga2_del_running_list_timeout(void);
+static void rga2_try_set_reg(void);
+
+
+/* Logging */
+#define RGA_DEBUG 0
+#if RGA_DEBUG
+#define DBG(format, args...) printk(KERN_DEBUG "%s: " format, DRIVER_NAME, ## args)
+#define ERR(format, args...) printk(KERN_ERR "%s: " format, DRIVER_NAME, ## args)
+#define WARNING(format, args...) printk(KERN_WARN "%s: " format, DRIVER_NAME, ## args)
+#define INFO(format, args...) printk(KERN_INFO "%s: " format, DRIVER_NAME, ## args)
+#else
+#define DBG(format, args...)
+#define ERR(format, args...)
+#define WARNING(format, args...)
+#define INFO(format, args...)
+#endif
+
+#if RGA2_TEST_MSG
+static void print_info(struct rga2_req *req)
+{
+	printk("render_mode=%d bitblt_mode=%d rotate_mode=%.8x\n",
+	        req->render_mode, req->bitblt_mode, req->rotate_mode);
+	printk("src : y=%.lx uv=%.lx v=%.lx format=%d aw=%d ah=%d vw=%d vh=%d xoff=%d yoff=%d \n",
+	        req->src.yrgb_addr, req->src.uv_addr, req->src.v_addr, req->src.format,
+	        req->src.act_w, req->src.act_h, req->src.vir_w, req->src.vir_h,
+	        req->src.x_offset, req->src.y_offset);
+	printk("dst : y=%lx uv=%lx v=%lx format=%d aw=%d ah=%d vw=%d vh=%d xoff=%d yoff=%d \n",
+	        req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr, req->dst.format,
+	        req->dst.act_w, req->dst.act_h, req->dst.vir_w, req->dst.vir_h,
+	        req->dst.x_offset, req->dst.y_offset);
+	printk("mmu : src=%.2x src1=%.2x dst=%.2x els=%.2x\n",
+	        req->mmu_info.src0_mmu_flag, req->mmu_info.src1_mmu_flag,
+	        req->mmu_info.dst_mmu_flag,  req->mmu_info.els_mmu_flag);
+	printk("alpha : flag %.8x mode0=%.8x mode1=%.8x\n",
+	        req->alpha_rop_flag, req->alpha_mode_0, req->alpha_mode_1);
+}
+#endif
+
+static inline void rga2_write(u32 b, u32 r)
+{
+	*((volatile unsigned int *)(rga2_drvdata->rga_base + r)) = b;
+}
+
+static inline u32 rga2_read(u32 r)
+{
+	return *((volatile unsigned int *)(rga2_drvdata->rga_base + r));
+}
+
+static inline int rga2_init_version(void)
+{
+	struct rga2_drvdata_t *rga = rga2_drvdata;
+	u32 major_version, minor_version;
+	u32 reg_version;
+
+	if (!rga) {
+		pr_err("rga2_drvdata is null\n");
+		return -EINVAL;
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_get_sync(rga2_drvdata->dev);
+#endif
+
+	clk_prepare_enable(rga2_drvdata->aclk_rga2);
+	clk_prepare_enable(rga2_drvdata->hclk_rga2);
+
+	reg_version = rga2_read(0x028);
+
+	clk_disable_unprepare(rga2_drvdata->aclk_rga2);
+	clk_disable_unprepare(rga2_drvdata->hclk_rga2);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_put(rga2_drvdata->dev);
+#endif
+
+	major_version = (reg_version & RGA2_MAJOR_VERSION_MASK) >> 24;
+	minor_version = (reg_version & RGA2_MINOR_VERSION_MASK) >> 20;
+
+	/*
+	 * some old rga ip has no rga version register, so force set to 2.00
+	 */
+	if (!major_version && !minor_version)
+		major_version = 2;
+	sprintf(rga->version, "%d.%02d", major_version, minor_version);
+
+	return 0;
+}
+
+static void rga2_soft_reset(void)
+{
+	u32 i;
+	u32 reg;
+
+	rga2_write((1 << 3) | (1 << 4) | (1 << 6), RGA2_SYS_CTRL);
+
+	for(i = 0; i < RGA2_RESET_TIMEOUT; i++)
+	{
+		reg = rga2_read(RGA2_SYS_CTRL) & 1; //RGA_SYS_CTRL
+
+		if(reg == 0)
+			break;
+
+		udelay(1);
+	}
+
+	if(i == RGA2_RESET_TIMEOUT)
+		ERR("soft reset timeout.\n");
+}
+
+static void rga2_dump(void)
+{
+	int running;
+	struct rga2_reg *reg, *reg_tmp;
+	rga2_session *session, *session_tmp;
+
+	running = atomic_read(&rga2_service.total_running);
+	printk("rga total_running %d\n", running);
+	list_for_each_entry_safe(session, session_tmp, &rga2_service.session,
+		list_session)
+	{
+		printk("session pid %d:\n", session->pid);
+		running = atomic_read(&session->task_running);
+		printk("task_running %d\n", running);
+		list_for_each_entry_safe(reg, reg_tmp, &session->waiting, session_link)
+		{
+			printk("waiting register set 0x %.lu\n", (unsigned long)reg);
+		}
+		list_for_each_entry_safe(reg, reg_tmp, &session->running, session_link)
+		{
+			printk("running register set 0x %.lu\n", (unsigned long)reg);
+		}
+	}
+}
+
+static inline void rga2_queue_power_off_work(void)
+{
+	queue_delayed_work(system_wq, &rga2_drvdata->power_off_work,
+		RGA2_POWER_OFF_DELAY);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_power_on(void)
+{
+	static ktime_t last;
+	ktime_t now = ktime_get();
+
+	if (ktime_to_ns(ktime_sub(now, last)) > NSEC_PER_SEC) {
+		cancel_delayed_work_sync(&rga2_drvdata->power_off_work);
+		rga2_queue_power_off_work();
+		last = now;
+	}
+
+	if (rga2_service.enable)
+		return;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_get_sync(rga2_drvdata->dev);
+#endif
+
+	clk_prepare_enable(rga2_drvdata->rga2);
+	clk_prepare_enable(rga2_drvdata->aclk_rga2);
+	clk_prepare_enable(rga2_drvdata->hclk_rga2);
+	wake_lock(&rga2_drvdata->wake_lock);
+	rga2_service.enable = true;
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_power_off(void)
+{
+	int total_running;
+
+	if (!rga2_service.enable) {
+		return;
+	}
+
+	total_running = atomic_read(&rga2_service.total_running);
+	if (total_running) {
+		pr_err("power off when %d task running!!\n", total_running);
+		mdelay(50);
+		pr_err("delay 50 ms for running task\n");
+		rga2_dump();
+	}
+
+	clk_disable_unprepare(rga2_drvdata->rga2);
+	clk_disable_unprepare(rga2_drvdata->aclk_rga2);
+	clk_disable_unprepare(rga2_drvdata->hclk_rga2);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_put(rga2_drvdata->dev);
+#endif
+
+	wake_unlock(&rga2_drvdata->wake_lock);
+    first_RGA2_proc = 0;
+	rga2_service.enable = false;
+}
+
+static void rga2_power_off_work(struct work_struct *work)
+{
+	if (mutex_trylock(&rga2_service.lock)) {
+		rga2_power_off();
+		mutex_unlock(&rga2_service.lock);
+	} else {
+		/* Come back later if the device is busy... */
+		rga2_queue_power_off_work();
+	}
+}
+
+static int rga2_flush(rga2_session *session, unsigned long arg)
+{
+    int ret = 0;
+    int ret_timeout;
+
+    #if RGA2_TEST_FLUSH_TIME
+    ktime_t start;
+    ktime_t end;
+    start = ktime_get();
+    #endif
+
+    ret_timeout = wait_event_timeout(session->wait, atomic_read(&session->done), RGA2_TIMEOUT_DELAY);
+
+	if (unlikely(ret_timeout < 0)) {
+		//pr_err("flush pid %d wait task ret %d\n", session->pid, ret);
+        mutex_lock(&rga2_service.lock);
+        rga2_del_running_list();
+        mutex_unlock(&rga2_service.lock);
+        ret = ret_timeout;
+	} else if (0 == ret_timeout) {
+		//pr_err("flush pid %d wait %d task done timeout\n", session->pid, atomic_read(&session->task_running));
+        //printk("bus  = %.8x\n", rga_read(RGA_INT));
+        mutex_lock(&rga2_service.lock);
+        rga2_del_running_list_timeout();
+        rga2_try_set_reg();
+        mutex_unlock(&rga2_service.lock);
+		ret = -ETIMEDOUT;
+	}
+
+    #if RGA2_TEST_FLUSH_TIME
+    end = ktime_get();
+    end = ktime_sub(end, start);
+    printk("one flush wait time %d\n", (int)ktime_to_us(end));
+    #endif
+
+	return ret;
+}
+
+
+static int rga2_get_result(rga2_session *session, unsigned long arg)
+{
+	int ret = 0;
+	int num_done;
+
+	num_done = atomic_read(&session->num_done);
+	if (unlikely(copy_to_user((void __user *)arg, &num_done, sizeof(int)))) {
+	    printk("copy_to_user failed\n");
+	    ret =  -EFAULT;
+	}
+	return ret;
+}
+
+
+static int rga2_check_param(const struct rga2_req *req)
+{
+	if(!((req->render_mode == color_fill_mode)))
+	{
+	    if (unlikely((req->src.act_w <= 0) || (req->src.act_w > 8191) || (req->src.act_h <= 0) || (req->src.act_h > 8191)))
+	    {
+		printk("invalid source resolution act_w = %d, act_h = %d\n", req->src.act_w, req->src.act_h);
+		return -EINVAL;
+	    }
+	}
+
+	if(!((req->render_mode == color_fill_mode)))
+	{
+	    if (unlikely((req->src.vir_w <= 0) || (req->src.vir_w > 8191) || (req->src.vir_h <= 0) || (req->src.vir_h > 8191)))
+	    {
+		printk("invalid source resolution vir_w = %d, vir_h = %d\n", req->src.vir_w, req->src.vir_h);
+		return -EINVAL;
+	    }
+	}
+
+	//check dst width and height
+	if (unlikely((req->dst.act_w <= 0) || (req->dst.act_w > 4096) || (req->dst.act_h <= 0) || (req->dst.act_h > 4096)))
+	{
+	    printk("invalid destination resolution act_w = %d, act_h = %d\n", req->dst.act_w, req->dst.act_h);
+	    return -EINVAL;
+	}
+
+	if (unlikely((req->dst.vir_w <= 0) || (req->dst.vir_w > 4096) || (req->dst.vir_h <= 0) || (req->dst.vir_h > 4096)))
+	{
+	    printk("invalid destination resolution vir_w = %d, vir_h = %d\n", req->dst.vir_w, req->dst.vir_h);
+	    return -EINVAL;
+	}
+
+	//check src_vir_w
+	if(unlikely(req->src.vir_w < req->src.act_w)){
+	    printk("invalid src_vir_w act_w = %d, vir_w = %d\n", req->src.act_w, req->src.vir_w);
+	    return -EINVAL;
+	}
+
+	//check dst_vir_w
+	if(unlikely(req->dst.vir_w < req->dst.act_w)){
+	    if(req->rotate_mode != 1)
+	    {
+		printk("invalid dst_vir_w act_h = %d, vir_h = %d\n", req->dst.act_w, req->dst.vir_w);
+		return -EINVAL;
+	    }
+	}
+
+	return 0;
+}
+
+static void rga2_copy_reg(struct rga2_reg *reg, uint32_t offset)
+{
+    uint32_t i;
+    uint32_t *cmd_buf;
+    uint32_t *reg_p;
+
+    if(atomic_read(&reg->session->task_running) != 0)
+        printk(KERN_ERR "task_running is no zero\n");
+
+    atomic_add(1, &rga2_service.cmd_num);
+	atomic_add(1, &reg->session->task_running);
+
+    cmd_buf = (uint32_t *)rga2_service.cmd_buff + offset*32;
+    reg_p = (uint32_t *)reg->cmd_reg;
+
+    for(i=0; i<32; i++)
+        cmd_buf[i] = reg_p[i];
+}
+
+
+static struct rga2_reg * rga2_reg_init(rga2_session *session, struct rga2_req *req)
+{
+    int32_t ret;
+	struct rga2_reg *reg = kzalloc(sizeof(struct rga2_reg), GFP_KERNEL);
+	if (NULL == reg) {
+		pr_err("kmalloc fail in rga_reg_init\n");
+		return NULL;
+	}
+
+    reg->session = session;
+	INIT_LIST_HEAD(&reg->session_link);
+	INIT_LIST_HEAD(&reg->status_link);
+
+    reg->MMU_base = NULL;
+
+    if ((req->mmu_info.src0_mmu_flag & 1) || (req->mmu_info.src1_mmu_flag & 1)
+        || (req->mmu_info.dst_mmu_flag & 1) || (req->mmu_info.els_mmu_flag & 1))
+    {
+        ret = rga2_set_mmu_info(reg, req);
+        if(ret < 0) {
+            printk("%s, [%d] set mmu info error \n", __FUNCTION__, __LINE__);
+            kfree(reg);
+
+            return NULL;
+        }
+    }
+
+    if(RGA2_gen_reg_info((uint8_t *)reg->cmd_reg, req) == -1) {
+        printk("gen reg info error\n");
+        kfree(reg);
+
+        return NULL;
+    }
+
+	reg->sg_src0 = req->sg_src0;
+	reg->sg_dst = req->sg_dst;
+	reg->sg_src1 = req->sg_src1;
+	reg->attach_src0 = req->attach_src0;
+	reg->attach_dst = req->attach_dst;
+	reg->attach_src1 = req->attach_src1;
+
+    mutex_lock(&rga2_service.lock);
+	list_add_tail(&reg->status_link, &rga2_service.waiting);
+	list_add_tail(&reg->session_link, &session->waiting);
+	mutex_unlock(&rga2_service.lock);
+
+    return reg;
+}
+
+
+/* Caller must hold rga_service.lock */
+static void rga2_reg_deinit(struct rga2_reg *reg)
+{
+	list_del_init(&reg->session_link);
+	list_del_init(&reg->status_link);
+	kfree(reg);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_reg_from_wait_to_run(struct rga2_reg *reg)
+{
+	list_del_init(&reg->status_link);
+	list_add_tail(&reg->status_link, &rga2_service.running);
+
+	list_del_init(&reg->session_link);
+	list_add_tail(&reg->session_link, &reg->session->running);
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_service_session_clear(rga2_session *session)
+{
+	struct rga2_reg *reg, *n;
+
+	list_for_each_entry_safe(reg, n, &session->waiting, session_link)
+	{
+		rga2_reg_deinit(reg);
+	}
+
+	list_for_each_entry_safe(reg, n, &session->running, session_link)
+	{
+		rga2_reg_deinit(reg);
+	}
+}
+
+/* Caller must hold rga_service.lock */
+static void rga2_try_set_reg(void)
+{
+	struct rga2_reg *reg ;
+
+	if (list_empty(&rga2_service.running))
+	{
+		if (!list_empty(&rga2_service.waiting))
+		{
+			/* RGA is idle */
+			reg = list_entry(rga2_service.waiting.next, struct rga2_reg, status_link);
+
+			rga2_power_on();
+			udelay(1);
+
+			rga2_copy_reg(reg, 0);
+			rga2_reg_from_wait_to_run(reg);
+
+#ifdef CONFIG_ARM
+			dmac_flush_range(&rga2_service.cmd_buff[0], &rga2_service.cmd_buff[32]);
+			outer_flush_range(virt_to_phys(&rga2_service.cmd_buff[0]),virt_to_phys(&rga2_service.cmd_buff[32]));
+#elif defined(CONFIG_ARM64)
+			__dma_flush_range(&rga2_service.cmd_buff[0], &rga2_service.cmd_buff[32]);
+#endif
+
+			//rga2_soft_reset();
+
+			rga2_write(0x0, RGA2_SYS_CTRL);
+
+			/* CMD buff */
+			rga2_write(virt_to_phys(rga2_service.cmd_buff), RGA2_CMD_BASE);
+
+#if RGA2_TEST
+			if(rga2_flag) {
+				int32_t i, *p;
+				p = rga2_service.cmd_buff;
+				printk("CMD_REG\n");
+				for (i=0; i<8; i++)
+					printk("%.8x %.8x %.8x %.8x\n", p[0 + i*4], p[1+i*4], p[2 + i*4], p[3 + i*4]);
+			}
+#endif
+
+			/* master mode */
+			rga2_write((0x1<<1)|(0x1<<2)|(0x1<<5)|(0x1<<6), RGA2_SYS_CTRL);
+
+			/* All CMD finish int */
+			rga2_write(rga2_read(RGA2_INT)|(0x1<<10)|(0x1<<9)|(0x1<<8), RGA2_INT);
+
+#if RGA2_TEST_TIME
+			rga2_start = ktime_get();
+#endif
+
+			/* Start proc */
+			atomic_set(&reg->session->done, 0);
+			rga2_write(0x1, RGA2_CMD_CTRL);
+#if RGA2_TEST
+			if(rga2_flag)
+			{
+				uint32_t i;
+				printk("CMD_READ_BACK_REG\n");
+				for (i=0; i<8; i++)
+					printk("%.8x %.8x %.8x %.8x\n", rga2_read(0x100 + i*16 + 0),
+							rga2_read(0x100 + i*16 + 4), rga2_read(0x100 + i*16 + 8), rga2_read(0x100 + i*16 + 12));
+			}
+#endif
+		}
+	}
+}
+
+static int rga2_put_dma_buf(struct rga2_req *req, struct rga2_reg *reg)
+{
+	struct dma_buf_attachment *attach = NULL;
+	struct sg_table *sgt = NULL;
+	struct dma_buf *dma_buf = NULL;
+
+	if (!req && !reg)
+		return -EINVAL;
+
+	attach = (!reg) ? req->attach_src0 : reg->attach_src0;
+	sgt = (!reg) ? req->sg_src0 : reg->sg_src0;
+	if (attach && sgt)
+		dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+	if (attach) {
+		dma_buf = attach->dmabuf;
+		dma_buf_detach(dma_buf, attach);
+		dma_buf_put(dma_buf);
+	}
+
+	attach = (!reg) ? req->attach_dst : reg->attach_dst;
+	sgt = (!reg) ? req->sg_dst : reg->sg_dst;
+	if (attach && sgt)
+		dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+	if (attach) {
+		dma_buf = attach->dmabuf;
+		dma_buf_detach(dma_buf, attach);
+		dma_buf_put(dma_buf);
+	}
+
+	attach = (!reg) ? req->attach_src1 : reg->attach_src1;
+	sgt = (!reg) ? req->sg_src1 : reg->sg_src1;
+	if (attach && sgt)
+		dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+	if (attach) {
+		dma_buf = attach->dmabuf;
+		dma_buf_detach(dma_buf, attach);
+		dma_buf_put(dma_buf);
+	}
+
+	return 0;
+}
+
+static void rga2_del_running_list(void)
+{
+	struct rga2_mmu_buf_t *tbuf = &rga2_mmu_buf;
+	struct rga2_reg *reg;
+
+	while (!list_empty(&rga2_service.running)) {
+		reg = list_entry(rga2_service.running.next, struct rga2_reg,
+				 status_link);
+		if (reg->MMU_len && tbuf) {
+			if (tbuf->back + reg->MMU_len > 2 * tbuf->size)
+				tbuf->back = reg->MMU_len + tbuf->size;
+			else
+				tbuf->back += reg->MMU_len;
+		}
+
+		rga2_put_dma_buf(NULL, reg);
+
+		atomic_sub(1, &reg->session->task_running);
+		atomic_sub(1, &rga2_service.total_running);
+
+		if(list_empty(&reg->session->waiting))
+		{
+			atomic_set(&reg->session->done, 1);
+			wake_up(&reg->session->wait);
+		}
+
+		rga2_reg_deinit(reg);
+	}
+}
+
+static void rga2_del_running_list_timeout(void)
+{
+	struct rga2_mmu_buf_t *tbuf = &rga2_mmu_buf;
+	struct rga2_reg *reg;
+
+	while (!list_empty(&rga2_service.running)) {
+		reg = list_entry(rga2_service.running.next, struct rga2_reg,
+				 status_link);
+		kfree(reg->MMU_base);
+		if (reg->MMU_len && tbuf) {
+			if (tbuf->back + reg->MMU_len > 2 * tbuf->size)
+				tbuf->back = reg->MMU_len + tbuf->size;
+			else
+				tbuf->back += reg->MMU_len;
+		}
+
+		rga2_put_dma_buf(NULL, reg);
+
+		atomic_sub(1, &reg->session->task_running);
+		atomic_sub(1, &rga2_service.total_running);
+		rga2_soft_reset();
+		if (list_empty(&reg->session->waiting)) {
+			atomic_set(&reg->session->done, 1);
+			wake_up(&reg->session->wait);
+		}
+		rga2_reg_deinit(reg);
+	}
+	return;
+}
+
+static int rga2_get_img_info(rga_img_info_t *img,
+			     u8 mmu_flag,
+			     struct sg_table **psgt,
+			     struct dma_buf_attachment **pattach)
+{
+	struct dma_buf_attachment *attach = NULL;
+	struct device *rga_dev = NULL;
+	struct sg_table *sgt = NULL;
+	struct dma_buf *dma_buf = NULL;
+	u32 vir_w, vir_h;
+	int yrgb_addr = -1;
+	int ret = 0;
+
+	rga_dev = rga2_drvdata->dev;
+	yrgb_addr = (int)img->yrgb_addr;
+	vir_w = img->vir_w;
+	vir_h = img->vir_h;
+
+	if (yrgb_addr > 0) {
+		dma_buf = dma_buf_get(img->yrgb_addr);
+		if (IS_ERR(dma_buf)) {
+			ret = -EINVAL;
+			pr_err("dma_buf_get fail fd[%d]\n", yrgb_addr);
+			return ret;
+		}
+
+		attach = dma_buf_attach(dma_buf, rga_dev);
+		if (IS_ERR(attach)) {
+			dma_buf_put(dma_buf);
+			ret = -EINVAL;
+			pr_err("Failed to attach dma_buf\n");
+			return ret;
+		}
+
+		*pattach = attach;
+		sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+		if (IS_ERR(sgt)) {
+			ret = -EINVAL;
+			pr_err("Failed to map src attachment\n");
+			goto err_get_sg;
+		}
+		if (!mmu_flag) {
+			ret = -EINVAL;
+			pr_err("Fix it please enable iommu flag\n");
+			goto err_get_sg;
+		}
+
+		if (mmu_flag) {
+			*psgt = sgt;
+			img->yrgb_addr = img->uv_addr;
+			img->uv_addr = img->yrgb_addr + (vir_w * vir_h);
+			img->v_addr = img->uv_addr + (vir_w * vir_h) / 4;
+		}
+	} else {
+		img->yrgb_addr = img->uv_addr;
+		img->uv_addr = img->yrgb_addr + (vir_w * vir_h);
+		img->v_addr = img->uv_addr + (vir_w * vir_h) / 4;
+	}
+
+	return ret;
+
+err_get_sg:
+	if (sgt)
+		dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
+	if (attach) {
+		dma_buf = attach->dmabuf;
+		dma_buf_detach(dma_buf, attach);
+		*pattach = NULL;
+		dma_buf_put(dma_buf);
+	}
+	return ret;
+}
+
+static int rga2_get_dma_buf(struct rga2_req *req)
+{
+	struct dma_buf *dma_buf = NULL;
+	u8 mmu_flag = 0;
+	int ret = 0;
+
+	req->sg_src0 = NULL;
+	req->sg_src1 = NULL;
+	req->sg_dst = NULL;
+	req->sg_els = NULL;
+	req->attach_src0 = NULL;
+	req->attach_dst = NULL;
+	req->attach_src1 = NULL;
+	mmu_flag = req->mmu_info.src0_mmu_flag;
+	ret = rga2_get_img_info(&req->src, mmu_flag, &req->sg_src0,
+				&req->attach_src0);
+	if (ret) {
+		pr_err("src:rga2_get_img_info fail\n");
+		goto err_src;
+	}
+
+	mmu_flag = req->mmu_info.dst_mmu_flag;
+	ret = rga2_get_img_info(&req->dst, mmu_flag, &req->sg_dst,
+				&req->attach_dst);
+	if (ret) {
+		pr_err("dst:rga2_get_img_info fail\n");
+		goto err_dst;
+	}
+
+	mmu_flag = req->mmu_info.src1_mmu_flag;
+	ret = rga2_get_img_info(&req->src1, mmu_flag, &req->sg_src1,
+				&req->attach_src1);
+	if (ret) {
+		pr_err("src1:rga2_get_img_info fail\n");
+		goto err_src1;
+	}
+
+	return ret;
+
+err_src1:
+	if (req->sg_dst && req->attach_dst) {
+		dma_buf_unmap_attachment(req->attach_dst,
+					 req->sg_dst, DMA_BIDIRECTIONAL);
+		dma_buf = req->attach_dst->dmabuf;
+		dma_buf_detach(dma_buf, req->attach_dst);
+		dma_buf_put(dma_buf);
+	}
+err_dst:
+	if (req->sg_src0 && req->attach_src0) {
+		dma_buf_unmap_attachment(req->attach_src0,
+					 req->sg_src0, DMA_BIDIRECTIONAL);
+		dma_buf = req->attach_src0->dmabuf;
+		dma_buf_detach(dma_buf, req->attach_src0);
+		dma_buf_put(dma_buf);
+	}
+err_src:
+
+	return ret;
+}
+
+static int rga2_blit(rga2_session *session, struct rga2_req *req)
+{
+	int ret = -1;
+	int num = 0;
+	struct rga2_reg *reg;
+
+	if (rga2_get_dma_buf(req)) {
+		pr_err("RGA2 : DMA buf copy error\n");
+		return -EFAULT;
+	}
+
+	do {
+		/* check value if legal */
+		ret = rga2_check_param(req);
+		if(ret == -EINVAL) {
+			pr_err("req argument is inval\n");
+			goto err_put_dma_buf;
+		}
+
+		reg = rga2_reg_init(session, req);
+		if(reg == NULL) {
+			pr_err("init reg fail\n");
+			goto err_put_dma_buf;
+		}
+
+		num = 1;
+		mutex_lock(&rga2_service.lock);
+		atomic_add(num, &rga2_service.total_running);
+		rga2_try_set_reg();
+		mutex_unlock(&rga2_service.lock);
+
+		return 0;
+	}
+	while(0);
+
+err_put_dma_buf:
+	rga2_put_dma_buf(req, NULL);
+
+	return -EFAULT;
+}
+
+static int rga2_blit_async(rga2_session *session, struct rga2_req *req)
+{
+	int ret = -1;
+
+#if RGA2_TEST_MSG
+	if (1) {//req->src.format >= 0x10) {
+		print_info(req);
+		rga2_flag = 1;
+		printk("*** rga_blit_async proc ***\n");
+	}
+	else
+		rga2_flag = 0;
+#endif
+	atomic_set(&session->done, 0);
+	ret = rga2_blit(session, req);
+
+	return ret;
+	}
+
+static int rga2_blit_sync(rga2_session *session, struct rga2_req *req)
+{
+	struct rga2_req req_bak;
+	int restore = 0;
+	int try = 10;
+	int ret = -1;
+	int ret_timeout = 0;
+
+	memcpy(&req_bak, req, sizeof(req_bak));
+retry:
+
+#if RGA2_TEST_MSG
+	if (1) {//req->bitblt_mode == 0x2) {
+		print_info(req);
+		rga2_flag = 1;
+		printk("*** rga2_blit_sync proc ***\n");
+	}
+	else
+		rga2_flag = 0;
+#endif
+
+	atomic_set(&session->done, 0);
+
+	ret = rga2_blit(session, req);
+	if(ret < 0)
+		return ret;
+
+	ret_timeout = wait_event_timeout(session->wait, atomic_read(&session->done), RGA2_TIMEOUT_DELAY);
+
+	if (unlikely(ret_timeout< 0))
+	{
+		//pr_err("sync pid %d wait task ret %d\n", session->pid, ret_timeout);
+		mutex_lock(&rga2_service.lock);
+		rga2_del_running_list();
+		mutex_unlock(&rga2_service.lock);
+		ret = ret_timeout;
+	}
+	else if (0 == ret_timeout)
+	{
+		//pr_err("sync pid %d wait %d task done timeout\n", session->pid, atomic_read(&session->task_running));
+		mutex_lock(&rga2_service.lock);
+		rga2_del_running_list_timeout();
+		rga2_try_set_reg();
+		mutex_unlock(&rga2_service.lock);
+		ret = -ETIMEDOUT;
+	}
+
+#if RGA2_TEST_TIME
+	rga2_end = ktime_get();
+	rga2_end = ktime_sub(rga2_end, rga2_start);
+	printk("sync one cmd end time %d\n", (int)ktime_to_us(rga2_end));
+#endif
+	if (ret == -ETIMEDOUT && try--) {
+		memcpy(req, &req_bak, sizeof(req_bak));
+		/*
+		 * if rga work timeout with scaling, need do a non-scale work
+		 * first, restore hardware status, then do actually work.
+		 */
+		if (req->src.act_w != req->dst.act_w ||
+		    req->src.act_h != req->dst.act_h) {
+			req->src.act_w = MIN(320, MIN(req->src.act_w,
+						      req->dst.act_w));
+			req->src.act_h = MIN(240, MIN(req->src.act_h,
+						      req->dst.act_h));
+			req->dst.act_w = req->src.act_w;
+			req->dst.act_h = req->src.act_h;
+			restore = 1;
+		}
+		goto retry;
+	}
+	if (!ret && restore) {
+		memcpy(req, &req_bak, sizeof(req_bak));
+		restore = 0;
+		goto retry;
+	}
+
+	return ret;
+}
+
+static long rga_ioctl(struct file *file, uint32_t cmd, unsigned long arg)
+{
+	struct rga2_drvdata_t *rga = rga2_drvdata;
+	struct rga2_req req, req_first;
+	struct rga_req req_rga;
+	int ret = 0;
+	rga2_session *session;
+
+	if (!rga) {
+		pr_err("rga2_drvdata is null, rga2 is not init\n");
+		return -ENODEV;
+	}
+	memset(&req, 0x0, sizeof(req));
+
+	mutex_lock(&rga2_service.mutex);
+
+	session = (rga2_session *)file->private_data;
+
+	if (NULL == session)
+	{
+		printk("%s [%d] rga thread session is null\n",__FUNCTION__,__LINE__);
+		mutex_unlock(&rga2_service.mutex);
+		return -EINVAL;
+	}
+
+	memset(&req, 0x0, sizeof(req));
+
+	switch (cmd)
+	{
+		case RGA_BLIT_SYNC:
+			if (unlikely(copy_from_user(&req_rga, (struct rga_req*)arg, sizeof(struct rga_req))))
+			{
+				ERR("copy_from_user failed\n");
+				ret = -EFAULT;
+				break;
+			}
+			RGA_MSG_2_RGA2_MSG(&req_rga, &req);
+
+			if (first_RGA2_proc == 0 && req.bitblt_mode == bitblt_mode && rga2_service.dev_mode == 1) {
+				memcpy(&req_first, &req, sizeof(struct rga2_req));
+				if ((req_first.src.act_w != req_first.dst.act_w)
+						|| (req_first.src.act_h != req_first.dst.act_h)) {
+					req_first.src.act_w = MIN(320, MIN(req_first.src.act_w, req_first.dst.act_w));
+					req_first.src.act_h = MIN(240, MIN(req_first.src.act_h, req_first.dst.act_h));
+					req_first.dst.act_w = req_first.src.act_w;
+					req_first.dst.act_h = req_first.src.act_h;
+					ret = rga2_blit_async(session, &req_first);
+				}
+				ret = rga2_blit_sync(session, &req);
+				first_RGA2_proc = 1;
+			}
+			else {
+				ret = rga2_blit_sync(session, &req);
+			}
+			break;
+		case RGA_BLIT_ASYNC:
+			if (unlikely(copy_from_user(&req_rga, (struct rga_req*)arg, sizeof(struct rga_req))))
+			{
+				ERR("copy_from_user failed\n");
+				ret = -EFAULT;
+				break;
+			}
+
+			RGA_MSG_2_RGA2_MSG(&req_rga, &req);
+
+			if (first_RGA2_proc == 0 && req.bitblt_mode == bitblt_mode && rga2_service.dev_mode == 1) {
+				memcpy(&req_first, &req, sizeof(struct rga2_req));
+				if ((req_first.src.act_w != req_first.dst.act_w)
+						|| (req_first.src.act_h != req_first.dst.act_h)) {
+					req_first.src.act_w = MIN(320, MIN(req_first.src.act_w, req_first.dst.act_w));
+					req_first.src.act_h = MIN(240, MIN(req_first.src.act_h, req_first.dst.act_h));
+					req_first.dst.act_w = req_first.src.act_w;
+					req_first.dst.act_h = req_first.src.act_h;
+					ret = rga2_blit_async(session, &req_first);
+				}
+				ret = rga2_blit_async(session, &req);
+				first_RGA2_proc = 1;
+			}
+			else {
+				ret = rga2_blit_async(session, &req);
+			}
+			break;
+		case RGA2_BLIT_SYNC:
+			if (unlikely(copy_from_user(&req, (struct rga2_req*)arg, sizeof(struct rga2_req))))
+			{
+				ERR("copy_from_user failed\n");
+				ret = -EFAULT;
+				break;
+			}
+			ret = rga2_blit_sync(session, &req);
+			break;
+		case RGA2_BLIT_ASYNC:
+			if (unlikely(copy_from_user(&req, (struct rga2_req*)arg, sizeof(struct rga2_req))))
+			{
+				ERR("copy_from_user failed\n");
+				ret = -EFAULT;
+				break;
+			}
+
+			if((atomic_read(&rga2_service.total_running) > 16))
+			{
+				ret = rga2_blit_sync(session, &req);
+			}
+			else
+			{
+				ret = rga2_blit_async(session, &req);
+			}
+			break;
+		case RGA_FLUSH:
+		case RGA2_FLUSH:
+			ret = rga2_flush(session, arg);
+			break;
+		case RGA_GET_RESULT:
+		case RGA2_GET_RESULT:
+			ret = rga2_get_result(session, arg);
+			break;
+		case RGA_GET_VERSION:
+		case RGA2_GET_VERSION:
+			ret = copy_to_user((void *)arg, rga->version, 16);
+			break;
+		default:
+			ERR("unknown ioctl cmd!\n");
+			ret = -EINVAL;
+			break;
+	}
+
+	mutex_unlock(&rga2_service.mutex);
+
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long compat_rga_ioctl(struct file *file, uint32_t cmd, unsigned long arg)
+{
+	struct rga2_drvdata_t *rga = rga2_drvdata;
+	struct rga2_req req, req_first;
+	struct rga_req_32 req_rga;
+	int ret = 0;
+	rga2_session *session;
+
+	if (!rga) {
+		pr_err("rga2_drvdata is null, rga2 is not init\n");
+		return -ENODEV;
+	}
+	memset(&req, 0x0, sizeof(req));
+
+	mutex_lock(&rga2_service.mutex);
+
+	session = (rga2_session *)file->private_data;
+
+#if RGA2_TEST_MSG
+	printk("use compat_rga_ioctl\n");
+#endif
+
+	if (NULL == session) {
+		printk("%s [%d] rga thread session is null\n",__FUNCTION__,__LINE__);
+		mutex_unlock(&rga2_service.mutex);
+		return -EINVAL;
+	}
+
+	memset(&req, 0x0, sizeof(req));
+
+	switch (cmd) {
+		case RGA_BLIT_SYNC:
+			if (unlikely(copy_from_user(&req_rga, compat_ptr((compat_uptr_t)arg), sizeof(struct rga_req_32))))
+			{
+				ERR("copy_from_user failed\n");
+				ret = -EFAULT;
+				break;
+			}
+
+			RGA_MSG_2_RGA2_MSG_32(&req_rga, &req);
+
+			if (first_RGA2_proc == 0 && req.bitblt_mode == bitblt_mode && rga2_service.dev_mode == 1) {
+				memcpy(&req_first, &req, sizeof(struct rga2_req));
+				if ((req_first.src.act_w != req_first.dst.act_w)
+						|| (req_first.src.act_h != req_first.dst.act_h)) {
+					req_first.src.act_w = MIN(320, MIN(req_first.src.act_w, req_first.dst.act_w));
+					req_first.src.act_h = MIN(240, MIN(req_first.src.act_h, req_first.dst.act_h));
+					req_first.dst.act_w = req_first.src.act_w;
+					req_first.dst.act_h = req_first.src.act_h;
+					ret = rga2_blit_async(session, &req_first);
+				}
+				ret = rga2_blit_sync(session, &req);
+				first_RGA2_proc = 1;
+			}
+			else {
+				ret = rga2_blit_sync(session, &req);
+			}
+			break;
+		case RGA_BLIT_ASYNC:
+			if (unlikely(copy_from_user(&req_rga, compat_ptr((compat_uptr_t)arg), sizeof(struct rga_req_32))))
+			{
+				ERR("copy_from_user failed\n");
+				ret = -EFAULT;
+				break;
+			}
+			RGA_MSG_2_RGA2_MSG_32(&req_rga, &req);
+
+			if (first_RGA2_proc == 0 && req.bitblt_mode == bitblt_mode && rga2_service.dev_mode == 1) {
+				memcpy(&req_first, &req, sizeof(struct rga2_req));
+				if ((req_first.src.act_w != req_first.dst.act_w)
+						|| (req_first.src.act_h != req_first.dst.act_h)) {
+					req_first.src.act_w = MIN(320, MIN(req_first.src.act_w, req_first.dst.act_w));
+					req_first.src.act_h = MIN(240, MIN(req_first.src.act_h, req_first.dst.act_h));
+					req_first.dst.act_w = req_first.src.act_w;
+					req_first.dst.act_h = req_first.src.act_h;
+					ret = rga2_blit_async(session, &req_first);
+				}
+				ret = rga2_blit_sync(session, &req);
+				first_RGA2_proc = 1;
+			}
+			else {
+				ret = rga2_blit_sync(session, &req);
+			}
+
+			//if((atomic_read(&rga2_service.total_running) > 8))
+			//    ret = rga2_blit_sync(session, &req);
+			//else
+			//    ret = rga2_blit_async(session, &req);
+
+			break;
+		case RGA2_BLIT_SYNC:
+			if (unlikely(copy_from_user(&req, compat_ptr((compat_uptr_t)arg), sizeof(struct rga2_req))))
+			{
+				ERR("copy_from_user failed\n");
+				ret = -EFAULT;
+				break;
+			}
+			ret = rga2_blit_sync(session, &req);
+			break;
+		case RGA2_BLIT_ASYNC:
+			if (unlikely(copy_from_user(&req, compat_ptr((compat_uptr_t)arg), sizeof(struct rga2_req))))
+			{
+				ERR("copy_from_user failed\n");
+				ret = -EFAULT;
+				break;
+			}
+
+			if((atomic_read(&rga2_service.total_running) > 16))
+				ret = rga2_blit_sync(session, &req);
+			else
+				ret = rga2_blit_async(session, &req);
+
+			break;
+		case RGA_FLUSH:
+		case RGA2_FLUSH:
+			ret = rga2_flush(session, arg);
+			break;
+		case RGA_GET_RESULT:
+		case RGA2_GET_RESULT:
+			ret = rga2_get_result(session, arg);
+			break;
+		case RGA_GET_VERSION:
+		case RGA2_GET_VERSION:
+			ret = copy_to_user((void *)arg, rga->version, 16);
+			break;
+		default:
+			ERR("unknown ioctl cmd!\n");
+			ret = -EINVAL;
+			break;
+	}
+
+	mutex_unlock(&rga2_service.mutex);
+
+	return ret;
+}
+#endif
+
+
+static long rga2_ioctl_kernel(struct rga_req *req_rga)
+{
+	int ret = 0;
+	rga2_session *session;
+	struct rga2_req req;
+
+	memset(&req, 0x0, sizeof(req));
+	mutex_lock(&rga2_service.mutex);
+	session = &rga2_session_global;
+	if (NULL == session)
+	{
+		printk("%s [%d] rga thread session is null\n",__FUNCTION__,__LINE__);
+		mutex_unlock(&rga2_service.mutex);
+		return -EINVAL;
+	}
+
+	RGA_MSG_2_RGA2_MSG(req_rga, &req);
+	ret = rga2_blit_sync(session, &req);
+	mutex_unlock(&rga2_service.mutex);
+
+	return ret;
+}
+
+
+static int rga2_open(struct inode *inode, struct file *file)
+{
+	rga2_session *session = kzalloc(sizeof(rga2_session), GFP_KERNEL);
+
+	if (NULL == session) {
+		pr_err("unable to allocate memory for rga_session.");
+		return -ENOMEM;
+	}
+
+	session->pid = current->pid;
+	INIT_LIST_HEAD(&session->waiting);
+	INIT_LIST_HEAD(&session->running);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	mutex_lock(&rga2_service.lock);
+	list_add_tail(&session->list_session, &rga2_service.session);
+	mutex_unlock(&rga2_service.lock);
+	atomic_set(&session->task_running, 0);
+	atomic_set(&session->num_done, 0);
+	file->private_data = (void *)session;
+
+	return nonseekable_open(inode, file);
+}
+
+static int rga2_release(struct inode *inode, struct file *file)
+{
+	int task_running;
+	rga2_session *session = (rga2_session *)file->private_data;
+
+	if (NULL == session)
+		return -EINVAL;
+
+	task_running = atomic_read(&session->task_running);
+	if (task_running)
+	{
+		pr_err("rga2_service session %d still has %d task running when closing\n", session->pid, task_running);
+		msleep(100);
+	}
+
+	wake_up(&session->wait);
+	mutex_lock(&rga2_service.lock);
+	list_del(&session->list_session);
+	rga2_service_session_clear(session);
+	kfree(session);
+	mutex_unlock(&rga2_service.lock);
+
+	return 0;
+}
+
+static irqreturn_t rga2_irq_thread(int irq, void *dev_id)
+{
+	mutex_lock(&rga2_service.lock);
+	if (rga2_service.enable) {
+		rga2_del_running_list();
+		rga2_try_set_reg();
+	}
+	mutex_unlock(&rga2_service.lock);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t rga2_irq(int irq,  void *dev_id)
+{
+	/*clear INT */
+	rga2_write(rga2_read(RGA2_INT) | (0x1<<4) | (0x1<<5) | (0x1<<6) | (0x1<<7), RGA2_INT);
+
+	return IRQ_WAKE_THREAD;
+}
+
+struct file_operations rga2_fops = {
+	.owner		= THIS_MODULE,
+	.open		= rga2_open,
+	.release	= rga2_release,
+	.unlocked_ioctl		= rga_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl		= compat_rga_ioctl,
+#endif
+};
+
+static struct miscdevice rga2_dev ={
+	.minor = RGA2_MAJOR,
+	.name  = "rga",
+	.fops  = &rga2_fops,
+};
+
+static const struct of_device_id rockchip_rga_dt_ids[] = {
+	{ .compatible = "rockchip,rga2", },
+	{},
+};
+
+static int rga2_drv_probe(struct platform_device *pdev)
+{
+	struct rga2_drvdata_t *data;
+	struct resource *res;
+	int ret = 0;
+	struct device_node *np = pdev->dev.of_node;
+
+	mutex_init(&rga2_service.lock);
+	mutex_init(&rga2_service.mutex);
+	atomic_set(&rga2_service.total_running, 0);
+	atomic_set(&rga2_service.src_format_swt, 0);
+	rga2_service.last_prc_src_format = 1; /* default is yuv first*/
+	rga2_service.enable = false;
+
+	rga2_ioctl_kernel_p = rga2_ioctl_kernel;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(struct rga2_drvdata_t), GFP_KERNEL);
+	if(NULL == data)
+	{
+		ERR("failed to allocate driver data.\n");
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&data->power_off_work, rga2_power_off_work);
+	wake_lock_init(&data->wake_lock, WAKE_LOCK_SUSPEND, "rga");
+
+	data->rga2 = devm_clk_get(&pdev->dev, "clk_rga");
+	data->aclk_rga2 = devm_clk_get(&pdev->dev, "aclk_rga");
+	data->hclk_rga2 = devm_clk_get(&pdev->dev, "hclk_rga");
+
+	/* map the registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->rga_base = devm_ioremap_resource(&pdev->dev, res);
+	if (!data->rga_base) {
+		ERR("rga ioremap failed\n");
+		ret = -ENOENT;
+		goto err_ioremap;
+	}
+
+	/* get the IRQ */
+	data->irq = platform_get_irq(pdev, 0);
+	if (data->irq <= 0) {
+		ERR("failed to get rga irq resource (%d).\n", data->irq);
+		ret = data->irq;
+		goto err_irq;
+	}
+
+	/* request the IRQ */
+	ret = devm_request_threaded_irq(&pdev->dev, data->irq, rga2_irq, rga2_irq_thread, 0, "rga", pdev);
+	if (ret)
+	{
+		ERR("rga request_irq failed (%d).\n", ret);
+		goto err_irq;
+	}
+
+	platform_set_drvdata(pdev, data);
+	data->dev = &pdev->dev;
+	rga2_drvdata = data;
+	of_property_read_u32(np, "dev_mode", &rga2_service.dev_mode);
+
+#if defined(CONFIG_ION_ROCKCHIP)
+	data->ion_client = rockchip_ion_client_create("rga");
+	if (IS_ERR(data->ion_client)) {
+		dev_err(&pdev->dev, "failed to create ion client for rga");
+		return PTR_ERR(data->ion_client);
+	} else {
+		dev_info(&pdev->dev, "rga ion client create success!\n");
+	}
+#endif
+
+	ret = misc_register(&rga2_dev);
+	if(ret)
+	{
+		ERR("cannot register miscdev (%d)\n", ret);
+		goto err_misc_register;
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_enable(&pdev->dev);
+#endif
+	rga2_init_version();
+	pr_info("Driver loaded successfully ver:%s\n", rga2_drvdata->version);
+
+	return 0;
+
+err_misc_register:
+	free_irq(data->irq, pdev);
+err_irq:
+	iounmap(data->rga_base);
+err_ioremap:
+	wake_lock_destroy(&data->wake_lock);
+	//kfree(data);
+
+	return ret;
+}
+
+static int rga2_drv_remove(struct platform_device *pdev)
+{
+	struct rga2_drvdata_t *data = platform_get_drvdata(pdev);
+	DBG("%s [%d]\n",__FUNCTION__,__LINE__);
+
+	wake_lock_destroy(&data->wake_lock);
+	misc_deregister(&(data->miscdev));
+	free_irq(data->irq, &data->miscdev);
+	iounmap((void __iomem *)(data->rga_base));
+
+	devm_clk_put(&pdev->dev, data->rga2);
+	devm_clk_put(&pdev->dev, data->aclk_rga2);
+	devm_clk_put(&pdev->dev, data->hclk_rga2);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_disable(&pdev->dev);
+#endif
+
+	//kfree(data);
+	return 0;
+}
+
+static struct platform_driver rga2_driver = {
+	.probe		= rga2_drv_probe,
+	.remove		= rga2_drv_remove,
+	.driver		= {
+		.name	= "rga2",
+		.of_match_table = of_match_ptr(rockchip_rga_dt_ids),
+	},
+};
+
+
+void rga2_test_0(void);
+
+static int __init rga2_init(void)
+{
+	int ret;
+	uint32_t *buf_p;
+	uint32_t *buf;
+
+	/* malloc pre scale mid buf mmu table */
+	buf_p = kmalloc(1024*256, GFP_KERNEL);
+	rga2_mmu_buf.buf_virtual = buf_p;
+#if (defined(CONFIG_ARM) && defined(CONFIG_ARM_LPAE))
+	buf = (uint32_t *)(uint32_t)virt_to_phys((void *)((unsigned long)buf_p));
+#else
+	buf = (uint32_t *)virt_to_phys((void *)((unsigned long)buf_p));
+#endif
+	rga2_mmu_buf.buf = buf;
+	rga2_mmu_buf.front = 0;
+	rga2_mmu_buf.back = 64*1024;
+	rga2_mmu_buf.size = 64*1024;
+
+	rga2_mmu_buf.pages = kmalloc(32768 * sizeof(struct page *), GFP_KERNEL);
+
+	ret = platform_driver_register(&rga2_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+	rga2_session_global.pid = 0x0000ffff;
+	INIT_LIST_HEAD(&rga2_session_global.waiting);
+	INIT_LIST_HEAD(&rga2_session_global.running);
+	INIT_LIST_HEAD(&rga2_session_global.list_session);
+
+	INIT_LIST_HEAD(&rga2_service.waiting);
+	INIT_LIST_HEAD(&rga2_service.running);
+	INIT_LIST_HEAD(&rga2_service.done);
+	INIT_LIST_HEAD(&rga2_service.session);
+	init_waitqueue_head(&rga2_session_global.wait);
+	//mutex_lock(&rga_service.lock);
+	list_add_tail(&rga2_session_global.list_session, &rga2_service.session);
+	//mutex_unlock(&rga_service.lock);
+	atomic_set(&rga2_session_global.task_running, 0);
+	atomic_set(&rga2_session_global.num_done, 0);
+
+#if RGA2_TEST_CASE
+	rga2_test_0();
+#endif
+
+	INFO("Module initialized.\n");
+
+	return 0;
+}
+
+static void __exit rga2_exit(void)
+{
+	rga2_power_off();
+
+	kfree(rga2_mmu_buf.buf_virtual);
+
+	platform_driver_unregister(&rga2_driver);
+}
+
+
+#if RGA2_TEST_CASE
+
+void rga2_test_0(void)
+{
+	struct rga2_req req;
+	rga2_session session;
+	unsigned int *src, *dst;
+
+	session.pid	= current->pid;
+	INIT_LIST_HEAD(&session.waiting);
+	INIT_LIST_HEAD(&session.running);
+	INIT_LIST_HEAD(&session.list_session);
+	init_waitqueue_head(&session.wait);
+	/* no need to protect */
+	list_add_tail(&session.list_session, &rga2_service.session);
+	atomic_set(&session.task_running, 0);
+	atomic_set(&session.num_done, 0);
+
+	memset(&req, 0, sizeof(struct rga2_req));
+	src = kmalloc(800*480*4, GFP_KERNEL);
+	dst = kmalloc(800*480*4, GFP_KERNEL);
+
+	printk("\n********************************\n");
+	printk("************ RGA2_TEST ************\n");
+	printk("********************************\n\n");
+
+#if 1
+	memset(src, 0x80, 800 * 480 * 4);
+	memset(dst, 0xcc, 800 * 480 * 4);
+#endif
+#if 0
+	dmac_flush_range(src, &src[800 * 480]);
+	outer_flush_range(virt_to_phys(src), virt_to_phys(&src[800 * 480]));
+
+	dmac_flush_range(dst, &dst[800 * 480]);
+	outer_flush_range(virt_to_phys(dst), virt_to_phys(&dst[800 * 480]));
+#endif
+
+#if 0
+	req.pat.act_w = 16;
+	req.pat.act_h = 16;
+	req.pat.vir_w = 16;
+	req.pat.vir_h = 16;
+	req.pat.yrgb_addr = virt_to_phys(src);
+	req.render_mode = 0;
+	rga2_blit_sync(&session, &req);
+#endif
+	{
+		uint32_t i, j;
+		uint8_t *sp;
+
+		sp = (uint8_t *)src;
+		for (j = 0; j < 240; j++) {
+			sp = (uint8_t *)src + j * 320 * 10 / 8;
+			for (i = 0; i < 320; i++) {
+				if ((i & 3) == 0) {
+					sp[i * 5 / 4] = 0;
+					sp[i * 5 / 4+1] = 0x1;
+				} else if ((i & 3) == 1) {
+					sp[i * 5 / 4+1] = 0x4;
+				} else if ((i & 3) == 2) {
+					sp[i * 5 / 4+1] = 0x10;
+				} else if ((i & 3) == 3) {
+					sp[i * 5 / 4+1] = 0x40;
+			    }
+			}
+		}
+		sp = (uint8_t *)src;
+		for (j = 0; j < 100; j++)
+			printk("src %.2x\n", sp[j]);
+	}
+	req.src.act_w = 320;
+	req.src.act_h = 240;
+
+	req.src.vir_w = 320;
+	req.src.vir_h = 240;
+	req.src.yrgb_addr = 0;//(uint32_t)virt_to_phys(src);
+	req.src.uv_addr = (unsigned long)virt_to_phys(src);
+	req.src.v_addr = 0;
+	req.src.format = RGA2_FORMAT_YCbCr_420_SP_10B;
+
+	req.dst.act_w  = 320;
+	req.dst.act_h = 240;
+	req.dst.x_offset = 0;
+	req.dst.y_offset = 0;
+
+	req.dst.vir_w = 320;
+	req.dst.vir_h = 240;
+
+	req.dst.yrgb_addr = 0;//((uint32_t)virt_to_phys(dst));
+	req.dst.uv_addr = (unsigned long)virt_to_phys(dst);
+	req.dst.format = RGA2_FORMAT_YCbCr_420_SP;
+
+	//dst = dst0;
+
+	//req.render_mode = color_fill_mode;
+	//req.fg_color = 0x80ffffff;
+
+	req.rotate_mode = 0;
+	req.scale_bicu_mode = 2;
+
+#if 0
+	//req.alpha_rop_flag = 0;
+	//req.alpha_rop_mode = 0x19;
+	//req.PD_mode = 3;
+
+	//req.mmu_info.mmu_flag = 0x21;
+	//req.mmu_info.mmu_en = 1;
+
+	//printk("src = %.8x\n", req.src.yrgb_addr);
+	//printk("src = %.8x\n", req.src.uv_addr);
+	//printk("dst = %.8x\n", req.dst.yrgb_addr);
+#endif
+
+	rga2_blit_sync(&session, &req);
+
+#if 0
+	uint32_t j;
+	for (j = 0; j < 320 * 240 * 10 / 8; j++) {
+        if (src[j] != dst[j])
+		printk("error value dst not equal src j %d, s %.2x d %.2x\n",
+			j, src[j], dst[j]);
+	}
+#endif
+
+#if 1
+	{
+		uint32_t j;
+		uint8_t *dp = (uint8_t *)dst;
+
+		for (j = 0; j < 100; j++)
+			printk("%d %.2x\n", j, dp[j]);
+	}
+#endif
+
+	kfree(src);
+	kfree(dst);
+}
+#endif
+
+late_initcall(rga2_init);
+module_exit(rga2_exit);
+
+/* Module information */
+MODULE_AUTHOR("zsq@rock-chips.com");
+MODULE_DESCRIPTION("Driver for rga device");
+MODULE_LICENSE("GPL");
diff -Nupr a/drivers/video/rockchip/rga2/rga2.h b/drivers/video/rockchip/rga2/rga2.h
--- a/drivers/video/rockchip/rga2/rga2.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/rga2.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,722 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RGA_DRIVER_H_
+#define _RGA_DRIVER_H_
+
+#include <linux/mutex.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-buf.h>
+
+
+#define RGA_BLIT_SYNC	0x5017
+#define RGA_BLIT_ASYNC  0x5018
+#define RGA_FLUSH       0x5019
+#define RGA_GET_RESULT  0x501a
+#define RGA_GET_VERSION 0x501b
+
+#define RGA2_BLIT_SYNC	 0x6017
+#define RGA2_BLIT_ASYNC  0x6018
+#define RGA2_FLUSH       0x6019
+#define RGA2_GET_RESULT  0x601a
+#define RGA2_GET_VERSION 0x601b
+
+
+#define RGA2_REG_CTRL_LEN    0x8    /* 8  */
+#define RGA2_REG_CMD_LEN     0x20   /* 32 */
+#define RGA2_CMD_BUF_SIZE    0x700  /* 16*28*4 */
+
+#define RGA2_OUT_OF_RESOURCES    -10
+#define RGA2_MALLOC_ERROR        -11
+
+#define SCALE_DOWN_LARGE 1
+
+#define rgaIS_ERROR(status)			(status < 0)
+#define rgaNO_ERROR(status)			(status >= 0)
+#define rgaIS_SUCCESS(status)		(status == 0)
+
+#define RGA_BUF_GEM_TYPE_MASK      0xC0
+#define RGA_BUF_GEM_TYPE_DMA       0x80
+#define RGA2_MAJOR_VERSION_MASK     (0xFF000000)
+#define RGA2_MINOR_VERSION_MASK     (0x00F00000)
+
+/* RGA2 process mode enum */
+enum
+{
+    bitblt_mode               = 0x0,
+    color_palette_mode        = 0x1,
+    color_fill_mode           = 0x2,
+    update_palette_table_mode = 0x3,
+    update_patten_buff_mode   = 0x4,
+};  /*render mode*/
+
+enum
+{
+    A_B_B =0x0,
+    A_B_C =0x1,
+};  //bitblt_mode select
+
+enum
+{
+    rop_enable_mask          = 0x2,
+    dither_enable_mask       = 0x8,
+    fading_enable_mask       = 0x10,
+    PD_enbale_mask           = 0x20,
+};
+
+
+
+/*
+//          Alpha    Red     Green   Blue
+{  4, 32, {{32,24,   8, 0,  16, 8,  24,16 }}, GGL_RGBA },   // RK_FORMAT_RGBA_8888
+{  4, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGBX_8888
+{  3, 24, {{ 0, 0,   8, 0,  16, 8,  24,16 }}, GGL_RGB  },   // RK_FORMAT_RGB_888
+{  4, 32, {{32,24,  24,16,  16, 8,   8, 0 }}, GGL_BGRA },   // RK_FORMAT_BGRA_8888
+{  2, 16, {{ 0, 0,  16,11,  11, 5,   5, 0 }}, GGL_RGB  },   // RK_FORMAT_RGB_565
+{  2, 16, {{ 1, 0,  16,11,  11, 6,   6, 1 }}, GGL_RGBA },   // RK_FORMAT_RGBA_5551
+{  2, 16, {{ 4, 0,  16,12,  12, 8,   8, 4 }}, GGL_RGBA },   // RK_FORMAT_RGBA_4444
+{  2, 16, {{ 0, 0,   5, 0   11, 5,   16,11}}, GGL_BGR  },   // RK_FORMAT_BGR_565
+{  2, 16, {{ 1, 0,   6, 1,  11, 6,   16,11}}, GGL_BGRA },   // RK_FORMAT_BGRA_5551
+{  2, 16, {{ 4, 0,   8, 4,  12, 8,   16,12}}, GGL_BGRA },   // RK_FORMAT_BGRA_4444
+
+*/
+enum
+{
+	RGA2_FORMAT_RGBA_8888    = 0x0,
+    RGA2_FORMAT_RGBX_8888    = 0x1,
+    RGA2_FORMAT_RGB_888      = 0x2,
+    RGA2_FORMAT_BGRA_8888    = 0x3,
+    RGA2_FORMAT_BGRX_8888    = 0x4,
+    RGA2_FORMAT_BGR_888      = 0x5,
+    RGA2_FORMAT_RGB_565      = 0x6,
+    RGA2_FORMAT_RGBA_5551    = 0x7,
+    RGA2_FORMAT_RGBA_4444    = 0x8,
+    RGA2_FORMAT_BGR_565      = 0x9,
+    RGA2_FORMAT_BGRA_5551    = 0xa,
+    RGA2_FORMAT_BGRA_4444    = 0xb,
+
+    RGA2_FORMAT_YCbCr_422_SP = 0x10,
+    RGA2_FORMAT_YCbCr_422_P  = 0x11,
+    RGA2_FORMAT_YCbCr_420_SP = 0x12,
+    RGA2_FORMAT_YCbCr_420_P  = 0x13,
+    RGA2_FORMAT_YCrCb_422_SP = 0x14,
+    RGA2_FORMAT_YCrCb_422_P  = 0x15,
+    RGA2_FORMAT_YCrCb_420_SP = 0x16,
+    RGA2_FORMAT_YCrCb_420_P  = 0x17,
+    RGA2_FORMAT_YCbCr_420_SP_10B = 0x20,
+    RGA2_FORMAT_YCrCb_420_SP_10B = 0x21,
+    RGA2_FORMAT_YCbCr_422_SP_10B = 0x22,
+    RGA2_FORMAT_YCrCb_422_SP_10B = 0x23,
+};
+
+typedef struct mdp_img
+{
+    u16 width;
+    u16 height;
+    u32 format;
+    u32 mem_addr;
+}
+mdp_img;
+
+typedef struct mdp_img_act
+{
+    u16 width;     // width
+    u16 height;    // height
+    s16 x_off;     // x offset for the vir
+    s16 y_off;     // y offset for the vir
+    s16 uv_x_off;
+    s16 uv_y_off;
+}
+mdp_img_act;
+
+typedef struct mdp_img_vir
+{
+    u16 width;
+    u16 height;
+    u32 format;
+    u32 mem_addr;
+    u32 uv_addr;
+    u32 v_addr;
+}
+mdp_img_vir;
+
+
+typedef struct MMU_INFO
+{
+    unsigned long src0_base_addr;
+    unsigned long src1_base_addr;
+    unsigned long dst_base_addr;
+    unsigned long els_base_addr;
+
+    u8 src0_mmu_flag;     /* [0] src0 mmu enable [1] src0_flush [2] src0_prefetch_en [3] src0_prefetch dir */
+    u8 src1_mmu_flag;     /* [0] src1 mmu enable [1] src1_flush [2] src1_prefetch_en [3] src1_prefetch dir */
+    u8 dst_mmu_flag;      /* [0] dst  mmu enable [1] dst_flush  [2] dst_prefetch_en  [3] dst_prefetch dir  */
+    u8 els_mmu_flag;      /* [0] els  mmu enable [1] els_flush  [2] els_prefetch_en  [3] els_prefetch dir  */
+} MMU_INFO;
+
+
+enum
+{
+	MMU_DIS = 0x0,
+	MMU_EN  = 0x1
+};
+enum
+{
+	MMU_FLUSH_DIS = 0x0,
+	MMU_FLUSH_EN  = 0x2
+};
+enum
+{
+	MMU_PRE_DIS = 0x0,
+	MMU_PRE_EN  = 0x4
+};
+enum
+{
+	MMU_PRE_DIR_FORW  = 0x0,
+	MMU_PRE_DIR_BACK  = 0x8
+};
+typedef struct COLOR_FILL
+{
+    s16 gr_x_a;
+    s16 gr_y_a;
+    s16 gr_x_b;
+    s16 gr_y_b;
+    s16 gr_x_g;
+    s16 gr_y_g;
+    s16 gr_x_r;
+    s16 gr_y_r;
+}
+COLOR_FILL;
+
+enum
+{
+	ALPHA_ORIGINAL = 0x0,
+	ALPHA_NO_128   = 0x1
+};
+
+enum
+{
+	R2_BLACK       = 0x00,
+	R2_COPYPEN     = 0xf0,
+	R2_MASKNOTPEN  = 0x0a,
+	R2_MASKPEN     = 0xa0,
+	R2_MASKPENNOT  = 0x50,
+	R2_MERGENOTPEN = 0xaf,
+	R2_MERGEPEN    = 0xfa,
+	R2_MERGEPENNOT = 0xf5,
+	R2_NOP         = 0xaa,
+	R2_NOT         = 0x55,
+	R2_NOTCOPYPEN  = 0x0f,
+	R2_NOTMASKPEN  = 0x5f,
+	R2_NOTMERGEPEN = 0x05,
+	R2_NOTXORPEN   = 0xa5,
+	R2_WHITE       = 0xff,
+	R2_XORPEN      = 0x5a
+};
+
+
+/***************************************/
+/* porting from rga.h for msg convert  */
+/***************************************/
+
+typedef struct FADING
+{
+    uint8_t b;
+    uint8_t g;
+    uint8_t r;
+    uint8_t res;
+}
+FADING;
+
+typedef struct MMU
+{
+    unsigned char mmu_en;
+    unsigned long base_addr;
+    uint32_t mmu_flag;     /* [0] mmu enable [1] src_flush [2] dst_flush [3] CMD_flush [4~5] page size*/
+} MMU;
+
+typedef struct MMU_32
+{
+    unsigned char mmu_en;
+    uint32_t base_addr;
+    uint32_t mmu_flag;     /* [0] mmu enable [1] src_flush [2] dst_flush [3] CMD_flush [4~5] page size*/
+} MMU_32;
+
+typedef struct RECT
+{
+    unsigned short xmin;
+    unsigned short xmax; // width - 1
+    unsigned short ymin;
+    unsigned short ymax; // height - 1
+} RECT;
+
+typedef struct POINT
+{
+    unsigned short x;
+    unsigned short y;
+}
+POINT;
+
+typedef struct line_draw_t
+{
+    POINT start_point;              /* LineDraw_start_point                */
+    POINT end_point;                /* LineDraw_end_point                  */
+    uint32_t   color;               /* LineDraw_color                      */
+    uint32_t   flag;                /* (enum) LineDrawing mode sel         */
+    uint32_t   line_width;          /* range 1~16 */
+}
+line_draw_t;
+
+typedef struct rga_img_info_t
+{
+    unsigned long yrgb_addr;      /* yrgb    mem addr         */
+    unsigned long uv_addr;        /* cb/cr   mem addr         */
+    unsigned long v_addr;         /* cr      mem addr         */
+    unsigned int format;         //definition by RK_FORMAT
+
+    unsigned short act_w;
+    unsigned short act_h;
+    unsigned short x_offset;
+    unsigned short y_offset;
+
+    unsigned short vir_w;
+    unsigned short vir_h;
+
+    unsigned short endian_mode; //for BPP
+    unsigned short alpha_swap;
+}
+rga_img_info_t;
+
+typedef struct rga_img_info_32_t
+{
+    uint32_t yrgb_addr;      /* yrgb    mem addr         */
+    uint32_t uv_addr;        /* cb/cr   mem addr         */
+    uint32_t v_addr;         /* cr      mem addr         */
+    unsigned int format;         //definition by RK_FORMAT
+    unsigned short act_w;
+    unsigned short act_h;
+    unsigned short x_offset;
+    unsigned short y_offset;
+    unsigned short vir_w;
+    unsigned short vir_h;
+    unsigned short endian_mode; //for BPP
+    unsigned short alpha_swap;
+}
+rga_img_info_32_t;
+
+struct rga_req {
+    uint8_t render_mode;            /* (enum) process mode sel */
+
+    rga_img_info_t src;             /* src image info */
+    rga_img_info_t dst;             /* dst image info */
+    rga_img_info_t pat;             /* patten image info */
+
+    unsigned long rop_mask_addr;         /* rop4 mask addr */
+    unsigned long LUT_addr;              /* LUT addr */
+
+    RECT clip;                      /* dst clip window default value is dst_vir */
+                                    /* value from [0, w-1] / [0, h-1]*/
+
+    int32_t sina;                   /* dst angle  default value 0  16.16 scan from table */
+    int32_t cosa;                   /* dst angle  default value 0  16.16 scan from table */
+
+    uint16_t alpha_rop_flag;        /* alpha rop process flag           */
+                                    /* ([0] = 1 alpha_rop_enable)       */
+                                    /* ([1] = 1 rop enable)             */
+                                    /* ([2] = 1 fading_enable)          */
+                                    /* ([3] = 1 PD_enable)              */
+                                    /* ([4] = 1 alpha cal_mode_sel)     */
+                                    /* ([5] = 1 dither_enable)          */
+                                    /* ([6] = 1 gradient fill mode sel) */
+                                    /* ([7] = 1 AA_enable)              */
+
+    uint8_t  scale_mode;            /* 0 nearst / 1 bilnear / 2 bicubic */
+
+    uint32_t color_key_max;         /* color key max */
+    uint32_t color_key_min;         /* color key min */
+
+    uint32_t fg_color;              /* foreground color */
+    uint32_t bg_color;              /* background color */
+
+    COLOR_FILL gr_color;            /* color fill use gradient */
+
+    line_draw_t line_draw_info;
+
+    FADING fading;
+
+    uint8_t PD_mode;                /* porter duff alpha mode sel */
+
+    uint8_t alpha_global_value;     /* global alpha value */
+
+    uint16_t rop_code;              /* rop2/3/4 code  scan from rop code table*/
+
+    uint8_t bsfilter_flag;          /* [2] 0 blur 1 sharp / [1:0] filter_type*/
+
+    uint8_t palette_mode;           /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+
+    uint8_t yuv2rgb_mode;           /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+
+    uint8_t endian_mode;            /* 0/big endian 1/little endian*/
+
+    uint8_t rotate_mode;            /* (enum) rotate mode  */
+                                    /* 0x0,     no rotate  */
+                                    /* 0x1,     rotate     */
+                                    /* 0x2,     x_mirror   */
+                                    /* 0x3,     y_mirror   */
+
+    uint8_t color_fill_mode;        /* 0 solid color / 1 patten color */
+
+    MMU mmu_info;                   /* mmu information */
+
+    uint8_t  alpha_rop_mode;        /* ([0~1] alpha mode)            */
+                                    /* ([2~3] rop   mode)            */
+                                    /* ([4]   zero  mode en)         */
+                                    /* ([5]   dst   alpha mode)      */
+                                    /* ([6]   alpha output mode sel) 0 src / 1 dst*/
+
+    uint8_t  src_trans_mode;
+};
+struct rga_req_32
+{
+    uint8_t render_mode;            /* (enum) process mode sel */
+    rga_img_info_32_t src;             /* src image info */
+    rga_img_info_32_t dst;             /* dst image info */
+    rga_img_info_32_t pat;             /* patten image info */
+    uint32_t rop_mask_addr;         /* rop4 mask addr */
+    uint32_t LUT_addr;              /* LUT addr */
+    RECT clip;                      /* dst clip window default value is dst_vir */
+                                    /* value from [0, w-1] / [0, h-1]*/
+    int32_t sina;                   /* dst angle  default value 0  16.16 scan from table */
+    int32_t cosa;                   /* dst angle  default value 0  16.16 scan from table */
+    uint16_t alpha_rop_flag;        /* alpha rop process flag           */
+                                    /* ([0] = 1 alpha_rop_enable)       */
+                                    /* ([1] = 1 rop enable)             */
+                                    /* ([2] = 1 fading_enable)          */
+                                    /* ([3] = 1 PD_enable)              */
+                                    /* ([4] = 1 alpha cal_mode_sel)     */
+                                    /* ([5] = 1 dither_enable)          */
+                                    /* ([6] = 1 gradient fill mode sel) */
+                                    /* ([7] = 1 AA_enable)              */
+    uint8_t  scale_mode;            /* 0 nearst / 1 bilnear / 2 bicubic */
+    uint32_t color_key_max;         /* color key max */
+    uint32_t color_key_min;         /* color key min */
+    uint32_t fg_color;              /* foreground color */
+    uint32_t bg_color;              /* background color */
+    COLOR_FILL gr_color;            /* color fill use gradient */
+    line_draw_t line_draw_info;
+    FADING fading;
+    uint8_t PD_mode;                /* porter duff alpha mode sel */
+    uint8_t alpha_global_value;     /* global alpha value */
+    uint16_t rop_code;              /* rop2/3/4 code  scan from rop code table*/
+    uint8_t bsfilter_flag;          /* [2] 0 blur 1 sharp / [1:0] filter_type*/
+    uint8_t palette_mode;           /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+    uint8_t yuv2rgb_mode;           /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+    uint8_t endian_mode;            /* 0/big endian 1/little endian*/
+    uint8_t rotate_mode;            /* (enum) rotate mode  */
+                                    /* 0x0,     no rotate  */
+                                    /* 0x1,     rotate     */
+                                    /* 0x2,     x_mirror   */
+                                    /* 0x3,     y_mirror   */
+    uint8_t color_fill_mode;        /* 0 solid color / 1 patten color */
+    MMU_32 mmu_info;                   /* mmu information */
+    uint8_t  alpha_rop_mode;        /* ([0~1] alpha mode)            */
+                                    /* ([2~3] rop   mode)            */
+                                    /* ([4]   zero  mode en)         */
+                                    /* ([5]   dst   alpha mode)      */
+                                    /* ([6]   alpha output mode sel) 0 src / 1 dst*/
+    uint8_t  src_trans_mode;
+};
+
+
+
+struct rga2_req
+{
+    u8 render_mode;          /* (enum) process mode sel */
+
+    rga_img_info_t src;    // src  active window
+    rga_img_info_t src1;   // src1 active window
+    rga_img_info_t dst;    // dst  active window
+    rga_img_info_t pat;    // patten active window
+
+    unsigned long rop_mask_addr;       // rop4 mask addr
+    unsigned long LUT_addr;            // LUT addr
+
+    u32 rop_mask_stride;
+
+    u8 bitblt_mode;          /* 0: SRC + DST  => DST     */
+                             /* 1: SRC + SRC1 => DST     */
+
+    u8 rotate_mode;          /* [1:0]                           */
+                             /* 0   degree 0x0                  */
+                             /* 90  degree 0x1                  */
+                             /* 180 degree 0x2                  */
+                             /* 270 degree 0x3                  */
+                             /* [5:4]                           */
+                             /* none                0x0         */
+                             /* x_mirror            0x1         */
+                             /* y_mirror            0x2         */
+                             /* x_mirror + y_mirror 0x3         */
+
+    u16 alpha_rop_flag;         /* alpha rop process flag           */
+                                /* ([0] = 1 alpha_rop_enable)       */
+                                /* ([1] = 1 rop enable)             */
+                                /* ([2] = 1 fading_enable)          */
+                                /* ([3] = 1 alpha cal_mode_sel)     */
+                                /* ([4] = 1 src_dither_up_enable)   */
+                                /* ([5] = 1 dst_dither_up_enable)   */
+                                /* ([6] = 1 dither_down_enable)     */
+                                /* ([7] = 1 gradient fill mode sel) */
+
+
+    u16 alpha_mode_0;           /* [0]     SrcAlphaMode0          */
+                                /* [2:1]   SrcGlobalAlphaMode0    */
+                                /* [3]     SrcAlphaSelectMode0    */
+                                /* [6:4]   SrcFactorMode0         */
+                                /* [7]     SrcColorMode           */
+
+                                /* [8]     DstAlphaMode0          */
+                                /* [10:9]  DstGlobalAlphaMode0    */
+                                /* [11]    DstAlphaSelectMode0    */
+                                /* [14:12] DstFactorMode0         */
+                                /* [15]    DstColorMode0          */
+
+    u16 alpha_mode_1;           /* [0]     SrcAlphaMode1          */
+                                /* [2:1]   SrcGlobalAlphaMode1    */
+                                /* [3]     SrcAlphaSelectMode1    */
+                                /* [6:4]   SrcFactorMode1         */
+
+                                /* [8]     DstAlphaMode1          */
+                                /* [10:9]  DstGlobalAlphaMode1    */
+                                /* [11]    DstAlphaSelectMode1    */
+                                /* [14:12] DstFactorMode1         */
+
+    u8  scale_bicu_mode;    /* 0   1   2  3 */
+
+    u32 color_key_max;      /* color key max */
+    u32 color_key_min;      /* color key min */
+
+    u32 fg_color;           /* foreground color */
+    u32 bg_color;           /* background color */
+
+    u8 color_fill_mode;
+    COLOR_FILL gr_color;    /* color fill use gradient */
+
+    u8 fading_alpha_value;  /* Fading value */
+    u8 fading_r_value;
+    u8 fading_g_value;
+    u8 fading_b_value;
+
+    u8 src_a_global_val;    /* src global alpha value        */
+    u8 dst_a_global_val;    /* dst global alpha value        */
+
+
+    u8  rop_mode;
+    u16 rop_code;           /* rop2/3/4 code */
+
+    u8 palette_mode;        /* (enum) color palatte  0/1bpp, 1/2bpp 2/4bpp 3/8bpp*/
+
+    u8 yuv2rgb_mode;        /* (enum) BT.601 MPEG / BT.601 JPEG / BT.709  */
+
+    u8 endian_mode;         /* 0/little endian 1/big endian */
+
+    u8 CMD_fin_int_enable;
+
+    MMU_INFO mmu_info;               /* mmu infomation */
+
+    u8 alpha_zero_key;
+    u8 src_trans_mode;
+
+    u8 alpha_swp;
+    u8 dither_mode;
+
+    u8 rgb2yuv_mode;
+
+	u8 buf_type;
+	struct sg_table *sg_src0;
+	struct sg_table *sg_src1;
+	struct sg_table *sg_dst;
+	struct sg_table *sg_els;
+	struct dma_buf_attachment *attach_src0;
+	struct dma_buf_attachment *attach_src1;
+	struct dma_buf_attachment *attach_dst;
+};
+
+struct rga2_mmu_buf_t {
+    int32_t front;
+    int32_t back;
+    int32_t size;
+    int32_t curr;
+    unsigned int *buf;
+    unsigned int *buf_virtual;
+
+    struct page **pages;
+};
+
+enum
+{
+    BB_ROTATE_OFF   = 0x0,     /* no rotate  */
+    BB_ROTATE_90    = 0x1,     /* rotate 90  */
+    BB_ROTATE_180   = 0x2,     /* rotate 180 */
+    BB_ROTATE_270   = 0x3,     /* rotate 270 */
+};  /*rotate mode*/
+
+enum
+{
+    BB_MIRROR_OFF   = (0x0 << 4),     /* no mirror  */
+    BB_MIRROR_X     = (0x1 << 4),     /* x  mirror  */
+    BB_MIRROR_Y     = (0x2 << 4),     /* y  mirror  */
+    BB_MIRROR_XY    = (0x3 << 4),     /* xy mirror  */
+};  /*mirror mode*/
+
+enum
+{
+    BB_COPY_USE_TILE = (0x1 << 6),    /* bitblt mode copy but use Tile mode */
+};
+
+enum
+{
+	//BYPASS        = 0x0,
+    BT_601_RANGE0   = 0x1,
+    BT_601_RANGE1   = 0x2,
+    BT_709_RANGE0   = 0x3,
+}; /*yuv2rgb_mode*/
+
+enum
+{
+    BPP1        = 0x0,     /* BPP1 */
+    BPP2        = 0x1,     /* BPP2 */
+    BPP4        = 0x2,     /* BPP4 */
+    BPP8        = 0x3      /* BPP8 */
+}; /*palette_mode*/
+
+enum
+{
+	SOLID_COLOR   = 0x0, //color fill mode; ROP4: SOLID_rop4_mask_addr COLOR
+	PATTERN_COLOR = 0x1  //pattern_fill_mode;ROP4:PATTERN_COLOR
+};  /*color fill mode*/
+
+enum
+{
+	COLOR_FILL_CLIP     = 0x0,
+	COLOR_FILL_NOT_CLIP = 0x1
+};
+
+enum
+{
+    CATROM    = 0x0,
+    MITCHELL  = 0x1,
+    HERMITE   = 0x2,
+    B_SPLINE  = 0x3,
+};  /*bicubic coefficient*/
+
+enum
+{
+	ROP2 = 0x0,
+	ROP3 = 0x1,
+	ROP4 = 0x2
+};  /*ROP mode*/
+
+enum
+{
+	BIG_ENDIAN    = 0x0,
+	LITTLE_ENDIAN = 0x1
+};  /*endian mode*/
+
+enum
+{
+	MMU_TABLE_4KB  = 0x0,
+	MMU_TABLE_64KB = 0x1,
+};  /*MMU table size*/
+
+enum
+{
+    RGB_2_666 = 0x0,
+    RGB_2_565 = 0x1,
+    RGB_2_555 = 0x2,
+    RGB_2_444 = 0x3,
+};  /*dither down mode*/
+
+
+
+/**
+ * struct for process session which connect to rga
+ *
+ * @author ZhangShengqin (2012-2-15)
+ */
+typedef struct rga2_session {
+	/* a linked list of data so we can access them for debugging */
+	struct list_head    list_session;
+	/* a linked list of register data waiting for process */
+	struct list_head    waiting;
+	/* a linked list of register data in processing */
+	struct list_head    running;
+	/* all coommand this thread done */
+    atomic_t            done;
+	wait_queue_head_t   wait;
+	pid_t           pid;
+	atomic_t        task_running;
+    atomic_t        num_done;
+} rga2_session;
+
+struct rga2_reg {
+	rga2_session		*session;
+	struct list_head	session_link;
+	struct list_head	status_link;
+	uint32_t  sys_reg[8];
+	uint32_t  cmd_reg[32];
+
+	uint32_t *MMU_base;
+	uint32_t MMU_len;
+
+	struct sg_table *sg_src0;
+	struct sg_table *sg_src1;
+	struct sg_table *sg_dst;
+
+	struct dma_buf_attachment *attach_src0;
+	struct dma_buf_attachment *attach_src1;
+	struct dma_buf_attachment *attach_dst;
+};
+
+struct rga2_service_info {
+    struct mutex	lock;
+    struct timer_list	timer;			/* timer for power off */
+    struct list_head	waiting;		/* link to link_reg in struct vpu_reg */
+    struct list_head	running;		/* link to link_reg in struct vpu_reg */
+    struct list_head	done;			/* link to link_reg in struct vpu_reg */
+    struct list_head	session;		/* link to list_session in struct vpu_session */
+    atomic_t		total_running;
+
+    struct rga2_reg        *reg;
+
+    uint32_t            cmd_buff[32*8];/* cmd_buff for rga */
+    uint32_t            *pre_scale_buf;
+    atomic_t            int_disable;     /* 0 int enable 1 int disable  */
+    atomic_t            cmd_num;
+    atomic_t            src_format_swt;
+    int                 last_prc_src_format;
+    atomic_t            rga_working;
+    bool                enable;
+    uint32_t            dev_mode;
+
+    //struct rga_req      req[10];
+
+    struct mutex	mutex;	// mutex
+};
+
+#define RGA2_TEST_CASE 0
+#define RGA2_TEST      0
+#define RGA2_TEST_MSG  0
+#define RGA2_TEST_TIME 0
+
+//General Registers
+#define RGA2_SYS_CTRL             0x000
+#define RGA2_CMD_CTRL             0x004
+#define RGA2_CMD_BASE             0x008
+#define RGA2_STATUS               0x00c
+#define RGA2_INT                  0x010
+#define RGA2_MMU_CTRL0            0x018
+#define RGA2_MMU_CMD_BASE         0x01c
+
+//Command code start
+#define RGA2_MODE_CTRL            0x100
+#define RGA_BLIT_COMPLETE_EVENT 1
+
+#endif /*_RK29_IPP_DRIVER_H_*/
diff -Nupr a/drivers/video/rockchip/rga2/rga2_mmu_info.c b/drivers/video/rockchip/rga2/rga2_mmu_info.c
--- a/drivers/video/rockchip/rga2/rga2_mmu_info.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/rga2_mmu_info.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,918 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/pagemap.h>
+#include <linux/seq_file.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/memory.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <asm/memory.h>
+#include <asm/atomic.h>
+#include <asm/cacheflush.h>
+#include "rga2_mmu_info.h"
+
+extern struct rga2_service_info rga2_service;
+extern struct rga2_mmu_buf_t rga2_mmu_buf;
+
+//extern int mmu_buff_temp[1024];
+
+#define KERNEL_SPACE_VALID    0xc0000000
+
+#define V7_VATOPA_SUCESS_MASK	(0x1)
+#define V7_VATOPA_GET_PADDR(X)	(X & 0xFFFFF000)
+#define V7_VATOPA_GET_INER(X)		((X>>4) & 7)
+#define V7_VATOPA_GET_OUTER(X)		((X>>2) & 3)
+#define V7_VATOPA_GET_SH(X)		((X>>7) & 1)
+#define V7_VATOPA_GET_NS(X)		((X>>9) & 1)
+#define V7_VATOPA_GET_SS(X)		((X>>1) & 1)
+
+static void rga_dma_flush_range(void *pstart, void *pend)
+{
+#ifdef CONFIG_ARM
+	dmac_flush_range(pstart, pend);
+	outer_flush_range(virt_to_phys(pstart), virt_to_phys(pend));
+#elif defined(CONFIG_ARM64)
+	__dma_flush_range(pstart, pend);
+#endif
+}
+
+static void rga_dma_flush_page(struct page *page)
+{
+	phys_addr_t paddr;
+	void *virt;
+
+	paddr = page_to_phys(page);
+#ifdef CONFIG_ARM
+	if (PageHighMem(page)) {
+		if (cache_is_vipt_nonaliasing()) {
+			virt = kmap_atomic(page);
+			dmac_flush_range(virt, virt + PAGE_SIZE);
+			kunmap_atomic(virt);
+		} else {
+			virt = kmap_high_get(page);
+			dmac_flush_range(virt, virt + PAGE_SIZE);
+			kunmap_high(page);
+		}
+	} else {
+		virt = page_address(page);
+		dmac_flush_range(virt, virt + PAGE_SIZE);
+	}
+
+	outer_flush_range(paddr, paddr + PAGE_SIZE);
+#elif defined(CONFIG_ARM64)
+	virt = page_address(page);
+	__dma_flush_range(virt, virt + PAGE_SIZE);
+#endif
+}
+
+#if 0
+static unsigned int armv7_va_to_pa(unsigned int v_addr)
+{
+	unsigned int p_addr;
+	__asm__ volatile (	"mcr p15, 0, %1, c7, c8, 0\n"
+						"isb\n"
+						"dsb\n"
+						"mrc p15, 0, %0, c7, c4, 0\n"
+						: "=r" (p_addr)
+						: "r" (v_addr)
+						: "cc");
+
+	if (p_addr & V7_VATOPA_SUCESS_MASK)
+		return 0xFFFFFFFF;
+	else
+		return (V7_VATOPA_GET_SS(p_addr) ? 0xFFFFFFFF : V7_VATOPA_GET_PADDR(p_addr));
+}
+#endif
+
+static int rga2_mmu_buf_get(struct rga2_mmu_buf_t *t, uint32_t size)
+{
+    mutex_lock(&rga2_service.lock);
+    t->front += size;
+    mutex_unlock(&rga2_service.lock);
+
+    return 0;
+}
+
+static int rga2_mmu_buf_get_try(struct rga2_mmu_buf_t *t, uint32_t size)
+{
+	int ret = 0;
+
+	mutex_lock(&rga2_service.lock);
+	if ((t->back - t->front) > t->size) {
+		if (t->front + size > t->back - t->size) {
+			pr_info("front %d, back %d dsize %d size %d",
+				t->front, t->back, t->size, size);
+			ret = -ENOMEM;
+			goto out;
+		}
+	} else {
+		if ((t->front + size) > t->back) {
+			pr_info("front %d, back %d dsize %d size %d",
+				t->front, t->back, t->size, size);
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		if (t->front + size > t->size) {
+			if (size > (t->back - t->size)) {
+				pr_info("front %d, back %d dsize %d size %d",
+					t->front, t->back, t->size, size);
+				ret = -ENOMEM;
+				goto out;
+			}
+			t->front = 0;
+		}
+	}
+out:
+	mutex_unlock(&rga2_service.lock);
+	return ret;
+}
+
+static int rga2_mem_size_cal(unsigned long Mem, uint32_t MemSize, unsigned long *StartAddr)
+{
+    unsigned long start, end;
+    uint32_t pageCount;
+
+    end = (Mem + (MemSize + PAGE_SIZE - 1)) >> PAGE_SHIFT;
+    start = Mem >> PAGE_SHIFT;
+    pageCount = end - start;
+    *StartAddr = start;
+    return pageCount;
+}
+
+static int rga2_buf_size_cal(unsigned long yrgb_addr, unsigned long uv_addr, unsigned long v_addr,
+                                        int format, uint32_t w, uint32_t h, unsigned long *StartAddr )
+{
+    uint32_t size_yrgb = 0;
+    uint32_t size_uv = 0;
+    uint32_t size_v = 0;
+    uint32_t stride = 0;
+    unsigned long start, end;
+    uint32_t pageCount;
+
+    switch(format)
+    {
+        case RGA2_FORMAT_RGBA_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBX_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGB_888 :
+            stride = (w * 3 + 3) & (~3);
+            size_yrgb = stride*h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_BGRA_8888 :
+            stride = (w * 4 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGB_565 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBA_5551 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_RGBA_4444 :
+            stride = (w*2 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+        case RGA2_FORMAT_BGR_888 :
+            stride = (w*3 + 3) & (~3);
+            size_yrgb = stride * h;
+            start = yrgb_addr >> PAGE_SHIFT;
+            pageCount = (size_yrgb + PAGE_SIZE - 1) >> PAGE_SHIFT;
+            break;
+
+        /* YUV FORMAT */
+        case RGA2_FORMAT_YCbCr_422_SP :
+        case RGA2_FORMAT_YCrCb_422_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = stride * h;
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_422_P :
+        case RGA2_FORMAT_YCrCb_422_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * h);
+            size_v = ((stride >> 1) * h);
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start = start >> PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_420_SP :
+        case RGA2_FORMAT_YCrCb_420_SP :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = (stride * (h >> 1));
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        case RGA2_FORMAT_YCbCr_420_P :
+        case RGA2_FORMAT_YCrCb_420_P :
+            stride = (w + 3) & (~3);
+            size_yrgb = stride * h;
+            size_uv = ((stride >> 1) * (h >> 1));
+            size_v = ((stride >> 1) * (h >> 1));
+            start = MIN(MIN(yrgb_addr, uv_addr), v_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX(MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv)), (v_addr + size_v));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        #if 0
+        case RK_FORMAT_BPP1 :
+            break;
+        case RK_FORMAT_BPP2 :
+            break;
+        case RK_FORMAT_BPP4 :
+            break;
+        case RK_FORMAT_BPP8 :
+            break;
+        #endif
+        case RGA2_FORMAT_YCbCr_420_SP_10B:
+        case RGA2_FORMAT_YCrCb_420_SP_10B:
+            stride = (w + 3) & (~3);
+            stride = stride;
+            size_yrgb = stride * h;
+            size_uv = (stride * (h >> 1));
+            start = MIN(yrgb_addr, uv_addr);
+            start >>= PAGE_SHIFT;
+            end = MAX((yrgb_addr + size_yrgb), (uv_addr + size_uv));
+            end = (end + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+            pageCount = end - start;
+            break;
+        default :
+            pageCount = 0;
+            start = 0;
+            break;
+    }
+
+    *StartAddr = start;
+    return pageCount;
+}
+
+static int rga2_MapUserMemory(struct page **pages, uint32_t *pageTable,
+			      unsigned long Memory, uint32_t pageCount,
+			      int writeFlag)
+{
+	struct vm_area_struct *vma;
+	int32_t result;
+	uint32_t i;
+	uint32_t status;
+	unsigned long Address;
+	unsigned long pfn;
+	struct page __maybe_unused *page;
+	spinlock_t * ptl;
+	pte_t * pte;
+	pgd_t * pgd;
+	pud_t * pud;
+	pmd_t * pmd;
+
+	status = 0;
+	Address = 0;
+	down_read(&current->mm->mmap_sem);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
+	result = get_user_pages(current, current->mm, Memory << PAGE_SHIFT,
+				pageCount, writeFlag, 0, pages, NULL);
+#else
+	result = get_user_pages_remote(current, current->mm,
+				       Memory << PAGE_SHIFT,
+				       pageCount, writeFlag, 0, pages, NULL);
+#endif
+	if (result > 0 && result >= pageCount) {
+		/* Fill the page table. */
+		for (i = 0; i < pageCount; i++) {
+			/* Get the physical address from page struct. */
+			pageTable[i] = page_to_phys(pages[i]);
+			/* ensure dst not flush null cache */
+			if (writeFlag && i >= pageCount - 2)
+				break;
+			rga_dma_flush_page(pages[i]);
+		}
+		for (i = 0; i < result; i++)
+			put_page(pages[i]);
+		up_read(&current->mm->mmap_sem);
+		return 0;
+	}
+	if (result > 0) {
+		for (i = 0; i < result; i++)
+			put_page(pages[i]);
+	}
+	for (i = 0; i < pageCount; i++) {
+		vma = find_vma(current->mm, (Memory + i) << PAGE_SHIFT);
+		if (!vma) {
+			status = RGA2_OUT_OF_RESOURCES;
+			break;
+		}
+		pgd = pgd_offset(current->mm, (Memory + i) << PAGE_SHIFT);
+		if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd))) {
+			pr_err("RGA2 failed to get pgd\n");
+			status = RGA2_OUT_OF_RESOURCES;
+			break;
+		}
+		pud = pud_offset(pgd, (Memory + i) << PAGE_SHIFT);
+		if (pud_none(*pud) || unlikely(pud_bad(*pud))) {
+			pr_err("RGA2 failed to get pud\n");
+			status = RGA2_OUT_OF_RESOURCES;
+			break;
+		}
+		pmd = pmd_offset(pud, (Memory + i) << PAGE_SHIFT);
+		if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd))) {
+			pr_err("RGA2 failed to get pmd\n");
+			status = RGA2_OUT_OF_RESOURCES;
+			break;
+		}
+		pte = pte_offset_map_lock(current->mm, pmd,
+					  (Memory + i) << PAGE_SHIFT,
+					  &ptl);
+		if (!pte) {
+			pr_err("RGA2 failed to get pte\n");
+			pte_unmap_unlock(pte, ptl);
+			status = RGA2_OUT_OF_RESOURCES;
+			break;
+		}
+		pfn = pte_pfn(*pte);
+		Address = ((pfn << PAGE_SHIFT) | (((unsigned long)((Memory + i)
+			   << PAGE_SHIFT)) & ~PAGE_MASK));
+		pte_unmap_unlock(pte, ptl);
+		pageTable[i] = (uint32_t)Address;
+		if ( writeFlag && (i >= pageCount - 2))
+			break;
+		rga_dma_flush_page(pfn_to_page(pfn));
+	}
+	up_read(&current->mm->mmap_sem);
+	return status;
+}
+
+static int rga2_MapION(struct sg_table *sg,
+                               uint32_t *Memory,
+                               int32_t  pageCount)
+{
+    uint32_t i;
+    uint32_t status;
+    unsigned long Address;
+    uint32_t mapped_size = 0;
+    uint32_t len;
+    struct scatterlist *sgl = sg->sgl;
+    uint32_t sg_num = 0;
+    uint32_t break_flag = 0;
+
+    status = 0;
+    Address = 0;
+    do {
+        len = sg_dma_len(sgl) >> PAGE_SHIFT;
+        Address = sg_phys(sgl);
+
+        for(i=0; i<len; i++) {
+            if (mapped_size + i >= pageCount) {
+                break_flag = 1;
+                break;
+            }
+            Memory[mapped_size + i] = (uint32_t)(Address + (i << PAGE_SHIFT));
+        }
+        if (break_flag)
+            break;
+        mapped_size += len;
+        sg_num += 1;
+    }
+    while((sgl = sg_next(sgl)) && (mapped_size < pageCount) && (sg_num < sg->nents));
+
+    return 0;
+}
+
+
+static int rga2_mmu_info_BitBlt_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+	int Src0MemSize, DstMemSize, Src1MemSize;
+	unsigned long Src0Start, Src1Start, DstStart;
+	unsigned long Src0PageCount, Src1PageCount, DstPageCount;
+	uint32_t AllSize;
+	uint32_t *MMU_Base, *MMU_Base_phys;
+	int ret;
+	int status;
+	uint32_t uv_size, v_size;
+	struct page **pages = NULL;
+	MMU_Base = NULL;
+	Src0MemSize = 0;
+	Src1MemSize = 0;
+	DstMemSize  = 0;
+	Src0PageCount = 0;
+	Src1PageCount = 0;
+	DstPageCount = 0;
+
+	/* cal src0 buf mmu info */
+	if (req->mmu_info.src0_mmu_flag & 1) {
+		Src0PageCount = rga2_buf_size_cal(req->src.yrgb_addr,
+						  req->src.uv_addr,
+						  req->src.v_addr,
+						  req->src.format,
+						  req->src.vir_w,
+						  (req->src.vir_h),
+						  &Src0Start);
+		if (Src0PageCount == 0)
+			return -EINVAL;
+	}
+	/* cal src1 buf mmu info */
+	if (req->mmu_info.src1_mmu_flag & 1) {
+		Src1PageCount = rga2_buf_size_cal(req->src1.yrgb_addr,
+						  req->src1.uv_addr,
+						  req->src1.v_addr,
+						  req->src1.format,
+						  req->src1.vir_w,
+						  (req->src1.vir_h),
+						  &Src1Start);
+		Src1PageCount = (Src1PageCount + 3) & (~3);
+		if (Src1PageCount == 0)
+			return -EINVAL;
+	}
+	/* cal dst buf mmu info */
+	if (req->mmu_info.dst_mmu_flag & 1) {
+		DstPageCount = rga2_buf_size_cal(req->dst.yrgb_addr,
+						 req->dst.uv_addr,
+						 req->dst.v_addr,
+						 req->dst.format,
+						 req->dst.vir_w,
+						 req->dst.vir_h,
+						 &DstStart);
+		/* if vir_address not 4k align need more page */
+		DstPageCount += 2;
+		if (DstPageCount == 0)
+			return -EINVAL;
+	}
+	/* Cal out the needed mem size */
+	Src0MemSize = (Src0PageCount + 15) & (~15);
+	Src1MemSize = (Src1PageCount + 15) & (~15);
+	DstMemSize  = (DstPageCount + 15) & (~15);
+	AllSize = Src0MemSize + Src1MemSize + DstMemSize;
+
+	if (rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+		pr_err("RGA2 Get MMU mem failed\n");
+		status = RGA2_MALLOC_ERROR;
+		goto out;
+	}
+	pages = rga2_mmu_buf.pages;
+	mutex_lock(&rga2_service.lock);
+        MMU_Base = rga2_mmu_buf.buf_virtual +
+				(rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base_phys = rga2_mmu_buf.buf +
+				(rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+        if (Src0MemSize) {
+		if (req->sg_src0)
+			ret = rga2_MapION(req->sg_src0,
+					  &MMU_Base[0], Src0MemSize);
+		else
+			ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0],
+						 Src0Start, Src0PageCount, 0);
+
+		if (ret < 0) {
+			pr_err("rga2 map src0 memory failed\n");
+			status = ret;
+			goto out;
+		}
+		/* change the buf address in req struct */
+		req->mmu_info.src0_base_addr = (((unsigned long)MMU_Base_phys));
+		uv_size = (req->src.uv_addr
+			   - (Src0Start << PAGE_SHIFT)) >> PAGE_SHIFT;
+		v_size = (req->src.v_addr
+			  - (Src0Start << PAGE_SHIFT)) >> PAGE_SHIFT;
+
+		req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK));
+		req->src.uv_addr = (req->src.uv_addr & (~PAGE_MASK)) |
+							(uv_size << PAGE_SHIFT);
+		req->src.v_addr = (req->src.v_addr & (~PAGE_MASK)) |
+							(v_size << PAGE_SHIFT);
+	}
+        if (Src1MemSize) {
+		if (req->sg_src1)
+			ret = rga2_MapION(req->sg_src1,
+					MMU_Base + Src0MemSize, Src1MemSize);
+		else
+			ret = rga2_MapUserMemory(&pages[0],
+						 MMU_Base + Src0MemSize,
+						 Src1Start, Src1PageCount, 0);
+		if (ret < 0) {
+			pr_err("rga2 map src1 memory failed\n");
+			status = ret;
+			goto out;
+		}
+		/* change the buf address in req struct */
+		req->mmu_info.src1_base_addr = ((unsigned long)(MMU_Base_phys
+						+ Src0MemSize));
+		req->src1.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK));
+	}
+        if (DstMemSize) {
+		if (req->sg_dst)
+			ret = rga2_MapION(req->sg_dst, MMU_Base + Src0MemSize
+					  + Src1MemSize, DstMemSize);
+		else
+			ret = rga2_MapUserMemory(&pages[0], MMU_Base
+						 + Src0MemSize + Src1MemSize,
+						 DstStart, DstPageCount, 1);
+		if (ret < 0) {
+			pr_err("rga2 map dst memory failed\n");
+			status = ret;
+			goto out;
+		}
+		/* change the buf address in req struct */
+		req->mmu_info.dst_base_addr  = ((unsigned long)(MMU_Base_phys
+					+ Src0MemSize + Src1MemSize));
+		req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
+		uv_size = (req->dst.uv_addr
+			   - (DstStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+		v_size = (req->dst.v_addr
+			  - (DstStart << PAGE_SHIFT)) >> PAGE_SHIFT;
+		req->dst.uv_addr = (req->dst.uv_addr & (~PAGE_MASK)) |
+						   ((uv_size) << PAGE_SHIFT);
+		req->dst.v_addr = (req->dst.v_addr & (~PAGE_MASK)) |
+			((v_size) << PAGE_SHIFT);
+
+		if (((req->alpha_rop_flag & 1) == 1) && (req->bitblt_mode == 0)) {
+			req->mmu_info.src1_base_addr = req->mmu_info.dst_base_addr;
+			req->mmu_info.src1_mmu_flag  = req->mmu_info.dst_mmu_flag;
+		}
+	}
+	/* flush data to DDR */
+	rga_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+	rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
+	reg->MMU_len = AllSize;
+	status = 0;
+out:
+	return status;
+}
+
+static int rga2_mmu_info_color_palette_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize, DstMemSize;
+    unsigned long SrcStart, DstStart;
+    struct page **pages = NULL;
+    uint32_t AllSize;
+    uint32_t *MMU_Base = NULL, *MMU_Base_phys;
+    int ret, status;
+    uint32_t stride;
+
+    uint8_t shift;
+    uint16_t sw, byte_num;
+
+    shift = 3 - (req->palette_mode & 3);
+    sw = req->src.vir_w*req->src.vir_h;
+    byte_num = sw >> shift;
+    stride = (byte_num + 3) & (~3);
+
+    SrcStart = 0;
+    DstStart = 0;
+    SrcMemSize = 0;
+    DstMemSize = 0;
+
+    do {
+        if (req->mmu_info.src0_mmu_flag) {
+            SrcMemSize = rga2_mem_size_cal(req->src.yrgb_addr, stride, &SrcStart);
+            if(SrcMemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        if (req->mmu_info.dst_mmu_flag) {
+            DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                            req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                            &DstStart);
+            if(DstMemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        SrcMemSize = (SrcMemSize + 15) & (~15);
+        DstMemSize = (DstMemSize + 15) & (~15);
+
+        AllSize = SrcMemSize + DstMemSize;
+
+        if (rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+            pr_err("RGA2 Get MMU mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        pages = rga2_mmu_buf.pages;
+        if(pages == NULL) {
+            pr_err("RGA MMU malloc pages mem failed\n");
+            return -EINVAL;
+        }
+
+        mutex_lock(&rga2_service.lock);
+        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+
+        if(SrcMemSize) {
+		ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0],
+					 SrcStart, SrcMemSize, 0);
+            if (ret < 0) {
+                pr_err("rga2 map src0 memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.src0_base_addr = (((unsigned long)MMU_Base_phys));
+            req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK));
+        }
+
+        if(DstMemSize) {
+		ret = rga2_MapUserMemory(&pages[0], MMU_Base + SrcMemSize,
+					 DstStart, DstMemSize, 1);
+            if (ret < 0) {
+                pr_err("rga2 map dst memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.dst_base_addr  = ((unsigned long)(MMU_Base_phys + SrcMemSize));
+            req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
+        }
+
+        /* flush data to DDR */
+        rga_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
+        reg->MMU_len = AllSize;
+
+        return 0;
+    }
+    while(0);
+
+    return 0;
+}
+
+static int rga2_mmu_info_color_fill_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int DstMemSize;
+    unsigned long DstStart;
+    struct page **pages = NULL;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_Base_phys;
+    int ret;
+    int status;
+
+    DstMemSize = 0;
+    MMU_Base = NULL;
+
+    do {
+        if(req->mmu_info.dst_mmu_flag & 1) {
+            DstMemSize = rga2_buf_size_cal(req->dst.yrgb_addr, req->dst.uv_addr, req->dst.v_addr,
+                                        req->dst.format, req->dst.vir_w, req->dst.vir_h,
+                                        &DstStart);
+            if(DstMemSize == 0) {
+                return -EINVAL;
+            }
+        }
+
+        AllSize = (DstMemSize + 15) & (~15);
+
+        pages = rga2_mmu_buf.pages;
+
+        if(rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+           pr_err("RGA2 Get MMU mem failed\n");
+           status = RGA2_MALLOC_ERROR;
+           break;
+        }
+
+        mutex_lock(&rga2_service.lock);
+        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+
+        if (DstMemSize) {
+            if (req->sg_dst) {
+                ret = rga2_MapION(req->sg_dst, &MMU_Base[0], DstMemSize);
+            }
+            else {
+		    ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0],
+					     DstStart, DstMemSize, 1);
+            }
+            if (ret < 0) {
+                pr_err("rga2 map dst memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.dst_base_addr = ((unsigned long)MMU_Base_phys);
+            req->dst.yrgb_addr = (req->dst.yrgb_addr & (~PAGE_MASK));
+        }
+
+        /* flush data to DDR */
+        rga_dma_flush_range(MMU_Base, (MMU_Base + AllSize + 1));
+        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
+
+        return 0;
+    }
+    while(0);
+
+    return status;
+}
+
+
+static int rga2_mmu_info_update_palette_table_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize;
+    unsigned long SrcStart;
+    struct page **pages = NULL;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_Base_phys;
+    int ret, status;
+
+    MMU_Base = NULL;
+
+    do {
+        /* cal src buf mmu info */
+        SrcMemSize = rga2_mem_size_cal(req->pat.yrgb_addr, req->pat.vir_w * req->pat.vir_h, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        SrcMemSize = (SrcMemSize + 15) & (~15);
+        AllSize = SrcMemSize;
+
+        if (rga2_mmu_buf_get_try(&rga2_mmu_buf, AllSize)) {
+            pr_err("RGA2 Get MMU mem failed\n");
+            status = RGA2_MALLOC_ERROR;
+            break;
+        }
+
+        mutex_lock(&rga2_service.lock);
+        MMU_Base = rga2_mmu_buf.buf_virtual + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        MMU_Base_phys = rga2_mmu_buf.buf + (rga2_mmu_buf.front & (rga2_mmu_buf.size - 1));
+        mutex_unlock(&rga2_service.lock);
+
+        pages = kzalloc(AllSize * sizeof(struct page *), GFP_KERNEL);
+
+        if(SrcMemSize) {
+		ret = rga2_MapUserMemory(&pages[0], &MMU_Base[0],
+					 SrcStart, SrcMemSize, 0);
+            if (ret < 0) {
+                pr_err("rga2 map palette memory failed\n");
+                status = ret;
+                break;
+            }
+
+            /* change the buf address in req struct */
+            req->mmu_info.src0_base_addr = (((unsigned long)MMU_Base_phys));
+            req->pat.yrgb_addr = (req->pat.yrgb_addr & (~PAGE_MASK));
+        }
+
+        /* flush data to DDR */
+        rga_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+        rga2_mmu_buf_get(&rga2_mmu_buf, AllSize);
+        reg->MMU_len = AllSize;
+
+        return 0;
+    }
+    while(0);
+
+    return status;
+}
+
+static int rga2_mmu_info_update_patten_buff_mode(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int SrcMemSize, CMDMemSize;
+    unsigned long SrcStart, CMDStart;
+    struct page **pages = NULL;
+    uint32_t i;
+    uint32_t AllSize;
+    uint32_t *MMU_Base, *MMU_p;
+    int ret, status;
+
+    MMU_Base = MMU_p = 0;
+
+    do {
+        /* cal src buf mmu info */
+        SrcMemSize = rga2_mem_size_cal(req->pat.yrgb_addr, req->pat.act_w * req->pat.act_h * 4, &SrcStart);
+        if(SrcMemSize == 0) {
+            return -EINVAL;
+        }
+
+        /* cal cmd buf mmu info */
+        CMDMemSize = rga2_mem_size_cal((unsigned long)rga2_service.cmd_buff, RGA2_CMD_BUF_SIZE, &CMDStart);
+        if(CMDMemSize == 0) {
+            return -EINVAL;
+        }
+
+        AllSize = SrcMemSize + CMDMemSize;
+
+        pages = rga2_mmu_buf.pages;
+
+        MMU_Base = kzalloc(AllSize * sizeof(uint32_t), GFP_KERNEL);
+
+        for(i=0; i<CMDMemSize; i++) {
+            MMU_Base[i] = virt_to_phys((uint32_t *)((CMDStart + i) << PAGE_SHIFT));
+        }
+
+        if (req->src.yrgb_addr < KERNEL_SPACE_VALID)
+        {
+		ret = rga2_MapUserMemory(&pages[CMDMemSize],
+					 &MMU_Base[CMDMemSize],
+					 SrcStart, SrcMemSize, 1);
+            if (ret < 0) {
+                pr_err("rga map src memory failed\n");
+                status = ret;
+                break;
+            }
+        }
+        else
+        {
+            MMU_p = MMU_Base + CMDMemSize;
+
+            for(i=0; i<SrcMemSize; i++)
+            {
+                MMU_p[i] = (uint32_t)virt_to_phys((uint32_t *)((SrcStart + i) << PAGE_SHIFT));
+            }
+        }
+
+        /* zsq
+         * change the buf address in req struct
+         * for the reason of lie to MMU
+         */
+        req->mmu_info.src0_base_addr = (virt_to_phys(MMU_Base) >> 2);
+
+        req->src.yrgb_addr = (req->src.yrgb_addr & (~PAGE_MASK)) | (CMDMemSize << PAGE_SHIFT);
+
+        /*record the malloc buf for the cmd end to release*/
+        reg->MMU_base = MMU_Base;
+
+        /* flush data to DDR */
+        rga_dma_flush_range(MMU_Base, (MMU_Base + AllSize));
+        return 0;
+
+    }
+    while(0);
+
+    return status;
+}
+
+int rga2_set_mmu_info(struct rga2_reg *reg, struct rga2_req *req)
+{
+    int ret;
+
+    switch (req->render_mode) {
+        case bitblt_mode :
+            ret = rga2_mmu_info_BitBlt_mode(reg, req);
+            break;
+        case color_palette_mode :
+            ret = rga2_mmu_info_color_palette_mode(reg, req);
+            break;
+        case color_fill_mode :
+            ret = rga2_mmu_info_color_fill_mode(reg, req);
+            break;
+        case update_palette_table_mode :
+            ret = rga2_mmu_info_update_palette_table_mode(reg, req);
+            break;
+        case update_patten_buff_mode :
+            ret = rga2_mmu_info_update_patten_buff_mode(reg, req);
+            break;
+        default :
+            ret = -1;
+            break;
+    }
+
+    return ret;
+}
+
diff -Nupr a/drivers/video/rockchip/rga2/rga2_mmu_info.h b/drivers/video/rockchip/rga2/rga2_mmu_info.h
--- a/drivers/video/rockchip/rga2/rga2_mmu_info.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/rga2_mmu_info.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RGA_MMU_INFO_H__
+#define __RGA_MMU_INFO_H__
+
+#include "rga2.h"
+
+#ifndef MIN
+#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
+#endif
+
+
+int rga2_set_mmu_info(struct rga2_reg *reg, struct rga2_req *req);
+
+
+#endif
+
+
diff -Nupr a/drivers/video/rockchip/rga2/rga2_reg_info.c b/drivers/video/rockchip/rga2/rga2_reg_info.c
--- a/drivers/video/rockchip/rga2/rga2_reg_info.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/rga2_reg_info.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1367 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+//#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <asm/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/syscalls.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <asm/cacheflush.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/wakelock.h>
+
+#include "rga2_reg_info.h"
+#include "../rga/rga_type.h"
+//#include "../rga/rga_rop.h"
+#include "rga2.h"
+
+extern unsigned int rga2_ROP3_code[256];
+
+static void RGA2_reg_get_param(unsigned char *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_SRC_INFO;
+    RK_U32 *bRGA_SRC_X_FACTOR;
+    RK_U32 *bRGA_SRC_Y_FACTOR;
+    RK_U32 sw, sh;
+    RK_U32 dw, dh;
+    RK_U32 param_x, param_y;
+    RK_U8 x_flag, y_flag;
+
+    RK_U32 reg;
+
+    bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+    reg = *bRGA_SRC_INFO;
+
+    bRGA_SRC_X_FACTOR = (RK_U32 *)(base + RGA2_SRC_X_FACTOR_OFFSET);
+    bRGA_SRC_Y_FACTOR = (RK_U32 *)(base + RGA2_SRC_Y_FACTOR_OFFSET);
+
+    x_flag = y_flag = 0;
+
+    if(((msg->rotate_mode & 0x3) == 1) || ((msg->rotate_mode & 0x3) == 3))
+    {
+        dw = msg->dst.act_h;
+        dh = msg->dst.act_w;
+    }
+    else
+    {
+        dw = msg->dst.act_w;
+        dh = msg->dst.act_h;
+    }
+
+    sw = msg->src.act_w;
+    sh = msg->src.act_h;
+
+    if (sw > dw)
+    {
+        x_flag = 1;
+        #if SCALE_DOWN_LARGE
+        param_x = ((dw) << 16) / (sw) + 1;
+		#else
+        param_x = ((dw) << 16) / (sw);
+        #endif
+        *bRGA_SRC_X_FACTOR |= ((param_x & 0xffff) << 0 );
+    }
+    else if (sw < dw)
+    {
+        x_flag = 2;
+        #if 1//SCALE_MINUS1
+        param_x = ((sw - 1) << 16) / (dw - 1);
+        #else
+        param_x = ((sw) << 16) / (dw);
+		#endif
+        *bRGA_SRC_X_FACTOR |= ((param_x & 0xffff) << 16);
+    }
+    else
+    {
+        *bRGA_SRC_X_FACTOR = 0;//((1 << 14) << 16) | (1 << 14);
+    }
+
+    if (sh > dh)
+    {
+        y_flag = 1;
+        #if SCALE_DOWN_LARGE
+        param_y = ((dh) << 16) / (sh) + 1;
+		#else
+        param_y = ((dh) << 16) / (sh);
+        #endif
+        *bRGA_SRC_Y_FACTOR |= ((param_y & 0xffff) << 0 );
+    }
+    else if (sh < dh)
+    {
+        y_flag = 2;
+        #if 1//SCALE_MINUS1
+        param_y = ((sh - 1) << 16) / (dh - 1);
+        #else
+        param_y = ((sh) << 16) / (dh);
+		#endif
+        *bRGA_SRC_Y_FACTOR |= ((param_y & 0xffff) << 16);
+    }
+    else
+    {
+        *bRGA_SRC_Y_FACTOR = 0;//((1 << 14) << 16) | (1 << 14);
+    }
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE(x_flag)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE(y_flag)));
+}
+
+static void RGA2_set_mode_ctrl(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_MODE_CTL;
+    RK_U32 reg = 0;
+    RK_U32 render_mode = msg->render_mode;
+
+    bRGA_MODE_CTL = (u32 *)(base + RGA2_MODE_CTRL_OFFSET);
+
+    if(msg->render_mode == 4)
+    {
+        render_mode = 3;
+    }
+
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_RENDER_MODE)) | (s_RGA2_MODE_CTRL_SW_RENDER_MODE(render_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_BITBLT_MODE)) | (s_RGA2_MODE_CTRL_SW_BITBLT_MODE(msg->bitblt_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_CF_ROP4_PAT)) | (s_RGA2_MODE_CTRL_SW_CF_ROP4_PAT(msg->color_fill_mode)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET)) | (s_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET(msg->alpha_zero_key)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_GRADIENT_SAT)) | (s_RGA2_MODE_CTRL_SW_GRADIENT_SAT(msg->alpha_rop_flag >> 7)));
+    reg = ((reg & (~m_RGA2_MODE_CTRL_SW_INTR_CF_E)) | (s_RGA2_MODE_CTRL_SW_INTR_CF_E(msg->CMD_fin_int_enable)));
+
+    *bRGA_MODE_CTL = reg;
+}
+
+static void RGA2_set_reg_src_info(RK_U8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_SRC_INFO;
+    RK_U32 *bRGA_SRC_BASE0, *bRGA_SRC_BASE1, *bRGA_SRC_BASE2;
+    RK_U32 *bRGA_SRC_VIR_INFO;
+    RK_U32 *bRGA_SRC_ACT_INFO;
+    RK_U32 *bRGA_MASK_ADDR;
+	RK_U32 *bRGA_SRC_TR_COLOR0, *bRGA_SRC_TR_COLOR1;
+
+    RK_U32 reg = 0;
+    RK_U8 src0_format = 0;
+
+    RK_U8 src0_rb_swp = 0;
+    RK_U8 src0_rgb_pack = 0;
+
+    RK_U8 src0_cbcr_swp = 0;
+    RK_U8 pixel_width = 1;
+    RK_U32 stride = 0;
+    RK_U32 uv_stride = 0;
+    RK_U32 mask_stride = 0;
+    RK_U32 ydiv = 1, xdiv = 2;
+    RK_U8  yuv10 = 0;
+
+    RK_U32 sw, sh;
+    RK_U32 dw, dh;
+    RK_U8 rotate_mode;
+    RK_U8 scale_w_flag, scale_h_flag;
+
+    bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+
+    bRGA_SRC_BASE0 = (RK_U32 *)(base + RGA2_SRC_BASE0_OFFSET);
+    bRGA_SRC_BASE1 = (RK_U32 *)(base + RGA2_SRC_BASE1_OFFSET);
+    bRGA_SRC_BASE2 = (RK_U32 *)(base + RGA2_SRC_BASE2_OFFSET);
+
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+    bRGA_SRC_ACT_INFO = (RK_U32 *)(base + RGA2_SRC_ACT_INFO_OFFSET);
+
+    bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+
+    bRGA_SRC_TR_COLOR0 = (RK_U32 *)(base + RGA2_SRC_TR_COLOR0_OFFSET);
+    bRGA_SRC_TR_COLOR1 = (RK_U32 *)(base + RGA2_SRC_TR_COLOR1_OFFSET);
+
+    if (msg->src.format == RGA2_FORMAT_YCbCr_420_SP_10B ||
+        msg->src.format == RGA2_FORMAT_YCrCb_420_SP_10B) {
+       if ((msg->src.act_w == msg->dst.act_w) &&
+           (msg->src.act_h == msg->dst.act_h) &&
+           (msg->rotate_mode == 0))
+           msg->rotate_mode = 1 << 6;
+    }
+
+    {
+        rotate_mode = msg->rotate_mode & 0x3;
+
+        sw = msg->src.act_w;
+        sh = msg->src.act_h;
+
+        if((rotate_mode == 1) | (rotate_mode == 3))
+        {
+            dw = msg->dst.act_h;
+            dh = msg->dst.act_w;
+        }
+        else
+        {
+            dw = msg->dst.act_w;
+            dh = msg->dst.act_h;
+        }
+
+        if(sw > dw)
+            scale_w_flag = 1;
+        else if (sw < dw)
+            scale_w_flag = 2;
+        else {
+            scale_w_flag = 0;
+            if(msg->rotate_mode >> 6)
+                scale_w_flag = 3;
+        }
+
+        if(sh > dh)
+            scale_h_flag = 1;
+        else if (sh < dh)
+            scale_h_flag = 2;
+        else {
+            scale_h_flag = 0;
+            if(msg->rotate_mode >> 6)
+                scale_h_flag = 3;
+        }
+    }
+
+    switch (msg->src.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : src0_format = 0x0; pixel_width = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : src0_format = 0x0; src0_rb_swp = 0x1; pixel_width = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : src0_format = 0x1; pixel_width = 4; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGRX_8888    : src0_format = 0x1; src0_rb_swp = 0x1; pixel_width = 4; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_RGB_888      : src0_format = 0x2; src0_rgb_pack = 1; pixel_width = 3; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGR_888      : src0_format = 0x2; src0_rgb_pack = 1; src0_rb_swp = 1; pixel_width = 3; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_RGB_565      : src0_format = 0x4; pixel_width = 2; msg->src_trans_mode &= 0x07; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : src0_format = 0x5; pixel_width = 2; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : src0_format = 0x6; pixel_width = 2; src0_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : src0_format = 0x4; pixel_width = 2; msg->src_trans_mode &= 0x07; break;
+        case RGA2_FORMAT_BGRA_5551    : src0_format = 0x5; pixel_width = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : src0_format = 0x6; pixel_width = 2; break;
+
+        case RGA2_FORMAT_YCbCr_422_SP : src0_format = 0x8; xdiv = 1; ydiv = 1; break;
+        case RGA2_FORMAT_YCbCr_422_P  : src0_format = 0x9; xdiv = 2; ydiv = 1; break;
+        case RGA2_FORMAT_YCbCr_420_SP : src0_format = 0xa; xdiv = 1; ydiv = 2; break;
+        case RGA2_FORMAT_YCbCr_420_P  : src0_format = 0xb; xdiv = 2; ydiv = 2; break;
+        case RGA2_FORMAT_YCrCb_422_SP : src0_format = 0x8; xdiv = 1; ydiv = 1; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_422_P  : src0_format = 0x9; xdiv = 2; ydiv = 1; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_420_SP : src0_format = 0xa; xdiv = 1; ydiv = 2; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCrCb_420_P  : src0_format = 0xb; xdiv = 2; ydiv = 2; src0_cbcr_swp = 1; break;
+        case RGA2_FORMAT_YCbCr_420_SP_10B : src0_format = 0xa; xdiv = 1; ydiv = 2; yuv10 = 1; break;
+        case RGA2_FORMAT_YCrCb_420_SP_10B : src0_format = 0xa; xdiv = 1; ydiv = 2; src0_cbcr_swp = 1; yuv10 = 1; break;
+    };
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SRC_FMT)) | (s_RGA2_SRC_INFO_SW_SRC_FMT(src0_format)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP(src0_rb_swp)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP(msg->alpha_swp)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP)) | (s_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP(src0_cbcr_swp)));
+    if(msg->src.format <= RGA2_FORMAT_BGRA_4444)
+    	reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(0)));
+    else
+        if(msg->dst.format >= RGA2_FORMAT_YCbCr_422_SP)
+            reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(0)));
+        else
+    	    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(msg->yuv2rgb_mode)));
+
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE(msg->rotate_mode & 0x3)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE((msg->rotate_mode >> 4) & 0x3)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE((scale_w_flag))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE((scale_h_flag))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER)) | (s_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER((msg->scale_bicu_mode))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE)) | (s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE(msg->src_trans_mode)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E)) | (s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E(msg->src_trans_mode >> 1)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E)) | (s_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E((msg->alpha_rop_flag >> 4) & 0x1)));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL)) | (s_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL((msg->scale_bicu_mode>>4))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_YUV10_E)) | (s_RGA2_SRC_INFO_SW_SW_YUV10_E((yuv10))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E)) | (s_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E((yuv10))));
+    RGA2_reg_get_param(base, msg);
+
+    stride = (((msg->src.vir_w * pixel_width) + 3) & ~3) >> 2;
+    uv_stride = ((msg->src.vir_w / xdiv + 3) & ~3);
+
+    *bRGA_SRC_BASE0 = (RK_U32)(msg->src.yrgb_addr + msg->src.y_offset * (stride<<2) + msg->src.x_offset * pixel_width);
+    *bRGA_SRC_BASE1 = (RK_U32)(msg->src.uv_addr + (msg->src.y_offset / ydiv) * uv_stride + (msg->src.x_offset / xdiv));
+    *bRGA_SRC_BASE2 = (RK_U32)(msg->src.v_addr + (msg->src.y_offset / ydiv) * uv_stride + (msg->src.x_offset / xdiv));
+
+    //mask_stride = ((msg->src0_act.width + 31) & ~31) >> 5;
+    mask_stride = msg->rop_mask_stride;
+
+    *bRGA_SRC_VIR_INFO = stride | (mask_stride << 16);
+
+    *bRGA_SRC_ACT_INFO = (msg->src.act_w - 1) | ((msg->src.act_h - 1) << 16);
+
+    *bRGA_MASK_ADDR = (RK_U32)msg->rop_mask_addr;
+
+    *bRGA_SRC_INFO = reg;
+
+	*bRGA_SRC_TR_COLOR0 = msg->color_key_min;
+    *bRGA_SRC_TR_COLOR1 = msg->color_key_max;
+}
+
+static void RGA2_set_reg_dst_info(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_DST_INFO;
+    RK_U32 *bRGA_DST_BASE0, *bRGA_DST_BASE1, *bRGA_DST_BASE2, *bRGA_SRC_BASE3;
+    RK_U32 *bRGA_DST_VIR_INFO;
+    RK_U32 *bRGA_DST_ACT_INFO;
+
+    RK_U8 src1_format = 0;
+    RK_U8 src1_rb_swp = 0;
+    RK_U8 src1_rgb_pack = 0;
+    RK_U8 dst_format = 0;
+    RK_U8 dst_rb_swp = 0;
+    RK_U8 dst_rgb_pack = 0;
+    RK_U8 dst_cbcr_swp = 0;
+    RK_U32 reg = 0;
+    RK_U8 spw, dpw;
+    RK_U32 s_stride, d_stride;
+    RK_U32 x_mirr, y_mirr, rot_90_flag;
+    RK_U32 yrgb_addr, u_addr, v_addr, s_yrgb_addr;
+    RK_U32 d_uv_stride, x_div, y_div;
+    RK_U32 y_lt_addr, y_ld_addr, y_rt_addr, y_rd_addr;
+    RK_U32 u_lt_addr, u_ld_addr, u_rt_addr, u_rd_addr;
+    RK_U32 v_lt_addr, v_ld_addr, v_rt_addr, v_rd_addr;
+
+    RK_U32 s_y_lt_addr, s_y_ld_addr, s_y_rt_addr, s_y_rd_addr;
+
+    dpw = 1;
+    x_div = y_div = 1;
+
+    bRGA_DST_INFO = (RK_U32 *)(base + RGA2_DST_INFO_OFFSET);
+    bRGA_DST_BASE0 = (RK_U32 *)(base + RGA2_DST_BASE0_OFFSET);
+    bRGA_DST_BASE1 = (RK_U32 *)(base + RGA2_DST_BASE1_OFFSET);
+    bRGA_DST_BASE2 = (RK_U32 *)(base + RGA2_DST_BASE2_OFFSET);
+
+    bRGA_SRC_BASE3 = (RK_U32 *)(base + RGA2_SRC_BASE3_OFFSET);
+
+    bRGA_DST_VIR_INFO = (RK_U32 *)(base + RGA2_DST_VIR_INFO_OFFSET);
+    bRGA_DST_ACT_INFO = (RK_U32 *)(base + RGA2_DST_ACT_INFO_OFFSET);
+
+    switch (msg->src1.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : src1_format = 0x0; spw = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : src1_format = 0x0; src1_rb_swp = 0x1; spw = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : src1_format = 0x1; spw = 4; break;
+        case RGA2_FORMAT_BGRX_8888    : src1_format = 0x1; src1_rb_swp = 0x1; spw = 4; break;
+        case RGA2_FORMAT_RGB_888      : src1_format = 0x2; src1_rgb_pack = 1; spw = 3; break;
+        case RGA2_FORMAT_BGR_888      : src1_format = 0x2; src1_rgb_pack = 1; src1_rb_swp = 1; spw = 3; break;
+        case RGA2_FORMAT_RGB_565      : src1_format = 0x4; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : src1_format = 0x5; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : src1_format = 0x6; spw = 2; src1_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : src1_format = 0x4; spw = 2; break;
+        case RGA2_FORMAT_BGRA_5551    : src1_format = 0x5; spw = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : src1_format = 0x6; spw = 2; break;
+        default                       : spw = 4; break;
+    };
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_FMT)) | (s_RGA2_DST_INFO_SW_SRC1_FMT(src1_format)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_RB_SWP)) | (s_RGA2_DST_INFO_SW_SRC1_RB_SWP(src1_rb_swp)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP)) | (s_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP(msg->alpha_swp >> 1)));
+
+
+    switch (msg->dst.format)
+    {
+        case RGA2_FORMAT_RGBA_8888    : dst_format = 0x0; dpw = 4; break;
+        case RGA2_FORMAT_BGRA_8888    : dst_format = 0x0; dst_rb_swp = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_RGBX_8888    : dst_format = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_BGRX_8888    : dst_format = 0x1; dst_rb_swp = 0x1; dpw = 4; break;
+        case RGA2_FORMAT_RGB_888      : dst_format = 0x2; dst_rgb_pack = 1; dpw = 3; break;
+        case RGA2_FORMAT_BGR_888      : dst_format = 0x2; dst_rgb_pack = 1; dst_rb_swp = 1; dpw = 3; break;
+        case RGA2_FORMAT_RGB_565      : dst_format = 0x4; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_5551    : dst_format = 0x5; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_RGBA_4444    : dst_format = 0x6; dpw = 2; dst_rb_swp = 0x1; break;
+        case RGA2_FORMAT_BGR_565      : dst_format = 0x4; dpw = 2; break;
+        case RGA2_FORMAT_BGRA_5551    : dst_format = 0x5; dpw = 2; break;
+        case RGA2_FORMAT_BGRA_4444    : dst_format = 0x6; dpw = 2; break;
+
+        case RGA2_FORMAT_YCbCr_422_SP : dst_format = 0x8; x_div = 1; y_div = 1; break;
+        case RGA2_FORMAT_YCbCr_422_P  : dst_format = 0x9; x_div = 2; y_div = 1; break;
+        case RGA2_FORMAT_YCbCr_420_SP : dst_format = 0xa; x_div = 1; y_div = 2; break;
+        case RGA2_FORMAT_YCbCr_420_P  : dst_format = 0xb; x_div = 2; y_div = 2; break;
+        case RGA2_FORMAT_YCrCb_422_SP : dst_format = 0x8; dst_cbcr_swp = 1; x_div = 1; y_div = 1; break;
+        case RGA2_FORMAT_YCrCb_422_P  : dst_format = 0x9; dst_cbcr_swp = 1; x_div = 2; y_div = 1; break;
+        case RGA2_FORMAT_YCrCb_420_SP : dst_format = 0xa; dst_cbcr_swp = 1; x_div = 1; y_div = 2; break;
+        case RGA2_FORMAT_YCrCb_420_P  : dst_format = 0xb; dst_cbcr_swp = 1; x_div = 2; y_div = 2; break;
+    };
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_FMT)) | (s_RGA2_DST_INFO_SW_DST_FMT(dst_format)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_RB_SWAP)) | (s_RGA2_DST_INFO_SW_DST_RB_SWAP(dst_rb_swp)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_ALPHA_SWAP)) | (s_RGA2_DST_INFO_SW_ALPHA_SWAP(msg->alpha_swp >> 2)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_UV_SWAP)) | (s_RGA2_DST_INFO_SW_DST_UV_SWAP(dst_cbcr_swp)));
+
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_UP_E)) | (s_RGA2_DST_INFO_SW_DITHER_UP_E(msg->alpha_rop_flag >> 5)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_DOWN_E)) | (s_RGA2_DST_INFO_SW_DITHER_DOWN_E(msg->alpha_rop_flag >> 6)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DITHER_MODE)) | (s_RGA2_DST_INFO_SW_DITHER_MODE(msg->dither_mode)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_DST_CSC_MODE)) | (s_RGA2_DST_INFO_SW_DST_CSC_MODE(msg->yuv2rgb_mode >> 4)));
+    reg = ((reg & (~m_RGA2_DST_INFO_SW_CSC_CLIP_MODE)) | (s_RGA2_DST_INFO_SW_CSC_CLIP_MODE(msg->yuv2rgb_mode >> 6)));
+
+
+    *bRGA_DST_INFO = reg;
+
+    s_stride = ((msg->src1.vir_w * spw + 3) & ~3) >> 2;
+    d_stride = ((msg->dst.vir_w * dpw + 3) & ~3) >> 2;
+    d_uv_stride = (d_stride << 2) / x_div;
+
+    *bRGA_DST_VIR_INFO = d_stride | (s_stride << 16);
+    *bRGA_DST_ACT_INFO = (msg->dst.act_w - 1) | ((msg->dst.act_h - 1) << 16);
+    s_stride <<= 2;
+	d_stride <<= 2;
+
+    if(((msg->rotate_mode & 0xf) == 0) || ((msg->rotate_mode & 0xf) == 1))
+    {
+        x_mirr = 0;
+        y_mirr = 0;
+    }
+    else
+    {
+        x_mirr = 1;
+        y_mirr = 1;
+    }
+
+    rot_90_flag = msg->rotate_mode & 1;
+    x_mirr = (x_mirr + ((msg->rotate_mode >> 4) & 1)) & 1;
+    y_mirr = (y_mirr + ((msg->rotate_mode >> 5) & 1)) & 1;
+
+    yrgb_addr = (RK_U32)msg->src1.yrgb_addr + (msg->src1.y_offset * s_stride) + (msg->src1.x_offset * spw);
+
+    s_y_lt_addr = yrgb_addr;
+    s_y_ld_addr = yrgb_addr + (msg->src1.act_h - 1) * s_stride;
+    s_y_rt_addr = yrgb_addr + (msg->dst.act_w - 1) * spw;
+    s_y_rd_addr = s_y_ld_addr + (msg->dst.act_w - 1) * spw;
+
+    yrgb_addr = (RK_U32)msg->dst.yrgb_addr + (msg->dst.y_offset * d_stride) + (msg->dst.x_offset * dpw);
+    u_addr = (RK_U32)msg->dst.uv_addr + (msg->dst.y_offset / y_div) * d_uv_stride + msg->dst.x_offset / x_div;
+    v_addr = (RK_U32)msg->dst.v_addr + (msg->dst.y_offset / y_div) * d_uv_stride + msg->dst.x_offset / x_div;
+
+    y_lt_addr = yrgb_addr;
+    u_lt_addr = u_addr;
+    v_lt_addr = v_addr;
+
+    y_ld_addr = yrgb_addr + (msg->dst.act_h - 1) * (d_stride);
+    u_ld_addr = u_addr + ((msg->dst.act_h / y_div) - 1) * (d_uv_stride);
+    v_ld_addr = v_addr + ((msg->dst.act_h / y_div) - 1) * (d_uv_stride);
+
+    y_rt_addr = yrgb_addr + (msg->dst.act_w - 1) * dpw;
+    u_rt_addr = u_addr + (msg->dst.act_w / x_div) - 1;
+    v_rt_addr = v_addr + (msg->dst.act_w / x_div) - 1;
+
+    y_rd_addr = y_ld_addr + (msg->dst.act_w - 1) * dpw;
+    u_rd_addr = u_ld_addr + (msg->dst.act_w / x_div) - 1;
+    v_rd_addr = v_ld_addr + (msg->dst.act_w / x_div) - 1;
+
+    if(rot_90_flag == 0)
+    {
+        if(y_mirr == 1)
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_rd_addr;
+                u_addr = u_rd_addr;
+                v_addr = v_rd_addr;
+
+                s_yrgb_addr = s_y_rd_addr;
+            }
+            else
+            {
+                yrgb_addr = y_ld_addr;
+                u_addr = u_ld_addr;
+                v_addr = v_ld_addr;
+
+                s_yrgb_addr = s_y_ld_addr;
+            }
+        }
+        else
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_rt_addr;
+                u_addr = u_rt_addr;
+                v_addr = v_rt_addr;
+
+                s_yrgb_addr = s_y_rt_addr;
+            }
+            else
+            {
+                yrgb_addr = y_lt_addr;
+                u_addr = u_lt_addr;
+                v_addr = v_lt_addr;
+
+                s_yrgb_addr = s_y_lt_addr;
+            }
+        }
+    }
+    else
+    {
+        if(y_mirr == 1)
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_ld_addr;
+                u_addr = u_ld_addr;
+                v_addr = v_ld_addr;
+
+                s_yrgb_addr = s_y_ld_addr;
+            }
+            else
+            {
+                yrgb_addr = y_rd_addr;
+                u_addr = u_rd_addr;
+                v_addr = v_rd_addr;
+
+                s_yrgb_addr = s_y_rd_addr;
+            }
+        }
+        else
+        {
+            if(x_mirr == 1)
+            {
+                yrgb_addr = y_lt_addr;
+                u_addr = u_lt_addr;
+                v_addr = v_lt_addr;
+
+                s_yrgb_addr = s_y_lt_addr;
+            }
+            else
+            {
+                yrgb_addr = y_rt_addr;
+                u_addr = u_rt_addr;
+                v_addr = v_rt_addr;
+
+                s_yrgb_addr = s_y_rt_addr;
+            }
+        }
+    }
+
+    *bRGA_DST_BASE0 = (RK_U32)yrgb_addr;
+
+    if((msg->dst.format == RGA2_FORMAT_YCbCr_420_P) || (msg->dst.format == RGA2_FORMAT_YCrCb_420_P))
+    {
+        if(dst_cbcr_swp == 0) {
+            *bRGA_DST_BASE1 = (RK_U32)v_addr;
+            *bRGA_DST_BASE2 = (RK_U32)u_addr;
+        }
+        else {
+            *bRGA_DST_BASE1 = (RK_U32)u_addr;
+            *bRGA_DST_BASE2 = (RK_U32)v_addr;
+        }
+    }
+    else {
+        *bRGA_DST_BASE1 = (RK_U32)u_addr;
+        *bRGA_DST_BASE2 = (RK_U32)v_addr;
+    }
+
+    *bRGA_SRC_BASE3 = (RK_U32)s_y_lt_addr;
+}
+
+static void RGA2_set_reg_alpha_info(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_ALPHA_CTRL0;
+    RK_U32 *bRGA_ALPHA_CTRL1;
+    RK_U32 *bRGA_FADING_CTRL;
+    RK_U32 reg0 = 0;
+    RK_U32 reg1 = 0;
+
+    bRGA_ALPHA_CTRL0 = (RK_U32 *)(base + RGA2_ALPHA_CTRL0_OFFSET);
+    bRGA_ALPHA_CTRL1 = (RK_U32 *)(base + RGA2_ALPHA_CTRL1_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0)) | (s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0(msg->alpha_rop_flag)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL)) | (s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL(msg->alpha_rop_flag >> 1)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_ROP_MODE)) | (s_RGA2_ALPHA_CTRL0_SW_ROP_MODE(msg->rop_mode)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA)) | (s_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA(msg->src_a_global_val)));
+    reg0 = ((reg0 & (~m_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA)) | (s_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA(msg->dst_a_global_val)));
+
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0(msg->alpha_mode_0 >> 15)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0(msg->alpha_mode_0 >> 7)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0(msg->alpha_mode_0 >> 12)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0(msg->alpha_mode_0 >> 4)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0(msg->alpha_mode_0 >> 11)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0(msg->alpha_mode_0 >> 3)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0(msg->alpha_mode_0 >> 9)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0(msg->alpha_mode_0 >> 1)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0(msg->alpha_mode_0 >> 8)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0(msg->alpha_mode_0 >> 0)));
+
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1(msg->alpha_mode_1 >> 12)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1(msg->alpha_mode_1 >> 4)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1(msg->alpha_mode_1 >> 11)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1(msg->alpha_mode_1 >> 3)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1(msg->alpha_mode_1 >> 9)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1(msg->alpha_mode_1 >> 1)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1)) | (s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1(msg->alpha_mode_1 >> 8)));
+    reg1 = ((reg1 & (~m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1)) | (s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1(msg->alpha_mode_1 >> 0)));
+
+    *bRGA_ALPHA_CTRL0 = reg0;
+    *bRGA_ALPHA_CTRL1 = reg1;
+
+    if((msg->alpha_rop_flag>>2)&1)
+    {
+        *bRGA_FADING_CTRL = (1<<24) | (msg->fading_b_value<<16) | (msg->fading_g_value<<8) | (msg->fading_r_value);
+    }
+}
+
+static void RGA2_set_reg_rop_info(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_ALPHA_CTRL0;
+    RK_U32 *bRGA_ROP_CTRL0;
+    RK_U32 *bRGA_ROP_CTRL1;
+    RK_U32 *bRGA_MASK_ADDR;
+    RK_U32 *bRGA_FG_COLOR;
+    RK_U32 *bRGA_PAT_CON;
+
+    RK_U32 rop_code0 = 0;
+    RK_U32 rop_code1 = 0;
+
+    bRGA_ALPHA_CTRL0 = (RK_U32 *)(base + RGA2_ALPHA_CTRL0_OFFSET);
+    bRGA_ROP_CTRL0 = (RK_U32 *)(base + RGA2_ROP_CTRL0_OFFSET);
+    bRGA_ROP_CTRL1 = (RK_U32 *)(base + RGA2_ROP_CTRL1_OFFSET);
+	bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_FG_COLOR  = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+    bRGA_PAT_CON   = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+
+    if(msg->rop_mode == 0) {
+	rop_code0 = rga2_ROP3_code[(msg->rop_code & 0xff)];
+    }
+    else if(msg->rop_mode == 1) {
+	rop_code0 = rga2_ROP3_code[(msg->rop_code & 0xff)];
+    }
+    else if(msg->rop_mode == 2) {
+	rop_code0 = rga2_ROP3_code[(msg->rop_code & 0xff)];
+	rop_code1 = rga2_ROP3_code[(msg->rop_code & 0xff00)>>8];
+    }
+
+    *bRGA_ROP_CTRL0 = rop_code0;
+    *bRGA_ROP_CTRL1 = rop_code1;
+    *bRGA_FG_COLOR = msg->fg_color;
+    *bRGA_MASK_ADDR = (RK_U32)msg->rop_mask_addr;
+    *bRGA_PAT_CON = (msg->pat.act_w-1) | ((msg->pat.act_h-1) << 8)
+                     | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
+    *bRGA_ALPHA_CTRL0 = *bRGA_ALPHA_CTRL0 | (((msg->endian_mode >> 1) & 1) << 20);
+
+}
+
+static void RGA2_set_reg_color_palette(RK_U8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_SRC_BASE0, *bRGA_SRC_INFO, *bRGA_SRC_VIR_INFO, *bRGA_SRC_ACT_INFO, *bRGA_SRC_FG_COLOR, *bRGA_SRC_BG_COLOR;
+    RK_U32  *p;
+    RK_S16  x_off, y_off;
+    RK_U16  src_stride;
+    RK_U8   shift;
+    RK_U32  sw;
+    RK_U32  byte_num;
+    RK_U32 reg;
+
+    bRGA_SRC_BASE0 = (RK_U32 *)(base + RGA2_SRC_BASE0_OFFSET);
+	bRGA_SRC_INFO = (RK_U32 *)(base + RGA2_SRC_INFO_OFFSET);
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+    bRGA_SRC_ACT_INFO = (RK_U32 *)(base + RGA2_SRC_ACT_INFO_OFFSET);
+    bRGA_SRC_FG_COLOR = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+    bRGA_SRC_BG_COLOR = (RK_U32 *)(base + RGA2_SRC_BG_COLOR_OFFSET);
+
+    reg = 0;
+
+    shift = 3 - msg->palette_mode;
+
+    x_off = msg->src.x_offset;
+    y_off = msg->src.y_offset;
+
+    sw = msg->src.vir_w;
+    byte_num = sw >> shift;
+
+    src_stride = (byte_num + 3) & (~3);
+
+    p = (RK_U32 *)((unsigned long)msg->src.yrgb_addr);
+
+    #if 0
+    if(endian_mode)
+    {
+        p = p + (x_off>>shift) + y_off*src_stride;
+    }
+    else
+    {
+        p = p + (((x_off>>shift)>>2)<<2) + (3 - ((x_off>>shift) & 3)) + y_off*src_stride;
+    }
+    #endif
+
+    p = p + (x_off>>shift) + y_off*src_stride;
+
+
+    *bRGA_SRC_BASE0 = (unsigned long)p;
+
+	reg = ((reg & (~m_RGA2_SRC_INFO_SW_SRC_FMT)) | (s_RGA2_SRC_INFO_SW_SRC_FMT((msg->palette_mode | 0xc))));
+    reg = ((reg & (~m_RGA2_SRC_INFO_SW_SW_CP_ENDAIN)) | (s_RGA2_SRC_INFO_SW_SW_CP_ENDAIN(msg->endian_mode & 1)));
+    *bRGA_SRC_VIR_INFO = src_stride >> 2;
+    *bRGA_SRC_ACT_INFO = (msg->src.act_w - 1) | ((msg->src.act_h - 1) << 16);
+    *bRGA_SRC_INFO = reg;
+
+    *bRGA_SRC_FG_COLOR = msg->fg_color;
+    *bRGA_SRC_BG_COLOR = msg->bg_color;
+
+}
+
+static void RGA2_set_reg_color_fill(u8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_CF_GR_A;
+    RK_U32 *bRGA_CF_GR_B;
+    RK_U32 *bRGA_CF_GR_G;
+    RK_U32 *bRGA_CF_GR_R;
+    RK_U32 *bRGA_SRC_FG_COLOR;
+    RK_U32 *bRGA_MASK_ADDR;
+    RK_U32 *bRGA_PAT_CON;
+
+    RK_U32 mask_stride;
+    RK_U32 *bRGA_SRC_VIR_INFO;
+
+    bRGA_SRC_FG_COLOR = (RK_U32 *)(base + RGA2_SRC_FG_COLOR_OFFSET);
+
+    bRGA_CF_GR_A = (RK_U32 *)(base + RGA2_CF_GR_A_OFFSET);
+    bRGA_CF_GR_B = (RK_U32 *)(base + RGA2_CF_GR_B_OFFSET);
+    bRGA_CF_GR_G = (RK_U32 *)(base + RGA2_CF_GR_G_OFFSET);
+    bRGA_CF_GR_R = (RK_U32 *)(base + RGA2_CF_GR_R_OFFSET);
+
+    bRGA_MASK_ADDR = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_PAT_CON = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+
+    bRGA_SRC_VIR_INFO = (RK_U32 *)(base + RGA2_SRC_VIR_INFO_OFFSET);
+
+    mask_stride = msg->rop_mask_stride;
+
+    if(msg->color_fill_mode == 0)
+    {
+        /* solid color */
+        *bRGA_CF_GR_A = (msg->gr_color.gr_x_a & 0xffff) | (msg->gr_color.gr_y_a << 16);
+        *bRGA_CF_GR_B = (msg->gr_color.gr_x_b & 0xffff) | (msg->gr_color.gr_y_b << 16);
+        *bRGA_CF_GR_G = (msg->gr_color.gr_x_g & 0xffff) | (msg->gr_color.gr_y_g << 16);
+        *bRGA_CF_GR_R = (msg->gr_color.gr_x_r & 0xffff) | (msg->gr_color.gr_y_r << 16);
+
+        *bRGA_SRC_FG_COLOR = msg->fg_color;
+    }
+    else
+    {
+        /* patten color */
+        *bRGA_MASK_ADDR = (RK_U32)msg->pat.yrgb_addr;
+        *bRGA_PAT_CON = (msg->pat.act_w - 1) | ((msg->pat.act_h - 1) << 8)
+                       | (msg->pat.x_offset << 16) | (msg->pat.y_offset << 24);
+    }
+	*bRGA_SRC_VIR_INFO = mask_stride << 16;
+}
+
+static void RGA2_set_reg_update_palette_table(RK_U8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_MASK_BASE;
+    RK_U32 *bRGA_FADING_CTRL;
+
+    bRGA_MASK_BASE  = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    *bRGA_FADING_CTRL = msg->fading_g_value << 8;
+    *bRGA_MASK_BASE = (RK_U32)msg->pat.yrgb_addr;
+}
+
+
+static void RGA2_set_reg_update_patten_buff(RK_U8 *base, struct rga2_req *msg)
+{
+    u32 *bRGA_PAT_MST;
+    u32 *bRGA_PAT_CON;
+    u32 *bRGA_PAT_START_POINT;
+    RK_U32 *bRGA_FADING_CTRL;
+    u32 reg = 0;
+    rga_img_info_t *pat;
+
+    RK_U32 num, offset;
+
+    pat = &msg->pat;
+
+    num = (pat->act_w * pat->act_h) - 1;
+
+    offset = pat->act_w * pat->y_offset + pat->x_offset;
+
+    bRGA_PAT_START_POINT = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+    bRGA_PAT_MST = (RK_U32 *)(base + RGA2_MASK_BASE_OFFSET);
+    bRGA_PAT_CON = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    *bRGA_PAT_MST = (RK_U32)msg->pat.yrgb_addr;
+    *bRGA_PAT_START_POINT = (pat->act_w * pat->y_offset) + pat->x_offset;
+
+    reg = (pat->act_w-1) | ((pat->act_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
+    *bRGA_PAT_CON = reg;
+
+    *bRGA_FADING_CTRL = (num << 8) | offset;
+}
+
+static void RGA2_set_pat_info(RK_U8 *base, struct rga2_req *msg)
+{
+    u32 *bRGA_PAT_CON;
+    u32 *bRGA_FADING_CTRL;
+    u32 reg = 0;
+    rga_img_info_t *pat;
+
+    RK_U32 num, offset;
+
+    pat = &msg->pat;
+
+    num = ((pat->act_w * pat->act_h) - 1) & 0xff;
+
+    offset = (pat->act_w * pat->y_offset) + pat->x_offset;
+
+    bRGA_PAT_CON     = (RK_U32 *)(base + RGA2_PAT_CON_OFFSET);
+    bRGA_FADING_CTRL = (RK_U32 *)(base + RGA2_FADING_CTRL_OFFSET);
+
+    reg = (pat->act_w-1) | ((pat->act_h-1) << 8) | (pat->x_offset << 16) | (pat->y_offset << 24);
+    *bRGA_PAT_CON = reg;
+    *bRGA_FADING_CTRL = (num << 8) | offset;
+}
+
+static void RGA2_set_mmu_info(RK_U8 *base, struct rga2_req *msg)
+{
+    RK_U32 *bRGA_MMU_CTRL1;
+    RK_U32 *bRGA_MMU_SRC_BASE;
+    RK_U32 *bRGA_MMU_SRC1_BASE;
+    RK_U32 *bRGA_MMU_DST_BASE;
+    RK_U32 *bRGA_MMU_ELS_BASE;
+
+    RK_U32 reg;
+
+    bRGA_MMU_CTRL1 = (RK_U32 *)(base + RGA2_MMU_CTRL1_OFFSET);
+    bRGA_MMU_SRC_BASE = (RK_U32 *)(base + RGA2_MMU_SRC_BASE_OFFSET);
+    bRGA_MMU_SRC1_BASE = (RK_U32 *)(base + RGA2_MMU_SRC1_BASE_OFFSET);
+    bRGA_MMU_DST_BASE = (RK_U32 *)(base + RGA2_MMU_DST_BASE_OFFSET);
+    bRGA_MMU_ELS_BASE = (RK_U32 *)(base + RGA2_MMU_ELS_BASE_OFFSET);
+
+    reg = (msg->mmu_info.src0_mmu_flag & 0xf) | ((msg->mmu_info.src1_mmu_flag & 0xf) << 4)
+         | ((msg->mmu_info.dst_mmu_flag & 0xf) << 8) | ((msg->mmu_info.els_mmu_flag & 0x3) << 12);
+
+    *bRGA_MMU_CTRL1 = reg;
+    *bRGA_MMU_SRC_BASE  = (RK_U32)(msg->mmu_info.src0_base_addr) >> 4;
+    *bRGA_MMU_SRC1_BASE = (RK_U32)(msg->mmu_info.src1_base_addr) >> 4;
+    *bRGA_MMU_DST_BASE  = (RK_U32)(msg->mmu_info.dst_base_addr)  >> 4;
+    *bRGA_MMU_ELS_BASE  = (RK_U32)(msg->mmu_info.els_base_addr)  >> 4;
+}
+
+
+int
+RGA2_gen_reg_info(RK_U8 *base , struct rga2_req *msg)
+{
+
+    RGA2_set_mode_ctrl(base, msg);
+
+    RGA2_set_pat_info(base, msg);
+
+    switch(msg->render_mode)
+    {
+        case bitblt_mode:
+            RGA2_set_reg_src_info(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            RGA2_set_reg_alpha_info(base, msg);
+            RGA2_set_reg_rop_info(base, msg);
+            break;
+        case color_fill_mode :
+            RGA2_set_reg_color_fill(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            RGA2_set_reg_alpha_info(base, msg);
+            break;
+        case color_palette_mode :
+            RGA2_set_reg_color_palette(base, msg);
+            RGA2_set_reg_dst_info(base, msg);
+            break;
+        case update_palette_table_mode :
+            RGA2_set_reg_update_palette_table(base, msg);
+            break;
+        case update_patten_buff_mode :
+            RGA2_set_reg_update_patten_buff(base, msg);
+            break;
+        default :
+            printk("RGA2 ERROR msg render mode %d \n", msg->render_mode);
+            break;
+
+    }
+
+    RGA2_set_mmu_info(base, msg);
+
+    return 0;
+
+}
+
+static void format_name_convert(uint32_t *df, uint32_t sf)
+{
+    /*
+    RK_FORMAT_RGBA_8888    = 0x0,
+    RK_FORMAT_RGBX_8888    = 0x1,
+    RK_FORMAT_RGB_888      = 0x2,
+    RK_FORMAT_BGRA_8888    = 0x3,
+    RK_FORMAT_RGB_565      = 0x4,
+    RK_FORMAT_RGBA_5551    = 0x5,
+    RK_FORMAT_RGBA_4444    = 0x6,
+    RK_FORMAT_BGR_888      = 0x7,
+
+    RK_FORMAT_YCbCr_422_SP = 0x8,
+    RK_FORMAT_YCbCr_422_P  = 0x9,
+    RK_FORMAT_YCbCr_420_SP = 0xa,
+    RK_FORMAT_YCbCr_420_P  = 0xb,
+
+    RK_FORMAT_YCrCb_422_SP = 0xc,
+    RK_FORMAT_YCrCb_422_P  = 0xd,
+    RK_FORMAT_YCrCb_420_SP = 0xe,
+    RK_FORMAT_YCrCb_420_P  = 0xf,
+
+    RGA2_FORMAT_RGBA_8888    = 0x0,
+    RGA2_FORMAT_RGBX_8888    = 0x1,
+    RGA2_FORMAT_RGB_888      = 0x2,
+    RGA2_FORMAT_BGRA_8888    = 0x3,
+    RGA2_FORMAT_BGRX_8888    = 0x4,
+    RGA2_FORMAT_BGR_888      = 0x5,
+    RGA2_FORMAT_RGB_565      = 0x6,
+    RGA2_FORMAT_RGBA_5551    = 0x7,
+    RGA2_FORMAT_RGBA_4444    = 0x8,
+    RGA2_FORMAT_BGR_565      = 0x9,
+    RGA2_FORMAT_BGRA_5551    = 0xa,
+    RGA2_FORMAT_BGRA_4444    = 0xb,
+
+    RGA2_FORMAT_YCbCr_422_SP = 0x10,
+    RGA2_FORMAT_YCbCr_422_P  = 0x11,
+    RGA2_FORMAT_YCbCr_420_SP = 0x12,
+    RGA2_FORMAT_YCbCr_420_P  = 0x13,
+    RGA2_FORMAT_YCrCb_422_SP = 0x14,
+    RGA2_FORMAT_YCrCb_422_P  = 0x15,
+    RGA2_FORMAT_YCrCb_420_SP = 0x16,
+    RGA2_FORMAT_YCrCb_420_P  = 0x17,*/
+    switch(sf)
+    {
+        case 0x0: *df = RGA2_FORMAT_RGBA_8888; break;
+        case 0x1: *df = RGA2_FORMAT_RGBX_8888; break;
+        case 0x2: *df = RGA2_FORMAT_RGB_888; break;
+        case 0x3: *df = RGA2_FORMAT_BGRA_8888; break;
+        case 0x4: *df = RGA2_FORMAT_RGB_565; break;
+        case 0x5: *df = RGA2_FORMAT_RGBA_5551; break;
+        case 0x6: *df = RGA2_FORMAT_RGBA_4444; break;
+        case 0x7: *df = RGA2_FORMAT_BGR_888; break;
+        case 0x8: *df = RGA2_FORMAT_YCbCr_422_SP; break;
+        case 0x9: *df = RGA2_FORMAT_YCbCr_422_P; break;
+        case 0xa: *df = RGA2_FORMAT_YCbCr_420_SP; break;
+        case 0xb: *df = RGA2_FORMAT_YCbCr_420_P; break;
+        case 0xc: *df = RGA2_FORMAT_YCrCb_422_SP; break;
+        case 0xd: *df = RGA2_FORMAT_YCrCb_422_P; break;
+        case 0xe: *df = RGA2_FORMAT_YCrCb_420_SP; break;
+        case 0xf: *df = RGA2_FORMAT_YCrCb_420_P; break;
+
+        case 0x20:*df = RGA2_FORMAT_YCbCr_420_SP_10B; break;
+        case 0x21:*df = RGA2_FORMAT_YCrCb_420_SP_10B; break;
+    }
+}
+
+void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req)
+{
+	u16 alpha_mode_0, alpha_mode_1;
+
+	if (req_rga->render_mode & RGA_BUF_GEM_TYPE_MASK)
+		req->buf_type = RGA_BUF_GEM_TYPE_MASK & RGA_BUF_GEM_TYPE_DMA;
+
+	req_rga->render_mode &= (~RGA_BUF_GEM_TYPE_MASK);
+
+    if (req_rga->render_mode == 6)
+        req->render_mode = update_palette_table_mode;
+    else if (req_rga->render_mode == 7)
+        req->render_mode = update_patten_buff_mode;
+    else if (req_rga->render_mode == 5)
+        req->render_mode = bitblt_mode;
+    else
+        req->render_mode = req_rga->render_mode;
+
+    memcpy(&req->src, &req_rga->src, sizeof(req_rga->src));
+    memcpy(&req->dst, &req_rga->dst, sizeof(req_rga->dst));
+    memcpy(&req->pat, &req_rga->pat, sizeof(req_rga->pat));
+    memcpy(&req->src1,&req_rga->pat, sizeof(req_rga->pat));
+
+    format_name_convert(&req->src.format, req_rga->src.format);
+    format_name_convert(&req->dst.format, req_rga->dst.format);
+
+    if(req_rga->rotate_mode == 1) {
+        if(req_rga->sina == 0 && req_rga->cosa == 65536) {
+            /* rotate 0 */
+            req->rotate_mode = 0;
+        }
+        else if (req_rga->sina == 65536 && req_rga->cosa == 0) {
+            /* rotate 90 */
+            req->rotate_mode = 1;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_h + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+        else if (req_rga->sina == 0 && req_rga->cosa == -65536) {
+            /* rotate 180 */
+            req->rotate_mode = 2;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_w + 1;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_h + 1;
+        }
+        else if (req_rga->sina == -65536 && req_rga->cosa == 0) {
+            /* totate 270 */
+            req->rotate_mode = 3;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_w + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+    }
+    else if (req_rga->rotate_mode == 2)
+    {
+        //x_mirror
+        req->rotate_mode |= (1 << 4);
+    }
+    else if (req_rga->rotate_mode == 3)
+    {
+        //y_mirror
+        req->rotate_mode |= (2 << 4);
+    }
+    else {
+        req->rotate_mode = 0;
+    }
+
+    if((req->dst.act_w > 2048) && (req->src.act_h < req->dst.act_h))
+        req->scale_bicu_mode |= (1<<4);
+
+    req->LUT_addr = req_rga->LUT_addr;
+    req->rop_mask_addr = req_rga->rop_mask_addr;
+
+    req->bitblt_mode = req_rga->bsfilter_flag;
+
+    req->src_a_global_val = req_rga->alpha_global_value;
+    req->dst_a_global_val = req_rga->alpha_global_value;
+    req->rop_code = req_rga->rop_code;
+    req->rop_mode = 0;
+
+    req->color_fill_mode = req_rga->color_fill_mode;
+    req->color_key_min   = req_rga->color_key_min;
+    req->color_key_max   = req_rga->color_key_max;
+
+    req->fg_color = req_rga->fg_color;
+    req->bg_color = req_rga->bg_color;
+    memcpy(&req->gr_color, &req_rga->gr_color, sizeof(req_rga->gr_color));
+
+    req->palette_mode = req_rga->palette_mode;
+    req->yuv2rgb_mode = req_rga->yuv2rgb_mode + 1;
+    req->endian_mode = req_rga->endian_mode;
+    req->rgb2yuv_mode = 0;
+
+    req->fading_alpha_value = 0;
+    req->fading_r_value = req_rga->fading.r;
+    req->fading_g_value = req_rga->fading.g;
+    req->fading_b_value = req_rga->fading.b;
+
+    /* alpha mode set */
+    req->alpha_rop_flag = 0;
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag & 1)));           // alpha_rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 1) & 1) << 1); // rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 2) & 1) << 2); // fading_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 4) & 1) << 3); // alpha_cal_mode_sel
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 5) & 1) << 6); // dst_dither_down
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 6) & 1) << 7); // gradient fill mode sel
+
+    if (((req_rga->alpha_rop_flag) & 1)) {
+        if ((req_rga->alpha_rop_flag >> 3) & 1) {
+            /* porter duff alpha enable */
+            switch (req_rga->PD_mode)
+            {
+                case 0: //dst = 0
+                    break;
+                case 1: //dst = src
+                    break;
+                case 2: //dst = dst
+                    break;
+                case 3: //dst = (256*sc + (256 - sa)*dc) >> 8
+                    if((req_rga->alpha_rop_mode & 3) == 0) {
+                        alpha_mode_0 = 0x3818;
+                        alpha_mode_1 = 0x3818;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 1) {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                        alpha_mode_0 = 0x381C;
+                        alpha_mode_1 = 0x381C;
+                    }
+                    else {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    req->alpha_mode_0 = alpha_mode_0;
+                    req->alpha_mode_1 = alpha_mode_1;
+                    break;
+                case 4: //dst = (sc*(256-da) + 256*dc) >> 8
+                    break;
+                case 5: //dst = (da*sc) >> 8
+                    break;
+                case 6: //dst = (sa*dc) >> 8
+                    break;
+                case 7: //dst = ((256-da)*sc) >> 8
+                    break;
+                case 8: //dst = ((256-sa)*dc) >> 8
+                    break;
+                case 9: //dst = (da*sc + (256-sa)*dc) >> 8
+                    req->alpha_mode_0 = 0x3848;
+                    req->alpha_mode_1 = 0x3848;
+                    break;
+                case 10://dst = ((256-da)*sc + (sa*dc)) >> 8
+                    break;
+                case 11://dst = ((256-da)*sc + (256-sa)*dc) >> 8;
+                    break;
+		case 12:
+		    req->alpha_mode_0 = 0x0010;
+		    req->alpha_mode_1 = 0x0820;
+		    break;
+                default:
+                    break;
+            }
+        }
+        else {
+            if((req_rga->alpha_rop_mode & 3) == 0) {
+                req->alpha_mode_0 = 0x3848;
+                req->alpha_mode_1 = 0x3848;
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 1) {
+                req->alpha_mode_0 = 0x483A;
+                req->alpha_mode_1 = 0x483A;
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                req->alpha_mode_0 = 0x384C;
+                req->alpha_mode_1 = 0x384C;
+            }
+        }
+    }
+
+    if (req_rga->mmu_info.mmu_en && (req_rga->mmu_info.mmu_flag & 1) == 1) {
+        req->mmu_info.src0_mmu_flag = 1;
+        req->mmu_info.dst_mmu_flag = 1;
+
+        if (req_rga->mmu_info.mmu_flag >> 31) {
+            req->mmu_info.src0_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 8)  & 1);
+            req->mmu_info.src1_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 9)  & 1);
+            req->mmu_info.dst_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 10) & 1);
+            req->mmu_info.els_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 11) & 1);
+        }
+        else {
+            if (req_rga->src.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.src0_mmu_flag = 0;
+               req->src.yrgb_addr = req_rga->src.yrgb_addr - 0x60000000;
+               req->src.uv_addr   = req_rga->src.uv_addr - 0x60000000;
+               req->src.v_addr    = req_rga->src.v_addr - 0x60000000;
+            }
+
+            if (req_rga->dst.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.dst_mmu_flag = 0;
+               req->dst.yrgb_addr = req_rga->dst.yrgb_addr - 0x60000000;
+            }
+        }
+    }
+}
+
+static void memcpy_img_info(struct rga_img_info_t *dst, struct rga_img_info_32_t *src)
+{
+    dst->yrgb_addr = src->yrgb_addr;      /* yrgb    mem addr         */
+    dst->uv_addr = src->uv_addr;        /* cb/cr   mem addr         */
+    dst->v_addr = src->v_addr;         /* cr      mem addr         */
+    dst->format = src->format;         //definition by RK_FORMAT
+
+    dst->act_w = src->act_w;
+    dst->act_h = src->act_h;
+    dst->x_offset = src->x_offset;
+    dst->y_offset = src->y_offset;
+
+    dst->vir_w = src->vir_w;
+    dst->vir_h = src->vir_h;
+    dst->endian_mode = src->endian_mode; //for BPP
+    dst->alpha_swap = src->alpha_swap;
+}
+
+void RGA_MSG_2_RGA2_MSG_32(struct rga_req_32 *req_rga, struct rga2_req *req)
+{
+	u16 alpha_mode_0, alpha_mode_1;
+
+	if (req_rga->render_mode & RGA_BUF_GEM_TYPE_MASK)
+		req->buf_type = RGA_BUF_GEM_TYPE_MASK & RGA_BUF_GEM_TYPE_DMA;
+
+	req_rga->render_mode &= (~RGA_BUF_GEM_TYPE_MASK);
+
+    if (req_rga->render_mode == 6)
+        req->render_mode = update_palette_table_mode;
+    else if (req_rga->render_mode == 7)
+        req->render_mode = update_patten_buff_mode;
+    else if (req_rga->render_mode == 5)
+        req->render_mode = bitblt_mode;
+    else
+        req->render_mode = req_rga->render_mode;
+    memcpy_img_info(&req->src, &req_rga->src);
+    memcpy_img_info(&req->dst, &req_rga->dst);
+    memcpy_img_info(&req->pat, &req_rga->pat);
+    memcpy_img_info(&req->src1,&req_rga->pat);
+    format_name_convert(&req->src.format, req_rga->src.format);
+    format_name_convert(&req->dst.format, req_rga->dst.format);
+    if(req_rga->rotate_mode == 1) {
+        if(req_rga->sina == 0 && req_rga->cosa == 65536) {
+            req->rotate_mode = 0;
+        }
+        else if (req_rga->sina == 65536 && req_rga->cosa == 0) {
+            req->rotate_mode = 1;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_h + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+        else if (req_rga->sina == 0 && req_rga->cosa == -65536) {
+            req->rotate_mode = 2;
+            req->dst.x_offset = req_rga->dst.x_offset - req_rga->dst.act_w + 1;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_h + 1;
+        }
+        else if (req_rga->sina == -65536 && req_rga->cosa == 0) {
+            req->rotate_mode = 3;
+            req->dst.y_offset = req_rga->dst.y_offset - req_rga->dst.act_w + 1;
+            req->dst.act_w = req_rga->dst.act_h;
+            req->dst.act_h = req_rga->dst.act_w;
+        }
+    }
+    else if (req_rga->rotate_mode == 2)
+    {
+        req->rotate_mode = (1 << 4);
+    }
+    else if (req_rga->rotate_mode == 3)
+    {
+        req->rotate_mode = (2 << 4);
+    }
+    else {
+        req->rotate_mode = 0;
+    }
+    if((req->dst.act_w > 2048) && (req->src.act_h < req->dst.act_h))
+        req->scale_bicu_mode |= (1<<4);
+    req->LUT_addr = req_rga->LUT_addr;
+    req->rop_mask_addr = req_rga->rop_mask_addr;
+    req->bitblt_mode = req_rga->bsfilter_flag;
+    req->src_a_global_val = req_rga->alpha_global_value;
+    req->dst_a_global_val = req_rga->alpha_global_value;
+    req->rop_code = req_rga->rop_code;
+    req->rop_mode = 0;
+    req->color_fill_mode = req_rga->color_fill_mode;
+    req->color_key_min   = req_rga->color_key_min;
+    req->color_key_max   = req_rga->color_key_max;
+    req->fg_color = req_rga->fg_color;
+    req->bg_color = req_rga->bg_color;
+    memcpy(&req->gr_color, &req_rga->gr_color, sizeof(req_rga->gr_color));
+    req->palette_mode = req_rga->palette_mode;
+    req->yuv2rgb_mode = req_rga->yuv2rgb_mode + 1;
+    req->endian_mode = req_rga->endian_mode;
+    req->rgb2yuv_mode = 0;
+    req->fading_alpha_value = 0;
+    req->fading_r_value = req_rga->fading.r;
+    req->fading_g_value = req_rga->fading.g;
+    req->fading_b_value = req_rga->fading.b;
+    req->alpha_rop_flag = 0;
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag & 1)));           // alpha_rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 1) & 1) << 1); // rop_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 2) & 1) << 2); // fading_enable
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 4) & 1) << 3); // alpha_cal_mode_sel
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 5) & 1) << 6); // dst_dither_down
+    req->alpha_rop_flag |= (((req_rga->alpha_rop_flag >> 6) & 1) << 7); // gradient fill mode sel
+    if(((req_rga->alpha_rop_flag) & 1)) {
+        if((req_rga->alpha_rop_flag >> 3) & 1) {
+            switch(req_rga->PD_mode)
+            {
+                case 0: //dst = 0
+                    break;
+                case 1: //dst = src
+                    break;
+                case 2: //dst = dst
+                    break;
+                case 3: //dst = (256*sc + (256 - sa)*dc) >> 8
+                    if((req_rga->alpha_rop_mode & 3) == 0) {
+                        alpha_mode_0 = 0x3818;
+                        alpha_mode_1 = 0x3818;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 1) {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                        alpha_mode_0 = 0x381C;
+                        alpha_mode_1 = 0x381C;
+                    }
+                    else {
+                        alpha_mode_0 = 0x381A;
+                        alpha_mode_1 = 0x381A;
+                    }
+                    req->alpha_mode_0 = alpha_mode_0;
+                    req->alpha_mode_1 = alpha_mode_1;
+                    break;
+                case 4: //dst = (sc*(256-da) + 256*dc) >> 8
+                    break;
+                case 5: //dst = (da*sc) >> 8
+                    break;
+                case 6: //dst = (sa*dc) >> 8
+                    break;
+                case 7: //dst = ((256-da)*sc) >> 8
+                    break;
+                case 8: //dst = ((256-sa)*dc) >> 8
+                    break;
+                case 9: //dst = (da*sc + (256-sa)*dc) >> 8
+                    req->alpha_mode_0 = 0x3848;
+                    req->alpha_mode_1 = 0x3848;
+                    break;
+                case 10://dst = ((256-da)*sc + (sa*dc)) >> 8
+                    break;
+                case 11://dst = ((256-da)*sc + (256-sa)*dc) >> 8;
+                    break;
+		case 12:
+		    req->alpha_mode_0 = 0x0010;
+		    req->alpha_mode_1 = 0x0820;
+		    break;
+                default:
+                    break;
+            }
+        }
+        else {
+            if((req_rga->alpha_rop_mode & 3) == 0) {
+                req->alpha_mode_0 = 0x3848;
+                req->alpha_mode_1 = 0x3848;
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 1) {
+                req->alpha_mode_0 = 0x483A;
+                req->alpha_mode_1 = 0x483A;
+            }
+            else if ((req_rga->alpha_rop_mode & 3) == 2) {
+                req->alpha_mode_0 = 0x384C;
+                req->alpha_mode_1 = 0x384C;
+            }
+        }
+    }
+    if (req_rga->mmu_info.mmu_en && (req_rga->mmu_info.mmu_flag & 1) == 1) {
+        req->mmu_info.src0_mmu_flag = 1;
+        req->mmu_info.dst_mmu_flag = 1;
+        if (req_rga->mmu_info.mmu_flag >> 31) {
+            req->mmu_info.src0_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 8)  & 1);
+            req->mmu_info.src1_mmu_flag = ((req_rga->mmu_info.mmu_flag >> 9)  & 1);
+            req->mmu_info.dst_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 10) & 1);
+            req->mmu_info.els_mmu_flag  = ((req_rga->mmu_info.mmu_flag >> 11) & 1);
+        }
+        else {
+            if (req_rga->src.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.src0_mmu_flag = 0;
+               req->src.yrgb_addr = req_rga->src.yrgb_addr - 0x60000000;
+               req->src.uv_addr   = req_rga->src.uv_addr - 0x60000000;
+               req->src.v_addr    = req_rga->src.v_addr - 0x60000000;
+            }
+            if (req_rga->dst.yrgb_addr >= 0xa0000000) {
+               req->mmu_info.dst_mmu_flag = 0;
+               req->dst.yrgb_addr = req_rga->dst.yrgb_addr - 0x60000000;
+            }
+        }
+    }
+}
diff -Nupr a/drivers/video/rockchip/rga2/rga2_reg_info.h b/drivers/video/rockchip/rga2/rga2_reg_info.h
--- a/drivers/video/rockchip/rga2/rga2_reg_info.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/rga2_reg_info.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,302 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __REG2_INFO_H__
+#define __REG2_INFO_H__
+
+
+//#include "chip_register.h"
+
+//#include "rga_struct.h"
+#include "rga2.h"
+
+#ifndef MIN
+#define MIN(X, Y)           ((X)<(Y)?(X):(Y))
+#endif
+
+#ifndef MAX
+#define MAX(X, Y)           ((X)>(Y)?(X):(Y))
+#endif
+
+#ifndef ABS
+#define ABS(X)              (((X) < 0) ? (-(X)) : (X))
+#endif
+
+#ifndef CLIP
+#define CLIP(x, a,  b)				((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x))
+#endif
+
+#define rRGA_SYS_CTRL             (*(volatile u32 *)(RGA2_BASE + RGA2_SYS_CTRL_OFFSET    ))
+#define rRGA_CMD_CTRL             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_CTRL_OFFSET    ))
+#define rRGA_CMD_BASE             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_BASE_OFFSET    ))
+#define rRGA_STATUS               (*(volatile u32 *)(RGA2_BASE + RGA2_STATUS_OFFSET      ))
+#define rRGA_INT                  (*(volatile u32 *)(RGA2_BASE + RGA2_INT_OFFSET         ))
+#define rRGA_MMU_CTRL0            (*(volatile u32 *)(RGA2_BASE + RGA2_MMU_CTRL0_OFFSET   ))
+#define rRGA_MMU_CMD_BASE         (*(volatile u32 *)(RGA2_BASE + RGA2_MMU_CMD_BASE_OFFSET))
+#define rRGA_CMD_ADDR             (*(volatile u32 *)(RGA2_BASE + RGA2_CMD_ADDR))
+
+/*RGA_INT*/
+#define m_RGA2_INT_ALL_CMD_DONE_INT_EN             ( 1<<10 )
+#define m_RGA2_INT_MMU_INT_EN                      ( 1<<9  )
+#define m_RGA2_INT_ERROR_INT_EN                    ( 1<<8  )
+#define m_RGA2_INT_NOW_CMD_DONE_INT_CLEAR          ( 1<<7  )
+#define m_RGA2_INT_ALL_CMD_DONE_INT_CLEAR          ( 1<<6  )
+#define m_RGA2_INT_MMU_INT_CLEAR                   ( 1<<5  )
+#define m_RGA2_INT_ERROR_INT_CLEAR                 ( 1<<4  )
+#define m_RGA2_INT_CUR_CMD_DONE_INT_FLAG           ( 1<<3  )
+#define m_RGA2_INT_ALL_CMD_DONE_INT_FLAG           ( 1<<2  )
+#define m_RGA2_INT_MMU_INT_FLAG                    ( 1<<1  )
+#define m_RGA2_INT_ERROR_INT_FLAG                  ( 1<<0  )
+
+#define s_RGA2_INT_ALL_CMD_DONE_INT_EN(x)          ( (x&0x1)<<10 )
+#define s_RGA2_INT_MMU_INT_EN(x)                   ( (x&0x1)<<9  )
+#define s_RGA2_INT_ERROR_INT_EN(x)                 ( (x&0x1)<<8  )
+#define s_RGA2_INT_NOW_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<7  )
+#define s_RGA2_INT_ALL_CMD_DONE_INT_CLEAR(x)       ( (x&0x1)<<6  )
+#define s_RGA2_INT_MMU_INT_CLEAR(x)                ( (x&0x1)<<5  )
+#define s_RGA2_INT_ERROR_INT_CLEAR(x)              ( (x&0x1)<<4  )
+
+
+
+/* RGA_MODE_CTRL */
+#define m_RGA2_MODE_CTRL_SW_RENDER_MODE         (  0x7<<0  )
+#define m_RGA2_MODE_CTRL_SW_BITBLT_MODE         (  0x1<<3  )
+#define m_RGA2_MODE_CTRL_SW_CF_ROP4_PAT         (  0x1<<4  )
+#define m_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET      (  0x1<<5  )
+#define m_RGA2_MODE_CTRL_SW_GRADIENT_SAT        (  0x1<<6  )
+#define m_RGA2_MODE_CTRL_SW_INTR_CF_E           (  0x1<<7  )
+
+#define s_RGA2_MODE_CTRL_SW_RENDER_MODE(x)      (  (x&0x7)<<0  )
+#define s_RGA2_MODE_CTRL_SW_BITBLT_MODE(x)      (  (x&0x1)<<3  )
+#define s_RGA2_MODE_CTRL_SW_CF_ROP4_PAT(x)      (  (x&0x1)<<4  )
+#define s_RGA2_MODE_CTRL_SW_ALPHA_ZERO_KET(x)   (  (x&0x1)<<5  )
+#define s_RGA2_MODE_CTRL_SW_GRADIENT_SAT(x)     (  (x&0x1)<<6  )
+#define s_RGA2_MODE_CTRL_SW_INTR_CF_E(x)        (  (x&0x1)<<7  )
+
+/* RGA_SRC_INFO */
+#define m_RGA2_SRC_INFO_SW_SRC_FMT                (   0xf<<0   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP         (   0x1<<4   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP      (   0x1<<5   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP         (   0x1<<6   )
+#define m_RGA2_SRC_INFO_SW_SW_CP_ENDAIN           (   0x1<<7   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE        (   0x3<<8   )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE        (   0x3<<10  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE        (   0x3<<12  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE       (   0x3<<14  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE       (   0x3<<16  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE      (   0x1<<18  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E         (   0xf<<19  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E     (   0x1<<23  )
+#define m_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER      (   0x3<<24  )
+#define m_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL        (   0x1<<26  )
+#define m_RGA2_SRC_INFO_SW_SW_YUV10_E             (   0x1<<27  )
+#define m_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E       (   0x1<<28  )
+
+
+
+
+
+#define s_RGA2_SRC_INFO_SW_SRC_FMT(x)                (   (x&0xf)<<0   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_RB_SWAP(x)         (   (x&0x1)<<4   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_ALPHA_SWAP(x)      (   (x&0x1)<<5   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_UV_SWAP(x)         (   (x&0x1)<<6   )
+#define s_RGA2_SRC_INFO_SW_SW_CP_ENDAIN(x)           (   (x&0x1)<<7   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_CSC_MODE(x)        (   (x&0x3)<<8   )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_ROT_MODE(x)        (   (x&0x3)<<10  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_MIR_MODE(x)        (   (x&0x3)<<12  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_HSCL_MODE(x)       (   (x&0x3)<<14  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_VSCL_MODE(x)       (   (x&0x3)<<16  )
+
+#define s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_MODE(x)      (   (x&0x1)<<18  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_TRANS_E(x)         (   (x&0xf)<<19  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_DITHER_UP_E(x)     (   (x&0x1)<<23  )
+#define s_RGA2_SRC_INFO_SW_SW_SRC_SCL_FILTER(x)      (   (x&0x3)<<24  )
+#define s_RGA2_SRC_INFO_SW_SW_VSP_MODE_SEL(x)        (   (x&0x1)<<26  )
+#define s_RGA2_SRC_INFO_SW_SW_YUV10_E(x)             (   (x&0x1)<<27  )
+#define s_RGA2_SRC_INFO_SW_SW_YUV10_ROUND_E(x)       (   (x&0x1)<<28  )
+
+/* RGA_SRC_VIR_INFO */
+#define m_RGA2_SRC_VIR_INFO_SW_SRC_VIR_STRIDE        (  0x7fff<<0  )         //modify
+#define m_RGA2_SRC_VIR_INFO_SW_MASK_VIR_STRIDE       (   0x3ff<<16 )         //modify
+
+#define s_RGA2_SRC_VIR_INFO_SW_SRC_VIR_STRIDE(x)        ( (x&0x7fff)<<0  )   //modify
+#define s_RGA2_SRC_VIR_INFO_SW_MASK_VIR_STRIDE(x)       (   (x&0x3ff)<<16 )  //modify
+
+
+/* RGA_SRC_ACT_INFO */
+#define m_RGA2_SRC_ACT_INFO_SW_SRC_ACT_WIDTH        (  0x1fff<<0  )
+#define m_RGA2_SRC_ACT_INFO_SW_SRC_ACT_HEIGHT       (  0x1fff<<16  )
+
+#define s_RGA2_SRC_ACT_INFO_SW_SRC_ACT_WIDTH(x)        (  (x&0x1fff)<<0  )
+#define s_RGA2_SRC_ACT_INFO_SW_SRC_ACT_HEIGHT(x)       (  (x&0x1fff<)<16  )
+
+
+/* RGA_DST_INFO */
+#define m_RGA2_DST_INFO_SW_DST_FMT                   (  0xf<<0 )
+#define m_RGA2_DST_INFO_SW_DST_RB_SWAP               (  0x1<<4 )
+#define m_RGA2_DST_INFO_SW_ALPHA_SWAP                (  0x1<<5 )
+#define m_RGA2_DST_INFO_SW_DST_UV_SWAP               (  0x1<<6 )
+#define m_RGA2_DST_INFO_SW_SRC1_FMT                  (  0x7<<7 )
+#define m_RGA2_DST_INFO_SW_SRC1_RB_SWP               (  0x1<<10)
+#define m_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP            (  0x1<<11)
+#define m_RGA2_DST_INFO_SW_DITHER_UP_E               (  0x1<<12)
+#define m_RGA2_DST_INFO_SW_DITHER_DOWN_E             (  0x1<<13)
+#define m_RGA2_DST_INFO_SW_DITHER_MODE               (  0x3<<14)
+#define m_RGA2_DST_INFO_SW_DST_CSC_MODE              (  0x3<<16)    //add
+#define m_RGA2_DST_INFO_SW_CSC_CLIP_MODE             (  0x1<<18)
+
+#define s_RGA2_DST_INFO_SW_DST_FMT(x)                   (  (x&0xf)<<0 )
+#define s_RGA2_DST_INFO_SW_DST_RB_SWAP(x)               (  (x&0x1)<<4 )
+#define s_RGA2_DST_INFO_SW_ALPHA_SWAP(x)                (  (x&0x1)<<5 )
+#define s_RGA2_DST_INFO_SW_DST_UV_SWAP(x)               (  (x&0x1)<<6 )
+#define s_RGA2_DST_INFO_SW_SRC1_FMT(x)                  (  (x&0x7)<<7 )
+#define s_RGA2_DST_INFO_SW_SRC1_RB_SWP(x)               (  (x&0x1)<<10)
+#define s_RGA2_DST_INFO_SW_SRC1_ALPHA_SWP(x)            (  (x&0x1)<<11)
+#define s_RGA2_DST_INFO_SW_DITHER_UP_E(x)               (  (x&0x1)<<12)
+#define s_RGA2_DST_INFO_SW_DITHER_DOWN_E(x)             (  (x&0x1)<<13)
+#define s_RGA2_DST_INFO_SW_DITHER_MODE(x)               (  (x&0x3)<<14)
+#define s_RGA2_DST_INFO_SW_DST_CSC_MODE(x)              (  (x&0x3)<<16)    //add
+#define s_RGA2_DST_INFO_SW_CSC_CLIP_MODE(x)             (  (x&0x1)<<18)
+
+
+/* RGA_ALPHA_CTRL0 */
+#define m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0             (  0x1<<0  )
+#define m_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL           (  0x1<<1  )
+#define m_RGA2_ALPHA_CTRL0_SW_ROP_MODE                (  0x3<<2  )
+#define m_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA        ( 0xff<<4  )
+#define m_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA        ( 0xff<<12 )
+#define m_RGA2_ALPHA_CTRLO_SW_MASK_ENDIAN             (  0x1<<20 )         //add
+
+#define s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_0(x)             (  (x&0x1)<<0  )
+#define s_RGA2_ALPHA_CTRL0_SW_ALPHA_ROP_SEL(x)           (  (x&0x1)<<1  )
+#define s_RGA2_ALPHA_CTRL0_SW_ROP_MODE(x)                (  (x&0x3)<<2  )
+#define s_RGA2_ALPHA_CTRL0_SW_SRC_GLOBAL_ALPHA(x)        ( (x&0xff)<<4  )
+#define s_RGA2_ALPHA_CTRL0_SW_DST_GLOBAL_ALPHA(x)        ( (x&0xff)<<12 )
+#define s_RGA2_ALPHA_CTRLO_SW_MASK_ENDIAN(x)             (  (x&0x1)<<20 )  //add
+
+
+
+/* RGA_ALPHA_CTRL1 */
+#define m_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0            ( 0x1<<0 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0            ( 0x1<<1 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0           ( 0x7<<2 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0           ( 0x7<<5 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0        ( 0x1<<8 )
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0        ( 0x1<<9 )
+#define m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0            ( 0x3<<10)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0            ( 0x3<<12)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0            ( 0x1<<14)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0            ( 0x1<<15)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1           ( 0x7<<16)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1           ( 0x7<<19)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1        ( 0x1<<22)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1        ( 0x1<<23)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1            ( 0x3<<24)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1            ( 0x3<<26)
+#define m_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1            ( 0x1<<28)
+#define m_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1            ( 0x1<<29)
+
+#define s_RGA2_ALPHA_CTRL1_SW_DST_COLOR_M0(x)            ( (x&0x1)<<0 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_COLOR_M0(x)            ( (x&0x1)<<1 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M0(x)           ( (x&0x7)<<2 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M0(x)           ( (x&0x7)<<5 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M0(x)        ( (x&0x1)<<8 )
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M0(x)        ( (x&0x1)<<9 )
+#define s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M0(x)            ( (x&0x3)<<10)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M0(x)            ( (x&0x3)<<12)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M0(x)            ( (x&0x1)<<14)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M0(x)            ( (x&0x1)<<15)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_FACTOR_M1(x)           ( (x&0x7)<<16)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_FACTOR_M1(x)           ( (x&0x7)<<19)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_CAL_M1(x)        ( (x&0x1)<<22)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_CAL_M1(x)        ( (x&0x1)<<23)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_BLEND_M1(x)            ( (x&0x3)<<24)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_BLEND_M1(x)            ( (x&0x3)<<26)
+#define s_RGA2_ALPHA_CTRL1_SW_DST_ALPHA_M1(x)            ( (x&0x1)<<28)
+#define s_RGA2_ALPHA_CTRL1_SW_SRC_ALPHA_M1(x)            ( (x&0x1)<<29)
+
+
+
+/* RGA_MMU_CTRL1 */
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_EN                  (  0x1<<0 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_FLUSH               (  0x1<<1 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_EN         (  0x1<<2 )
+#define m_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_DIR        (  0x1<<3 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_EN                 (  0x1<<4 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_FLUSH              (  0x1<<5 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_EN        (  0x1<<6 )
+#define m_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_DIR       (  0x1<<7 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_EN                  (  0x1<<8 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_FLUSH               (  0x1<<9 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_EN         (  0x1<<10 )
+#define m_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_DIR        (  0x1<<11 )
+#define m_RGA2_MMU_CTRL1_SW_ELS_MMU_EN                  (  0x1<<12 )
+#define m_RGA2_MMU_CTRL1_SW_ELS_MMU_FLUSH               (  0x1<<13 )
+
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_EN(x)                  (  (x&0x1)<<0 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_FLUSH(x)               (  (x&0x1)<<1 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_EN(x)         (  (x&0x1)<<2 )
+#define s_RGA2_MMU_CTRL1_SW_SRC_MMU_PREFETCH_DIR(x)        (  (x&0x1)<<3 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_EN(x)                 (  (x&0x1)<<4 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_FLUSH(x)              (  (x&0x1)<<5 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_EN(x)        (  (x&0x1)<<6 )
+#define s_RGA2_MMU_CTRL1_SW_SRC1_MMU_PREFETCH_DIR(x)       (  (x&0x1)<<7 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_EN(x)                  (  (x&0x1)<<8 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_FLUSH(x)               (  (x&0x1)<<9 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_EN(x)         (  (x&0x1)<<10 )
+#define s_RGA2_MMU_CTRL1_SW_DST_MMU_PREFETCH_DIR(x)        (  (x&0x1)<<11 )
+#define s_RGA2_MMU_CTRL1_SW_ELS_MMU_EN(x)                  (  (x&0x1)<<12 )
+#define s_RGA2_MMU_CTRL1_SW_ELS_MMU_FLUSH(x)               (  (x&0x1)<<13 )
+
+
+#define RGA2_SYS_CTRL_OFFSET             0x0
+#define RGA2_CMD_CTRL_OFFSET             0x4
+#define RGA2_CMD_BASE_OFFSET             0x8
+#define RGA2_STATUS_OFFSET               0xc
+#define RGA2_INT_OFFSET                  0x10
+#define RGA2_MMU_CTRL0_OFFSET            0x14
+#define RGA2_MMU_CMD_BASE_OFFSET         0x18
+
+#define RGA2_MODE_CTRL_OFFSET                   0x00
+#define RGA2_SRC_INFO_OFFSET                    0x04
+#define RGA2_SRC_BASE0_OFFSET                   0x08
+#define RGA2_SRC_BASE1_OFFSET                   0x0c
+#define RGA2_SRC_BASE2_OFFSET                   0x10
+#define RGA2_SRC_BASE3_OFFSET                   0x14
+#define RGA2_SRC_VIR_INFO_OFFSET                0x18
+#define RGA2_SRC_ACT_INFO_OFFSET                0x1c
+#define RGA2_SRC_X_FACTOR_OFFSET                0x20
+#define RGA2_SRC_Y_FACTOR_OFFSET                0x24
+#define RGA2_SRC_BG_COLOR_OFFSET                0x28
+#define RGA2_SRC_FG_COLOR_OFFSET                0x2c
+#define RGA2_SRC_TR_COLOR0_OFFSET               0x30
+#define RGA2_CF_GR_A_OFFSET                     0x30 // repeat
+#define RGA2_SRC_TR_COLOR1_OFFSET               0x34
+#define RGA2_CF_GR_B_OFFSET                     0x34 // repeat
+#define RGA2_DST_INFO_OFFSET                    0x38
+#define RGA2_DST_BASE0_OFFSET                   0x3c
+#define RGA2_DST_BASE1_OFFSET                   0x40
+#define RGA2_DST_BASE2_OFFSET                   0x44
+#define RGA2_DST_VIR_INFO_OFFSET                0x48
+#define RGA2_DST_ACT_INFO_OFFSET                0x4c
+#define RGA2_ALPHA_CTRL0_OFFSET                 0x50
+#define RGA2_ALPHA_CTRL1_OFFSET                 0x54
+#define RGA2_FADING_CTRL_OFFSET                 0x58
+#define RGA2_PAT_CON_OFFSET                     0x5c
+#define RGA2_ROP_CTRL0_OFFSET                   0x60
+#define RGA2_CF_GR_G_OFFSET                     0x60 // repeat
+#define RGA2_ROP_CTRL1_OFFSET                   0x64
+#define RGA2_CF_GR_R_OFFSET                     0x64 // repeat
+#define RGA2_MASK_BASE_OFFSET                   0x68
+#define RGA2_MMU_CTRL1_OFFSET                   0x6c
+#define RGA2_MMU_SRC_BASE_OFFSET                0x70
+#define RGA2_MMU_SRC1_BASE_OFFSET               0x74
+#define RGA2_MMU_DST_BASE_OFFSET                0x78
+#define RGA2_MMU_ELS_BASE_OFFSET                0x7c
+
+int RGA2_gen_reg_info(unsigned char *base, struct rga2_req *msg);
+void RGA_MSG_2_RGA2_MSG(struct rga_req *req_rga, struct rga2_req *req);
+void RGA_MSG_2_RGA2_MSG_32(struct rga_req_32 *req_rga, struct rga2_req *req);
+
+
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/rga2/rga2_rop.h b/drivers/video/rockchip/rga2/rga2_rop.h
--- a/drivers/video/rockchip/rga2/rga2_rop.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/rga2_rop.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RGA_ROP_H__
+#define __RGA_ROP_H__
+
+unsigned int rga2_ROP3_code[256] =
+{
+    0x00000007, 0x00000451, 0x00006051, 0x00800051, 0x00007041, 0x00800041, 0x00804830, 0x000004f0,//0
+    0x00800765, 0x000004b0, 0x00000065, 0x000004f4, 0x00000075, 0x000004e6, 0x00804850, 0x00800005,
+
+    0x00006850, 0x00800050, 0x00805028, 0x00000568, 0x00804031, 0x00000471, 0x002b6071, 0x018037aa,//1
+    0x008007aa, 0x00036071, 0x00002c6a, 0x00803631, 0x00002d68, 0x00802721, 0x008002d0, 0x000006d0,
+
+    0x0080066e, 0x00000528, 0x00000066, 0x0000056c, 0x018007aa, 0x0002e06a, 0x00003471, 0x00834031,//2
+    0x00800631, 0x0002b471, 0x00006071, 0x008037aa, 0x000036d0, 0x008002d4, 0x00002d28, 0x000006d4,
+
+    0x0000006e, 0x00000565, 0x00003451, 0x00800006, 0x000034f0, 0x00834830, 0x00800348, 0x00000748,//3
+    0x00002f48, 0x0080034c, 0x000034b0, 0x0000074c, 0x00000031, 0x00834850, 0x000034e6, 0x00800071,
+
+    0x008006f4, 0x00000431, 0x018007a1, 0x00b6e870, 0x00000074, 0x0000046e, 0x00002561, 0x00802f28,//4
+    0x00800728, 0x0002a561, 0x000026c2, 0x008002c6, 0x00007068, 0x018035aa, 0x00002c2a, 0x000006c6,
+
+    0x0000006c, 0x00000475, 0x000024e2, 0x008036b0, 0x00804051, 0x00800004, 0x00800251, 0x00000651,
+    0x00002e4a, 0x0080024e, 0x00000028, 0x00824842, 0x000024a2, 0x0000064e, 0x000024f4, 0x00800068,//5
+
+    0x008006b0, 0x000234f0, 0x00002741, 0x00800345, 0x00003651, 0x00800255, 0x00000030, 0x00834051,
+    0x00a34842, 0x000002b0, 0x00800271, 0x0002b651, 0x00800368, 0x0002a741, 0x0000364e, 0x00806830,//6
+
+    0x00006870, 0x008037a2, 0x00003431, 0x00000745, 0x00002521, 0x00000655, 0x0000346e, 0x00800062,
+    0x008002f0, 0x000236d0, 0x000026d4, 0x00807028, 0x000036c6, 0x00806031, 0x008005aa, 0x00000671,//7
+
+    0x00800671, 0x000005aa, 0x00006031, 0x008036c6, 0x00007028, 0x00802e55, 0x008236d0, 0x000002f0,
+    0x00000070, 0x0080346e, 0x00800655, 0x00802521, 0x00800745, 0x00803431, 0x000037a2, 0x00806870,//8
+
+    0x00006830, 0x0080364e, 0x00822f48, 0x00000361, 0x0082b651, 0x00000271, 0x00800231, 0x002b4051,
+    0x00034051, 0x00800030, 0x0080026e, 0x00803651, 0x0080036c, 0x00802741, 0x008234f0, 0x000006b0,//9
+
+    0x00000068, 0x00802c75, 0x0080064e, 0x008024a2, 0x0002c04a, 0x00800021, 0x00800275, 0x00802e51,
+    0x00800651, 0x00000251, 0x00800000, 0x00004051, 0x000036b0, 0x008024e2, 0x00800475, 0x00000045,//a
+
+    0x008006c6, 0x00802c2a, 0x000035aa, 0x00807068, 0x008002f4, 0x008026c2, 0x00822d68, 0x00000728,
+    0x00002f28, 0x00802561, 0x0080046e, 0x00000046, 0x00836870, 0x000007a2, 0x00800431, 0x00004071,//b
+
+    0x00000071, 0x008034e6, 0x00034850, 0x00800031, 0x0080074c, 0x008034b0, 0x00800365, 0x00802f48,
+    0x00800748, 0x00000341, 0x000026a2, 0x008034f0, 0x00800002, 0x00005048, 0x00800565, 0x00000055,//c
+
+    0x008006d4, 0x00802d28, 0x008002e6, 0x008036d0, 0x000037aa, 0x00806071, 0x0082b471, 0x00000631,
+    0x00002e2a, 0x00803471, 0x00826862, 0x010007aa, 0x0080056c, 0x00000054, 0x00800528, 0x00005068,//d
+
+    0x008006d0, 0x000002d0, 0x00002721, 0x00802d68, 0x00003631, 0x00802c6a, 0x00836071, 0x000007aa,
+    0x010037aa, 0x00a36870, 0x00800471, 0x00004031, 0x00800568, 0x00005028, 0x00000050, 0x00800545,//e
+
+    0x00800001, 0x00004850, 0x008004e6, 0x0000004e, 0x008004f4, 0x0000004c, 0x008004b0, 0x00004870,
+    0x008004f0, 0x00004830, 0x00000048, 0x0080044e, 0x00000051, 0x008004d4, 0x00800451, 0x00800007,//f
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/rga2/rga2_type.h b/drivers/video/rockchip/rga2/rga2_type.h
--- a/drivers/video/rockchip/rga2/rga2_type.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rga2/rga2_type.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RGA_TYPE_H__
+#define __RGA_TYPE_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+typedef  unsigned int     UWORD32;
+typedef  unsigned int     uint32;
+typedef  unsigned int     RK_U32;
+
+typedef  unsigned short   UWORD16;
+typedef  unsigned short   RK_U16;
+
+typedef  unsigned char    UBYTE;
+typedef  unsigned char    RK_U8;
+
+typedef  int              WORD32;
+typedef  int              RK_S32;
+
+typedef  short            WORD16;
+typedef  short            RK_S16;
+
+typedef  char             BYTE;
+typedef  char             RK_S8;
+
+
+#ifndef NULL
+#define NULL              0L
+#endif
+
+#ifndef TRUE
+#define TRUE              1L
+#endif
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* __RGA_TYPR_H__ */
+
diff -Nupr a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.c
--- a/drivers/video/rockchip/rk_fb.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rk_fb.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,4723 @@
+/*
+ * drivers/video/rockchip/rk_fb.c
+ *
+ * Copyright (C) ROCKCHIP, Inc.
+ * Author:yxj<yxj@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kthread.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <asm/div64.h>
+#include <linux/uaccess.h>
+#include <linux/rk_fb.h>
+#include <linux/linux_logo.h>
+#include <linux/dma-mapping.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_address.h>
+#include <linux/memblock.h>
+
+#include "bmp_helper.h"
+
+#if defined(CONFIG_RK_HDMI)
+#include "hdmi/rockchip-hdmi.h"
+#endif
+
+#if defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
+#include "rga/rga.h"
+#endif
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <video/of_display_timing.h>
+#include <video/display_timing.h>
+#endif
+
+#if defined(CONFIG_ION_ROCKCHIP)
+#include <linux/rockchip_ion.h>
+#include <linux/rockchip-iovmm.h>
+#include <linux/dma-buf.h>
+#include <linux/highmem.h>
+#endif
+
+#define H_USE_FENCE 1
+/* #define FB_ROATE_BY_KERNEL 1 */
+
+static int hdmi_switch_state;
+static struct platform_device *fb_pdev;
+
+#if defined(CONFIG_FB_MIRRORING)
+int (*video_data_to_mirroring)(struct fb_info *info, u32 yuv_phy[2]);
+EXPORT_SYMBOL(video_data_to_mirroring);
+#endif
+
+extern phys_addr_t uboot_logo_base;
+extern phys_addr_t uboot_logo_size;
+extern phys_addr_t uboot_logo_offset;
+static struct rk_fb_trsm_ops *trsm_lvds_ops;
+static struct rk_fb_trsm_ops *trsm_edp_ops;
+static struct rk_fb_trsm_ops *trsm_mipi_ops;
+static int uboot_logo_on;
+
+static int rk_fb_debug_lvl;
+static int rk_fb_iommu_debug;
+module_param(rk_fb_debug_lvl, int, S_IRUGO | S_IWUSR);
+module_param(rk_fb_iommu_debug, int, S_IRUGO | S_IWUSR);
+
+#define rk_fb_dbg(level, x...) do {		\
+	if (unlikely(rk_fb_debug_lvl >= level))	\
+		pr_info(x);			\
+	} while (0)
+static int rk_fb_config_debug(struct rk_lcdc_driver *dev_drv,
+			      struct rk_fb_win_cfg_data *win_data,
+			      struct rk_fb_reg_data *regs, u32 cmd);
+static int car_reversing;
+
+static int is_car_camcap(void) {
+	return car_reversing && strcmp("camcap", current->comm);
+}
+
+int support_uboot_display(void)
+{
+	return uboot_logo_on;
+}
+
+int rk_fb_get_display_policy(void)
+{
+	struct rk_fb *rk_fb;
+
+	if (fb_pdev) {
+		rk_fb = platform_get_drvdata(fb_pdev);
+		return rk_fb->disp_policy;
+	} else {
+		return DISPLAY_POLICY_SDK;
+	}
+}
+
+int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type)
+{
+	switch (type) {
+	case SCREEN_RGB:
+	case SCREEN_LVDS:
+	case SCREEN_DUAL_LVDS:
+	case SCREEN_LVDS_10BIT:
+	case SCREEN_DUAL_LVDS_10BIT:
+		trsm_lvds_ops = ops;
+		break;
+	case SCREEN_EDP:
+		trsm_edp_ops = ops;
+		break;
+	case SCREEN_MIPI:
+	case SCREEN_DUAL_MIPI:
+		trsm_mipi_ops = ops;
+		break;
+	default:
+		pr_warn("%s: unsupported transmitter: %d!\n",
+			__func__, type);
+		break;
+	}
+	return 0;
+}
+
+struct rk_fb_trsm_ops *rk_fb_trsm_ops_get(int type)
+{
+	struct rk_fb_trsm_ops *ops;
+
+	switch (type) {
+	case SCREEN_RGB:
+	case SCREEN_LVDS:
+	case SCREEN_DUAL_LVDS:
+	case SCREEN_LVDS_10BIT:
+	case SCREEN_DUAL_LVDS_10BIT:
+		ops = trsm_lvds_ops;
+		break;
+	case SCREEN_EDP:
+		ops = trsm_edp_ops;
+		break;
+	case SCREEN_MIPI:
+	case SCREEN_DUAL_MIPI:
+		ops = trsm_mipi_ops;
+		break;
+	default:
+		ops = NULL;
+		pr_warn("%s: unsupported transmitter: %d!\n",
+			__func__, type);
+		break;
+	}
+	return ops;
+}
+
+int rk_fb_pixel_width(int data_format)
+{
+	int pixel_width;
+
+	switch (data_format) {
+	case XBGR888:
+	case XRGB888:
+	case ABGR888:
+	case ARGB888:
+	case FBDC_ARGB_888:
+	case FBDC_ABGR_888:
+	case FBDC_RGBX_888:
+		pixel_width = 4 * 8;
+		break;
+	case RGB888:
+	case BGR888:
+		pixel_width = 3 * 8;
+		break;
+	case RGB565:
+	case BGR565:
+	case FBDC_RGB_565:
+		pixel_width = 2 * 8;
+		break;
+	case YUV422:
+	case YUV420:
+	case YUV420_NV21:
+	case YUV444:
+		pixel_width = 1 * 8;
+		break;
+	case YUV422_A:
+	case YUV420_A:
+	case YUV444_A:
+		pixel_width = 8;
+		break;
+	case YUYV422:
+	case UYVY422:
+	case YUYV420:
+	case UYVY420:
+		pixel_width = 16;
+		break;
+	default:
+		pr_warn("%s: unsupported format: 0x%x\n",
+			__func__, data_format);
+		return -EINVAL;
+	}
+	return pixel_width;
+}
+
+static int rk_fb_data_fmt(int data_format, int bits_per_pixel)
+{
+	int fb_data_fmt = 0;
+
+	if (data_format) {
+		switch (data_format) {
+		case HAL_PIXEL_FORMAT_RGBX_8888:
+			fb_data_fmt = XBGR888;
+			break;
+		case HAL_PIXEL_FORMAT_BGRX_8888:
+			fb_data_fmt = XRGB888;
+			break;
+		case HAL_PIXEL_FORMAT_RGBA_8888:
+			fb_data_fmt = ABGR888;
+			break;
+		case HAL_PIXEL_FORMAT_BGRA_8888:
+			fb_data_fmt = ARGB888;
+			break;
+		case HAL_PIXEL_FORMAT_RGB_888:
+			fb_data_fmt = RGB888;
+			break;
+		case HAL_PIXEL_FORMAT_BGR_888:
+			fb_data_fmt = BGR888;
+			break;
+		case HAL_PIXEL_FORMAT_RGB_565:
+			fb_data_fmt = RGB565;
+			break;
+		case HAL_PIXEL_FORMAT_BGR_565:
+			fb_data_fmt = BGR565;
+			break;
+		case HAL_PIXEL_FORMAT_YCbCr_422_SP:	/* yuv422 */
+			fb_data_fmt = YUV422;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_420_SP:	/* YUV420---vuvuvu */
+			fb_data_fmt = YUV420_NV21;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_NV12:	/* YUV420---uvuvuv */
+			fb_data_fmt = YUV420;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_444:	/* yuv444 */
+			fb_data_fmt = YUV444;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_NV12_10:	/* yuv444 */
+			fb_data_fmt = YUV420_A;
+			break;
+		case HAL_PIXEL_FORMAT_YCbCr_422_SP_10:	/* yuv444 */
+			fb_data_fmt = YUV422_A;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_444_SP_10:	/* yuv444 */
+			fb_data_fmt = YUV444_A;
+			break;
+		case HAL_PIXEL_FORMAT_FBDC_RGB565:	/* fbdc rgb565*/
+			fb_data_fmt = FBDC_RGB_565;
+			break;
+		case HAL_PIXEL_FORMAT_FBDC_U8U8U8U8:	/* fbdc argb888 */
+			fb_data_fmt = FBDC_ARGB_888;
+			break;
+		case HAL_PIXEL_FORMAT_FBDC_RGBA888:	/* fbdc abgr888 */
+			fb_data_fmt = FBDC_ABGR_888;
+			break;
+		case HAL_PIXEL_FORMAT_FBDC_U8U8U8:	/* fbdc rgb888 */
+			fb_data_fmt = FBDC_RGBX_888;
+			break;
+		case HAL_PIXEL_FORMAT_YUYV422:		/* yuyv422 */
+			fb_data_fmt = YUYV422;
+			break;
+		case HAL_PIXEL_FORMAT_YUYV420:		/* yuyv420 */
+			fb_data_fmt = YUYV420;
+			break;
+		case HAL_PIXEL_FORMAT_UYVY422:		/* uyvy422 */
+			fb_data_fmt = UYVY422;
+			break;
+		case HAL_PIXEL_FORMAT_UYVY420:		/* uyvy420 */
+			fb_data_fmt = UYVY420;
+			break;
+		default:
+			pr_warn("%s: unsupported format: 0x%x\n",
+				__func__, data_format);
+			return -EINVAL;
+		}
+	} else {
+		switch (bits_per_pixel) {
+		case 32:
+			fb_data_fmt = ARGB888;
+			break;
+		case 24:
+			fb_data_fmt = RGB888;
+			break;
+		case 16:
+			fb_data_fmt = RGB565;
+			break;
+		default:
+			pr_warn("%s: unsupported bits_per_pixel: %d\n",
+				__func__, bits_per_pixel);
+			break;
+		}
+	}
+	return fb_data_fmt;
+}
+
+/*
+ * rk display power control parse from dts
+ */
+int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)
+{
+	struct device_node *root = of_get_child_by_name(dev_drv->dev->of_node,
+							"power_ctr");
+	struct device_node *child;
+	struct rk_disp_pwr_ctr_list *pwr_ctr;
+	struct list_head *pos;
+	enum of_gpio_flags flags;
+	u32 val = 0;
+	u32 debug = 0;
+	int ret;
+
+	INIT_LIST_HEAD(&dev_drv->pwrlist_head);
+	if (!root) {
+		dev_err(dev_drv->dev, "can't find power_ctr node for lcdc%d\n",
+			dev_drv->id);
+		return -ENODEV;
+	}
+
+	for_each_child_of_node(root, child) {
+		pwr_ctr = kmalloc(sizeof(struct rk_disp_pwr_ctr_list),
+				  GFP_KERNEL);
+		if (!pwr_ctr)
+			return -ENOMEM;
+		strcpy(pwr_ctr->pwr_ctr.name, child->name);
+		if (!of_property_read_u32(child, "rockchip,power_type", &val)) {
+			if (val == GPIO) {
+				pwr_ctr->pwr_ctr.type = GPIO;
+				pwr_ctr->pwr_ctr.gpio = of_get_gpio_flags(child, 0, &flags);
+				if (!gpio_is_valid(pwr_ctr->pwr_ctr.gpio)) {
+					dev_err(dev_drv->dev, "%s ivalid gpio\n",
+						child->name);
+					return -EINVAL;
+				}
+				pwr_ctr->pwr_ctr.atv_val = !(flags & OF_GPIO_ACTIVE_LOW);
+				ret = gpio_request(pwr_ctr->pwr_ctr.gpio,
+						   child->name);
+				if (ret) {
+					dev_err(dev_drv->dev,
+						"request %s gpio fail:%d\n",
+						child->name, ret);
+				}
+
+			} else {
+				pwr_ctr->pwr_ctr.type = REGULATOR;
+				pwr_ctr->pwr_ctr.rgl_name = NULL;
+				ret = of_property_read_string(child, "rockchip,regulator_name",
+							      &(pwr_ctr->pwr_ctr.rgl_name));
+				if (ret || IS_ERR_OR_NULL(pwr_ctr->pwr_ctr.rgl_name))
+					dev_err(dev_drv->dev, "get regulator name failed!\n");
+				if (!of_property_read_u32(child, "rockchip,regulator_voltage", &val))
+					pwr_ctr->pwr_ctr.volt = val;
+				else
+					pwr_ctr->pwr_ctr.volt = 0;
+			}
+		};
+
+		if (!of_property_read_u32(child, "rockchip,delay", &val))
+			pwr_ctr->pwr_ctr.delay = val;
+		else
+			pwr_ctr->pwr_ctr.delay = 0;
+		list_add_tail(&pwr_ctr->list, &dev_drv->pwrlist_head);
+	}
+
+	of_property_read_u32(root, "rockchip,debug", &debug);
+
+	if (debug) {
+		list_for_each(pos, &dev_drv->pwrlist_head) {
+			pwr_ctr = list_entry(pos, struct rk_disp_pwr_ctr_list,
+					     list);
+			pr_info("pwr_ctr_name:%s\n"
+				"pwr_type:%s\n"
+				"gpio:%d\n"
+				"atv_val:%d\n"
+				"delay:%d\n\n",
+				pwr_ctr->pwr_ctr.name,
+				(pwr_ctr->pwr_ctr.type == GPIO) ? "gpio" : "regulator",
+				pwr_ctr->pwr_ctr.gpio,
+				pwr_ctr->pwr_ctr.atv_val,
+				pwr_ctr->pwr_ctr.delay);
+		}
+	}
+
+	return 0;
+}
+
+int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv)
+{
+	struct list_head *pos;
+	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
+	struct pwr_ctr *pwr_ctr;
+	struct regulator *regulator_lcd = NULL;
+	int count = 10;
+
+	if (list_empty(&dev_drv->pwrlist_head))
+		return 0;
+	list_for_each(pos, &dev_drv->pwrlist_head) {
+		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list,
+					  list);
+		pwr_ctr = &pwr_ctr_list->pwr_ctr;
+		if (pwr_ctr->type == GPIO) {
+			gpio_direction_output(pwr_ctr->gpio, pwr_ctr->atv_val);
+			mdelay(pwr_ctr->delay);
+		} else if (pwr_ctr->type == REGULATOR) {
+			if (pwr_ctr->rgl_name)
+				regulator_lcd =
+					regulator_get(NULL, pwr_ctr->rgl_name);
+			if (regulator_lcd == NULL) {
+				dev_err(dev_drv->dev,
+					"%s: regulator get failed,regulator name:%s\n",
+					__func__, pwr_ctr->rgl_name);
+				continue;
+			}
+			regulator_set_voltage(regulator_lcd, pwr_ctr->volt, pwr_ctr->volt);
+			while (!regulator_is_enabled(regulator_lcd)) {
+				if (regulator_enable(regulator_lcd) == 0 || count == 0)
+					break;
+				else
+					dev_err(dev_drv->dev,
+						"regulator_enable failed,count=%d\n",
+						count);
+				count--;
+			}
+			regulator_put(regulator_lcd);
+			msleep(pwr_ctr->delay);
+		}
+	}
+
+	return 0;
+}
+
+int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv)
+{
+	struct list_head *pos;
+	struct rk_disp_pwr_ctr_list *pwr_ctr_list;
+	struct pwr_ctr *pwr_ctr;
+	struct regulator *regulator_lcd = NULL;
+	int count = 10;
+
+	if (list_empty(&dev_drv->pwrlist_head))
+		return 0;
+	list_for_each(pos, &dev_drv->pwrlist_head) {
+		pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list,
+					  list);
+		pwr_ctr = &pwr_ctr_list->pwr_ctr;
+		if (pwr_ctr->type == GPIO) {
+			gpio_set_value(pwr_ctr->gpio, !pwr_ctr->atv_val);
+		} else if (pwr_ctr->type == REGULATOR) {
+			if (pwr_ctr->rgl_name)
+				regulator_lcd = regulator_get(NULL, pwr_ctr->rgl_name);
+			if (regulator_lcd == NULL) {
+				dev_err(dev_drv->dev,
+					"%s: regulator get failed,regulator name:%s\n",
+					__func__, pwr_ctr->rgl_name);
+				continue;
+			}
+			while (regulator_is_enabled(regulator_lcd) > 0) {
+				if (regulator_disable(regulator_lcd) == 0 ||
+				    count == 0)
+					break;
+				else
+					dev_err(dev_drv->dev,
+						"regulator_disable failed,count=%d\n",
+						count);
+				count--;
+			}
+			regulator_put(regulator_lcd);
+		}
+	}
+	return 0;
+}
+
+int rk_fb_video_mode_from_timing(const struct display_timing *dt,
+				 struct rk_screen *screen)
+{
+	screen->mode.pixclock = dt->pixelclock.typ;
+	screen->mode.left_margin = dt->hback_porch.typ;
+	screen->mode.right_margin = dt->hfront_porch.typ;
+	screen->mode.xres = dt->hactive.typ;
+	screen->mode.hsync_len = dt->hsync_len.typ;
+	screen->mode.upper_margin = dt->vback_porch.typ;
+	screen->mode.lower_margin = dt->vfront_porch.typ;
+	screen->mode.yres = dt->vactive.typ;
+	screen->mode.vsync_len = dt->vsync_len.typ;
+	screen->type = dt->screen_type;
+	screen->refresh_mode = dt->refresh_mode;
+	screen->lvds_format = dt->lvds_format;
+	screen->face = dt->face;
+	screen->color_mode = dt->color_mode;
+	screen->width = dt->screen_widt;
+	screen->height = dt->screen_hight;
+	screen->dsp_lut = dt->dsp_lut;
+	screen->cabc_lut = dt->cabc_lut;
+	screen->cabc_gamma_base = dt->cabc_gamma_base;
+
+	if (dt->flags & DISPLAY_FLAGS_INTERLACED)
+		screen->mode.vmode |= FB_VMODE_INTERLACED;
+	if (dt->flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
+		screen->pin_dclk = 1;
+	else
+		screen->pin_dclk = 0;
+	if (dt->flags & DISPLAY_FLAGS_HSYNC_HIGH)
+		screen->pin_hsync = 1;
+	else
+		screen->pin_hsync = 0;
+	if (dt->flags & DISPLAY_FLAGS_VSYNC_HIGH)
+		screen->pin_vsync = 1;
+	else
+		screen->pin_vsync = 0;
+	if (dt->flags & DISPLAY_FLAGS_DE_HIGH)
+		screen->pin_den = 1;
+	else
+		screen->pin_den = 0;
+
+	return 0;
+}
+
+int rk_fb_prase_timing_dt(struct device_node *np, struct rk_screen *screen)
+{
+	struct display_timings *disp_timing;
+	struct display_timing *dt;
+
+	disp_timing = of_get_display_timings(np);
+	if (!disp_timing) {
+		pr_err("parse display timing err\n");
+		return -EINVAL;
+	}
+	dt = display_timings_get(disp_timing, disp_timing->native_mode);
+	rk_fb_video_mode_from_timing(dt, screen);
+
+	return 0;
+}
+
+int rk_fb_calc_fps(struct rk_screen *screen, u32 pixclock)
+{
+	int x, y;
+	unsigned long long hz;
+
+	if (!screen) {
+		pr_err("%s:null screen!\n", __func__);
+		return 0;
+	}
+	x = screen->mode.xres + screen->mode.left_margin +
+	    screen->mode.right_margin + screen->mode.hsync_len;
+	y = screen->mode.yres + screen->mode.upper_margin +
+	    screen->mode.lower_margin + screen->mode.vsync_len;
+
+	hz = 1000000000000ULL;	/* 1e12 picoseconds per second */
+
+	hz += (x * y) / 2;
+	do_div(hz, x * y);	/* divide by x * y with rounding */
+
+	hz += pixclock / 2;
+	do_div(hz, pixclock);	/* divide by pixclock with rounding */
+
+	return hz;
+}
+
+char *get_format_string(enum data_format format, char *fmt)
+{
+	if (!fmt)
+		return NULL;
+	switch (format) {
+	case ARGB888:
+		strcpy(fmt, "ARGB888");
+		break;
+	case RGB888:
+		strcpy(fmt, "RGB888");
+		break;
+	case BGR888:
+		strcpy(fmt, "BGR888");
+		break;
+	case RGB565:
+		strcpy(fmt, "RGB565");
+		break;
+	case BGR565:
+		strcpy(fmt, "BGR565");
+		break;
+	case YUV420:
+	case YUV420_NV21:
+		strcpy(fmt, "YUV420");
+		break;
+	case YUV422:
+		strcpy(fmt, "YUV422");
+		break;
+	case YUV444:
+		strcpy(fmt, "YUV444");
+		break;
+	case YUV420_A:
+		strcpy(fmt, "YUV420_A");
+		break;
+	case YUV422_A:
+		strcpy(fmt, "YUV422_A");
+		break;
+	case YUV444_A:
+		strcpy(fmt, "YUV444_A");
+		break;
+	case XRGB888:
+		strcpy(fmt, "XRGB888");
+		break;
+	case XBGR888:
+		strcpy(fmt, "XBGR888");
+		break;
+	case ABGR888:
+		strcpy(fmt, "ABGR888");
+		break;
+	case FBDC_RGB_565:
+		strcpy(fmt, "FBDC_RGB_565");
+		break;
+	case FBDC_ARGB_888:
+	case FBDC_ABGR_888:
+		strcpy(fmt, "FBDC_ARGB_888");
+		break;
+	case FBDC_RGBX_888:
+		strcpy(fmt, "FBDC_RGBX_888");
+		break;
+	case YUYV422:
+		strcpy(fmt, "YUYV422");
+		break;
+	case YUYV420:
+		strcpy(fmt, "YUYV420");
+		break;
+	case UYVY422:
+		strcpy(fmt, "UYVY422");
+		break;
+	case UYVY420:
+		strcpy(fmt, "UYVY420");
+		break;
+	default:
+		strcpy(fmt, "invalid");
+		break;
+	}
+
+	return fmt;
+}
+
+int rk_fb_set_vop_pwm(void)
+{
+	int i = 0;
+	struct rk_fb *inf = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
+
+	if (likely(fb_pdev))
+		inf = platform_get_drvdata(fb_pdev);
+	else
+		return -1;
+
+	for (i = 0; i < inf->num_lcdc; i++) {
+		if (inf->lcdc_dev_drv[i]->cabc_mode == 1) {
+			dev_drv = inf->lcdc_dev_drv[i];
+			break;
+		}
+	}
+
+	if (!dev_drv)
+		return -1;
+
+	mutex_lock(&dev_drv->win_config);
+	if (dev_drv->ops->extern_func)
+		dev_drv->ops->extern_func(dev_drv, UPDATE_CABC_PWM);
+	mutex_unlock(&dev_drv->win_config);
+
+	return 0;
+}
+
+/*
+ * this is for hdmi
+ * name: lcdc device name ,lcdc0 , lcdc1
+ */
+struct rk_lcdc_driver *rk_get_lcdc_drv(char *name)
+{
+	struct rk_fb *inf = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
+	int i = 0;
+
+	if (likely(fb_pdev))
+		inf = platform_get_drvdata(fb_pdev);
+	else
+		return NULL;
+
+	for (i = 0; i < inf->num_lcdc; i++) {
+		if (!strcmp(inf->lcdc_dev_drv[i]->name, name)) {
+			dev_drv = inf->lcdc_dev_drv[i];
+			break;
+		}
+	}
+
+	return dev_drv;
+}
+
+static struct rk_lcdc_driver *rk_get_prmry_lcdc_drv(void)
+{
+	struct rk_fb *inf = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
+	int i = 0;
+
+	if (likely(fb_pdev))
+		inf = platform_get_drvdata(fb_pdev);
+	else
+		return NULL;
+
+	for (i = 0; i < inf->num_lcdc; i++) {
+		if (inf->lcdc_dev_drv[i]->prop == PRMRY) {
+			dev_drv = inf->lcdc_dev_drv[i];
+			break;
+		}
+	}
+
+	return dev_drv;
+}
+
+static __maybe_unused struct rk_lcdc_driver *rk_get_extend_lcdc_drv(void)
+{
+	struct rk_fb *inf = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
+	int i = 0;
+
+	if (likely(fb_pdev))
+		inf = platform_get_drvdata(fb_pdev);
+	else
+		return NULL;
+
+	for (i = 0; i < inf->num_lcdc; i++) {
+		if (inf->lcdc_dev_drv[i]->prop == EXTEND) {
+			dev_drv = inf->lcdc_dev_drv[i];
+			break;
+		}
+	}
+
+	return dev_drv;
+}
+
+/*
+ * get one frame time of the prmry screen, unit: us
+ */
+u32 rk_fb_get_prmry_screen_ft(void)
+{
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+	u32 htotal, vtotal, pixclock_ps;
+	u64 pix_total, ft_us;
+
+	if (unlikely(!dev_drv))
+		return 0;
+
+	pixclock_ps = dev_drv->pixclock;
+
+	vtotal = dev_drv->cur_screen->mode.upper_margin +
+		 dev_drv->cur_screen->mode.lower_margin +
+		 dev_drv->cur_screen->mode.yres +
+		 dev_drv->cur_screen->mode.vsync_len;
+	htotal = dev_drv->cur_screen->mode.left_margin +
+		 dev_drv->cur_screen->mode.right_margin +
+		 dev_drv->cur_screen->mode.xres +
+		 dev_drv->cur_screen->mode.hsync_len;
+	pix_total = htotal * vtotal;
+	ft_us = pix_total * pixclock_ps;
+	do_div(ft_us, 1000000);
+	if (dev_drv->frame_time.ft == 0)
+		dev_drv->frame_time.ft = ft_us;
+
+	ft_us = dev_drv->frame_time.framedone_t - dev_drv->frame_time.last_framedone_t;
+	do_div(ft_us, 1000);
+	ft_us = min(dev_drv->frame_time.ft, (u32)ft_us);
+	if (ft_us != 0)
+		dev_drv->frame_time.ft = ft_us;
+
+	return dev_drv->frame_time.ft;
+}
+
+/*
+ * get the vblanking time of the prmry screen, unit: us
+ */
+u32 rk_fb_get_prmry_screen_vbt(void)
+{
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+	u32 htotal, vblank, pixclock_ps;
+	u64 pix_blank, vbt_us;
+
+	if (unlikely(!dev_drv))
+		return 0;
+
+	pixclock_ps = dev_drv->pixclock;
+
+	htotal = (dev_drv->cur_screen->mode.left_margin +
+		  dev_drv->cur_screen->mode.right_margin +
+		  dev_drv->cur_screen->mode.xres +
+		  dev_drv->cur_screen->mode.hsync_len);
+	vblank = (dev_drv->cur_screen->mode.upper_margin +
+		  dev_drv->cur_screen->mode.lower_margin +
+		  dev_drv->cur_screen->mode.vsync_len);
+	pix_blank = htotal * vblank;
+	vbt_us = pix_blank * pixclock_ps;
+	do_div(vbt_us, 1000000);
+	return (u32)vbt_us;
+}
+
+/*
+ * get the frame done time of the prmry screen, unit: us
+ */
+u64 rk_fb_get_prmry_screen_framedone_t(void)
+{
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+
+	if (unlikely(!dev_drv))
+		return 0;
+	else
+		return dev_drv->frame_time.framedone_t;
+}
+
+/*
+ * set prmry screen status
+ */
+int rk_fb_set_prmry_screen_status(int status)
+{
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+	struct rk_screen *screen;
+
+	if (unlikely(!dev_drv))
+		return 0;
+
+	screen = dev_drv->cur_screen;
+	switch (status) {
+	case SCREEN_PREPARE_DDR_CHANGE:
+		if (screen->type == SCREEN_MIPI ||
+		    screen->type == SCREEN_DUAL_MIPI) {
+			if (dev_drv->trsm_ops->dsp_pwr_off)
+				dev_drv->trsm_ops->dsp_pwr_off();
+		}
+		break;
+	case SCREEN_UNPREPARE_DDR_CHANGE:
+		if (screen->type == SCREEN_MIPI ||
+		    screen->type == SCREEN_DUAL_MIPI) {
+			if (dev_drv->trsm_ops->dsp_pwr_on)
+				dev_drv->trsm_ops->dsp_pwr_on();
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+u32 rk_fb_get_prmry_screen_pixclock(void)
+{
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+
+	if (unlikely(!dev_drv))
+		return 0;
+	else
+		return dev_drv->pixclock;
+}
+
+int rk_fb_poll_prmry_screen_vblank(void)
+{
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+
+	if (likely(dev_drv)) {
+		if (dev_drv->ops->poll_vblank)
+			return dev_drv->ops->poll_vblank(dev_drv);
+		else
+			return RK_LF_STATUS_NC;
+	} else {
+		return RK_LF_STATUS_NC;
+	}
+}
+
+bool rk_fb_poll_wait_frame_complete(void)
+{
+	uint32_t timeout = RK_LF_MAX_TIMEOUT;
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+
+	if (likely(dev_drv)) {
+		if (dev_drv->ops->set_irq_to_cpu)
+			dev_drv->ops->set_irq_to_cpu(dev_drv, 0);
+	}
+
+	if (rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_NC) {
+		if (likely(dev_drv)) {
+			if (dev_drv->ops->set_irq_to_cpu)
+				dev_drv->ops->set_irq_to_cpu(dev_drv, 1);
+		}
+		return false;
+	}
+	while (!(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_FR) && --timeout)
+		;
+	while (!(rk_fb_poll_prmry_screen_vblank() == RK_LF_STATUS_FC) && --timeout)
+		;
+	if (likely(dev_drv)) {
+		if (dev_drv->ops->set_irq_to_cpu)
+			dev_drv->ops->set_irq_to_cpu(dev_drv, 1);
+	}
+
+	return true;
+}
+
+/* rk_fb_get_sysmmu_device_by_compatible()
+ * @compt: dts device compatible name
+ * return value: success: pointer to the device inside of platform device
+ *               fail: NULL
+ */
+struct device *rk_fb_get_sysmmu_device_by_compatible(const char *compt)
+{
+	struct device_node *dn = NULL;
+	struct platform_device *pd = NULL;
+	struct device *ret = NULL ;
+
+	dn = of_find_compatible_node(NULL, NULL, compt);
+	if (!dn) {
+		pr_info("can't find device node %s \r\n", compt);
+		return NULL;
+	}
+
+	pd = of_find_device_by_node(dn);
+	if (!pd) {
+		pr_info("can't find platform device node %s \r\n", compt);
+		return  NULL;
+	}
+	ret = &pd->dev;
+
+	return ret;
+}
+
+#ifdef CONFIG_IOMMU_API
+void rk_fb_platform_set_sysmmu(struct device *sysmmu, struct device *dev)
+{
+	dev->archdata.iommu = sysmmu;
+}
+#else
+void rk_fb_platform_set_sysmmu(struct device *sysmmu, struct device *dev)
+{
+}
+#endif
+
+static int rk_fb_open(struct fb_info *info, int user)
+{
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int win_id;
+
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
+	fb_par->state++;
+	/* if this win aready opened ,no need to reopen */
+	if (dev_drv->win[win_id]->state)
+		return 0;
+	else
+		dev_drv->ops->open(dev_drv, win_id, 1);
+	return 0;
+}
+
+static int rk_fb_close(struct fb_info *info, int user)
+{
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_lcdc_win *win = NULL;
+	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
+
+	if (win_id >= 0) {
+		win = dev_drv->win[win_id];
+		if (fb_par->state)
+			fb_par->state--;
+		if (!fb_par->state) {
+			if (fb_par->fb_phy_base > 0)
+				info->fix.smem_start = fb_par->fb_phy_base;
+			info->var.xres = dev_drv->screen0->mode.xres;
+			info->var.yres = dev_drv->screen0->mode.yres;
+			/*
+			 *info->var.grayscale |=
+			 *   (info->var.xres << 8) + (info->var.yres << 20);
+			 */
+			info->var.xres_virtual = info->var.xres;
+			info->var.yres_virtual = info->var.yres;
+#if defined(CONFIG_LOGO_LINUX_BMP)
+			info->var.bits_per_pixel = 32;
+#else
+			info->var.bits_per_pixel = 16;
+#endif
+			info->fix.line_length =
+			    (info->var.xres_virtual) *
+			    (info->var.bits_per_pixel >> 3);
+			info->var.width = dev_drv->screen0->width;
+			info->var.height = dev_drv->screen0->height;
+			info->var.pixclock = dev_drv->pixclock;
+			info->var.left_margin =
+				dev_drv->screen0->mode.left_margin;
+			info->var.right_margin =
+				dev_drv->screen0->mode.right_margin;
+			info->var.upper_margin =
+				dev_drv->screen0->mode.upper_margin;
+			info->var.lower_margin =
+				dev_drv->screen0->mode.lower_margin;
+			info->var.vsync_len = dev_drv->screen0->mode.vsync_len;
+			info->var.hsync_len = dev_drv->screen0->mode.hsync_len;
+		}
+	}
+
+	return 0;
+}
+
+#if defined(FB_ROATE_BY_KERNEL)
+
+#if defined(CONFIG_RK29_IPP)
+static int get_ipp_format(int fmt)
+{
+	int ipp_fmt = IPP_XRGB_8888;
+
+	switch (fmt) {
+	case HAL_PIXEL_FORMAT_RGBX_8888:
+	case HAL_PIXEL_FORMAT_BGRX_8888:
+	case HAL_PIXEL_FORMAT_RGBA_8888:
+	case HAL_PIXEL_FORMAT_BGRA_8888:
+	case HAL_PIXEL_FORMAT_RGB_888:
+	case HAL_PIXEL_FORMAT_BGR_888:
+		ipp_fmt = IPP_XRGB_8888;
+		break;
+	case HAL_PIXEL_FORMAT_RGB_565:
+	case HAL_PIXEL_FORMAT_BGR_565:
+		ipp_fmt = IPP_RGB_565;
+		break;
+	case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+		ipp_fmt = IPP_Y_CBCR_H2V1;
+		break;
+	case HAL_PIXEL_FORMAT_YCrCb_NV12:
+		ipp_fmt = IPP_Y_CBCR_H2V2;
+		break;
+	case HAL_PIXEL_FORMAT_YCrCb_444:
+		ipp_fmt = IPP_Y_CBCR_H1V1;
+		break;
+	default:
+		ipp_fmt = IPP_IMGTYPE_LIMIT;
+		break;
+	}
+
+	return ipp_fmt;
+}
+
+static void ipp_win_check(int *dst_w, int *dst_h, int *dst_vir_w,
+			  int rotation, int fmt)
+{
+	int align16 = 2;
+	int align64 = 8;
+
+	if (fmt == IPP_XRGB_8888) {
+		align16 = 1;
+		align64 = 2;
+	} else if (fmt == IPP_RGB_565) {
+		align16 = 1;
+		align64 = 4;
+	} else {
+		align16 = 2;
+		align64 = 8;
+	}
+	align16 -= 1;		/*for YUV, 1 */
+	align64 -= 1;		/*for YUV, 7 */
+
+	if (rotation == IPP_ROT_0) {
+		if (fmt > IPP_RGB_565) {
+			if ((*dst_w & 1) != 0)
+				*dst_w = *dst_w + 1;
+			if ((*dst_h & 1) != 0)
+				*dst_h = *dst_h + 1;
+			if (*dst_vir_w < *dst_w)
+				*dst_vir_w = *dst_w;
+		}
+	} else {
+		if ((*dst_w & align64) != 0)
+			*dst_w = (*dst_w + align64) & (~align64);
+		if ((fmt > IPP_RGB_565) && ((*dst_h & 1) == 1))
+			*dst_h = *dst_h + 1;
+		if (*dst_vir_w < *dst_w)
+			*dst_vir_w = *dst_w;
+	}
+}
+
+static void fb_copy_by_ipp(struct fb_info *dst_info,
+			   struct fb_info *src_info)
+{
+	struct rk29_ipp_req ipp_req;
+	uint32_t rotation = 0;
+	int dst_w, dst_h, dst_vir_w;
+	int ipp_fmt;
+	u8 data_format = (dst_info->var.nonstd) & 0xff;
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)dst_info->par;
+	struct rk_lcdc_driver *ext_dev_drv = fb_par->lcdc_drv;
+	u16 orientation = ext_dev_drv->rotate_mode;
+
+	memset(&ipp_req, 0, sizeof(struct rk29_ipp_req));
+
+	switch (orientation) {
+	case 0:
+		rotation = IPP_ROT_0;
+		break;
+	case ROTATE_90:
+		rotation = IPP_ROT_90;
+		break;
+	case ROTATE_180:
+		rotation = IPP_ROT_180;
+		break;
+	case ROTATE_270:
+		rotation = IPP_ROT_270;
+		break;
+	default:
+		rotation = IPP_ROT_270;
+		break;
+	}
+
+	dst_w = dst_info->var.xres;
+	dst_h = dst_info->var.yres;
+	dst_vir_w = dst_info->var.xres_virtual;
+	ipp_fmt = get_ipp_format(data_format);
+	ipp_win_check(&dst_w, &dst_h, &dst_vir_w, rotation, ipp_fmt);
+	ipp_req.src0.YrgbMst = src_info->fix.smem_start + offset;
+	ipp_req.src0.w = src_info->var.xres;
+	ipp_req.src0.h = src_info->var.yres;
+	ipp_req.src_vir_w = src_info->var.xres_virtual;
+	ipp_req.src0.fmt = ipp_fmt;
+
+	ipp_req.dst0.YrgbMst = dst_info->fix.smem_start + offset;
+	ipp_req.dst0.w = dst_w;
+	ipp_req.dst0.h = dst_h;
+	ipp_req.dst_vir_w = dst_vir_w;
+	ipp_req.dst0.fmt = ipp_fmt;
+
+	ipp_req.timeout = 100;
+	ipp_req.flag = rotation;
+	ipp_blit_sync(&ipp_req);
+}
+
+#endif
+
+#if defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
+static int get_rga_format(int fmt)
+{
+	int rga_fmt = 0;
+
+	switch (fmt) {
+	case XBGR888:
+		rga_fmt = RK_FORMAT_RGBX_8888;
+		break;
+	case ABGR888:
+		rga_fmt = RK_FORMAT_RGBA_8888;
+		break;
+	case ARGB888:
+		rga_fmt = RK_FORMAT_BGRA_8888;
+		break;
+	case RGB888:
+		rga_fmt = RK_FORMAT_RGB_888;
+		break;
+	case RGB565:
+		rga_fmt = RK_FORMAT_RGB_565;
+		break;
+	case YUV422:
+		rga_fmt = RK_FORMAT_YCbCr_422_SP;
+		break;
+	case YUV420:
+		rga_fmt = RK_FORMAT_YCbCr_420_SP;
+		break;
+	default:
+		rga_fmt = RK_FORMAT_RGBA_8888;
+		break;
+	}
+
+	return rga_fmt;
+}
+
+static void rga_win_check(struct rk_lcdc_win *dst_win,
+			  struct rk_lcdc_win *src_win)
+{
+	int format = 0;
+
+	format = get_rga_format(src_win->area[0].format);
+	/* width and height must be even number */
+	if (format >= RK_FORMAT_YCbCr_422_SP &&
+	    format <= RK_FORMAT_YCrCb_420_P) {
+		if ((src_win->area[0].xact % 2) != 0)
+			src_win->area[0].xact += 1;
+		if ((src_win->area[0].yact % 2) != 0)
+			src_win->area[0].yact += 1;
+	}
+	if (src_win->area[0].xvir < src_win->area[0].xact)
+		src_win->area[0].xvir = src_win->area[0].xact;
+	if (src_win->area[0].yvir < src_win->area[0].yact)
+		src_win->area[0].yvir = src_win->area[0].yact;
+
+	format = get_rga_format(dst_win->area[0].format);
+	if (format >= RK_FORMAT_YCbCr_422_SP &&
+	    format <= RK_FORMAT_YCrCb_420_P) {
+		if ((dst_win->area[0].xact % 2) != 0)
+			dst_win->area[0].xact += 1;
+		if ((dst_win->area[0].yact % 2) != 0)
+			dst_win->area[0].yact += 1;
+	}
+	if (dst_win->area[0].xvir < dst_win->area[0].xact)
+		dst_win->area[0].xvir = dst_win->area[0].xact;
+	if (dst_win->area[0].yvir < dst_win->area[0].yact)
+		dst_win->area[0].yvir = dst_win->area[0].yact;
+}
+
+static void win_copy_by_rga(struct rk_lcdc_win *dst_win,
+			    struct rk_lcdc_win *src_win,
+			    u16 orientation, int iommu_en)
+{
+	struct rga_req rga_request;
+	long ret = 0;
+	/* int fd = 0; */
+
+	memset(&rga_request, 0, sizeof(rga_request));
+	rga_win_check(dst_win, src_win);
+
+	switch (orientation) {
+	case ROTATE_90:
+		rga_request.rotate_mode = 1;
+		rga_request.sina = 65536;
+		rga_request.cosa = 0;
+		rga_request.dst.act_w = dst_win->area[0].yact;
+		rga_request.dst.act_h = dst_win->area[0].xact;
+		rga_request.dst.x_offset = dst_win->area[0].xact - 1;
+		rga_request.dst.y_offset = 0;
+		break;
+	case ROTATE_180:
+		rga_request.rotate_mode = 1;
+		rga_request.sina = 0;
+		rga_request.cosa = -65536;
+		rga_request.dst.act_w = dst_win->area[0].xact;
+		rga_request.dst.act_h = dst_win->area[0].yact;
+		rga_request.dst.x_offset = dst_win->area[0].xact - 1;
+		rga_request.dst.y_offset = dst_win->area[0].yact - 1;
+		break;
+	case ROTATE_270:
+		rga_request.rotate_mode = 1;
+		rga_request.sina = -65536;
+		rga_request.cosa = 0;
+		rga_request.dst.act_w = dst_win->area[0].yact;
+		rga_request.dst.act_h = dst_win->area[0].xact;
+		rga_request.dst.x_offset = 0;
+		rga_request.dst.y_offset = dst_win->area[0].yact - 1;
+		break;
+	default:
+		rga_request.rotate_mode = 0;
+		rga_request.dst.act_w = dst_win->area[0].xact;
+		rga_request.dst.act_h = dst_win->area[0].yact;
+		rga_request.dst.x_offset = dst_win->area[0].xact - 1;
+		rga_request.dst.y_offset = dst_win->area[0].yact - 1;
+		break;
+	}
+
+	/*
+	 * fd =
+	 *    ion_share_dma_buf_fd(rk_fb->ion_client, src_win->area[0].ion_hdl);
+	 * rga_request.src.yrgb_addr = fd;
+	 * fd =
+	 *    ion_share_dma_buf_fd(rk_fb->ion_client, dst_win->area[0].ion_hdl);
+	 * rga_request.dst.yrgb_addr = fd;
+	 */
+	rga_request.src.yrgb_addr = 0;
+	rga_request.src.uv_addr =
+	    src_win->area[0].smem_start + src_win->area[0].y_offset;
+	rga_request.src.v_addr = 0;
+
+	rga_request.dst.yrgb_addr = 0;
+	rga_request.dst.uv_addr =
+	    dst_win->area[0].smem_start + dst_win->area[0].y_offset;
+	rga_request.dst.v_addr = 0;
+
+	rga_request.src.vir_w = src_win->area[0].xvir;
+	rga_request.src.vir_h = src_win->area[0].yvir;
+	rga_request.src.format = get_rga_format(src_win->area[0].format);
+	rga_request.src.act_w = src_win->area[0].xact;
+	rga_request.src.act_h = src_win->area[0].yact;
+	rga_request.src.x_offset = 0;
+	rga_request.src.y_offset = 0;
+
+	rga_request.dst.vir_w = dst_win->area[0].xvir;
+	rga_request.dst.vir_h = dst_win->area[0].yvir;
+	rga_request.dst.format = get_rga_format(dst_win->area[0].format);
+
+	rga_request.clip.xmin = 0;
+	rga_request.clip.xmax = dst_win->area[0].xact - 1;
+	rga_request.clip.ymin = 0;
+	rga_request.clip.ymax = dst_win->area[0].yact - 1;
+	rga_request.scale_mode = 0;
+
+	if (iommu_en) {
+		rga_request.mmu_info.mmu_en = 1;
+		rga_request.mmu_info.mmu_flag = 1;
+	} else {
+		rga_request.mmu_info.mmu_en = 0;
+		rga_request.mmu_info.mmu_flag = 0;
+	}
+
+	ret = rga_ioctl_kernel(&rga_request);
+}
+
+/*
+ * This function is used for copying fb by RGA Module
+ * RGA only support copy RGB to RGB
+ * RGA2 support copy RGB to RGB and YUV to YUV
+ */
+static void fb_copy_by_rga(struct fb_info *dst_info,
+			   struct fb_info *src_info)
+{
+	struct rk_fb_par *src_fb_par = (struct rk_fb_par *)src_info->par;
+	struct rk_fb_par *dst_fb_par = (struct rk_fb_par *)dst_info->par;
+	struct rk_lcdc_driver *dev_drv = src_fb_par->lcdc_drv;
+	struct rk_lcdc_driver *ext_dev_drv = dst_fb_par->lcdc_drv;
+	int win_id = 0, ext_win_id;
+	struct rk_lcdc_win *src_win, *dst_win;
+
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, src_info->fix.id);
+	src_win = dev_drv->win[win_id];
+
+	ext_win_id =
+	    ext_dev_drv->ops->fb_get_win_id(ext_dev_drv, dst_info->fix.id);
+	dst_win = ext_dev_drv->win[ext_win_id];
+
+	win_copy_by_rga(dst_win, src_win, ext_dev_drv->rotate_mode,
+			ext_dev_drv->iommu_enabled);
+}
+#endif
+
+static int rk_fb_rotate(struct fb_info *dst_info,
+			struct fb_info *src_info)
+{
+#if defined(CONFIG_RK29_IPP)
+	fb_copy_by_ipp(dst_info, src_info);
+#elif defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
+	fb_copy_by_rga(dst_info, src_info);
+#else
+	return -1;
+#endif
+	return 0;
+}
+
+static int __maybe_unused rk_fb_win_rotate(struct rk_lcdc_win *dst_win,
+					   struct rk_lcdc_win *src_win,
+					   u16 rotate, int iommu_en)
+{
+#if defined(CONFIG_ROCKCHIP_RGA) || defined(CONFIG_ROCKCHIP_RGA2)
+	win_copy_by_rga(dst_win, src_win, rotate, iommu_en);
+#else
+	return -1;
+#endif
+	return 0;
+}
+
+#endif
+
+static int rk_fb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	int win_id = 0;
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u32 xoffset = var->xoffset;
+	u32 yoffset = var->yoffset;
+	u32 xvir = var->xres_virtual;
+	u8 pixel_width;
+	u32 vir_width_bit;
+	u32 stride, uv_stride;
+	u32 stride_32bit_1;
+	u32 stride_32bit_2;
+	u16 uv_x_off, uv_y_off, uv_y_act;
+	u8 is_pic_yuv = 0;
+
+	if (dev_drv->suspend_flag || is_car_camcap())
+		return 0;
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
+	if (win_id < 0)
+		return -ENODEV;
+	else
+		win = dev_drv->win[win_id];
+
+	pixel_width = rk_fb_pixel_width(win->area[0].format);
+	vir_width_bit = pixel_width * xvir;
+	stride_32bit_1 = ALIGN_N_TIMES(vir_width_bit, 32) / 8;
+	stride_32bit_2 = ALIGN_N_TIMES(vir_width_bit * 2, 32) / 8;
+
+	switch (win->area[0].format) {
+	case YUV422:
+	case YUV422_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_1;
+		uv_x_off = xoffset;
+		uv_y_off = yoffset;
+		fix->line_length = stride;
+		uv_y_act = win->area[0].yact >> 1;
+		break;
+	case YUV420:		/* nv12 */
+	case YUV420_NV21:	/* nv21 */
+	case YUV420_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_1;
+		uv_x_off = xoffset;
+		uv_y_off = yoffset >> 1;
+		fix->line_length = stride;
+		uv_y_act = win->area[0].yact >> 1;
+		break;
+	case YUV444:
+	case YUV444_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_2;
+		uv_x_off = xoffset * 2;
+		uv_y_off = yoffset;
+		fix->line_length = stride << 2;
+		uv_y_act = win->area[0].yact;
+		break;
+	default:
+		stride = stride_32bit_1;	/* default rgb */
+		fix->line_length = stride;
+		break;
+	}
+
+	/* x y mirror ,jump line */
+	if ((screen->y_mirror == 1) ||
+	    (win->xmirror && win->ymirror)) {
+		if (screen->interlace == 1) {
+			win->area[0].y_offset = yoffset * stride * 2 +
+			    ((win->area[0].yact - 1) * 2 + 1) * stride +
+			    xoffset * pixel_width / 8;
+		} else {
+			win->area[0].y_offset = yoffset * stride +
+			    (win->area[0].yact - 1) * stride +
+			    xoffset * pixel_width / 8;
+		}
+	} else {
+		if (screen->interlace == 1) {
+			win->area[0].y_offset =
+			    yoffset * stride * 2 + xoffset * pixel_width / 8;
+		} else {
+			win->area[0].y_offset =
+			    yoffset * stride + xoffset * pixel_width / 8;
+		}
+	}
+	if (is_pic_yuv == 1) {
+		if ((screen->y_mirror == 1) ||
+		    (win->xmirror && win->ymirror)) {
+			if (screen->interlace == 1) {
+				win->area[0].c_offset =
+				    uv_y_off * uv_stride * 2 +
+				    ((uv_y_act - 1) * 2 + 1) * uv_stride +
+				    uv_x_off * pixel_width / 8;
+			} else {
+				win->area[0].c_offset = uv_y_off * uv_stride +
+				    (uv_y_act - 1) * uv_stride +
+				    uv_x_off * pixel_width / 8;
+			}
+		} else {
+			if (screen->interlace == 1) {
+				win->area[0].c_offset =
+				    uv_y_off * uv_stride * 2 +
+				    uv_x_off * pixel_width / 8;
+			} else {
+				win->area[0].c_offset =
+				    uv_y_off * uv_stride +
+				    uv_x_off * pixel_width / 8;
+			}
+		}
+	}
+
+	win->area[0].smem_start = fix->smem_start;
+	win->area[0].cbr_start = fix->mmio_start;
+	win->area[0].state = 1;
+	win->area_num = 1;
+
+	dev_drv->ops->pan_display(dev_drv, win_id);
+
+#ifdef	CONFIG_FB_MIRRORING
+	if (video_data_to_mirroring)
+		video_data_to_mirroring(info, NULL);
+#endif
+	/* if not want the config effect,set reserved[3] bit[0] 1 */
+	if (likely((var->reserved[3] & 0x1) == 0))
+		dev_drv->ops->cfg_done(dev_drv);
+	if (dev_drv->hdmi_switch)
+		mdelay(100);
+	return 0;
+}
+
+static int rk_fb_get_list_stat(struct rk_lcdc_driver *dev_drv)
+{
+	int i, j;
+
+	i = list_empty(&dev_drv->update_regs_list);
+	j = list_empty(&dev_drv->saved_list);
+	return i == j ? 0 : 1;
+}
+
+void rk_fd_fence_wait(struct rk_lcdc_driver *dev_drv, struct sync_fence *fence)
+{
+	int err = sync_fence_wait(fence, 1000);
+
+	if (err >= 0)
+		return;
+
+	if (err == -ETIME)
+		err = sync_fence_wait(fence, 10 * MSEC_PER_SEC);
+
+	if (err < 0)
+		pr_info("error waiting on fence\n");
+}
+#if 0
+static int rk_fb_copy_from_loader(struct fb_info *info)
+{
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	void *dst = info->screen_base;
+	u32 dsp_addr[4];
+	u32 src;
+	u32 i, size;
+	int win_id;
+	struct rk_lcdc_win *win;
+
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
+	win = dev_drv->win[win_id];
+	size = (win->area[0].xact) * (win->area[0].yact) << 2;
+	dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
+	src = dsp_addr[win_id];
+	dev_info(info->dev, "copy fb data %d x %d  from  dst_addr:%08x\n",
+		 win->area[0].xact, win->area[0].yact, src);
+	for (i = 0; i < size; i += PAGE_SIZE) {
+		void *page = phys_to_page(i + src);
+		void *from_virt = kmap(page);
+		void *to_virt = dst + i;
+
+		memcpy(to_virt, from_virt, PAGE_SIZE);
+	}
+	dev_drv->ops->direct_set_addr(dev_drv, win_id,
+				      info->fix.smem_start);
+	return 0;
+}
+#endif
+static int g_last_addr[5][4];
+static int g_now_config_addr[5][4];
+static int g_last_state[5][4];
+static int g_now_config_state[5][4];
+int g_last_timeout;
+u32 freed_addr[10];
+u32 freed_index;
+
+#define DUMP_CHUNK 256
+char buf[PAGE_SIZE];
+
+int rk_fb_sysmmu_fault_handler(struct device *dev,
+			       enum rk_iommu_inttype itype,
+			       unsigned long pgtable_base,
+			       unsigned long fault_addr, unsigned int status)
+{
+	struct rk_lcdc_driver *dev_drv = rk_get_prmry_lcdc_drv();
+	int i = 0, j = 0;
+	static int page_fault_cnt;
+
+	if ((page_fault_cnt++) >= 10)
+		return 0;
+	pr_err
+	    ("PAGE FAULT occurred at 0x%lx (Page table base: 0x%lx),status=%d\n",
+	     fault_addr, pgtable_base, status);
+	pr_info("last config addr:\n");
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++)
+			pr_info("win[%d],area[%d] = 0x%08x\n",
+				i, j, g_last_addr[i][j]);
+	}
+	pr_info("last freed buffer:\n");
+	for (i = 0; (freed_addr[i] != 0xfefefefe) && freed_addr[i]; i++)
+		pr_info("%d:0x%08x\n", i, freed_addr[i]);
+	pr_info("last timeout:%d\n", g_last_timeout);
+	dev_drv->ops->get_disp_info(dev_drv, buf, 0);
+	for (i = 0; i < PAGE_SIZE; i += DUMP_CHUNK) {
+		if ((PAGE_SIZE - i) > DUMP_CHUNK) {
+			char c = buf[i + DUMP_CHUNK];
+
+			buf[i + DUMP_CHUNK] = 0;
+			pr_cont("%s", buf + i);
+			buf[i + DUMP_CHUNK] = c;
+		} else {
+			buf[PAGE_SIZE - 1] = 0;
+			pr_cont("%s", buf + i);
+		}
+	}
+
+	return 0;
+}
+
+void rk_fb_free_wb_buf(struct rk_lcdc_driver *dev_drv,
+		       struct rk_fb_reg_wb_data *wb_data)
+{
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+
+	if (dev_drv->iommu_enabled && wb_data->ion_handle)
+		ion_unmap_iommu(dev_drv->dev, rk_fb->ion_client,
+				wb_data->ion_handle);
+	if (wb_data->ion_handle)
+		ion_free(rk_fb->ion_client, wb_data->ion_handle);
+}
+
+void rk_fb_free_dma_buf(struct rk_lcdc_driver *dev_drv,
+			struct rk_fb_reg_win_data *reg_win_data)
+{
+	int i, index_buf;
+	struct rk_fb_reg_area_data *area_data;
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+
+	for (i = 0; i < reg_win_data->area_num; i++) {
+		area_data = &reg_win_data->reg_area_data[i];
+		index_buf = area_data->index_buf;
+		if (dev_drv->iommu_enabled) {
+			if (area_data->ion_handle != NULL &&
+			    !IS_YUV_FMT(area_data->data_format))
+				ion_unmap_iommu(dev_drv->dev, rk_fb->ion_client,
+						area_data->ion_handle);
+			freed_addr[freed_index++] = area_data->smem_start;
+		}
+		if (area_data->ion_handle != NULL)
+			ion_free(rk_fb->ion_client, area_data->ion_handle);
+
+		if (area_data->acq_fence)
+			sync_fence_put(area_data->acq_fence);
+	}
+}
+
+static void rk_fb_update_win(struct rk_lcdc_driver *dev_drv,
+			     struct rk_lcdc_win *win,
+			     struct rk_fb_reg_win_data *reg_win_data)
+{
+	int i = 0;
+	struct rk_fb *inf = platform_get_drvdata(fb_pdev);
+	struct rk_screen *cur_screen;
+	struct rk_screen primary_screen;
+
+	if (unlikely(!inf) || unlikely(!dev_drv) ||
+	    unlikely(!win) || unlikely(!reg_win_data))
+		return;
+
+	cur_screen = dev_drv->cur_screen;
+	rk_fb_get_prmry_screen(&primary_screen);
+
+	win->area_num = reg_win_data->area_num;
+	win->id = reg_win_data->win_id;
+	win->z_order = reg_win_data->z_order;
+
+	if (reg_win_data->reg_area_data[0].smem_start > 0) {
+		win->state = 1;
+		win->area_num = reg_win_data->area_num;
+		win->id = reg_win_data->win_id;
+		win->z_order = reg_win_data->z_order;
+		win->area[0].uv_vir_stride =
+		    reg_win_data->reg_area_data[0].uv_vir_stride;
+		win->area[0].cbr_start =
+		    reg_win_data->reg_area_data[0].cbr_start;
+		win->area[0].c_offset = reg_win_data->reg_area_data[0].c_offset;
+		win->alpha_en = reg_win_data->alpha_en;
+		win->alpha_mode = reg_win_data->alpha_mode;
+		win->g_alpha_val = reg_win_data->g_alpha_val;
+		/*
+		 * reg_win_data mirror_en means that xmirror ymirror all
+		 * enabled.
+		 */
+		win->xmirror = reg_win_data->mirror_en ? 1 : 0;
+		win->ymirror = reg_win_data->mirror_en ? 1 : 0;
+		win->colorspace = reg_win_data->colorspace;
+		win->area[0].fbdc_en =
+			reg_win_data->reg_area_data[0].fbdc_en;
+		win->area[0].fbdc_cor_en =
+			reg_win_data->reg_area_data[0].fbdc_cor_en;
+		win->area[0].fbdc_data_format =
+			reg_win_data->reg_area_data[0].fbdc_data_format;
+		for (i = 0; i < RK_WIN_MAX_AREA; i++) {
+			if (reg_win_data->reg_area_data[i].smem_start > 0) {
+				win->area[i].format =
+					reg_win_data->reg_area_data[i].data_format;
+				win->area[i].data_space =
+					reg_win_data->reg_area_data[i].data_space;
+				win->area[i].ion_hdl =
+					reg_win_data->reg_area_data[i].ion_handle;
+				win->area[i].smem_start =
+					reg_win_data->reg_area_data[i].smem_start;
+				if (inf->disp_mode == DUAL ||
+				    inf->disp_mode == DUAL_LCD ||
+				    inf->disp_mode == NO_DUAL) {
+					win->area[i].xpos =
+						reg_win_data->reg_area_data[i].xpos;
+					win->area[i].ypos =
+						reg_win_data->reg_area_data[i].ypos;
+					win->area[i].xsize =
+						reg_win_data->reg_area_data[i].xsize;
+					win->area[i].ysize =
+						reg_win_data->reg_area_data[i].ysize;
+				} else {
+					win->area[i].xpos =
+						reg_win_data->reg_area_data[i].xpos *
+						cur_screen->mode.xres /
+						primary_screen.mode.xres;
+					win->area[i].ypos =
+						reg_win_data->reg_area_data[i].ypos *
+						cur_screen->mode.yres /
+						primary_screen.mode.yres;
+					win->area[i].xsize =
+						reg_win_data->reg_area_data[i].xsize *
+						cur_screen->mode.xres /
+						primary_screen.mode.xres;
+					win->area[i].ysize =
+						reg_win_data->reg_area_data[i].ysize *
+						cur_screen->mode.yres /
+						primary_screen.mode.yres;
+
+					/* recalc display size if set hdmi scaler when at ONE_DUAL mode */
+					if (inf->disp_mode == ONE_DUAL && hdmi_switch_state) {
+						if (cur_screen->xsize > 0 &&
+						    cur_screen->xsize <= cur_screen->mode.xres) {
+							win->area[i].xpos =
+								((cur_screen->mode.xres - cur_screen->xsize) >> 1) +
+								cur_screen->xsize * win->area[i].xpos / cur_screen->mode.xres;
+							win->area[i].xsize =
+								win->area[i].xsize * cur_screen->xsize / cur_screen->mode.xres;
+						}
+						if (cur_screen->ysize > 0 && cur_screen->ysize <= cur_screen->mode.yres) {
+							win->area[i].ypos =
+								((cur_screen->mode.yres - cur_screen->ysize) >> 1) +
+								cur_screen->ysize * win->area[i].ypos / cur_screen->mode.yres;
+							win->area[i].ysize =
+								win->area[i].ysize * cur_screen->ysize / cur_screen->mode.yres;
+						}
+					}
+				}
+				win->area[i].xact =
+				    reg_win_data->reg_area_data[i].xact;
+				win->area[i].yact =
+				    reg_win_data->reg_area_data[i].yact;
+				win->area[i].xvir =
+				    reg_win_data->reg_area_data[i].xvir;
+				win->area[i].yvir =
+				    reg_win_data->reg_area_data[i].yvir;
+				win->area[i].xoff =
+				    reg_win_data->reg_area_data[i].xoff;
+				win->area[i].yoff =
+				    reg_win_data->reg_area_data[i].yoff;
+				win->area[i].y_offset =
+				    reg_win_data->reg_area_data[i].y_offset;
+				win->area[i].y_vir_stride =
+				    reg_win_data->reg_area_data[i].y_vir_stride;
+				win->area[i].state = 1;
+				if (dev_drv->iommu_enabled) {
+					g_now_config_addr[win->id][i] =
+						win->area[i].smem_start +
+						win->area[i].y_offset;
+					g_now_config_state[win->id][i] = 1;
+				}
+			} else {
+				win->area[i].state = 0;
+				win->area[i].fbdc_en = 0;
+				if (dev_drv->iommu_enabled) {
+					g_now_config_addr[win->id][i] = 0;
+					g_now_config_state[win->id][i] = 0;
+				}
+			}
+		}
+	}
+}
+
+static struct rk_fb_reg_win_data *rk_fb_get_win_data(struct rk_fb_reg_data
+						     *regs, int win_id)
+{
+	int i;
+	struct rk_fb_reg_win_data *win_data = NULL;
+
+	for (i = 0; i < regs->win_num; i++) {
+		if (regs->reg_win_data[i].win_id == win_id) {
+			win_data = &(regs->reg_win_data[i]);
+			break;
+		}
+	}
+
+	return win_data;
+}
+
+static int rk_fb_reg_effect(struct rk_lcdc_driver *dev_drv,
+			    struct rk_fb_reg_data *regs,
+			    int count)
+{
+	int i, j, wait_for_vsync = false;
+	unsigned int dsp_addr[5][4];
+	int win_status = 0;
+
+	if (dev_drv->ops->get_dsp_addr)
+		dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
+
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+			if ((j > 0) && (dev_drv->area_support[i] == 1))
+				continue;
+			if (dev_drv->win[i]->area[j].state == 1) {
+				u32 new_start =
+					dev_drv->win[i]->area[j].smem_start +
+					dev_drv->win[i]->area[j].y_offset;
+				u32 reg_start = dsp_addr[i][j];
+
+				if (unlikely(new_start != reg_start)) {
+					wait_for_vsync = true;
+					dev_info(dev_drv->dev,
+						 "win%d:new_addr:0x%08x cur_addr:0x%08x--%d\n",
+						 i, new_start, reg_start,
+						 101 - count);
+					break;
+				}
+			} else if (dev_drv->win[i]->area[j].state == 0) {
+				if (dev_drv->ops->get_win_state) {
+					win_status =
+					dev_drv->ops->get_win_state(dev_drv, i, j);
+					if (win_status) {
+						wait_for_vsync = true;
+						dev_info(dev_drv->dev,
+							 "win[%d]area[%d]: "
+							 "state: %d, "
+							 "cur state: %d,"
+							 "count: %d\n",
+							 i, j,
+							 dev_drv->win[i]->area[j].state,
+							 win_status,
+							 101 - count);
+					}
+				}
+			} else {
+				pr_err("!!!win[%d]state:%d,error!!!\n",
+				       i, dev_drv->win[i]->state);
+			}
+		}
+	}
+
+	return wait_for_vsync;
+}
+
+static int rk_fb_iommu_page_fault_dump(struct rk_lcdc_driver *dev_drv)
+{
+	int i, j, state, page_fault = 0;
+	unsigned int dsp_addr[5][4];
+
+	if (dev_drv->ops->extern_func) {
+		dev_drv->ops->extern_func(dev_drv, UNMASK_PAGE_FAULT);
+		page_fault = dev_drv->ops->extern_func(dev_drv, GET_PAGE_FAULT);
+	}
+	if (page_fault) {
+		pr_info("last config:\n");
+		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+				if ((j > 0) && (dev_drv->area_support[i] == 1))
+					continue;
+				pr_info("win[%d]area[%d],state=%d,addr=0x%08x\n",
+					i, j, g_last_state[i][j], g_last_addr[i][j]);
+			}
+		}
+
+		pr_info("last freed buffer:\n");
+		for (i = 0; (freed_addr[i] != 0xfefefefe) && freed_addr[i]; i++)
+			pr_info("%d:0x%08x\n", i, freed_addr[i]);
+
+		dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
+		pr_info("vop now state:\n");
+		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+				if ((j > 0) && (dev_drv->area_support[i] == 1))
+					continue;
+				state = dev_drv->ops->get_win_state(dev_drv, i, j);
+				pr_info("win[%d]area[%d],state=%d,addr=0x%08x\n",
+					i, j, state, dsp_addr[i][j]);
+			}
+		}
+		pr_info("now config:\n");
+		for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+				if ((j > 0) && (dev_drv->area_support[i] == 1))
+					continue;
+				pr_info("win[%d]area[%d],state=%d,addr=0x%08x\n",
+					i, j, g_now_config_state[i][j],
+					g_now_config_addr[i][j]);
+			}
+		}
+		for (i = 0; i < DUMP_FRAME_NUM; i++)
+			rk_fb_config_debug(dev_drv, &dev_drv->tmp_win_cfg[i],
+					   &dev_drv->tmp_regs[i], 0);
+	}
+
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+			if ((j > 0) && (dev_drv->area_support[i] == 1))
+				continue;
+			g_last_addr[i][j] = g_now_config_addr[i][j];
+			g_last_state[i][j] = g_now_config_state[i][j];
+		}
+	}
+
+	return page_fault;
+}
+static void rk_fb_update_reg(struct rk_lcdc_driver *dev_drv,
+			     struct rk_fb_reg_data *regs)
+{
+	int i, j;
+	struct rk_lcdc_win *win;
+	ktime_t timestamp = dev_drv->vsync_info.timestamp;
+	struct rk_fb_reg_win_data *win_data;
+	bool wait_for_vsync;
+	int count = 100;
+	long timeout;
+	int pagefault = 0;
+
+	if (dev_drv->suspend_flag == 1) {
+#ifdef H_USE_FENCE
+		sw_sync_timeline_inc(dev_drv->timeline, 1);
+#endif
+		for (i = 0; i < regs->win_num; i++) {
+			win_data = &regs->reg_win_data[i];
+			rk_fb_free_dma_buf(dev_drv, win_data);
+		}
+		if (dev_drv->property.feature & SUPPORT_WRITE_BACK)
+			rk_fb_free_wb_buf(dev_drv, &regs->reg_wb_data);
+		kfree(regs);
+		return;
+	}
+	/* acq_fence wait */
+	for (i = 0; i < regs->win_num; i++) {
+		win_data = &regs->reg_win_data[i];
+		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+			if (win_data->reg_area_data[j].acq_fence)
+				rk_fd_fence_wait(dev_drv, win_data->reg_area_data[j].acq_fence);
+		}
+	}
+
+	mutex_lock(&dev_drv->win_config);
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		win = dev_drv->win[i];
+		win_data = rk_fb_get_win_data(regs, i);
+		if (win_data) {
+			rk_fb_update_win(dev_drv, win, win_data);
+			win->state = 1;
+			dev_drv->ops->set_par(dev_drv, i);
+			dev_drv->ops->pan_display(dev_drv, i);
+		} else {
+			win->z_order = -1;
+			win->state = 0;
+			for (j = 0; j < 4; j++) {
+				win->area[j].state = 0;
+				win->area[j].fbdc_en = 0;
+			}
+			if (dev_drv->iommu_enabled) {
+				for (j = 0; j < 4; j++) {
+					g_now_config_addr[i][j] = 0;
+					g_now_config_state[i][j] = 0;
+				}
+			}
+		}
+	}
+	dev_drv->ops->ovl_mgr(dev_drv, 0, 1);
+
+	if (dev_drv->property.feature & SUPPORT_WRITE_BACK) {
+		memcpy(&dev_drv->wb_data, &regs->reg_wb_data,
+		       sizeof(struct rk_fb_reg_wb_data));
+		if (dev_drv->ops->set_wb)
+			dev_drv->ops->set_wb(dev_drv);
+	}
+
+	if (rk_fb_iommu_debug > 0)
+		pagefault = rk_fb_iommu_page_fault_dump(dev_drv);
+
+	if (pagefault == 0)
+		dev_drv->ops->cfg_done(dev_drv);
+	else
+		sw_sync_timeline_inc(dev_drv->timeline, 1);
+	mutex_unlock(&dev_drv->win_config);
+
+	do {
+		timestamp = dev_drv->vsync_info.timestamp;
+		timeout = wait_event_interruptible_timeout(dev_drv->vsync_info.wait,
+				ktime_compare(dev_drv->vsync_info.timestamp, timestamp) > 0,
+				msecs_to_jiffies(50));
+		if (timeout <= 0)
+			dev_info(dev_drv->dev, "timeout: %ld\n", timeout);
+		wait_for_vsync = rk_fb_reg_effect(dev_drv, regs, count);
+	} while (wait_for_vsync && count--);
+#ifdef H_USE_FENCE
+	sw_sync_timeline_inc(dev_drv->timeline, 1);
+#endif
+
+	if (dev_drv->front_regs) {
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->ops->mmu_en)
+				dev_drv->ops->mmu_en(dev_drv);
+			freed_index = 0;
+			g_last_timeout = timeout;
+		}
+
+		mutex_lock(&dev_drv->front_lock);
+
+		for (i = 0; i < dev_drv->front_regs->win_num; i++) {
+			win_data = &dev_drv->front_regs->reg_win_data[i];
+			rk_fb_free_dma_buf(dev_drv, win_data);
+		}
+		if (dev_drv->property.feature & SUPPORT_WRITE_BACK)
+			rk_fb_free_wb_buf(dev_drv,
+					  &dev_drv->front_regs->reg_wb_data);
+		kfree(dev_drv->front_regs);
+
+		mutex_unlock(&dev_drv->front_lock);
+
+		if (dev_drv->iommu_enabled)
+			freed_addr[freed_index] = 0xfefefefe;
+	}
+
+	mutex_lock(&dev_drv->front_lock);
+
+	dev_drv->front_regs = regs;
+
+	mutex_unlock(&dev_drv->front_lock);
+
+	trace_buffer_dump(&fb_pdev->dev, dev_drv);
+}
+
+static void rk_fb_update_regs_handler(struct kthread_work *work)
+{
+	struct rk_lcdc_driver *dev_drv =
+	    container_of(work, struct rk_lcdc_driver, update_regs_work);
+	struct rk_fb_reg_data *data, *next;
+
+	mutex_lock(&dev_drv->update_regs_list_lock);
+	dev_drv->saved_list = dev_drv->update_regs_list;
+	list_replace_init(&dev_drv->update_regs_list, &dev_drv->saved_list);
+	mutex_unlock(&dev_drv->update_regs_list_lock);
+
+	list_for_each_entry_safe(data, next, &dev_drv->saved_list, list) {
+		list_del(&data->list);
+		rk_fb_update_reg(dev_drv, data);
+	}
+
+	if (dev_drv->wait_fs && list_empty(&dev_drv->update_regs_list))
+		wake_up(&dev_drv->update_regs_wait);
+}
+
+static int rk_fb_check_config_var(struct rk_fb_area_par *area_par,
+				  struct rk_screen *screen)
+{
+	if (area_par->phy_addr > 0)
+		pr_err("%s[%d], phy_addr = 0x%x\n",
+		       __func__, __LINE__, area_par->phy_addr);
+	if ((area_par->x_offset + area_par->xact > area_par->xvir) ||
+	    (area_par->xact <= 0) || (area_par->yact <= 0) ||
+	    (area_par->xvir <= 0) || (area_par->yvir <= 0)) {
+		pr_err("check config var fail 0:\n"
+		       "x_offset=%d,xact=%d,xvir=%d\n",
+		       area_par->x_offset, area_par->xact, area_par->xvir);
+		return -EINVAL;
+	}
+
+	if ((area_par->xpos >= screen->mode.xres) ||
+	    (area_par->ypos >= screen->mode.yres) ||
+	    ((area_par->xsize <= 0) || (area_par->ysize <= 0))) {
+		pr_warn("check config var fail 1:\n"
+			"xpos=%d,xsize=%d,xres=%d\n"
+			"ypos=%d,ysize=%d,yres=%d\n",
+			area_par->xpos, area_par->xsize, screen->mode.xres,
+			area_par->ypos, area_par->ysize, screen->mode.yres);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int rk_fb_config_debug(struct rk_lcdc_driver *dev_drv,
+			      struct rk_fb_win_cfg_data *win_data,
+			      struct rk_fb_reg_data *regs, u32 cmd)
+{
+	int i, j;
+	struct rk_fb_win_par *win_par;
+	struct rk_fb_area_par *area_par;
+	struct rk_fb_reg_win_data *reg_win_data;
+	struct rk_fb_reg_area_data *area_data;
+
+	rk_fb_dbg(cmd, "-------------frame start-------------\n");
+	rk_fb_dbg(cmd, "user config:\n");
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		win_par = &(win_data->win_par[i]);
+		if ((win_par->area_par[0].ion_fd <= 0) &&
+		    (win_par->area_par[0].phy_addr <= 0))
+			continue;
+		rk_fb_dbg(cmd, "win[%d]:z_order=%d,galhpa_v=%d\n",
+			  win_par->win_id, win_par->z_order,
+			  win_par->g_alpha_val);
+		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+			area_par = &(win_par->area_par[j]);
+			if (((j > 0) && (dev_drv->area_support[i] == 1)) ||
+			    ((win_par->area_par[j].ion_fd <= 0) &&
+			     (win_par->area_par[j].phy_addr <= 0)))
+				continue;
+			rk_fb_dbg(cmd, " area[%d]:fmt=%d,ion_fd=%d,phy_add=0x%x,xoff=%d,yoff=%d\n",
+				  j, area_par->data_format, area_par->ion_fd,
+				  area_par->phy_addr, area_par->x_offset,
+				  area_par->y_offset);
+			rk_fb_dbg(cmd, "	   xpos=%d,ypos=%d,xsize=%d,ysize=%d\n",
+				  area_par->xpos, area_par->ypos,
+				  area_par->xsize, area_par->ysize);
+			rk_fb_dbg(cmd, "	   xact=%d,yact=%d,xvir=%d,yvir=%d\n",
+				  area_par->xact, area_par->yact,
+				  area_par->xvir, area_par->yvir);
+			rk_fb_dbg(cmd, "	   data_space%d\n",
+				  area_par->data_space);
+		}
+	}
+
+	rk_fb_dbg(cmd, "regs data:\n");
+	rk_fb_dbg(cmd, "win_num=%d,buf_num=%d\n",
+		  regs->win_num, regs->buf_num);
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		reg_win_data = &(regs->reg_win_data[i]);
+		if (reg_win_data->reg_area_data[0].smem_start <= 0)
+			continue;
+		rk_fb_dbg(cmd, "win[%d]:z_order=%d,area_num=%d,area_buf_num=%d\n",
+			  reg_win_data->win_id, reg_win_data->z_order,
+			  reg_win_data->area_num, reg_win_data->area_buf_num);
+		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+			area_data = &(reg_win_data->reg_area_data[j]);
+			if (((j > 0) && (dev_drv->area_support[i] == 1)) ||
+			    (area_data->smem_start <= 0))
+				continue;
+			rk_fb_dbg(cmd, " area[%d]:fmt=%d,ion=%p,smem_star=0x%lx,cbr_star=0x%lx\n",
+				  j, area_data->data_format, area_data->ion_handle,
+				  area_data->smem_start, area_data->cbr_start);
+			rk_fb_dbg(cmd, "	   yoff=0x%x,coff=0x%x,area_data->buff_len=%x\n",
+				  area_data->y_offset, area_data->c_offset, area_data->buff_len);
+			rk_fb_dbg(cmd, "	   xpos=%d,ypos=%d,xsize=%d,ysize=%d\n",
+				  area_data->xpos, area_data->ypos,
+				  area_data->xsize, area_data->ysize);
+			rk_fb_dbg(cmd, "	   xact=%d,yact=%d,xvir=%d,yvir=%d\n",
+				  area_data->xact, area_data->yact,
+				  area_data->xvir, area_data->yvir);
+		}
+	}
+	rk_fb_dbg(cmd, "-------------frame end---------------\n");
+
+	return 0;
+}
+static int rk_fb_config_backup(struct rk_lcdc_driver *dev_drv,
+			       struct rk_fb_win_cfg_data *win_cfg,
+			       struct rk_fb_reg_data *regs)
+{
+	int i;
+
+	/*2->1->0: 0 is newest*/
+	for (i = 0; i < DUMP_FRAME_NUM - 1; i++) {
+		memcpy(&dev_drv->tmp_win_cfg[DUMP_FRAME_NUM - 1 - i],
+		       &dev_drv->tmp_win_cfg[DUMP_FRAME_NUM - 2 - i],
+		       sizeof(struct rk_fb_win_cfg_data));
+		memcpy(&dev_drv->tmp_regs[DUMP_FRAME_NUM - 1 - i],
+		       &dev_drv->tmp_regs[DUMP_FRAME_NUM - 2 - i],
+		       sizeof(struct rk_fb_reg_data));
+	}
+
+	memcpy(&dev_drv->tmp_win_cfg[0], win_cfg,
+	       sizeof(struct rk_fb_win_cfg_data));
+	memcpy(&dev_drv->tmp_regs[0], regs,
+	       sizeof(struct rk_fb_reg_data));
+
+	return 0;
+}
+
+static int rk_fb_set_wb_buffer(struct fb_info *info,
+			       struct rk_fb_wb_cfg *wb_cfg,
+			       struct rk_fb_reg_wb_data *wb_data)
+{
+	int ret = 0;
+	ion_phys_addr_t phy_addr;
+	size_t len;
+	u8 fb_data_fmt;
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
+
+	if ((wb_cfg->phy_addr == 0) && (wb_cfg->ion_fd == 0)) {
+		wb_data->state = 0;
+		return 0;
+	}
+	if (wb_cfg->phy_addr == 0) {
+		wb_data->ion_handle =
+		    ion_import_dma_buf(rk_fb->ion_client,
+				       wb_cfg->ion_fd);
+		if (IS_ERR(wb_data->ion_handle)) {
+			pr_info("Could not import handle: %ld\n",
+				(long)wb_data->ion_handle);
+			return -EINVAL;
+		}
+		if (dev_drv->iommu_enabled)
+			ret = ion_map_iommu(dev_drv->dev,
+					    rk_fb->ion_client,
+					    wb_data->ion_handle,
+					    (unsigned long *)&phy_addr,
+					    (unsigned long *)&len);
+		else
+			ret = ion_phys(rk_fb->ion_client, wb_data->ion_handle,
+				       &phy_addr, &len);
+		if (ret < 0) {
+			pr_err("ion map to get phy addr failed\n");
+			ion_free(rk_fb->ion_client, wb_data->ion_handle);
+			return -ENOMEM;
+		}
+		wb_data->smem_start = phy_addr;
+	} else {
+		wb_data->smem_start = wb_cfg->phy_addr;
+	}
+
+	fb_data_fmt = rk_fb_data_fmt(wb_cfg->data_format, 0);
+	if (IS_YUV_FMT(fb_data_fmt))
+		wb_data->cbr_start = wb_data->smem_start +
+					wb_cfg->xsize * wb_cfg->ysize;
+	wb_data->xsize = wb_cfg->xsize;
+	wb_data->ysize = wb_cfg->ysize;
+	wb_data->data_format = fb_data_fmt;
+	wb_data->state = 1;
+
+	return 0;
+}
+
+static int rk_fb_set_win_buffer(struct fb_info *info,
+				struct rk_fb_win_par *win_par,
+				struct rk_fb_reg_win_data *reg_win_data)
+{
+	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	/*if hdmi size move to hwc,screen should point to cur_screen
+	 *otherwise point to screen0[main screen]*/
+	struct rk_screen *screen = dev_drv->cur_screen;/*screen0;*/
+	struct fb_info *fbi;
+	int i, ion_fd, acq_fence_fd;
+	u32 xvir = 0, yvir = 0;
+	u32 xoffset = 0, yoffset = 0;
+
+	struct ion_handle *hdl;
+	size_t len;
+	int index_buf = 0;
+	u8 fb_data_fmt = 0;
+	u8 pixel_width = 0;
+	u32 vir_width_bit = 0;
+	u32 stride = 0, uv_stride = 0;
+	u32 stride_32bit_1 = 0;
+	u32 stride_32bit_2 = 0;
+	u16 uv_x_off = 0, uv_y_off = 0, uv_y_act = 0;
+	u8 is_pic_yuv = 0;
+	u8 ppixel_a = 0, global_a = 0;
+	ion_phys_addr_t phy_addr;
+	int ret = 0;
+	int buff_len = 0;
+
+	reg_win_data->reg_area_data[0].smem_start = -1;
+	reg_win_data->area_num = 0;
+	fbi = rk_fb->fb[win_par->win_id + dev_drv->fb_index_base];
+	if (win_par->area_par[0].phy_addr == 0) {
+		for (i = 0; i < RK_WIN_MAX_AREA; i++) {
+			ion_fd = win_par->area_par[i].ion_fd;
+			if (ion_fd > 0) {
+				hdl =
+				    ion_import_dma_buf(rk_fb->ion_client,
+						       ion_fd);
+				if (IS_ERR(hdl)) {
+					pr_info("%s: win[%d]area[%d] can't import handle\n",
+						__func__, win_par->win_id, i);
+					pr_info("fd: %d, hdl: 0x%p, ion_client: 0x%p\n",
+						ion_fd, hdl, rk_fb->ion_client);
+					return -EINVAL;
+					break;
+				}
+				reg_win_data->reg_area_data[i].ion_handle = hdl;
+				if (dev_drv->iommu_enabled)
+					ret = ion_map_iommu(dev_drv->dev,
+							    rk_fb->ion_client,
+							    hdl,
+							    (unsigned long *)&phy_addr,
+							    (unsigned long *)&len);
+				else
+					ret = ion_phys(rk_fb->ion_client, hdl,
+						       &phy_addr, &len);
+				if (ret < 0) {
+					dev_err(fbi->dev, "ion map to get phy addr failed\n");
+					ion_free(rk_fb->ion_client, hdl);
+					return -ENOMEM;
+				}
+				reg_win_data->reg_area_data[i].smem_start = phy_addr;
+				reg_win_data->area_num++;
+				reg_win_data->area_buf_num++;
+				reg_win_data->reg_area_data[i].index_buf = 1;
+				reg_win_data->reg_area_data[i].buff_len = len;
+			}
+		}
+	} else {
+		reg_win_data->reg_area_data[0].smem_start =
+		    win_par->area_par[0].phy_addr;
+		reg_win_data->area_num = 1;
+		reg_win_data->area_buf_num++;
+		fbi->screen_base = phys_to_virt(win_par->area_par[0].phy_addr);
+	}
+
+	if (reg_win_data->area_num == 0) {
+		for (i = 0; i < RK_WIN_MAX_AREA; i++)
+			reg_win_data->reg_area_data[i].smem_start = 0;
+		reg_win_data->z_order = -1;
+		reg_win_data->win_id = -1;
+		return 0;
+	}
+
+	for (i = 0; i < reg_win_data->area_num; i++) {
+		acq_fence_fd = win_par->area_par[i].acq_fence_fd;
+		index_buf = reg_win_data->reg_area_data[i].index_buf;
+		if ((acq_fence_fd > 0) && (index_buf == 1)) {
+			reg_win_data->reg_area_data[i].acq_fence =
+			    sync_fence_fdget(win_par->area_par[i].acq_fence_fd);
+		}
+	}
+	if (reg_win_data->reg_area_data[0].smem_start > 0) {
+		reg_win_data->z_order = win_par->z_order;
+		reg_win_data->win_id = win_par->win_id;
+	} else {
+		reg_win_data->z_order = -1;
+		reg_win_data->win_id = -1;
+	}
+
+	reg_win_data->mirror_en = win_par->mirror_en;
+	for (i = 0; i < reg_win_data->area_num; i++) {
+		u8 data_format = win_par->area_par[i].data_format;
+		/*rk_fb_check_config_var(&win_par->area_par[i], screen);*/
+		reg_win_data->colorspace = CSC_FORMAT(data_format);
+		data_format &= ~CSC_MASK;
+		fb_data_fmt = rk_fb_data_fmt(data_format, 0);
+		reg_win_data->reg_area_data[i].data_format = fb_data_fmt;
+		reg_win_data->reg_area_data[i].data_space =
+					win_par->area_par[i].data_space;
+		if (IS_FBDC_FMT(fb_data_fmt)) {
+			reg_win_data->reg_area_data[i].fbdc_en = 1;
+			reg_win_data->reg_area_data[i].fbdc_cor_en = 1;
+		} else {
+			reg_win_data->reg_area_data[i].fbdc_en = 0;
+			reg_win_data->reg_area_data[i].fbdc_cor_en = 0;
+		}
+		pixel_width = rk_fb_pixel_width(fb_data_fmt);
+
+		ppixel_a |= ((fb_data_fmt == ARGB888) ||
+			     (fb_data_fmt == FBDC_ARGB_888) ||
+			     (fb_data_fmt == FBDC_ABGR_888) ||
+			     (fb_data_fmt == ABGR888)) ? 1 : 0;
+		/*act_height should be 2 pix align for interlace output*/
+		if (win_par->area_par[i].yact % 2 == 1) {
+			win_par->area_par[i].yact  -= 1;
+			win_par->area_par[i].ysize -= 1;
+		}
+
+		/* buf offset should be 2 pix align*/
+		if ((win_par->area_par[i].x_offset % 2 == 1) &&
+		    IS_YUV_FMT(fb_data_fmt)) {
+			win_par->area_par[i].x_offset += 1;
+			win_par->area_par[i].xact -= 1;
+		}
+
+		/* visiable pos in panel */
+		reg_win_data->reg_area_data[i].xpos = win_par->area_par[i].xpos;
+		reg_win_data->reg_area_data[i].ypos = win_par->area_par[i].ypos;
+
+		/* realy size in panel */
+		reg_win_data->reg_area_data[i].xsize = win_par->area_par[i].xsize;
+		reg_win_data->reg_area_data[i].ysize = win_par->area_par[i].ysize;
+
+		/* realy size in panel */
+		reg_win_data->reg_area_data[i].xact = win_par->area_par[i].xact;
+		reg_win_data->reg_area_data[i].yact = win_par->area_par[i].yact;
+
+		xoffset = win_par->area_par[i].x_offset;	/* buf offset */
+		yoffset = win_par->area_par[i].y_offset;
+		reg_win_data->reg_area_data[i].xoff = xoffset;
+		reg_win_data->reg_area_data[i].yoff = yoffset;
+
+		xvir = win_par->area_par[i].xvir;
+		reg_win_data->reg_area_data[i].xvir = xvir;
+		yvir = win_par->area_par[i].yvir;
+		reg_win_data->reg_area_data[i].yvir = yvir;
+
+		vir_width_bit = pixel_width * xvir;
+		/* pixel_width = byte_num*8 */
+		stride_32bit_1 = ((vir_width_bit + 31) & (~31)) / 8;
+		stride_32bit_2 = ((vir_width_bit * 2 + 31) & (~31)) / 8;
+
+		stride = stride_32bit_1;	/* default rgb */
+		fix->line_length = stride;
+		reg_win_data->reg_area_data[i].y_vir_stride = stride >> 2;
+
+		/* x y mirror ,jump line
+		 * reg_win_data->reg_area_data[i].y_offset =
+		 *		yoffset*stride+xoffset*pixel_width/8;
+		 */
+		if (screen->y_mirror || reg_win_data->mirror_en) {
+			if (screen->interlace == 1) {
+				reg_win_data->reg_area_data[i].y_offset =
+				    yoffset * stride * 2 +
+				    ((reg_win_data->reg_area_data[i].yact - 1) * 2 + 1) * stride +
+				    xoffset * pixel_width / 8;
+			} else {
+				reg_win_data->reg_area_data[i].y_offset =
+				    yoffset * stride +
+				    (reg_win_data->reg_area_data[i].yact - 1) * stride +
+				    xoffset * pixel_width / 8;
+			}
+		} else {
+			if (screen->interlace == 1) {
+				reg_win_data->reg_area_data[i].y_offset =
+				    yoffset * stride * 2 +
+				    xoffset * pixel_width / 8;
+			} else {
+				reg_win_data->reg_area_data[i].y_offset =
+				    yoffset * stride +
+				    xoffset * pixel_width / 8;
+			}
+		}
+		if (IS_RGB_FMT(fb_data_fmt) && dev_drv->iommu_enabled) {
+			buff_len = yoffset * stride +
+				xoffset * pixel_width / 8 +
+				reg_win_data->reg_area_data[i].xvir *
+				reg_win_data->reg_area_data[i].yact *
+				pixel_width / 8 -
+				reg_win_data->reg_area_data[i].xoff*
+				pixel_width / 8;
+			if (buff_len > reg_win_data->reg_area_data[i].buff_len)
+				pr_err("\n!!!!!!error: fmt=%d,xvir[%d]*"
+				       "yact[%d]*bpp[%d]"
+				       "=buff_len[0x%x]>>mmu len=0x%x\n",
+				       fb_data_fmt,
+				       reg_win_data->reg_area_data[i].xvir,
+				       reg_win_data->reg_area_data[i].yact,
+				       pixel_width, buff_len,
+				       reg_win_data->reg_area_data[i].buff_len);
+		}
+	}
+
+	global_a = (win_par->g_alpha_val == 0) ? 0 : 1;
+	reg_win_data->alpha_en = ppixel_a | global_a;
+	reg_win_data->g_alpha_val = win_par->g_alpha_val;
+	reg_win_data->alpha_mode = win_par->alpha_mode;
+
+	switch (fb_data_fmt) {
+	case YUV422:
+	case YUV422_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_1;
+		uv_x_off = xoffset;
+		uv_y_off = yoffset;
+		fix->line_length = stride;
+		uv_y_act = win_par->area_par[0].yact >> 1;
+		break;
+	case YUV420:		/* nv12 */
+	case YUV420_NV21:	/* nv21 */
+	case YUV420_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_1;
+		uv_x_off = xoffset;
+		uv_y_off = yoffset >> 1;
+		fix->line_length = stride;
+		uv_y_act = win_par->area_par[0].yact >> 1;
+		break;
+	case YUV444:
+	case YUV444_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_2;
+		uv_x_off = xoffset * 2;
+		uv_y_off = yoffset;
+		fix->line_length = stride << 2;
+		uv_y_act = win_par->area_par[0].yact;
+		break;
+	default:
+		break;
+	}
+	if (is_pic_yuv == 1) {
+		reg_win_data->reg_area_data[0].cbr_start =
+		    reg_win_data->reg_area_data[0].smem_start + xvir * yvir;
+		reg_win_data->reg_area_data[0].uv_vir_stride = uv_stride >> 2;
+		if ((screen->y_mirror == 1) || (reg_win_data->mirror_en)) {
+			if (screen->interlace == 1) {
+				reg_win_data->reg_area_data[0].c_offset =
+				    uv_y_off * uv_stride * 2 +
+				    ((uv_y_act - 1) * 2 + 1) * uv_stride +
+				    uv_x_off * pixel_width / 8;
+			} else {
+				reg_win_data->reg_area_data[0].c_offset =
+				    uv_y_off * uv_stride +
+				    (uv_y_act - 1) * uv_stride +
+				    uv_x_off * pixel_width / 8;
+			}
+		} else {
+			if (screen->interlace == 1) {
+				reg_win_data->reg_area_data[0].c_offset =
+				    uv_y_off * uv_stride * 2 +
+				    uv_x_off * pixel_width / 8;
+			} else {
+				reg_win_data->reg_area_data[0].c_offset =
+				    uv_y_off * uv_stride +
+				    uv_x_off * pixel_width / 8;
+			}
+		}
+		buff_len = reg_win_data->reg_area_data[0].cbr_start +
+			uv_y_off * uv_stride + uv_x_off * pixel_width / 8 +
+			reg_win_data->reg_area_data[0].xvir *
+			reg_win_data->reg_area_data[0].yact *
+			pixel_width / 16 -
+			reg_win_data->reg_area_data[0].smem_start -
+			reg_win_data->reg_area_data[0].xoff*
+			pixel_width / 16;
+		if ((buff_len > reg_win_data->reg_area_data[0].buff_len) &&
+		     dev_drv->iommu_enabled)
+			pr_err("\n!!!!!!error: fmt=%d,xvir[%d]*"
+			       "yact[%d]*bpp[%d]"
+			       "=buff_len[0x%x]>>mmu len=0x%x\n",
+			       fb_data_fmt,
+			       reg_win_data->reg_area_data[0].xvir,
+			       reg_win_data->reg_area_data[0].yact,
+			       pixel_width, buff_len,
+			       reg_win_data->reg_area_data[0].buff_len);
+	}
+
+	/* record buffer information for rk_fb_disp_scale to prevent fence
+	 * timeout because rk_fb_disp_scale will call function
+	 * info->fbops->fb_set_par(info);
+	 * delete by hjc for new hdmi overscan framework.
+	 */
+	/* info->var.yoffset = yoffset;
+	 * info->var.xoffset = xoffset;
+	 */
+	return 0;
+}
+
+static int rk_fb_set_win_config(struct fb_info *info,
+				struct rk_fb_win_cfg_data *win_data)
+{
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_fb_reg_data *regs;
+#ifdef H_USE_FENCE
+	struct sync_fence *release_fence[RK_MAX_BUF_NUM];
+	struct sync_fence *retire_fence;
+	struct sync_pt *release_sync_pt[RK_MAX_BUF_NUM];
+	struct sync_pt *retire_sync_pt;
+	char fence_name[20];
+#endif
+	int ret = 0, i, j = 0;
+	int list_is_empty = 0;
+	struct rk_screen *screen = dev_drv->cur_screen;
+
+	mutex_lock(&dev_drv->output_lock);
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++) {
+			if ((win_data->win_par[i].area_par[j].ion_fd > 0) ||
+			    (win_data->win_par[i].area_par[j].phy_addr > 0))
+				ret += rk_fb_check_config_var(
+					&win_data->win_par[i].area_par[j],
+					screen);
+		}
+	}
+	if ((dev_drv->suspend_flag) || (dev_drv->hdmi_switch) || (ret < 0)) {
+		dev_drv->timeline_max++;
+		sw_sync_timeline_inc(dev_drv->timeline, 1);
+		if (dev_drv->suspend_flag)
+			pr_err("suspend_flag=%d\n", dev_drv->suspend_flag);
+		else if (dev_drv->hdmi_switch)
+			pr_err("hdmi switch = %d\n", dev_drv->hdmi_switch);
+		else
+			pr_err("error config ,ignore\n");
+		for (j = 0; j < RK_MAX_BUF_NUM; j++)
+			win_data->rel_fence_fd[j] = -1;
+		win_data->ret_fence_fd = -1;
+		goto err;
+	}
+
+	regs = kzalloc(sizeof(struct rk_fb_reg_data), GFP_KERNEL);
+	if (!regs) {
+		pr_info("could not allocate rk_fb_reg_data\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0, j = 0; i < dev_drv->lcdc_win_num; i++) {
+		if (win_data->win_par[i].win_id < dev_drv->lcdc_win_num) {
+			if (rk_fb_set_win_buffer(info, &win_data->win_par[i],
+						 &regs->reg_win_data[j])) {
+				ret = -ENOMEM;
+				pr_info("error:%s[%d]\n", __func__, __LINE__);
+				goto err2;
+			}
+			if (regs->reg_win_data[j].area_num > 0) {
+				regs->win_num++;
+				regs->buf_num +=
+				    regs->reg_win_data[j].area_buf_num;
+			}
+			j++;
+		} else {
+			pr_info("error:win_id bigger than lcdc_win_num\n");
+			pr_info("i=%d,win_id=%d\n", i,
+				win_data->win_par[i].win_id);
+		}
+	}
+	if (dev_drv->property.feature & SUPPORT_WRITE_BACK)
+		rk_fb_set_wb_buffer(info, &win_data->wb_cfg,
+				    &regs->reg_wb_data);
+	if (regs->win_num <= 0)
+		goto err_null_frame;
+
+	dev_drv->timeline_max++;
+#ifdef H_USE_FENCE
+	win_data->ret_fence_fd = get_unused_fd_flags(0);
+	if (win_data->ret_fence_fd < 0) {
+		pr_err("ret_fence_fd=%d\n", win_data->ret_fence_fd);
+		win_data->ret_fence_fd = -1;
+		ret = -EFAULT;
+		goto err2;
+	}
+	for (i = 0; i < RK_MAX_BUF_NUM; i++) {
+		if (i < regs->buf_num) {
+			sprintf(fence_name, "fence%d", i);
+			win_data->rel_fence_fd[i] = get_unused_fd_flags(0);
+			if (win_data->rel_fence_fd[i] < 0) {
+				pr_info("rel_fence_fd=%d\n",
+					win_data->rel_fence_fd[i]);
+				ret = -EFAULT;
+				goto err2;
+			}
+			release_sync_pt[i] =
+			    sw_sync_pt_create(dev_drv->timeline,
+					      dev_drv->timeline_max);
+			release_fence[i] =
+			    sync_fence_create(fence_name, release_sync_pt[i]);
+			sync_fence_install(release_fence[i],
+					   win_data->rel_fence_fd[i]);
+		} else {
+			win_data->rel_fence_fd[i] = -1;
+		}
+	}
+
+	retire_sync_pt =
+	    sw_sync_pt_create(dev_drv->timeline, dev_drv->timeline_max);
+	retire_fence = sync_fence_create("ret_fence", retire_sync_pt);
+	sync_fence_install(retire_fence, win_data->ret_fence_fd);
+#else
+	for (i = 0; i < RK_MAX_BUF_NUM; i++)
+		win_data->rel_fence_fd[i] = -1;
+
+	win_data->ret_fence_fd = -1;
+#endif
+	if (dev_drv->wait_fs == 0) {
+		mutex_lock(&dev_drv->update_regs_list_lock);
+		list_add_tail(&regs->list, &dev_drv->update_regs_list);
+		mutex_unlock(&dev_drv->update_regs_list_lock);
+		queue_kthread_work(&dev_drv->update_regs_worker,
+				   &dev_drv->update_regs_work);
+	} else {
+		mutex_lock(&dev_drv->update_regs_list_lock);
+		list_is_empty = list_empty(&dev_drv->update_regs_list) &&
+					list_empty(&dev_drv->saved_list);
+		mutex_unlock(&dev_drv->update_regs_list_lock);
+		if (!list_is_empty) {
+			ret = wait_event_timeout(dev_drv->update_regs_wait,
+				list_empty(&dev_drv->update_regs_list) && list_empty(&dev_drv->saved_list),
+				msecs_to_jiffies(60));
+			if (ret > 0)
+				rk_fb_update_reg(dev_drv, regs);
+			else
+				pr_info("%s: wait update_regs_wait timeout\n", __func__);
+		} else if (ret == 0) {
+			rk_fb_update_reg(dev_drv, regs);
+		}
+	}
+	if (rk_fb_debug_lvl > 0)
+		rk_fb_config_debug(dev_drv, win_data, regs, rk_fb_debug_lvl);
+	if (rk_fb_iommu_debug > 0)
+		rk_fb_config_backup(dev_drv, win_data, regs);
+err:
+	mutex_unlock(&dev_drv->output_lock);
+	return ret;
+err_null_frame:
+	for (j = 0; j < RK_MAX_BUF_NUM; j++)
+		win_data->rel_fence_fd[j] = -1;
+	win_data->ret_fence_fd = -1;
+	pr_info("win num = %d,null frame\n", regs->win_num);
+err2:
+	rk_fb_config_debug(dev_drv, win_data, regs, 0);
+	kfree(regs);
+	mutex_unlock(&dev_drv->output_lock);
+
+	return ret;
+}
+
+#if 1
+static int cfgdone_distlist[10] = { 0 };
+
+static int cfgdone_index;
+static int cfgdone_lasttime;
+
+int rk_get_real_fps(int before)
+{
+	struct timespec now;
+	int dist_curr;
+	int dist_total = 0;
+	int dist_count = 0;
+	int dist_first = 0;
+
+	int index = cfgdone_index;
+	int i = 0, fps = 0;
+	int total;
+
+	if (before > 100)
+		before = 100;
+	if (before < 0)
+		before = 0;
+
+	getnstimeofday(&now);
+	dist_curr = (now.tv_sec * 1000000 + now.tv_nsec / 1000) -
+			cfgdone_lasttime;
+	total = dist_curr;
+	for (i = 0; i < 10; i++) {
+		if (--index < 0)
+			index = 9;
+		total += cfgdone_distlist[index];
+		if (i == 0)
+			dist_first = cfgdone_distlist[index];
+		if (total < (before * 1000)) {
+			dist_total += cfgdone_distlist[index];
+			dist_count++;
+		} else {
+			break;
+		}
+	}
+
+	dist_curr = (dist_curr > dist_first) ? dist_curr : dist_first;
+	dist_total += dist_curr;
+	dist_count++;
+
+	if (dist_total > 0)
+		fps = (1000000 * dist_count) / dist_total;
+	else
+		fps = 60;
+
+	return fps;
+}
+EXPORT_SYMBOL(rk_get_real_fps);
+
+#endif
+#define ION_MAX 10
+static struct ion_handle *ion_hanle[ION_MAX];
+static struct ion_handle *ion_hwc[1];
+static int rk_fb_ioctl(struct fb_info *info, unsigned int cmd,
+		       unsigned long arg)
+{
+	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct rk_lcdc_win *win;
+	int enable;	/* enable fb:1 enable;0 disable */
+	int ovl;	/* overlay:0 win1 on the top of win0;1,win0 on the top of win1 */
+	int num_buf;	/* buffer_number */
+	int ret = 0;
+	struct rk_fb_win_cfg_data win_data;
+	unsigned int dsp_addr[4][4];
+	int list_stat;
+
+	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
+	void __user *argp = (void __user *)arg;
+
+	win = dev_drv->win[win_id];
+	switch (cmd) {
+	case RK_FBIOSET_HWC_ADDR:
+	{
+		u32 hwc_phy[1];
+
+		if (copy_from_user(hwc_phy, argp, 4))
+			return -EFAULT;
+		if (!dev_drv->iommu_enabled) {
+			fix->smem_start = hwc_phy[0];
+		} else {
+			int usr_fd;
+			struct ion_handle *hdl;
+			ion_phys_addr_t phy_addr;
+			size_t len;
+
+			usr_fd = hwc_phy[0];
+			if (!usr_fd) {
+				fix->smem_start = 0;
+				fix->mmio_start = 0;
+				dev_drv->ops->open(dev_drv, win_id, 0);
+				break;
+			}
+
+			if (ion_hwc[0] != 0) {
+				ion_free(rk_fb->ion_client, ion_hwc[0]);
+				ion_hwc[0] = 0;
+			}
+
+			hdl = ion_import_dma_buf(rk_fb->ion_client, usr_fd);
+			if (IS_ERR(hdl)) {
+				dev_err(info->dev, "failed to get hwc ion handle:%ld\n",
+					PTR_ERR(hdl));
+				return -EFAULT;
+			}
+
+			ret = ion_map_iommu(dev_drv->dev, rk_fb->ion_client, hdl,
+					    (unsigned long *)&phy_addr,
+					    (unsigned long *)&len);
+			if (ret < 0) {
+				dev_err(info->dev, "ion map to get hwc phy addr failed");
+				ion_free(rk_fb->ion_client, hdl);
+				return -ENOMEM;
+			}
+			fix->smem_start = phy_addr;
+			ion_hwc[0] = hdl;
+		}
+		break;
+	}
+	case RK_FBIOSET_YUV_ADDR:
+		{
+			u32 yuv_phy[2];
+
+			if (copy_from_user(yuv_phy, argp, 8))
+				return -EFAULT;
+			if (!dev_drv->iommu_enabled || !strcmp(info->fix.id, "fb0")) {
+				fix->smem_start = yuv_phy[0];
+				fix->mmio_start = yuv_phy[1];
+			} else {
+				int usr_fd, offset, tmp;
+				struct ion_handle *hdl;
+				ion_phys_addr_t phy_addr;
+				size_t len;
+
+				usr_fd = yuv_phy[0];
+				offset = yuv_phy[1] - yuv_phy[0];
+				if (!usr_fd) {
+					fix->smem_start = 0;
+					fix->mmio_start = 0;
+					break;
+				}
+
+				if (ion_hanle[ION_MAX - 1] != 0) {
+					/*ion_unmap_kernel(rk_fb->ion_client,
+					 *	ion_hanle[ION_MAX - 1]);
+					 *ion_unmap_iommu(dev_drv->dev,
+					 *	rk_fb->ion_client,
+					 *	ion_hanle[ION_MAX - 1]);
+					 */
+					ion_free(rk_fb->ion_client, ion_hanle[ION_MAX - 1]);
+					ion_hanle[ION_MAX - 1] = 0;
+				}
+
+				hdl = ion_import_dma_buf(rk_fb->ion_client, usr_fd);
+				if (IS_ERR(hdl)) {
+					dev_err(info->dev, "failed to get ion handle:%ld\n",
+						PTR_ERR(hdl));
+					return -EFAULT;
+				}
+
+				ret = ion_map_iommu(dev_drv->dev, rk_fb->ion_client, hdl,
+						    (unsigned long *)&phy_addr,
+						    (unsigned long *)&len);
+				if (ret < 0) {
+					dev_err(info->dev, "ion map to get phy addr failed");
+					ion_free(rk_fb->ion_client, hdl);
+					return -ENOMEM;
+				}
+				fix->smem_start = phy_addr;
+				fix->mmio_start = phy_addr + offset;
+				fix->smem_len = len;
+				/*info->screen_base =
+				 *	ion_map_kernel(rk_fb->ion_client, hdl);
+				 */
+				ion_hanle[0] = hdl;
+				for (tmp = ION_MAX - 1; tmp > 0; tmp--)
+					ion_hanle[tmp] = ion_hanle[tmp - 1];
+				ion_hanle[0] = 0;
+			}
+			break;
+		}
+	case RK_FBIOSET_ENABLE:
+		if (copy_from_user(&enable, argp, sizeof(enable)))
+			return -EFAULT;
+				if (enable && fb_par->state)
+					fb_par->state++;
+				else
+					fb_par->state--;
+		dev_drv->ops->open(dev_drv, win_id, enable);
+		break;
+	case RK_FBIOGET_ENABLE:
+		enable = dev_drv->ops->get_win_state(dev_drv, win_id, 0);
+		if (copy_to_user(argp, &enable, sizeof(enable)))
+			return -EFAULT;
+		break;
+	case RK_FBIOSET_OVERLAY_STA:
+		if (copy_from_user(&ovl, argp, sizeof(ovl)))
+			return -EFAULT;
+		dev_drv->ops->ovl_mgr(dev_drv, ovl, 1);
+		break;
+	case RK_FBIOGET_OVERLAY_STA:
+		ovl = dev_drv->ops->ovl_mgr(dev_drv, 0, 0);
+		if (copy_to_user(argp, &ovl, sizeof(ovl)))
+			return -EFAULT;
+		break;
+	case RK_FBIOPUT_NUM_BUFFERS:
+		if (copy_from_user(&num_buf, argp, sizeof(num_buf)))
+			return -EFAULT;
+		dev_drv->num_buf = num_buf;
+		break;
+	case RK_FBIOSET_VSYNC_ENABLE:
+		if (copy_from_user(&enable, argp, sizeof(enable)))
+			return -EFAULT;
+		if (enable)
+			dev_drv->vsync_info.active++;
+		else
+			dev_drv->vsync_info.active--;
+		break;
+	case RK_FBIOGET_DSP_ADDR:
+		dev_drv->ops->get_dsp_addr(dev_drv, dsp_addr);
+		if (copy_to_user(argp, &dsp_addr, sizeof(dsp_addr)))
+			return -EFAULT;
+		break;
+	case RK_FBIOGET_LIST_STA:
+		list_stat = rk_fb_get_list_stat(dev_drv);
+		if (copy_to_user(argp, &list_stat, sizeof(list_stat)))
+			return -EFAULT;
+
+		break;
+	case RK_FBIOGET_IOMMU_STA:
+		if (copy_to_user(argp, &dev_drv->iommu_enabled,
+				 sizeof(dev_drv->iommu_enabled)))
+			return -EFAULT;
+		break;
+#if defined(CONFIG_ION_ROCKCHIP)
+	case RK_FBIOSET_DMABUF_FD:
+		{
+			int usr_fd;
+			struct ion_handle *hdl;
+			ion_phys_addr_t phy_addr;
+			size_t len;
+
+			if (copy_from_user(&usr_fd, argp, sizeof(usr_fd)))
+				return -EFAULT;
+
+			hdl = ion_import_dma_buf(rk_fb->ion_client, usr_fd);
+			ion_phys(rk_fb->ion_client, hdl, &phy_addr, &len);
+			fix->smem_start = phy_addr;
+			break;
+		}
+	case RK_FBIOGET_DMABUF_FD:
+		{
+			int fd = -1;
+
+			if (IS_ERR_OR_NULL(fb_par->ion_hdl)) {
+				dev_err(info->dev,
+					"get dma_buf fd failed,ion handle is err\n");
+				return PTR_ERR(fb_par->ion_hdl);
+			}
+			fd = ion_share_dma_buf_fd(rk_fb->ion_client,
+						  fb_par->ion_hdl);
+			if (fd < 0) {
+				dev_err(info->dev,
+					"ion_share_dma_buf_fd failed\n");
+				return fd;
+			}
+			if (copy_to_user(argp, &fd, sizeof(fd)))
+				return -EFAULT;
+			break;
+		}
+#endif
+	case RK_FBIOSET_CLEAR_FB:
+		memset(fb_par->fb_virt_base, 0, fb_par->fb_size);
+		break;
+	case RK_FBIOSET_CONFIG_DONE:
+		{
+			int curr = 0;
+			struct timespec now;
+
+			getnstimeofday(&now);
+			curr = now.tv_sec * 1000000 + now.tv_nsec / 1000;
+			cfgdone_distlist[cfgdone_index++] =
+				curr - cfgdone_lasttime;
+			cfgdone_lasttime = curr;
+			if (cfgdone_index >= 10)
+				cfgdone_index = 0;
+		}
+		if (is_car_camcap()) {
+			int i = 0;
+
+			for (i = 0; i < RK_MAX_BUF_NUM; i++)
+				win_data.rel_fence_fd[i] = -1;
+
+			win_data.ret_fence_fd = -1;
+			goto cam_exit;
+		}
+		if (copy_from_user(&win_data,
+				   (struct rk_fb_win_cfg_data __user *)argp,
+				   sizeof(win_data))) {
+			ret = -EFAULT;
+			break;
+		};
+
+		dev_drv->wait_fs = win_data.wait_fs;
+		ret = rk_fb_set_win_config(info, &win_data);
+
+cam_exit:
+		if (copy_to_user((struct rk_fb_win_cfg_data __user *)arg,
+				 &win_data, sizeof(win_data))) {
+			ret = -EFAULT;
+			break;
+		}
+		memset(&win_data, 0, sizeof(struct rk_fb_win_cfg_data));
+
+		if (dev_drv->uboot_logo)
+			dev_drv->uboot_logo = 0;
+
+		break;
+	default:
+		dev_drv->ops->ioctl(dev_drv, cmd, arg, win_id);
+		break;
+	}
+
+	return ret;
+}
+
+static int rk_fb_blank(int blank_mode, struct fb_info *info)
+{
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	int win_id;
+#if defined(CONFIG_RK_HDMI)
+	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
+#endif
+
+	if (is_car_camcap())
+		return 0;
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, fix->id);
+	if (win_id < 0)
+		return -ENODEV;
+	mutex_lock(&dev_drv->switch_screen);
+#if defined(CONFIG_RK_HDMI)
+	if ((rk_fb->disp_mode == ONE_DUAL) &&
+	    (hdmi_get_hotplug() == HDMI_HPD_ACTIVATED)) {
+		pr_info("hdmi is connect , not blank lcdc\n");
+	} else
+#endif
+	{
+		dev_drv->ops->blank(dev_drv, win_id, blank_mode);
+	}
+	mutex_unlock(&dev_drv->switch_screen);
+	return 0;
+}
+
+static int rk_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	if ((0 == var->xres_virtual) || (0 == var->yres_virtual) ||
+	    (0 == var->xres) || (0 == var->yres) || (var->xres < 16) ||
+	    ((16 != var->bits_per_pixel) &&
+	    (32 != var->bits_per_pixel) &&
+	    (24 != var->bits_per_pixel))) {
+		dev_err(info->dev, "%s check var fail 1:\n"
+			"xres_vir:%d>>yres_vir:%d\n"
+			"xres:%d>>yres:%d\n"
+			"bits_per_pixel:%d\n",
+			info->fix.id,
+			var->xres_virtual,
+			var->yres_virtual,
+			var->xres, var->yres, var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	if (((var->xoffset + var->xres) > var->xres_virtual) ||
+	    ((var->yoffset + var->yres) > (var->yres_virtual))) {
+		dev_err(info->dev, "%s check_var fail 2:\n"
+			"xoffset:%d>>xres:%d>>xres_vir:%d\n"
+			"yoffset:%d>>yres:%d>>yres_vir:%d\n",
+			info->fix.id,
+			var->xoffset,
+			var->xres,
+			var->xres_virtual,
+			var->yoffset, var->yres, var->yres_virtual);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static ssize_t rk_fb_read(struct fb_info *info, char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	unsigned long p = *ppos;
+	u8 *buffer, *dst;
+	u8 __iomem *src;
+	int c, cnt = 0, err = 0;
+	unsigned long total_size;
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_lcdc_win *win = NULL;
+	int win_id = 0;
+
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
+	if (win_id < 0)
+		return -ENODEV;
+	else
+		win = dev_drv->win[win_id];
+
+	/* only read the current frame buffer */
+	if (win->area[0].format == RGB565) {
+		total_size = win->area[0].y_vir_stride * win->area[0].yact << 1;
+	} else if ((win->area[0].format == YUV420) ||
+		   (win->area[0].format == YUV420_NV21)) {
+		total_size =
+		    (win->area[0].y_vir_stride * win->area[0].yact * 6);
+	} else {
+		total_size = win->area[0].y_vir_stride * win->area[0].yact << 2;
+	}
+	if (p >= total_size)
+		return 0;
+
+	if (count >= total_size)
+		count = total_size;
+
+	if (count + p > total_size)
+		count = total_size - p;
+
+	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	src = (u8 __iomem *)(info->screen_base + p + win->area[0].y_offset);
+
+	while (count) {
+		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
+		dst = buffer;
+		fb_memcpy_fromfb(dst, src, c);
+		dst += c;
+		src += c;
+
+		if (copy_to_user(buf, buffer, c)) {
+			err = -EFAULT;
+			break;
+		}
+		*ppos += c;
+		buf += c;
+		cnt += c;
+		count -= c;
+	}
+
+	kfree(buffer);
+
+	return (err) ? err : cnt;
+}
+
+static ssize_t rk_fb_write(struct fb_info *info, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	unsigned long p = *ppos;
+	u8 *buffer, *src;
+	u8 __iomem *dst;
+	int c, cnt = 0, err = 0;
+	unsigned long total_size;
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_lcdc_win *win = NULL;
+	int win_id = 0;
+
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
+	if (win_id < 0)
+		return -ENODEV;
+	else
+		win = dev_drv->win[win_id];
+
+	/* write the current frame buffer */
+	if (win->area[0].format == RGB565)
+		total_size = win->area[0].xact * win->area[0].yact << 1;
+	else
+		total_size = win->area[0].xact * win->area[0].yact << 2;
+
+	if (p > total_size)
+		return -EFBIG;
+
+	if (count > total_size) {
+		err = -EFBIG;
+		count = total_size;
+	}
+
+	if (count + p > total_size) {
+		if (!err)
+			err = -ENOSPC;
+
+		count = total_size - p;
+	}
+
+	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	dst = (u8 __iomem *)(info->screen_base + p + win->area[0].y_offset);
+
+	while (count) {
+		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
+		src = buffer;
+
+		if (copy_from_user(src, buf, c)) {
+			err = -EFAULT;
+			break;
+		}
+
+		fb_memcpy_tofb(dst, src, c);
+		dst += c;
+		src += c;
+		*ppos += c;
+		buf += c;
+		cnt += c;
+		count -= c;
+	}
+
+	kfree(buffer);
+
+	return (cnt) ? cnt : err;
+}
+
+static int rk_fb_set_par(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_lcdc_win *win = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	int win_id = 0;
+	u16 xsize = 0, ysize = 0;	/* winx display window height/width --->LCDC_WINx_DSP_INFO */
+	u32 xoffset = var->xoffset;	/* offset from virtual to visible */
+	u32 yoffset = var->yoffset;
+	u16 xpos = (var->nonstd >> 8) & 0xfff;	/*visiable pos in panel */
+	u16 ypos = (var->nonstd >> 20) & 0xfff;
+	u32 xvir = var->xres_virtual;
+	u8 data_format = var->nonstd & 0xff;
+	u8 fb_data_fmt;
+	u8 pixel_width = 0;
+	u32 vir_width_bit;
+	u32 stride, uv_stride = 0;
+	u32 stride_32bit_1;
+	u32 stride_32bit_2;
+	u16 uv_x_off, uv_y_off, uv_y_act;
+	u8 is_pic_yuv = 0;
+	/*var->pixclock = dev_drv->pixclock;*/
+	if (dev_drv->suspend_flag || is_car_camcap())
+		return 0;
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
+	if (win_id < 0)
+		return -ENODEV;
+	else
+		win = dev_drv->win[win_id];
+
+	/* if the application has specific the hor and ver display size */
+	if (var->grayscale >> 8) {
+		xsize = (var->grayscale >> 8) & 0xfff;
+		ysize = (var->grayscale >> 20) & 0xfff;
+		xsize |= (var->reserved[0] << 12);
+		var->reserved[0] = 0;
+		if (xsize > screen->mode.xres)
+			xsize = screen->mode.xres;
+		if (ysize > screen->mode.yres)
+			ysize = screen->mode.yres;
+	} else {		/*ohterwise  full  screen display */
+		xsize = screen->mode.xres;
+		ysize = screen->mode.yres;
+	}
+
+	win->colorspace = CSC_FORMAT(data_format);
+	data_format &= ~CSC_MASK;
+	fb_data_fmt = rk_fb_data_fmt(data_format, var->bits_per_pixel);
+	if (IS_FBDC_FMT(fb_data_fmt)) {
+		win->area[0].fbdc_en = 1;
+		win->area[0].fbdc_cor_en = 1;
+	} else {
+		win->area[0].fbdc_en = 0;
+		win->area[0].fbdc_cor_en = 0;
+	}
+	pixel_width = rk_fb_pixel_width(fb_data_fmt);
+	vir_width_bit = pixel_width * xvir;
+	/* pixel_width = byte_num * 8 */
+	stride_32bit_1 = ALIGN_N_TIMES(vir_width_bit, 32) / 8;
+	stride_32bit_2 = ALIGN_N_TIMES(vir_width_bit * 2, 32) / 8;
+
+	switch (fb_data_fmt) {
+	case YUV422:
+	case YUV422_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_1;
+		uv_x_off = xoffset;
+		uv_y_off = yoffset;
+		fix->line_length = stride;
+		uv_y_act = win->area[0].yact >> 1;
+		break;
+	case YUV420:		/* nv12 */
+	case YUV420_NV21:	/* nv21 */
+	case YUV420_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_1;
+		uv_x_off = xoffset;
+		uv_y_off = yoffset >> 1;
+		fix->line_length = stride;
+		uv_y_act = win->area[0].yact >> 1;
+		break;
+	case YUV444:
+	case YUV444_A:
+		is_pic_yuv = 1;
+		stride = stride_32bit_1;
+		uv_stride = stride_32bit_2;
+		uv_x_off = xoffset * 2;
+		uv_y_off = yoffset;
+		fix->line_length = stride << 2;
+		uv_y_act = win->area[0].yact;
+		break;
+	default:
+		stride = stride_32bit_1;	/* default rgb */
+		fix->line_length = stride;
+		break;
+	}
+
+	win->area[0].format = fb_data_fmt;
+	win->area[0].y_vir_stride = stride >> 2;
+	win->area[0].uv_vir_stride = uv_stride >> 2;
+	win->area[0].xpos = xpos;
+	win->area[0].ypos = ypos;
+	win->area[0].xsize = xsize;
+	win->area[0].ysize = ysize;
+	win->area[0].xact = var->xres;	/* winx active window height,is a wint of vir */
+	win->area[0].yact = var->yres;
+	win->area[0].xvir = var->xres_virtual;	/* virtual resolution  stride --->LCDC_WINx_VIR */
+	win->area[0].yvir = var->yres_virtual;
+	win->area[0].xoff = xoffset;
+	win->area[0].yoff = yoffset;
+	win->ymirror = 0;
+	win->state = 1;
+	win->last_state = 1;
+
+	win->area_num = 1;
+	win->alpha_mode = 4;	/* AB_SRC_OVER; */
+	win->alpha_en = ((win->area[0].format == ARGB888) ||
+			 (win->area[0].format == FBDC_ARGB_888) ||
+			 (win->area[0].format == FBDC_ABGR_888) ||
+			 (win->area[0].format == ABGR888)) ? 1 : 0;
+	win->g_alpha_val = 0;
+
+	dev_drv->ops->set_par(dev_drv, win_id);
+
+	return 0;
+}
+
+static inline unsigned int chan_to_field(unsigned int chan,
+					 struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int fb_setcolreg(unsigned regno,
+			unsigned red, unsigned green, unsigned blue,
+			unsigned transp, struct fb_info *info)
+{
+	unsigned int val;
+
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/* true-colour, use pseudo-palette */
+		if (regno < 16) {
+			u32 *pal = info->pseudo_palette;
+
+			val = chan_to_field(red, &info->var.red);
+			val |= chan_to_field(green, &info->var.green);
+			val |= chan_to_field(blue, &info->var.blue);
+			pal[regno] = val;
+		}
+		break;
+	default:
+		return -1;	/* unknown type */
+	}
+
+	return 0;
+}
+
+static int rk_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)info->par;
+	struct ion_handle *handle = fb_par->ion_hdl;
+	struct dma_buf *dma_buf = NULL;
+
+	if (IS_ERR_OR_NULL(handle)) {
+		dev_err(info->dev, "failed to get ion handle:%ld\n",
+			PTR_ERR(handle));
+		return -ENOMEM;
+	}
+	dma_buf = ion_share_dma_buf(rk_fb->ion_client, handle);
+	if (IS_ERR_OR_NULL(dma_buf)) {
+		pr_info("get ion share dma buf failed\n");
+		return -ENOMEM;
+	}
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	return dma_buf_mmap(dma_buf, vma, 0);
+}
+
+static struct fb_ops fb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = rk_fb_open,
+	.fb_release = rk_fb_close,
+	.fb_check_var = rk_fb_check_var,
+	.fb_set_par = rk_fb_set_par,
+	.fb_blank = rk_fb_blank,
+	.fb_ioctl = rk_fb_ioctl,
+	.fb_compat_ioctl = rk_fb_ioctl,
+	.fb_pan_display = rk_fb_pan_display,
+	.fb_read = rk_fb_read,
+	.fb_write = rk_fb_write,
+	.fb_setcolreg = fb_setcolreg,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+};
+
+static struct fb_var_screeninfo def_var = {
+#if defined(CONFIG_LOGO_LINUX_BMP)
+	.red = {16, 8, 0},
+	.green = {8, 8, 0},
+	.blue = {0, 8, 0},
+	.transp = {0, 0, 0},
+	.nonstd = HAL_PIXEL_FORMAT_BGRA_8888,
+#else
+	.red = {11, 5, 0},
+	.green = {5, 6, 0},
+	.blue = {0, 5, 0},
+	.transp = {0, 0, 0},
+	.nonstd = HAL_PIXEL_FORMAT_RGB_565,	/* (ypos<<20+xpos<<8+format) format */
+#endif
+	.grayscale = 0,		/* (ysize<<20+xsize<<8) */
+	.activate = FB_ACTIVATE_NOW,
+	.accel_flags = 0,
+	.vmode = FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo def_fix = {
+	.type = FB_TYPE_PACKED_PIXELS,
+	.type_aux = 0,
+	.xpanstep = 1,
+	.ypanstep = 1,
+	.ywrapstep = 0,
+	.accel = FB_ACCEL_NONE,
+	.visual = FB_VISUAL_TRUECOLOR,
+
+};
+
+static int rk_fb_wait_for_vsync_thread(void *data)
+{
+	struct rk_lcdc_driver *dev_drv = data;
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+	struct fb_info *fbi = rk_fb->fb[dev_drv->fb_index_base];
+
+	while (!kthread_should_stop()) {
+		ktime_t timestamp = dev_drv->vsync_info.timestamp;
+		int ret = wait_event_interruptible(dev_drv->vsync_info.wait,
+				!ktime_equal(timestamp, dev_drv->vsync_info.timestamp) &&
+				(dev_drv->vsync_info.active > 0 || dev_drv->vsync_info.irq_stop));
+
+		if (!ret)
+			sysfs_notify(&fbi->dev->kobj, NULL, "vsync");
+	}
+
+	return 0;
+}
+
+static ssize_t rk_fb_vsync_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	return scnprintf(buf, PAGE_SIZE, "%llu\n",
+			 ktime_to_ns(dev_drv->vsync_info.timestamp));
+}
+
+static DEVICE_ATTR(vsync, S_IRUGO, rk_fb_vsync_show, NULL);
+
+/*
+ * this two function is for other module that in the kernel which
+ * need show image directly through fb
+ * fb_id:we have 4 fb here,default we use fb0 for ui display
+ */
+struct fb_info *rk_get_fb(int fb_id)
+{
+	struct rk_fb *inf = platform_get_drvdata(fb_pdev);
+	struct fb_info *fb = inf->fb[fb_id];
+	return fb;
+}
+EXPORT_SYMBOL(rk_get_fb);
+
+void rk_direct_fb_show(struct fb_info *fbi)
+{
+	rk_fb_set_par(fbi);
+	rk_fb_pan_display(&fbi->var, fbi);
+}
+EXPORT_SYMBOL(rk_direct_fb_show);
+
+int rk_fb_dpi_open(bool open)
+{
+	struct rk_lcdc_driver *dev_drv = NULL;
+
+	dev_drv = rk_get_prmry_lcdc_drv();
+	if (dev_drv->ops->dpi_open)
+		dev_drv->ops->dpi_open(dev_drv, open);
+	return 0;
+}
+
+int rk_fb_dpi_win_sel(int win_id)
+{
+	struct rk_lcdc_driver *dev_drv = NULL;
+
+	dev_drv = rk_get_prmry_lcdc_drv();
+	if (dev_drv->ops->dpi_win_sel)
+		dev_drv->ops->dpi_win_sel(dev_drv, win_id);
+	return 0;
+}
+
+int rk_fb_dpi_status(void)
+{
+	int ret = 0;
+	struct rk_lcdc_driver *dev_drv = NULL;
+
+	dev_drv = rk_get_prmry_lcdc_drv();
+	if (dev_drv->ops->dpi_status)
+		ret = dev_drv->ops->dpi_status(dev_drv);
+
+	return ret;
+}
+
+/*
+ * function: this function will be called by display device, enable/disable lcdc
+ * @screen: screen timing to be set to lcdc
+ * @enable: 0 disable lcdc; 1 enable change lcdc timing; 2 just enable dclk
+ * @lcdc_id: the lcdc id the display device attached ,0 or 1
+ */
+int rk_fb_switch_screen(struct rk_screen *screen, int enable, int lcdc_id)
+{
+	struct rk_fb *rk_fb =  platform_get_drvdata(fb_pdev);
+	struct fb_info *info = NULL;
+	struct rk_fb_par *fb_par = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
+	struct rk_lcdc_win *win;
+	char name[6] = {0};
+	int i, win_id;
+	static bool load_screen;
+	char *envp[4];
+	char envplcdc[32];
+	char envpfbdev[32];
+	int ret, list_is_empty = 0;
+
+	if (unlikely(!rk_fb) || unlikely(!screen))
+		return -ENODEV;
+
+	/* get lcdc driver */
+	sprintf(name, "lcdc%d", lcdc_id);
+	dev_drv = rk_get_lcdc_drv(name);
+
+	if (dev_drv == NULL) {
+		pr_err("%s driver not found!", name);
+		return -ENODEV;
+	}
+	if (screen->type == SCREEN_HDMI)
+		pr_info("hdmi %s lcdc%d\n",
+			enable ? "connect to" : "remove from",
+			dev_drv->id);
+	else if (screen->type == SCREEN_TVOUT ||
+		 screen->type == SCREEN_TVOUT_TEST)
+		pr_info("cvbs %s lcdc%d\n",
+			enable ? "connect to" : "remove from",
+			dev_drv->id);
+	if (enable == 2 /*&& dev_drv->enable*/)
+		return 0;
+	pr_info("switch:en=%d,lcdc_id=%d,screen type=%d,cur type=%d",
+		enable, lcdc_id, screen->type, dev_drv->cur_screen->type);
+	pr_info("data space: %d, color mode: %d\n",
+		screen->data_space, screen->color_mode);
+
+	mutex_lock(&dev_drv->switch_screen);
+	dev_drv->hot_plug_state = enable;
+	hdmi_switch_state = 0;
+	dev_drv->hdmi_switch = 1;
+	if (!dev_drv->uboot_logo) {
+		mdelay(200);
+		list_is_empty = list_empty(&dev_drv->update_regs_list) &&
+					   list_empty(&dev_drv->saved_list);
+		if (!list_is_empty) {
+			ret = wait_event_timeout(dev_drv->update_regs_wait,
+						 list_empty(&dev_drv->update_regs_list) &&
+						 list_empty(&dev_drv->saved_list),
+						 msecs_to_jiffies(60));
+			if (ret <= 0)
+				pr_info("%s: wait update_regs_wait timeout\n",
+					__func__);
+		}
+	}
+
+	envp[0] = "switch vop screen";
+	memset(envplcdc, 0, sizeof(envplcdc));
+	memset(envpfbdev, 0, sizeof(envpfbdev));
+	sprintf(envplcdc, "SCREEN=%d,ENABLE=%d,VOPID=%d", screen->type, enable, dev_drv->id);
+	sprintf(envpfbdev, "FBDEV=%d", dev_drv->fb_index_base);
+	envp[1] = envplcdc;
+	envp[2] = envpfbdev;
+	envp[3] = NULL;
+
+	if ((rk_fb->disp_mode == ONE_DUAL) ||
+	    (rk_fb->disp_mode == NO_DUAL)) {
+		if ((dev_drv->ops->backlight_close) &&
+		    (rk_fb->disp_policy != DISPLAY_POLICY_BOX))
+			dev_drv->ops->backlight_close(dev_drv, 1);
+		if (!dev_drv->uboot_logo || load_screen ||
+		    (rk_fb->disp_policy != DISPLAY_POLICY_BOX)) {
+			if (dev_drv->ops->dsp_black)
+				dev_drv->ops->dsp_black(dev_drv, 0);
+		}
+		if ((dev_drv->ops->set_screen_scaler) &&
+		    (rk_fb->disp_mode == ONE_DUAL))
+			dev_drv->ops->set_screen_scaler(dev_drv,
+							dev_drv->screen0, 0);
+	}
+	if (!enable) {
+		/* if screen type is different, we do not disable lcdc. */
+		if (dev_drv->cur_screen->type != screen->type) {
+			dev_drv->hdmi_switch = 0;
+			mutex_unlock(&dev_drv->switch_screen);
+			return 0;
+		}
+
+		/* if used one lcdc to dual disp, no need to close win */
+		if ((rk_fb->disp_mode == ONE_DUAL) ||
+		    ((rk_fb->disp_mode == NO_DUAL) &&
+		    (rk_fb->disp_policy != DISPLAY_POLICY_BOX))) {
+			dev_drv->cur_screen = dev_drv->screen0;
+			dev_drv->ops->load_screen(dev_drv, 1);
+			/* force modify dsp size */
+			info = rk_fb->fb[dev_drv->fb_index_base];
+			info->var.grayscale &= 0xff;
+			info->var.grayscale |=
+				((dev_drv->cur_screen->mode.xres & 0xfff) << 8) +
+				(dev_drv->cur_screen->mode.yres << 20);
+			info->var.reserved[0] |= (dev_drv->cur_screen->mode.xres >> 12);
+			mutex_lock(&dev_drv->win_config);
+			info->var.xoffset = 0;
+			info->var.yoffset = 0;
+			info->fbops->fb_set_par(info);
+			info->fbops->fb_pan_display(&info->var, info);
+			mutex_unlock(&dev_drv->win_config);
+
+			/*
+			 * if currently is loader display, black until new
+			 * display job.
+			 */
+			if (dev_drv->uboot_logo) {
+				for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+					if (dev_drv->win[i] && dev_drv->win[i]->state &&
+					    dev_drv->ops->win_direct_en)
+						dev_drv->ops->win_direct_en(dev_drv, i, 0);
+				}
+			}
+
+			/*if (dev_drv->ops->dsp_black)
+			 *	dev_drv->ops->dsp_black(dev_drv, 0);
+			 */
+			if ((dev_drv->ops->backlight_close) &&
+			    (rk_fb->disp_policy != DISPLAY_POLICY_BOX))
+				dev_drv->ops->backlight_close(dev_drv, 0);
+		} else if (rk_fb->num_lcdc > 1) {
+			/* If there is more than one lcdc device, we disable
+			 *  the layer which attached to this device
+			 */
+			flush_kthread_worker(&dev_drv->update_regs_worker);
+			for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+				if (dev_drv->win[i] && dev_drv->win[i]->state)
+					dev_drv->ops->open(dev_drv, i, 0);
+			}
+		}
+		kobject_uevent_env(&dev_drv->dev->kobj, KOBJ_CHANGE, envp);
+
+		hdmi_switch_state = 0;
+		dev_drv->hdmi_switch = 0;
+		mutex_unlock(&dev_drv->switch_screen);
+		return 0;
+	} else {
+		if (load_screen || (rk_fb->disp_policy != DISPLAY_POLICY_BOX)) {
+			for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+				if (dev_drv->win[i] && dev_drv->win[i]->state &&
+					dev_drv->ops->win_direct_en)
+					dev_drv->ops->win_direct_en(dev_drv, i, 0);
+			}
+		}
+		if (dev_drv->screen1)
+			dev_drv->cur_screen = dev_drv->screen1;
+
+		memcpy(dev_drv->cur_screen, screen, sizeof(struct rk_screen));
+		dev_drv->cur_screen->xsize = dev_drv->cur_screen->mode.xres;
+		dev_drv->cur_screen->ysize = dev_drv->cur_screen->mode.yres;
+		dev_drv->cur_screen->x_mirror =
+					!!(dev_drv->rotate_mode & X_MIRROR);
+		dev_drv->cur_screen->y_mirror =
+					!!(dev_drv->rotate_mode & Y_MIRROR);
+	}
+
+	if (!dev_drv->uboot_logo || load_screen ||
+	    (rk_fb->disp_policy != DISPLAY_POLICY_BOX)) {
+		info = rk_fb->fb[dev_drv->fb_index_base];
+		fb_par = (struct rk_fb_par *)info->par;
+		win_id = 0;
+		win = dev_drv->win[win_id];
+		if (win && fb_par->state) {
+			dev_drv->ops->load_screen(dev_drv, 1);
+			info->var.activate |= FB_ACTIVATE_FORCE;
+			if (rk_fb->disp_mode == ONE_DUAL) {
+				info->var.grayscale &= 0xff;
+				info->var.grayscale |=
+					((dev_drv->cur_screen->mode.xres & 0xfff) << 8) +
+					(dev_drv->cur_screen->ysize << 20);
+				info->var.reserved[0] |= (dev_drv->cur_screen->mode.xres >> 12);
+			}
+			if (dev_drv->uboot_logo && win->state) {
+				if (win->area[0].xpos ||
+				    win->area[0].ypos) {
+					win->area[0].xpos =
+						(screen->mode.xres -
+						 win->area[0].xsize) / 2;
+					win->area[0].ypos =
+						(screen->mode.yres -
+						 win->area[0].ysize) / 2;
+				} else {
+					win->area[0].xsize = screen->mode.xres;
+					win->area[0].ysize = screen->mode.yres;
+				}
+				dev_drv->ops->set_par(dev_drv, i);
+				dev_drv->ops->cfg_done(dev_drv);
+			} else if (!dev_drv->win[win_id]->state) {
+				dev_drv->ops->open(dev_drv, win_id, 1);
+				info->fbops->fb_pan_display(&info->var, info);
+			}
+		}
+	} else {
+		dev_drv->ops->load_screen(dev_drv, 0);
+	}
+	kobject_uevent_env(&dev_drv->dev->kobj, KOBJ_CHANGE, envp);
+
+	if (dev_drv->cur_screen->width && dev_drv->cur_screen->height) {
+		/* for vr auto dp support */
+		info = rk_fb->fb[dev_drv->fb_index_base];
+		info->var.width = dev_drv->cur_screen->width;
+		info->var.height = dev_drv->cur_screen->height;
+		pr_info("%s:info->var.width=%d, info->var.height=%d\n",
+			__func__, info->var.width, info->var.height);
+	}
+
+	hdmi_switch_state = 1;
+	load_screen = true;
+	dev_drv->hdmi_switch = 0;
+	if ((rk_fb->disp_mode == ONE_DUAL) || (rk_fb->disp_mode == NO_DUAL)) {
+		if ((dev_drv->ops->set_screen_scaler) &&
+		    (rk_fb->disp_mode == ONE_DUAL))
+			dev_drv->ops->set_screen_scaler(dev_drv,
+							dev_drv->screen0, 1);
+		/*if (dev_drv->ops->dsp_black)
+		 *	dev_drv->ops->dsp_black(dev_drv, 0);*/
+		if ((dev_drv->ops->backlight_close) &&
+		    (rk_fb->disp_policy != DISPLAY_POLICY_BOX) &&
+		    (rk_fb->disp_mode == ONE_DUAL))
+			dev_drv->ops->backlight_close(dev_drv, 0);
+	}
+	mutex_unlock(&dev_drv->switch_screen);
+	return 0;
+}
+
+/*
+ * function:this function current only called by hdmi for
+ *	scale the display
+ * scale_x: scale rate of x resolution
+ * scale_y: scale rate of y resolution
+ * lcdc_id: the lcdc id the hdmi attached ,0 or 1
+ */
+int rk_fb_disp_scale(u8 scale_x, u8 scale_y, u8 lcdc_id)
+{
+	struct rk_fb *inf = platform_get_drvdata(fb_pdev);
+	struct fb_info *info = NULL;
+	struct fb_info *pmy_info = NULL;
+	struct fb_var_screeninfo *var = NULL;
+	struct rk_lcdc_driver *dev_drv = NULL;
+	u16 screen_x, screen_y;
+	u16 xpos, ypos;
+	char name[6];
+	struct rk_screen primary_screen;
+
+	rk_fb_get_prmry_screen(&primary_screen);
+	if (primary_screen.type == SCREEN_HDMI)
+		return 0;
+
+	pr_err("should not be here--%s\n", __func__);
+
+	return 0;
+	sprintf(name, "lcdc%d", lcdc_id);
+
+	if (inf->disp_mode == DUAL) {
+		dev_drv = rk_get_lcdc_drv(name);
+		if (!dev_drv) {
+			pr_err("%s driver not found!", name);
+			return -ENODEV;
+		}
+	} else {
+		dev_drv = inf->lcdc_dev_drv[0];
+	}
+
+	if (inf->num_lcdc == 1) {
+		info = inf->fb[0];
+	} else if (inf->num_lcdc == 2) {
+		info = inf->fb[dev_drv->lcdc_win_num];
+		pmy_info = inf->fb[0];
+	}
+
+	var = &info->var;
+	screen_x = dev_drv->cur_screen->mode.xres;
+	screen_y = dev_drv->cur_screen->mode.yres;
+
+	if (inf->disp_mode != DUAL && dev_drv->screen1) {
+		dev_drv->cur_screen->xpos =
+		    (screen_x - screen_x * scale_x / 100) >> 1;
+		dev_drv->cur_screen->ypos =
+		    (screen_y - screen_y * scale_y / 100) >> 1;
+		dev_drv->cur_screen->xsize = screen_x * scale_x / 100;
+		dev_drv->cur_screen->ysize = screen_y * scale_y / 100;
+	} else {
+		xpos = (screen_x - screen_x * scale_x / 100) >> 1;
+		ypos = (screen_y - screen_y * scale_y / 100) >> 1;
+		dev_drv->cur_screen->xsize = screen_x * scale_x / 100;
+		dev_drv->cur_screen->ysize = screen_y * scale_y / 100;
+		if (inf->disp_mode == ONE_DUAL) {
+			var->nonstd &= 0xff;
+			var->nonstd |= (xpos << 8) + (ypos << 20);
+			var->grayscale &= 0xff;
+			var->grayscale |=
+				(dev_drv->cur_screen->xsize << 8) +
+				(dev_drv->cur_screen->ysize << 20);
+		}
+	}
+
+	mutex_lock(&dev_drv->win_config);
+	info->fbops->fb_set_par(info);
+	dev_drv->ops->cfg_done(dev_drv);
+	mutex_unlock(&dev_drv->win_config);
+
+	return 0;
+}
+
+#if defined(CONFIG_ION_ROCKCHIP)
+static int rk_fb_alloc_buffer_by_ion(struct fb_info *fbi,
+				     struct rk_lcdc_win *win,
+				     unsigned long fb_mem_size)
+{
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct ion_handle *handle;
+	ion_phys_addr_t phy_addr;
+	size_t len;
+	int ret = 0;
+
+	if (dev_drv->iommu_enabled)
+		handle = ion_alloc(rk_fb->ion_client, (size_t)fb_mem_size, 0,
+				   ION_HEAP_SYSTEM_MASK, 0);
+	else
+		handle = ion_alloc(rk_fb->ion_client, (size_t)fb_mem_size, 0,
+				   ION_HEAP_TYPE_DMA_MASK, 0);
+
+	if (IS_ERR(handle)) {
+		dev_err(fbi->device, "failed to ion_alloc:%ld\n",
+			PTR_ERR(handle));
+		return -ENOMEM;
+	}
+
+	fb_par->ion_hdl = handle;
+	win->area[0].dma_buf = ion_share_dma_buf(rk_fb->ion_client, handle);
+	if (IS_ERR_OR_NULL(win->area[0].dma_buf)) {
+		pr_info("ion_share_dma_buf() failed\n");
+		goto err_share_dma_buf;
+	}
+	win->area[0].ion_hdl = handle;
+	if (dev_drv->prop == PRMRY)
+		fbi->screen_base = ion_map_kernel(rk_fb->ion_client, handle);
+	if (dev_drv->iommu_enabled && dev_drv->mmu_dev)
+		ret = ion_map_iommu(dev_drv->dev, rk_fb->ion_client, handle,
+				    (unsigned long *)&phy_addr,
+				    (unsigned long *)&len);
+	else
+		ret = ion_phys(rk_fb->ion_client, handle, &phy_addr, &len);
+	if (ret < 0) {
+		dev_err(fbi->dev, "ion map to get phy addr failed\n");
+		goto err_share_dma_buf;
+	}
+	fbi->fix.smem_start = phy_addr;
+	fbi->fix.smem_len = len;
+	pr_info("alloc_buffer:ion_phy_addr=0x%lx\n", phy_addr);
+	return 0;
+
+err_share_dma_buf:
+	ion_free(rk_fb->ion_client, handle);
+	return -ENOMEM;
+}
+#endif
+
+static int rk_fb_alloc_buffer(struct fb_info *fbi)
+{
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_lcdc_win *win = NULL;
+	int win_id;
+	int ret = 0;
+	unsigned long fb_mem_size;
+#if !defined(CONFIG_ION_ROCKCHIP)
+	dma_addr_t fb_mem_phys;
+	void *fb_mem_virt;
+#endif
+	ion_phys_addr_t phy_addr;
+	size_t len;
+
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
+	if (win_id < 0)
+		return -ENODEV;
+	else
+		win = dev_drv->win[win_id];
+
+	if (!strcmp(fbi->fix.id, "fb0")) {
+		fb_mem_size = get_fb_size(dev_drv->reserved_fb);
+#if defined(CONFIG_ION_ROCKCHIP)
+		if (rk_fb_alloc_buffer_by_ion(fbi, win, fb_mem_size) < 0)
+			return -ENOMEM;
+#else
+		fb_mem_virt = dma_alloc_writecombine(fbi->dev, fb_mem_size,
+						     &fb_mem_phys, GFP_KERNEL);
+		if (!fb_mem_virt) {
+			pr_err("%s: Failed to allocate framebuffer\n",
+			       __func__);
+			return -ENOMEM;
+		}
+		fbi->fix.smem_len = fb_mem_size;
+		fbi->fix.smem_start = fb_mem_phys;
+		fbi->screen_base = fb_mem_virt;
+#endif
+		memset(fbi->screen_base, 0, fbi->fix.smem_len);
+	} else {
+		if (dev_drv->prop == EXTEND && dev_drv->iommu_enabled) {
+			struct rk_lcdc_driver *dev_drv_prmry;
+			int win_id_prmry;
+
+			fb_mem_size = get_fb_size(dev_drv->reserved_fb);
+#if defined(CONFIG_ION_ROCKCHIP)
+			dev_drv_prmry = rk_get_prmry_lcdc_drv();
+			if (dev_drv_prmry == NULL)
+				return -ENODEV;
+			win_id_prmry =
+				dev_drv_prmry->ops->fb_get_win_id(dev_drv_prmry,
+								 fbi->fix.id);
+			if (win_id_prmry < 0)
+				return -ENODEV;
+			else
+				fb_par->ion_hdl =
+				dev_drv_prmry->win[win_id_prmry]->area[0].ion_hdl;
+			fbi->screen_base =
+				ion_map_kernel(rk_fb->ion_client,
+					       fb_par->ion_hdl);
+			dev_drv->win[win_id]->area[0].ion_hdl =
+				fb_par->ion_hdl;
+			if (dev_drv->mmu_dev)
+				ret = ion_map_iommu(dev_drv->dev,
+						    rk_fb->ion_client,
+						    fb_par->ion_hdl,
+						    (unsigned long *)&phy_addr,
+						    (unsigned long *)&len);
+			else
+				ret = ion_phys(rk_fb->ion_client,
+					       fb_par->ion_hdl,
+					       &phy_addr, &len);
+			if (ret < 0) {
+				dev_err(fbi->dev, "ion map to get phy addr failed\n");
+				return -ENOMEM;
+			}
+			fbi->fix.smem_start = phy_addr;
+			fbi->fix.smem_len = len;
+#else
+			fb_mem_virt = dma_alloc_writecombine(fbi->dev,
+							     fb_mem_size,
+							     &fb_mem_phys,
+							     GFP_KERNEL);
+			if (!fb_mem_virt) {
+				pr_err("%s: Failed to allocate framebuffer\n",
+				       __func__);
+				return -ENOMEM;
+			}
+			fbi->fix.smem_len = fb_mem_size;
+			fbi->fix.smem_start = fb_mem_phys;
+			fbi->screen_base = fb_mem_virt;
+#endif
+		} else {
+			fbi->fix.smem_start = rk_fb->fb[0]->fix.smem_start;
+			fbi->fix.smem_len = rk_fb->fb[0]->fix.smem_len;
+			fbi->screen_base = rk_fb->fb[0]->screen_base;
+		}
+	}
+
+	fbi->screen_size = fbi->fix.smem_len;
+	fb_par->fb_phy_base = fbi->fix.smem_start;
+	fb_par->fb_virt_base = fbi->screen_base;
+	fb_par->fb_size = fbi->fix.smem_len;
+
+	pr_info("%s:phy:%lx>>vir:%p>>len:0x%x\n", fbi->fix.id,
+		fbi->fix.smem_start, fbi->screen_base,
+		fbi->fix.smem_len);
+	return ret;
+}
+
+#if 0
+static int rk_release_fb_buffer(struct fb_info *fbi)
+{
+	/* buffer for fb1 and fb3 are alloc by android */
+	if (!strcmp(fbi->fix.id, "fb1") || !strcmp(fbi->fix.id, "fb3"))
+		return 0;
+	iounmap(fbi->screen_base);
+	release_mem_region(fbi->fix.smem_start, fbi->fix.smem_len);
+	return 0;
+}
+#endif
+
+static int init_lcdc_win(struct rk_lcdc_driver *dev_drv,
+			 struct rk_lcdc_win *def_win)
+{
+	int i;
+	int lcdc_win_num = dev_drv->lcdc_win_num;
+
+	for (i = 0; i < lcdc_win_num; i++) {
+		struct rk_lcdc_win *win = NULL;
+
+		win = kzalloc(sizeof(struct rk_lcdc_win), GFP_KERNEL);
+		if (!win) {
+			dev_err(dev_drv->dev, "kzmalloc for win fail!");
+			return -ENOMEM;
+		}
+
+		strcpy(win->name, def_win[i].name);
+		win->id = def_win[i].id;
+		win->support_3d = def_win[i].support_3d;
+		win->property.feature = def_win[i].property.feature;
+		win->property.max_input_x = def_win[i].property.max_input_x;
+		win->property.max_input_y = def_win[i].property.max_input_y;
+		dev_drv->win[i] = win;
+	}
+
+	return 0;
+}
+
+static int init_lcdc_device_driver(struct rk_fb *rk_fb,
+				   struct rk_lcdc_win *def_win, int index)
+{
+	struct rk_lcdc_driver *dev_drv = rk_fb->lcdc_dev_drv[index];
+	struct rk_screen *screen = devm_kzalloc(dev_drv->dev,
+						sizeof(struct rk_screen),
+						GFP_KERNEL);
+	int i = 0;
+
+	if (!screen) {
+		dev_err(dev_drv->dev, "malloc screen for lcdc%d fail!",
+			dev_drv->id);
+		return -ENOMEM;
+	}
+
+	screen->screen_id = 0;
+	screen->lcdc_id = dev_drv->id;
+	screen->overscan.left = 100;
+	screen->overscan.top = 100;
+	screen->overscan.right = 100;
+	screen->overscan.bottom = 100;
+
+	screen->x_mirror = !!(dev_drv->rotate_mode & X_MIRROR);
+	screen->y_mirror = !!(dev_drv->rotate_mode & Y_MIRROR);
+
+	dev_drv->screen0 = screen;
+	dev_drv->cur_screen = screen;
+	/* devie use one lcdc + rk61x scaler for dual display */
+	if ((rk_fb->disp_mode == ONE_DUAL) || (rk_fb->disp_mode == NO_DUAL)) {
+		struct rk_screen *screen1 =
+				devm_kzalloc(dev_drv->dev,
+					     sizeof(struct rk_screen),
+					     GFP_KERNEL);
+		if (!screen1) {
+			dev_err(dev_drv->dev, "malloc screen1 for lcdc%d fail!",
+				dev_drv->id);
+			return -ENOMEM;
+		}
+		screen1->screen_id = 1;
+		screen1->lcdc_id = 1;
+		dev_drv->screen1 = screen1;
+	}
+	sprintf(dev_drv->name, "lcdc%d", dev_drv->id);
+	init_lcdc_win(dev_drv, def_win);
+	init_completion(&dev_drv->frame_done);
+	spin_lock_init(&dev_drv->cpl_lock);
+	mutex_init(&dev_drv->fb_win_id_mutex);
+	mutex_init(&dev_drv->win_config);
+	mutex_init(&dev_drv->front_lock);
+	mutex_init(&dev_drv->switch_screen);
+	dev_drv->ops->fb_win_remap(dev_drv, dev_drv->fb_win_map);
+	dev_drv->first_frame = 1;
+	dev_drv->overscan.left = 100;
+	dev_drv->overscan.top = 100;
+	dev_drv->overscan.right = 100;
+	dev_drv->overscan.bottom = 100;
+	for (i = 0; i < RK30_MAX_LAYER_SUPPORT; i++)
+		dev_drv->area_support[i] = 1;
+	if (dev_drv->ops->area_support_num)
+		dev_drv->ops->area_support_num(dev_drv, dev_drv->area_support);
+	rk_disp_pwr_ctr_parse_dt(dev_drv);
+	if (dev_drv->prop == PRMRY) {
+		rk_fb_set_prmry_screen(screen);
+		rk_fb_get_prmry_screen(screen);
+	}
+	dev_drv->trsm_ops = rk_fb_trsm_ops_get(screen->type);
+	if (dev_drv->prop != PRMRY)
+		rk_fb_get_extern_screen(screen);
+	dev_drv->output_color = screen->color_mode;
+
+	return 0;
+}
+
+#ifdef CONFIG_LOGO_LINUX_BMP
+static struct linux_logo *bmp_logo;
+static int fb_prewine_bmp_logo(struct fb_info *info, int rotate)
+{
+	bmp_logo = fb_find_logo(24);
+	if (bmp_logo == NULL) {
+		pr_info("%s error\n", __func__);
+		return 0;
+	}
+	return 1;
+}
+
+static void fb_show_bmp_logo(struct fb_info *info, int rotate)
+{
+	unsigned char *src = bmp_logo->data;
+	unsigned char *dst = info->screen_base;
+	int i;
+	unsigned int needwidth = (*(src - 24) << 8) | (*(src - 23));
+	unsigned int needheight = (*(src - 22) << 8) | (*(src - 21));
+
+	for (i = 0; i < needheight; i++)
+		memcpy(dst + info->var.xres * i * 4,
+		       src + bmp_logo->width * i * 4, needwidth * 4);
+}
+#endif
+
+/*
+ * check if the primary lcdc has registered,
+ * the primary lcdc mas register first
+ */
+bool is_prmry_rk_lcdc_registered(void)
+{
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+
+	if (rk_fb->lcdc_dev_drv[0])
+		return true;
+	else
+		return false;
+}
+
+phys_addr_t uboot_logo_base;
+phys_addr_t uboot_logo_size;
+phys_addr_t uboot_logo_offset;
+
+static int __init rockchip_uboot_mem_late_init(void)
+{
+	int err;
+
+	if (uboot_logo_size) {
+		void *start = phys_to_virt(uboot_logo_base);
+		void *end = phys_to_virt(uboot_logo_base + uboot_logo_size);
+
+		err = memblock_free(uboot_logo_base, uboot_logo_size);
+		if (err < 0)
+			pr_err("%s: freeing memblock failed: %d\n",
+			       __func__, err);
+		free_reserved_area(start, end, -1, "logo");
+	}
+	return 0;
+}
+
+late_initcall(rockchip_uboot_mem_late_init);
+
+int rk_fb_register(struct rk_lcdc_driver *dev_drv,
+		   struct rk_lcdc_win *win, int id)
+{
+	struct rk_fb *rk_fb = platform_get_drvdata(fb_pdev);
+	struct fb_info *fbi;
+	struct rk_fb_par *fb_par = NULL;
+	int i = 0, ret = 0, index = 0;
+	unsigned long flags;
+	char time_line_name[16];
+	int mirror = 0;
+
+	if (rk_fb->num_lcdc == RK30_MAX_LCDC_SUPPORT)
+		return -ENXIO;
+
+	for (i = 0; i < RK30_MAX_LCDC_SUPPORT; i++) {
+		if (!rk_fb->lcdc_dev_drv[i]) {
+			rk_fb->lcdc_dev_drv[i] = dev_drv;
+			rk_fb->lcdc_dev_drv[i]->id = id;
+			rk_fb->num_lcdc++;
+			break;
+		}
+	}
+
+	index = i;
+	init_lcdc_device_driver(rk_fb, win, index);
+	dev_drv->fb_index_base = rk_fb->num_fb;
+	for (i = 0; i < dev_drv->lcdc_win_num; i++) {
+		fbi = framebuffer_alloc(0, &fb_pdev->dev);
+		if (!fbi) {
+			dev_err(&fb_pdev->dev, "fb framebuffer_alloc fail!");
+			return -ENOMEM;
+		}
+		fb_par = devm_kzalloc(&fb_pdev->dev, sizeof(struct rk_fb_par),
+				      GFP_KERNEL);
+		if (!fb_par) {
+			dev_err(&fb_pdev->dev, "malloc fb_par for fb%d fail!",
+				rk_fb->num_fb);
+			return -ENOMEM;
+		}
+		fb_par->id = rk_fb->num_fb;
+		fb_par->lcdc_drv = dev_drv;
+		fbi->par = (void *)fb_par;
+		fbi->var = def_var;
+		fbi->fix = def_fix;
+		sprintf(fbi->fix.id, "fb%d", rk_fb->num_fb);
+		fb_videomode_to_var(&fbi->var, &dev_drv->cur_screen->mode);
+		if (dev_drv->dsp_mode == ONE_VOP_DUAL_MIPI_VER_SCAN) {
+			fbi->var.xres /= 2;
+			fbi->var.yres *= 2;
+			fbi->var.xres_virtual /= 2;
+			fbi->var.yres_virtual *= 2;
+		}
+		fbi->var.width = dev_drv->cur_screen->width;
+		fbi->var.height = dev_drv->cur_screen->height;
+		fbi->var.grayscale |=
+		    ((fbi->var.xres & 0xfff) << 8) + (fbi->var.yres << 20);
+		fbi->var.reserved[0] |= (fbi->var.xres >> 12);
+#if defined(CONFIG_LOGO_LINUX_BMP)
+		fbi->var.bits_per_pixel = 32;
+#else
+		fbi->var.bits_per_pixel = 16;
+#endif
+		fbi->fix.line_length =
+		    (fbi->var.xres_virtual) * (fbi->var.bits_per_pixel >> 3);
+		if (dev_drv->iommu_enabled)
+			fb_ops.fb_mmap = rk_fb_mmap;
+		fbi->fbops = &fb_ops;
+		fbi->flags = FBINFO_FLAG_DEFAULT;
+		fbi->pseudo_palette = dev_drv->win[i]->pseudo_pal;
+		ret = register_framebuffer(fbi);
+		if (ret < 0) {
+			dev_err(&fb_pdev->dev,
+				"%s fb%d register_framebuffer fail!\n",
+				__func__, rk_fb->num_fb);
+			return ret;
+		}
+		rkfb_create_sysfs(fbi);
+		rk_fb->fb[rk_fb->num_fb] = fbi;
+		dev_info(fbi->dev, "rockchip framebuffer registerd:%s\n",
+			 fbi->fix.id);
+		rk_fb->num_fb++;
+
+		if (i == 0) {
+			init_waitqueue_head(&dev_drv->vsync_info.wait);
+			init_waitqueue_head(&dev_drv->update_regs_wait);
+			ret = device_create_file(fbi->dev, &dev_attr_vsync);
+			if (ret)
+				dev_err(fbi->dev,
+					"failed to create vsync file\n");
+			dev_drv->vsync_info.thread =
+			    kthread_run(rk_fb_wait_for_vsync_thread, dev_drv,
+					"fb-vsync");
+			if (dev_drv->vsync_info.thread == ERR_PTR(-ENOMEM)) {
+				dev_err(fbi->dev,
+					"failed to run vsync thread\n");
+				dev_drv->vsync_info.thread = NULL;
+			}
+			dev_drv->vsync_info.active = 1;
+
+			mutex_init(&dev_drv->output_lock);
+
+			INIT_LIST_HEAD(&dev_drv->update_regs_list);
+			INIT_LIST_HEAD(&dev_drv->saved_list);
+			mutex_init(&dev_drv->update_regs_list_lock);
+			init_kthread_worker(&dev_drv->update_regs_worker);
+
+			dev_drv->update_regs_thread =
+			    kthread_run(kthread_worker_fn,
+					&dev_drv->update_regs_worker, "rk-fb");
+			if (IS_ERR(dev_drv->update_regs_thread)) {
+				int err = PTR_ERR(dev_drv->update_regs_thread);
+
+				dev_drv->update_regs_thread = NULL;
+				pr_info("failed to run update_regs thread\n");
+				return err;
+			}
+			init_kthread_work(&dev_drv->update_regs_work,
+					  rk_fb_update_regs_handler);
+
+			snprintf(time_line_name, sizeof(time_line_name),
+				 "vop%d-timeline", id);
+			dev_drv->timeline =
+			    sw_sync_timeline_create(time_line_name);
+			dev_drv->timeline_max = 1;
+		}
+	}
+
+	/* show logo for primary display device */
+#if !defined(CONFIG_FRAMEBUFFER_CONSOLE)
+	if (dev_drv->prop == PRMRY) {
+		u16 xact, yact;
+		int format;
+		u32 dsp_addr;
+		struct fb_info *main_fbi = rk_fb->fb[0];
+
+		main_fbi->fbops->fb_open(main_fbi, 1);
+		main_fbi->var.pixclock = dev_drv->pixclock;
+		if (dev_drv->iommu_enabled) {
+			if (dev_drv->mmu_dev)
+				rockchip_iovmm_set_fault_handler(dev_drv->dev,
+						rk_fb_sysmmu_fault_handler);
+		}
+
+		rk_fb_alloc_buffer(main_fbi);	/* only alloc memory for main fb */
+		dev_drv->uboot_logo = support_uboot_display();
+
+		if (dev_drv->uboot_logo &&
+		    uboot_logo_offset && uboot_logo_base) {
+			int width, height, bits, xvir;
+			phys_addr_t start = uboot_logo_base + uboot_logo_offset;
+			unsigned int size = uboot_logo_size - uboot_logo_offset;
+			unsigned int nr_pages;
+			int ymirror = 0;
+			struct page **pages;
+			char *vaddr;
+			int logo_len, i = 0;
+
+			if (dev_drv->ops->get_dspbuf_info)
+				dev_drv->ops->get_dspbuf_info(dev_drv, &xact,
+					&yact, &format,	&dsp_addr, &ymirror);
+			logo_len = rk_fb_pixel_width(format) * xact * yact >> 3;
+			nr_pages = size >> PAGE_SHIFT;
+			pages = kzalloc(sizeof(struct page) * nr_pages,
+					GFP_KERNEL);
+			if (!pages)
+				return -ENOMEM;
+			while (i < nr_pages) {
+				pages[i] = phys_to_page(start);
+				start += PAGE_SIZE;
+				i++;
+			}
+			vaddr = vmap(pages, nr_pages, VM_MAP, PAGE_KERNEL);
+			if (!vaddr) {
+				pr_err("failed to vmap phy addr 0x%lx\n",
+				       (long)(uboot_logo_base +
+				       uboot_logo_offset));
+				kfree(pages);
+				return -1;
+			}
+
+			if (bmpdecoder(vaddr, main_fbi->screen_base, &width,
+				       &height, &bits)) {
+				kfree(pages);
+				vunmap(vaddr);
+				return 0;
+			}
+			kfree(pages);
+			vunmap(vaddr);
+			if (width != xact || height != yact) {
+				pr_err("can't support uboot kernel logo use different size [%dx%d] != [%dx%d]\n",
+				       xact, yact, width, height);
+				return 0;
+			}
+			xvir = ALIGN(width * bits, 1 << 5) >> 5;
+			ymirror = 0;
+			local_irq_save(flags);
+			if (dev_drv->ops->wait_frame_start)
+				dev_drv->ops->wait_frame_start(dev_drv, 0);
+			mirror = ymirror || dev_drv->cur_screen->y_mirror;
+			if (dev_drv->ops->post_dspbuf) {
+				dev_drv->ops->post_dspbuf(dev_drv,
+					main_fbi->fix.smem_start +
+					(mirror ? logo_len : 0),
+					rk_fb_data_fmt(0, bits),
+					width, height, xvir,
+					ymirror);
+			}
+			if (dev_drv->iommu_enabled) {
+				rk_fb_poll_wait_frame_complete();
+				if (dev_drv->ops->mmu_en)
+					dev_drv->ops->mmu_en(dev_drv);
+				freed_index = 0;
+			}
+			local_irq_restore(flags);
+			return 0;
+		} else if (dev_drv->uboot_logo && uboot_logo_base) {
+			u32 start = uboot_logo_base;
+			int logo_len, i = 0;
+			int y_mirror = 0;
+			unsigned int nr_pages;
+			struct page **pages;
+			char *vaddr;
+			int align = 0, xvir;
+
+			dev_drv->ops->get_dspbuf_info(dev_drv, &xact,
+						      &yact, &format,
+						      &start,
+						      &y_mirror);
+			logo_len = rk_fb_pixel_width(format) * xact * yact >> 3;
+			if (logo_len > uboot_logo_size ||
+			    logo_len > main_fbi->fix.smem_len) {
+				pr_err("logo size > uboot reserve buffer size\n");
+				return -1;
+			}
+			if (y_mirror)
+				start -= logo_len;
+
+			align = start % PAGE_SIZE;
+			start -= align;
+			nr_pages = PAGE_ALIGN(logo_len + align) >> PAGE_SHIFT;
+			pages = kzalloc(sizeof(struct page) * nr_pages,
+					GFP_KERNEL);
+			if (!pages)
+				return -ENOMEM;
+			while (i < nr_pages) {
+				pages[i] = phys_to_page(start);
+				start += PAGE_SIZE;
+				i++;
+			}
+			vaddr = vmap(pages, nr_pages, VM_MAP, PAGE_KERNEL);
+			if (!vaddr) {
+				pr_err("failed to vmap phy addr 0x%x\n",
+				       start);
+				kfree(pages);
+				return -1;
+			}
+
+			memcpy(main_fbi->screen_base, vaddr + align, logo_len);
+
+			kfree(pages);
+			vunmap(vaddr);
+			xvir = ALIGN(xact * rk_fb_pixel_width(format),
+				     1 << 5) >> 5;
+			local_irq_save(flags);
+			if (dev_drv->ops->wait_frame_start)
+				dev_drv->ops->wait_frame_start(dev_drv, 0);
+			mirror = y_mirror || dev_drv->cur_screen->y_mirror;
+			dev_drv->ops->post_dspbuf(dev_drv,
+					main_fbi->fix.smem_start +
+					(mirror ? logo_len : 0),
+					format,	xact, yact,
+					xvir,
+					y_mirror);
+			if (dev_drv->iommu_enabled) {
+				rk_fb_poll_wait_frame_complete();
+				if (dev_drv->ops->mmu_en)
+					dev_drv->ops->mmu_en(dev_drv);
+				freed_index = 0;
+			}
+			local_irq_restore(flags);
+			return 0;
+		} else {
+			if (dev_drv->iommu_enabled) {
+				if (dev_drv->ops->mmu_en)
+					dev_drv->ops->mmu_en(dev_drv);
+				freed_index = 0;
+			}
+		}
+#if defined(CONFIG_LOGO)
+		main_fbi->fbops->fb_set_par(main_fbi);
+#if  defined(CONFIG_LOGO_LINUX_BMP)
+		if (fb_prewine_bmp_logo(main_fbi, FB_ROTATE_UR)) {
+			fb_set_cmap(&main_fbi->cmap, main_fbi);
+			fb_show_bmp_logo(main_fbi, FB_ROTATE_UR);
+		}
+#else
+		if (fb_prepare_logo(main_fbi, FB_ROTATE_UR)) {
+			fb_set_cmap(&main_fbi->cmap, main_fbi);
+			fb_show_logo(main_fbi, FB_ROTATE_UR);
+		}
+#endif
+		main_fbi->fbops->fb_pan_display(&main_fbi->var, main_fbi);
+#endif
+	} else {
+		struct fb_info *extend_fbi = rk_fb->fb[dev_drv->fb_index_base];
+
+		extend_fbi->var.pixclock = rk_fb->fb[0]->var.pixclock;
+		if (rk_fb->disp_mode == DUAL_LCD) {
+			extend_fbi->fbops->fb_open(extend_fbi, 1);
+			if (dev_drv->iommu_enabled) {
+				if (dev_drv->mmu_dev)
+					rockchip_iovmm_set_fault_handler(dev_drv->dev,
+									 rk_fb_sysmmu_fault_handler);
+			}
+			rk_fb_alloc_buffer(extend_fbi);
+		}
+	}
+#endif
+	return 0;
+}
+
+int rk_fb_unregister(struct rk_lcdc_driver *dev_drv)
+{
+	struct rk_fb *fb_inf = platform_get_drvdata(fb_pdev);
+	struct fb_info *fbi;
+	int fb_index_base = dev_drv->fb_index_base;
+	int fb_num = dev_drv->lcdc_win_num;
+	int i = 0;
+
+	if (fb_inf->lcdc_dev_drv[i]->vsync_info.thread) {
+		fb_inf->lcdc_dev_drv[i]->vsync_info.irq_stop = 1;
+		kthread_stop(fb_inf->lcdc_dev_drv[i]->vsync_info.thread);
+	}
+
+	for (i = 0; i < fb_num; i++)
+		kfree(dev_drv->win[i]);
+
+	for (i = fb_index_base; i < (fb_index_base + fb_num); i++) {
+		fbi = fb_inf->fb[i];
+		unregister_framebuffer(fbi);
+		/* rk_release_fb_buffer(fbi); */
+		framebuffer_release(fbi);
+	}
+	fb_inf->lcdc_dev_drv[dev_drv->id] = NULL;
+	fb_inf->num_lcdc--;
+
+	return 0;
+}
+
+int rk_fb_set_car_reverse_status(struct rk_lcdc_driver *dev_drv,
+				 int status)
+{
+	char *envp[3] = {"Request", "FORCE UPDATE", NULL};
+
+	if (status) {
+		car_reversing = 1;
+		flush_kthread_worker(&dev_drv->update_regs_worker);
+		dev_drv->timeline_max++;
+#ifdef H_USE_FENCE
+		sw_sync_timeline_inc(dev_drv->timeline, 1);
+#endif
+		pr_debug("%s: camcap reverse start...\n", __func__);
+	} else {
+		car_reversing = 0;
+		kobject_uevent_env(&dev_drv->dev->kobj,
+				   KOBJ_CHANGE, envp);
+		pr_debug("%s: camcap reverse finish...\n", __func__);
+	}
+
+	return 0;
+}
+
+static int rk_fb_probe(struct platform_device *pdev)
+{
+	struct rk_fb *rk_fb = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	u32 mode, ret;
+	struct device_node *node;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing device tree node.\n");
+		return -EINVAL;
+	}
+
+	rk_fb = devm_kzalloc(&pdev->dev, sizeof(struct rk_fb), GFP_KERNEL);
+	if (!rk_fb) {
+		dev_err(&pdev->dev, "kmalloc for rk fb fail!");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, rk_fb);
+
+	if (!of_property_read_u32(np, "rockchip,disp-mode", &mode)) {
+		rk_fb->disp_mode = mode;
+
+	} else {
+		dev_err(&pdev->dev, "no disp-mode node found!");
+		return -ENODEV;
+	}
+
+	if (!of_property_read_u32(np, "rockchip,disp-policy", &mode)) {
+		rk_fb->disp_policy = mode;
+		pr_info("fb disp policy is %s\n",
+			rk_fb->disp_policy ? "box" : "sdk");
+	}
+
+	if (!of_property_read_u32(np, "rockchip,uboot-logo-on", &uboot_logo_on))
+		pr_info("uboot-logo-on:%d\n", uboot_logo_on);
+
+	dev_set_name(&pdev->dev, "rockchip-fb");
+#if defined(CONFIG_ION_ROCKCHIP)
+	rk_fb->ion_client = rockchip_ion_client_create("rk_fb");
+	if (IS_ERR(rk_fb->ion_client)) {
+		dev_err(&pdev->dev, "failed to create ion client for rk fb");
+		return PTR_ERR(rk_fb->ion_client);
+	} else {
+		dev_info(&pdev->dev, "rk fb ion client create success!\n");
+	}
+#endif
+
+	node = of_parse_phandle(np, "memory-region", 0);
+	if (node) {
+		struct resource r;
+
+		ret = of_address_to_resource(node, 0, &r);
+		if (ret)
+			return ret;
+
+		if (uboot_logo_on) {
+			uboot_logo_base = r.start;
+			uboot_logo_size = resource_size(&r);
+
+			if (uboot_logo_size > SZ_16M)
+				uboot_logo_offset = SZ_16M;
+			else
+				uboot_logo_offset = 0;
+		}
+		pr_info("logo: base=0x%llx, size=0x%llx, offset=0x%llx\n",
+			uboot_logo_base, uboot_logo_size, uboot_logo_offset);
+	}
+
+	fb_pdev = pdev;
+	dev_info(&pdev->dev, "rockchip framebuffer driver probe\n");
+	return 0;
+}
+
+static int rk_fb_remove(struct platform_device *pdev)
+{
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static void rk_fb_shutdown(struct platform_device *pdev)
+{
+	struct rk_fb *rk_fb = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < rk_fb->num_lcdc; i++) {
+		if (!rk_fb->lcdc_dev_drv[i])
+			continue;
+		sw_sync_timeline_inc(rk_fb->lcdc_dev_drv[i]->timeline, 1);
+	}
+}
+
+static const struct of_device_id rkfb_dt_ids[] = {
+	{.compatible = "rockchip,rk-fb",},
+	{}
+};
+
+static struct platform_driver rk_fb_driver = {
+	.probe = rk_fb_probe,
+	.remove = rk_fb_remove,
+	.driver = {
+		   .name = "rk-fb",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rkfb_dt_ids),
+		   },
+	.shutdown = rk_fb_shutdown,
+};
+
+static int __init rk_fb_init(void)
+{
+	return platform_driver_register(&rk_fb_driver);
+}
+
+static void __exit rk_fb_exit(void)
+{
+	platform_driver_unregister(&rk_fb_driver);
+}
+
+fs_initcall(rk_fb_init);
+module_exit(rk_fb_exit);
diff -Nupr a/drivers/video/rockchip/rkfb_sysfs.c b/drivers/video/rockchip/rkfb_sysfs.c
--- a/drivers/video/rockchip/rkfb_sysfs.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/rkfb_sysfs.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1352 @@
+/*
+ * linux/drivers/video/rockchip/rkfb-sysfs.c
+ *
+ * Copyright (C) 2012 Rockchip Corporation
+ * Author: yxj<yxj@rock-chips.com>
+ *
+ * Some code and ideas taken from
+ *drivers/video/omap2/omapfb/omapfb-sys.c
+ *driver by Tomi Valkeinen.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/fb.h>
+#include <linux/namei.h>
+#include <linux/sysfs.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <asm/div64.h>
+#include <linux/rk_screen.h>
+#include <linux/rk_fb.h>
+#if defined(CONFIG_ION_ROCKCHIP)
+#include <linux/rockchip_ion.h>
+#endif
+#include "bmp_helper.h"
+#include <linux/delay.h>
+struct rkfb_sys_trace {
+	int num_frames;
+	int count_frame;
+	int mask_win;
+	int mask_area;
+	bool is_bmp;
+	bool is_append;
+};
+#define DUMP_BUF_PATH		"/data/dmp_buf"
+
+static char *get_format_str(enum data_format format)
+{
+	switch (format) {
+	case ARGB888:
+		return "ARGB888";
+	case RGB888:
+		return "RGB888";
+	case RGB565:
+		return "RGB565";
+	case YUV420:
+	case YUV420_NV21:
+		return "YUV420";
+	case YUV422:
+		return "YUV422";
+	case YUV444:
+		return "YUV444";
+	case YUV420_A:
+		return "YUV420_A";
+	case YUV422_A:
+		return "YUV422_A";
+	case YUV444_A:
+		return "YUV444_A";
+	case XRGB888:
+		return "XRGB888";
+	case XBGR888:
+		return "XBGR888";
+	case ABGR888:
+		return "ABGR888";
+	case FBDC_RGB_565:
+		return "FBDC_RGB_565";
+	case FBDC_ARGB_888:
+		return "FBDC_ARGB_888";
+	case FBDC_RGBX_888:
+		return "FBDC_RGBX_888";
+	default:
+		return "invalid";
+	}
+}
+
+static ssize_t show_screen_info(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	int fps = 0;
+	u32 x = screen->mode.left_margin + screen->mode.right_margin +
+		screen->mode.xres + screen->mode.hsync_len;
+	u32 y = screen->mode.upper_margin + screen->mode.lower_margin +
+		screen->mode.yres + screen->mode.vsync_len;
+	u64 ft = (u64)x * y * (dev_drv->pixclock);
+
+	if (ft > 0)
+		fps = div64_u64(1000000000000llu, ft);
+	return snprintf(buf, PAGE_SIZE,
+			"xres:%d\nyres:%d\nfps:%d\ntype:%d\ninterlace:%d\n",
+			screen->mode.xres, screen->mode.yres,
+			fps, screen->type, screen->mode.vmode);
+}
+
+static ssize_t set_screen_info(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int xmirror = 0, ymirror = 0, ret = 0, rotate = 0;
+
+	ret = kstrtoint(buf, 0, &rotate);
+	if (ret)
+		return ret;
+	xmirror = !!(rotate & X_MIRROR);
+	ymirror = !!(rotate & Y_MIRROR);
+	dev_drv->cur_screen->x_mirror = xmirror;
+	dev_drv->cur_screen->y_mirror = ymirror;
+	dev_drv->rotate_mode = rotate;
+	mutex_lock(&dev_drv->output_lock);
+	mutex_lock(&dev_drv->win_config);
+	if (dev_drv->ops->extern_func)
+		dev_drv->ops->extern_func(dev_drv, SET_DSP_MIRROR);
+	mutex_unlock(&dev_drv->win_config);
+	mutex_unlock(&dev_drv->output_lock);
+
+	return count;
+}
+
+static ssize_t show_disp_info(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
+
+	if (dev_drv->ops->get_disp_info)
+		return dev_drv->ops->get_disp_info(dev_drv, buf, win_id);
+
+	return 0;
+}
+
+static void fill_buffer(void *handle, void *vaddr, int size)
+{
+	struct file *filp = handle;
+
+	if (filp)
+		vfs_write(filp, vaddr, size, &filp->f_pos);
+}
+
+static void read_buffer(void *handle, void *vaddr, int size, loff_t pos)
+{
+	struct file *filp = handle;
+
+	if (filp)
+		vfs_read(filp, vaddr, size, &pos);
+}
+
+static int dump_win(struct ion_client *ion_client,
+		    struct ion_handle *ion_handle, phys_addr_t phys_addr,
+		    int width, int height, u8 data_format, uint32_t frameid,
+		    int win_id, int area_id, bool is_bmp, bool is_append)
+{
+	void __iomem *vaddr = NULL;
+	struct file *filp;
+	mm_segment_t old_fs;
+	char name[100];
+	int flags;
+	int bits;
+
+	switch (data_format) {
+	case XRGB888:
+	case XBGR888:
+	case ARGB888:
+	case ABGR888:
+	case FBDC_RGBX_888:
+		bits = 32;
+		break;
+	case YUV444_A:
+	case YUV444:
+	case RGB888:
+	case FBDC_ARGB_888:
+		bits = 24;
+		break;
+	case RGB565:
+	case FBDC_RGB_565:
+	case YUV422:
+	case YUV422_A:
+		bits = 16;
+		break;
+	case YUV420_A:
+	case YUV420:
+	case YUV420_NV21:
+		bits = 12;
+		break;
+	default:
+		return 0;
+	}
+
+	if (ion_handle) {
+		vaddr = ion_map_kernel(ion_client, ion_handle);
+	} else if (phys_addr) {
+		unsigned long start;
+		unsigned int nr_pages;
+		struct page **pages;
+		int i = 0;
+
+		start = phys_addr;
+		nr_pages = roundup(width * height * (bits >> 3), PAGE_SIZE);
+		nr_pages /= PAGE_SIZE;
+		pages = kzalloc(sizeof(struct page) * nr_pages, GFP_KERNEL);
+		if (!pages)
+			return -ENOMEM;
+		while (i < nr_pages) {
+			pages[i] = phys_to_page(start);
+			start += PAGE_SIZE;
+			i++;
+		}
+		vaddr = vmap(pages, nr_pages, VM_MAP,
+			     pgprot_writecombine(PAGE_KERNEL));
+		if (!vaddr) {
+			pr_err("failed to vmap phy addr %lx\n",
+			       start);
+			return -1;
+		}
+	} else {
+		return 0;
+	}
+
+	flags = O_RDWR | O_CREAT | O_NONBLOCK;
+	if (is_append) {
+		snprintf(name, 100, "%s/append_win%d_%d_%dx%d_%s.%s",
+			 DUMP_BUF_PATH, win_id, area_id, width, height,
+			 get_format_str(data_format), is_bmp ? "bmp" : "bin");
+		flags |= O_APPEND;
+	} else {
+		snprintf(name, 100, "%s/frame%d_win%d_%d_%dx%d_%s.%s",
+			 DUMP_BUF_PATH, frameid, win_id, area_id, width, height,
+			 get_format_str(data_format), is_bmp ? "bmp" : "bin");
+	}
+
+	pr_info("dump win == > %s\n", name);
+	filp = filp_open(name, flags, 0x600);
+	if (!filp)
+		pr_err("fail to create %s\n", name);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	if (is_bmp)
+		bmpencoder(vaddr, width, height,
+			   data_format, filp, fill_buffer);
+	else
+		fill_buffer(filp, vaddr, width * height * bits >> 3);
+
+	set_fs(old_fs);
+
+	if (ion_handle)
+		ion_unmap_kernel(ion_client, ion_handle);
+	else if (vaddr)
+		vunmap(vaddr);
+
+	filp_close(filp, NULL);
+
+	return 0;
+}
+
+static ssize_t show_dump_buffer(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t size;
+
+	size = snprintf(buf, PAGE_SIZE,
+			"bmp       -- dump buffer to bmp image\n"
+			"             can't support dump to single file\n"
+			"bin       -- dump buffer to bin image\n"
+			"multi     -- each dump will create new file\n"
+			"             only works on trace context\n"
+			"win=num   -- mask win to dump, default mask all\n"
+			"             win=1, will dump win1 buffer\n"
+			"             win=23, will dump win2 area3 buffer\n"
+			"trace=num -- trace num frames buffer dump\n"
+			"             this option will block buffer switch\n"
+			"             so recommend use with bin and win=xx\n"
+			"\nExample:\n"
+			"echo bmp > dump_buf; -- dump current buf to bmp file\n"
+			"echo bin > dump_buf; -- dump current buf to bin file\n"
+			"echo trace=50:win=1:win=23 > dump_buf\n"
+			"         -- dump 50 frames, dump win1 and win2 area3\n"
+			"         -- dump all buffer to single file\n"
+			"You can found dump files at %s\n"
+			, DUMP_BUF_PATH);
+
+	return size;
+}
+
+void trace_buffer_dump(struct device *dev, struct rk_lcdc_driver *dev_drv)
+{
+	struct rk_fb *rk_fb = dev_get_drvdata(dev);
+	struct rk_fb_reg_data *front_regs;
+	struct rk_fb_reg_win_data *win_data;
+	struct rk_fb_reg_area_data *area_data;
+	struct rkfb_sys_trace *trace = dev_drv->trace_buf;
+	int i, j;
+
+	if (!trace)
+		return;
+	if (trace->num_frames <= trace->count_frame)
+		return;
+
+	if (!dev_drv->front_regs)
+		return;
+	front_regs = dev_drv->front_regs;
+
+	for (i = 0; i < front_regs->win_num; i++) {
+		if (trace->mask_win && !(trace->mask_win & (1 << i)))
+			continue;
+		for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+			win_data = &front_regs->reg_win_data[i];
+			area_data = &win_data->reg_area_data[j];
+			if (trace->mask_area && !(trace->mask_area & (1 << j)))
+				continue;
+
+			dump_win(rk_fb->ion_client, area_data->ion_handle,
+				 area_data->smem_start,
+				 area_data->xvir, area_data->yvir,
+				 area_data->data_format, trace->count_frame,
+				 i, j, trace->is_bmp, trace->is_append);
+		}
+	}
+	trace->count_frame++;
+}
+
+static ssize_t set_dump_buffer(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_fb *rk_fb = dev_get_drvdata(fbi->device);
+	struct rk_fb_reg_data *front_regs;
+	struct rk_fb_reg_win_data *win_data;
+	struct rk_fb_reg_area_data *area_data;
+	struct rkfb_sys_trace *trace;
+	struct dentry *dentry;
+	struct path path;
+	int err = 0;
+	int num_frames = 0;
+	int mask_win = 0;
+	int mask_area = 0;
+	bool is_bmp = false;
+	bool is_append = true;
+	char *p;
+	int i, j;
+
+	if (!rk_fb->ion_client)
+		return 0;
+
+	if (!dev_drv->trace_buf) {
+		dev_drv->trace_buf = devm_kmalloc(dev_drv->dev,
+						  sizeof(struct rkfb_sys_trace),
+						  GFP_KERNEL);
+		if (!dev_drv->trace_buf)
+			return -ENOMEM;
+	}
+	trace = dev_drv->trace_buf;
+	/*
+	 * Stop buffer trace.
+	 */
+	trace->num_frames = 0;
+
+	while ((p = strsep((char **)&buf, ":")) != NULL) {
+		if (!*p)
+			continue;
+		if (!strncmp(p, "trace=", 6)) {
+			if (kstrtoint(p + 6, 0, &num_frames))
+				dev_err(dev, "can't found trace frames\n");
+			continue;
+		}
+		if (!strncmp(p, "win=", 4)) {
+			int win;
+
+			if (kstrtoint(p + 4, 0, &win))
+				dev_err(dev, "can't found trace frames\n");
+			if (win < 10) {
+			       mask_win |= 1 << win;
+			} else {
+				mask_win |= 1 << (win / 10);
+				mask_area |= 1 << (win % 10);
+			}
+
+			continue;
+		}
+		if (!strncmp(p, "bmp", 3)) {
+			is_bmp = true;
+			is_append = false;
+			continue;
+		}
+		if (!strncmp(p, "bin", 3)) {
+			is_bmp = false;
+			continue;
+		}
+		if (!strncmp(p, "multi", 5)) {
+			is_append = false;
+			continue;
+		}
+
+		dev_err(dev, "unknown option %s\n", p);
+	}
+
+	dentry = kern_path_create(AT_FDCWD, DUMP_BUF_PATH, &path,
+				  LOOKUP_DIRECTORY);
+	if (!IS_ERR(dentry)) {
+		err = vfs_mkdir(path.dentry->d_inode, dentry, 700);
+		if (err)
+			dev_err(dev, "can't create %s err%d\n",
+				DUMP_BUF_PATH, err);
+		done_path_create(&path, dentry);
+	} else if (PTR_ERR(dentry) != -EEXIST) {
+		dev_err(dev, "can't create PATH %s err%d\n",
+				DUMP_BUF_PATH, err);
+		return PTR_ERR(dentry);
+	}
+
+	mutex_lock(&dev_drv->front_lock);
+	if (!num_frames) {
+		if (!dev_drv->front_regs) {
+			u16 xact, yact;
+			int data_format;
+			u32 dsp_addr;
+			int ymirror;
+
+			if (dev_drv->ops->get_dspbuf_info)
+				dev_drv->ops->get_dspbuf_info(dev_drv, &xact,
+						&yact, &data_format, &dsp_addr,
+						&ymirror);
+
+			dump_win(NULL, NULL, dsp_addr, xact, yact, data_format,
+				 0, 0, 0, is_bmp, false);
+			goto out;
+		}
+		front_regs = kmalloc(sizeof(*front_regs), GFP_KERNEL);
+		if (!front_regs) {
+			mutex_unlock(&dev_drv->front_lock);
+			return -ENOMEM;
+		}
+		memcpy(front_regs, dev_drv->front_regs, sizeof(*front_regs));
+
+		for (i = 0; i < front_regs->win_num; i++) {
+			if (mask_win && !(mask_win & (1 << i)))
+				continue;
+			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+				if (mask_area && !(mask_area & (1 << j)))
+					continue;
+				win_data = &front_regs->reg_win_data[i];
+				area_data = &win_data->reg_area_data[j];
+				if (area_data->ion_handle)
+					ion_handle_get(area_data->ion_handle);
+			}
+		}
+
+		for (i = 0; i < front_regs->win_num; i++) {
+			if (mask_win && !(mask_win & (1 << i)))
+				continue;
+			for (j = 0; j < RK_WIN_MAX_AREA; j++) {
+				if (mask_area && !(mask_area & (1 << j)))
+					continue;
+
+				win_data = &front_regs->reg_win_data[i];
+				area_data = &win_data->reg_area_data[j];
+
+				dump_win(rk_fb->ion_client,
+					 area_data->ion_handle,
+					 area_data->smem_start,
+					 area_data->xvir, area_data->yvir,
+					 area_data->data_format,
+					 0, i, j, is_bmp, false);
+				if (area_data->ion_handle)
+					ion_handle_put(area_data->ion_handle);
+			}
+		}
+
+		kfree(front_regs);
+	} else {
+		trace->num_frames = num_frames;
+		trace->count_frame = 0;
+		trace->is_bmp = is_bmp;
+		trace->is_append = is_append;
+		trace->mask_win = mask_win;
+		trace->mask_area = mask_area;
+	}
+out:
+	mutex_unlock(&dev_drv->front_lock);
+	return count;
+}
+
+static ssize_t show_dsp_buffer(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	ssize_t size;
+
+	size = snprintf(buf, PAGE_SIZE,
+			"you can display a picture store in "
+			"/data/fb0.bin use the following cmd:\n"
+			"echo n xsize ysize format > dsp_buf\n"
+			"n: picture number"
+			"xsize: picture horizontal size\n"
+			"ysize: picture vertical size\n"
+			"format:\n"
+			"    RGBA=1,RGBX=2,RGB=3,YUV420SP=17");
+
+	return size;
+}
+extern int __close_fd(struct files_struct *files, unsigned fd);
+
+static ssize_t set_dsp_buffer(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_fb *rk_fb = dev_get_drvdata(fbi->device);
+	struct file *filp;
+	mm_segment_t old_fs;
+	int width, height, frame_num;
+	int i, j, flags, fd;
+	const char *start = buf;
+	struct ion_handle *handle = NULL;
+	char __iomem *screen_base;
+	struct rk_fb_win_cfg_data *win_config = NULL;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	int space_max = 10;
+	int format;
+	size_t mem_size = 0;
+	char *name = "/data/fb0.bin";
+	struct sync_fence *acq_fence;
+	struct files_struct *files = current->files;
+
+	frame_num = simple_strtoul(start, NULL, 10);
+	do {
+		start++;
+		space_max--;
+	} while ((*start != ' ') && space_max);
+	start++;
+	width = simple_strtoul(start, NULL, 10);
+	do {
+		start++;
+		space_max--;
+	} while ((*start != ' ') && space_max);
+	start++;
+	height = simple_strtoul(start, NULL, 10);
+
+	do {
+		start++;
+		space_max--;
+	} while ((*start != ' ') && space_max);
+	start++;
+	format = simple_strtoul(start, NULL, 10);
+
+	pr_info("frame_num=%d,w=%d,h=%d,file=%s,format=%d\n",
+		frame_num, width, height, name, format);
+	flags = O_RDWR | O_CREAT | O_NONBLOCK;
+	filp = filp_open(name, flags, 0x600);
+	if (!filp)
+		pr_err("fail to create %s\n", name);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	mem_size = width * height * 4 * frame_num;
+	if (dev_drv->iommu_enabled)
+		handle = ion_alloc(rk_fb->ion_client, mem_size, 0,
+				   ION_HEAP_SYSTEM_MASK, 0);
+	else
+		handle = ion_alloc(rk_fb->ion_client, mem_size, 0,
+				   ION_HEAP_TYPE_DMA_MASK, 0);
+	if (IS_ERR(handle)) {
+		pr_err("failed to ion_alloc:%ld\n", PTR_ERR(handle));
+		return -ENOMEM;
+	}
+	fd = ion_share_dma_buf_fd(rk_fb->ion_client, handle);
+	if (fd < 0) {
+		pr_err("ion_share_dma_buf_fd failed, fd=%d\n", fd);
+		return fd;
+	}
+	screen_base = ion_map_kernel(rk_fb->ion_client, handle);
+	read_buffer(filp, screen_base, mem_size, 0);
+	win_config =
+		kzalloc(sizeof(*win_config), GFP_KERNEL);
+	if (!win_config)
+		return -ENOMEM;
+
+	memset(win_config, 0, sizeof(struct rk_fb_win_cfg_data));
+	win_config->wait_fs = 0;
+	win_config->win_par[0].win_id = 0;
+	win_config->win_par[0].z_order = 0;
+	win_config->win_par[0].area_par[0].data_format = format;
+	win_config->win_par[0].area_par[0].ion_fd = fd;
+	win_config->win_par[0].area_par[0].x_offset = 0;
+	win_config->win_par[0].area_par[0].y_offset = 0;
+	win_config->win_par[0].area_par[0].xpos = 0;
+	win_config->win_par[0].area_par[0].ypos = 0;
+	win_config->win_par[0].area_par[0].xsize = screen->mode.xres;
+	win_config->win_par[0].area_par[0].ysize = screen->mode.yres;
+	win_config->win_par[0].area_par[0].xact = width;
+	win_config->win_par[0].area_par[0].yact = height;
+	win_config->win_par[0].area_par[0].xvir = width;
+	win_config->win_par[0].area_par[0].yvir = height;
+
+	for (i = 0; i < frame_num; i++) {
+		win_config->win_par[0].area_par[0].y_offset = height * i;
+		fbi->fbops->fb_ioctl(fbi, RK_FBIOSET_CONFIG_DONE,
+				     (unsigned long)(win_config));
+		for (j = 0; j < RK_MAX_BUF_NUM; j++) {
+			if (win_config->rel_fence_fd[j] > 0) {
+				acq_fence =
+				sync_fence_fdget(win_config->rel_fence_fd[j]);
+				sync_fence_put(acq_fence);
+			}
+		}
+
+		if (win_config->ret_fence_fd > 0) {
+			acq_fence =
+			sync_fence_fdget(win_config->ret_fence_fd);
+			sync_fence_put(acq_fence);
+		}
+	}
+
+	ion_unmap_kernel(rk_fb->ion_client, handle);
+	ion_free(rk_fb->ion_client, handle);
+	__close_fd(files, fd);
+
+	set_fs(old_fs);
+	filp_close(filp, NULL);
+	kfree(win_config);
+	return count;
+}
+
+static ssize_t show_phys(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "0x%lx-----0x%x\n",
+			fbi->fix.smem_start, fbi->fix.smem_len);
+}
+
+static ssize_t show_virt(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "0x%p-----0x%x\n",
+			fbi->screen_base, fbi->fix.smem_len);
+}
+
+static ssize_t show_fb_state(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
+	int state = dev_drv->ops->get_win_state(dev_drv, win_id, 0);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", state ? "enabled" : "disabled");
+}
+
+static ssize_t show_dual_mode(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb *rk_fb = dev_get_drvdata(fbi->device);
+	int mode = rk_fb->disp_mode;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", mode);
+}
+
+static ssize_t set_fb_state(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
+	int state;
+	int ret;
+
+	ret = kstrtoint(buf, 0, &state);
+	if (ret)
+		return ret;
+	dev_drv->ops->open(dev_drv, win_id, state);
+	if (state) {
+		dev_drv->ops->set_par(dev_drv, win_id);
+		dev_drv->ops->pan_display(dev_drv, win_id);
+		dev_drv->ops->cfg_done(dev_drv);
+	}
+	return count;
+}
+
+static ssize_t show_overlay(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int ovl = 0;
+
+	if (dev_drv->ops->ovl_mgr)
+		ovl = dev_drv->ops->ovl_mgr(dev_drv, 0, 0);
+
+	if (ovl < 0)
+		return ovl;
+
+	return snprintf(buf, PAGE_SIZE, "%s\n",
+			ovl ? "win0 on the top of win1" :
+			"win1 on the top of win0");
+}
+
+static ssize_t set_overlay(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	u32 ovl;
+	int ret;
+
+	ret = kstrtou32(buf, 0, &ovl);
+	if (ret)
+		return ret;
+	if (dev_drv->ops->ovl_mgr)
+		ret = dev_drv->ops->ovl_mgr(dev_drv, ovl, 1);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t show_fps(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int fps = 0;
+
+	if (dev_drv->ops->fps_mgr)
+		fps = dev_drv->ops->fps_mgr(dev_drv, 0, 0);
+	if (fps < 0)
+		return fps;
+
+	return snprintf(buf, PAGE_SIZE, "fps:%d\n", fps);
+}
+
+static ssize_t set_fps(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	struct rk_screen *screen = dev_drv->cur_screen;
+	u32 fps, origin_fps;
+	int ret;
+
+	ret = kstrtou32(buf, 0, &fps);
+	if (ret)
+		return ret;
+
+	origin_fps = rk_fb_calc_fps(screen, dev_drv->pixclock);
+
+	/*
+	 * use too low or too high fps would make screen abnormal,
+	 * and maybe can't recovery, so limit the fps.
+	 */
+	if (fps <= 40 || fps > origin_fps)
+		fps = origin_fps;
+
+	if (dev_drv->ops->fps_mgr)
+		ret = dev_drv->ops->fps_mgr(dev_drv, fps, 1);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t show_fb_win_map(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int ret;
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	ret =
+	    snprintf(buf, PAGE_SIZE, "fb0:win%d\nfb1:win%d\nfb2:win%d\n",
+		     dev_drv->fb0_win_id, dev_drv->fb1_win_id,
+		     dev_drv->fb2_win_id);
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return ret;
+}
+
+static ssize_t set_fb_win_map(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	u32 order;
+	int ret;
+
+	ret = kstrtou32(buf, 0, &order);
+	if ((order != FB0_WIN2_FB1_WIN1_FB2_WIN0) &&
+	    (order != FB0_WIN1_FB1_WIN2_FB2_WIN0) &&
+	    (order != FB0_WIN2_FB1_WIN0_FB2_WIN1) &&
+	    (order != FB0_WIN0_FB1_WIN2_FB2_WIN1) &&
+	    (order != FB0_WIN0_FB1_WIN1_FB2_WIN2) &&
+	    (order != FB0_WIN1_FB1_WIN0_FB2_WIN2)) {
+		dev_info(dev, "un supported map\n"
+		       "you can use the following order:\n" "201:\n"
+		       "fb0-win1\n" "fb1-win0\n" "fb2-win2\n" "210:\n"
+		       "fb0-win0\n" "fb1-win1\n" "fb2-win2\n" "120:\n"
+		       "fb0-win0\n" "fb1-win2\n" "fb2-win1\n" "102:\n"
+		       "fb0-win2\n" "fb1-win0\n" "fb2-win1\n" "021:\n"
+		       "fb0-win1\n" "fb1-win2\n" "fb2-win0\n" "012:\n"
+		       "fb0-win2\n" "fb1-win1\n" "fb2-win0\n");
+		return count;
+	} else {
+		if (dev_drv->ops->fb_win_remap)
+			dev_drv->ops->fb_win_remap(dev_drv, order);
+	}
+
+	return count;
+}
+
+static ssize_t show_hwc_lut(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t set_hwc_lut(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int *hwc_lut = NULL;
+	const char *start = buf;
+	int i = 256, temp;
+	int space_max;
+
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	hwc_lut = kzalloc(256 * 4, GFP_KERNEL);
+	if (!hwc_lut)
+		return -ENOMEM;
+	/*printk("count:%d\n>>%s\n\n",count,start);*/
+	for (i = 0; i < 256; i++) {
+		space_max = 15;	/*max space number 15*/
+		temp = simple_strtoul(start, NULL, 16);
+		hwc_lut[i] = temp;
+		do {
+			start++;
+			space_max--;
+		} while ((*start != ' ') && space_max);
+
+		if (!space_max)
+			break;
+		else
+			start++;
+	}
+	if (dev_drv->ops->set_hwc_lut)
+		dev_drv->ops->set_hwc_lut(dev_drv, hwc_lut, 1);
+	kfree(hwc_lut);
+
+	return count;
+}
+
+static ssize_t show_cabc_lut(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t set_cabc_lut(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	int *cabc_lut = NULL;
+	const char *start = buf;
+	int i = 256, temp;
+	int space_max = 10;
+
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	cabc_lut = kzalloc(256 * 4, GFP_KERNEL);
+	if (!cabc_lut)
+		return -ENOMEM;
+	for (i = 0; i < 256; i++) {
+		temp = i;
+		/*init by default value*/
+		cabc_lut[i] = temp + (temp << 8) + (temp << 16);
+	}
+	for (i = 0; i < 256; i++) {
+		space_max = 10;	/*max space number 10*/
+		temp = simple_strtoul(start, NULL, 10);
+		cabc_lut[i] = temp;
+		do {
+			start++;
+			space_max--;
+		} while ((*start != ' ') && space_max);
+
+		if (!space_max)
+			break;
+		else
+			start++;
+	}
+	if (dev_drv->ops->set_cabc_lut)
+		dev_drv->ops->set_cabc_lut(dev_drv, cabc_lut);
+
+	kfree(cabc_lut);
+	return count;
+}
+
+static ssize_t show_dsp_lut(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t set_dsp_lut(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int *dsp_lut = NULL;
+	const char *start = buf;
+	int i = 256, temp;
+	int space_max = 10;
+
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	dsp_lut = kzalloc(256 * 4, GFP_KERNEL);
+	if (!dsp_lut)
+		return -ENOMEM;
+	for (i = 0; i < 256; i++) {
+		temp = i;
+		/*init by default value*/
+		dsp_lut[i] = temp + (temp << 8) + (temp << 16);
+	}
+	/*printk("count:%d\n>>%s\n\n",count,start);*/
+	for (i = 0; i < 256; i++) {
+		space_max = 10;	/*max space number 10*/
+		temp = simple_strtoul(start, NULL, 10);
+		dsp_lut[i] = temp;
+		do {
+			start++;
+			space_max--;
+		} while ((*start != ' ') && space_max);
+
+		if (!space_max)
+			break;
+		else
+			start++;
+	}
+	if (dev_drv->ops->set_dsp_lut)
+		dev_drv->ops->set_dsp_lut(dev_drv, dsp_lut);
+
+	kfree(dsp_lut);
+	return count;
+}
+
+static ssize_t show_dsp_cabc(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	return snprintf(buf, PAGE_SIZE, "cabc mode=%d\n",
+		dev_drv->cabc_mode);
+	return 0;
+}
+
+static ssize_t set_dsp_cabc(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int space_max, ret = 0;
+	int mode = 0, calc = 0, up = 0, down = 0, global = 0;
+	const char *start = buf;
+
+	space_max = 10;	/*max space number 10*/
+	mode = simple_strtoul(start, NULL, 10);
+	do {
+		start++;
+		space_max--;
+	} while ((*start != ' ') && space_max);
+	start++;
+	calc = simple_strtoul(start, NULL, 10);
+
+	do {
+		start++;
+		space_max--;
+	} while ((*start != ' ') && space_max);
+	start++;
+	up  = simple_strtoul(start, NULL, 10);
+
+	do {
+		start++;
+		space_max--;
+	} while ((*start != ' ') && space_max);
+	start++;
+	down = simple_strtoul(start, NULL, 10);
+
+	do {
+		start++;
+		space_max--;
+	} while ((*start != ' ') && space_max);
+	start++;
+	global = simple_strtoul(start, NULL, 10);
+
+	if (dev_drv->ops->set_dsp_cabc)
+		ret = dev_drv->ops->set_dsp_cabc(dev_drv, mode,
+						 calc, up, down, global);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t show_dsp_bcsh(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int brightness = 0, contrast = 0, sat_con = 0, sin_hue = 0, cos_hue = 0;
+
+	if (dev_drv->ops->get_dsp_bcsh_bcs) {
+		brightness = dev_drv->ops->get_dsp_bcsh_bcs(dev_drv,
+							    BRIGHTNESS);
+		contrast = dev_drv->ops->get_dsp_bcsh_bcs(dev_drv, CONTRAST);
+		sat_con = dev_drv->ops->get_dsp_bcsh_bcs(dev_drv, SAT_CON);
+	}
+	if (dev_drv->ops->get_dsp_bcsh_hue) {
+		sin_hue = dev_drv->ops->get_dsp_bcsh_hue(dev_drv, H_SIN);
+		cos_hue = dev_drv->ops->get_dsp_bcsh_hue(dev_drv, H_COS);
+	}
+	return snprintf(buf, PAGE_SIZE,
+			"brightness:%4d,contrast:%4d,sat_con:%4d,"
+			"sin_hue:%4d,cos_hue:%4d\n",
+			brightness, contrast, sat_con, sin_hue, cos_hue);
+}
+
+static ssize_t set_dsp_bcsh(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int brightness, contrast, sat_con, ret = 0, sin_hue, cos_hue;
+
+	if (!strncmp(buf, "open", 4)) {
+		if (dev_drv->ops->open_bcsh)
+			ret = dev_drv->ops->open_bcsh(dev_drv, 1);
+		else
+			ret = -1;
+	} else if (!strncmp(buf, "close", 5)) {
+		if (dev_drv->ops->open_bcsh)
+			ret = dev_drv->ops->open_bcsh(dev_drv, 0);
+		else
+			ret = -1;
+	} else if (!strncmp(buf, "brightness", 10)) {
+		sscanf(buf, "brightness %d", &brightness);
+		if (unlikely(brightness > 255)) {
+			dev_err(fbi->dev,
+				"brightness should be [0:255],now=%d\n\n",
+				brightness);
+			brightness = 255;
+		}
+		if (dev_drv->ops->set_dsp_bcsh_bcs)
+			ret = dev_drv->ops->set_dsp_bcsh_bcs(dev_drv,
+							     BRIGHTNESS,
+							     brightness);
+		else
+			ret = -1;
+	} else if (!strncmp(buf, "contrast", 8)) {
+		sscanf(buf, "contrast %d", &contrast);
+		if (unlikely(contrast > 510)) {
+			dev_err(fbi->dev,
+				"contrast should be [0:510],now=%d\n",
+				contrast);
+			contrast = 510;
+		}
+		if (dev_drv->ops->set_dsp_bcsh_bcs)
+			ret = dev_drv->ops->set_dsp_bcsh_bcs(dev_drv,
+							     CONTRAST,
+							     contrast);
+		else
+			ret = -1;
+	} else if (!strncmp(buf, "sat_con", 7)) {
+		sscanf(buf, "sat_con %d", &sat_con);
+		if (unlikely(sat_con > 1015)) {
+			dev_err(fbi->dev,
+				"sat_con should be [0:1015],now=%d\n",
+				sat_con);
+			sat_con = 1015;
+		}
+		if (dev_drv->ops->set_dsp_bcsh_bcs)
+			ret = dev_drv->ops->set_dsp_bcsh_bcs(dev_drv,
+							     SAT_CON,
+							     sat_con);
+		else
+			ret = -1;
+	} else if (!strncmp(buf, "hue", 3)) {
+		sscanf(buf, "hue %d %d", &sin_hue, &cos_hue);
+		if (unlikely(sin_hue > 511 || cos_hue > 511)) {
+			dev_err(fbi->dev, "sin_hue=%d,cos_hue=%d\n",
+				sin_hue, cos_hue);
+		}
+		if (dev_drv->ops->set_dsp_bcsh_hue)
+			ret = dev_drv->ops->set_dsp_bcsh_hue(dev_drv,
+							     sin_hue,
+							     cos_hue);
+		else
+			ret = -1;
+	} else {
+		dev_info(dev, "format error\n");
+	}
+
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t show_scale(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	return snprintf(buf, PAGE_SIZE,
+		"xscale=%d yscale=%d\nleft=%d top=%d right=%d bottom=%d\n",
+		(dev_drv->overscan.left + dev_drv->overscan.right) / 2,
+		(dev_drv->overscan.top + dev_drv->overscan.bottom) / 2,
+		dev_drv->overscan.left, dev_drv->overscan.top,
+		dev_drv->overscan.right, dev_drv->overscan.bottom);
+}
+
+static ssize_t set_scale(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	u32 left, top, right, bottom;
+
+	if (!strncmp(buf, "overscan", 8)) {
+		sscanf(buf,
+		       "overscan %d,%d,%d,%d", &left, &top, &right, &bottom);
+		if (left > 0 && left <= 100)
+			dev_drv->overscan.left = left;
+		if (top > 0 && top <= 100)
+			dev_drv->overscan.top = top;
+		if (right > 0 && right <= 100)
+			dev_drv->overscan.right = right;
+		if (bottom > 0 && bottom <= 100)
+			dev_drv->overscan.bottom = bottom;
+	} else if (!strncmp(buf, "left", 4)) {
+		sscanf(buf, "left=%d", &left);
+		if (left > 0 && left <= 100)
+			dev_drv->overscan.left = left;
+	} else if (!strncmp(buf, "top", 3)) {
+		sscanf(buf, "top=%d", &top);
+		if (top > 0 && top <= 100)
+			dev_drv->overscan.top = top;
+	} else if (!strncmp(buf, "right", 5)) {
+		sscanf(buf, "right=%d", &right);
+		if (right > 0 && right <= 100)
+			dev_drv->overscan.right = right;
+	} else if (!strncmp(buf, "bottom", 6)) {
+		sscanf(buf, "bottom=%d", &bottom);
+		if (bottom > 0 && bottom <= 100)
+			dev_drv->overscan.bottom = bottom;
+	} else if (!strncmp(buf, "xscale", 6)) {
+		sscanf(buf, "xscale=%d", &left);
+		if (left > 0 && left <= 100) {
+			dev_drv->overscan.left = left;
+			dev_drv->overscan.right = left;
+		}
+	} else if (!strncmp(buf, "yscale", 6)) {
+		sscanf(buf, "yscale=%d", &left);
+		if (left > 0 && left <= 100) {
+			dev_drv->overscan.top = left;
+			dev_drv->overscan.bottom = left;
+		}
+	} else {
+		sscanf(buf, "%d", &left);
+		if (left > 0 && left <= 100) {
+			dev_drv->overscan.left = left;
+			dev_drv->overscan.right = left;
+			dev_drv->overscan.top = left;
+			dev_drv->overscan.bottom = left;
+		}
+	}
+
+	if (dev_drv->ops->set_overscan)
+		dev_drv->ops->set_overscan(dev_drv, &dev_drv->overscan);
+
+	return count;
+}
+
+static ssize_t show_lcdc_id(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", dev_drv->id);
+}
+
+static ssize_t show_dsp_mode(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", dev_drv->dsp_mode);
+}
+
+static ssize_t show_hot_plug_state(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", dev_drv->hot_plug_state);
+}
+
+static ssize_t show_win_property(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	int win_id = 0;
+
+	win_id = dev_drv->ops->fb_get_win_id(dev_drv, fbi->fix.id);
+	return snprintf(buf, PAGE_SIZE,
+			"feature: %d, max_input_x: %d, max_input_y: %d\n",
+			dev_drv->win[win_id]->property.feature,
+			dev_drv->win[win_id]->property.max_input_x,
+			dev_drv->win[win_id]->property.max_input_y);
+}
+
+static ssize_t set_car_reverse(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_fb_par *fb_par = (struct rk_fb_par *)fbi->par;
+	struct rk_lcdc_driver *dev_drv = fb_par->lcdc_drv;
+	u32 status;
+	int ret;
+
+	ret = kstrtou32(buf, 0, &status);
+	if (ret)
+		return ret;
+	rk_fb_set_car_reverse_status(dev_drv, status);
+
+	return count;
+}
+
+static struct device_attribute rkfb_attrs[] = {
+	__ATTR(phys_addr, S_IRUGO, show_phys, NULL),
+	__ATTR(virt_addr, S_IRUGO, show_virt, NULL),
+	__ATTR(disp_info, S_IRUGO, show_disp_info, NULL),
+	__ATTR(dump_buf, S_IRUGO | S_IWUSR, show_dump_buffer, set_dump_buffer),
+	__ATTR(dsp_buf, S_IRUGO | S_IWUSR, show_dsp_buffer, set_dsp_buffer),
+	__ATTR(screen_info, S_IRUGO | S_IWUSR,
+	       show_screen_info, set_screen_info),
+	__ATTR(dual_mode, S_IRUGO, show_dual_mode, NULL),
+	__ATTR(enable, S_IRUGO | S_IWUSR, show_fb_state, set_fb_state),
+	__ATTR(overlay, S_IRUGO | S_IWUSR, show_overlay, set_overlay),
+	__ATTR(fps, S_IRUGO | S_IWUSR, show_fps, set_fps),
+	__ATTR(map, S_IRUGO | S_IWUSR, show_fb_win_map, set_fb_win_map),
+	__ATTR(dsp_lut, S_IRUGO | S_IWUSR, show_dsp_lut, set_dsp_lut),
+	__ATTR(cabc_lut, S_IRUGO | S_IWUSR, show_cabc_lut, set_cabc_lut),
+	__ATTR(hwc_lut, S_IRUGO | S_IWUSR, show_hwc_lut, set_hwc_lut),
+	__ATTR(cabc, S_IRUGO | S_IWUSR, show_dsp_cabc, set_dsp_cabc),
+	__ATTR(bcsh, S_IRUGO | S_IWUSR, show_dsp_bcsh, set_dsp_bcsh),
+	__ATTR(scale, S_IRUGO | S_IWUSR, show_scale, set_scale),
+	__ATTR(lcdcid, S_IRUGO, show_lcdc_id, NULL),
+	__ATTR(win_property, S_IRUGO, show_win_property, NULL),
+	__ATTR(car_reverse, S_IWUSR, NULL, set_car_reverse),
+	__ATTR(dsp_mode, S_IRUGO, show_dsp_mode, NULL),
+	__ATTR(hot_plug_state, S_IRUGO, show_hot_plug_state, NULL),
+};
+
+int rkfb_create_sysfs(struct fb_info *fbi)
+{
+	int r, t;
+
+	for (t = 0; t < ARRAY_SIZE(rkfb_attrs); t++) {
+		r = device_create_file(fbi->dev, &rkfb_attrs[t]);
+		if (r) {
+			dev_err(fbi->dev, "failed to create sysfs " "file\n");
+			return r;
+		}
+	}
+
+	return 0;
+}
+
+void rkfb_remove_sysfs(struct rk_fb *rk_fb)
+{
+	int i, t;
+
+	for (i = 0; i < rk_fb->num_fb; i++) {
+		for (t = 0; t < ARRAY_SIZE(rkfb_attrs); t++)
+			device_remove_file(rk_fb->fb[i]->dev, &rkfb_attrs[t]);
+	}
+}
diff -Nupr a/drivers/video/rockchip/screen/.gitignore b/drivers/video/rockchip/screen/.gitignore
--- a/drivers/video/rockchip/screen/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/screen/.gitignore	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,4 @@
+#
+# Generated files
+#
+*lcd.h
diff -Nupr a/drivers/video/rockchip/screen/Kconfig b/drivers/video/rockchip/screen/Kconfig
--- a/drivers/video/rockchip/screen/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/screen/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,14 @@
+# SPDX-License-Identifier: GPL-2.0
+choice
+	depends on FB_ROCKCHIP || DRM_ROCKCHIP
+	prompt  "LCD Panel Select"
+
+config LCD_GENERAL
+	bool "General lcd panel"
+	help 
+	  select if the panel do not need initialization
+config LCD_MIPI
+	bool "rk mipi dsi lcd"	
+endchoice
+
+
diff -Nupr a/drivers/video/rockchip/screen/lcd_general.c b/drivers/video/rockchip/screen/lcd_general.c
--- a/drivers/video/rockchip/screen/lcd_general.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/screen/lcd_general.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __LCD_NULL__
+#define __LCD_NULL__
+
+
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/screen/lcd_mipi.c b/drivers/video/rockchip/screen/lcd_mipi.c
--- a/drivers/video/rockchip/screen/lcd_mipi.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/screen/lcd_mipi.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,747 @@
+/*
+ * Copyright (C) 2014 ROCKCHIP, Inc.
+ * drivers/video/rockchip/screen/lcd_mipi.c
+ * author: libing@rock-chips.com
+ * create date: 2014-04-10
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef CONFIG_LCD_MIPI
+#include <common.h>
+#endif
+#ifdef CONFIG_LCD_MIPI
+#include "../transmitter/mipi_dsi.h"
+#include <linux/delay.h>
+#endif
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <malloc.h>
+#include <fdtdec.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/rkplat.h>
+#include <lcd.h>
+#include "../transmitter/mipi_dsi.h"
+#endif
+
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+#define	MIPI_SCREEN_DBG(x...)	/* printf(x) */
+#elif defined CONFIG_LCD_MIPI
+#define	MIPI_SCREEN_DBG(x...)	/* printk(KERN_ERR x) */
+#else
+#define	MIPI_SCREEN_DBG(x...)
+#endif
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+DECLARE_GLOBAL_DATA_PTR;
+#define	printk(x...)	/* printf(x) */
+#endif
+static struct mipi_screen *gmipi_screen;
+
+static inline void mipidelay(unsigned int msecs)
+{
+	usleep_range(msecs * 1000, msecs * 1000 + 200);
+}
+
+static void rk_mipi_screen_pwr_disable(struct mipi_screen *screen)
+{
+	if (screen->lcd_en_gpio != INVALID_GPIO) {
+		gpio_direction_output(screen->lcd_en_gpio, !screen->lcd_en_atv_val);
+		mipidelay(screen->lcd_en_delay);
+	} else{
+		MIPI_SCREEN_DBG("lcd_en_gpio is null");
+	}
+
+	if (screen->lcd_rst_gpio != INVALID_GPIO) {
+
+		gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
+		mipidelay(screen->lcd_rst_delay);
+	} else {
+		MIPI_SCREEN_DBG("lcd_rst_gpio is null");
+	}
+}
+
+static void rk_mipi_screen_pwr_enable(struct mipi_screen *screen)
+{
+	if (screen->lcd_en_gpio != INVALID_GPIO) {
+		gpio_direction_output(screen->lcd_en_gpio, !screen->lcd_en_atv_val);
+		mipidelay(screen->lcd_en_delay);
+		gpio_direction_output(screen->lcd_en_gpio, screen->lcd_en_atv_val);
+		mipidelay(screen->lcd_en_delay);
+	} else
+		MIPI_SCREEN_DBG("lcd_en_gpio is null\n");
+
+	if (screen->lcd_rst_gpio != INVALID_GPIO) {
+		gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
+		mipidelay(screen->lcd_rst_delay);
+		gpio_direction_output(screen->lcd_rst_gpio, screen->lcd_rst_atv_val);
+		mipidelay(screen->lcd_rst_delay);
+	} else
+		MIPI_SCREEN_DBG("lcd_rst_gpio is null\n");
+}
+
+static void rk_mipi_screen_cmd_init(struct mipi_screen *screen)
+{
+	u8 len, i;
+	u8 *cmds;
+	struct list_head *screen_pos;
+	struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+	cmds = calloc(1, 0x400);
+	if (!cmds) {
+		printf("request cmds fail!\n");
+		return;
+	}
+#endif
+
+#ifdef CONFIG_LCD_MIPI
+	cmds = kmalloc(0x400, GFP_KERNEL);
+	if (!cmds) {
+		printk("request cmds fail!\n");
+		return ;
+	}
+#endif
+	list_for_each(screen_pos, &screen->cmdlist_head) {
+		dcs_cmd = list_entry(screen_pos, struct mipi_dcs_cmd_ctr_list, list);
+		len = dcs_cmd->dcs_cmd.cmd_len + 1;
+		for (i = 1; i < len ; i++) {
+			cmds[i] = dcs_cmd->dcs_cmd.cmds[i-1];
+		}
+		MIPI_SCREEN_DBG("dcs_cmd.name:%s\n", dcs_cmd->dcs_cmd.name);
+		if (dcs_cmd->dcs_cmd.type == LPDT) {
+			cmds[0] = LPDT;
+			if (dcs_cmd->dcs_cmd.dsi_id == 0) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n", __LINE__);
+				dsi_send_packet(0, cmds, len);
+			} else if (dcs_cmd->dcs_cmd.dsi_id == 1) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n", __LINE__);
+				dsi_send_packet(1, cmds, len);
+			} else if (dcs_cmd->dcs_cmd.dsi_id == 2) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n", __LINE__);
+				dsi_send_packet(0, cmds, len);
+				dsi_send_packet(1, cmds, len);
+			} else {
+				MIPI_SCREEN_DBG("dsi is err.\n");
+			}
+			if (dcs_cmd->dcs_cmd.delay)
+				mipidelay(dcs_cmd->dcs_cmd.delay);
+		} else if (dcs_cmd->dcs_cmd.type == HSDT) {
+			cmds[0] = HSDT;
+			if (dcs_cmd->dcs_cmd.dsi_id == 0) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n", __LINE__);
+				dsi_send_packet(0, cmds, len);
+			} else if (dcs_cmd->dcs_cmd.dsi_id == 1) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n", __LINE__);
+				dsi_send_packet(1, cmds, len);
+			} else if (dcs_cmd->dcs_cmd.dsi_id == 2) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n", __LINE__);
+				dsi_send_packet(0, cmds, len);
+				dsi_send_packet(1, cmds, len);
+			} else {
+				MIPI_SCREEN_DBG("dsi is err.");
+			}
+			if (dcs_cmd->dcs_cmd.delay)
+				mipidelay(dcs_cmd->dcs_cmd.delay);
+		} else
+			MIPI_SCREEN_DBG("cmd type err.\n");
+	}
+
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+	free(cmds);
+#endif
+#ifdef CONFIG_LCD_MIPI
+	kfree(cmds);
+#endif
+}
+
+int rk_mipi_screen(void)
+{
+	u8 dcs[16] = {0}, rk_dsi_num;
+	rk_dsi_num = gmipi_screen->mipi_dsi_num;
+	if (gmipi_screen->screen_init == 0) {
+		rk_mipi_screen_pwr_enable(gmipi_screen);
+		dsi_enable_hs_clk(0, 1);
+		if (rk_dsi_num == 2) {
+			dsi_enable_hs_clk(1, 1);
+		}
+
+		dsi_enable_command_mode(0, 1);
+		if (rk_dsi_num == 2) {
+			dsi_enable_command_mode(1, 1);
+		}
+
+		dcs[0] = LPDT;
+		dcs[1] = DTYPE_DCS_SWRITE_0P;
+		dcs[2] = dcs_exit_sleep_mode;
+		dsi_send_packet(0, dcs, 3);
+		if (rk_dsi_num == 2)
+			dsi_send_packet(1, dcs, 3);
+
+		mipidelay(20);
+
+		dcs[0] = LPDT;
+		dcs[1] = DTYPE_DCS_SWRITE_0P;
+		dcs[2] = dcs_set_display_on;
+		dsi_send_packet(0, dcs, 3);
+		if (rk_dsi_num == 2)
+			dsi_send_packet(1, dcs, 3);
+
+		mipidelay(20);
+	} else {
+		rk_mipi_screen_pwr_enable(gmipi_screen);
+
+		dsi_enable_hs_clk(0, 1);
+		if (rk_dsi_num == 2) {
+			dsi_enable_hs_clk(1, 1);
+		}
+
+		dsi_enable_command_mode(0, 1);
+		if (rk_dsi_num == 2) {
+			dsi_enable_command_mode(1, 1);
+		}
+
+		rk_mipi_screen_cmd_init(gmipi_screen);
+	}
+
+	MIPI_SCREEN_DBG("++++++++++++++++%s:%d\n", __func__, __LINE__);
+	return 0;
+}
+
+int rk_mipi_screen_standby(u8 enable)
+{
+	u8 dcs[16] = {0}, rk_dsi_num;
+	rk_dsi_num = gmipi_screen->mipi_dsi_num;
+
+	if (dsi_is_active(0) != 1)
+		return -1;
+
+	if (rk_dsi_num == 2)
+		if ((dsi_is_active(0) != 1) || (dsi_is_active(1) != 1))
+			return -1;
+
+	if (enable) {
+		/* below is changeable */
+		dcs[0] = LPDT;
+		dcs[1] = DTYPE_DCS_SWRITE_0P;
+		dcs[2] = dcs_set_display_off;
+		dsi_send_packet(0, dcs, 3);
+		if (rk_dsi_num == 2)
+			dsi_send_packet(1, dcs, 3);
+
+		mipidelay(30);
+
+		dcs[0] = LPDT;
+		dcs[1] = DTYPE_DCS_SWRITE_0P;
+		dcs[2] = dcs_enter_sleep_mode;
+		dsi_send_packet(0, dcs, 3);
+		if (rk_dsi_num == 2)
+			dsi_send_packet(1, dcs, 3);
+
+		mipidelay(100);
+		rk_mipi_screen_pwr_disable(gmipi_screen);
+		MIPI_SCREEN_DBG("++++enable++++++++++++%s:%d\n", __func__, __LINE__);
+	} else {
+		rk_mipi_screen();
+	}
+	return 0;
+}
+#ifdef CONFIG_LCD_MIPI
+static int rk_mipi_screen_init_dt(struct device *dev,
+				  struct mipi_screen *screen)
+{
+	struct device_node *childnode, *grandchildnode, *root;
+	struct mipi_dcs_cmd_ctr_list *dcs_cmd;
+	struct list_head *pos;
+	struct property *prop;
+	enum of_gpio_flags flags;
+	u32 value, i, debug, gpio, ret, length;
+
+	memset(screen, 0, sizeof(*screen));
+
+	INIT_LIST_HEAD(&screen->cmdlist_head);
+
+	childnode = of_find_node_by_name(NULL, "mipi_dsi_init");
+	if (!childnode) {
+		MIPI_SCREEN_DBG("%s: Can not get child => mipi_init.\n", __func__);
+	} else {
+		ret = of_property_read_u32(childnode, "rockchip,screen_init", &value);
+		if (ret) {
+			MIPI_SCREEN_DBG("%s: Can not read property: screen_init.\n", __func__);
+		} else {
+			if ((value != 0) && (value != 1)) {
+				printk("err: rockchip,mipi_dsi_init not match.\n");
+				return -1;
+			} else
+				screen->screen_init = value ;
+
+			MIPI_SCREEN_DBG("%s: lcd->screen_init = %d.\n", __func__, screen->screen_init);
+		}
+
+		ret = of_property_read_u32(childnode, "rockchip,dsi_lane", &value);
+		if (ret) {
+			MIPI_SCREEN_DBG("%s: Can not read property: dsi_lane.\n", __func__);
+		} else {
+			screen->dsi_lane = value;
+			MIPI_SCREEN_DBG("%s: mipi_lcd->dsi_lane = %d.\n", __func__, screen->dsi_lane);
+		}
+
+		ret = of_property_read_u32(childnode, "rockchip,dsi_hs_clk", &value);
+		if (ret) {
+			MIPI_SCREEN_DBG("%s: Can not read property: dsi_hs_clk.\n", __func__);
+		} else {
+			if ((value <= 90) || (value >= 1500)) {
+				printk("err: rockchip,hs_tx_clk not match.");
+				return -1;
+			} else {
+				screen->hs_tx_clk = value*MHz;
+			}
+
+			MIPI_SCREEN_DBG("%s: lcd->screen->hs_tx_clk = %d.\n", __func__, screen->hs_tx_clk);
+		}
+
+		ret = of_property_read_u32(childnode, "rockchip,mipi_dsi_num", &value);
+		if (ret) {
+			MIPI_SCREEN_DBG("%s: Can not read property: mipi_dsi_num.\n", __func__);
+		} else {
+			if ((value != 1) && (value != 2)) {
+				printk("err: rockchip,mipi_dsi_num not match.\n");
+				return -1;
+			} else {
+				screen->mipi_dsi_num = value ;
+			}
+
+			MIPI_SCREEN_DBG("%s: lcd->screen.mipi_dsi_num = %d.\n", __func__, screen->mipi_dsi_num);
+		}
+	}
+
+	childnode = of_find_node_by_name(NULL, "mipi_power_ctr");
+	if (!childnode) {
+		screen->lcd_rst_gpio = INVALID_GPIO;
+		screen->lcd_en_gpio = INVALID_GPIO;
+		MIPI_SCREEN_DBG("%s: Can not get child => mipi_power_ctr.\n", __func__);
+	} else {
+		grandchildnode = of_find_node_by_name(childnode, "mipi_lcd_rst");
+		if (!grandchildnode) {
+			screen->lcd_rst_gpio = INVALID_GPIO;
+			MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_rst.\n", __func__);
+		} else {
+			ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
+			if (ret) {
+				MIPI_SCREEN_DBG("%s: Can not read property: delay.\n", __func__);
+			} else {
+				screen->lcd_rst_delay = value;
+				MIPI_SCREEN_DBG("%s: lcd->screen->lcd_rst_delay = %d.\n", __func__, screen->lcd_rst_delay);
+			}
+
+			gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
+			if (!gpio_is_valid(gpio)) {
+				MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
+			}
+
+			ret = gpio_request(gpio, "mipi_lcd_rst");
+			if (ret) {
+				screen->lcd_rst_gpio = INVALID_GPIO;
+				MIPI_SCREEN_DBG("request mipi_lcd_rst gpio fail:%d\n", gpio);
+				return -1;
+			}
+
+			screen->lcd_rst_gpio = gpio;
+			screen->lcd_rst_atv_val = (flags == GPIO_ACTIVE_HIGH) ? 1:0;
+
+			MIPI_SCREEN_DBG("lcd->lcd_rst_gpio=%d,dsi->lcd_rst_atv_val=%d\n", screen->lcd_rst_gpio, screen->lcd_rst_atv_val);
+		}
+
+		grandchildnode = of_find_node_by_name(childnode, "mipi_lcd_en");
+		if (!grandchildnode) {
+			screen->lcd_en_gpio = INVALID_GPIO;
+			MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en.\n", __func__);
+		} else {
+			ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
+			if (ret) {
+				MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en-delay.\n", __func__);
+			} else {
+				screen->lcd_en_delay = value;
+				MIPI_SCREEN_DBG("%s: lcd->screen.lcd_en_delay = %d.\n", __func__, screen->lcd_en_delay);
+			}
+
+			gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
+			if (!gpio_is_valid(gpio)) {
+				MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
+			}
+
+			ret = gpio_request(gpio, "mipi_lcd_en");
+			if (ret) {
+				screen->lcd_en_gpio = INVALID_GPIO;
+				MIPI_SCREEN_DBG("request mipi_lcd_en gpio fail:%d\n", gpio);
+				return -1;
+			}
+			screen->lcd_en_gpio = gpio;
+			screen->lcd_en_atv_val = (flags == GPIO_ACTIVE_HIGH) ? 1:0;
+			MIPI_SCREEN_DBG("dsi->lcd_en_gpio=%d, dsi->screen.lcd_en_atv_val=%d\n", screen->lcd_en_gpio, screen->lcd_en_atv_val);
+		}
+	}
+
+	root = of_find_node_by_name(NULL, "screen-on-cmds");
+	if (!root) {
+		MIPI_SCREEN_DBG("can't find screen-on-cmds node\n");
+	} else {
+		for_each_child_of_node(root, childnode) {
+			dcs_cmd = kmalloc(sizeof(struct mipi_dcs_cmd_ctr_list), GFP_KERNEL);
+			strcpy(dcs_cmd->dcs_cmd.name, childnode->name);
+
+			prop = of_find_property(childnode, "rockchip,cmd", &length);
+			if (!prop) {
+				MIPI_SCREEN_DBG("Can not read property: cmds\n");
+				return -EINVAL;
+			}
+
+			MIPI_SCREEN_DBG("\n childnode->name =%s:length=%d\n", childnode->name, (length / sizeof(u32)));
+
+			dcs_cmd->dcs_cmd.cmds =
+				devm_kzalloc(dev, length, GFP_KERNEL);
+			if (!dcs_cmd->dcs_cmd.cmds) {
+				pr_err("malloc cmds fail!\n");
+				return -ENOMEM;
+			}
+
+			ret = of_property_read_u32_array(childnode,
+							 "rockchip,cmd",
+							 dcs_cmd->dcs_cmd.cmds,
+							 length / sizeof(u32));
+			if (ret < 0) {
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmds\n", __func__, childnode->name);
+				kfree(dcs_cmd->dcs_cmd.cmds);
+				dcs_cmd->dcs_cmd.cmds = NULL;
+				return ret;
+			} else {
+				dcs_cmd->dcs_cmd.cmd_len =  length / sizeof(u32);
+			}
+			ret = of_property_read_u32(childnode, "rockchip,dsi_id", &value);
+			if (ret) {
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__, childnode->name);
+			} else {
+				if (screen->mipi_dsi_num == 1) {
+					if (value != 0) {
+						printk("err: rockchip,dsi_id not match.\n");
+					} else {
+						dcs_cmd->dcs_cmd.dsi_id = value;
+					}
+				} else {
+					if ((value < 0) || (value > 2))
+						printk("err: rockchip,dsi_id not match.\n");
+					else
+						dcs_cmd->dcs_cmd.dsi_id = value;
+				}
+			}
+
+			ret = of_property_read_u32(childnode, "rockchip,cmd_type", &value);
+			if (ret) {
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__, childnode->name);
+			} else {
+				if ((value != 0) && (value != 1)) {
+					printk("err: rockchip, cmd_type not match.\n");
+				} else {
+					dcs_cmd->dcs_cmd.type = value;
+				}
+			}
+
+			ret = of_property_read_u32(childnode, "rockchip,cmd_delay", &value);
+			if (ret)
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_delay\n", __func__, childnode->name);
+			else
+				dcs_cmd->dcs_cmd.delay = value;
+
+			list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
+		}
+	}
+	ret = of_property_read_u32(root, "rockchip,cmd_debug", &debug);
+	if (ret) {
+		MIPI_SCREEN_DBG("%s: Can not read property: rockchip,cmd_debug.\n", __func__);
+	} else {
+		if (debug) {
+			list_for_each(pos, &screen->cmdlist_head) {
+				dcs_cmd = list_entry(pos, struct mipi_dcs_cmd_ctr_list, list);
+				printk("\n dcs_name:%s,dcs_type:%d,side_id:%d,cmd_len:%d,delay:%d\n\n",
+					dcs_cmd->dcs_cmd.name,
+					dcs_cmd->dcs_cmd.type,
+					dcs_cmd->dcs_cmd.dsi_id,
+					dcs_cmd->dcs_cmd.cmd_len,
+					dcs_cmd->dcs_cmd.delay);
+				for (i = 0; i < (dcs_cmd->dcs_cmd.cmd_len); i++) {
+					printk("[%d]=%02x,", i+1, dcs_cmd->dcs_cmd.cmds[i]);
+				}
+			}
+		} else {
+			MIPI_SCREEN_DBG("---close cmd debug---\n");
+		}
+	}
+	return 0;
+}
+#endif
+int rk_mipi_get_dsi_num(void)
+{
+	return gmipi_screen->mipi_dsi_num;
+}
+#ifdef CONFIG_LCD_MIPI
+EXPORT_SYMBOL(rk_mipi_get_dsi_num);
+#endif
+
+int rk_mipi_get_dsi_lane(void)
+{
+	return gmipi_screen->dsi_lane;
+}
+#ifdef CONFIG_LCD_MIPI
+EXPORT_SYMBOL(rk_mipi_get_dsi_lane);
+#endif
+
+int rk_mipi_get_dsi_clk(void)
+{
+	return gmipi_screen->hs_tx_clk;
+}
+#ifdef CONFIG_LCD_MIPI
+EXPORT_SYMBOL(rk_mipi_get_dsi_clk);
+#endif
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+#ifdef CONFIG_OF_LIBFDT
+static int rk_mipi_screen_init_dt(struct mipi_screen *screen)
+{
+	struct mipi_dcs_cmd_ctr_list *dcs_cmd;
+	u32 i;
+	int length;
+	int err;
+	int node;
+	const void *blob;
+	struct fdt_gpio_state gpio_val;
+	int noffset;
+
+	INIT_LIST_HEAD(&screen->cmdlist_head);
+
+	blob = gd->fdt_blob; /* getenv_hex("fdtaddr", 0); */
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_INIT);
+	if (node < 0) {
+		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_INIT\n");
+	}
+	screen->screen_init = fdtdec_get_int(blob, node, "rockchip,screen_init", -1);
+	if (screen->screen_init < 0) {
+		MIPI_SCREEN_DBG("Can not get screen_init\n");
+	}
+	screen->dsi_lane = fdtdec_get_int(blob, node, "rockchip,dsi_lane", -1);
+	if (screen->dsi_lane < 0) {
+		MIPI_SCREEN_DBG("Can not get dsi_lane\n");
+	}
+	screen->hs_tx_clk = fdtdec_get_int(blob, node, "rockchip,dsi_hs_clk", -1);
+	if (screen->hs_tx_clk < 0) {
+		MIPI_SCREEN_DBG("Can not get dsi_hs_clk\n");
+	} else {
+		screen->hs_tx_clk = screen->hs_tx_clk*MHZ;
+	}
+	screen->mipi_dsi_num = fdtdec_get_int(blob, node, "rockchip,mipi_dsi_num", -1);
+	if (screen->mipi_dsi_num < 0) {
+		MIPI_SCREEN_DBG("Can't get mipi_dsi_num\n");
+	}
+#if 0
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
+	if (node < 0) {
+		printf("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
+	}
+#endif
+
+#if 0
+/*get the lcd rst status
+	handle = fdt_getprop_u32_default(blob, "/mipi_power_ctr", "mipi_lcd_rst", -1);
+	node = fdt_node_offset_by_phandle(blob, handle);
+*/
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
+	if (node < 0) {
+		printf("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
+	} else {
+		subnode = fdtdec_next_compatible_subnode(blob, node,
+				COMPAT_ROCKCHIP_MIPI_LCD_RST, &depth);
+		if (subnode <= 0) {
+			screen->lcd_rst_gpio = INVALID_GPIO;
+			printf("Can't get pin of mipi_lcd_rst\n");
+		} else {
+			err = fdtdec_decode_gpio(blob, subnode, "rockchip,gpios", &gpio_val);
+			gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
+			if (err < 0) {
+				screen->lcd_rst_gpio = INVALID_GPIO;
+				printf("Can't find GPIO rst\n");
+			} else {
+				screen->lcd_rst_gpio = gpio_val.gpio;
+				screen->lcd_rst_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
+			}
+			screen->lcd_rst_delay = fdtdec_get_int(blob, subnode, "rockchip,delay", -1);
+			if (screen->lcd_rst_delay < 0) {
+				printf("Can't get delay of rst delay\n");
+			}
+			printf("Get lcd rst gpio and delay successfully!\n");
+		}
+	}
+#endif
+	/* get the lcd rst & en status */
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
+	if (node < 0) {
+		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
+	} else {
+#if 0
+		noffset = fdt_first_subnode(blob, node);
+		const char *name = fdt_get_name(blob, noffset, NULL);
+		printf("XJH_DEBUG1:%s\n", name);
+		noffset = fdt_next_subnode(blob, noffset);
+		const char *name1 = fdt_get_name(blob, noffset, NULL);
+		printf("XJH_DEBUG2:%s\n", name1);
+#endif
+		for (noffset = fdt_first_subnode(blob, node);
+		noffset >= 0;
+		noffset = fdt_next_subnode(blob, noffset)) {
+			if (0 == fdt_node_check_compatible(blob, noffset, "rockchip,lcd_rst")) {
+				err = fdtdec_decode_gpio(blob, noffset, "rockchip,gpios", &gpio_val);
+				gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
+				if (err < 0) {
+					screen->lcd_rst_gpio = INVALID_GPIO;
+					MIPI_SCREEN_DBG("Can't find GPIO rst\n");
+				} else {
+					screen->lcd_rst_gpio = gpio_val.gpio;
+					screen->lcd_rst_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
+				}
+				screen->lcd_rst_delay = fdtdec_get_int(blob, noffset, "rockchip,delay", -1);
+				if (screen->lcd_rst_delay < 0) {
+					MIPI_SCREEN_DBG("Can't get delay of rst delay\n");
+				}
+				MIPI_SCREEN_DBG("Get lcd rst gpio and delay successfully!\n");
+			}
+			if (0 == fdt_node_check_compatible(blob, noffset, "rockchip,lcd_en")) {
+				err = fdtdec_decode_gpio(blob, noffset, "rockchip,gpios", &gpio_val);
+				gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
+				if (err < 0) {
+					screen->lcd_en_gpio = INVALID_GPIO;
+					MIPI_SCREEN_DBG("Can't find GPIO en\n");
+				} else {
+					screen->lcd_en_gpio = gpio_val.gpio;
+					screen->lcd_en_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
+				}
+				screen->lcd_en_delay = fdtdec_get_int(blob, noffset, "rockchip,delay", -1);
+				if (screen->lcd_en_delay < 0) {
+					MIPI_SCREEN_DBG("Can't get delay of lcd_en delay\n");
+				}
+				MIPI_SCREEN_DBG("Get lcd en gpio and delay successfully:delay %d!\n", screen->lcd_en_delay);
+			}
+		}
+	}
+
+	/*get the initial command list*/
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_SONCMDS);
+	if (node < 0) {
+		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_SONCMDS\n");
+	} else {
+		for (noffset = fdt_first_subnode(blob, node);
+		noffset >= 0;
+		noffset = fdt_next_subnode(blob, noffset)) {
+
+			MIPI_SCREEN_DBG("build MIPI LCD init cmd tables\n");
+			/*
+			subnode = fdtdec_next_compatible_subnode(blob, node,
+					COMPAT_ROCKCHIP_MIPI_ONCMDS, &depth);
+			if (noffset < 0)
+				break;
+			*/
+			dcs_cmd = calloc(1, sizeof(struct mipi_dcs_cmd_ctr_list));
+			/* node = fdt_node_offset_by_phandle(blob, handle); */
+			strcpy(dcs_cmd->dcs_cmd.name, fdt_get_name(blob, noffset, NULL));
+			MIPI_SCREEN_DBG("%s\n", dcs_cmd->dcs_cmd.name);
+			dcs_cmd->dcs_cmd.type = fdtdec_get_int(blob, noffset, "rockchip,cmd_type", -1);
+			MIPI_SCREEN_DBG("dcs_cmd.type=%02x\n", dcs_cmd->dcs_cmd.type);
+			dcs_cmd->dcs_cmd.dsi_id = fdtdec_get_int(blob, noffset, "rockchip,dsi_id", -1);
+			MIPI_SCREEN_DBG("dcs_cmd.dsi_id=%02x\n", dcs_cmd->dcs_cmd.dsi_id);
+			fdt_getprop(blob, noffset, "rockchip,cmd", &length);
+			dcs_cmd->dcs_cmd.cmd_len = length / sizeof(u32) ;
+
+			dcs_cmd->dcs_cmd.cmds = calloc(1, length);
+			if (!dcs_cmd->dcs_cmd.cmds) {
+				pr_err("calloc cmds fail!\n");
+				return -1;
+			}
+
+			err = fdtdec_get_int_array(blob, noffset,
+						   "rockchip,cmd",
+						   dcs_cmd->dcs_cmd.cmds,
+						   dcs_cmd->dcs_cmd.cmd_len);
+			dcs_cmd->dcs_cmd.delay = fdtdec_get_int(blob, noffset, "rockchip,cmd_delay", -1);
+			MIPI_SCREEN_DBG("dcs_cmd.delay=%d\n", dcs_cmd->dcs_cmd.delay);
+			list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
+		}
+	}
+	return 0;
+}
+#endif /* CONFIG_OF_LIBFDT */
+
+int rk_mipi_screen_probe(void)
+{
+	int ret = 0;
+	gmipi_screen = calloc(1, sizeof(struct mipi_screen));
+	if (!gmipi_screen) {
+		printf("request struct screen fail!\n");
+		return -ENOMEM;
+	}
+#ifdef CONFIG_OF_LIBFDT
+	ret = rk_mipi_screen_init_dt(gmipi_screen);
+	if (ret < 0) {
+		printf(" rk_mipi_screen_init_dt fail!\n");
+		return -1;
+	}
+#endif /* CONFIG_OF_LIBFDT */
+
+	MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
+	return 0;
+}
+
+#endif /* CONFIG_RK_3288_DSI_UBOOT */
+#ifdef CONFIG_LCD_MIPI
+static int __init rk_mipi_screen_probe(struct platform_device *pdev)
+{
+	static int ret;
+
+	gmipi_screen = devm_kzalloc(&pdev->dev, sizeof(struct mipi_screen), GFP_KERNEL);
+	if (!gmipi_screen) {
+		dev_err(&pdev->dev, "request struct screen fail!\n");
+		return -ENOMEM;
+	}
+
+	ret = rk_mipi_screen_init_dt(&pdev->dev, gmipi_screen);
+	if (ret < 0) {
+		dev_err(&pdev->dev, " rk_mipi_screen_init_dt fail!\n");
+		return -1;
+	}
+
+	MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
+	return 0;
+}
+
+static struct platform_driver mipi_screen_platform_driver = {
+	.driver = {
+		.name = "rk_mipi_screen",
+	},
+};
+
+static int __init rk_mipi_screen_init(void)
+{
+	platform_device_register_simple("rk_mipi_screen", -1, NULL, 0);
+	return platform_driver_probe(&mipi_screen_platform_driver, rk_mipi_screen_probe);
+}
+
+static void __exit rk_mipi_screen_exit(void)
+{
+	platform_driver_unregister(&mipi_screen_platform_driver);
+}
+
+subsys_initcall_sync(rk_mipi_screen_init);
+module_exit(rk_mipi_screen_exit);
+#endif
diff -Nupr a/drivers/video/rockchip/screen/Makefile b/drivers/video/rockchip/screen/Makefile
--- a/drivers/video/rockchip/screen/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/screen/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_LCD_GENERAL)			+= lcd_general.o
+obj-$(CONFIG_LCD_MIPI)	+= lcd_mipi.o
+
+
+quiet_cmd_gen = GEN     $@
+      cmd_gen = cmp -s $< $@ || cp $< $@
+
+lcd-obj := $(filter lcd_%.o,$(obj-y))
+lcd-cfile := $(patsubst %.o,%.c,$(lcd-obj))
+lcd-cpath := $(src)/$(lcd-cfile)
+
+obj-y := $(filter-out $(lcd-obj),$(obj-y))
+
+$(obj)/lcd.h: $(lcd-cpath)  FORCE
+	$(call if_changed,gen)
+
+$(obj)/rk_screen.o: $(obj)/lcd.h
+obj-y += rk_screen.o
+
+clean-files := lcd.h
diff -Nupr a/drivers/video/rockchip/screen/rk_screen.c b/drivers/video/rockchip/screen/rk_screen.c
--- a/drivers/video/rockchip/screen/rk_screen.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/screen/rk_screen.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/module.h>
+#include <linux/rk_fb.h>
+#include <linux/device.h>
+#include "lcd.h"
+#include "../hdmi/rockchip-hdmi.h"
+
+static struct rk_screen *rk_screen;
+
+int rk_fb_get_extern_screen(struct rk_screen *screen)
+{
+	if (unlikely(!rk_screen) || unlikely(!screen))
+		return -1;
+
+	memcpy(screen, rk_screen, sizeof(struct rk_screen));
+	screen->dsp_lut = NULL;
+	screen->cabc_lut = NULL;
+	screen->type = SCREEN_NULL;
+
+	return 0;
+}
+
+int  rk_fb_get_prmry_screen(struct rk_screen *screen)
+{
+	if (unlikely(!rk_screen) || unlikely(!screen))
+		return -1;
+
+	memcpy(screen, rk_screen, sizeof(struct rk_screen));
+	return 0;
+}
+
+int rk_fb_set_prmry_screen(struct rk_screen *screen)
+{
+	if (unlikely(!rk_screen) || unlikely(!screen))
+		return -1;
+
+	rk_screen->lcdc_id = screen->lcdc_id;
+	rk_screen->screen_id = screen->screen_id;
+	rk_screen->x_mirror = screen->x_mirror;
+	rk_screen->y_mirror = screen->y_mirror;
+	rk_screen->overscan.left = screen->overscan.left;
+	rk_screen->overscan.top = screen->overscan.left;
+	rk_screen->overscan.right = screen->overscan.left;
+	rk_screen->overscan.bottom = screen->overscan.left;
+	return 0;
+}
+
+size_t get_fb_size(u8 reserved_fb)
+{
+	size_t size = 0;
+	u32 xres = 0;
+	u32 yres = 0;
+
+	if (unlikely(!rk_screen))
+		return 0;
+
+	xres = rk_screen->mode.xres;
+	yres = rk_screen->mode.yres;
+
+	/* align as 64 bytes(16*4) in an odd number of times */
+	xres = ALIGN_64BYTE_ODD_TIMES(xres, ALIGN_PIXEL_64BYTE_RGB8888);
+        if (reserved_fb == 1) {
+                size = (xres * yres << 2) << 1;/*two buffer*/
+        } else {
+#if defined(CONFIG_THREE_FB_BUFFER)
+		size = (xres * yres << 2) * 3;	/* three buffer */
+#else
+		size = (xres * yres << 2) << 1; /* two buffer */
+#endif
+	}
+	return ALIGN(size, SZ_1M);
+}
+
+static int rk_screen_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing device tree node.\n");
+		return -EINVAL;
+	}
+	rk_screen = devm_kzalloc(&pdev->dev,
+			sizeof(struct rk_screen), GFP_KERNEL);
+	if (!rk_screen) {
+		dev_err(&pdev->dev, "kmalloc for rk screen fail!");
+		return  -ENOMEM;
+	}
+	ret = rk_fb_prase_timing_dt(np, rk_screen);
+	dev_info(&pdev->dev, "rockchip screen probe %s\n",
+				ret ? "failed" : "success");
+	return ret;
+}
+
+static const struct of_device_id rk_screen_dt_ids[] = {
+	{ .compatible = "rockchip,screen", },
+	{}
+};
+
+static struct platform_driver rk_screen_driver = {
+	.probe		= rk_screen_probe,
+	.driver		= {
+		.name	= "rk-screen",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(rk_screen_dt_ids),
+	},
+};
+
+static int __init rk_screen_init(void)
+{
+	return platform_driver_register(&rk_screen_driver);
+}
+
+static void __exit rk_screen_exit(void)
+{
+	platform_driver_unregister(&rk_screen_driver);
+}
+
+fs_initcall(rk_screen_init);
+module_exit(rk_screen_exit);
+
diff -Nupr a/drivers/video/rockchip/transmitter/anx6345.h b/drivers/video/rockchip/transmitter/anx6345.h
--- a/drivers/video/rockchip/transmitter/anx6345.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/anx6345.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,689 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ANX6345_H_
+#define __ANX6345_H_
+
+#include<linux/rk_fb.h>
+#include "anx9805.h"
+
+#define ANX6345_SCL_RATE (100*1000)
+
+#define MAX_REG     	0xf0
+#define MAX_BUF_CNT 	6
+
+
+#define DP_TX_PORT0_ADDR 0x70
+#define HDMI_TX_PORT0_ADDR 0x72
+
+#define DP_TIMEOUT_LOOP_CNT 100
+#define MAX_CR_LOOP 5
+#define MAX_EQ_LOOP 5
+
+/***************************************************************/
+//  DEV_ADDR = 0x7A or 0x7B , MIPI Rx Registers
+#define MIPI_ANALOG_PWD_CTRL0				 0x00
+#define MIPI_ANALOG_PWD_CTRL1			        0x01
+#define MIPI_ANALOG_PWD_CTRL2			        0x02
+
+#define MIPI_MISC_CTRL                         0x03 
+
+#define MIPI_TIMING_REG0                    0x04 
+#define MIPI_TIMING_REG1                    0x05 
+#define MIPI_TIMING_REG2                    0x06 
+#define MIPI_TIMING_REG3                    0x07
+#define MIPI_TIMING_REG4                    0x08 
+#define MIPI_TIMING_REG5                    0x09 
+#define MIPI_TIMING_REG6                    0x0a 
+
+#define MIPI_HS_JITTER_REG                 0x0B
+
+#define MIPI_VID_STABLE_CNT               0x0C 
+
+#define MIPI_ANALOG_CTRL0                  0x0D 
+#define MIPI_ANALOG_CTRL1                  0x0E
+#define MIPI_ANALOG_CTRL2                  0x0F 
+
+#define MIPI_PRBS_REG                           0x10 
+#define MIPI_PROTOCOL_STATE               0x11 
+
+
+//End for DEV_addr 0x7A/0x7E
+
+/***************************************************************/
+//  DEV_ADDR = 0x70 or 0x78 , Displayport mode and HDCP registers
+#define HDCP_STATUS							  				0x00
+#define HDCP_AUTH_PASS						  			0x02//bit position
+
+#define HDCP_CONTROL_0_REG                  		0x01
+#define HDCP_CONTROL_0_STORE_AN            0x80//bit position
+#define HDCP_CONTROL_0_RX_REPEATER   	0x40//bit position
+#define HDCP_CONTROL_0_RE_AUTH              0x20//bit position
+#define HDCP_CONTROL_0_SW_AUTH_OK       0x10//bit position
+#define HDCP_CONTROL_0_HARD_AUTH_EN   0x08//bit position
+#define HDCP_CONTROL_0_HDCP_ENC_EN      0x04//bit position
+#define HDCP_CONTROL_0_BKSV_SRM_PASS  0x02//bit position
+#define HDCP_CONTROL_0_KSVLIST_VLD        0x01//bit position
+
+
+#define HDCP_CONTROL_1_REG                  		0x02
+#define HDCP_CONTROL_1_DDC_NO_STOP      			0x20//bit position
+#define HDCP_CONTROL_1_DDC_NO_ACK        			0x10//bit position
+#define HDCP_CONTROL_1_EDDC_NO_ACK          		0x08//bit position
+//#define HDCP_CONTROL_1_HDCP_EMB_SCREEN_EN   		0x04//bit position
+#define HDCP_CONTROL_1_RCV_11_EN                  0x02//bit position
+#define HDCP_CONTROL_1_HDCP_11_EN           		0x01//bit position
+
+#define HDCP_LINK_CHK_FRAME_NUM				 	0x03
+#define HDCP_CONTROL_2_REG						0x04
+
+#define HDCP_AKSV0								0x05
+#define HDCP_AKSV1								0x06
+#define HDCP_AKSV2								0x07
+#define HDCP_AKSV3								0x08
+#define HDCP_AKSV4								0x09
+
+//AKSV
+#define HDCP_AN0									0x0A
+#define HDCP_AN1									0x0B
+#define HDCP_AN2									0x0C
+#define HDCP_AN3									0x0D
+#define HDCP_AN4									0x0E
+#define HDCP_AN5									0x0F
+#define HDCP_AN6									0x10
+#define HDCP_AN7									0x11
+
+//BKSV
+#define HDCP_BKSV0								0x12
+#define HDCP_BKSV1								0x13
+#define HDCP_BKSV2								0x14
+#define HDCP_BKSV3								0x15
+#define HDCP_BKSV4								0x16
+
+#define HDCP_R0_L									0x17
+#define HDCP_R0_H									0x18
+
+#define M_VID_0 0xC0
+#define M_VID_1 0xC1
+#define M_VID_2 0xC2
+#define N_VID_0 0xC3
+#define N_VID_1 0xC4
+#define N_VID_2 0xC5
+
+#define HDCP_R0_WAIT_Timer					 0x40
+
+
+
+#define SYS_CTRL1_REG           					0x80
+//#define SYS_CTRL1_PD_IO         					0x80    // bit position
+//#define SYS_CTRL1_PD_VID        					0x40    // bit position
+//#define SYS_CTRL1_PD_LINK       					0x20    // bit position
+//#define SYS_CTRL1_PD_TOTAL      					0x10    // bit position
+//#define SYS_CTRL1_MODE_SEL      					0x08    // bit position
+#define SYS_CTRL1_DET_STA       					0x04    // bit position
+#define SYS_CTRL1_FORCE_DET     					0x02    // bit position
+#define SYS_CTRL1_DET_CTRL      					0x01    // bit position
+
+#define SYS_CTRL2_REG           					0x81
+// #define SYS_CTRL2_ENHANCED 	  					0x08	  //bit position
+#define SYS_CTRL2_CHA_STA       					0x04    // bit position
+#define SYS_CTRL2_FORCE_CHA     					0x02    // bit position
+#define SYS_CTRL2_CHA_CTRL      					0x01    // bit position
+
+#define SYS_CTRL3_REG           					0x82
+#define SYS_CTRL3_HPD_STATUS    					0x40    // bit position
+#define SYS_CTRL3_F_HPD         					0x20    // bit position
+#define SYS_CTRL3_HPD_CTRL      					0x10    // bit position
+#define SYS_CTRL3_STRM_VALID    					0x04    // bit position
+#define SYS_CTRL3_F_VALID       					0x02    // bit position
+#define SYS_CTRL3_VALID_CTRL    					0x01    // bit position
+
+#define SYS_CTRL4_REG			  					0x83
+#define SYS_CTRL4_ENHANCED 	  					0x08//bit position
+
+#define VID_CTRL				  					0x84
+
+#define AUD_CTRL									0x87
+#define AUD_CTRL_AUD_EN							0x01
+
+
+#define PKT_EN_REG              					0x90
+#define PKT_AUD_UP								0x80  // bit position
+#define PKT_AVI_UD              					0x40  // bit position
+#define PKT_MPEG_UD             					0x20  // bit position    
+#define PKT_SPD_UD              					0x10  // bit position   
+#define PKT_AUD_EN								0x08  // bit position=
+#define PKT_AVI_EN              					0x04  // bit position          
+#define PKT_MPEG_EN             					0x02  // bit position     
+#define PKT_SPD_EN              					0x01  // bit position       
+
+
+#define HDCP_CTRL 												0x92
+
+#define LINK_BW_SET_REG         				 0xA0
+#define LANE_COUNT_SET_REG      				 0xA1
+
+#define TRAINING_PTN_SET_REG                   0xA2
+#define SCRAMBLE_DISABLE						 0x20//bit 5
+
+#define TRAINING_LANE0_SET_REG                 				0xA3
+#define TRAINING_LANE0_SET_MAX_PRE_REACH        0x20        // bit position
+#define TRAINING_LANE0_SET_MAX_DRIVE_REACH     0x04        // bit position
+
+#define TRAINING_LANE1_SET_REG                0xA4
+
+
+#define SSC_CTRL_REG1					 0xA7
+#define SPREAD_AMP						 0x10//bit 4
+#define MODULATION_FREQ					 0x01//bit 0
+
+
+#define LINK_TRAINING_CTRL_REG                0xA8
+#define LINK_TRAINING_CTRL_EN                 0x01        // bit position
+
+
+#define DEBUG_REG1							0xB0
+#define DEBUG_HPD_POLLING_DET						0x40//bit position
+#define DEBUG_HPD_POLLING_EN						0x20//bit position
+#define DEBUG_PLL_LOCK						0x10//bit position
+
+
+#define LINK_DEBUG_REG                        0xB8
+#define LINK_DEBUG_INSERT_ER                  0x02        // bit position
+#define LINK_DEBUG_PRBS31_EN                  0x01        // bit position
+
+#define SINK_COUNT_REG                0xB9
+
+#define LINK_STATUS_REG1                               0xBB
+
+#define SINK_STATUS_REG                                   0xBE
+#define SINK_STATUS_SINK_STATUS_1          	0x02        // bit position
+#define SINK_STATUS_SINK_STATUS_0          	0x01        // bit position
+
+
+//#define LINK_TEST_COUNT                     0xC0
+
+
+#define PLL_CTRL_REG											0xC7	
+#define PLL_CTRL_PLL_PD           						0x80        // bit position
+#define PLL_CTRL_PLL_RESET        					0x40        // bit position 
+//#define PLL_CTRL_CPREG_BLEED      					0x08        // bit position 
+
+#define ANALOG_POWER_DOWN_REG                   			0xC8
+#define ANALOG_POWER_DOWN_MACRO_PD              	0x20        // bit position 
+#define ANALOG_POWER_DOWN_AUX_PD                		0x10        // bit position 
+//#define ANALOG_POWER_DOWN_CH3_PD                		0x08        // bit position 
+//#define ANALOG_POWER_DOWN_CH2_PD                		0x04        // bit position 
+#define ANALOG_POWER_DOWN_CH1_PD                		0x02        // bit position 
+#define ANALOG_POWER_DOWN_CH0_PD                		0x01        // bit position 
+
+
+#define ANALOG_TEST_REG                         					0xC9
+#define ANALOG_TEST_MACRO_RST                   				0x20       // bit position 
+#define ANALOG_TEST_PLL_TEST                    				0x10       // bit position 
+#define ANALOG_TEST_CH3_TEST                    				0x08       // bit position 
+#define ANALOG_TEST_CH2_TEST                    				0x04       // bit position 
+#define ANALOG_TEST_CH1_TEST                    				0x02       // bit position 
+#define ANALOG_TEST_CH0_TEST                    				0x01       // bit position 
+
+#define GNS_CTRL_REG                            							0xCD
+#define SP_EQ_LOOP_CNT											0x40//bit position
+#define VIDEO_MAP_CTRL                 			                            0x02       // bit position 
+#define RS_CTRL                        					              	0x01       // bit position 
+
+#define DOWN_SPREADING_CTRL1                                               0xD0   //guochuncheng
+#define DOWN_SPREADING_CTRL2                                               0xD1
+#define DOWN_SPREADING_CTRL3                                               0xD2
+#define SSC_D_CTRL                                                             0x40       //bit position
+#define FS_CTRL_TH_CTRL                                                   0x20       //bit position
+
+#define M_CALCU_CTRL												0xD9
+#define M_GEN_CLK_SEL													0x01//bit 0
+
+
+#define EXTRA_ADDR_REG											0xCE
+#define I2C_STRETCH_CTRL_REG                                                              0xDB
+#define AUX_STATUS            										0xE0
+#define DEFER_CTRL_REG            									0xE2
+#define SP_TXL_DEFER_CTRL_EN  					                     		       0x80       // bit position 
+
+#define BUF_DATA_COUNT_REG											0xE4
+#define AUX_CTRL_REG              										0xE5
+#define MOT_BIT													0x04//bit 2
+
+#define AUX_ADDR_7_0_REG          									0xE6
+#define AUX_ADDR_15_8_REG         									0xE7
+#define AUX_ADDR_19_16_REG        									0xE8
+
+#define AUX_CTRL_REG2                                                 0xE9
+#define ADDR_ONLY_BIT													0x02//bit 1
+
+#define BUF_DATA_0_REG                          0xf0
+#define BUF_DATA_1_REG                          0xf1
+#define BUF_DATA_2_REG                          0xf2
+#define BUF_DATA_3_REG                          0xf3
+#define BUF_DATA_4_REG                          0xf4
+#define BUF_DATA_5_REG                          0xf5
+#define BUF_DATA_6_REG                          0xf6
+#define BUF_DATA_7_REG                          0xf7
+#define BUF_DATA_8_REG                          0xf8
+#define BUF_DATA_9_REG                          0xf9
+#define BUF_DATA_10_REG                         0xfa
+#define BUF_DATA_11_REG                         0xfb
+#define BUF_DATA_12_REG                         0xfc
+#define BUF_DATA_13_REG                         0xfd
+#define BUF_DATA_14_REG                         0xfe
+#define BUF_DATA_15_REG                         0xff
+
+//End for Address 0x70 or 0x78
+
+/***************************************************************/
+//  DEV_ADDR = 0x72 or 0x76, System control registers
+#define VND_IDL_REG             	0x00
+#define VND_IDH_REG             	0x01
+#define DEV_IDL_REG             	0x02
+#define DEV_IDH_REG             	0x03
+#define DEV_REV_REG             	0x04
+
+#define SP_POWERD_CTRL_REG			  	0x05
+#define SP_POWERD_REGISTER_REG			0x80// bit position
+//#define SP_POWERD_MISC_REG			  	0x40// bit position
+#define SP_POWERD_IO_REG			  	0x20// bit position
+#define SP_POWERD_AUDIO_REG				0x10// bit position
+#define SP_POWERD_VIDEO_REG			  	0x08// bit position
+#define SP_POWERD_LINK_REG			  	0x04// bit position
+#define SP_POWERD_TOTAL_REG			  	0x02// bit position
+#define SP_MODE_SEL_REG				  	0x01// bit position
+
+#define RST_CTRL_REG            	0x06
+#define RST_MISC_REG 			  	0x80	// bit position
+#define RST_VIDCAP_REG		  	0x40	// bit position
+#define RST_VIDFIF_REG          	0x20    // bit position
+#define RST_AUDFIF_REG          	0x10    // bit position
+#define RST_AUDCAP_REG         	0x08    // bit position
+#define RST_HDCP_REG            	0x04    // bit position
+#define RST_SW_RST             	0x02    // bit position
+#define RST_HW_RST             	0x01    // bit position
+
+#define RST_CTRL2_REG				0x07
+#define RST_SSC					0x80//bit position
+#define AC_MODE					0x40//bit position
+//#define DDC_RST					0x10//bit position
+//#define TMDS_BIST_RST				0x08//bit position
+#define AUX_RST					0x04//bit position
+#define SERDES_FIFO_RST			0x02//bit position
+#define I2C_REG_RST				0x01//bit position
+
+
+#define VID_CTRL1_REG           	0x08
+#define VID_CTRL1_VID_EN       0x80    // bit position
+#define VID_CTRL1_VID_MUTE   0x40    // bit position
+#define VID_CTRL1_DE_GEN      0x20    // bit position
+#define VID_CTRL1_DEMUX        0x10    // bit position
+#define VID_CTRL1_IN_BIT		  	0x04    // bit position
+#define VID_CTRL1_DDRCTRL		0x02    // bit position
+#define VID_CTRL1_EDGE		  		0x01    // bit position
+
+#define VID_CTRL2_REG           	0x09
+#define VID_CTRL1_YCBIT_SEL  		0x04    // bit position
+
+#define VID_CTRL3_REG           	0x0A
+
+#define VID_CTRL4_REG           		0x0B
+#define VID_CTRL4_E_SYNC_EN	  	0x80	  //bit position
+#define VID_CTRL4_EX_E_SYNC    		0x40    // bit position
+#define VID_CTRL4_BIST          		0x08    // bit position
+#define VID_CTRL4_BIST_WIDTH   		0x04        // bit position
+
+#define VID_CTRL5_REG           		0x0C
+
+#define VID_CTRL6_REG           		0x0D
+#define VID_UPSAMPLE			0x02//bit position
+
+#define VID_CTRL7_REG           		0x0E
+#define VID_CTRL8_REG           		0x0F
+#define VID_CTRL9_REG           		0x10
+
+#define VID_CTRL10_REG           		0x11
+#define VID_CTRL10_INV_F         		0x08    // bit position
+#define VID_CTRL10_I_SCAN        		0x04    // bit position
+#define VID_CTRL10_VSYNC_POL   		0x02    // bit position
+#define VID_CTRL10_HSYNC_POL   		0x01    // bit position
+
+#define TOTAL_LINEL_REG         0x12
+#define TOTAL_LINEH_REG         0x13
+#define ACT_LINEL_REG           0x14
+#define ACT_LINEH_REG           0x15
+#define VF_PORCH_REG            0x16
+#define VSYNC_CFG_REG           0x17
+#define VB_PORCH_REG            0x18
+#define TOTAL_PIXELL_REG        0x19
+#define TOTAL_PIXELH_REG        0x1A
+#define ACT_PIXELL_REG          0x1B
+#define ACT_PIXELH_REG          0x1C
+#define HF_PORCHL_REG           0x1D
+#define HF_PORCHH_REG           0x1E
+#define HSYNC_CFGL_REG          0x1F
+#define HSYNC_CFGH_REG          0x20
+#define HB_PORCHL_REG           0x21
+#define HB_PORCHH_REG           0x22
+
+#define VID_STATUS						0x23
+
+#define TOTAL_LINE_STA_L        0x24
+#define TOTAL_LINE_STA_H        0x25
+#define ACT_LINE_STA_L          0x26
+#define ACT_LINE_STA_H          0x27
+#define V_F_PORCH_STA           0x28
+#define V_SYNC_STA              0x29
+#define V_B_PORCH_STA           0x2A
+#define TOTAL_PIXEL_STA_L       0x2B
+#define TOTAL_PIXEL_STA_H       0x2C
+#define ACT_PIXEL_STA_L         0x2D
+#define ACT_PIXEL_STA_H         0x2E
+#define H_F_PORCH_STA_L         0x2F
+#define H_F_PORCH_STA_H         0x30
+#define H_SYNC_STA_L            0x31
+#define H_SYNC_STA_H            0x32
+#define H_B_PORCH_STA_L         0x33
+#define H_B_PORCH_STA_H         0x34
+
+#define Video_Interface_BIST    0x35
+
+#define SPDIF_AUDIO_CTRL0			0x36
+#define SPDIF_AUDIO_CTRL0_SPDIF_IN  0x80 // bit position
+
+#define SPDIF_AUDIO_STATUS0			0x38
+#define SPDIF_AUDIO_STATUS0_CLK_DET 0x80
+#define SPDIF_AUDIO_STATUS0_AUD_DET 0x01
+
+#define SPDIF_AUDIO_STATUS1 0x39
+
+#define AUDIO_BIST_CTRL 0x3c
+#define AUDIO_BIST_EN 0x01
+
+//#define AUDIO_BIST_CHANNEL_STATUS1 0xd0
+//#define AUDIO_BIST_CHANNEL_STATUS2 0xd1
+//#define AUDIO_BIST_CHANNEL_STATUS3 0xd2
+//#define AUDIO_BIST_CHANNEL_STATUS4 0xd3
+//#define AUDIO_BIST_CHANNEL_STATUS5 0xd4
+
+#define VIDEO_BIT_CTRL_0_REG                    0x40
+#define VIDEO_BIT_CTRL_1_REG                    0x41
+#define VIDEO_BIT_CTRL_2_REG                    0x42
+#define VIDEO_BIT_CTRL_3_REG                    0x43
+#define VIDEO_BIT_CTRL_4_REG                    0x44
+#define VIDEO_BIT_CTRL_5_REG                    0x45
+#define VIDEO_BIT_CTRL_6_REG                    0x46
+#define VIDEO_BIT_CTRL_7_REG                    0x47
+#define VIDEO_BIT_CTRL_8_REG                    0x48
+#define VIDEO_BIT_CTRL_9_REG                    0x49
+#define VIDEO_BIT_CTRL_10_REG                   0x4a
+#define VIDEO_BIT_CTRL_11_REG                   0x4b
+#define VIDEO_BIT_CTRL_12_REG                   0x4c
+#define VIDEO_BIT_CTRL_13_REG                   0x4d
+#define VIDEO_BIT_CTRL_14_REG                   0x4e
+#define VIDEO_BIT_CTRL_15_REG                   0x4f
+#define VIDEO_BIT_CTRL_16_REG                   0x50
+#define VIDEO_BIT_CTRL_17_REG                   0x51
+#define VIDEO_BIT_CTRL_18_REG                   0x52
+#define VIDEO_BIT_CTRL_19_REG                   0x53
+#define VIDEO_BIT_CTRL_20_REG                   0x54
+#define VIDEO_BIT_CTRL_21_REG                   0x55
+#define VIDEO_BIT_CTRL_22_REG                   0x56
+#define VIDEO_BIT_CTRL_23_REG                   0x57
+#define VIDEO_BIT_CTRL_24_REG                   0x58
+#define VIDEO_BIT_CTRL_25_REG                   0x59
+#define VIDEO_BIT_CTRL_26_REG                   0x5a
+#define VIDEO_BIT_CTRL_27_REG                   0x5b
+#define VIDEO_BIT_CTRL_28_REG                   0x5c
+#define VIDEO_BIT_CTRL_29_REG                   0x5d
+#define VIDEO_BIT_CTRL_30_REG                   0x5e
+#define VIDEO_BIT_CTRL_31_REG                   0x5f
+#define VIDEO_BIT_CTRL_32_REG                   0x60
+#define VIDEO_BIT_CTRL_33_REG                   0x61
+#define VIDEO_BIT_CTRL_34_REG                   0x62
+#define VIDEO_BIT_CTRL_35_REG                   0x63
+#define VIDEO_BIT_CTRL_36_REG                   0x64
+#define VIDEO_BIT_CTRL_37_REG                   0x65
+#define VIDEO_BIT_CTRL_38_REG                   0x66
+#define VIDEO_BIT_CTRL_39_REG                   0x67
+#define VIDEO_BIT_CTRL_40_REG                   0x68
+#define VIDEO_BIT_CTRL_41_REG                   0x69
+#define VIDEO_BIT_CTRL_42_REG                   0x6a
+#define VIDEO_BIT_CTRL_43_REG                   0x6b
+#define VIDEO_BIT_CTRL_44_REG                   0x6c
+#define VIDEO_BIT_CTRL_45_REG                   0x6d
+#define VIDEO_BIT_CTRL_46_REG                   0x6e
+#define VIDEO_BIT_CTRL_47_REG                   0x6f
+
+//AVI info frame
+#define AVI_TYPE              0x70
+#define AVI_VER               0x71
+#define AVI_LEN               0x72
+#define AVI_DB0		     0x73
+#define AVI_DB1               0x74
+#define AVI_DB2               0x75
+#define AVI_DB3               0x76
+#define AVI_DB4               0x77
+#define AVI_DB5               0x78
+#define AVI_DB6               0x79
+#define AVI_DB7               0x7A
+#define AVI_DB8               0x7B
+#define AVI_DB9               0x7C
+#define AVI_DB10              0x7D
+#define AVI_DB11              0x7E
+#define AVI_DB12              0x7F
+#define AVI_DB13              0x80
+#define AVI_DB14              0x81
+#define AVI_DB15              0x82
+
+//Audio info frame
+#define AUD_TYPE			 0x83
+#define AUD_VER			 0x84
+#define AUD_LEN			 0x85
+#define AUD_DB0			 0x86
+#define AUD_DB1			 0x87
+#define AUD_DB2			 0x88
+#define AUD_DB3			 0x89
+#define AUD_DB4			 0x8A
+#define AUD_DB5			 0x8B
+#define AUD_DB6			 0x8C
+#define AUD_DB7			 0x8D
+#define AUD_DB8			 0x8E
+#define AUD_DB9			 0x8F
+#define AUD_DB10			 0x90
+
+//SPD info frame
+#define SPD_TYPE                0x91
+#define SPD_VER                 0x92
+#define SPD_LEN                 0x93
+#define SPD_DATA0		0x94
+#define SPD_DATA1               0x95
+#define SPD_DATA2               0x96
+#define SPD_DATA3               0x97
+#define SPD_DATA4               0x98
+#define SPD_DATA5               0x99
+#define SPD_DATA6               0x9A
+#define SPD_DATA7               0x9B
+#define SPD_DATA8               0x9C
+#define SPD_DATA9               0x9D
+#define SPD_DATA10              0x9E
+#define SPD_DATA11              0x9F
+#define SPD_DATA12              0xA0
+#define SPD_DATA13              0xA1
+#define SPD_DATA14              0xA2
+#define SPD_DATA15              0xA3
+#define SPD_DATA16              0xA4
+#define SPD_DATA17              0xA5
+#define SPD_DATA18              0xA6
+#define SPD_DATA19              0xA7
+#define SPD_DATA20              0xA8
+#define SPD_DATA21              0xA9
+#define SPD_DATA22              0xAA
+#define SPD_DATA23              0xAB
+#define SPD_DATA24              0xAC
+#define SPD_DATA25              0xAD
+#define SPD_DATA26              0xAE
+#define SPD_DATA27              0xAF
+
+//Mpeg source info frame
+#define MPEG_TYPE               0xB0
+#define MPEG_VER                0xB1
+#define MPEG_LEN                0xB2
+#define MPEG_DATA0              0xB3
+#define MPEG_DATA1              0xB4
+#define MPEG_DATA2              0xB5
+#define MPEG_DATA3              0xB6
+#define MPEG_DATA4              0xB7
+#define MPEG_DATA5              0xB8
+#define MPEG_DATA6              0xB9
+#define MPEG_DATA7              0xBA
+#define MPEG_DATA8              0xBB
+#define MPEG_DATA9              0xBC
+#define MPEG_DATA10             0xBD
+#define MPEG_DATA11            0xBE
+#define MPEG_DATA12            0xBF
+#define MPEG_DATA13            0xC0
+#define MPEG_DATA14            0xC1
+#define MPEG_DATA15            0xC2
+#define MPEG_DATA16            0xC3
+#define MPEG_DATA17            0xC4
+#define MPEG_DATA18            0xC5
+#define MPEG_DATA19            0xC6
+#define MPEG_DATA20            0xC7
+#define MPEG_DATA21            0xC8
+#define MPEG_DATA22            0xC9
+#define MPEG_DATA23            0xCA
+#define MPEG_DATA24            0xCB
+#define MPEG_DATA25            0xCC
+#define MPEG_DATA26            0xCD
+#define MPEG_DATA27            0xCE
+
+//#define GNSS_CTRL_REG				0xCD
+//#define ENABLE_SSC_FILTER			0x80//bit 
+
+//#define SSC_D_VALUE					 0xD0
+//#define SSC_CTRL_REG2					 0xD1
+
+#define ANALOG_DEBUG_REG1			0xDC
+#define ANALOG_SEL_BG				0x40//bit 4
+#define ANALOG_SWING_A_30PER		0x08//bit 3
+
+#define ANALOG_DEBUG_REG2			0xDD
+#define ANALOG_24M_SEL				0x08//bit 3
+//#define ANALOG_FILTER_ENABLED		0x10//bit 4
+
+
+#define ANALOG_DEBUG_REG3			0xDE
+
+#define PLL_FILTER_CTRL1			0xDF
+#define PD_RING_OSC					0x40//bit 6
+
+#define PLL_FILTER_CTRL2			0xE0
+#define PLL_FILTER_CTRL3			0xE1
+#define PLL_FILTER_CTRL4			0xE2
+#define PLL_FILTER_CTRL5			0xE3
+#define PLL_FILTER_CTRL6			0xE4
+
+#define I2S_CTRL			0xE6
+#define I2S_FMT			0xE7
+#define I2S_CH_Status1			0xD0
+#define I2S_CH_Status2			0xD1
+#define I2S_CH_Status3			0xD2
+#define I2S_CH_Status4			0xD3
+#define I2S_CH_Status5			0xD4
+
+//interrupt
+#define SP_COMMON_INT_STATUS1     0xF1
+#define SP_COMMON_INT1_PLL_LOCK_CHG 	0x40//bit position
+#define SP_COMMON_INT1_VIDEO_FORMAT_CHG 0x08//bit position
+#define SP_COMMON_INT1_AUDIO_CLK_CHG	0x04//bit position
+#define SP_COMMON_INT1_VIDEO_CLOCK_CHG  0x02//bit position
+
+
+#define SP_COMMON_INT_STATUS2	  0xF2
+#define SP_COMMON_INT2_AUTHCHG	  0x02 //bit position
+#define SP_COMMON_INT2_AUTHDONE	  0x01 //bit position
+
+#define SP_COMMON_INT_STATUS3	  0xF3
+#define SP_COMMON_INT3_AFIFO_UNDER	0x80//bit position
+#define SP_COMMON_INT3_AFIFO_OVER	0x40//bit position
+
+#define SP_COMMON_INT_STATUS4	    0xF4
+#define SP_COMMON_INT4_PLUG                0x01   // bit position
+#define SP_COMMON_INT4_ESYNC_ERR          0x10   // bit position
+#define SP_COMMON_INT4_HPDLOST		0x02   //bit position
+#define SP_COMMON_INT4_HPD_CHANGE   0x04   //bit position
+
+
+#define INT_STATUS1		  0xF7
+#define INT_STATUS1_HPD	  0x40 //bit position
+#define INT_STATUS1_TRAINING_Finish       0x20   // bit position
+#define INT_STATUS1_POLLING_ERR        0x10   // bit position
+
+#define INT_SINK_CHG		  0x08//bit position
+
+
+#define AUX_CH_STA				0xe0
+#define AUX_BUSY				(0x1 << 4)
+#define AUX_STATUS_MASK				(0xf << 0)
+#define DP_AUX_RX_COMM				0xe3
+#define BUF_DATA_CTL				0xe4
+#define BUF_CLR					(0x1 << 7)
+#define DP_AUX_CH_CTL_1				0xe5
+#define AUX_LENGTH(x)				(((x - 1) & 0xf) << 4)
+#define AUX_TX_COMM_MASK			(0xf << 0)
+#define AUX_TX_COMM_DP_TRANSACTION		(0x1 << 3)
+#define AUX_TX_COMM_I2C_TRANSACTION		(0x0 << 3)
+#define AUX_TX_COMM_MOT				(0x1 << 2)
+#define AUX_TX_COMM_WRITE			(0x0 << 0)
+#define AUX_TX_COMM_READ			(0x1 << 0)
+
+#define DP_AUX_ADDR_7_0				0xe6
+#define DP_AUX_ADDR_15_8			0xe7
+#define DP_AUX_ADDR_19_16			0xe8
+
+#define DP_AUX_CH_CTL_2				0xe9
+#define ADDR_ONLY				(0x1 << 1)
+#define AUX_EN					(0x1 << 0)
+
+#define BUF_DATA_0				0xf0
+
+#define DP_INT_STA				0xf7
+#define RPLY_RECEIV				(0x1 << 1)
+#define AUX_ERR					(0x1 << 0)
+#define SP_COMMON_INT_MASK1			0xF8
+#define SP_COMMON_INT_MASK2			0xF9
+#define SP_COMMON_INT_MASK3			0xFA
+#define SP_COMMON_INT_MASK4			0xFB
+#define SP_INT_MASK					  					0xFE
+#define INT_CTRL_REG			0xFF	
+//End for dev_addr 0x72 or 0x76
+
+/***************************************************************/
+/***************************************************************/
+
+
+
+struct  anx6345_platform_data {
+	unsigned int dvdd33_en_pin;
+	int 	     dvdd33_en_val;
+	unsigned int dvdd18_en_pin;
+	int 	     dvdd18_en_val;
+	unsigned int edp_rst_pin;
+	int (*power_ctl)(struct anx6345_platform_data *pdata);
+	bool pwron;
+};
+
+struct edp_anx6345 {
+	struct i2c_client *client;
+	struct anx6345_platform_data *pdata;
+	struct rk_screen screen;
+	struct fb_monspecs specs;	
+	struct dentry *debugfs_dir;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif 
+	int (*edp_anx_init)(struct i2c_client *client);
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/anx9805.h b/drivers/video/rockchip/transmitter/anx9805.h
--- a/drivers/video/rockchip/transmitter/anx9805.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/anx9805.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _DP_ANX9805_H_
+#define _DP_ANX9805_H_
+/**************register define  for anx9805 anx9804********/
+
+#define DP_TX_VND_IDL_REG             	0x00
+#define DP_TX_VND_IDH_REG             	0x01
+#define DP_TX_DEV_IDL_REG             	0x02
+#define DP_TX_DEV_IDH_REG             	0x03
+#define DP_POWERD_CTRL_REG		0x05
+
+#define DP_TX_VID_CTRL1_REG           	0x08
+#define DP_TX_VID_CTRL1_VID_EN     	0x80    // bit position
+#define DP_POWERD_TOTAL_REG		0x02// bit position
+#define DP_POWERD_AUDIO_REG		0x10// bit position
+
+#define DP_TX_RST_CTRL_REG            	0x06
+#define DP_TX_RST_CTRL2_REG		0x07
+#define DP_TX_RST_HW_RST             	0x01    // bit position
+#define DP_TX_AUX_RST					0x04//bit position
+#define DP_TX_RST_SW_RST             	0x02    // bit position
+#define DP_TX_PLL_CTRL_REG		0xC7
+#define DP_TX_EXTRA_ADDR_REG		0xCE
+#define DP_TX_PLL_FILTER_CTRL3		0xE1
+#define DP_TX_PLL_CTRL3					0xE6
+#define DP_TX_AC_MODE					0x40//bit position
+#define ANALOG_DEBUG_REG1				0xDC
+#define ANALOG_DEBUG_REG3				0xDE
+#define DP_TX_PLL_FILTER_CTRL1		 	0xDF
+#define DP_TX_PLL_FILTER_CTRL3			0xE1
+#define DP_TX_PLL_FILTER_CTRL       	0xE2
+#define DP_TX_LINK_DEBUG_REG            0xB8
+#define DP_TX_GNS_CTRL_REG              0xCD
+#define DP_TX_AUX_CTRL_REG2             0xE9
+#define DP_TX_BUF_DATA_COUNT_REG		0xE4
+#define DP_TX_AUX_CTRL_REG              0xE5
+#define DP_TX_AUX_ADDR_7_0_REG          0xE6
+#define DP_TX_AUX_ADDR_15_8_REG         0xE7
+#define DP_TX_AUX_ADDR_19_16_REG        0xE8
+#define DP_TX_BUF_DATA_0_REG            0xf0
+#define DP_TX_SYS_CTRL4_REG			  	0x83
+#define DP_TX_SYS_CTRL4_ENHANCED 	  	0x08//bit position
+#define DP_TX_LINK_BW_SET_REG         	0xA0
+#define DP_TX_LANE_COUNT_SET_REG      	0xA1
+#define DP_TX_LINK_TRAINING_CTRL_REG    0xA8
+#define DP_TX_LINK_TRAINING_CTRL_EN     0x01// bit position
+#define DP_TX_TRAINING_LANE0_SET_REG    0xA3
+#define DP_TX_TRAINING_LANE1_SET_REG    0xA4
+#define DP_TX_TRAINING_LANE2_SET_REG    0xA5
+#define DP_TX_TRAINING_LANE3_SET_REG    0xA6
+#define DP_TX_SYS_CTRL1_REG           	0x80
+#define DP_TX_SYS_CTRL1_DET_STA       	0x04// bit position
+#define DP_TX_SYS_CTRL2_REG           	0x81
+#define DP_TX_SYS_CTRL3_REG           	0x82
+#define DP_TX_SYS_CTRL2_CHA_STA       	0x04// bit position
+#define DP_TX_VID_CTRL2_REG           	0x09
+#define DP_TX_TOTAL_LINEL_REG         	0x12
+#define DP_TX_TOTAL_LINEH_REG         	0x13
+#define DP_TX_ACT_LINEL_REG           	0x14
+#define DP_TX_ACT_LINEH_REG           	0x15
+#define DP_TX_VF_PORCH_REG            	0x16
+#define DP_TX_VSYNC_CFG_REG           	0x17
+#define DP_TX_VB_PORCH_REG            	0x18
+#define DP_TX_TOTAL_PIXELL_REG        	0x19
+#define DP_TX_TOTAL_PIXELH_REG        	0x1A
+#define DP_TX_ACT_PIXELL_REG          	0x1B
+#define DP_TX_ACT_PIXELH_REG          	0x1C
+#define DP_TX_HF_PORCHL_REG           	0x1D
+#define DP_TX_HF_PORCHH_REG           	0x1E
+#define DP_TX_HSYNC_CFGL_REG          	0x1F
+#define DP_TX_HSYNC_CFGH_REG          	0x20
+#define DP_TX_HB_PORCHL_REG           	0x21
+#define DP_TX_HB_PORCHH_REG           	0x22
+#define DP_TX_VID_CTRL10_REG           	0x11
+#define DP_TX_VID_CTRL4_REG           	0x0B
+#define DP_TX_VID_CTRL4_E_SYNC_EN	  	0x80//bit position
+#define DP_TX_VID_CTRL10_I_SCAN        	0x04// bit position
+#define DP_TX_VID_CTRL10_VSYNC_POL   	0x02// bit position
+#define DP_TX_VID_CTRL10_HSYNC_POL   	0x01// bit position
+#define DP_TX_VID_CTRL4_BIST_WIDTH   	0x04// bit position
+#define DP_TX_VID_CTRL4_BIST          	0x08// bit position
+
+
+typedef enum
+{
+    COLOR_6,
+    COLOR_8,
+    COLOR_10,
+    COLOR_12
+}VIP_COLOR_DEPTH;
+
+struct rk_edp_platform_data {
+	unsigned int dvdd33_en_pin;
+	int 	     dvdd33_en_val;
+	unsigned int dvdd18_en_pin;
+	int 	     dvdd18_en_val;
+	unsigned int edp_rst_pin;
+	int (*power_ctl)(void);
+};
+
+struct rk_edp {
+	struct i2c_client *client;
+	struct rk_edp_platform_data *pdata;
+	struct rk_screen screen;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif 
+};
+
+#endif
+
+
+
+
diff -Nupr a/drivers/video/rockchip/transmitter/dp501.c b/drivers/video/rockchip/transmitter/dp501.c
--- a/drivers/video/rockchip/transmitter/dp501.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/dp501.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,295 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/dp501.h>
+#include <linux/debugfs.h>
+
+
+
+static int dp501_write_reg(struct i2c_client *client,char index,char reg,char val)
+{
+	int ret;
+	if(index == 0)  //page 0
+	{
+		client->addr = (DP501_P0_ADDR >> 1);
+	}
+	else if(index == 1) //page1
+	{
+		client->addr = (DP501_P1_ADDR >> 1);
+	}
+	else if(index == 2) //page 2
+	{
+		client->addr = (DP501_P2_ADDR >> 1);
+	}
+	else if(index == 3)
+	{
+		client->addr = (DP501_P3_ADDR >> 1);
+	}
+	else
+	{
+		dev_err(&client->dev,"invalid page number\n");
+		return -EINVAL;
+	}
+	ret = i2c_master_reg8_send(client, reg, &val, 1,DP501_SCL_RATE);
+	if(ret < 0)
+	{
+		
+		dev_err(&client->dev,"%s page%d:0x%x err\n",__func__,index,reg);
+		ret = -EINVAL;
+	}
+
+	return ret;
+	
+}
+
+static char dp501_read_reg(struct i2c_client *client,char index,char reg)
+{
+	int ret;
+	char val;
+	if(index == 0)  //page 0
+	{
+		client->addr = (DP501_P0_ADDR >> 1);
+	}
+	else if(index == 1) //page1
+	{
+		client->addr = (DP501_P1_ADDR>>1);
+	}
+	else if(index == 2) //page 2
+	{
+		client->addr = (DP501_P2_ADDR>>1);
+	}
+	else if(index == 3)
+	{
+		client->addr = (DP501_P3_ADDR>>1);
+	}
+	else
+	{
+		dev_err(&client->dev,"invalid page number\n");
+		return -EINVAL;
+	}
+
+	
+	ret = i2c_master_reg8_recv(client, reg, &val, 1, DP501_SCL_RATE);
+	if(ret < 0)
+	{
+		dev_err(&client->dev,"%s page%d:0x%x err\n",__func__,index,reg);
+		return  -EINVAL;
+	}
+
+	return val;
+	
+}
+static int get_dp_chip_id(struct i2c_client *client)
+{
+	char c1,c2;
+	int id;
+	c1 = dp501_read_reg(client,2,CHIP_ID_L);
+    	c2 = dp501_read_reg(client,2,CHIP_ID_H);
+	id = c2;
+	return (id<<8)|c1;
+	return 0;
+}
+
+static int dp501_init(struct i2c_client *client)
+{
+	char val,val1;
+
+	dp501_write_reg(client,2,0x00,0x6C);
+	dp501_write_reg(client,2,0x01,0x68);
+	dp501_write_reg(client,2,0x02,0x28);
+	dp501_write_reg(client,2,0x03,0x2A);
+	dp501_write_reg(client,2,0x16,0x50);
+	dp501_write_reg(client,2,0x24,0x22);
+	dp501_write_reg(client,2,0x25,0x04);
+	dp501_write_reg(client,2,0x26,0x10); //PIO setting
+	
+	dp501_write_reg(client,0,0x0a,0x0c); //block 74 & 76
+	dp501_write_reg(client,0,0x20,0x00); 
+	dp501_write_reg(client,0,0x27,0x30); //auto detect CRTC 
+	dp501_write_reg(client,0,0x2f,0x82); //reset tpfifo at v blank 
+	dp501_write_reg(client,0,0x24,0xc0); //DVO mapping ; crtc follow mode
+	dp501_write_reg(client,0,0x28,0x07); //crtc follow mode
+	dp501_write_reg(client,0,0x87,0x7f); //aux retry
+	dp501_write_reg(client,0,0x88,0x1e); //aux retry
+	dp501_write_reg(client,0,0xbb,0x06); //aux retry
+	dp501_write_reg(client,0,0x72,0xa9); //DPCD readable
+	dp501_write_reg(client,0,0x60,0x00); //Scramble on
+	dp501_write_reg(client,0,0x8f,0x02); //debug select, read P0.0x8d[2] can check HPD
+
+
+	//second, set up training
+	dp501_write_reg(client,0,0x5d,0x06); //training link rate(2.7Gbps)
+	dp501_write_reg(client,0,0x5e,0x84); //training lane count(4Lanes),
+	dp501_write_reg(client,0,0x74,0x00); //idle pattern
+	dp501_write_reg(client,0,0x5f,0x0d); //trigger training
+	mdelay(100); //delay 100ms
+
+	//then, check training result
+	val = dp501_read_reg(client,0,0x63); 
+	val1 = dp501_read_reg(client,0,0x64); //Each 4bits stand for one lane, 0x77/0x77 means training succeed with 4Lanes.
+	dev_info(&client->dev,"training result:>>val:0x%x>>val1:0x%x\n",val,val1);
+	
+	return 0;
+}
+
+
+
+static int edp_reg_show(struct seq_file *s, void *v)
+{
+	int i = 0;
+	char val;
+	struct  dp501 *dp501= s->private;
+
+	seq_printf(s,"page 0:\n");
+	for(i=0;i< MAX_REG;i++)
+	{
+		val = dp501_read_reg(dp501->client,0,i);
+		seq_printf(s,"0x%02x>>0x%02x\n",i,val);
+	}
+
+	seq_printf(s,"page 1:\n");
+	for(i=0;i< MAX_REG;i++)
+	{
+		val = dp501_read_reg(dp501->client,1,i);
+		seq_printf(s,"0x%02x>>0x%02x\n",i,val);
+	}
+
+	seq_printf(s,"page 2:\n");
+	for(i=0;i< MAX_REG;i++)
+	{
+		val = dp501_read_reg(dp501->client,0,i);
+		seq_printf(s,"0x%02x>>0x%02x\n",2,val);
+	}
+
+	seq_printf(s,"page 3:\n");
+	for(i=0;i< MAX_REG;i++)
+	{
+		val = dp501_read_reg(dp501->client,3,i);
+		seq_printf(s,"0x%02x>>0x%02x\n",i,val);
+	}
+	
+	return 0;
+}
+
+static int edp_reg_open(struct inode *inode, struct file *file)
+{
+	struct dp501 *dp501 = inode->i_private;
+	return single_open(file,edp_reg_show,dp501);
+}
+
+static const struct file_operations edp_reg_fops = {
+	.owner		= THIS_MODULE,
+	.open		= edp_reg_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void dp501_early_suspend(struct early_suspend *h)
+{
+	struct dp501 *dp501 = container_of(h, struct dp501, early_suspend);
+	gpio_set_value(dp501->pdata->dvdd33_en_pin,!dp501->pdata->dvdd33_en_val);
+	gpio_set_value(dp501->pdata->dvdd18_en_pin,!dp501->pdata->dvdd18_en_val);
+	
+}
+
+static void dp501_late_resume(struct early_suspend *h)
+{
+	struct dp501 *dp501 = container_of(h, struct dp501, early_suspend);
+	gpio_set_value(dp501->pdata->dvdd33_en_pin,dp501->pdata->dvdd33_en_val);
+	gpio_set_value(dp501->pdata->dvdd18_en_pin,dp501->pdata->dvdd18_en_val);
+	gpio_set_value(dp501->pdata->edp_rst_pin,0);
+	msleep(10);
+	gpio_set_value(dp501->pdata->edp_rst_pin,1);
+	dp501->edp_init(dp501->client);
+}
+#endif
+static int dp501_i2c_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{
+	int ret;
+	
+	struct dp501 *dp501 = NULL;
+	int chip_id;
+
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
+	{
+		dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+		ret = -ENODEV;
+	}
+	dp501 = kzalloc(sizeof(struct dp501), GFP_KERNEL);
+	if (dp501 == NULL)
+	{
+		dev_err(&client->dev,"alloc for struct dp501 fail\n");
+		ret = -ENOMEM;
+	}
+
+	dp501->client = client;
+	dp501->pdata = client->dev.platform_data;
+	i2c_set_clientdata(client,dp501);
+	if(dp501->pdata->power_ctl)
+		dp501->pdata->power_ctl();
+
+	debugfs_create_file("edp-reg", S_IRUSR,NULL,dp501,&edp_reg_fops);
+	
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	dp501->early_suspend.suspend = dp501_early_suspend;
+	dp501->early_suspend.resume = dp501_late_resume;
+    	dp501->early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING;
+	register_early_suspend(&dp501->early_suspend);
+#endif
+
+	chip_id = get_dp_chip_id(client);
+	dp501->edp_init = dp501_init;
+	dp501->edp_init(client);
+
+
+	printk("edp dp%x probe ok\n",chip_id);
+
+	return ret;
+}
+
+static int __devexit dp501_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+
+static const struct i2c_device_id id_table[] = {
+	{"dp501", 0 },
+	{ }
+};
+
+static struct i2c_driver dp501_i2c_driver  = {
+	.driver = {
+		.name  = "dp501",
+		.owner = THIS_MODULE,
+	},
+	.probe		= &dp501_i2c_probe,
+	.remove     	= &dp501_i2c_remove,
+	.id_table	= id_table,
+};
+
+
+static int __init dp501_module_init(void)
+{
+	return i2c_add_driver(&dp501_i2c_driver);
+}
+
+static void __exit dp501_module_exit(void)
+{
+	i2c_del_driver(&dp501_i2c_driver);
+}
+
+fs_initcall_sync(dp501_module_init);
+module_exit(dp501_module_exit);
+
diff -Nupr a/drivers/video/rockchip/transmitter/dp_anx6345.c b/drivers/video/rockchip/transmitter/dp_anx6345.c
--- a/drivers/video/rockchip/transmitter/dp_anx6345.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/dp_anx6345.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1425 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+#include<linux/earlysuspend.h>
+#endif
+#if defined(CONFIG_OF)
+#include <linux/of_gpio.h>
+#endif
+#include "anx6345.h"
+#include "dpcd_edid.h"
+#if defined(CONFIG_DEBUG_FS)
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#endif
+
+
+static struct edp_anx6345 *edp;
+//#define BIST_MODE 0
+static int i2c_master_reg8_send(const struct i2c_client *client,
+		const char reg, const char *buf, int count, int scl_rate)
+{
+        struct i2c_adapter *adap=client->adapter;
+        struct i2c_msg msg;
+        int ret;
+        char *tx_buf = (char *)kmalloc(count + 1, GFP_KERNEL);
+        if(!tx_buf)
+                return -ENOMEM;
+        tx_buf[0] = reg;
+        memcpy(tx_buf+1, buf, count);
+
+        msg.addr = client->addr;
+        msg.flags = client->flags;
+        msg.len = count + 1;
+        msg.buf = (char *)tx_buf;
+        msg.scl_rate = scl_rate;
+
+        ret = i2c_transfer(adap, &msg, 1);
+        kfree(tx_buf);
+        return (ret == 1) ? count : ret;
+
+}
+
+static int i2c_master_reg8_recv(const struct i2c_client *client,
+		const char reg, char *buf, int count, int scl_rate)
+{
+        struct i2c_adapter *adap=client->adapter;
+        struct i2c_msg msgs[2];
+        int ret;
+        char reg_buf = reg;
+
+        msgs[0].addr = client->addr;
+        msgs[0].flags = client->flags;
+        msgs[0].len = 1;
+        msgs[0].buf = &reg_buf;
+        msgs[0].scl_rate = scl_rate;
+
+        msgs[1].addr = client->addr;
+        msgs[1].flags = client->flags | I2C_M_RD;
+        msgs[1].len = count;
+        msgs[1].buf = (char *)buf;
+        msgs[1].scl_rate = scl_rate;
+
+        ret = i2c_transfer(adap, msgs, 2);
+
+        return (ret == 2)? count : ret;
+}
+
+static int anx6345_i2c_read_p0_reg(struct i2c_client *client, char reg, char *val)
+{
+	int ret;
+	client->addr = DP_TX_PORT0_ADDR >> 1;
+	ret = i2c_master_reg8_recv(client, reg, val, 1, ANX6345_SCL_RATE) > 0? 0: -EINVAL;
+	if(ret < 0)
+	{
+		printk(KERN_ERR "%s>>err\n",__func__);
+	}
+
+	return ret;
+}
+static int  anx6345_i2c_write_p0_reg(struct i2c_client *client, char reg, char *val)
+{
+	int ret;
+	client->addr = DP_TX_PORT0_ADDR >> 1;
+	ret = i2c_master_reg8_send(client, reg, val, 1, ANX6345_SCL_RATE) > 0? 0: -EINVAL;
+	if(ret < 0)
+	{
+		printk(KERN_ERR "%s>>err\n",__func__);
+	}
+
+	return ret;
+}
+static int anx6345_i2c_read_p1_reg(struct i2c_client *client, char reg, char *val)
+{
+	int ret;
+	client->addr = HDMI_TX_PORT0_ADDR >> 1;
+	ret = i2c_master_reg8_recv(client, reg, val, 1, ANX6345_SCL_RATE) > 0? 0: -EINVAL;
+	if(ret < 0)
+	{
+		printk(KERN_ERR "%s>>err\n",__func__);
+	}
+
+	return ret;
+}
+
+static int anx6345_i2c_write_p1_reg(struct i2c_client *client, char reg, char *val)
+{
+	int ret;
+	client->addr = HDMI_TX_PORT0_ADDR >> 1;
+	ret = i2c_master_reg8_send(client, reg, val, 1, ANX6345_SCL_RATE) > 0? 0: -EINVAL;
+	if(ret < 0)
+	{
+		printk(KERN_ERR "%s>>err\n",__func__);
+	}
+
+	return ret;
+}
+
+#if defined(CONFIG_DEBUG_FS)
+static int edp_reg_show(struct seq_file *s, void *v)
+{
+	int i = 0;
+	char val;
+	struct edp_anx6345 *anx6345 = s->private;
+	if(!anx6345)
+	{
+		printk(KERN_ERR "no edp device!\n");
+		return 0;
+	}
+	
+	seq_printf(s,"0x70:\n");
+	for(i=0;i< MAX_REG;i++)
+	{
+		anx6345_i2c_read_p0_reg(anx6345->client, i , &val);
+		seq_printf(s,"0x%02x>>0x%02x\n",i,val);
+	}
+	
+	seq_printf(s,"\n0x72:\n");
+	for(i=0;i< MAX_REG;i++)
+	{
+		anx6345_i2c_read_p1_reg(anx6345->client, i , &val);
+		seq_printf(s,"0x%02x>>0x%02x\n",i,val);
+	}
+	return 0;
+}
+
+static int edp_reg_open(struct inode *inode, struct file *file)
+{
+	struct edp_anx6345 *anx6345 = inode->i_private;
+	return single_open(file, edp_reg_show, anx6345);
+}
+
+static const struct file_operations edp_reg_fops = {
+	.owner		= THIS_MODULE,
+	.open		= edp_reg_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+#endif
+
+//get chip ID. Make sure I2C is OK
+static int get_dp_chip_id(struct i2c_client *client)
+{
+	char c1,c2;
+	int id;
+	anx6345_i2c_read_p1_reg(client,DEV_IDL_REG,&c1);
+    	anx6345_i2c_read_p1_reg(client,DEV_IDH_REG,&c2);
+	id = c2;
+	return (id<<8)|c1;
+}
+
+#if defined(BIST_MODE)
+static int anx980x_bist_mode(struct i2c_client *client)
+{
+	char val,i;
+	u8 cnt=0;
+
+	//Power on total and select DP mode
+	val = 00;
+        anx6345_i2c_write_p1_reg(client, DP_POWERD_CTRL_REG, &val);
+	
+	//HW reset
+	val = DP_TX_RST_HW_RST;
+	anx6345_i2c_write_p1_reg(client, DP_TX_RST_CTRL_REG, &val);
+	msleep(10);
+	val = 0x00;
+	anx6345_i2c_write_p1_reg(client, DP_TX_RST_CTRL_REG, &val);
+
+
+	anx6345_i2c_read_p1_reg(client, DP_POWERD_CTRL_REG, &val);
+	val = 0x00;
+        anx6345_i2c_write_p1_reg(client, DP_POWERD_CTRL_REG, &val);
+	
+	
+	//get chip ID. Make sure I2C is OK
+	anx6345_i2c_read_p1_reg(client, DP_TX_DEV_IDH_REG , &val);
+	if (val==0x98)
+		printk("Chip found\n");	
+
+	//for clocl detect
+	for(i=0;i<100;i++)
+	{
+		anx6345_i2c_read_p0_reg(client, DP_TX_SYS_CTRL1_REG, &val);
+		anx6345_i2c_write_p0_reg(client, DP_TX_SYS_CTRL1_REG, &val);
+		anx6345_i2c_read_p0_reg(client, DP_TX_SYS_CTRL1_REG, &val);
+		if((val&DP_TX_SYS_CTRL1_DET_STA)!=0)
+		{
+			printk("clock is detected.\n");
+			break;
+		}
+
+		msleep(10);
+	}
+       //check whther clock is stable
+	for(i=0;i<50;i++)
+	{
+		anx6345_i2c_read_p0_reg(client, DP_TX_SYS_CTRL2_REG, &val);
+		anx6345_i2c_write_p0_reg(client, DP_TX_SYS_CTRL2_REG, &val);
+		anx6345_i2c_read_p0_reg(client, DP_TX_SYS_CTRL2_REG, &val);
+		if((val&DP_TX_SYS_CTRL2_CHA_STA)==0)
+		{
+			printk("clock is stable.\n");
+			break;
+		}
+		msleep(10);
+	}
+
+	//VESA range, 8bits BPC, RGB 
+	val = 0x10;
+	anx6345_i2c_write_p1_reg(client, DP_TX_VID_CTRL2_REG, &val);
+	//RK_EDP chip analog setting
+	val = 0x07;
+	anx6345_i2c_write_p0_reg(client, DP_TX_PLL_CTRL_REG, &val); 
+	val = 0x19;
+	anx6345_i2c_write_p1_reg(client, DP_TX_PLL_FILTER_CTRL3, &val); 
+	val = 0xd9;
+	anx6345_i2c_write_p1_reg(client, DP_TX_PLL_CTRL3, &val); 
+	
+	//Select AC mode
+	val = 0x40;
+	anx6345_i2c_write_p1_reg(client, DP_TX_RST_CTRL2_REG, &val); 
+
+	//RK_EDP chip analog setting
+	val = 0xf0;
+	anx6345_i2c_write_p1_reg(client, ANALOG_DEBUG_REG1, &val);
+	val = 0x99;
+	anx6345_i2c_write_p1_reg(client, ANALOG_DEBUG_REG3, &val);
+	val = 0x7b;
+	anx6345_i2c_write_p1_reg(client, DP_TX_PLL_FILTER_CTRL1, &val);
+	val = 0x30;
+	anx6345_i2c_write_p0_reg(client, DP_TX_LINK_DEBUG_REG,&val);
+	val = 0x06;
+	anx6345_i2c_write_p1_reg(client, DP_TX_PLL_FILTER_CTRL, &val);
+	
+	//force HPD
+	val = 0x30;
+	anx6345_i2c_write_p0_reg(client, DP_TX_SYS_CTRL3_REG, &val);
+	//power on 4 lanes
+	val = 0x00;
+	anx6345_i2c_write_p0_reg(client, 0xc8, &val);
+	//lanes setting
+	anx6345_i2c_write_p0_reg(client, 0xa3, &val);
+	anx6345_i2c_write_p0_reg(client, 0xa4, &val);
+	anx6345_i2c_write_p0_reg(client, 0xa5,&val);
+	anx6345_i2c_write_p0_reg(client, 0xa6, &val);
+
+	//reset AUX CH
+	val = 0x44;
+	anx6345_i2c_write_p1_reg(client,  DP_TX_RST_CTRL2_REG, &val);
+	val = 0x40;
+	anx6345_i2c_write_p1_reg(client,  DP_TX_RST_CTRL2_REG, &val);
+
+	//Select 1.62G
+	val = 0x06;
+	anx6345_i2c_write_p0_reg(client, DP_TX_LINK_BW_SET_REG, &val);
+	//Select 4 lanes
+	val = 0x04;
+	anx6345_i2c_write_p0_reg(client, DP_TX_LANE_COUNT_SET_REG, &val);
+	
+	//strart link traing
+	//DP_TX_LINK_TRAINING_CTRL_EN is self clear. If link training is OK, it will self cleared.
+	#if 1
+	val = DP_TX_LINK_TRAINING_CTRL_EN;
+	anx6345_i2c_write_p0_reg(client, DP_TX_LINK_TRAINING_CTRL_REG, &val);
+	msleep(5);
+	anx6345_i2c_read_p0_reg(client, DP_TX_LINK_TRAINING_CTRL_REG, &val);
+	while((val&0x01)&&(cnt++ < 10))
+	{
+		printk("Waiting...\n");
+		msleep(5);
+		anx6345_i2c_read_p0_reg(client, DP_TX_LINK_TRAINING_CTRL_REG, &val);
+	}
+
+	if(cnt >= 10)
+	{
+		printk(KERN_INFO "HW LT fail\n");
+	}
+	else
+	{
+		printk(KERN_INFO "HW LT success ...cnt:%d\n",cnt);
+	}
+	#else
+	DP_TX_HW_LT(client,0x0a,0x04); //2.7Gpbs 4lane
+	#endif
+	//DP_TX_Write_Reg(0x7a, 0x7c, 0x02);  	
+	
+	//Set bist format 2048x1536
+	val = 0x2c;
+	anx6345_i2c_write_p1_reg(client, DP_TX_TOTAL_LINEL_REG, &val);
+	val = 0x06;
+	anx6345_i2c_write_p1_reg(client, DP_TX_TOTAL_LINEH_REG, &val);
+
+	val = 0x00;
+	anx6345_i2c_write_p1_reg(client, DP_TX_ACT_LINEL_REG, &val);
+	val = 0x06;
+	anx6345_i2c_write_p1_reg(client, DP_TX_ACT_LINEH_REG,&val);
+	val = 0x02;
+	anx6345_i2c_write_p1_reg(client, DP_TX_VF_PORCH_REG, &val);
+	val = 0x04;
+	anx6345_i2c_write_p1_reg(client, DP_TX_VSYNC_CFG_REG,&val);
+	val = 0x26;
+	anx6345_i2c_write_p1_reg(client, DP_TX_VB_PORCH_REG, &val);
+	val = 0x50;
+	anx6345_i2c_write_p1_reg(client, DP_TX_TOTAL_PIXELL_REG, &val);
+	val = 0x04;
+	anx6345_i2c_write_p1_reg(client, DP_TX_TOTAL_PIXELH_REG, &val);
+	val = 0x00;
+	anx6345_i2c_write_p1_reg(client, DP_TX_ACT_PIXELL_REG, &val);
+	val = 0x04;
+	anx6345_i2c_write_p1_reg(client, DP_TX_ACT_PIXELH_REG, &val);
+
+	val = 0x18;
+	anx6345_i2c_write_p1_reg(client, DP_TX_HF_PORCHL_REG, &val);
+	val = 0x00;
+	anx6345_i2c_write_p1_reg(client, DP_TX_HF_PORCHH_REG, &val);
+
+	val = 0x10;
+	anx6345_i2c_write_p1_reg(client, DP_TX_HSYNC_CFGL_REG,&val);
+	val = 0x00;
+	anx6345_i2c_write_p1_reg(client, DP_TX_HSYNC_CFGH_REG,&val);
+	val = 0x28;
+	anx6345_i2c_write_p1_reg(client, DP_TX_HB_PORCHL_REG, &val);
+	val = 0x00;
+	anx6345_i2c_write_p1_reg(client, DP_TX_HB_PORCHH_REG, &val);
+	val = 0x03;
+	anx6345_i2c_write_p1_reg(client, DP_TX_VID_CTRL10_REG, &val);
+
+	//enable BIST
+	val = DP_TX_VID_CTRL4_BIST;
+	anx6345_i2c_write_p1_reg(client, DP_TX_VID_CTRL4_REG, &val);
+	//enable video input
+	val = 0x8d;
+	anx6345_i2c_write_p1_reg(client, DP_TX_VID_CTRL1_REG, &val);
+	//force HPD and stream valid
+	val = 0x33;
+	anx6345_i2c_write_p0_reg(client, 0x82, &val);
+
+	return 0;
+}
+#endif
+static int anx980x_aux_rst(struct i2c_client *client)
+{
+	char val;
+	anx6345_i2c_read_p1_reg(client, DP_TX_RST_CTRL2_REG, &val);
+	val |= DP_TX_AUX_RST;
+    	anx6345_i2c_write_p1_reg(client, DP_TX_RST_CTRL2_REG, &val);
+	val &= ~DP_TX_AUX_RST;
+    	anx6345_i2c_write_p1_reg(client, DP_TX_RST_CTRL2_REG, &val);
+	return 0;
+}
+
+
+static int anx980x_wait_aux_finished(struct i2c_client *client)
+{
+	char val,cnt;
+	cnt = 0;
+	
+	anx6345_i2c_read_p0_reg(client,DP_TX_AUX_CTRL_REG2, &val);
+	while(val&0x01)
+	{
+		//delay_ms(20);
+		cnt ++;
+		if(cnt == 10)
+		{
+		   printk("aux break");
+		    anx980x_aux_rst(client);
+		    //cnt = 0;
+		    break;
+		}
+		anx6345_i2c_read_p0_reg(client, DP_TX_AUX_CTRL_REG2, &val);
+	}
+
+	return 0;
+}
+
+static int anx980x_aux_dpcdread_bytes(struct i2c_client *client,unsigned long addr, char cCount,char* pBuf)
+{
+	char val,i;
+	
+	val = 0x80;
+	anx6345_i2c_write_p0_reg(client, DP_TX_BUF_DATA_COUNT_REG, &val);
+
+	//set read cmd and count
+	val = (((char)(cCount-1) <<4)&(0xf0))|0x09;
+	anx6345_i2c_write_p0_reg(client, DP_TX_AUX_CTRL_REG, &val);
+
+	//set aux address15:0
+	val = (char)addr&0xff;
+	anx6345_i2c_write_p0_reg(client, DP_TX_AUX_ADDR_7_0_REG, &val);
+	val = (char)((addr>>8)&0xff);
+	anx6345_i2c_write_p0_reg(client, DP_TX_AUX_ADDR_15_8_REG, &val);
+
+	//set address19:16 and enable aux
+	anx6345_i2c_read_p0_reg(client, DP_TX_AUX_ADDR_19_16_REG, &val);
+	val &=(0xf0)|(char)((addr>>16)&0xff);
+	anx6345_i2c_write_p0_reg(client, DP_TX_AUX_ADDR_19_16_REG, &val);
+
+	//Enable Aux
+	anx6345_i2c_read_p0_reg(client, DP_TX_AUX_CTRL_REG2, &val);
+	val |= 0x01;
+	anx6345_i2c_write_p0_reg(client, DP_TX_AUX_CTRL_REG2, &val);
+
+	//delay_ms(2);
+	anx980x_wait_aux_finished(client);
+
+	for(i =0;i<cCount;i++)
+	{
+		anx6345_i2c_read_p0_reg(client, DP_TX_BUF_DATA_0_REG+i, &val);
+
+		//debug_printf("c = %.2x\n",(WORD)c);
+		*(pBuf+i) = val;
+
+		if(i >= MAX_BUF_CNT)
+			return 1;
+			//break;
+	}
+
+	return 0;
+	
+
+}
+
+static int anx_video_map_config(struct i2c_client *client)
+{
+	char val = 0;
+ 	char i = 0;
+	anx6345_i2c_write_p1_reg(client,  0x40, &val);
+	anx6345_i2c_write_p1_reg(client,  0x41, &val);
+	anx6345_i2c_write_p1_reg(client,  0x48, &val);
+	anx6345_i2c_write_p1_reg(client,  0x49, &val);
+	anx6345_i2c_write_p1_reg(client,  0x50, &val);
+	anx6345_i2c_write_p1_reg(client,  0x51, &val);
+	for(i=0; i<6; i++)
+	{    
+		val = i;
+		anx6345_i2c_write_p1_reg(client,  0x42+i, &val);
+	}
+
+	for(i=0; i<6; i++)
+	{    
+		val = 6+i;
+		anx6345_i2c_write_p1_reg(client,  0x4a+i, &val);
+	}
+
+	for(i=0; i<6; i++)
+	{    
+		val = 0x0c+i;
+		anx6345_i2c_write_p1_reg(client,  0x52+i, &val);
+	}
+
+	return 0;
+			
+}
+static int anx980x_eanble_video_input(struct i2c_client *client)
+{
+	char val;
+
+	anx6345_i2c_read_p1_reg(client,  DP_TX_VID_CTRL1_REG, &val);
+	val |= DP_TX_VID_CTRL1_VID_EN;
+	anx6345_i2c_write_p1_reg(client,  DP_TX_VID_CTRL1_REG, &val);
+	
+	anx_video_map_config(client);
+	
+	return 0;
+}
+
+static int anx980x_init(struct i2c_client *client)
+{
+	char val = 0x00;
+	char safe_mode = 0;
+	char ByteBuf[2];
+	char dp_tx_bw,dp_tx_lane_count;
+	char cnt = 10;
+
+#if defined(BIST_MODE)
+	return anx980x_bist_mode(client);
+#endif
+	 //power on all block and select DisplayPort mode
+	val |= DP_POWERD_AUDIO_REG;
+	anx6345_i2c_write_p1_reg(client, DP_POWERD_CTRL_REG, &val );
+
+	anx6345_i2c_read_p1_reg(client, DP_TX_VID_CTRL1_REG, &val);
+	val &= ~DP_TX_VID_CTRL1_VID_EN;
+ 	anx6345_i2c_read_p1_reg(client, DP_TX_VID_CTRL1_REG, &val);
+
+	//software reset    
+	anx6345_i2c_read_p1_reg(client, DP_TX_RST_CTRL_REG, &val);
+	val |= DP_TX_RST_SW_RST;
+	anx6345_i2c_write_p1_reg(client, DP_TX_RST_CTRL_REG,&val);
+	val &= ~DP_TX_RST_SW_RST;
+	anx6345_i2c_write_p1_reg(client, DP_TX_RST_CTRL_REG, &val);
+
+	
+	val = 0x07;
+	anx6345_i2c_write_p0_reg(client, DP_TX_PLL_CTRL_REG, &val);
+	val = 0x50;
+	anx6345_i2c_write_p0_reg(client, DP_TX_EXTRA_ADDR_REG, &val);
+	
+	//24bit SDR,negedge latch, and wait video stable
+	val = 0x01;
+	anx6345_i2c_write_p1_reg(client, DP_TX_VID_CTRL1_REG, &val);//72:08 for 9804 SDR, neg edge 05/04/09 extra pxl
+	val = 0x19;
+	anx6345_i2c_write_p1_reg(client, DP_TX_PLL_FILTER_CTRL3, &val); 
+	val = 0xd9;
+	anx6345_i2c_write_p1_reg(client, DP_TX_PLL_CTRL3, &val);
+
+	//serdes ac mode.
+	anx6345_i2c_read_p1_reg(client, DP_TX_RST_CTRL2_REG, &val);
+	val |= DP_TX_AC_MODE;
+	anx6345_i2c_write_p1_reg(client, DP_TX_RST_CTRL2_REG, &val);
+
+	//set termination
+	val = 0xf0;
+	anx6345_i2c_write_p1_reg(client, ANALOG_DEBUG_REG1, &val);
+	//set duty cycle
+	val = 0x99;
+	anx6345_i2c_write_p1_reg(client, ANALOG_DEBUG_REG3, &val);
+
+	anx6345_i2c_read_p1_reg(client, DP_TX_PLL_FILTER_CTRL1, &val);
+	val |= 0x2a; 
+	anx6345_i2c_write_p1_reg(client, DP_TX_PLL_FILTER_CTRL1, &val);
+
+	//anx6345_i2c_write_p0_reg(client, DP_TX_HDCP_CTRL, 0x01);
+	val = 0x30;
+	anx6345_i2c_write_p0_reg(client, DP_TX_LINK_DEBUG_REG,&val);
+
+	//for DP link CTS 
+	anx6345_i2c_read_p0_reg(client, DP_TX_GNS_CTRL_REG, &val);
+	val |= 0x40;
+	anx6345_i2c_write_p0_reg(client, DP_TX_GNS_CTRL_REG, &val);
+
+	//power down  PLL filter
+	val = 0x06;
+	anx6345_i2c_write_p1_reg(client, DP_TX_PLL_FILTER_CTRL,&val);
+	
+	anx6345_i2c_write_p0_reg(client, DP_TX_TRAINING_LANE0_SET_REG, &val);
+	anx6345_i2c_write_p0_reg(client, DP_TX_TRAINING_LANE1_SET_REG, &val);
+	anx6345_i2c_write_p0_reg(client, DP_TX_TRAINING_LANE2_SET_REG, &val);
+	anx6345_i2c_write_p0_reg(client, DP_TX_TRAINING_LANE3_SET_REG, &val);
+
+	val = 0x06;
+	anx6345_i2c_write_p0_reg(client, DP_TX_LINK_BW_SET_REG, &val);
+	val = 0x04;
+	anx6345_i2c_write_p0_reg(client, DP_TX_LANE_COUNT_SET_REG, &val);
+	
+	val = DP_TX_LINK_TRAINING_CTRL_EN;
+	anx6345_i2c_write_p0_reg(client, DP_TX_LINK_TRAINING_CTRL_REG,&val);
+	msleep(2);
+	anx6345_i2c_read_p0_reg(client, DP_TX_LINK_TRAINING_CTRL_REG, &val);
+	while((val & DP_TX_LINK_TRAINING_CTRL_EN)&&(cnt--))
+	{
+		anx6345_i2c_read_p0_reg(client, DP_TX_LINK_TRAINING_CTRL_REG, &val);
+		cnt--;
+	}
+	if(cnt < 0)
+	{
+		printk(KERN_INFO "HW LT fail\n");
+	}
+	else
+		printk(KERN_INFO "HW LT Success!>>:times:%d\n",(11-cnt));
+	//DP_TX_Config_Video(client);
+	anx6345_i2c_write_p0_reg(client, DP_TX_SYS_CTRL1_REG, &val);
+	anx6345_i2c_read_p0_reg(client,  DP_TX_SYS_CTRL1_REG, &val);
+	if(!(val & DP_TX_SYS_CTRL1_DET_STA))
+	{
+		printk("No pclk\n");
+		//return;  //mask by yxj
+	}
+
+	anx6345_i2c_read_p0_reg(client,  DP_TX_SYS_CTRL2_REG, &val);
+	anx6345_i2c_write_p0_reg(client,  DP_TX_SYS_CTRL2_REG, &val);
+	anx6345_i2c_read_p0_reg(client,  DP_TX_SYS_CTRL2_REG, &val);
+	if(val & DP_TX_SYS_CTRL2_CHA_STA)
+	{
+		printk("pclk not stable!\n");
+		//return; mask by yxj
+	}
+
+	anx980x_aux_dpcdread_bytes(client,(unsigned long)0x00001,2,ByteBuf);
+	dp_tx_bw = ByteBuf[0];
+	dp_tx_lane_count = ByteBuf[1] & 0x0f;
+	printk("%s..lc:%d--bw:%d\n",__func__,dp_tx_lane_count,dp_tx_bw);
+	
+	if(!safe_mode)
+	{
+		//set Input BPC mode & color space
+		anx6345_i2c_read_p1_reg(client,  DP_TX_VID_CTRL2_REG, &val);
+		val &= 0x8c;
+		val = val |((char)(0) << 4);  //8bits  ,rgb
+		anx6345_i2c_write_p1_reg(client,  DP_TX_VID_CTRL2_REG, &val);
+	}
+	
+	
+	
+	//enable video input
+	 anx980x_eanble_video_input(client);
+
+	return 0;
+}
+
+#if defined(BIST_MODE)
+static int anx6345_bist_mode(struct i2c_client *client)
+{
+	struct edp_anx6345 *anx6345 = i2c_get_clientdata(client);
+	struct rk_screen *screen = &anx6345->screen;
+	u16 x_total ,y_total, x_act;
+	char val = 0x00;
+	//these register are for bist mode
+	x_total = screen->mode.left_margin + screen->mode.right_margin +
+			screen->mode.xres + screen->mode.hsync_len;
+	y_total = screen->mode.upper_margin + screen->mode.lower_margin +
+			screen->mode.yres + screen->mode.vsync_len;
+	x_total >>= 1;
+	x_act = screen->mode.xres >> 1;
+	val = y_total & 0xff;
+	anx6345_i2c_write_p1_reg(client,TOTAL_LINEL_REG,&val);
+	val = (y_total >> 8);
+	anx6345_i2c_write_p1_reg(client,TOTAL_LINEH_REG,&val);
+	val = (screen->mode.yres & 0xff);
+	anx6345_i2c_write_p1_reg(client,ACT_LINEL_REG,&val);
+	val = (screen->mode.yres >> 8);
+	anx6345_i2c_write_p1_reg(client,ACT_LINEH_REG,&val);
+	val = screen->mode.lower_margin;
+	anx6345_i2c_write_p1_reg(client,VF_PORCH_REG,&val);
+	val = screen->mode.vsync_len;
+	anx6345_i2c_write_p1_reg(client,VSYNC_CFG_REG,&val);
+	val = screen->mode.upper_margin;
+	anx6345_i2c_write_p1_reg(client,VB_PORCH_REG,&val);
+	val = x_total & 0xff;
+	anx6345_i2c_write_p1_reg(client,TOTAL_PIXELL_REG,&val);
+	val = x_total >> 8;
+	anx6345_i2c_write_p1_reg(client,TOTAL_PIXELH_REG,&val);
+	val = (x_act & 0xff);
+	anx6345_i2c_write_p1_reg(client,ACT_PIXELL_REG,&val);
+	val = (x_act >> 8);
+	anx6345_i2c_write_p1_reg(client,ACT_PIXELH_REG,&val);
+	val = screen->mode.right_margin & 0xff;
+	anx6345_i2c_write_p1_reg(client,HF_PORCHL_REG,&val);
+	val = screen->mode.right_margin >> 8;
+	anx6345_i2c_write_p1_reg(client,HF_PORCHH_REG,&val);
+	val = screen->mode.hsync_len & 0xff;
+	anx6345_i2c_write_p1_reg(client,HSYNC_CFGL_REG,&val);
+	val = screen->mode.hsync_len >> 8;
+	anx6345_i2c_write_p1_reg(client,HSYNC_CFGH_REG,&val);
+	val = screen->mode.left_margin & 0xff;
+	anx6345_i2c_write_p1_reg(client,HB_PORCHL_REG,&val);
+	val = screen->mode.left_margin  >> 8;
+	anx6345_i2c_write_p1_reg(client,HB_PORCHH_REG,&val);
+	val = 0x13;
+	anx6345_i2c_write_p1_reg(client,VID_CTRL10_REG,&val);
+
+
+       //enable BIST. In normal mode, don't need to config this reg
+	val = 0x08;
+	anx6345_i2c_write_p1_reg(client, VID_CTRL4_REG, &val);
+	printk("anx6345 enter bist mode\n");
+
+	return 0;
+}
+#endif
+
+int anx6345_start_aux_transaction(struct i2c_client  *client)
+{
+	char val;
+	int retval = 0;
+	int timeout_loop = 0;
+	int aux_timeout = 0;
+	
+
+	anx6345_i2c_read_p0_reg(client, DP_AUX_CH_CTL_2, &val);
+	val |= AUX_EN;
+	anx6345_i2c_write_p0_reg(client, DP_AUX_CH_CTL_2, &val);
+
+	anx6345_i2c_read_p0_reg(client, DP_AUX_CH_CTL_2, &val);
+	while (val & AUX_EN) {
+		aux_timeout++;
+		if ((DP_TIMEOUT_LOOP_CNT * 10) < aux_timeout) {
+			dev_err(&client->dev, "AUX CH enable timeout!\n");
+			return -ETIMEDOUT;
+		}
+		anx6345_i2c_read_p0_reg(client, DP_AUX_CH_CTL_2, &val);
+		udelay(100);
+	}
+
+	/* Is AUX CH command redply received? */
+	anx6345_i2c_read_p1_reg(client, DP_INT_STA, &val);
+	while (!(val & RPLY_RECEIV)) {
+		timeout_loop++;
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(&client->dev, "AUX CH command redply failed!\n");
+			return -ETIMEDOUT;
+		}
+		anx6345_i2c_read_p1_reg(client, DP_INT_STA, &val);
+		udelay(10);
+	}
+
+	/* Clear interrupt source for AUX CH command redply */
+	anx6345_i2c_write_p1_reg(client, DP_INT_STA, &val);
+
+	/* Check AUX CH error access status */
+	anx6345_i2c_read_p0_reg(client, AUX_CH_STA, &val);
+	if ((val & AUX_STATUS_MASK) != 0) {
+		dev_err(&client->dev, "AUX CH error happens: %d\n\n",
+			val & AUX_STATUS_MASK);
+		return -EREMOTEIO;
+	}
+
+	return retval;
+}
+
+int anx6345_dpcd_write_bytes(struct i2c_client *client,
+				unsigned int val_addr,
+				unsigned int count,
+				unsigned char data[])
+{
+	char val;
+	unsigned int start_offset;
+	unsigned int cur_data_count;
+	unsigned int cur_data_idx;
+	int retval = 0;
+
+	start_offset = 0;
+	while (start_offset < count) {
+		/* Buffer size of AUX CH is 16 * 4bytes */
+		if ((count - start_offset) > 16)
+			cur_data_count = 16;
+		else
+			cur_data_count = count - start_offset;
+
+		val = BUF_CLR;
+		anx6345_i2c_write_p0_reg(client, BUF_DATA_CTL, &val);
+		
+		val = AUX_ADDR_7_0(val_addr + start_offset);
+		anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_7_0, &val);
+		val = AUX_ADDR_15_8(val_addr + start_offset);
+		anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_15_8, &val);
+		val = AUX_ADDR_19_16(val_addr + start_offset);
+		anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_19_16, &val);
+
+		for (cur_data_idx = 0; cur_data_idx < cur_data_count;
+		     cur_data_idx++) {
+			val = data[start_offset + cur_data_idx];
+			anx6345_i2c_write_p0_reg(client, BUF_DATA_0 + cur_data_idx, &val);
+		}
+
+		/*
+		 * Set DisplayPort transaction and write
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		val = AUX_LENGTH(cur_data_count) |
+			AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;
+		anx6345_i2c_write_p0_reg(client, DP_AUX_CH_CTL_1, &val);
+
+		/* Start AUX transaction */
+		retval = anx6345_start_aux_transaction(client);
+		if (retval == 0)
+			break;
+		else
+			dev_dbg(&client->dev, "Aux Transaction fail!\n");
+		
+
+		start_offset += cur_data_count;
+	}
+
+	return retval;
+}
+
+
+int anx6345_dpcd_read_bytes(struct i2c_client *client,
+				unsigned int val_addr,
+				unsigned int count,
+				unsigned char data[])
+{
+	char val;
+	unsigned int start_offset;
+	unsigned int cur_data_count;
+	unsigned int cur_data_idx;
+	int i;
+	int retval = 0;
+
+	start_offset = 0;
+	while (start_offset < count) {
+		/* Buffer size of AUX CH is 16 * 4bytes */
+		if ((count - start_offset) > 16)
+			cur_data_count = 16;
+		else
+			cur_data_count = count - start_offset;
+
+		/* AUX CH Request Transaction process */
+		for (i = 0; i < 10; i++) {
+			/* Select DPCD device address */
+			val = AUX_ADDR_7_0(val_addr + start_offset);
+			anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_7_0, &val);
+			val = AUX_ADDR_15_8(val_addr + start_offset);
+			anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_15_8, &val);
+			val = AUX_ADDR_19_16(val_addr + start_offset);
+			anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_19_16, &val);
+
+			/*
+			 * Set DisplayPort transaction and read
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			val = AUX_LENGTH(cur_data_count) |
+				AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;
+			anx6345_i2c_write_p0_reg(client, DP_AUX_CH_CTL_1, &val);
+
+			val = BUF_CLR;
+			anx6345_i2c_write_p0_reg(client, BUF_DATA_CTL, &val);
+
+			/* Start AUX transaction */
+			retval = anx6345_start_aux_transaction(client);
+			if (retval == 0)
+				break;
+			else
+				dev_dbg(&client->dev, "Aux Transaction fail!\n");
+		}
+
+		for (cur_data_idx = 0; cur_data_idx < cur_data_count;
+		    cur_data_idx++) {
+			anx6345_i2c_read_p0_reg(client, BUF_DATA_0 + cur_data_idx, &val);
+			data[start_offset + cur_data_idx] = val;
+			dev_dbg(&client->dev, "0x%05x :0x%02x\n",cur_data_idx, val);
+		}
+
+		start_offset += cur_data_count;
+	}
+
+	return retval;
+}
+
+
+int anx6345_select_i2c_device(struct i2c_client *client,
+				unsigned int device_addr,
+				char val_addr)
+{
+	char val;
+	int retval;
+
+	/* Set normal AUX CH command */
+	anx6345_i2c_read_p0_reg(client, DP_AUX_CH_CTL_2, &val);
+	val &= ~ADDR_ONLY;
+	anx6345_i2c_write_p0_reg(client, DP_AUX_CH_CTL_2, &val);
+	/* Set EDID device address */
+	val = device_addr;
+	anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_7_0, &val);
+	val = 0;
+	anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_15_8, &val);
+	anx6345_i2c_write_p0_reg(client, DP_AUX_ADDR_19_16, &val);
+
+	/* Set offset from base address of EDID device */
+	anx6345_i2c_write_p0_reg(client, BUF_DATA_0, &val_addr);
+
+	/*
+	 * Set I2C transaction and write address
+	 * If bit 3 is 1, DisplayPort transaction.
+	 * If Bit 3 is 0, I2C transaction.
+	 */
+	val = AUX_TX_COMM_I2C_TRANSACTION | AUX_TX_COMM_MOT |
+		AUX_TX_COMM_WRITE;
+	anx6345_i2c_write_p0_reg(client, DP_AUX_CH_CTL_1, &val);
+
+	/* Start AUX transaction */
+	retval = anx6345_start_aux_transaction(client);
+	if (retval != 0)
+		dev_dbg(&client->dev, "Aux Transaction fail!\n");
+
+	return retval;
+}
+
+int anx6345_edid_read_bytes(struct i2c_client *client,
+				unsigned int device_addr,
+				unsigned int val_addr,
+				unsigned char count,
+				unsigned char edid[])
+{
+	char val;
+	unsigned int i;
+	unsigned int start_offset;
+	unsigned int cur_data_idx;
+	unsigned int cur_data_cnt;
+	unsigned int defer = 0;
+	int retval = 0;
+
+	for (i = 0; i < count; i += 16) {
+		start_offset = i;
+		if ((count - start_offset) > 16)
+				cur_data_cnt = 16;
+			else
+				cur_data_cnt = count - start_offset;
+		/*
+		 * If Rx sends defer, Tx sends only reads
+		 * request without sending addres
+		 */
+		if (!defer)
+			retval = anx6345_select_i2c_device(client,
+					device_addr, val_addr + i);
+		else
+			defer = 0;
+
+		/*
+		 * Set I2C transaction and write data
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		val = AUX_LENGTH(cur_data_cnt) | AUX_TX_COMM_I2C_TRANSACTION |
+			AUX_TX_COMM_READ;
+		anx6345_i2c_write_p0_reg(client, DP_AUX_CH_CTL_1, &val);
+
+		/* Start AUX transaction */
+		retval = anx6345_start_aux_transaction(client);
+		if (retval < 0)
+			dev_dbg(&client->dev, "Aux Transaction fail!\n");
+
+		/* Check if Rx sends defer */
+		anx6345_i2c_read_p0_reg(client, DP_AUX_RX_COMM, &val);
+		if (val == AUX_RX_COMM_AUX_DEFER ||
+			val == AUX_RX_COMM_I2C_DEFER) {
+			dev_err(&client->dev, "Defer: %d\n\n", val);
+			defer = 1;
+		}
+		
+
+		for (cur_data_idx = 0; cur_data_idx < cur_data_cnt; cur_data_idx++) {
+			anx6345_i2c_read_p0_reg(client, BUF_DATA_0 + cur_data_idx, &val);
+			edid[i + cur_data_idx] = val;
+			dev_dbg(&client->dev, "0x%02x : 0x%02x\n", i + cur_data_idx, val);
+		}
+	}
+
+	return retval;
+}
+
+static int anx6345_read_edid(struct i2c_client *client)
+{
+	unsigned char edid[EDID_LENGTH * 2];
+	unsigned char extend_block = 0;
+	unsigned char sum;
+	unsigned char test_vector;
+	int retval;
+	char addr;
+	struct edp_anx6345 *anx6345 = i2c_get_clientdata(client);
+	
+
+	/* Read Extension Flag, Number of 128-byte EDID extension blocks */
+	retval = anx6345_edid_read_bytes(client, EDID_ADDR,
+				EDID_EXTENSION_FLAG,1,&extend_block);
+	if (retval < 0) {
+		dev_err(&client->dev, "EDID extension flag failed!\n");
+		return -EIO;
+	}
+
+	if (extend_block > 0) {
+		dev_dbg(&client->dev, "EDID data includes a single extension!\n");
+
+		/* Read EDID data */
+		retval = anx6345_edid_read_bytes(client, EDID_ADDR,
+						EDID_HEADER,
+						EDID_LENGTH,
+						&edid[EDID_HEADER]);
+		if (retval != 0) {
+			dev_err(&client->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		sum = edp_calc_edid_check_sum(edid);
+		if (sum != 0) {
+			dev_warn(&client->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		/* Read additional EDID data */
+		retval = anx6345_edid_read_bytes(client, EDID_ADDR, EDID_LENGTH,
+							EDID_LENGTH, &edid[EDID_LENGTH]);
+		if (retval != 0) {
+			dev_err(&client->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		sum = edp_calc_edid_check_sum(&edid[EDID_LENGTH]);
+		if (sum != 0) {
+			dev_warn(&client->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		retval = anx6345_dpcd_read_bytes(client, DPCD_TEST_REQUEST,
+						1, &test_vector);
+		if (retval < 0) {
+			dev_err(&client->dev, "DPCD EDID Read failed!\n");
+			return retval;
+		}
+
+		if (test_vector & DPCD_TEST_EDID_READ) {
+			retval = anx6345_dpcd_write_bytes(client,
+					DPCD_TEST_EDID_CHECKSUM,1,
+					&edid[EDID_LENGTH + EDID_CHECKSUM]);
+			if (retval < 0) {
+				dev_err(&client->dev, "DPCD EDID Write failed!\n");
+				return retval;
+			}
+
+			addr = DPCD_TEST_EDID_CHECKSUM_WRITE;
+			retval = anx6345_dpcd_write_bytes(client,
+					DPCD_TEST_RESPONSE, 1, &addr);
+			if (retval < 0) {
+				dev_err(&client->dev, "DPCD EDID checksum failed!\n");
+				return retval;
+			}
+		}
+	} else {
+		dev_info(&client->dev, "EDID data does not include any extensions.\n");
+
+		/* Read EDID data */
+		retval = anx6345_edid_read_bytes(client, EDID_ADDR, EDID_HEADER,
+				          EDID_LENGTH, &edid[EDID_HEADER]);
+		if (retval != 0) {
+			dev_err(&client->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		
+		sum = edp_calc_edid_check_sum(edid);
+		if (sum != 0) {
+			dev_warn(&client->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		retval = anx6345_dpcd_read_bytes(client, DPCD_TEST_REQUEST,
+						1,&test_vector);
+		if (retval < 0) {
+			dev_err(&client->dev, "DPCD EDID Read failed!\n");
+			return retval;
+		}
+
+		if (test_vector & DPCD_TEST_EDID_READ) {
+			retval = anx6345_dpcd_write_bytes(client,
+					DPCD_TEST_EDID_CHECKSUM, 1,
+					&edid[EDID_CHECKSUM]);
+			if (retval < 0) {
+				dev_err(&client->dev, "DPCD EDID Write failed!\n");
+				return retval;
+			}
+			addr = DPCD_TEST_EDID_CHECKSUM_WRITE;
+			retval = anx6345_dpcd_write_bytes(client, DPCD_TEST_RESPONSE,
+					1, &addr);
+			if (retval < 0) {
+				dev_err(&client->dev, "DPCD EDID checksum failed!\n");
+				return retval;
+			}
+		}
+	}
+	fb_edid_to_monspecs(edid, &anx6345->specs);
+	dev_info(&client->dev, "EDID Read success!\n");
+	return 0;
+}
+
+static int anx6345_init(struct i2c_client *client)
+{
+	char val = 0x00;
+	char i = 0;
+	char lc,bw;
+	char cnt = 50;
+	u8 buf[12];
+	
+	val = 0x30;	
+	anx6345_i2c_write_p1_reg(client,SP_POWERD_CTRL_REG,&val);
+
+	//clock detect	
+	for(i=0;i<50;i++)
+	{
+		
+		anx6345_i2c_read_p0_reg(client, SYS_CTRL1_REG, &val);
+		anx6345_i2c_write_p0_reg(client, SYS_CTRL1_REG, &val);
+		anx6345_i2c_read_p0_reg(client, SYS_CTRL1_REG, &val);
+		if((val&SYS_CTRL1_DET_STA)!=0)
+		{
+			break;
+		}
+
+		mdelay(10);
+	}
+	if(i>49)
+		printk("no clock detected by anx6345\n");
+	
+	//check whether clock is stable
+	for(i=0;i<50;i++)
+	{
+		anx6345_i2c_read_p0_reg(client, SYS_CTRL2_REG, &val);
+		anx6345_i2c_write_p0_reg(client,SYS_CTRL2_REG, &val);
+		anx6345_i2c_read_p0_reg(client, SYS_CTRL2_REG, &val);
+		if((val&SYS_CTRL2_CHA_STA)==0)
+		{
+			break;
+		}
+		mdelay(10);
+	}
+	if(i>49)
+		printk("clk is not stable\n");
+
+	anx6345_dpcd_read_bytes(client, DPCD_REV, 12, buf);
+	anx6345_read_edid(client);
+	
+    	//VESA range, 6bits BPC, RGB 
+	val = 0x00;
+	anx6345_i2c_write_p1_reg(client, VID_CTRL2_REG, &val);
+	
+	//ANX6345 chip pll setting 
+	val = 0x00;
+	anx6345_i2c_write_p0_reg(client, PLL_CTRL_REG, &val);                  //UPDATE: FROM 0X07 TO 0X00
+	
+	
+	//ANX chip analog setting
+	val = 0x70;
+	anx6345_i2c_write_p1_reg(client, ANALOG_DEBUG_REG1, &val);               //UPDATE: FROM 0XF0 TO 0X70
+	val = 0x30;
+	anx6345_i2c_write_p0_reg(client, LINK_DEBUG_REG, &val);
+
+	//force HPD
+	//anx6345_i2c_write_p0_reg(client, SYS_CTRL3_REG, &val);
+
+	
+	//reset AUX
+	anx6345_i2c_read_p1_reg(client, RST_CTRL2_REG, &val);
+	val |= AUX_RST;
+	anx6345_i2c_write_p1_reg(client, RST_CTRL2_REG, &val);
+	val &= ~AUX_RST;
+	anx6345_i2c_write_p1_reg(client, RST_CTRL2_REG, &val);
+	
+	//Select 2.7G
+	val = 0x0a;
+	anx6345_i2c_write_p0_reg(client, LINK_BW_SET_REG, &val);  
+	//Select 2 lanes
+	val = 0x02;
+	anx6345_i2c_write_p0_reg(client,LANE_COUNT_SET_REG,&val);
+	
+	val = LINK_TRAINING_CTRL_EN;  
+	anx6345_i2c_write_p0_reg(client, LINK_TRAINING_CTRL_REG, &val);
+	mdelay(5);
+	anx6345_i2c_read_p0_reg(client, LINK_TRAINING_CTRL_REG, &val);
+	while((val&0x80)&&(cnt))                                                                                //UPDATE: FROM 0X01 TO 0X80
+	{
+		printk("Waiting...\n");
+		mdelay(5);
+		anx6345_i2c_read_p0_reg(client,LINK_TRAINING_CTRL_REG,&val);
+		cnt--;
+	} 
+	if(cnt <= 0)
+	{
+		printk(KERN_INFO "HW LT fail\n");
+	}
+	else
+		printk("HW LT Success>>:times:%d\n",(51-cnt));
+
+
+	
+	//enable video input, set DDR mode, the input DCLK should be 102.5MHz; 
+	//In normal mode, set this reg to 0x81, SDR mode, the input DCLK should be 205MHz
+
+#if defined(BIST_MODE)
+	anx6345_bist_mode(client);
+	val = 0x8f;
+#else
+	val = 0x81;
+#endif
+	anx6345_i2c_write_p1_reg(client,VID_CTRL1_REG,&val);
+
+	anx_video_map_config(client);
+	//force HPD and stream valid
+	val = 0x33;
+	anx6345_i2c_write_p0_reg(client,SYS_CTRL3_REG,&val);
+
+	anx6345_i2c_read_p0_reg(client,LANE_COUNT_SET_REG, &lc);
+	anx6345_i2c_read_p0_reg(client,LINK_BW_SET_REG, &bw);
+	printk("%s..lc:%d--bw:%d\n",__func__,lc,bw);
+
+	return 0;
+}
+
+
+static int  anx6345_disable(void)
+{
+	struct edp_anx6345 *anx6345 = edp;
+
+	if (!anx6345->pdata->pwron)
+		return 0;
+	gpio_set_value(anx6345->pdata->dvdd33_en_pin,!anx6345->pdata->dvdd33_en_val);
+	gpio_set_value(anx6345->pdata->dvdd18_en_pin,!anx6345->pdata->dvdd18_en_val);
+	anx6345->pdata->pwron = false;
+
+	return 0;
+	
+}
+	
+
+static int anx6345_enable(void)
+{
+	struct edp_anx6345 *anx6345 = edp;
+
+	if (!anx6345->pdata->pwron) {
+		gpio_set_value(anx6345->pdata->dvdd33_en_pin,anx6345->pdata->dvdd33_en_val);
+		msleep(5);
+		gpio_set_value(anx6345->pdata->dvdd18_en_pin,anx6345->pdata->dvdd18_en_val);
+		gpio_set_value(anx6345->pdata->edp_rst_pin,0);
+		msleep(50);
+		gpio_set_value(anx6345->pdata->edp_rst_pin,1);
+		anx6345->pdata->pwron = true;
+	}
+	anx6345->edp_anx_init(anx6345->client);
+	return 0;
+}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void anx6345_early_suspend(struct early_suspend *h)
+{
+	anx6345_disable();
+}
+
+static void anx6345_late_resume(struct early_suspend *h)
+{
+	anx6345_enable();
+}
+#endif				
+
+#if defined(CONFIG_OF)
+
+static int anx6345_power_ctl(struct anx6345_platform_data  *pdata)
+{
+       int ret;
+       ret = gpio_request(pdata->dvdd33_en_pin, "dvdd33_en_pin");
+       if (ret != 0) {
+	       gpio_free(pdata->dvdd33_en_pin);
+	       printk(KERN_ERR "request dvdd33 en pin fail!\n");
+	       return -1;
+       } else {
+	       gpio_direction_output(pdata->dvdd33_en_pin, pdata->dvdd33_en_val);
+       }
+       mdelay(5);
+
+       ret = gpio_request(pdata->dvdd18_en_pin, "dvdd18_en_pin");
+       if (ret != 0) {
+	       gpio_free(pdata->dvdd18_en_pin);
+	       printk(KERN_ERR "request dvdd18 en pin fail!\n");
+	       return -1;
+       } else {
+	       gpio_direction_output(pdata->dvdd18_en_pin, pdata->dvdd18_en_pin);
+       }
+
+       ret = gpio_request(pdata->edp_rst_pin, "edp_rst_pin");
+       if (ret != 0) {
+	       gpio_free(pdata->edp_rst_pin);
+	       printk(KERN_ERR "request rst pin fail!\n");
+	       return -1;
+       } else {
+	       gpio_direction_output(pdata->edp_rst_pin, 0);
+	       msleep(50);
+	       gpio_direction_output(pdata->edp_rst_pin, 1);
+       }
+       pdata->pwron = true;
+       return 0;
+
+}
+
+
+struct rk_fb_trsm_ops  trsm_edp_ops = {
+	.enable = anx6345_enable,
+	.disable = anx6345_disable,
+	
+};
+static void anx6345_parse_dt(struct edp_anx6345 *anx6345)
+{
+	struct device_node *np = anx6345->client->dev.of_node;
+	struct anx6345_platform_data *pdata;
+	enum of_gpio_flags dvdd33_flags,dvdd18_flags,rst_flags;
+	pdata = devm_kzalloc(&anx6345->client->dev,
+			sizeof(struct anx6345_platform_data ), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(&anx6345->client->dev, 
+			"failed to allocate platform data\n");
+		return ;
+	}
+	pdata->dvdd33_en_pin = of_get_named_gpio_flags(np, "dvdd33-gpio", 0, &dvdd33_flags);
+	pdata->dvdd18_en_pin = of_get_named_gpio_flags(np, "dvdd18-gpio", 0, &dvdd18_flags);
+	pdata->edp_rst_pin = of_get_named_gpio_flags(np, "reset-gpio", 0, &rst_flags);
+	pdata->dvdd33_en_val = (dvdd33_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+	pdata->dvdd18_en_val = (dvdd18_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+	pdata->power_ctl = anx6345_power_ctl;
+	anx6345->pdata = pdata;
+	
+}
+#else
+static void anx6345_parse_dt(struct edp_anx6345 * anx6345)
+{
+	
+}
+#endif
+static int anx6345_i2c_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{
+	struct edp_anx6345 *anx6345;
+	int chip_id;
+
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
+	{
+		dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+		return -ENODEV;
+	}
+	anx6345 = devm_kzalloc(&client->dev, sizeof(struct edp_anx6345),
+				GFP_KERNEL);
+	if (unlikely(!anx6345)) {
+		dev_err(&client->dev, "alloc for struct anx6345 fail\n");
+		return -ENOMEM;
+	}
+
+	anx6345->client = client;
+	anx6345->pdata = dev_get_platdata(&client->dev);
+	if (!anx6345->pdata) {
+		anx6345_parse_dt(anx6345);
+	}
+	i2c_set_clientdata(client,anx6345);
+	rk_fb_get_prmry_screen(&anx6345->screen);
+	if (anx6345->screen.type != SCREEN_EDP){
+		dev_err(&client->dev, "screen is not edp!\n");
+		return -EINVAL;
+	}
+	if(anx6345->pdata->power_ctl)
+		anx6345->pdata->power_ctl(anx6345->pdata);
+
+#if defined(CONFIG_DEBUG_FS)
+	anx6345->debugfs_dir = debugfs_create_dir("edp", NULL);
+	if (IS_ERR(anx6345->debugfs_dir)) {
+		dev_err(&client->dev, "failed to create debugfs dir for edp!\n");
+	}
+	else
+		debugfs_create_file("edp-reg", S_IRUSR,anx6345->debugfs_dir,anx6345,&edp_reg_fops);
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	anx6345->early_suspend.suspend = anx6345_early_suspend;
+	anx6345->early_suspend.resume = anx6345_late_resume;
+    	anx6345->early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING;
+	register_early_suspend(&anx6345->early_suspend);
+#endif
+	chip_id = get_dp_chip_id(client);
+	if(chip_id == 0x9805)
+		anx6345->edp_anx_init = anx980x_init;
+	else
+		anx6345->edp_anx_init = anx6345_init;
+	edp = anx6345;
+
+	rk_fb_trsm_ops_register(&trsm_edp_ops, SCREEN_EDP);
+
+	dev_info(&client->dev, "edp anx%x probe ok \n", get_dp_chip_id(client));
+	
+	return 0;
+}
+
+static int  anx6345_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id id_table[] = {
+	{"anx6345", 0 },
+	{ }
+};
+
+#if defined(CONFIG_OF)
+static struct of_device_id anx6345_dt_ids[] = {
+	{ .compatible = "analogix, anx6345" },
+	{ }
+};
+#endif
+
+static struct i2c_driver anx6345_i2c_driver  = {
+	.driver = {
+		.name  = "anx6345",
+		.owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(anx6345_dt_ids),
+#endif
+	},
+	.probe		= &anx6345_i2c_probe,
+	.remove     	= &anx6345_i2c_remove,
+	.id_table	= id_table,
+};
+
+
+static int __init anx6345_module_init(void)
+{
+	return i2c_add_driver(&anx6345_i2c_driver);
+}
+
+static void __exit anx6345_module_exit(void)
+{
+	i2c_del_driver(&anx6345_i2c_driver);
+}
+
+fs_initcall(anx6345_module_init);
+module_exit(anx6345_module_exit);
+
diff -Nupr a/drivers/video/rockchip/transmitter/dpcd_edid.h b/drivers/video/rockchip/transmitter/dpcd_edid.h
--- a/drivers/video/rockchip/transmitter/dpcd_edid.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/dpcd_edid.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __DPCD_EDID_H
+#define __DPCD_EDID_H
+#include "../../fbdev/edid.h"
+
+#define DPCD_REV					0x00
+#define DPCD_MAX_LINK_RATE				0x01
+#define DPCD_MAX_LANE_CNT				0x02	
+
+#define DPCD_MAX_DOWNSPREAD				0x03
+#define DPCD_NORP					0x04
+#define DPCD_DOWNSTREAMPORT_PRESENT			0x05
+
+#define DPCD_RECEIVE_PORT0_CAP_0			0x08
+#define DPCD_RECEIVE_PORT0_CAP_1			0x09
+#define DPCD_RECEIVE_PORT0_CAP_2			0x0a
+#define DPCD_RECEIVE_PORT0_CAP_3			0x0b
+
+#define DPCD_LINK_BW_SET				0x100
+#define DPCD_LANE_CNT_SET				0x101
+#define DPCD_TRAINING_PATTERN_SET			0x102
+#define DPCD_TRAINING_LANE0_SET				0x103
+#define DPCD_TRAINING_LANE1_SET				0x104
+#define DPCD_TRAINING_LANE2_SET				0x105
+#define DPCD_TRAINING_LANE3_SET				0x106
+#define DPCD_DOWNSPREAD_CTRL				0x107
+
+#define DPCD_SINK_COUNT					0x200
+#define DPCD_DEVICE_SERVICE_IRQ_VECTOR			0x201
+#define DPCD_LANE0_1_STATUS				0x202
+#define DPCD_LANE2_3_STATUS				0x203
+#define DPCD_LANE_ALIGN_STATUS_UPDATED            	0x204
+#define DPCD_SINK_STATUS                                0x205
+#define DPCD_ADJUST_REQUEST_LANE0_1                     0x206
+#define DPCD_ADJUST_REQUEST_LANE2_3                     0x207
+#define DPCD_TRAINING_SCORE_LANE0                       0x208
+#define DPCD_TRAINING_SCORE_LANE1                       0x209
+#define DPCD_TRAINING_SCORE_LANE2                       0x20a
+#define DPCD_TRAINING_SCORE_LANE3                       0x20b
+#define DPCD_SYMBOL_ERR_CONUT_LANE0			0x210
+#define DPCD_SINK_POWER_STATE				0x0600
+
+/* DPCD_ADDR_MAX_LANE_COUNT */
+#define DPCD_ENHANCED_FRAME_CAP(x)		(((x) >> 7) & 0x1)
+#define DPCD_MAX_LANE_COUNT(x)			((x) & 0x1f)
+
+/* DPCD_ADDR_LANE_COUNT_SET */
+#define DPCD_ENHANCED_FRAME_EN			(0x1 << 7)
+#define DPCD_LANE_COUNT_SET(x)			((x) & 0x1f)
+
+/* DPCD_ADDR_TRAINING_PATTERN_SET */
+#define DPCD_SCRAMBLING_DISABLED		(0x1 << 5)
+#define DPCD_SCRAMBLING_ENABLED			(0x0 << 5)
+#define DPCD_TRAINING_PATTERN_2			(0x2 << 0)
+#define DPCD_TRAINING_PATTERN_1			(0x1 << 0)
+#define DPCD_TRAINING_PATTERN_DISABLED		(0x0 << 0)
+
+/* DPCD_ADDR_TRAINING_LANE0_SET */
+#define DPCD_MAX_PRE_EMPHASIS_REACHED		(0x1 << 5)
+#define DPCD_PRE_EMPHASIS_SET(x)		(((x) & 0x3) << 3)
+#define DPCD_PRE_EMPHASIS_GET(x)		(((x) >> 3) & 0x3)
+#define DPCD_PRE_EMPHASIS_PATTERN2_LEVEL0	(0x0 << 3)
+#define DPCD_MAX_SWING_REACHED			(0x1 << 2)
+#define DPCD_VOLTAGE_SWING_SET(x)		(((x) & 0x3) << 0)
+#define DPCD_VOLTAGE_SWING_GET(x)		(((x) >> 0) & 0x3)
+#define DPCD_VOLTAGE_SWING_PATTERN1_LEVEL0	(0x0 << 0)
+
+/* DPCD_ADDR_LANE0_1_STATUS */
+#define DPCD_LANE_SYMBOL_LOCKED			(0x1 << 2)
+#define DPCD_LANE_CHANNEL_EQ_DONE		(0x1 << 1)
+#define DPCD_LANE_CR_DONE			(0x1 << 0)
+#define DPCD_CHANNEL_EQ_BITS			(DPCD_LANE_CR_DONE|	\
+						 DPCD_LANE_CHANNEL_EQ_DONE|\
+						 DPCD_LANE_SYMBOL_LOCKED)
+
+#define DPCD_TEST_REQUEST                               0x218
+#define DPCD_TEST_LINK_RATE                             0x219
+
+#define DPCD_TEST_LANE_COUNT                            0x220
+#define DPCD_TEST_RESPONSE                            	0x260
+#define DPCD_TEST_EDID_CHECKSUM				0x261
+#define TEST_ACK                                        0x01
+#define DPCD_TEST_EDID_Checksum_Write                   0x04//bit position
+
+#define DPCD_TEST_EDID_Checksum                         0x261
+
+
+#define DPCD_SPECIFIC_INTERRUPT                         0x10
+#define DPCD_USER_COMM1                                 0x22//define for downstream HDMI Rx sense detection
+
+#define AUX_ADDR_7_0(x)					(((x) >> 0) & 0xff)
+#define AUX_ADDR_15_8(x)				(((x) >> 8) & 0xff)
+#define AUX_ADDR_19_16(x)				(((x) >> 16) & 0x0f)
+
+#define AUX_RX_COMM_I2C_DEFER				(0x2 << 2)
+#define AUX_RX_COMM_AUX_DEFER				(0x2 << 0)
+
+/* DPCD_ADDR_LANE_ALIGN__STATUS_UPDATED */
+#define DPCD_LINK_STATUS_UPDATED			(0x1 << 7)
+#define DPCD_DOWNSTREAM_PORT_STATUS_CHANGED		(0x1 << 6)
+#define DPCD_INTERLANE_ALIGN_DONE			(0x1 << 0)
+
+/* DPCD_ADDR_TEST_REQUEST */
+#define DPCD_TEST_EDID_READ				(0x1 << 2)
+
+/* DPCD_ADDR_TEST_RESPONSE */
+#define DPCD_TEST_EDID_CHECKSUM_WRITE			(0x1 << 2)
+
+/* DPCD_ADDR_SINK_POWER_STATE */
+#define DPCD_SET_POWER_STATE_D0				(0x1 << 0)
+#define DPCD_SET_POWER_STATE_D4				(0x2 << 0)
+
+
+/*
+ * EDID device address is 0x50.
+ * However, if necessary, you must have set upper address
+ * into E-EDID in I2C device, 0x30.
+ */
+
+#define EDID_ADDR 					0x50
+#define E_EDID_ADDR					0x30
+#define EDID_EXTENSION_FLAG				0x7e
+#define EDID_CHECKSUM					0x7f	
+
+static unsigned char inline edp_calc_edid_check_sum(unsigned char *edid_data)
+{
+	int i;
+	unsigned char sum = 0;
+
+	for (i = 0; i < EDID_LENGTH; i++)
+		sum = sum + edid_data[i];
+
+	return sum;
+}
+
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/Kconfig b/drivers/video/rockchip/transmitter/Kconfig
--- a/drivers/video/rockchip/transmitter/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,87 @@
+# SPDX-License-Identifier: GPL-2.0
+
+menuconfig RK_TRSM
+	bool "RockChip display transmitter support"
+	depends on FB_ROCKCHIP || DRM_ROCKCHIP
+
+config RK2928_LVDS
+	bool "RK2928/RK2926 lvds transmitter support"
+        depends on ARCH_RK2928 && RK_TRSM
+
+config RK3026_LVDS
+	depends on ARCH_RK3026 && RK_TRSM
+	bool "RK3026/RK3028A lvds transmitter support"
+	default y	
+
+config RK32_LVDS
+	bool "RK32 lvds transmitter support"
+	depends on RK_TRSM
+
+config RK31XX_LVDS
+	bool "RK312x/RK3190/3368 lvds transmitter support"
+	depends on RK_TRSM
+	help
+		If use LVDS or RGB output interface,selete this module.
+
+config RK610_LVDS
+	bool "RK610(Jetta) lvds transmitter support"
+	depends on MFD_RK610 && RK_TRSM 
+	help
+		Support Jetta(RK610) to output LCD1 and LVDS.
+
+config RK616_LVDS
+        bool "RK616(JettaB) lvds,lcd,scaler vido interface support"
+        depends on MFD_RK616 && RK_TRSM
+        help
+           RK616(Jetta B) LVDS,LCD,scaler transmitter support.
+		
+
+config DP_ANX6345
+	bool "RGB to DisplayPort transmitter anx6345,anx9804,anx9805 support"
+	depends on RK_TRSM
+
+config DP501
+	bool"RGB to DisplayPort transmitter dp501 support"
+	depends on RK_TRSM
+
+config RK32_DP
+	bool "RK32 RGB to DisplayPort transmitter support "
+	depends on RK_TRSM
+
+config RK_VGA
+         bool "VGA support on RockChip platform"
+         depends on RK_TRSM
+         default y
+         help
+           say y here will enable VGA on RockChip platform
+
+config MIPI_DSI
+	depends on RK_TRSM
+	bool "Rockchip MIPI DSI support"
+
+config TC358768_RGB2MIPI
+        tristate "toshiba TC358768 RGB to MIPI DSI"
+	depends on MIPI_DSI
+        help
+        "a chip that change RGB interface parallel signal into DSI serial signal"
+
+config SSD2828_RGB2MIPI
+        tristate "solomon SSD2828 RGB to MIPI DSI"
+		depends on MIPI_DSI
+        help
+        "a chip that change RGB interface parallel signal into DSI serial signal"
+
+config RK32_MIPI_DSI
+        tristate "rk32 mipi dsi support"
+        depends on MIPI_DSI
+        help
+           Rockchip mipi dsi support.		
+
+			
+config RK616_MIPI_DSI_RST
+	bool "Reset the rockchip mipi dsi"
+	depends on MFD_RK616 && RK616_MIPI_DSI && RK616_USE_MCLK_12M
+	default y
+	help
+	 if you say y here: inset the hdmi, mipi lcd will be reset. 
+
diff -Nupr a/drivers/video/rockchip/transmitter/Makefile b/drivers/video/rockchip/transmitter/Makefile
--- a/drivers/video/rockchip/transmitter/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,20 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for display transmitter like lvds edp mipi
+#
+obj-$(CONFIG_RK2928_LVDS)       += rk2928_lvds.o
+obj-$(CONFIG_RK3026_LVDS)       += rk3026_lvds.o
+obj-$(CONFIG_RK610_LVDS)	+= rk610_lcd.o
+obj-$(CONFIG_RK616_LVDS)        += rk616_lvds.o
+obj-$(CONFIG_RK32_LVDS)         += rk32_lvds.o
+obj-$(CONFIG_RK31XX_LVDS)	+= rk31xx_lvds.o
+obj-$(CONFIG_DP_ANX6345)        += dp_anx6345.o
+obj-$(CONFIG_DP501)          	+= dp501.o
+obj-$(CONFIG_RK32_DP)		+= rk32_dp.o rk32_dp_reg.o
+obj-$(CONFIG_MIPI_DSI)     	+= mipi_dsi.o 
+obj-$(CONFIG_RK616_MIPI_DSI)	+= rk616_mipi_dsi.o
+obj-$(CONFIG_RK32_MIPI_DSI)	+= rk32_mipi_dsi.o
+obj-$(CONFIG_TC358768_RGB2MIPI)	+= tc358768.o
+obj-$(CONFIG_SSD2828_RGB2MIPI)	+= ssd2828.o
+obj-$(CONFIG_RK_VGA)  		+= vga.o
+
diff -Nupr a/drivers/video/rockchip/transmitter/mipi_dsi.c b/drivers/video/rockchip/transmitter/mipi_dsi.c
--- a/drivers/video/rockchip/transmitter/mipi_dsi.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/mipi_dsi.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ * drivers/video/display/transmitter/mipi_dsi.c
+ * author: hhb@rock-chips.com
+ * create date: 2013-01-17
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef CONFIG_MIPI_DSI
+#include <common.h>
+#endif
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+#include <asm/io.h>
+#include <errno.h>
+#include <malloc.h>
+#include <fdtdec.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/rkplat.h>
+#include <lcd.h>
+#include "mipi_dsi.h"
+#else
+#include <linux/module.h>
+#include <linux/init.h>
+/* #include <asm/system.h> */
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/rk_fb.h>
+#include <linux/rk_screen.h>
+#include <linux/ktime.h>
+
+#include "mipi_dsi.h"
+#endif
+
+#define MAX_DSI_CHIPS 5
+
+/*
+*			 Driver Version Note
+*
+*v1.0 : this driver is a top level architecture of mipi dsi driver;
+*v1.1 : add struct mipi_dsi_screen
+*v1.2 : add id argument to identify different dsi 
+*v1.3 : fix send commad's methods  
+*/
+#define MIPI_DSI_VERSION_AND_TIME  "mipi_dsi v1.3 2014-04-17"
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+#define	printk(x...)	printf(x)
+#endif
+
+
+static struct mipi_dsi_ops *dsi_ops[MAX_DSI_CHIPS] = {NULL};
+//static struct mipi_dsi_ops *cur_dsi_ops;
+
+int register_dsi_ops(unsigned int id, struct mipi_dsi_ops *ops) {
+
+	//int i = 0;
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	dsi_ops[id] = ops;
+	return 0;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(register_dsi_ops);
+#endif
+
+int del_dsi_ops(struct mipi_dsi_ops *ops) {
+
+	int i = 0;
+
+	for(i = 0; i < MAX_DSI_CHIPS; i++) {
+		if(dsi_ops[i] == ops) {
+			dsi_ops[i] = NULL;
+			break;	
+		}	
+	}
+
+	if(i == MAX_DSI_CHIPS) {
+		printk("dsi ops not found\n");
+		return -1;
+	}
+	return 0;	
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(del_dsi_ops);
+#endif
+
+int dsi_probe_current_chip(unsigned int id) {
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+	if(!ops)
+		return -EINVAL;
+
+	id = ops->get_id(ops->dsi);
+
+	return id;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_probe_current_chip);
+#endif
+int dsi_power_up(unsigned int id) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+	if(ops->power_up)
+		ops->power_up(ops->dsi);
+	return 0;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_power_up);
+#endif
+
+int dsi_power_off(unsigned int id) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->power_down)
+		ops->power_down(ops->dsi);
+
+	return 0;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_power_off);
+#endif
+int dsi_set_regs(unsigned int id, void *array, u32 n) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_set_regs)
+		ops->dsi_set_regs(ops->dsi, array, n);
+
+	return 0;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_set_regs);
+#endif
+int dsi_init(unsigned int id, u32 n) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_init)
+		ops->dsi_init(ops->dsi, n);
+
+	return 0;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_init);
+#endif
+int dsi_enable_video_mode(unsigned int id, u32 enable) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_enable_video_mode)
+		ops->dsi_enable_video_mode(ops->dsi, enable);
+
+	return 0;
+
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_enable_video_mode);
+#endif
+int dsi_enable_command_mode(unsigned int id, u32 enable) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_enable_command_mode)
+		ops->dsi_enable_command_mode(ops->dsi, enable);
+
+	return 0;
+
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_enable_command_mode);
+#endif
+int dsi_enable_hs_clk(unsigned int id, u32 enable) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_enable_hs_clk)
+		ops->dsi_enable_hs_clk(ops->dsi, enable);
+
+	return 0;
+
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_enable_hs_clk);
+#endif
+int dsi_is_active(unsigned int id) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_is_active)
+		return ops->dsi_is_active(ops->dsi);
+	else
+		return -1;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_is_active);
+#endif
+int dsi_is_enable(unsigned int id, u32 enable){
+
+    struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_is_enable)
+		ops->dsi_is_enable(ops->dsi, enable);
+
+	return 0;
+	
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_is_enable);
+#endif
+int dsi_send_dcs_packet(unsigned int id, unsigned char *packet, u32 n) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+    //printk("dsi_send_dcs_packet-------id=%d\n",id);
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_send_dcs_packet)
+		ops->dsi_send_dcs_packet(ops->dsi, packet, n);
+	return 0;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_send_dcs_packet);
+#endif
+
+int dsi_read_dcs_packet(unsigned int id, unsigned char *packet, u32 n) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_read_dcs_packet)
+		ops->dsi_read_dcs_packet(ops->dsi, packet, n);
+	return 0;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_read_dcs_packet);
+#endif
+
+int dsi_send_packet(unsigned int id, unsigned char *packet, u32 n) {
+
+	struct mipi_dsi_ops *ops = NULL;
+
+	if(id > (MAX_DSI_CHIPS - 1))
+		return -EINVAL;
+
+	ops = dsi_ops[id];
+
+	if(!ops)
+		return -EINVAL;
+
+	if(ops->dsi_send_packet)
+		ops->dsi_send_packet(ops->dsi, packet, n);
+		
+	return 0;
+}
+#ifdef CONFIG_MIPI_DSI
+EXPORT_SYMBOL(dsi_send_packet);
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/mipi_dsi.h b/drivers/video/rockchip/transmitter/mipi_dsi.h
--- a/drivers/video/rockchip/transmitter/mipi_dsi.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/mipi_dsi.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,308 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+drivers/video/rockchip/transmitter/mipi_dsi.h
+*/
+#ifndef MIPI_DSI_H_
+#define MIPI_DSI_H_
+
+#ifdef CONFIG_MIPI_DSI_FT
+#include "..\..\common\config.h"
+#endif
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <dt-bindings/gpio/gpio.h>
+#endif
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+#include <linux/list.h>
+#endif
+
+
+//DSI DATA TYPE
+#define DTYPE_DCS_SWRITE_0P		0x05 
+#define DTYPE_DCS_SWRITE_1P		0x15 
+#define DTYPE_DCS_LWRITE		0x39 
+#define DTYPE_GEN_LWRITE		0x29 
+#define DTYPE_GEN_SWRITE_2P		0x23 
+#define DTYPE_GEN_SWRITE_1P		0x13
+#define DTYPE_GEN_SWRITE_0P		0x03
+
+//command transmit mode
+#define HSDT			0x00
+#define LPDT			0x01
+
+//DSI DATA TYPE FLAG
+#define DATA_TYPE_DCS			0x00
+#define DATA_TYPE_GEN			0x01
+
+
+//Video Mode
+#define VM_NBMWSP		0x00  //Non burst mode with sync pulses
+#define VM_NBMWSE		0x01  //Non burst mode with sync events
+#define VM_BM			0x02  //Burst mode
+
+//Video Pixel Format
+#define VPF_16BPP		0x00
+#define VPF_18BPP		0x01	 //packed
+#define VPF_18BPPL		0x02     //loosely packed
+#define VPF_24BPP		0x03
+
+//Display Command Set
+#define dcs_enter_idle_mode 		0x39
+#define dcs_enter_invert_mode 		0x21
+#define dcs_enter_normal_mode 		0x13
+#define dcs_enter_partial_mode  	0x12
+#define dcs_enter_sleep_mode  		0x10
+#define dcs_exit_idle_mode  		0x38
+#define dcs_exit_invert_mode  		0x20
+#define dcs_exit_sleep_mode  		0x11
+#define dcs_get_address_mode  		0x0b
+#define dcs_get_blue_channel  		0x08
+#define dcs_get_diagnostic_result  	0x0f
+#define dcs_get_display_mode  		0x0d
+#define dcs_get_green_channel  		0x07
+#define dcs_get_pixel_format  		0x0c
+#define dcs_get_power_mode  		0x0a
+#define dcs_get_red_channel 		0x06
+#define dcs_get_scanline 	 		0x45
+#define dcs_get_signal_mode  		0x0e
+#define dcs_nop				 		0x00
+#define dcs_read_DDB_continue  		0xa8
+#define dcs_read_DDB_start  		0xa1
+#define dcs_read_memory_continue  	0x3e
+#define dcs_read_memory_start  		0x2e
+#define dcs_set_address_mode  		0x36
+#define dcs_set_column_address  	0x2a
+#define dcs_set_display_off  		0x28
+#define dcs_set_display_on  		0x29
+#define dcs_set_gamma_curve  		0x26
+#define dcs_set_page_address  		0x2b
+#define dcs_set_partial_area  		0x30
+#define dcs_set_pixel_format  		0x3a
+#define dcs_set_scroll_area  		0x33
+#define dcs_set_scroll_start  		0x37
+#define dcs_set_tear_off 	 		0x34
+#define dcs_set_tear_on 	 		0x35
+#define dcs_set_tear_scanline  		0x44
+#define dcs_soft_reset 		 		0x01
+#define dcs_write_LUT 		 		0x2d
+#define dcs_write_memory_continue  	0x3c
+#define dcs_write_memory_start 		0x2c
+
+#ifndef MHz
+#define MHz   1000000
+#endif
+
+
+#if 0
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long s64;
+typedef unsigned long u64;
+#endif
+
+
+//iomux
+#define OLD_RK_IOMUX 0
+
+struct spi_t {
+	u32 cs;
+#if OLD_RK_IOMUX	
+	char* cs_mux_name;
+#endif	
+	int sck;
+#if OLD_RK_IOMUX	
+	char* sck_mux_name;
+#endif	
+	int miso;
+#if OLD_RK_IOMUX	
+	char* miso_mux_name;
+#endif	
+	int mosi;
+#if OLD_RK_IOMUX	
+	char* mosi_mux_name;
+#endif	
+};
+
+struct power_t {
+	int	enable_pin;    //gpio that control power
+#if OLD_RK_IOMUX	
+	char* mux_name;
+	u32 mux_mode;
+#endif	
+	u32 effect_value;
+	
+	char *name;
+	u32 voltage;
+	int (*enable)(void *);
+	int (*disable)(void *);
+};
+
+struct reset_t {
+	int	reset_pin;    //gpio that control reset
+#if OLD_RK_IOMUX	
+	char* mux_name;
+	u32 mux_mode;
+#endif	
+	u32 effect_value;
+	
+	u32 time_before_reset;    //ms
+ 	u32 time_after_reset;
+	
+	int (*do_reset)(void *);
+};
+
+struct tc358768_t {
+	u32 id;
+	struct reset_t reset;
+	struct power_t vddc;
+	struct power_t vddio;
+	struct power_t vdd_mipi;
+	struct i2c_client *client;
+	int (*gpio_init)(void *);
+	int (*gpio_deinit)(void *);
+	int (*power_up)(void);
+	int (*power_down)(void);
+};
+
+
+struct ssd2828_t {
+	u32 id;
+	struct reset_t reset;
+	struct power_t shut;
+	struct power_t vddio;
+	struct power_t vdd_mipi;
+	
+	struct spi_t spi;
+	int (*gpio_init)(void *);
+	int (*gpio_deinit)(void *);
+	int (*power_up)(void);
+	int (*power_down)(void);
+};
+
+struct mipi_dsi_ops {
+	u32 id;
+	char name[32];
+	void *dsi;
+	int (*get_id)(void *);
+	int (*dsi_init)(void *, u32 n);
+	int (*dsi_set_regs)(void *, void *, u32 n);
+	int (*dsi_enable_video_mode)(void *, u32 enable);
+	int (*dsi_enable_command_mode)(void *, u32 enable);
+	int (*dsi_enable_hs_clk)(void *, u32 enable);
+	int (*dsi_send_dcs_packet)(void *, unsigned char *, u32 n);
+	int (*dsi_read_dcs_packet)(void *, unsigned char *, u32 n);
+	int (*dsi_send_packet)(void *, unsigned char *, u32 n);
+    int (*dsi_is_enable)(void *, u32 enable);
+	int (*dsi_is_active)(void *);
+	int (*power_up)(void *);
+	int (*power_down)(void *);
+};
+
+/* Screen description */
+struct mipi_dsi_screen {
+
+	u16 type;
+	u16 face;
+	u8 lcdc_id;    
+	u8 screen_id; 
+
+	/* Timing */
+	u32 pixclock;
+	u16 left_margin;
+	u16 right_margin;
+	u16 hsync_len;
+	u16 upper_margin;
+	u16 lower_margin;
+	u16 vsync_len;
+	
+	/* Screen size */
+	u16 x_res;
+	u16 y_res;
+	u16 width;
+	u16 height;
+	/* Pin polarity */
+	u8 pin_hsync;
+	u8 pin_vsync;
+	u8 pin_den;
+	u8 pin_dclk;
+
+	/* MIPI DSI */
+	u8 dsi_lane;
+	u16 refresh_mode;
+	u32 hs_tx_clk;
+	struct rk_screen *screen;
+
+	/* Operation function*/
+	int (*init)(void);
+	int (*standby)(u8 enable);
+
+};
+
+#define INVALID_GPIO        -1
+
+struct dcs_cmd {
+	u8 type;
+	u8 dtype;
+	u8 dsi_id;
+	u8 cmd_len;
+	int *cmds;
+	int delay;
+	char name[32];
+};
+
+struct mipi_dcs_cmd_ctr_list {
+	struct list_head list;
+	struct dcs_cmd dcs_cmd;
+};
+
+enum {
+	VIDEO_MODE = 0,
+	COMMAND_MODE,
+};
+
+struct mipi_screen
+{
+	u8 screen_init;
+	u8 mipi_dsi_num;
+	u8 lcd_rst_atv_val;
+	u8 lcd_en_atv_val;
+	u8 dsi_lane;
+	u8 dsi_operate_mode;
+	u32 hs_tx_clk;
+	u32 lcd_en_gpio;
+	u32 lcd_en_delay;
+	u32 lcd_rst_gpio;
+	u32 lcd_rst_delay;
+
+	struct list_head cmdlist_head;
+};
+
+int register_dsi_ops(unsigned int id, struct mipi_dsi_ops *ops);
+int del_dsi_ops(struct mipi_dsi_ops *ops);
+int dsi_power_up(unsigned int id);
+int dsi_power_off(unsigned int id);
+int dsi_probe_current_chip(unsigned int id);
+int dsi_init(unsigned int id, u32 n);
+int dsi_is_active(unsigned int id);
+int dsi_enable_video_mode(unsigned int id, u32 enable);
+int dsi_enable_command_mode(unsigned int id, u32 enable);
+int dsi_enable_hs_clk(unsigned int id, u32 enable);
+int dsi_set_virtual_channel(unsigned int id, u32 channel);
+
+int dsi_set_regs(unsigned int id, void *array, u32 n);
+int dsi_send_dcs_packet(unsigned int id, unsigned char *packet, u32 n);
+int dsi_read_dcs_packet(unsigned int id, unsigned char *packet, u32 n);
+int dsi_send_packet(unsigned int id, unsigned char *packet, u32 n);
+int dsi_is_enable(unsigned int id, u32 enable);
+
+#endif /* end of MIPI_DSI_H_ */
diff -Nupr a/drivers/video/rockchip/transmitter/rk2928_lvds.c b/drivers/video/rockchip/transmitter/rk2928_lvds.c
--- a/drivers/video/rockchip/transmitter/rk2928_lvds.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk2928_lvds.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,64 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <asm/io.h>
+#include <mach/io.h>
+#include <linux/rk_screen.h>
+#include "rk2928_lvds.h"
+
+static void rk_output_lvds(rk_screen *screen)
+{
+	LVDSWrReg(m_PDN_CBG(1)|m_PD_PLL(0)|m_PDN(1)|m_OEN(0) 	\
+					|m_DS(DS_10PF)|m_MSBSEL(DATA_D0_MSB) 	\
+					|m_OUT_FORMAT(screen->lvds_format) 		\
+					|m_LCDC_SEL(screen->lcdc_id));
+
+       printk("%s>>connect to lcdc output interface%d\n",__func__,screen->lcdc_id);
+}
+
+static void rk_output_lvttl(rk_screen *screen)
+{
+	LVDSWrReg(m_PDN_CBG(0)|m_PD_PLL(1)|m_PDN(0)|m_OEN(1) 	\
+					|m_DS(DS_10PF)|m_MSBSEL(DATA_D0_MSB) 	\
+					|m_OUT_FORMAT(screen->lvds_format) 		\
+					|m_LCDC_SEL(screen->lcdc_id));
+        printk("%s>>connect to lcdc output interface%d\n",__func__,screen->lcdc_id);
+}
+
+static void rk_output_disable(void)
+{
+	LVDSWrReg(m_PDN_CBG(0)|m_PD_PLL(1)|m_PDN(0)|m_OEN(0));
+        printk("%s: reg = 0x%x\n",  __func__, LVDSRdReg());
+}
+
+static int rk_lvds_set_param(rk_screen *screen,bool enable )
+{
+	if(OUT_ENABLE == enable){
+		switch(screen->type){
+			case SCREEN_LVDS:
+					rk_output_lvds(screen);
+                                        
+					break;
+			case SCREEN_RGB:
+					rk_output_lvttl(screen);
+					break;
+			default:
+				printk("%s>>>>LVDS not support this screen type %d,power down LVDS\n",__func__,screen->type);
+					rk_output_disable();
+					break;
+		}
+	}else{
+		rk_output_disable();
+	}
+	return 0;
+}
+
+int rk_lvds_register(rk_screen *screen)
+{
+	if(screen->sscreen_set == NULL)
+		screen->sscreen_set = rk_lvds_set_param;
+
+	rk_lvds_set_param(screen , OUT_ENABLE);
+
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/transmitter/rk2928_lvds.h b/drivers/video/rockchip/transmitter/rk2928_lvds.h
--- a/drivers/video/rockchip/transmitter/rk2928_lvds.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk2928_lvds.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef RK_LVDS_H_
+#define RK_LVDS_H
+
+#define LVDS_CON0_OFFSET 	0x150
+#define LVDS_CON0_REG 		(RK2928_GRF_BASE + LVDS_CON0_OFFSET) 
+
+#define LVDSRdReg()					__raw_readl(LVDS_CON0_REG)
+#define LVDSWrReg(val)       	__raw_writel( val ,LVDS_CON0_REG)
+
+#define m_value(x,offset,mask)      \
+			((mask<<(offset+16)) | (x&mask)<<offset)
+
+#define OEN 				(1<<9)
+#define m_OEN(x)   			m_value(x,9,1)
+#define PD_PLL 				(1<<8)
+#define m_PD_PLL(x) 		m_value(x,8,1)
+#define PDN_CBG 			(1<<7)
+#define m_PDN_CBG(x)		m_value(x,7,1)
+#define PDN 				(1<<6)
+#define m_PDN(x) 			m_value(x,6,1)
+#define DS 					(3<<4)
+#define m_DS(x) 			m_value(x,4,3)
+#define MSBSEL				(1<<3)
+#define m_MSBSEL(x)			m_value(x,3,1)
+#define OUT_FORMAT			(3<<1)
+#define m_OUT_FORMAT(x) 	m_value(x,1,3)
+#define LCDC_SEL			(1<<0)
+#define m_LCDC_SEL(x)		m_value(x,0,1)
+
+enum{
+	OUT_DISABLE=0,
+	OUT_ENABLE,
+};
+
+//DS
+#define DS_3PF 			0
+#define DS_7PF 			0
+#define DS_5PF 			0
+#define DS_10PF			0
+
+//LVDS lane input format
+#define DATA_D0_MSB    	0
+#define DATA_D7_MSB    	1
+//LVDS input source
+#define FROM_LCDC0     	0
+#define FROM_LCDC1 		1
+
+extern int rk_lvds_register(rk_screen *screen);
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/rk3026_lvds.c b/drivers/video/rockchip/transmitter/rk3026_lvds.c
--- a/drivers/video/rockchip/transmitter/rk3026_lvds.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk3026_lvds.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,147 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/rk_fb.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+
+#include <mach/board.h>
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+
+#include "rk3026_lvds.h"
+
+#define lvds_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
+#define lvds_writel(v,offset) 	do{ writel_relaxed(v, RK30_GRF_BASE + offset);dsb();} while (0)
+
+static void rk3026_output_lvds(rk_screen *screen)
+{
+	u32 val =0;
+
+	#if defined(CONFIG_LCDC0_RK3188)	
+		val |= LVDS_DATA_SEL(0);
+	#else
+		val |= LVDS_DATA_SEL(1);
+	#endif
+	
+	if(screen->lvds_format == 0 || screen->lvds_format == 1)
+		val |= LVDS_CBS_COL_SEL(2);  //24bit lvds
+	else
+		val |= LVDS_CBS_COL_SEL(1);  //16bit lvds
+
+	val |= ((LVDS_OUTPUT_FORMAT(screen->lvds_format))|LVDS_INPUT_FORMAT(1)|LVDS_OUTPUT_LOAD_SEL(0)|
+		LVDS_CBG_PWD_EN(1)|LVDS_PLL_PWD_EN(0)|LVDS_OUTPUT_EN(0)|LVDS_SWING_SEL(0));
+
+	val |= ((m_DATA_SEL|m_CBS_COL_SEL|m_OUTPUT_FORMAT|m_INPUT_FORMAT|m_OUTPUT_LOAD_SEL|
+		m_CBG_PWD_EN|m_PLL_PWD_EN|m_OUTPUT_EN|m_SWING_SEL)<<16);
+
+	lvds_writel(val,CRU_LVDS_CON0);
+	
+	return;
+}
+
+static void rk3026_output_lvttl(rk_screen *screen)
+{
+
+	u32 val =0;
+
+	val |= (LVDS_CBG_PWD_EN(0)|LVDS_PLL_PWD_EN(1)|LVDS_OUTPUT_EN(1));
+	val |= ((m_CBG_PWD_EN|m_PLL_PWD_EN|m_OUTPUT_EN)<<16);
+	
+	lvds_writel(val,CRU_LVDS_CON0);
+
+	return;			
+}
+
+static void rk3026_output_disable(void)
+{	
+
+	u32 val =0;
+
+	val |= (LVDS_CBG_PWD_EN(1)|LVDS_PLL_PWD_EN(0)|LVDS_OUTPUT_EN(0)|LVDS_CBS_COL_SEL(0));
+	val |= ((m_CBG_PWD_EN|m_PLL_PWD_EN|m_OUTPUT_EN|m_CBS_COL_SEL)<<16);
+
+	lvds_writel(val,CRU_LVDS_CON0);
+	
+}
+
+
+static int rk3026_lvds_set_param(rk_screen *screen,bool enable)
+{
+
+	if(OUT_ENABLE == enable){
+		switch(screen->type){
+			case SCREEN_LVDS:
+				rk3026_output_lvds(screen);                                       
+				break;
+			case SCREEN_RGB:
+				rk3026_output_lvttl(screen);
+				break;
+			default:
+			        printk("%s>>>>LVDS not support this screen type %d,power down LVDS\n",__func__,screen->type);
+				rk3026_output_disable();
+				break;
+		}
+	}else{
+		rk3026_output_disable();
+	}
+	return 0;
+}
+
+
+static int rk3026_lvds_probe(struct platform_device *pdev)
+{
+	rk_screen *screen = NULL;
+	screen = rk_fb_get_prmry_screen();
+	if(!screen)
+	{
+		dev_err(&pdev->dev,"the fb prmry screen is null!\n");
+		return -ENODEV;
+	}
+	
+	rk3026_lvds_set_param(screen,OUT_ENABLE);
+
+	return 0;
+	
+}
+
+static int rk3026_lvds_remove(struct platform_device *pdev)
+{	
+	return 0;
+}
+
+static void rk3026_lvds_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+static struct platform_driver rk3026_lvds_driver = {
+	.driver		= {
+		.name	= "rk3026-lvds",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= rk3026_lvds_probe,
+	.remove		= rk3026_lvds_remove,
+	.shutdown	= rk3026_lvds_shutdown,
+};
+
+static int __init rk3026_lvds_init(void)
+{
+	return platform_driver_register(&rk3026_lvds_driver);
+}
+fs_initcall(rk3026_lvds_init);
+static void __exit rk3026_lvds_exit(void)
+{
+	platform_driver_unregister(&rk3026_lvds_driver);
+}
+module_exit(rk3026_lvds_exit);
+
+
+
diff -Nupr a/drivers/video/rockchip/transmitter/rk3026_lvds.h b/drivers/video/rockchip/transmitter/rk3026_lvds.h
--- a/drivers/video/rockchip/transmitter/rk3026_lvds.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk3026_lvds.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include<linux/rk_screen.h>
+
+
+#define CRU_LVDS_CON0   	0x0150
+#define LVDS_SWING_SEL(x) 	(((x)&1)<<12)//0:250mv-450mv;1:150mv-250mv
+#define LVDS_CBS_COL_SEL(x)	(((x)&3)<<10)// 1:18-bit lvds 2:24-bit lvds;  3:all lvds power down
+#define LVDS_OUTPUT_EN(x)	(((x)&1)<<9) //0:lvds; 1:lvttl
+#define LVDS_PLL_PWD_EN(x)	(((x)&1)<<8) //0:enable; 1:disable
+#define LVDS_CBG_PWD_EN(x)	(((x)&1)<<7) //0:disable; 1:enable
+#define LVDS_OUTPUT_LOAD_SEL(X) (((X)&3)<<4) //0:3pf; 1:6pf;  2:10pf;  3:15pf
+#define LVDS_INPUT_FORMAT(x)	(((x)&1)<<3) //0:MSB is on D7; 1:MSB is on D0;
+#define LVDS_OUTPUT_FORMAT(x)	(((x)&3)<<1) //0:LVDS_8BIT_1;  1:LVDS_8BIT_2;  2:LVDS_8BIT_3;   3:LVDS_6BIT
+#define LVDS_DATA_SEL(x)	(((x)&1)<<0) //0:from lcdc; 1:from ebc;
+
+
+#define	m_SWING_SEL 		(1<<12)
+#define m_CBS_COL_SEL		(3<<10)
+#define m_OUTPUT_EN		(1<<9)
+#define m_PLL_PWD_EN		(1<<8)
+#define m_CBG_PWD_EN 		(1<<7)
+#define m_OUTPUT_LOAD_SEL 	(3<<4) 
+#define m_INPUT_FORMAT 		(1<<3)
+#define m_OUTPUT_FORMAT  	(3<<1)
+#define m_DATA_SEL 		(1<<0)
+
+
+enum{
+	OUT_DISABLE=0,
+	OUT_ENABLE,
+};
+
diff -Nupr a/drivers/video/rockchip/transmitter/rk31xx_lvds.c b/drivers/video/rockchip/transmitter/rk31xx_lvds.c
--- a/drivers/video/rockchip/transmitter/rk31xx_lvds.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk31xx_lvds.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,544 @@
+/*
+ * drivers/video/rockchip/transmitter/rk31xx_lvds.c
+ *
+ * Copyright (C) 2014 ROCKCHIP, Inc.
+ * Author: zhuangwenlong<zwl@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/rk_fb.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/rockchip/iomap.h>
+#include <linux/rockchip/grf.h>
+#include "rk31xx_lvds.h"
+
+
+#define grf_readl(offset)	readl_relaxed(RK_GRF_VIRT + offset)
+#define grf_writel(v,offset)                                    \
+        do {                                                    \
+                writel_relaxed(v, RK_GRF_VIRT + offset);        \
+		dsb(sy);                                        \
+        } while (0)
+
+
+static struct rk_lvds_device *rk31xx_lvds;
+
+static int rk31xx_lvds_clk_init(struct rk_lvds_device *lvds)
+{
+        lvds->pclk = devm_clk_get(lvds->dev, "pclk_lvds");
+	if (IS_ERR(lvds->pclk)) {
+		dev_err(lvds->dev, "get pclk failed\n");
+		return PTR_ERR(lvds->pclk);
+	}
+
+	lvds->ctrl_pclk = devm_clk_get(lvds->dev, "pclk_lvds_ctl");
+	if (IS_ERR(lvds->ctrl_pclk)) {
+		dev_err(lvds->dev, "get ctrl pclk failed\n");
+		return PTR_ERR(lvds->ctrl_pclk);
+	}
+
+	if (lvds->data->soc_type == LVDS_SOC_RK312X) {
+		lvds->ctrl_hclk = devm_clk_get(lvds->dev, "hclk_vio_h2p");
+		if (IS_ERR(lvds->ctrl_hclk)) {
+			dev_err(lvds->dev, "get ctrl hclk failed\n");
+			return PTR_ERR(lvds->ctrl_hclk);
+		}
+	} else {
+                lvds->pd = devm_clk_get(lvds->dev, "pd_lvds");
+		if (IS_ERR(lvds->pd)) {
+			dev_err(lvds->dev, "get pd_lvds failed\n");
+			lvds->pd = NULL;
+                }
+        }
+
+	return 0;	
+}
+
+static int rk31xx_lvds_clk_enable(struct rk_lvds_device *lvds)
+{
+	if (!lvds->clk_on) {
+		clk_prepare_enable(lvds->pclk);
+		clk_prepare_enable(lvds->ctrl_pclk);
+		if (lvds->data->soc_type == LVDS_SOC_RK312X)
+			clk_prepare_enable(lvds->ctrl_hclk);
+		if (lvds->pd)
+			clk_prepare_enable(lvds->pd);
+		lvds->clk_on = true;
+	}
+
+	return 0;
+}
+
+static int rk31xx_lvds_clk_disable(struct rk_lvds_device *lvds)
+{
+	if (lvds->clk_on) {
+		clk_disable_unprepare(lvds->pclk);
+		if (lvds->data->soc_type == LVDS_SOC_RK312X)
+			clk_disable_unprepare(lvds->ctrl_hclk);
+		if (lvds->pd)
+		        clk_disable_unprepare(lvds->pd);
+		clk_disable_unprepare(lvds->ctrl_pclk);
+		lvds->clk_on = false;
+	}
+
+	return 0;
+}
+
+static int rk31xx_lvds_pwr_on(void)
+{
+        struct rk_lvds_device *lvds = rk31xx_lvds;
+
+        if (lvds->screen.type == SCREEN_LVDS) {
+                /* set VOCM 900 mv and V-DIFF 350 mv */
+	        lvds_msk_reg(lvds, MIPIPHY_REGE4, m_VOCM | m_DIFF_V,
+			     v_VOCM(0) | v_DIFF_V(2));
+
+                /* power up lvds pll and ldo */
+	        lvds_msk_reg(lvds, MIPIPHY_REG1,
+	                     m_SYNC_RST | m_LDO_PWR_DOWN | m_PLL_PWR_DOWN,
+	                     v_SYNC_RST(0) | v_LDO_PWR_DOWN(0) | v_PLL_PWR_DOWN(0));
+
+		/* enable lvds lane and power on pll */
+		lvds_writel(lvds, MIPIPHY_REGEB,
+			    v_LANE0_EN(1) | v_LANE1_EN(1) | v_LANE2_EN(1) |
+			    v_LANE3_EN(1) | v_LANECLK_EN(1) | v_PLL_PWR_OFF(0));
+
+	        /* enable lvds */
+	        lvds_msk_reg(lvds, MIPIPHY_REGE3,
+	                     m_MIPI_EN | m_LVDS_EN | m_TTL_EN,
+	                     v_MIPI_EN(0) | v_LVDS_EN(1) | v_TTL_EN(0));
+        } else {
+                lvds_msk_reg(lvds, MIPIPHY_REGE3,
+	                     m_MIPI_EN | m_LVDS_EN | m_TTL_EN,
+	                     v_MIPI_EN(0) | v_LVDS_EN(0) | v_TTL_EN(1));
+        }
+        return 0;
+}
+
+static int rk31xx_lvds_pwr_off(void)
+{
+        struct rk_lvds_device *lvds = rk31xx_lvds;
+
+	/* disable lvds lane and power off pll */
+	lvds_writel(lvds, MIPIPHY_REGEB,
+		    v_LANE0_EN(0) | v_LANE1_EN(0) | v_LANE2_EN(0) |
+		    v_LANE3_EN(0) | v_LANECLK_EN(0) | v_PLL_PWR_OFF(1));
+
+	/* power down lvds pll and bandgap */
+	lvds_msk_reg(lvds, MIPIPHY_REG1,
+	             m_SYNC_RST | m_LDO_PWR_DOWN | m_PLL_PWR_DOWN,
+	             v_SYNC_RST(1) | v_LDO_PWR_DOWN(1) | v_PLL_PWR_DOWN(1));
+
+	/* disable lvds */
+	lvds_msk_reg(lvds, MIPIPHY_REGE3, m_LVDS_EN | m_TTL_EN,
+	             v_LVDS_EN(0) | v_TTL_EN(0));
+        return 0;
+}
+
+static int rk31xx_lvds_disable(void)
+{
+	struct rk_lvds_device *lvds = rk31xx_lvds;
+	u32 val;
+
+        if (unlikely(!lvds) || !lvds->sys_state)
+                return 0;
+	if (lvds->data->soc_type == LVDS_SOC_RK3368) {
+		val = v_RK3368_LVDSMODE_EN(0) | v_RK3368_MIPIPHY_TTL_EN(0);
+		lvds_grf_writel(lvds, RK3368_GRF_SOC_CON7_LVDS, val);
+	} else {
+		grf_writel(v_LVDSMODE_EN(0) | v_MIPIPHY_TTL_EN(0), RK312X_GRF_LVDS_CON0);
+	}
+
+	rk31xx_lvds_pwr_off();
+	rk31xx_lvds_clk_disable(lvds);
+
+#if !defined(CONFIG_RK_FPGA)
+#ifdef CONFIG_PINCTRL
+        if (lvds->screen.type == SCREEN_RGB) {
+                if (lvds->dev->pins) {
+                        pinctrl_select_state(lvds->dev->pins->p,
+                                             lvds->dev->pins->sleep_state);
+                } else if (lvds->pins && !IS_ERR(lvds->pins->sleep_state)) {
+                        pinctrl_select_state(lvds->pins->p,
+                                             lvds->pins->sleep_state);
+                }
+        }
+#endif
+#endif
+        lvds->sys_state = false;
+	return 0;
+}
+
+static void rk31xx_output_lvds(struct rk_lvds_device *lvds,
+                               struct rk_screen *screen)
+{
+	u32 val = 0;
+	u32 delay_times = 20;
+
+        /* if LVDS transmitter source from VOP, vop_dclk need get invert
+         * set iomux in dts pinctrl
+         */
+	if ((lvds->data->soc_type == LVDS_SOC_RK3368) ||
+	    (lvds->data->soc_type == LVDS_SOC_RK3366)) {
+		/* enable lvds mode */
+		val |= v_RK3368_LVDSMODE_EN(1) | v_RK3368_MIPIPHY_TTL_EN(0);
+		/* config data source */
+		/*val |= v_LVDS_DATA_SEL(LVDS_DATA_FROM_LCDC); */
+		/* config lvds_format */
+		val |= v_RK3368_LVDS_OUTPUT_FORMAT(screen->lvds_format);
+		/* LSB receive mode */
+		val |= v_RK3368_LVDS_MSBSEL(LVDS_MSB_D7);
+		val |= v_RK3368_MIPIPHY_LANE0_EN(1) |
+		       v_RK3368_MIPIDPI_FORCEX_EN(1);
+		/*rk3368  RK3368_GRF_SOC_CON7 = 0X0041C*/
+		/*grf_writel(val, 0x0041C);*/
+		if (lvds->data->soc_type == LVDS_SOC_RK3368)
+			lvds_grf_writel(lvds, RK3368_GRF_SOC_CON7_LVDS, val);
+		else
+			lvds_grf_writel(lvds, RK3366_GRF_SOC_CON5_LVDS, val);
+	} else {
+		/* enable lvds mode */
+		val |= v_LVDSMODE_EN(1) | v_MIPIPHY_TTL_EN(0);
+		/* config data source */
+		val |= v_LVDS_DATA_SEL(LVDS_DATA_FROM_LCDC);
+		/* config lvds_format */
+		val |= v_LVDS_OUTPUT_FORMAT(screen->lvds_format);
+		/* LSB receive mode */
+		val |= v_LVDS_MSBSEL(LVDS_MSB_D7);
+		val |= v_MIPIPHY_LANE0_EN(1) | v_MIPIDPI_FORCEX_EN(1);
+		/*rk312x  RK312X_GRF_LVDS_CON0 = 0X00150*/
+		grf_writel(val, 0X00150);
+	}
+	/* digital internal disable */
+	lvds_msk_reg(lvds, MIPIPHY_REGE1, m_DIG_INTER_EN, v_DIG_INTER_EN(0));
+
+        /* set pll prediv and fbdiv */
+	lvds_writel(lvds, MIPIPHY_REG3, v_PREDIV(2) | v_FBDIV_MSB(0));
+	lvds_writel(lvds, MIPIPHY_REG4, v_FBDIV_LSB(28));
+
+	lvds_writel(lvds, MIPIPHY_REGE8, 0xfc);
+
+        /* set lvds mode and reset phy config */
+	lvds_msk_reg(lvds, MIPIPHY_REGE0,
+                     m_MSB_SEL | m_DIG_INTER_RST,
+                     v_MSB_SEL(1) | v_DIG_INTER_RST(1));
+
+	/* power on pll and enable lane */
+	rk31xx_lvds_pwr_on();
+
+	/* delay for waitting pll lock on */
+	while (delay_times--) {
+		if (lvds_phy_lockon(lvds)) {
+			msleep(1);
+			break;
+		}
+		udelay(100);
+	}
+	/* digital internal enable */
+        lvds_msk_reg(lvds, MIPIPHY_REGE1, m_DIG_INTER_EN, v_DIG_INTER_EN(1));
+
+#if 0
+        lvds_writel(lvds, MIPIPHY_REGE2, 0xa0); /* timing */
+        lvds_writel(lvds, MIPIPHY_REGE7, 0xfc); /* phase */
+#endif
+
+}
+
+static void rk31xx_output_lvttl(struct rk_lvds_device *lvds,
+                                struct rk_screen *screen)
+{
+        u32 val = 0;
+
+	if ((lvds->data->soc_type == LVDS_SOC_RK3368) ||
+	    (lvds->data->soc_type == LVDS_SOC_RK3366)) {
+		/* iomux to lcdc */
+#ifdef CONFIG_PINCTRL
+		if (lvds->pins && !IS_ERR(lvds->pins->default_state))
+			pinctrl_select_state(lvds->pins->p,
+					     lvds->pins->default_state);
+#endif
+                lvds_dsi_writel(lvds, 0x0, 0x4);/*set clock lane enable*/
+		/* enable lvds mode */
+		val |= v_RK3368_LVDSMODE_EN(0) | v_RK3368_MIPIPHY_TTL_EN(1) |
+			v_RK3368_MIPIPHY_LANE0_EN(1) |
+			v_RK3368_MIPIDPI_FORCEX_EN(1);
+		if (lvds->data->soc_type == LVDS_SOC_RK3368) {
+			lvds_grf_writel(lvds, RK3368_GRF_SOC_CON7_LVDS, val);
+			val = v_RK3368_FORCE_JETAG(0);
+			lvds_grf_writel(lvds, RK3368_GRF_SOC_CON15_LVDS, val);
+		} else {
+			lvds_grf_writel(lvds, RK3366_GRF_SOC_CON5_LVDS, val);
+			val = v_RK3368_FORCE_JETAG(0);
+			lvds_grf_writel(lvds, RK3366_GRF_SOC_CON6_LVDS, val);
+		}
+		/*val = v_MIPITTL_CLK_EN(1) | v_MIPITTL_LANE0_EN(1) |
+		v_MIPITTL_LANE1_EN(1) | v_MIPITTL_LANE2_EN(1) |
+		v_MIPITTL_LANE3_EN(1);
+		grf_writel(val, RK312X_GRF_SOC_CON1);*/
+	} else {
+		/* iomux to lcdc */
+#if defined(CONFIG_RK_FPGA)
+		grf_writel(0xffff5555, RK312X_GRF_GPIO2B_IOMUX);
+		grf_writel(0x00ff0055, RK312X_GRF_GPIO2C_IOMUX);
+		grf_writel(0x77771111, 0x00e8); /* RK312X_GRF_GPIO2C_IOMUX2 */
+		grf_writel(0x700c1004, RK312X_GRF_GPIO2D_IOMUX);
+#else
+#ifdef CONFIG_PINCTRL
+		if (lvds->pins && !IS_ERR(lvds->pins->default_state))
+			pinctrl_select_state(lvds->pins->p,
+					     lvds->pins->default_state);
+#endif
+#endif
+		/* enable lvds mode */
+		val |= v_LVDSMODE_EN(0) | v_MIPIPHY_TTL_EN(1);
+		/* config data source */
+		val |= v_LVDS_DATA_SEL(LVDS_DATA_FROM_LCDC);
+		grf_writel(0xffff0380, RK312X_GRF_LVDS_CON0);
+
+		val = v_MIPITTL_CLK_EN(1) | v_MIPITTL_LANE0_EN(1) |
+			v_MIPITTL_LANE1_EN(1) | v_MIPITTL_LANE2_EN(1) |
+			v_MIPITTL_LANE3_EN(1);
+		grf_writel(val, RK312X_GRF_SOC_CON1);
+	}
+        /* enable lane */
+        lvds_writel(lvds, MIPIPHY_REG0, 0x7f);
+        val = v_LANE0_EN(1) | v_LANE1_EN(1) | v_LANE2_EN(1) | v_LANE3_EN(1) |
+                v_LANECLK_EN(1) | v_PLL_PWR_OFF(1);
+        lvds_writel(lvds, MIPIPHY_REGEB, val);
+
+        /* set ttl mode and reset phy config */
+        val = v_LVDS_MODE_EN(0) | v_TTL_MODE_EN(1) | v_MIPI_MODE_EN(0) |
+                v_MSB_SEL(1) | v_DIG_INTER_RST(1);
+	lvds_writel(lvds, MIPIPHY_REGE0, val);
+
+	rk31xx_lvds_pwr_on();
+		
+}
+
+static int rk31xx_lvds_en(void)
+{
+	struct rk_lvds_device *lvds = rk31xx_lvds;
+	struct rk_screen *screen;
+
+        if (unlikely(!lvds))//|| lvds->sys_state)
+                return 0;
+
+        screen = &lvds->screen;
+	rk_fb_get_prmry_screen(screen);
+
+	/* enable clk */
+	rk31xx_lvds_clk_enable(lvds);
+
+	switch (screen->type) {
+        case SCREEN_LVDS:
+		rk31xx_output_lvds(lvds, screen);
+                break;
+        case SCREEN_RGB:
+		rk31xx_output_lvttl(lvds, screen);
+                break;
+        default:
+                printk("unsupport screen type\n");
+                break;
+	}
+
+        lvds->sys_state = true;
+	return 0;
+}
+
+static struct rk_fb_trsm_ops trsm_lvds_ops = {
+	.enable = rk31xx_lvds_en,
+	.disable = rk31xx_lvds_disable,
+	.dsp_pwr_on = rk31xx_lvds_pwr_on,
+	.dsp_pwr_off = rk31xx_lvds_pwr_off,
+};
+#if defined(CONFIG_OF)
+static struct rk_lvds_drvdata rk31xx_lvds_drvdata = {
+	.soc_type =  LVDS_SOC_RK312X,
+};
+
+static struct rk_lvds_drvdata rk3368_lvds_drvdata = {
+	.soc_type =  LVDS_SOC_RK3368,
+};
+
+static struct rk_lvds_drvdata rk3366_lvds_drvdata = {
+	.soc_type =  LVDS_SOC_RK3366,
+};
+
+static const struct of_device_id rk31xx_lvds_dt_ids[] = {
+	{.compatible = "rockchip,rk31xx-lvds",
+	 .data = (void *)&rk31xx_lvds_drvdata,},
+	{.compatible = "rockchip,rk3368-lvds",
+	 .data = (void *)&rk3368_lvds_drvdata,},
+	{.compatible = "rockchip,rk3366-lvds",
+	 .data = (void *)&rk3366_lvds_drvdata,},
+	{}
+};
+
+/*MODULE_DEVICE_TABLE(of, rk31xx_lvds_dt_ids);*/
+
+#endif
+
+static int rk31xx_lvds_probe(struct platform_device *pdev)
+{
+        struct rk_lvds_device *lvds;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *match;
+        int ret = 0;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Don't find lvds device tree node.\n");
+		return -EINVAL;
+	}	
+
+        lvds = devm_kzalloc(&pdev->dev, sizeof(struct rk_lvds_device), GFP_KERNEL);
+	if (!lvds) {
+		dev_err(&pdev->dev, "kzalloc rk31xx lvds failed\n");
+		return -ENOMEM;
+	}
+	lvds->dev = &pdev->dev;
+	match = of_match_node(rk31xx_lvds_dt_ids, np);
+	lvds->data = (struct rk_lvds_drvdata *)match->data;
+	dev_info(lvds->dev, "%s,type=%d\n",
+		 __func__, lvds->data->soc_type);
+
+	rk_fb_get_prmry_screen(&lvds->screen);
+        if ((lvds->screen.type != SCREEN_RGB) && 
+		(lvds->screen.type != SCREEN_LVDS)) {
+		dev_err(&pdev->dev, "screen is not lvds/rgb!\n");
+		ret = -EINVAL;
+                goto err_screen_type;
+	}
+
+	platform_set_drvdata(pdev, lvds);
+	dev_set_name(lvds->dev, "rk31xx-lvds");
+
+#ifdef CONFIG_PINCTRL
+        if (lvds->dev->pins == NULL && lvds->screen.type == SCREEN_RGB) {
+                lvds->pins = devm_kzalloc(lvds->dev, sizeof(*(lvds->pins)),
+                                          GFP_KERNEL);
+                if (!lvds->pins) {
+                        dev_err(lvds->dev, "kzalloc lvds pins failed\n");
+                        return -ENOMEM;
+                }
+
+                lvds->pins->p = devm_pinctrl_get(lvds->dev);
+                if (IS_ERR(lvds->pins->p)) {
+                        dev_info(lvds->dev, "no pinctrl handle\n");
+                        devm_kfree(lvds->dev, lvds->pins);
+                        lvds->pins = NULL;
+                } else {
+                        lvds->pins->default_state =
+                                pinctrl_lookup_state(lvds->pins->p, "lcdc");
+                        lvds->pins->sleep_state =
+                                pinctrl_lookup_state(lvds->pins->p, "sleep");
+                        if (IS_ERR(lvds->pins->default_state)) {
+                                dev_info(lvds->dev, "no default pinctrl state\n");
+                                devm_kfree(lvds->dev, lvds->pins);
+                                lvds->pins = NULL;
+                        }
+                }
+        }
+
+#endif
+        /* lvds regs on MIPIPHY_REG */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_lvds_phy");
+	lvds->regbase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(lvds->regbase)) {
+		dev_err(&pdev->dev, "ioremap mipi-lvds phy reg failed\n");
+		return PTR_ERR(lvds->regbase);
+	}
+
+	/* pll lock on status reg that is MIPICTRL Register */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_lvds_ctl");
+	lvds->ctrl_reg = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(lvds->ctrl_reg)) {
+		dev_err(&pdev->dev, "ioremap mipi-lvds ctl reg failed\n");
+		return PTR_ERR(lvds->ctrl_reg);
+	}
+#ifdef CONFIG_MFD_SYSCON
+	if ((lvds->data->soc_type == LVDS_SOC_RK3368) ||
+	    (lvds->data->soc_type == LVDS_SOC_RK3366)) {
+		lvds->grf_lvds_base =
+			syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+		if (IS_ERR(lvds->grf_lvds_base)) {
+			dev_err(&pdev->dev, "can't find rockchip,grf property\n");
+			return PTR_ERR(lvds->grf_lvds_base);
+		}
+	}
+#endif
+	ret = rk31xx_lvds_clk_init(lvds);
+	if(ret < 0)
+		goto err_clk_init;
+
+	if (support_uboot_display()) {
+		rk31xx_lvds_clk_enable(lvds);
+		/*lvds->sys_state = true;*/
+	}
+
+	rk31xx_lvds = lvds;
+	rk_fb_trsm_ops_register(&trsm_lvds_ops, SCREEN_LVDS);
+	dev_info(&pdev->dev, "rk31xx lvds driver probe success\n");
+
+	return 0;
+
+err_clk_init:
+err_screen_type:
+        devm_kfree(&pdev->dev, lvds);
+        lvds = NULL;
+        return ret;	
+}
+
+static int rk31xx_lvds_remove(struct platform_device *pdev)
+{	
+	return 0;
+}
+
+static void rk31xx_lvds_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+
+static struct platform_driver rk31xx_lvds_driver = {
+	.driver		= {
+		.name	= "rk31xx-lvds",
+		.owner	= THIS_MODULE,
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(rk31xx_lvds_dt_ids),
+#endif
+	},
+	.probe		= rk31xx_lvds_probe,
+	.remove		= rk31xx_lvds_remove,
+	.shutdown	= rk31xx_lvds_shutdown,
+};
+
+static int __init rk31xx_lvds_init(void)
+{
+	return platform_driver_register(&rk31xx_lvds_driver);
+}
+
+static void __exit rk31xx_lvds_exit(void)
+{
+	platform_driver_unregister(&rk31xx_lvds_driver);
+}
+
+fs_initcall(rk31xx_lvds_init);
+module_exit(rk31xx_lvds_exit);
+
diff -Nupr a/drivers/video/rockchip/transmitter/rk31xx_lvds.h b/drivers/video/rockchip/transmitter/rk31xx_lvds.h
--- a/drivers/video/rockchip/transmitter/rk31xx_lvds.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk31xx_lvds.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,203 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RK31XX_LVDS_H_
+#define _RK31XX_LVDS_H_
+
+#include <linux/rk_screen.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#define BITS(x, bit)            ((x) << (bit))
+#define BITS_MASK(x, mask, bit)  BITS((x) & (mask), bit)
+#define BITS_EN(mask, bit)       BITS(mask, bit + 16)
+
+/* RK312X_GRF_LVDS_CON0 */
+#define v_LVDS_DATA_SEL(x)      (BITS_MASK(x, 1, 0) | BITS_EN(1, 0))
+#define v_LVDS_OUTPUT_FORMAT(x) (BITS_MASK(x, 3, 1) | BITS_EN(3, 1))
+#define v_LVDS_MSBSEL(x)        (BITS_MASK(x, 1, 3) | BITS_EN(1, 3))
+#define v_LVDSMODE_EN(x)        (BITS_MASK(x, 1, 6) | BITS_EN(1, 6))
+#define v_MIPIPHY_TTL_EN(x)     (BITS_MASK(x, 1, 7) | BITS_EN(1, 7))
+#define v_MIPIPHY_LANE0_EN(x)   (BITS_MASK(x, 1, 8) | BITS_EN(1, 8))
+#define v_MIPIDPI_FORCEX_EN(x)  (BITS_MASK(x, 1, 9) | BITS_EN(1, 9))
+
+/* RK3368_GRF_SOC_CON7 0x41c*/
+/* RK3366_GRF_SOC_CON5 0x414*/
+#define v_RK3368_LVDS_OUTPUT_FORMAT(x) (BITS_MASK(x, 3, 13) | BITS_EN(3, 13))
+#define v_RK3368_LVDS_MSBSEL(x)        (BITS_MASK(x, 1, 11) | BITS_EN(1, 11))
+#define v_RK3368_LVDSMODE_EN(x)        (BITS_MASK(x, 1, 12) | BITS_EN(1, 12))
+#define v_RK3368_MIPIPHY_TTL_EN(x)     (BITS_MASK(x, 1, 15) | BITS_EN(1, 15))
+#define v_RK3368_MIPIPHY_LANE0_EN(x)   (BITS_MASK(x, 1, 5) | BITS_EN(1, 5))
+#define v_RK3368_MIPIDPI_FORCEX_EN(x)  (BITS_MASK(x, 1, 6) | BITS_EN(1, 6))
+enum {
+        LVDS_DATA_FROM_LCDC = 0,
+        LVDS_DATA_FORM_EBC,
+};
+
+enum {
+        LVDS_MSB_D0 = 0,
+        LVDS_MSB_D7,
+};
+
+/* RK312X_GRF_SOC_CON1 */
+#define v_MIPITTL_CLK_EN(x)     (BITS_MASK(x, 1, 7) | BITS_EN(1, 7))
+#define v_MIPITTL_LANE0_EN(x)   (BITS_MASK(x, 1, 11) | BITS_EN(1, 11))
+#define v_MIPITTL_LANE1_EN(x)   (BITS_MASK(x, 1, 12) | BITS_EN(1, 12))
+#define v_MIPITTL_LANE2_EN(x)   (BITS_MASK(x, 1, 13) | BITS_EN(1, 13))
+#define v_MIPITTL_LANE3_EN(x)   (BITS_MASK(x, 1, 14) | BITS_EN(1, 14))
+
+
+#define MIPIPHY_REG0            0x0000
+#define m_LANE_EN_0             BITS(1, 2)
+#define m_LANE_EN_1             BITS(1, 3)
+#define m_LANE_EN_2             BITS(1, 4)
+#define m_LANE_EN_3             BITS(1, 5)
+#define m_LANE_EN_CLK           BITS(1, 5)
+#define v_LANE_EN_0(x)          BITS(1, 2)
+#define v_LANE_EN_1(x)          BITS(1, 3)
+#define v_LANE_EN_2(x)          BITS(1, 4)
+#define v_LANE_EN_3(x)          BITS(1, 5)
+#define v_LANE_EN_CLK(x)        BITS(1, 5)
+
+#define MIPIPHY_REG1            0x0004
+#define m_SYNC_RST              BITS(1, 0)
+#define m_LDO_PWR_DOWN          BITS(1, 1)
+#define m_PLL_PWR_DOWN          BITS(1, 2)
+#define v_SYNC_RST(x)           BITS_MASK(x, 1, 0)
+#define v_LDO_PWR_DOWN(x)       BITS_MASK(x, 1, 1)
+#define v_PLL_PWR_DOWN(x)       BITS_MASK(x, 1, 2)
+
+#define MIPIPHY_REG3		0x000c
+#define m_PREDIV                BITS(0x1f, 0)
+#define m_FBDIV_MSB             BITS(1, 5)
+#define v_PREDIV(x)             BITS_MASK(x, 0x1f, 0)
+#define v_FBDIV_MSB(x)          BITS_MASK(x, 1, 5)
+
+#define MIPIPHY_REG4		0x0010
+#define v_FBDIV_LSB(x)          BITS_MASK(x, 0xff, 0)
+
+#define MIPIPHY_REGE0		0x0380
+#define m_MSB_SEL               BITS(1, 0)
+#define m_DIG_INTER_RST         BITS(1, 2)
+#define m_LVDS_MODE_EN          BITS(1, 5)
+#define m_TTL_MODE_EN           BITS(1, 6)
+#define m_MIPI_MODE_EN          BITS(1, 7)
+#define v_MSB_SEL(x)            BITS_MASK(x, 1, 0)
+#define v_DIG_INTER_RST(x)      BITS_MASK(x, 1, 2)
+#define v_LVDS_MODE_EN(x)       BITS_MASK(x, 1, 5)
+#define v_TTL_MODE_EN(x)        BITS_MASK(x, 1, 6)
+#define v_MIPI_MODE_EN(x)       BITS_MASK(x, 1, 7)
+
+#define MIPIPHY_REGE1           0x0384
+#define m_DIG_INTER_EN          BITS(1, 7)
+#define v_DIG_INTER_EN(x)       BITS_MASK(x, 1, 7)
+
+#define MIPIPHY_REGE3           0x038c
+#define m_MIPI_EN               BITS(1, 0)
+#define m_LVDS_EN               BITS(1, 1)
+#define m_TTL_EN                BITS(1, 2)
+#define v_MIPI_EN(x)            BITS_MASK(x, 1, 0)
+#define v_LVDS_EN(x)            BITS_MASK(x, 1, 1)
+#define v_TTL_EN(x)             BITS_MASK(x, 1, 2)
+
+#define MIPIPHY_REGE4		0x0390
+#define m_VOCM			BITS(3, 4)
+#define m_DIFF_V		BITS(3, 6)
+
+#define v_VOCM(x)		BITS_MASK(x, 3, 4)
+#define v_DIFF_V(x)		BITS_MASK(x, 3, 6)
+
+#define MIPIPHY_REGE8           0x03a0
+
+#define MIPIPHY_REGEB           0x03ac
+#define v_PLL_PWR_OFF(x)        BITS_MASK(x, 1, 2)
+#define v_LANECLK_EN(x)         BITS_MASK(x, 1, 3)
+#define v_LANE3_EN(x)           BITS_MASK(x, 1, 4)
+#define v_LANE2_EN(x)           BITS_MASK(x, 1, 5)
+#define v_LANE1_EN(x)           BITS_MASK(x, 1, 6)
+#define v_LANE0_EN(x)           BITS_MASK(x, 1, 7)
+
+#define RK3368_GRF_SOC_CON7_LVDS	0x041c
+#define RK3368_GRF_SOC_CON15_LVDS	0x043c
+#define RK3366_GRF_SOC_CON5_LVDS	0x0414
+#define RK3366_GRF_SOC_CON6_LVDS	0x0418
+#define v_RK3368_FORCE_JETAG(x) (BITS_MASK(x, 1, 13) | BITS_EN(1, 13))
+
+enum {
+	LVDS_SOC_RK312X,
+	LVDS_SOC_RK3368,
+	LVDS_SOC_RK3366
+};
+
+struct rk_lvds_drvdata  {
+	u8 soc_type;
+	u32 reversed;
+};
+
+struct rk_lvds_device {
+	struct rk_lvds_drvdata *data;
+	struct device 		*dev;
+	void __iomem  		*regbase;
+	void __iomem		*ctrl_reg;
+	struct regmap		*grf_lvds_base;
+	struct clk    		*pd;  /*power domain*/
+	struct clk    		*pclk;  /*phb clk*/
+	struct clk    		*ctrl_pclk;	/* mipi ctrl pclk*/
+	struct clk    		*ctrl_hclk;	/* mipi ctrl hclk*/
+	struct rk_screen	screen;
+	bool			clk_on;
+        bool                    sys_state;
+#ifdef CONFIG_PINCTRL
+	struct dev_pin_info	*pins;
+#endif
+};
+
+static inline int lvds_writel(struct rk_lvds_device *lvds, u32 offset, u32 val)
+{
+	writel_relaxed(val, lvds->regbase + offset);
+	return 0;
+}
+
+static inline int lvds_msk_reg(struct rk_lvds_device *lvds, u32 offset,
+			       u32 msk, u32 val)
+{
+	u32 temp;
+
+	temp = readl_relaxed(lvds->regbase + offset) & (0xFF - (msk));
+	writel_relaxed(temp | ((val) & (msk)), lvds->regbase + offset);
+	return 0;
+}
+
+static inline u32 lvds_readl(struct rk_lvds_device *lvds, u32 offset)
+{
+	return readl_relaxed(lvds->regbase + offset);
+}
+
+static inline int lvds_grf_writel(struct rk_lvds_device *lvds,
+				  u32 offset, u32 val)
+{
+	regmap_write(lvds->grf_lvds_base, offset, val);
+	dsb(sy);
+
+	return 0;
+}
+
+static inline int lvds_dsi_writel(struct rk_lvds_device *lvds,
+				  u32 offset, u32 val)
+{
+	writel_relaxed(val, lvds->ctrl_reg + offset);
+	dsb(sy);
+
+	return 0;
+}
+
+static inline u32 lvds_phy_lockon(struct rk_lvds_device *lvds)
+{
+	u32 val = 0;
+	if (lvds->data->soc_type == LVDS_SOC_RK312X)
+		val = readl_relaxed(lvds->ctrl_reg);
+	else
+		val = readl_relaxed(lvds->ctrl_reg + 0x10);
+	return (val & 0x01);
+}
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/transmitter/rk32_dp.c b/drivers/video/rockchip/transmitter/rk32_dp.c
--- a/drivers/video/rockchip/transmitter/rk32_dp.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk32_dp.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1920 @@
+/*
+ * DisplayPort driver for rk32xx
+ *
+ * Copyright (C) ROCKCHIP, Inc.
+ *Author:yxj<yxj@rock-chips.com>
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/grf.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#if defined(CONFIG_OF)
+#include <linux/of.h>
+#include <linux/of_device.h>
+#endif
+
+#if defined(CONFIG_DEBUG_FS)
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#endif
+
+#include "rk32_dp.h"
+
+/*#define EDP_BIST_MODE*/
+/*#define SW_LT*/
+
+#define RK3368_GRF_SOC_CON4	0x410
+#define RK3399_GRF_SOC_CON20	0x6250
+
+static struct rk32_edp *rk32_edp;
+
+static int rk32_edp_clk_enable(struct rk32_edp *edp)
+{
+	int ret;
+
+	if (!edp->clk_on) {
+		if (edp->pd)
+			clk_prepare_enable(edp->pd);
+		clk_prepare_enable(edp->pclk);
+		clk_prepare_enable(edp->clk_edp);
+
+		if (edp->soctype != SOC_RK3399) {
+			ret = clk_set_rate(edp->clk_24m, 24000000);
+			if (ret < 0)
+				pr_err("cannot set edp clk_24m %d\n", ret);
+			clk_prepare_enable(edp->clk_24m);
+		}
+		edp->clk_on = true;
+	}
+
+	return 0;
+}
+
+static int rk32_edp_clk_disable(struct rk32_edp *edp)
+{
+	if (edp->clk_on) {
+		clk_disable_unprepare(edp->pclk);
+		clk_disable_unprepare(edp->clk_edp);
+
+		if (edp->soctype != SOC_RK3399)
+			clk_disable_unprepare(edp->clk_24m);
+
+		if (edp->pd)
+			clk_disable_unprepare(edp->pd);
+		edp->clk_on = false;
+	}
+
+	return 0;
+}
+
+static int rk32_edp_pre_init(struct rk32_edp *edp)
+{
+	u32 val;
+
+	if (cpu_is_rk3288()) {
+#if 0
+		val = GRF_EDP_REF_CLK_SEL_INTER |
+			(GRF_EDP_REF_CLK_SEL_INTER << 16);
+		writel_relaxed(val, RK_GRF_VIRT + RK3288_GRF_SOC_CON12);
+
+		val = 0x80008000;
+		writel_relaxed(val, RK_CRU_VIRT + 0x01d0); /*reset edp*/
+		dsb(sy);
+		udelay(1);
+		val = 0x80000000;
+		writel_relaxed(val, RK_CRU_VIRT + 0x01d0);
+		dsb(sy);
+		udelay(1);
+#endif
+	} else {
+		/* The rk3368 reset the edp 24M clock and apb bus
+		 * according to the CRU_SOFTRST6_CON and CRU_SOFTRST7_CON.
+		 */
+		if (edp->soctype != SOC_RK3399) {
+			val = 0x01 | (0x01 << 16);
+			regmap_write(edp->grf, RK3368_GRF_SOC_CON4, val);
+
+			reset_control_assert(edp->rst_24m);
+			usleep_range(10, 20);
+			reset_control_deassert(edp->rst_24m);
+		}
+
+		reset_control_assert(edp->rst_apb);
+		usleep_range(10, 20);
+		reset_control_deassert(edp->rst_apb);
+	}
+	return 0;
+}
+
+static int rk32_edp_init_edp(struct rk32_edp *edp)
+{
+	struct rk_screen *screen = &edp->screen;
+	u32 val = 0;
+
+	rk_fb_get_prmry_screen(screen);
+
+	if (cpu_is_rk3288()) {
+#if 0
+		if (screen->lcdc_id == 1)  /*select lcdc*/
+			val = EDP_SEL_VOP_LIT | (EDP_SEL_VOP_LIT << 16);
+		else
+			val = EDP_SEL_VOP_LIT << 16;
+		writel_relaxed(val, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
+#endif
+	}
+
+	if (edp->soctype == SOC_RK3399) {
+		if (screen->lcdc_id == 1)  /*select lcdc*/
+			val = EDP_SEL_VOP_LIT | (EDP_SEL_VOP_LIT << 16);
+		else
+			val = EDP_SEL_VOP_LIT << 16;
+		clk_prepare_enable(edp->grf_clk);
+		regmap_write(edp->grf, RK3399_GRF_SOC_CON20, val);
+		clk_disable_unprepare(edp->grf_clk);
+	}
+
+	rk32_edp_reset(edp);
+	rk32_edp_init_refclk(edp);
+	rk32_edp_init_interrupt(edp);
+	rk32_edp_enable_sw_function(edp);
+	rk32_edp_init_analog_func(edp);
+	rk32_edp_init_hpd(edp);
+	rk32_edp_init_aux(edp);
+
+	return 0;
+}
+
+/*#if 0
+static int rk32_edp_detect_hpd(struct rk32_edp *edp)
+{
+	int timeout_loop = 0;
+
+	rk32_edp_init_hpd(edp);
+
+	udelay(200);
+
+	while (rk32_edp_get_plug_in_status(edp) != 0) {
+		timeout_loop++;
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(edp->dev, "failed to get hpd plug status\n");
+			return -ETIMEDOUT;
+		}
+		udelay(10);
+	}
+
+	return 0;
+}
+#endif*/
+
+static int rk32_edp_read_edid(struct rk32_edp *edp)
+{
+	unsigned char edid[EDID_LENGTH * 2];
+	unsigned int extend_block = 0;
+	unsigned char sum;
+	unsigned char test_vector;
+	int retval;
+
+	/*
+	 * EDID device address is 0x50.
+	 * However, if necessary, you must have set upper address
+	 * into E-EDID in I2C device, 0x30.
+	 */
+
+	/* Read Extension Flag, Number of 128-byte EDID extension blocks */
+	retval = rk32_edp_read_byte_from_i2c
+			(edp,
+			 EDID_ADDR, EDID_EXTENSION_FLAG, &extend_block);
+	if (retval < 0) {
+		dev_err(edp->dev, "EDID extension flag failed!\n");
+		return -EIO;
+	}
+
+	if (extend_block > 0) {
+		dev_dbg(edp->dev, "EDID data includes a single extension!\n");
+
+		/* Read EDID data */
+		retval = rk32_edp_read_bytes_from_i2c
+			       (edp,
+				EDID_ADDR, EDID_HEADER,
+				EDID_LENGTH, &edid[EDID_HEADER]);
+		if (retval != 0) {
+			dev_err(edp->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		sum = edp_calc_edid_check_sum(edid);
+		if (sum != 0) {
+			dev_warn(edp->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		/* Read additional EDID data */
+		retval = rk32_edp_read_bytes_from_i2c
+			       (edp,
+				EDID_ADDR, EDID_LENGTH,
+				EDID_LENGTH, &edid[EDID_LENGTH]);
+		if (retval != 0) {
+			dev_err(edp->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		sum = edp_calc_edid_check_sum(&edid[EDID_LENGTH]);
+		if (sum != 0) {
+			dev_warn(edp->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		retval = rk32_edp_read_byte_from_dpcd
+				(edp,
+				 DPCD_TEST_REQUEST, &test_vector);
+		if (retval < 0) {
+			dev_err(edp->dev, "DPCD EDID Read failed!\n");
+			return retval;
+		}
+
+		if (test_vector & DPCD_TEST_EDID_READ) {
+			retval = rk32_edp_write_byte_to_dpcd
+				       (edp,
+					DPCD_TEST_EDID_CHECKSUM,
+					edid[EDID_LENGTH + EDID_CHECKSUM]);
+			if (retval < 0) {
+				dev_err(edp->dev, "DPCD EDID Write failed!\n");
+				return retval;
+			}
+			retval = rk32_edp_write_byte_to_dpcd
+				       (edp,
+					DPCD_TEST_RESPONSE,
+					DPCD_TEST_EDID_CHECKSUM_WRITE);
+			if (retval < 0) {
+				dev_err(edp->dev, "DPCD EDID checksum failed!\n");
+				return retval;
+			}
+		}
+	} else {
+		dev_info(edp->dev, "EDID data does not include any extensions.\n");
+
+		/* Read EDID data */
+		retval = rk32_edp_read_bytes_from_i2c
+			       (edp,
+				EDID_ADDR, EDID_HEADER,
+				EDID_LENGTH, &edid[EDID_HEADER]);
+		if (retval != 0) {
+			dev_err(edp->dev, "EDID Read failed!\n");
+			return -EIO;
+		}
+		sum = edp_calc_edid_check_sum(edid);
+		if (sum != 0) {
+			dev_warn(edp->dev, "EDID bad checksum!\n");
+			return 0;
+		}
+
+		retval = rk32_edp_read_byte_from_dpcd
+				(edp,
+				 DPCD_TEST_REQUEST, &test_vector);
+		if (retval < 0) {
+			dev_err(edp->dev, "DPCD EDID Read failed!\n");
+			return retval;
+		}
+
+		if (test_vector & DPCD_TEST_EDID_READ) {
+			retval = rk32_edp_write_byte_to_dpcd
+					(edp,
+					 DPCD_TEST_EDID_CHECKSUM,
+					 edid[EDID_CHECKSUM]);
+			if (retval < 0) {
+				dev_err(edp->dev, "DPCD EDID Write failed!\n");
+				return retval;
+			}
+			retval = rk32_edp_write_byte_to_dpcd
+				       (edp,
+					DPCD_TEST_RESPONSE,
+					DPCD_TEST_EDID_CHECKSUM_WRITE);
+			if (retval < 0) {
+				dev_err(edp->dev, "DPCD EDID checksum failed!\n");
+				return retval;
+			}
+		}
+	}
+	fb_edid_to_monspecs(edid, &edp->specs);
+	dev_err(edp->dev, "EDID Read success!\n");
+	return 0;
+}
+#define open_t 0
+#if open_t
+static int rk32_edp_handle_edid(struct rk32_edp *edp)
+{
+	u8 buf[12];
+	int i;
+	int retval;
+
+	/* Read DPCD DPCD_ADDR_DPCD_REV~RECEIVE_PORT1_CAP_1 */
+	retval = rk32_edp_read_bytes_from_dpcd(edp, DPCD_REV, 12, buf);
+	if (retval < 0)
+		return retval;
+
+	for (i = 0; i < 12; i++)
+		dev_info(edp->dev, "%d:>>0x%02x\n", i, buf[i]);
+	/* Read EDID */
+	for (i = 0; i < 3; i++) {
+		retval = rk32_edp_read_edid(edp);
+		if (retval == 0)
+			break;
+	}
+
+	return retval;
+}
+
+
+static int rk32_edp_enable_rx_to_enhanced_mode(struct rk32_edp *edp,
+					       bool enable)
+{
+	u8 data;
+	int retval;
+
+	retval = rk32_edp_read_byte_from_dpcd
+			(edp,
+			 DPCD_LANE_CNT_SET, &data);
+	if (retval < 0)
+		return retval;
+
+	if (enable) {
+		retval = rk32_edp_write_byte_to_dpcd
+				(edp,
+				 DPCD_LANE_CNT_SET,
+				 DPCD_ENHANCED_FRAME_EN |
+				 DPCD_LANE_COUNT_SET(data));
+	} else {
+		/*retval = rk32_edp_write_byte_to_dpcd(edp,
+				DPCD_ADDR_CONFIGURATION_SET, 0);*/
+
+		retval = rk32_edp_write_byte_to_dpcd
+				(edp,
+				 DPCD_LANE_CNT_SET,
+				 DPCD_LANE_COUNT_SET(data));
+	}
+
+	return retval;
+}
+
+void rk32_edp_rx_control(struct rk32_edp *edp, bool enable)
+{
+	/*rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED1,0);
+	rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED2,0x90);
+
+	if (enable) {
+		rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED3,0x84);
+		rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED3,0x00);
+	} else {
+		rk32_edp_write_byte_to_dpcd(edp, DPCD_ADDR_USER_DEFINED3,0x80);
+	}*/
+}
+
+
+static int rk32_edp_is_enhanced_mode_available(struct rk32_edp *edp)
+{
+	u8 data;
+	int retval;
+
+	retval = rk32_edp_read_byte_from_dpcd
+			(edp,
+			 DPCD_MAX_LANE_CNT, &data);
+	if (retval < 0)
+		return retval;
+
+	return DPCD_ENHANCED_FRAME_CAP(data);
+}
+
+
+static void rk32_edp_disable_rx_zmux(struct rk32_edp *edp)
+{
+	/*rk32_edp_write_byte_to_dpcd(edp,
+			DPCD_ADDR_USER_DEFINED1, 0);
+	rk32_edp_write_byte_to_dpcd(edp,
+			DPCD_ADDR_USER_DEFINED2, 0x83);
+	rk32_edp_write_byte_to_dpcd(edp,
+			DPCD_ADDR_USER_DEFINED3, 0x27);*/
+}
+
+static int rk32_edp_set_enhanced_mode(struct rk32_edp *edp)
+{
+	u8 data;
+	int retval;
+
+	retval = rk32_edp_is_enhanced_mode_available(edp);
+	if (retval < 0)
+		return retval;
+
+	data = (u8)retval;
+	retval = rk32_edp_enable_rx_to_enhanced_mode(edp, data);
+	if (retval < 0)
+		return retval;
+
+	rk32_edp_enable_enhanced_mode(edp, data);
+
+	return 0;
+}
+#endif
+
+
+#if defined(SW_LT)
+static int rk32_edp_training_pattern_dis(struct rk32_edp *edp)
+{
+	int retval;
+
+	rk32_edp_set_training_pattern(edp, DP_NONE);
+
+	retval = rk32_edp_write_byte_to_dpcd(edp,
+					     DPCD_TRAINING_PATTERN_SET,
+					     DPCD_TRAINING_PATTERN_DISABLED);
+	if (retval < 0)
+		return retval;
+
+	return 0;
+}
+
+static void rk32_edp_set_lane_lane_pre_emphasis(struct rk32_edp *edp,
+						int pre_emphasis, int lane)
+{
+	switch (lane) {
+	case 0:
+		rk32_edp_set_lane0_pre_emphasis(edp, pre_emphasis);
+		break;
+	case 1:
+		rk32_edp_set_lane1_pre_emphasis(edp, pre_emphasis);
+		break;
+
+	case 2:
+		rk32_edp_set_lane2_pre_emphasis(edp, pre_emphasis);
+		break;
+
+	case 3:
+		rk32_edp_set_lane3_pre_emphasis(edp, pre_emphasis);
+		break;
+	}
+}
+
+static int rk32_edp_link_start(struct rk32_edp *edp)
+{
+	u8 buf[4];
+	int lane;
+	int lane_count;
+	int retval;
+
+	lane_count = edp->link_train.lane_count;
+
+	edp->link_train.lt_state = LT_CLK_RECOVERY;
+	edp->link_train.eq_loop = 0;
+
+	for (lane = 0; lane < lane_count; lane++)
+		edp->link_train.cr_loop[lane] = 0;
+
+	/* Set sink to D0 (Sink Not Ready) mode. */
+	retval = rk32_edp_write_byte_to_dpcd(edp, DPCD_SINK_POWER_STATE,
+					     DPCD_SET_POWER_STATE_D0);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to set sink device to D0!\n");
+		return retval;
+	}
+
+	/* Set link rate and count as you want to establish*/
+	rk32_edp_set_link_bandwidth(edp, edp->link_train.link_rate);
+	rk32_edp_set_lane_count(edp, edp->link_train.lane_count);
+
+	/* Setup RX configuration */
+	buf[0] = edp->link_train.link_rate;
+	buf[1] = edp->link_train.lane_count;
+	retval = rk32_edp_write_bytes_to_dpcd(edp, DPCD_LINK_BW_SET,
+					      2, buf);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to set bandwidth and lane count!\n");
+		return retval;
+	}
+
+	/* Set TX pre-emphasis to level1 */
+	for (lane = 0; lane < lane_count; lane++)
+		rk32_edp_set_lane_lane_pre_emphasis
+			(edp,
+			 PRE_EMPHASIS_LEVEL_1, lane);
+
+	/* Set training pattern 1 */
+	rk32_edp_set_training_pattern(edp, TRAINING_PTN1);
+
+	/* Set RX training pattern */
+	retval = rk32_edp_write_byte_to_dpcd(edp,
+					     DPCD_TRAINING_PATTERN_SET,
+					     DPCD_SCRAMBLING_DISABLED |
+					     DPCD_TRAINING_PATTERN_1);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to set training pattern 1!\n");
+		return retval;
+	}
+
+	for (lane = 0; lane < lane_count; lane++)
+		buf[lane] = DPCD_PRE_EMPHASIS_PATTERN2_LEVEL0 |
+			    DPCD_VOLTAGE_SWING_PATTERN1_LEVEL0;
+	retval = rk32_edp_write_bytes_to_dpcd(edp,
+					      DPCD_TRAINING_LANE0_SET,
+					      lane_count, buf);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to set training lane!\n");
+		return retval;
+	}
+
+	return 0;
+}
+
+static unsigned char rk32_edp_get_lane_status(u8 link_status[2], int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = link_status[lane>>1];
+
+	return (link_value >> shift) & 0xf;
+}
+
+static int rk32_edp_clock_recovery_ok(u8 link_status[2], int lane_count)
+{
+	int lane;
+	u8 lane_status;
+
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = rk32_edp_get_lane_status(link_status, lane);
+		if ((lane_status & DPCD_LANE_CR_DONE) == 0)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int rk32_edp_channel_eq_ok(u8 link_align[3], int lane_count)
+{
+	int lane;
+	u8 lane_align;
+	u8 lane_status;
+
+	lane_align = link_align[2];
+	if ((lane_align & DPCD_INTERLANE_ALIGN_DONE) == 0)
+		return -EINVAL;
+
+	for (lane = 0; lane < lane_count; lane++) {
+		lane_status = rk32_edp_get_lane_status(link_align, lane);
+		lane_status &= DPCD_CHANNEL_EQ_BITS;
+		if (lane_status != DPCD_CHANNEL_EQ_BITS)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned char rk32_edp_get_adjust_request_voltage(u8 adjust_request[2],
+							 int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = adjust_request[lane>>1];
+
+	return (link_value >> shift) & 0x3;
+}
+
+static unsigned char rk32_edp_get_adjust_request_pre_emphasis(
+					u8 adjust_request[2],
+					int lane)
+{
+	int shift = (lane & 1) * 4;
+	u8 link_value = adjust_request[lane>>1];
+
+	return ((link_value >> shift) & 0xc) >> 2;
+}
+
+static void rk32_edp_set_lane_link_training(struct rk32_edp *edp,
+					    u8 training_lane_set, int lane)
+{
+	switch (lane) {
+	case 0:
+		rk32_edp_set_lane0_link_training(edp, training_lane_set);
+		break;
+	case 1:
+		rk32_edp_set_lane1_link_training(edp, training_lane_set);
+		break;
+
+	case 2:
+		rk32_edp_set_lane2_link_training(edp, training_lane_set);
+		break;
+
+	case 3:
+		rk32_edp_set_lane3_link_training(edp, training_lane_set);
+		break;
+	}
+}
+
+static unsigned int rk32_edp_get_lane_link_training(
+						    struct rk32_edp *edp,
+						    int lane)
+{
+	u32 reg;
+
+	switch (lane) {
+	case 0:
+		reg = rk32_edp_get_lane0_link_training(edp);
+		break;
+	case 1:
+		reg = rk32_edp_get_lane1_link_training(edp);
+		break;
+	case 2:
+		reg = rk32_edp_get_lane2_link_training(edp);
+		break;
+	case 3:
+		reg = rk32_edp_get_lane3_link_training(edp);
+		break;
+	}
+
+	return reg;
+}
+
+static void rk32_edp_reduce_link_rate(struct rk32_edp *edp)
+{
+	rk32_edp_training_pattern_dis(edp);
+
+	edp->link_train.lt_state = FAILED;
+}
+
+static int rk32_edp_process_clock_recovery(struct rk32_edp *edp)
+{
+	u8 link_status[2];
+	int lane;
+	int lane_count;
+
+	u8 adjust_request[2];
+	u8 voltage_swing;
+	u8 pre_emphasis;
+	u8 training_lane;
+	int retval;
+
+	/*udelay(100);*/
+	usleep_range(99, 100);
+
+	lane_count = edp->link_train.lane_count;
+
+	retval = rk32_edp_read_bytes_from_dpcd(edp,
+					       DPCD_LANE0_1_STATUS,
+					       2, link_status);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to read lane status!\n");
+		return retval;
+	}
+
+	if (rk32_edp_clock_recovery_ok(link_status, lane_count) == 0) {
+		/* set training pattern 2 for EQ */
+		rk32_edp_set_training_pattern(edp, TRAINING_PTN2);
+
+		for (lane = 0; lane < lane_count; lane++) {
+			retval = rk32_edp_read_bytes_from_dpcd
+					(edp,
+					 DPCD_ADJUST_REQUEST_LANE0_1,
+					 2, adjust_request);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to read adjust request!\n");
+				return retval;
+			}
+
+			voltage_swing = rk32_edp_get_adjust_request_voltage(
+							adjust_request, lane);
+			pre_emphasis = rk32_edp_get_adjust_request_pre_emphasis(
+							adjust_request, lane);
+			training_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |
+					DPCD_PRE_EMPHASIS_SET(pre_emphasis);
+
+			if (voltage_swing == VOLTAGE_LEVEL_3)
+				training_lane |= DPCD_MAX_SWING_REACHED;
+			if (pre_emphasis == PRE_EMPHASIS_LEVEL_3)
+				training_lane |= DPCD_MAX_PRE_EMPHASIS_REACHED;
+
+			edp->link_train.training_lane[lane] = training_lane;
+
+			rk32_edp_set_lane_link_training
+				(edp,
+				 edp->link_train.training_lane[lane],
+				 lane);
+		}
+
+		retval = rk32_edp_write_byte_to_dpcd(edp,
+						     DPCD_TRAINING_PATTERN_SET,
+						     DPCD_SCRAMBLING_DISABLED |
+						     DPCD_TRAINING_PATTERN_2);
+		if (retval < 0) {
+			dev_err(edp->dev, "failed to set training pattern 2!\n");
+			return retval;
+		}
+
+		retval = rk32_edp_write_bytes_to_dpcd(edp,
+						      DPCD_TRAINING_LANE0_SET,
+						      lane_count,
+				edp->link_train.training_lane);
+		if (retval < 0) {
+			dev_err(edp->dev, "failed to set training lane!\n");
+			return retval;
+		}
+
+		dev_info(edp->dev, "Link Training Clock Recovery success\n");
+		edp->link_train.lt_state = LT_EQ_TRAINING;
+	} else {
+		for (lane = 0; lane < lane_count; lane++) {
+			training_lane = rk32_edp_get_lane_link_training(
+							edp, lane);
+			retval = rk32_edp_read_bytes_from_dpcd
+					(edp,
+					 DPCD_ADJUST_REQUEST_LANE0_1,
+					 2, adjust_request);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to read adjust request!\n");
+				return retval;
+			}
+
+			voltage_swing = rk32_edp_get_adjust_request_voltage(
+							adjust_request, lane);
+			pre_emphasis = rk32_edp_get_adjust_request_pre_emphasis(
+							adjust_request, lane);
+
+			if (voltage_swing == VOLTAGE_LEVEL_3 ||
+			    pre_emphasis == PRE_EMPHASIS_LEVEL_3) {
+				dev_err(edp->dev, "voltage or pre emphasis reached max level\n");
+				goto reduce_link_rate;
+			}
+
+			if ((DPCD_VOLTAGE_SWING_GET(training_lane) ==
+					voltage_swing) &&
+			   (DPCD_PRE_EMPHASIS_GET(training_lane) ==
+					pre_emphasis)) {
+				edp->link_train.cr_loop[lane]++;
+				if (edp->link_train.cr_loop[lane] ==
+					MAX_CR_LOOP) {
+					dev_err(edp->dev, "CR Max loop\n");
+					goto reduce_link_rate;
+				}
+			}
+
+			training_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |
+					DPCD_PRE_EMPHASIS_SET(pre_emphasis);
+
+			if (voltage_swing == VOLTAGE_LEVEL_3)
+				training_lane |= DPCD_MAX_SWING_REACHED;
+			if (pre_emphasis == PRE_EMPHASIS_LEVEL_3)
+				training_lane |= DPCD_MAX_PRE_EMPHASIS_REACHED;
+
+			edp->link_train.training_lane[lane] = training_lane;
+
+			rk32_edp_set_lane_link_training
+				(edp,
+				 edp->link_train.training_lane[lane], lane);
+		}
+
+		retval = rk32_edp_write_bytes_to_dpcd
+				(edp,
+				 DPCD_TRAINING_LANE0_SET,
+				 lane_count,
+				 edp->link_train.training_lane);
+		if (retval < 0) {
+			dev_err(edp->dev, "failed to set training lane!\n");
+			return retval;
+		}
+	}
+
+	return 0;
+
+reduce_link_rate:
+	rk32_edp_reduce_link_rate(edp);
+	return -EIO;
+}
+
+static int rk32_edp_process_equalizer_training(struct rk32_edp *edp)
+{
+	u8 link_status[2];
+	u8 link_align[3];
+	int lane;
+	int lane_count;
+	u32 reg;
+
+	u8 adjust_request[2];
+	u8 voltage_swing;
+	u8 pre_emphasis;
+	u8 training_lane;
+	int retval;
+
+	/*udelay(400);*/
+	usleep_range(399, 400);
+
+	lane_count = edp->link_train.lane_count;
+
+	retval = rk32_edp_read_bytes_from_dpcd(edp,
+					       DPCD_LANE0_1_STATUS,
+					       2, link_status);
+	if (retval < 0) {
+		dev_err(edp->dev, "failed to read lane status!\n");
+		return retval;
+	}
+
+	if (rk32_edp_clock_recovery_ok(link_status, lane_count) == 0) {
+		link_align[0] = link_status[0];
+		link_align[1] = link_status[1];
+
+		retval = rk32_edp_read_byte_from_dpcd
+				(edp,
+				 DPCD_LANE_ALIGN_STATUS_UPDATED,
+				 &link_align[2]);
+		if (retval < 0) {
+			dev_err(edp->dev, "failed to read lane aligne status!\n");
+			return retval;
+		}
+
+		for (lane = 0; lane < lane_count; lane++) {
+			retval = rk32_edp_read_bytes_from_dpcd
+					(edp,
+					 DPCD_ADJUST_REQUEST_LANE0_1,
+					 2, adjust_request);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to read adjust request!\n");
+				return retval;
+			}
+
+			voltage_swing = rk32_edp_get_adjust_request_voltage(
+							adjust_request, lane);
+			pre_emphasis = rk32_edp_get_adjust_request_pre_emphasis(
+							adjust_request, lane);
+			training_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |
+					DPCD_PRE_EMPHASIS_SET(pre_emphasis);
+
+			if (voltage_swing == VOLTAGE_LEVEL_3)
+				training_lane |= DPCD_MAX_SWING_REACHED;
+			if (pre_emphasis == PRE_EMPHASIS_LEVEL_3)
+				training_lane |= DPCD_MAX_PRE_EMPHASIS_REACHED;
+
+			edp->link_train.training_lane[lane] = training_lane;
+		}
+
+		if (rk32_edp_channel_eq_ok(link_align, lane_count) == 0) {
+			/* traing pattern Set to Normal */
+			retval = rk32_edp_training_pattern_dis(edp);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to disable training pattern!\n");
+				return retval;
+			}
+
+			dev_info(edp->dev, "Link Training success!\n");
+
+			rk32_edp_get_link_bandwidth(edp, &reg);
+			edp->link_train.link_rate = reg;
+			dev_dbg(edp->dev, "final bandwidth = %.2x\n",
+				edp->link_train.link_rate);
+
+			rk32_edp_get_lane_count(edp, &reg);
+			edp->link_train.lane_count = reg;
+			dev_dbg(edp->dev, "final lane count = %.2x\n",
+				edp->link_train.lane_count);
+
+			edp->link_train.lt_state = FINISHED;
+		} else {
+			/* not all locked */
+			edp->link_train.eq_loop++;
+
+			if (edp->link_train.eq_loop > MAX_EQ_LOOP) {
+				dev_err(edp->dev, "EQ Max loop\n");
+				goto reduce_link_rate;
+			}
+
+			for (lane = 0; lane < lane_count; lane++)
+				rk32_edp_set_lane_link_training
+				(edp,
+				 edp->link_train.training_lane[lane],
+				 lane);
+
+			retval = rk32_edp_write_bytes_to_dpcd
+					(edp,
+					 DPCD_TRAINING_LANE0_SET,
+					 lane_count,
+					 edp->link_train.training_lane);
+			if (retval < 0) {
+				dev_err(edp->dev, "failed to set training lane!\n");
+				return retval;
+			}
+		}
+	} else {
+		goto reduce_link_rate;
+	}
+
+	return 0;
+
+reduce_link_rate:
+	rk32_edp_reduce_link_rate(edp);
+	return -EIO;
+}
+#endif
+static int rk32_edp_get_max_rx_bandwidth(struct rk32_edp *edp,
+					 u8 *bandwidth)
+{
+	u8 data;
+	int retval = 0;
+
+	/*
+	 * For DP rev.1.1, Maximum link rate of Main Link lanes
+	 * 0x06 = 1.62 Gbps, 0x0a = 2.7 Gbps
+	 */
+	retval = rk32_edp_read_byte_from_dpcd(edp,
+					      DPCD_MAX_LINK_RATE, &data);
+	if (retval < 0)
+		*bandwidth = 0;
+	else
+		*bandwidth = data;
+	return retval;
+}
+
+static int rk32_edp_get_max_rx_lane_count(struct rk32_edp *edp,
+					  u8 *lane_count)
+{
+	u8 data;
+	int retval;
+
+	/*
+	 * For DP rev.1.1, Maximum number of Main Link lanes
+	 * 0x01 = 1 lane, 0x02 = 2 lanes, 0x04 = 4 lanes
+	 */
+	retval = rk32_edp_read_byte_from_dpcd(edp,
+					      DPCD_MAX_LANE_CNT, &data);
+	if (retval < 0)
+		*lane_count = 0;
+	else
+		*lane_count = DPCD_MAX_LANE_COUNT(data);
+	return retval;
+}
+
+static int rk32_edp_init_training(struct rk32_edp *edp)
+{
+	int retval;
+
+	/*
+	 * MACRO_RST must be applied after the PLL_LOCK to avoid
+	 * the DP inter pair skew issue for at least 10 us
+	 */
+	rk32_edp_reset_macro(edp);
+
+
+	retval = rk32_edp_get_max_rx_bandwidth(edp,
+					       &edp->link_train.link_rate);
+	retval = rk32_edp_get_max_rx_lane_count(edp,
+						&edp->link_train.lane_count);
+	dev_info(edp->dev, "max link rate:%d.%dGps max number of lanes:%d\n",
+		 edp->link_train.link_rate * 27/100,
+		 edp->link_train.link_rate*27%100,
+		 edp->link_train.lane_count);
+
+	if ((edp->link_train.link_rate != LINK_RATE_1_62GBPS) &&
+	    (edp->link_train.link_rate != LINK_RATE_2_70GBPS)) {
+		dev_warn
+		(edp->dev,
+		 "Rx Mx Link Rate is abnormal:%x!default link rate:%d.%dGps\n",
+		 edp->link_train.link_rate,
+		 edp->video_info.link_rate*27/100,
+		 edp->video_info.link_rate*27%100);
+		edp->link_train.link_rate = edp->video_info.link_rate;
+	}
+
+	if (edp->link_train.lane_count == 0) {
+		dev_err
+		(edp->dev,
+		 "Rx Max Lane count is abnormal :%x !use default lanes:%d\n",
+		 edp->link_train.lane_count,
+		 edp->video_info.lane_count);
+		edp->link_train.lane_count = edp->video_info.lane_count;
+	}
+
+	rk32_edp_analog_power_ctr(edp, 1);
+
+
+	return 0;
+}
+
+#if defined(SW_LT)
+static int rk32_edp_sw_link_training(struct rk32_edp *edp)
+{
+	int retval = 0;
+	int training_finished = 0;
+
+	edp->link_train.lt_state = LT_START;
+
+	/* Process here */
+	while (!training_finished) {
+		switch (edp->link_train.lt_state) {
+		case LT_START:
+			retval = rk32_edp_link_start(edp);
+			if (retval)
+				dev_err(edp->dev, "LT Start failed\n");
+			break;
+		case LT_CLK_RECOVERY:
+			retval = rk32_edp_process_clock_recovery(edp);
+			if (retval)
+				dev_err(edp->dev, "LT CR failed\n");
+			break;
+		case LT_EQ_TRAINING:
+			retval = rk32_edp_process_equalizer_training(edp);
+			if (retval)
+				dev_err(edp->dev, "LT EQ failed\n");
+			break;
+		case FINISHED:
+			training_finished = 1;
+			break;
+		case FAILED:
+			return -EREMOTEIO;
+		}
+	}
+
+	return retval;
+}
+
+#else
+static int rk32_edp_hw_link_training(struct rk32_edp *edp)
+{
+	u32 cnt = 50;
+	u32 val;
+	/* Set link rate and count as you want to establish*/
+	rk32_edp_set_link_bandwidth(edp, edp->link_train.link_rate);
+	rk32_edp_set_lane_count(edp, edp->link_train.lane_count);
+	rk32_edp_hw_link_training_en(edp);
+	val = rk32_edp_wait_hw_lt_done(edp);
+	while (val) {
+		if (cnt-- <= 0) {
+			dev_err(edp->dev, "hw lt timeout");
+			return -ETIMEDOUT;
+		}
+		mdelay(1);
+		val = rk32_edp_wait_hw_lt_done(edp);
+	}
+
+	val = rk32_edp_get_hw_lt_status(edp);
+	if (val)
+		dev_err(edp->dev, "hw lt err:%d\n", val);
+	return val;
+}
+#endif
+
+static int rk32_edp_set_link_train(struct rk32_edp *edp)
+{
+	int retval;
+
+	retval = rk32_edp_init_training(edp);
+	if (retval < 0)
+		dev_err(edp->dev, "DP LT init failed!\n");
+#if defined(SW_LT)
+	retval = rk32_edp_sw_link_training(edp);
+#else
+	retval = rk32_edp_hw_link_training(edp);
+#endif
+
+	return retval;
+}
+
+static int rk32_edp_config_video(struct rk32_edp *edp,
+				 struct video_info *video_info)
+{
+	int retval = 0;
+	int timeout_loop = 0;
+	int done_count = 0;
+
+	rk32_edp_config_video_slave_mode(edp, video_info);
+
+	rk32_edp_set_video_color_format(edp, video_info->color_depth,
+					video_info->color_space,
+					video_info->dynamic_range,
+					video_info->ycbcr_coeff);
+
+	if (rk32_edp_get_pll_lock_status(edp) == DP_PLL_UNLOCKED) {
+		dev_err(edp->dev, "PLL is not locked yet.\n");
+		return -EINVAL;
+	}
+
+	for (;;) {
+		timeout_loop++;
+		if (rk32_edp_is_slave_video_stream_clock_on(edp) == 0)
+			break;
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(edp->dev, "Timeout of video streamclk ok\n");
+			return -ETIMEDOUT;
+		}
+
+		udelay(1);
+	}
+
+	/* Set to use the register calculated M/N video */
+	rk32_edp_set_video_cr_mn(edp, CALCULATED_M, 0, 0);
+
+	/* For video bist, Video timing must be generated by register */
+#ifndef EDP_BIST_MODE
+	rk32_edp_set_video_timing_mode(edp, VIDEO_TIMING_FROM_CAPTURE);
+#endif
+	/* Disable video mute */
+	rk32_edp_enable_video_mute(edp, 0);
+
+	/* Configure video slave mode */
+	rk32_edp_enable_video_master(edp, 0);
+
+	/* Enable video */
+	rk32_edp_start_video(edp);
+
+	timeout_loop = 0;
+
+	for (;;) {
+		timeout_loop++;
+		if (rk32_edp_is_video_stream_on(edp) == 0) {
+			done_count++;
+			if (done_count > 10)
+				break;
+		} else if (done_count) {
+			done_count = 0;
+		}
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(edp->dev, "Timeout of video streamclk ok\n");
+			return -ETIMEDOUT;
+		}
+
+		mdelay(1);
+	}
+
+	if (retval != 0)
+		dev_err(edp->dev, "Video stream is not detected!\n");
+
+	return retval;
+}
+
+static irqreturn_t rk32_edp_isr(int irq, void *arg)
+{
+	struct rk32_edp *edp = arg;
+	enum dp_irq_type irq_type;
+
+	irq_type = rk32_edp_get_irq_type(edp);
+	switch (irq_type) {
+	case DP_IRQ_TYPE_HP_CABLE_IN:
+		dev_info(edp->dev, "Received irq - cable in\n");
+		rk32_edp_clear_hotplug_interrupts(edp);
+		break;
+	case DP_IRQ_TYPE_HP_CABLE_OUT:
+		dev_info(edp->dev, "Received irq - cable out\n");
+		rk32_edp_clear_hotplug_interrupts(edp);
+		break;
+	case DP_IRQ_TYPE_HP_CHANGE:
+		/*
+		 * We get these change notifications once in a while, but there
+		 * is nothing we can do with them. Just ignore it for now and
+		 * only handle cable changes.
+		 */
+		dev_info(edp->dev, "Received irq - hotplug change; ignoring.\n");
+		rk32_edp_clear_hotplug_interrupts(edp);
+		break;
+	default:
+		dev_err(edp->dev, "Received irq - unknown type!\n");
+		break;
+	}
+	return IRQ_HANDLED;
+}
+
+static int rk32_edp_enable(void)
+{
+	int ret = 0;
+	struct rk32_edp *edp = rk32_edp;
+
+	if (!edp->edp_en) {
+		rk32_edp_clk_enable(edp);
+		pm_runtime_get_sync(edp->dev);
+		rk32_edp_pre_init(edp);
+		rk32_edp_init_edp(edp);
+		enable_irq(edp->irq);
+		/*ret = rk32_edp_handle_edid(edp);
+		if (ret) {
+			dev_err(edp->dev, "unable to handle edid\n");
+			//goto out;
+		}
+
+		ret = rk32_edp_enable_scramble(edp, 0);
+		if (ret) {
+			dev_err(edp->dev, "unable to set scramble\n");
+			//goto out;
+		}
+
+		ret = rk32_edp_enable_rx_to_enhanced_mode(edp, 0);
+		if (ret) {
+			dev_err(edp->dev, "unable to set enhanced mode\n");
+			//goto out;
+		}
+		rk32_edp_enable_enhanced_mode(edp, 1);*/
+
+		ret = rk32_edp_set_link_train(edp);
+		if (ret)
+			dev_err(edp->dev, "link train failed!\n");
+		else
+			dev_info(edp->dev, "link training success.\n");
+
+		rk32_edp_set_lane_count(edp, edp->link_train.lane_count);
+		rk32_edp_set_link_bandwidth(edp, edp->link_train.link_rate);
+		rk32_edp_init_video(edp);
+
+#ifdef EDP_BIST_MODE
+		rk32_edp_bist_cfg(edp);
+#endif
+		ret = rk32_edp_config_video(edp, &edp->video_info);
+		if (ret)
+			dev_err(edp->dev, "unable to config video\n");
+
+		edp->edp_en = true;
+	}
+	return ret;
+}
+
+static int  rk32_edp_disable(void)
+{
+	struct rk32_edp *edp = rk32_edp;
+
+	if (edp->edp_en) {
+		edp->edp_en = false;
+		disable_irq(edp->irq);
+		rk32_edp_reset(edp);
+		rk32_edp_analog_power_ctr(edp, 0);
+		rk32_edp_clk_disable(edp);
+		pm_runtime_put_sync(edp->dev);
+	}
+
+	return 0;
+}
+
+
+static struct rk_fb_trsm_ops trsm_edp_ops = {
+	.enable = rk32_edp_enable,
+	.disable = rk32_edp_disable,
+};
+
+/*#if 0
+static int rk32_edp_enable_scramble(struct rk32_edp *edp, bool enable)
+{
+	u8 data;
+	int retval;
+
+	if (enable) {
+		rk32_edp_enable_scrambling(edp);
+
+		retval = rk32_edp_read_byte_from_dpcd
+				(edp,
+				 DPCD_TRAINING_PATTERN_SET,
+				 &data);
+		if (retval < 0)
+			return retval;
+
+		retval = rk32_edp_write_byte_to_dpcd
+				(edp,
+				 DPCD_TRAINING_PATTERN_SET,
+				 (u8)(data & ~DPCD_SCRAMBLING_DISABLED));
+		if (retval < 0)
+			return retval;
+	} else {
+		rk32_edp_disable_scrambling(edp);
+
+		retval = rk32_edp_read_byte_from_dpcd
+				(edp,
+				 DPCD_TRAINING_PATTERN_SET,
+				 &data);
+		if (retval < 0)
+			return retval;
+
+		retval = rk32_edp_write_byte_to_dpcd
+				(edp,
+				 DPCD_TRAINING_PATTERN_SET,
+				 (u8)(data | DPCD_SCRAMBLING_DISABLED));
+		if (retval < 0)
+			return retval;
+	}
+
+	return 0;
+}
+#endif*/
+static int rk32_edp_psr_enable(struct rk32_edp *edp)
+{
+	u8 buf;
+	int retval;
+	char date, psr_version;
+
+	/*if support PSR*/
+	retval = rk32_edp_read_byte_from_dpcd
+			(edp,
+			 PANEL_SELF_REFRESH_CAPABILITY_SUPPORTED_AND_VERSION,
+			 &psr_version);
+	if (retval < 0) {
+		dev_err(edp->dev, "PSR DPCD Read failed!\n");
+		return retval;
+	} else {
+		pr_info("PSR supporter and version:%x\n", psr_version);
+	}
+
+	 /*PSR capabilities*/
+	retval = rk32_edp_read_byte_from_dpcd
+			(edp,
+			 PANEL_SELF_REFRESH_CAPABILITIES, &date);
+	if (retval < 0) {
+		dev_err(edp->dev, "PSR DPCD Read failed!\n");
+		return retval;
+	} else {
+		pr_info("PSR capabilities:%x\n", date);
+	}
+
+	if (psr_version & PSR_SUPPORT) {
+		pr_info("PSR config psr\n");
+
+		/*config sink PSR*/
+		buf = 0x02;
+		retval = rk32_edp_write_bytes_to_dpcd(edp, PSR_ENABLE,
+						      1, &buf);
+		if (retval < 0) {
+			dev_err(edp->dev, "PSR failed to config sink PSR!\n");
+			return retval;
+		} else {
+			/*enable the PSR*/
+			buf = 0x03;
+			retval = rk32_edp_write_bytes_to_dpcd(edp,
+							      PSR_ENABLE,
+							      1, &buf);
+			if (retval < 0) {
+				dev_err(edp->dev, "PSR failed to enable the PSR!\n");
+				return retval;
+			}
+			/*read sink config state*/
+			retval = rk32_edp_read_byte_from_dpcd
+						(edp,
+						 PSR_ENABLE, &date);
+			if (retval < 0) {
+				dev_err(edp->dev, "PSR DPCD Read failed!\n");
+				return retval;
+			} else {
+				pr_info("PSR sink config state:%x\n", date);
+			}
+		}
+
+		/*enable sink crc*/
+		retval = rk32_edp_read_byte_from_dpcd(edp, 0x270, &buf);
+		buf |= 0x01;
+		retval = rk32_edp_write_bytes_to_dpcd(edp, 0x270, 1, &buf);
+	}
+
+		return 0;
+}
+static int psr_header_HB_PB(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = 0x0;
+	writel(val, edp->regs + HB0);/*HB0*/
+	val = 0x07;
+	writel(val, edp->regs + HB1);/*HB1*/
+	val = 0x02;
+	writel(val, edp->regs + HB2);/*HB2*/
+	val = 0x08;
+	writel(val, edp->regs + HB3);/*HB3*/
+	val = 0x00;
+	writel(val, edp->regs + PB0);/*PB0*/
+	val = 0x16;
+	writel(val, edp->regs + PB1);/*PB1*/
+	val = 0xce;
+	writel(val, edp->regs + PB2);/*PB2*/
+	val = 0x5d;
+	writel(val, edp->regs + PB3);/*PB3*/
+
+	return 0;
+}
+
+static int psr_enable_sdp(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + SPDIF_AUDIO_CTL_0);
+	val |= 0x08;
+	writel(val, edp->regs + SPDIF_AUDIO_CTL_0);/*enable SDP*/
+	val = readl(edp->regs + SPDIF_AUDIO_CTL_0);
+	pr_info("PSR reuse_spd_en:%x\n", val);
+
+	val = 0x83;
+	writel(val, edp->regs + IF_TYPE);/*enable IF_TYPE*/
+	val = readl(edp->regs + IF_TYPE);
+	pr_info("PSR IF_TYPE :%x\n", val);
+
+	val = readl(edp->regs + PKT_SEND_CTL);
+	val |= 0x10;
+	writel(val, edp->regs + PKT_SEND_CTL);/*enable IF_UP*/
+	val = readl(edp->regs + PKT_SEND_CTL);
+	pr_info("PSR if_up :%x\n", val);
+
+	val = readl(edp->regs + PKT_SEND_CTL);
+	val |= 0x01;
+	writel(val, edp->regs + PKT_SEND_CTL);/*enable IF_EN*/
+	val = readl(edp->regs + PKT_SEND_CTL);
+	pr_info("PSR if_en:%x\n", val);
+	return 0;
+}
+static int edp_disable_psr(struct rk32_edp *edp)
+{
+	u8 buf;
+	int retval;
+	char date;
+
+	/*disable sink PSR*/
+	retval = rk32_edp_read_byte_from_dpcd(edp,
+					      PSR_ENABLE, &date);
+	if (retval < 0) {
+		dev_err(edp->dev, "PSR sink original config Read failed!\n");
+		return retval;
+	}
+	buf = date&0xfe;
+	retval = rk32_edp_write_bytes_to_dpcd
+					(edp,
+					 PSR_ENABLE,
+					 1, &buf);
+	if (retval < 0) {
+		dev_err(edp->dev, "PSR failed to disable sink PSR!\n");
+		return retval;
+	}
+
+	pr_info("PSR disable success!!\n");
+	return 0;
+}
+
+static int edp_psr_state(struct rk32_edp *edp, int state)
+{
+		u32 val;
+		/*wait for VD blank*/
+		if  (rk_fb_poll_wait_frame_complete()) {
+			psr_header_HB_PB(edp);
+
+			val = state;
+			writel(val, edp->regs + DB1);
+			/*val = readl(edp->regs + DB1);
+			pr_info("PSR set DB1 state 0x0:%x\n", val);
+
+			for (i = 0; i < 22; i++)
+				 writel(0, edp->regs + DB2 + 4 * i);*/
+
+			psr_enable_sdp(edp);
+		}
+	return 0;
+}
+
+
+static int phy_power_channel(struct rk32_edp *edp, int state)
+{
+	u32 val;
+
+	val = state;
+	writel(val, edp->regs + DP_PD);
+
+	return 0;
+}
+
+#if defined(CONFIG_DEBUG_FS)
+
+static int edp_dpcd_debugfs_show(struct seq_file *s, void *v)
+{
+	int retval;
+	unsigned char buf[12];
+	struct rk32_edp *edp = s->private;
+
+	if (!edp) {
+		dev_err(edp->dev, "no edp device!\n");
+		return -ENODEV;
+	}
+
+	retval = rk32_edp_read_byte_from_dpcd
+			(edp,
+			 PANEL_SELF_REFRESH_CAPABILITY_SUPPORTED_AND_VERSION,
+			 &buf[0]);
+	seq_printf(s, "0x70 %x\n", buf[0]);
+
+	/*PSR capabilities*/
+	retval = rk32_edp_read_byte_from_dpcd
+			(edp,
+			 PANEL_SELF_REFRESH_CAPABILITIES, &buf[0]);
+	seq_printf(s, "0x71 %x\n", buf[0]);
+
+	retval = rk32_edp_read_byte_from_dpcd
+			(edp,
+			 PSR_ENABLE, &buf[0]);
+	seq_printf(s, "0x170 %x\n", buf[0]);
+
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x2006, &buf[0]);
+	seq_printf(s, "0x2006 %x\n", buf[0]);
+
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x2007, &buf[0]);
+	seq_printf(s, "0x2007 %x\n", buf[0]);
+
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x2008, &buf[0]);
+	seq_printf(s, "0x2008 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x2009, &buf[0]);
+	seq_printf(s, "0x2009 %x\n", buf[0]);
+
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x200a, &buf[0]);
+	seq_printf(s, "0x200a %x\n", buf[0]);
+
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x240, &buf[0]);
+	seq_printf(s, "0x240 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x241, &buf[0]);
+	seq_printf(s, "0x241 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x242, &buf[0]);
+	seq_printf(s, "0x242 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x243, &buf[0]);
+	seq_printf(s, "0x243 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x244, &buf[0]);
+	seq_printf(s, "0x244 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x245, &buf[0]);
+	seq_printf(s, "0x245 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x270, &buf[0]);
+	seq_printf(s, "0x270 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x246, &buf[0]);
+	seq_printf(s, "0x246 %x\n", buf[0]);
+
+	/*retval = rk32_edp_read_byte_from_dpcd(edp, 0x222, &buf[0]);
+	seq_printf(s, "0x222 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x223, &buf[0]);
+	seq_printf(s, "0x223 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x224, &buf[0]);
+	seq_printf(s, "0x224 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x225, &buf[0]);
+	seq_printf(s, "0x225 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x226, &buf[0]);
+	seq_printf(s, "0x226 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x227, &buf[0]);
+	seq_printf(s, "0x227 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x228, &buf[0]);
+	seq_printf(s, "0x228 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x229, &buf[0]);
+	seq_printf(s, "0x229 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x22a, &buf[0]);
+	seq_printf(s, "0x22a %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x22b, &buf[0]);
+	seq_printf(s, "0x22b %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x22c, &buf[0]);
+	seq_printf(s, "0x22c %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x22d, &buf[0]);
+	seq_printf(s, "0x22d %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x22e, &buf[0]);
+	seq_printf(s, "0x22e %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x22f, &buf[0]);
+	seq_printf(s, "0x22f %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x230, &buf[0]);
+	seq_printf(s, "0x230 %x\n", buf[0]);
+	retval = rk32_edp_read_byte_from_dpcd(edp, 0x231, &buf[0]);
+	seq_printf(s, "0x231 %x\n", buf[0]);*/
+
+	/*rk32_edp_read_bytes_from_dpcd(edp,
+			DPCD_SYMBOL_ERR_CONUT_LANE0, 12, buf);
+	for (i = 0; i < 12; i++)
+		seq_printf(s, "0x%02x>>0x%02x\n", 0x210 + i, buf[i]);*/
+	return 0;
+}
+
+static ssize_t edp_dpcd_write(struct file *file,
+			      const char __user *buf,
+			      size_t count,
+			      loff_t *ppos)
+{
+	return count;
+}
+
+static int edp_edid_debugfs_show(struct seq_file *s, void *v)
+{
+	struct rk32_edp *edp = s->private;
+
+	if (!edp) {
+		dev_err(edp->dev, "no edp device!\n");
+		return -ENODEV;
+	}
+	rk32_edp_read_edid(edp);
+	seq_puts(s, "edid");
+	return 0;
+}
+
+static ssize_t edp_edid_write(struct file *file,
+			      const char __user *buf,
+			      size_t count,
+			      loff_t *ppos)
+{
+	struct rk32_edp *edp =
+		((struct seq_file *)file->private_data)->private;
+
+	if (!edp) {
+		dev_err(edp->dev, "no edp device!\n");
+		return -ENODEV;
+	}
+	rk32_edp_disable();
+	rk32_edp_enable();
+	return count;
+}
+
+static int edp_reg_debugfs_show(struct seq_file *s, void *v)
+{
+	int i = 0;
+	struct rk32_edp *edp = s->private;
+
+	if (!edp) {
+		dev_err(edp->dev, "no edp device!\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < 0x284; i++) {
+		if (!(i%4))
+			seq_printf(s, "\n%08x:  ", i*4);
+		seq_printf(s, "%08x ", readl(edp->regs + i*4));
+	}
+	return 0;
+}
+
+static ssize_t edp_reg_write(struct file *file,
+			     const char __user *buf, size_t count,
+			     loff_t *ppos)
+{
+	return count;
+}
+
+static int edp_psr_debugfs_show(struct seq_file *s, void *v)
+{
+	return 0;
+}
+static ssize_t edp_psr_write(struct file *file,
+			     const char __user *buf,
+			     size_t count, loff_t *ppos)
+{
+	int a;
+	char kbuf[25];
+	int retval;
+	struct rk32_edp *edp =
+		((struct seq_file *)file->private_data)->private;
+
+	if (!edp) {
+		dev_err(edp->dev, "no edp device!\n");
+		return -ENODEV;
+	}
+	memset(kbuf, 0, 25);
+	if (copy_from_user(kbuf, buf, count))
+		return -EFAULT;
+	retval = kstrtoint(kbuf, 0, &a);
+	if (retval)
+		return retval;
+	/*retval = sscanf(kbuf, "%d", &a);
+	if (retval < 0) {
+		dev_err(edp->dev, "PSR failed sscanf!\n");
+		return retval;
+	}*/
+	/*disable psr*/
+	if (0 == a)
+		edp_disable_psr(edp);
+	/*enable psr*/
+	if (1 == a)
+		rk32_edp_psr_enable(edp);
+	/*inactive psr*/
+	if (2 == a)
+		edp_psr_state(edp, 0x0);
+	/*sink state 2*/
+	if  (3 == a)
+		edp_psr_state(edp, 0x01);
+	/*sink state 3*/
+	if  (4 == a)
+		edp_psr_state(edp, 0x03);
+	/*open 4 lanes*/
+	if  (5 == a) {
+		phy_power_channel(edp, 0xff);
+		usleep_range(9, 10);
+		phy_power_channel(edp, 0x7f);
+		usleep_range(9, 10);
+		phy_power_channel(edp, 0x0);
+	}
+	/*close 4 lanes*/
+	if (6 == a) {
+		phy_power_channel(edp, 0x7f);
+		usleep_range(9, 10);
+		phy_power_channel(edp, 0x0f);
+	}
+
+	return count;
+}
+
+#define EDP_DEBUG_ENTRY(name) \
+static int edp_##name##_debugfs_open(struct inode *inode, struct file *file) \
+{ \
+	return single_open(file, edp_##name##_debugfs_show, inode->i_private); \
+} \
+\
+static const struct file_operations edp_##name##_debugfs_fops = { \
+	.owner = THIS_MODULE, \
+	.open = edp_##name##_debugfs_open, \
+	.read = seq_read, \
+	.write = edp_##name##_write,	\
+	.llseek = seq_lseek, \
+	.release = single_release, \
+}
+
+EDP_DEBUG_ENTRY(psr);
+EDP_DEBUG_ENTRY(dpcd);
+EDP_DEBUG_ENTRY(edid);
+EDP_DEBUG_ENTRY(reg);
+#endif
+
+static int rk32_edp_probe(struct platform_device *pdev)
+{
+	struct rk32_edp *edp;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing device tree node.\n");
+		return -EINVAL;
+	}
+
+	edp = devm_kzalloc(&pdev->dev, sizeof(struct rk32_edp), GFP_KERNEL);
+	if (!edp) {
+		dev_err(&pdev->dev, "no memory for state\n");
+		return -ENOMEM;
+	}
+	edp->dev = &pdev->dev;
+	edp->video_info.h_sync_polarity	= 0;
+	edp->video_info.v_sync_polarity	= 0;
+	edp->video_info.interlaced	= 0;
+	edp->video_info.color_space	= CS_RGB;
+	edp->video_info.dynamic_range	= VESA;
+	edp->video_info.ycbcr_coeff	= COLOR_YCBCR601;
+	edp->video_info.color_depth	= COLOR_8;
+
+	edp->video_info.link_rate	= LINK_RATE_1_62GBPS;
+	edp->video_info.lane_count	= LANE_CNT4;
+	rk_fb_get_prmry_screen(&edp->screen);
+	if (edp->screen.type != SCREEN_EDP) {
+		dev_err(&pdev->dev, "screen is not edp!\n");
+		return -EINVAL;
+	}
+
+	edp->soctype = (unsigned long)of_device_get_match_data(&pdev->dev);
+
+	platform_set_drvdata(pdev, edp);
+	dev_set_name(edp->dev, "rk32-edp");
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	edp->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(edp->regs)) {
+		dev_err(&pdev->dev, "ioremap reg failed\n");
+		return PTR_ERR(edp->regs);
+	}
+
+	edp->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(edp->grf) && !cpu_is_rk3288()) {
+		dev_err(&pdev->dev, "can't find rockchip,grf property\n");
+		return PTR_ERR(edp->grf);
+	}
+
+	if (edp->soctype == SOC_RK3399) {
+		edp->grf_clk = devm_clk_get(&pdev->dev, "clk_grf");
+		if (IS_ERR(edp->grf_clk)) {
+			dev_err(&pdev->dev, "cannot get grf clk\n");
+			return PTR_ERR(edp->grf_clk);
+		}
+	}
+
+	edp->pd = devm_clk_get(&pdev->dev, "pd_edp");
+	if (IS_ERR(edp->pd)) {
+		dev_err(&pdev->dev, "cannot get pd\n");
+		edp->pd = NULL;
+	}
+
+	edp->clk_edp = devm_clk_get(&pdev->dev, "clk_edp");
+	if (IS_ERR(edp->clk_edp)) {
+		dev_err(&pdev->dev, "cannot get clk_edp\n");
+		return PTR_ERR(edp->clk_edp);
+	}
+
+	if (edp->soctype != SOC_RK3399) {
+		edp->clk_24m = devm_clk_get(&pdev->dev, "clk_edp_24m");
+		if (IS_ERR(edp->clk_24m)) {
+			dev_err(&pdev->dev, "cannot get clk_edp_24m\n");
+			return PTR_ERR(edp->clk_24m);
+		}
+	}
+
+	edp->pclk = devm_clk_get(&pdev->dev, "pclk_edp");
+	if (IS_ERR(edp->pclk)) {
+		dev_err(&pdev->dev, "cannot get pclk\n");
+		return PTR_ERR(edp->pclk);
+	}
+
+	/* We use the reset API to control the software reset at this version
+	 * and later, and we reserve the code that setting the cru regs directly
+	 * in the rk3288.
+	 */
+	if (edp->soctype != SOC_RK3399) {
+		/*edp 24m need sorft reset*/
+		edp->rst_24m = devm_reset_control_get(&pdev->dev, "edp_24m");
+		if (IS_ERR(edp->rst_24m))
+			dev_err(&pdev->dev, "failed to get reset\n");
+	}
+
+	/* edp ctrl apb bus need sorft reset */
+	edp->rst_apb = devm_reset_control_get(&pdev->dev, "edp_apb");
+	if (IS_ERR(edp->rst_apb))
+		dev_err(&pdev->dev, "failed to get reset\n");
+	rk32_edp_clk_enable(edp);
+	if (!support_uboot_display())
+		rk32_edp_pre_init(edp);
+	edp->irq = platform_get_irq(pdev, 0);
+	if (edp->irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		return edp->irq;
+	}
+	ret = devm_request_irq(&pdev->dev, edp->irq, rk32_edp_isr, 0,
+			       dev_name(&pdev->dev), edp);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot claim IRQ %d\n", edp->irq);
+		return ret;
+	}
+	disable_irq_nosync(edp->irq);
+	if (!support_uboot_display())
+		rk32_edp_clk_disable(edp);
+
+	pm_runtime_enable(&pdev->dev);
+	if (support_uboot_display()) {
+		edp->edp_en = true;
+		pm_runtime_get_sync(&pdev->dev);
+	}
+
+	rk32_edp = edp;
+	rk_fb_trsm_ops_register(&trsm_edp_ops, SCREEN_EDP);
+#if defined(CONFIG_DEBUG_FS)
+	edp->debugfs_dir = debugfs_create_dir("edp", NULL);
+	if (IS_ERR(edp->debugfs_dir)) {
+		dev_err(edp->dev, "failed to create debugfs dir for edp!\n");
+	} else {
+		debugfs_create_file("dpcd", S_IRUSR, edp->debugfs_dir,
+				    edp, &edp_dpcd_debugfs_fops);
+		debugfs_create_file("edid", S_IRUSR, edp->debugfs_dir,
+				    edp, &edp_edid_debugfs_fops);
+		debugfs_create_file("reg", S_IRUSR, edp->debugfs_dir,
+				    edp, &edp_reg_debugfs_fops);
+		debugfs_create_file("psr", S_IRUSR, edp->debugfs_dir,
+				    edp, &edp_psr_debugfs_fops);
+	}
+
+#endif
+	dev_info(&pdev->dev, "rk32 edp driver probe success\n");
+
+	return 0;
+}
+
+static int rockchip_edp_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk32_edp_dt_ids[] = {
+	{.compatible = "rockchip,rk32-edp", .data = (void *)SOC_COMMON},
+	{.compatible = "rockchip,rk3399-edp-fb", .data = (void *)SOC_RK3399},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, rk32_edp_dt_ids);
+#endif
+
+static struct platform_driver rk32_edp_driver = {
+	.probe = rk32_edp_probe,
+	.remove = rockchip_edp_remove,
+	.driver = {
+		   .name = "rk32-edp",
+		   .owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+		   .of_match_table = of_match_ptr(rk32_edp_dt_ids),
+#endif
+	},
+};
+
+static int __init rk32_edp_module_init(void)
+{
+	return platform_driver_register(&rk32_edp_driver);
+}
+
+static void __exit rk32_edp_module_exit(void)
+{
+}
+
+fs_initcall(rk32_edp_module_init);
+module_exit(rk32_edp_module_exit);
diff -Nupr a/drivers/video/rockchip/transmitter/rk32_dp.h b/drivers/video/rockchip/transmitter/rk32_dp.h
--- a/drivers/video/rockchip/transmitter/rk32_dp.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk32_dp.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,672 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RK32_DP_H
+#define __RK32_DP_H
+
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/rk_fb.h>
+
+#include "dpcd_edid.h"
+
+#define DP_VERSION				0x10
+
+#define TX_SW_RST				0x14
+
+#define FUNC_EN_1				0x18
+#define VID_CAP_FUNC_EN_N			(0x1 << 6)
+#define VID_FIFO_FUNC_EN_N			(0x1 << 5)
+#define AUD_FIFO_FUNC_EN_N			(0x1 << 4)
+#define AUD_FUNC_EN_N				(0x1 << 3)
+#define HDCP_FUNC_EN_N				(0x1 << 2)
+#define SW_FUNC_EN_N				(0x1 << 0)
+
+#define FUNC_EN_2				0x1C
+#define SSC_FUNC_EN_N				(0x1 << 7)
+#define AUX_FUNC_EN_N				(0x1 << 2)
+#define SERDES_FIFO_FUNC_EN_N			(0x1 << 1)
+#define LS_CLK_DOMAIN_FUNC_EN_N			(0x1 << 0)
+
+#define VIDEO_CTL_1				0x20
+#define VIDEO_EN				(0x1 << 7)
+#define VIDEO_MUTE				(0x1 << 6)
+
+#define VIDEO_CTL_2				0x24
+#define IN_D_RANGE_MASK				(0x1 << 7)
+#define IN_D_RANGE_SHIFT			(7)
+#define IN_D_RANGE_CEA				(0x1 << 7)
+#define IN_D_RANGE_VESA				(0x0 << 7)
+#define IN_BPC_MASK				(0x7 << 4)
+#define IN_BPC_SHIFT				(4)
+#define IN_BPC_12_BITS				(0x3 << 4)
+#define IN_BPC_10_BITS				(0x2 << 4)
+#define IN_BPC_8_BITS				(0x1 << 4)
+#define IN_BPC_6_BITS				(0x0 << 4)
+#define IN_COLOR_F_MASK				(0x3 << 0)
+#define IN_COLOR_F_SHIFT			(0)
+#define IN_COLOR_F_YCBCR444			(0x2 << 0)
+#define IN_COLOR_F_YCBCR422			(0x1 << 0)
+#define IN_COLOR_F_RGB				(0x0 << 0)
+
+#define VIDEO_CTL_3				0x28
+#define IN_YC_COEFFI_MASK			(0x1 << 7)
+#define IN_YC_COEFFI_SHIFT			(7)
+#define IN_YC_COEFFI_ITU709			(0x1 << 7)
+#define IN_YC_COEFFI_ITU601			(0x0 << 7)
+#define VID_CHK_UPDATE_TYPE_MASK		(0x1 << 4)
+#define VID_CHK_UPDATE_TYPE_SHIFT		(4)
+#define VID_CHK_UPDATE_TYPE_1			(0x1 << 4)
+#define VID_CHK_UPDATE_TYPE_0			(0x0 << 4)
+
+#define VIDEO_CTL_4				0x2c
+#define BIST_EN					(0x1 << 3)
+#define BIST_WH_64				(0x1 << 2)
+#define BIST_WH_32				(0x0 << 2)
+#define BIST_TYPE_COLR_BAR			(0x0 << 0)
+#define BIST_TYPE_GRAY_BAR			(0x1 << 0)
+#define BIST_TYPE_MOBILE_BAR			(0x2 << 0)
+
+#define VIDEO_CTL_8				0x3C
+#define VID_HRES_TH(x)				(((x) & 0xf) << 4)
+#define VID_VRES_TH(x)				(((x) & 0xf) << 0)
+
+#define VIDEO_CTL_10				0x44
+#define F_SEL					(0x1 << 4)
+#define INTERACE_SCAN_CFG			(0x1 << 2)
+#define VSYNC_POLARITY_CFG			(0x1 << 1)
+#define HSYNC_POLARITY_CFG			(0x1 << 0)
+
+#define TOTAL_LINE_CFG_L			0x48
+#define TOTAL_LINE_CFG_H			0x4c
+#define ATV_LINE_CFG_L				0x50
+#define ATV_LINE_CFG_H				0x54
+#define VF_PORCH_REG				0x58
+#define VSYNC_CFG_REG				0x5c
+#define VB_PORCH_REG				0x60
+#define TOTAL_PIXELL_REG			0x64
+#define TOTAL_PIXELH_REG			0x68
+#define ATV_PIXELL_REG				0x6c
+#define ATV_PIXELH_REG				0x70
+#define HF_PORCHL_REG				0x74
+#define HF_PORCHH_REG				0x78
+#define HSYNC_CFGL_REG				0x7c
+#define HSYNC_CFGH_REG				0x80
+#define HB_PORCHL_REG				0x84
+#define HB_PORCHH_REG				0x88
+
+
+#define SSC_REG					0x104
+#define TX_REG_COMMON				0x114
+#define DP_AUX					0x120
+#define DP_BIAS					0x124
+
+#define PLL_REG_1				0xfc
+#define REF_CLK_24M				(0x1 << 1)
+#define REF_CLK_27M				(0x0 << 1)
+
+#define PLL_REG_2				0x9e4
+#define PLL_REG_3				0x9e8
+#define PLL_REG_4				0x9ec
+#define PLL_REG_5				0xa00
+#define DP_PWRDN				0x12c
+#define PD_INC_BG				(0x1 << 7)
+#define PD_EXP_BG				(0x1 << 6)
+#define PD_AUX					(0x1 << 5)
+#define PD_PLL					(0x1 << 4)
+#define PD_CH3					(0x1 << 3)
+#define PD_CH2					(0x1 << 2)
+#define PD_CH1					(0x1 << 1)
+#define PD_CH0					(0x1 << 0)
+
+#define DP_RESERVE2				0x134
+
+#define LANE_MAP				0x35C
+#define LANE3_MAP_LOGIC_LANE_0			(0x0 << 6)
+#define LANE3_MAP_LOGIC_LANE_1			(0x1 << 6)
+#define LANE3_MAP_LOGIC_LANE_2			(0x2 << 6)
+#define LANE3_MAP_LOGIC_LANE_3			(0x3 << 6)
+#define LANE2_MAP_LOGIC_LANE_0			(0x0 << 4)
+#define LANE2_MAP_LOGIC_LANE_1			(0x1 << 4)
+#define LANE2_MAP_LOGIC_LANE_2			(0x2 << 4)
+#define LANE2_MAP_LOGIC_LANE_3			(0x3 << 4)
+#define LANE1_MAP_LOGIC_LANE_0			(0x0 << 2)
+#define LANE1_MAP_LOGIC_LANE_1			(0x1 << 2)
+#define LANE1_MAP_LOGIC_LANE_2			(0x2 << 2)
+#define LANE1_MAP_LOGIC_LANE_3			(0x3 << 2)
+#define LANE0_MAP_LOGIC_LANE_0			(0x0 << 0)
+#define LANE0_MAP_LOGIC_LANE_1			(0x1 << 0)
+#define LANE0_MAP_LOGIC_LANE_2			(0x2 << 0)
+#define LANE0_MAP_LOGIC_LANE_3			(0x3 << 0)
+
+#define ANALOG_CTL_2				0x374
+#define SEL_24M					(0x1 << 3)
+
+/*#define ANALOG_CTL_3				0x378
+#define PLL_FILTER_CTL_1			0x37C
+#define TX_AMP_TUNING_CTL			0x380*/
+
+#define AUX_HW_RETRY_CTL			0x390
+
+#define INT_STA					0x3c0
+
+#define COMMON_INT_STA_1			0x3C4
+#define VSYNC_DET				(0x1 << 7)
+#define PLL_LOCK_CHG				(0x1 << 6)
+#define SPDIF_ERR				(0x1 << 5)
+#define SPDIF_UNSTBL				(0x1 << 4)
+#define VID_FORMAT_CHG				(0x1 << 3)
+#define AUD_CLK_CHG				(0x1 << 2)
+#define VID_CLK_CHG				(0x1 << 1)
+#define SW_INT					(0x1 << 0)
+
+#define COMMON_INT_STA_2			0x3C8
+#define ENC_EN_CHG				(0x1 << 6)
+#define HW_BKSV_RDY				(0x1 << 3)
+#define HW_SHA_DONE				(0x1 << 2)
+#define HW_AUTH_STATE_CHG			(0x1 << 1)
+#define HW_AUTH_DONE				(0x1 << 0)
+
+#define COMMON_INT_STA_3			0x3CC
+#define AFIFO_UNDER				(0x1 << 7)
+#define AFIFO_OVER				(0x1 << 6)
+#define R0_CHK_FLAG				(0x1 << 5)
+
+#define COMMON_INT_STA_4			0x3D0
+#define PSR_ACTIVE				(0x1 << 7)
+#define PSR_INACTIVE				(0x1 << 6)
+#define SPDIF_BI_PHASE_ERR			(0x1 << 5)
+#define HOTPLUG_CHG				(0x1 << 2)
+#define HPD_LOST				(0x1 << 1)
+#define PLUG					(0x1 << 0)
+
+#define DP_INT_STA				0x3DC
+#define INT_HPD					(0x1 << 6)
+#define HW_LT_DONE				(0x1 << 5)
+#define SINK_LOST				(0x1 << 3)
+#define LINK_LOST				(0x1 << 2)
+#define RPLY_RECEIV				(0x1 << 1)
+#define AUX_ERR					(0x1 << 0)
+
+#define COMMON_INT_MASK_1			0x3E0
+#define COMMON_INT_MASK_2			0x3E4
+#define COMMON_INT_MASK_3			0x3E8
+#define COMMON_INT_MASK_4			0x3EC
+#define DP_INT_STA_MASK				0x3F8
+
+#define INT_CTL					0x3FC
+#define SOFT_INT_CTRL				(0x1 << 2)
+#define INT_POL					(0x1 << 0)
+
+#define SYS_CTL_1				0x600
+#define DET_STA					(0x1 << 2)
+#define FORCE_DET				(0x1 << 1)
+#define DET_CTRL				(0x1 << 0)
+
+#define SYS_CTL_2				0x604
+#define CHA_CRI(x)				(((x) & 0xf) << 4)
+#define CHA_STA					(0x1 << 2)
+#define FORCE_CHA				(0x1 << 1)
+#define CHA_CTRL				(0x1 << 0)
+
+#define SYS_CTL_3				0x608
+#define HPD_STATUS				(0x1 << 6)
+#define F_HPD					(0x1 << 5)
+#define HPD_CTRL				(0x1 << 4)
+#define HDCP_RDY				(0x1 << 3)
+#define STRM_VALID				(0x1 << 2)
+#define F_VALID					(0x1 << 1)
+#define VALID_CTRL				(0x1 << 0)
+
+#define SYS_CTL_4				0x60C
+#define FIX_M_AUD				(0x1 << 4)
+#define ENHANCED				(0x1 << 3)
+#define FIX_M_VID				(0x1 << 2)
+#define M_VID_UPDATE_CTRL			(0x3 << 0)
+
+
+#define PKT_SEND_CTL				0x640
+#define HDCP_CTL				0x648
+
+#define LINK_BW_SET				0x680
+#define LANE_CNT_SET				0x684
+
+#define TRAINING_PTN_SET			0x688
+#define SCRAMBLING_DISABLE			(0x1 << 5)
+#define SCRAMBLING_ENABLE			(0x0 << 5)
+#define LINK_QUAL_PATTERN_SET_MASK		(0x7 << 2)
+#define LINK_QUAL_PATTERN_SET_HBR2		(0x5 << 2)
+#define LINK_QUAL_PATTERN_SET_80BIT		(0x4 << 2)
+#define LINK_QUAL_PATTERN_SET_PRBS7		(0x3 << 2)
+#define LINK_QUAL_PATTERN_SET_D10_2		(0x1 << 2)
+#define LINK_QUAL_PATTERN_SET_DISABLE		(0x0 << 2)
+#define SW_TRAINING_PATTERN_SET_MASK		(0x3 << 0)
+#define SW_TRAINING_PATTERN_SET_PTN2		(0x2 << 0)
+#define SW_TRAINING_PATTERN_SET_PTN1		(0x1 << 0)
+#define SW_TRAINING_PATTERN_SET_DISABLE		(0x0 << 0)
+
+#define LN0_LINK_TRAINING_CTL			0x68C
+#define LN1_LINK_TRAINING_CTL			0x690
+#define LN2_LINK_TRAINING_CTL			0x694
+#define LN3_LINK_TRAINING_CTL			0x698
+
+#define HW_LT_CTL				0x6a0
+#define HW_LT_ERR_CODE_MASK			0x70
+#define HW_LT_EN				(0x1 << 0)
+
+#define DEBUG_CTL				0x6C0
+#define PLL_LOCK				(0x1 << 4)
+#define F_PLL_LOCK				(0x1 << 3)
+#define PLL_LOCK_CTRL				(0x1 << 2)
+#define POLL_EN					(0x1 << 1)
+#define PN_INV					(0x1 << 0)
+
+#define HPD_DEGLITCH_L				0x6C4
+#define HPD_DEGLITCH_H				0x6C8
+#define LINK_DEBUG_CTL				0x6E0
+
+#define M_VID_0					0x700
+#define M_VID_1					0x704
+#define M_VID_2					0x708
+#define N_VID_0					0x70C
+#define N_VID_1					0x710
+#define N_VID_2					0x714
+
+#define VIDEO_FIFO_THRD				0x730
+#define AUDIO_MARGIN				0x73C
+
+#define M_VID_GEN_FILTER_TH			0x764
+#define M_AUD_GEN_FILTER_TH			0x778
+
+#define AUX_CH_STA				0x780
+#define AUX_BUSY				(0x1 << 4)
+#define AUX_STATUS_MASK				(0xf << 0)
+
+#define AUX_CH_DEFER_CTL			0x788
+#define DEFER_CTRL_EN				(0x1 << 7)
+#define DEFER_COUNT(x)				(((x) & 0x7f) << 0)
+
+#define AUX_RX_COMM				0x78C
+#define BUFFER_DATA_CTL				0x790
+#define BUF_CLR					(0x1 << 7)
+#define BUF_HAVE_DATA				(0x1 << 4)
+#define BUF_DATA_COUNT(x)			(((x) & 0xf) << 0)
+
+#define AUX_CH_CTL_1				0x794
+#define AUX_LENGTH(x)				(((x - 1) & 0xf) << 4)
+#define AUX_TX_COMM_MASK			(0xf << 0)
+#define AUX_TX_COMM_DP_TRANSACTION		(0x1 << 3)
+#define AUX_TX_COMM_I2C_TRANSACTION		(0x0 << 3)
+#define AUX_TX_COMM_MOT				(0x1 << 2)
+#define AUX_TX_COMM_WRITE			(0x0 << 0)
+#define AUX_TX_COMM_READ			(0x1 << 0)
+
+#define DP_AUX_ADDR_7_0				0x798
+#define DP_AUX_ADDR_15_8			0x79C
+#define DP_AUX_ADDR_19_16			0x7A0
+
+#define AUX_CH_CTL_2				0x7A4
+#define PD_AUX_IDLE				(0x1 << 3)
+#define ADDR_ONLY				(0x1 << 1)
+#define AUX_EN					(0x1 << 0)
+
+#define BUF_DATA_0				0x7C0
+
+#define SOC_GENERAL_CTL				0x800
+
+/* TX_SW_RESET */
+#define RST_DP_TX				(0x1 << 0)
+
+/* ANALOG_CTL_1 */
+#define TX_TERMINAL_CTRL_50_OHM			(0x1 << 4)
+
+
+
+/* ANALOG_CTL_3 */
+#define DRIVE_DVDD_BIT_1_0625V			(0x4 << 5)
+#define VCO_BIT_600_MICRO			(0x5 << 0)
+
+/* PLL_FILTER_CTL_1 */
+#define PD_RING_OSC				(0x1 << 6)
+#define AUX_TERMINAL_CTRL_37_5_OHM		(0x0 << 4)
+#define AUX_TERMINAL_CTRL_45_OHM		(0x1 << 4)
+#define AUX_TERMINAL_CTRL_50_OHM		(0x2 << 4)
+#define AUX_TERMINAL_CTRL_65_OHM		(0x3 << 4)
+#define TX_CUR1_2X				(0x1 << 2)
+#define TX_CUR_16_MA				(0x3 << 0)
+
+/* TX_AMP_TUNING_CTL */
+#define CH3_AMP_SHIFT				(24)
+#define CH3_AMP_400_MV				(0x0 << 24)
+#define CH2_AMP_SHIFT				(16)
+#define CH2_AMP_400_MV				(0x0 << 16)
+#define CH1_AMP_SHIFT				(8)
+#define CH1_AMP_400_MV				(0x0 << 8)
+#define CH0_AMP_SHIFT				(0)
+#define CH0_AMP_400_MV				(0x0 << 0)
+
+/* AUX_HW_RETRY_CTL */
+#define AUX_BIT_PERIOD_EXPECTED_DELAY(x)	(((x) & 0x7) << 8)
+#define AUX_HW_RETRY_INTERVAL_MASK		(0x3 << 3)
+#define AUX_HW_RETRY_INTERVAL_600_MICROSECONDS	(0x0 << 3)
+#define AUX_HW_RETRY_INTERVAL_800_MICROSECONDS	(0x1 << 3)
+#define AUX_HW_RETRY_INTERVAL_1000_MICROSECONDS	(0x2 << 3)
+#define AUX_HW_RETRY_INTERVAL_1800_MICROSECONDS	(0x3 << 3)
+#define AUX_HW_RETRY_COUNT_SEL(x)		(((x) & 0x7) << 0)
+
+
+
+/* LN0_LINK_TRAINING_CTL */
+#define PRE_EMPHASIS_SET_MASK			(0x3 << 3)
+#define PRE_EMPHASIS_SET_SHIFT			(3)
+
+
+/* PLL_CTL */
+#define DP_PLL_PD				(0x1 << 7)
+#define DP_PLL_RESET				(0x1 << 6)
+#define DP_PLL_LOOP_BIT_DEFAULT			(0x1 << 4)
+#define DP_PLL_REF_BIT_1_1250V			(0x5 << 0)
+#define DP_PLL_REF_BIT_1_2500V			(0x7 << 0)
+
+/* PHY_TEST */
+#define MACRO_RST				(0x1 << 5)
+#define CH1_TEST				(0x1 << 1)
+#define CH0_TEST				(0x1 << 0)
+
+
+
+
+
+
+
+#define DP_TIMEOUT_LOOP_CNT 100
+#define MAX_CR_LOOP 5
+#define MAX_EQ_LOOP 5
+
+
+
+#define GRF_EDP_REF_CLK_SEL_INTER		(1 << 4)
+#define GRF_EDP_HDCP_EN				(1 << 15)
+#define GRF_EDP_BIST_EN				(1 << 14)
+#define GRF_EDP_MEM_CTL_BY_EDP			(1 << 13)
+#define GRF_EDP_SECURE_EN			(1 << 3)
+#define EDP_SEL_VOP_LIT				(1 << 5)
+
+/* PSR */
+#define PANEL_SELF_REFRESH_CAPABILITY_SUPPORTED_AND_VERSION 0x70
+#define PANEL_SELF_REFRESH_CAPABILITIES 0x71
+#define PSR_SUPPORT 0x1
+#define PSR_ENABLE 0x170
+#define SUORPSR_EVENT_STATUS_INDICATOR 0x2007
+#define SINK_DEVICE_PANEL_SELF_REFRESH_STATUS 0x2008
+#define LAST_RECEIVED_PSR_SDP 0x200a
+#define DEFINITION_WITHIN_LINKORSINK_DEVICE_POWER_CONTROL_FIELD 0x600
+
+#define HB0 0x02F8
+#define HB1 0x02FC
+#define HB2 0x0300
+#define HB3 0x0304
+#define PB0 0x0308
+#define PB1 0x030C
+#define PB2 0x0310
+#define PB3 0x0314
+#define DB0 0x0254
+#define DB1 0x0258
+#define DB2 0x025C
+#define DB3 0x0260
+#define DB4 0x0264
+#define DB5 0x0268
+#define DB6 0x026c
+#define DB7 0x0270
+#define DP_PD 0x012C
+#define IF_TYPE 0x0244
+#define VSC_SHADOW_DB1 0x0320
+#define PSR_FRAME_UPDATA_CTRL 0x0318
+#define SPDIF_AUDIO_CTL_0 0x00D8
+/* PSR END */
+
+enum dp_irq_type {
+	DP_IRQ_TYPE_HP_CABLE_IN,
+	DP_IRQ_TYPE_HP_CABLE_OUT,
+	DP_IRQ_TYPE_HP_CHANGE,
+	DP_IRQ_TYPE_UNKNOWN,
+};
+
+enum color_coefficient {
+	COLOR_YCBCR601,
+	COLOR_YCBCR709
+};
+
+enum dynamic_range {
+	VESA,
+	CEA
+};
+
+enum pll_status {
+	DP_PLL_UNLOCKED,
+	DP_PLL_LOCKED
+};
+
+enum clock_recovery_m_value_type {
+	CALCULATED_M,
+	REGISTER_M
+};
+
+enum video_timing_recognition_type {
+	VIDEO_TIMING_FROM_CAPTURE,
+	VIDEO_TIMING_FROM_REGISTER
+};
+
+enum pattern_set {
+	PRBS7,
+	D10_2,
+	TRAINING_PTN1,
+	TRAINING_PTN2,
+	DP_NONE
+};
+
+enum color_space {
+	CS_RGB,
+	CS_YCBCR422,
+	CS_YCBCR444
+};
+
+enum color_depth {
+	COLOR_6,
+	COLOR_8,
+	COLOR_10,
+	COLOR_12
+};
+
+enum link_rate_type {
+	LINK_RATE_1_62GBPS = 0x06,
+	LINK_RATE_2_70GBPS = 0x0a
+};
+
+enum link_lane_count_type {
+	LANE_CNT1 = 1,
+	LANE_CNT2 = 2,
+	LANE_CNT4 = 4
+};
+
+enum link_training_state {
+	LT_START,
+	LT_CLK_RECOVERY,
+	LT_EQ_TRAINING,
+	FINISHED,
+	FAILED
+};
+
+enum voltage_swing_level {
+	VOLTAGE_LEVEL_0,
+	VOLTAGE_LEVEL_1,
+	VOLTAGE_LEVEL_2,
+	VOLTAGE_LEVEL_3,
+};
+
+enum pre_emphasis_level {
+	PRE_EMPHASIS_LEVEL_0,
+	PRE_EMPHASIS_LEVEL_1,
+	PRE_EMPHASIS_LEVEL_2,
+	PRE_EMPHASIS_LEVEL_3,
+};
+
+enum analog_power_block {
+	AUX_BLOCK,
+	CH0_BLOCK,
+	CH1_BLOCK,
+	CH2_BLOCK,
+	CH3_BLOCK,
+	ANALOG_TOTAL,
+	POWER_ALL
+};
+
+struct video_info {
+	char *name;
+
+	bool h_sync_polarity;
+	bool v_sync_polarity;
+	bool interlaced;
+
+	enum color_space color_space;
+	enum dynamic_range dynamic_range;
+	enum color_coefficient ycbcr_coeff;
+	enum color_depth color_depth;
+
+	enum link_rate_type link_rate;
+	enum link_lane_count_type lane_count;
+};
+
+struct link_train {
+	int eq_loop;
+	int cr_loop[4];
+
+	u8 link_rate;
+	u8 lane_count;
+	u8 training_lane[4];
+
+	enum link_training_state lt_state;
+};
+
+enum {
+	SOC_COMMON = 0,
+	SOC_RK3399
+};
+
+struct rk32_edp {
+	struct device		*dev;
+	void __iomem		*regs;
+	struct regmap		*grf;
+	unsigned int		irq;
+	struct clk		*grf_clk;
+	struct clk		*pd;
+	struct clk		*clk_edp;  /*clk for edp controller*/
+	struct clk		*clk_24m;  /*clk for edp phy*/
+	struct clk		*pclk;	   /*clk for phb bus*/
+	struct reset_control    *rst_24m;
+	struct reset_control    *rst_apb;
+	struct link_train	link_train;
+	struct video_info	video_info;
+	struct rk_screen	screen;
+	struct fb_monspecs      specs;
+	bool clk_on;
+	bool edp_en;
+	int soctype;
+	struct dentry *debugfs_dir;
+};
+
+
+void rk32_edp_enable_video_mute(struct rk32_edp *edp, bool enable);
+void rk32_edp_stop_video(struct rk32_edp *edp);
+void rk32_edp_lane_swap(struct rk32_edp *edp, bool enable);
+void rk32_edp_init_refclk(struct rk32_edp *edp);
+void rk32_edp_init_interrupt(struct rk32_edp *edp);
+void rk32_edp_reset(struct rk32_edp *edp);
+void rk32_edp_config_interrupt(struct rk32_edp *edp);
+u32 rk32_edp_get_pll_lock_status(struct rk32_edp *edp);
+void rk32_edp_analog_power_ctr(struct rk32_edp *edp, bool enable);
+void rk32_edp_init_analog_func(struct rk32_edp *edp);
+void rk32_edp_init_hpd(struct rk32_edp *edp);
+void rk32_edp_reset_aux(struct rk32_edp *edp);
+void rk32_edp_init_aux(struct rk32_edp *edp);
+int rk32_edp_get_plug_in_status(struct rk32_edp *edp);
+void rk32_edp_enable_sw_function(struct rk32_edp *edp);
+int rk32_edp_start_aux_transaction(struct rk32_edp *edp);
+int rk32_edp_write_byte_to_dpcd(struct rk32_edp *edp,
+				unsigned int reg_addr,
+				unsigned char data);
+int rk32_edp_read_byte_from_dpcd(struct rk32_edp *edp,
+				 unsigned int reg_addr,
+				 unsigned char *data);
+int rk32_edp_write_bytes_to_dpcd(struct rk32_edp *edp,
+				 unsigned int reg_addr,
+				 unsigned int count,
+				 unsigned char data[]);
+int rk32_edp_read_bytes_from_dpcd(struct rk32_edp *edp,
+				  unsigned int reg_addr,
+				  unsigned int count,
+				  unsigned char data[]);
+int rk32_edp_select_i2c_device(struct rk32_edp *edp,
+			       unsigned int device_addr,
+			       unsigned int reg_addr);
+int rk32_edp_read_byte_from_i2c(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int reg_addr,
+				unsigned int *data);
+int rk32_edp_read_bytes_from_i2c(struct rk32_edp *edp,
+				 unsigned int device_addr,
+				 unsigned int reg_addr,
+				 unsigned int count,
+				 unsigned char edid[]);
+void rk32_edp_set_link_bandwidth(struct rk32_edp *edp, u32 bwtype);
+void rk32_edp_get_link_bandwidth(struct rk32_edp *edp, u32 *bwtype);
+void rk32_edp_set_lane_count(struct rk32_edp *edp, u32 count);
+void rk32_edp_get_lane_count(struct rk32_edp *edp, u32 *count);
+void rk32_edp_enable_enhanced_mode(struct rk32_edp *edp, bool enable);
+void rk32_edp_set_training_pattern(struct rk32_edp *edp,
+				   enum pattern_set pattern);
+void rk32_edp_set_lane0_pre_emphasis(struct rk32_edp *edp, u32 level);
+void rk32_edp_set_lane1_pre_emphasis(struct rk32_edp *edp, u32 level);
+void rk32_edp_set_lane2_pre_emphasis(struct rk32_edp *edp, u32 level);
+void rk32_edp_set_lane3_pre_emphasis(struct rk32_edp *edp, u32 level);
+void rk32_edp_set_lane0_link_training(struct rk32_edp *edp,
+				      u32 training_lane);
+void rk32_edp_set_lane1_link_training(struct rk32_edp *edp,
+				      u32 training_lane);
+void rk32_edp_set_lane2_link_training(struct rk32_edp *edp,
+				      u32 training_lane);
+void rk32_edp_set_lane3_link_training(struct rk32_edp *edp,
+				      u32 training_lane);
+u32 rk32_edp_get_lane0_link_training(struct rk32_edp *edp);
+u32 rk32_edp_get_lane1_link_training(struct rk32_edp *edp);
+u32 rk32_edp_get_lane2_link_training(struct rk32_edp *edp);
+u32 rk32_edp_get_lane3_link_training(struct rk32_edp *edp);
+void rk32_edp_reset_macro(struct rk32_edp *edp);
+int rk32_edp_init_video(struct rk32_edp *edp);
+
+void rk32_edp_set_video_color_format(struct rk32_edp *edp,
+				     u32 color_depth,
+				     u32 color_space,
+				     u32 dynamic_range,
+				     u32 coeff);
+int rk32_edp_is_slave_video_stream_clock_on(struct rk32_edp *edp);
+void rk32_edp_set_video_cr_mn(struct rk32_edp *edp,
+			      enum clock_recovery_m_value_type type,
+			      u32 m_value,
+			      u32 n_value);
+void rk32_edp_set_video_timing_mode(struct rk32_edp *edp, u32 type);
+void rk32_edp_enable_video_master(struct rk32_edp *edp, bool enable);
+void rk32_edp_start_video(struct rk32_edp *edp);
+int rk32_edp_is_video_stream_on(struct rk32_edp *edp);
+void rk32_edp_config_video_slave_mode(struct rk32_edp *edp,
+				      struct video_info *video_info);
+void rk32_edp_enable_scrambling(struct rk32_edp *edp);
+void rk32_edp_disable_scrambling(struct rk32_edp *edp);
+void rk32_edp_rx_control(struct rk32_edp *edp, bool enable);
+int rk32_edp_bist_cfg(struct rk32_edp *edp);
+void rk32_edp_hw_link_training_en(struct rk32_edp *edp);
+int rk32_edp_get_hw_lt_status(struct rk32_edp *edp);
+int rk32_edp_wait_hw_lt_done(struct rk32_edp *edp);
+enum dp_irq_type rk32_edp_get_irq_type(struct rk32_edp *edp);
+void rk32_edp_clear_hotplug_interrupts(struct rk32_edp *edp);
+
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/rk32_dp_reg.c b/drivers/video/rockchip/transmitter/rk32_dp_reg.c
--- a/drivers/video/rockchip/transmitter/rk32_dp_reg.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk32_dp_reg.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1300 @@
+/*
+ *RockChip DP (Display port) register interface driver.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/rockchip/cpu.h>
+#include <linux/rockchip/grf.h>
+#include "rk32_dp.h"
+
+
+void rk32_edp_enable_video_mute(struct rk32_edp *edp, bool enable)
+{
+	u32 val;
+
+	if (enable) {
+		val = readl(edp->regs + VIDEO_CTL_1);
+		val |= VIDEO_MUTE;
+		writel(val, edp->regs + VIDEO_CTL_1);
+	} else {
+		val = readl(edp->regs + VIDEO_CTL_1);
+		val &= ~VIDEO_MUTE;
+		writel(val, edp->regs + VIDEO_CTL_1);
+	}
+}
+
+void rk32_edp_stop_video(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + VIDEO_CTL_1);
+	val &= ~VIDEO_EN;
+	writel(val, edp->regs + VIDEO_CTL_1);
+}
+
+void rk32_edp_lane_swap(struct rk32_edp *edp, bool enable)
+{
+	u32 val;
+
+
+	if (enable)
+		val = LANE3_MAP_LOGIC_LANE_0 | LANE2_MAP_LOGIC_LANE_1 |
+			LANE1_MAP_LOGIC_LANE_2 | LANE0_MAP_LOGIC_LANE_3;
+	else
+		val = LANE3_MAP_LOGIC_LANE_3 | LANE2_MAP_LOGIC_LANE_2 |
+			LANE1_MAP_LOGIC_LANE_1 | LANE0_MAP_LOGIC_LANE_0;
+
+	writel(val, edp->regs + LANE_MAP);
+}
+
+void rk32_edp_init_refclk(struct rk32_edp *edp)
+{
+	u32 val;
+	/*struct rk32_edp_platdata *pdata = edp->dev->platform_data;
+	struct analog_param *analog_param = pdata->analog_param;
+
+	val = TX_TERMINAL_CTRL_50_OHM;
+	writel(val, edp->regs + ANALOG_CTL_1);*/
+
+	val = SEL_24M;
+	writel(val, edp->regs + ANALOG_CTL_2);
+
+	if (edp->soctype == SOC_RK3399)
+		val = 0x1 << 0;
+	else
+		val = REF_CLK_24M;
+	writel(val, edp->regs + PLL_REG_1);
+
+	val = 0x95;
+	writel(val, edp->regs + PLL_REG_2);
+
+	val = 0x40;
+	writel(val, edp->regs + PLL_REG_3);
+
+	val = 0x58;
+	writel(val, edp->regs + PLL_REG_4);
+
+	val = 0x22;
+	writel(val, edp->regs + PLL_REG_5);
+
+	val = 0x19;
+	writel(val, edp->regs + SSC_REG);
+	val = 0x87;
+	writel(val, edp->regs + TX_REG_COMMON);
+	val = 0x03;
+	writel(val, edp->regs + DP_AUX);
+	val = 0x46;
+	writel(val, edp->regs + DP_BIAS);
+	val = 0x55;
+	writel(val, edp->regs + DP_RESERVE2);
+
+
+	/*val = DRIVE_DVDD_BIT_1_0625V | VCO_BIT_600_MICRO;
+	writel(val, edp->regs + ANALOG_CTL_3);
+
+	if (!analog_param) {
+		val = PD_RING_OSC | AUX_TERMINAL_CTRL_50_OHM |
+			TX_CUR1_2X | TX_CUR_16_MA;
+		writel(val, edp->regs + PLL_FILTER_CTL_1);
+
+		val = CH3_AMP_400_MV | CH2_AMP_400_MV |
+			CH1_AMP_400_MV | CH0_AMP_400_MV;
+		writel(val, edp->regs + TX_AMP_TUNING_CTL);
+	} else {
+		int tx_amp;
+
+		val = PD_RING_OSC | TX_CUR1_2X | TX_CUR_16_MA;
+		switch (analog_param->aux_tx_terminal_resistor) {
+		case AUX_TX_37_5_OHM:
+			val |= AUX_TERMINAL_CTRL_37_5_OHM;
+			break;
+		case AUX_TX_45_OHM:
+			val |= AUX_TERMINAL_CTRL_45_OHM;
+			break;
+		case AUX_TX_50_OHM:
+			val |= AUX_TERMINAL_CTRL_50_OHM;
+			break;
+		case AUX_TX_65_OHM:
+			val |= AUX_TERMINAL_CTRL_65_OHM;
+			break;
+		}
+		writel(val, edp->regs + PLL_FILTER_CTL_1);
+
+		tx_amp = analog_param->tx_amplitude;
+		if (tx_amp < 200000 || tx_amp > 500000) {
+			dev_warn(edp->dev,
+				 "TX amp out of range, defaulting to 400mV\n");
+			tx_amp = 400000;
+		}
+
+		tx_amp = ((tx_amp - 400000) / 12500) & 0x1f;
+
+		val = (tx_amp << CH3_AMP_SHIFT) | (tx_amp << CH2_AMP_SHIFT) |
+			(tx_amp << CH1_AMP_SHIFT) | (tx_amp << CH0_AMP_SHIFT);
+		writel(val, edp->regs + TX_AMP_TUNING_CTL);
+	}*/
+}
+
+void rk32_edp_init_interrupt(struct rk32_edp *edp)
+{
+	/* Set interrupt pin assertion polarity as high */
+	writel(INT_POL, edp->regs + INT_CTL);
+
+	/* Clear pending valisers */
+	writel(0xff, edp->regs + COMMON_INT_STA_1);
+	writel(0x4f, edp->regs + COMMON_INT_STA_2);
+	writel(0xff, edp->regs + COMMON_INT_STA_3);
+	writel(0x27, edp->regs + COMMON_INT_STA_4);
+
+	writel(0x7f, edp->regs + DP_INT_STA);
+
+	/* 0:mask,1: unmask */
+	writel(0x00, edp->regs + COMMON_INT_MASK_1);
+	writel(0x00, edp->regs + COMMON_INT_MASK_2);
+	writel(0x00, edp->regs + COMMON_INT_MASK_3);
+	writel(0x00, edp->regs + COMMON_INT_MASK_4);
+	writel(0x00, edp->regs + DP_INT_STA_MASK);
+}
+
+void rk32_edp_reset(struct rk32_edp *edp)
+{
+	u32 val;
+
+	rk32_edp_stop_video(edp);
+	rk32_edp_enable_video_mute(edp, 0);
+
+	val = VID_CAP_FUNC_EN_N | AUD_FIFO_FUNC_EN_N |
+		AUD_FUNC_EN_N | HDCP_FUNC_EN_N | SW_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_1);
+
+	val = SSC_FUNC_EN_N | AUX_FUNC_EN_N |
+		SERDES_FIFO_FUNC_EN_N |
+		LS_CLK_DOMAIN_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_2);
+
+	udelay(20);
+
+	rk32_edp_lane_swap(edp, 0);
+
+	writel(0x0, edp->regs + SYS_CTL_1);
+	writel(0x40, edp->regs + SYS_CTL_2);
+	writel(0x0, edp->regs + SYS_CTL_3);
+	writel(0x0, edp->regs + SYS_CTL_4);
+
+	writel(0x0, edp->regs + PKT_SEND_CTL);
+	writel(0x0, edp->regs + HDCP_CTL);
+
+	writel(0x5e, edp->regs + HPD_DEGLITCH_L);
+	writel(0x1a, edp->regs + HPD_DEGLITCH_H);
+
+	writel(0x10, edp->regs + LINK_DEBUG_CTL);
+
+	writel(0x0, edp->regs + VIDEO_FIFO_THRD);
+	writel(0x20, edp->regs + AUDIO_MARGIN);
+
+	writel(0x4, edp->regs + M_VID_GEN_FILTER_TH);
+	writel(0x2, edp->regs + M_AUD_GEN_FILTER_TH);
+
+	writel(0x0, edp->regs + SOC_GENERAL_CTL);
+
+}
+
+void rk32_edp_config_interrupt(struct rk32_edp *edp)
+{
+	u32 val;
+
+	/* 0: mask, 1: unmask */
+	val = 0;
+	writel(val, edp->regs + COMMON_INT_MASK_1);
+
+	writel(val, edp->regs + COMMON_INT_MASK_2);
+
+	writel(val, edp->regs + COMMON_INT_MASK_3);
+
+	writel(val, edp->regs + COMMON_INT_MASK_4);
+
+	writel(val, edp->regs + DP_INT_STA_MASK);
+}
+
+u32 rk32_edp_get_pll_lock_status(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + DEBUG_CTL);
+	if (val & PLL_LOCK)
+		return DP_PLL_LOCKED;
+	else
+		return DP_PLL_UNLOCKED;
+}
+
+
+void rk32_edp_analog_power_ctr(struct rk32_edp *edp, bool enable)
+{
+	u32 val;
+
+	if (enable) {
+		val = PD_EXP_BG | PD_AUX | PD_PLL |
+			PD_CH3 | PD_CH2 | PD_CH1 | PD_CH0;
+		writel(val, edp->regs + DP_PWRDN);
+		udelay(10);
+		writel(0x0, edp->regs + DP_PWRDN);
+	} else {
+		val = PD_EXP_BG | PD_AUX | PD_PLL |
+			PD_CH3 | PD_CH2 | PD_CH1 | PD_CH0;
+		writel(val, edp->regs + DP_PWRDN);
+	}
+}
+
+
+void rk32_edp_init_analog_func(struct rk32_edp *edp)
+{
+	u32 val;
+	int wt = 0;
+	rk32_edp_analog_power_ctr(edp, 1);
+
+	val = PLL_LOCK_CHG;
+	writel(val, edp->regs + COMMON_INT_STA_1);
+
+	val = readl(edp->regs + DEBUG_CTL);
+	val &= ~(F_PLL_LOCK | PLL_LOCK_CTRL);
+	writel(val, edp->regs + DEBUG_CTL);
+
+	/* Power up PLL */
+	while (wt < 100) {
+		if (rk32_edp_get_pll_lock_status(edp) == DP_PLL_LOCKED) {
+			dev_info(edp->dev, "edp pll locked\n");
+			break;
+		} else {
+			wt++;
+			udelay(5);
+		}
+	}
+
+	/* Enable Serdes FIFO function and Link symbol clock domain module */
+	val = readl(edp->regs + FUNC_EN_2);
+	val &= ~(SERDES_FIFO_FUNC_EN_N | LS_CLK_DOMAIN_FUNC_EN_N
+		| AUX_FUNC_EN_N | SSC_FUNC_EN_N);
+	writel(val, edp->regs + FUNC_EN_2);
+}
+
+void rk32_edp_init_hpd(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = HOTPLUG_CHG | HPD_LOST | PLUG;
+	writel(val, edp->regs + COMMON_INT_STA_4);
+
+	val = INT_HPD;
+	writel(val, edp->regs + DP_INT_STA);
+
+	val = readl(edp->regs + SYS_CTL_3);
+	val |= (F_HPD | HPD_CTRL);
+	writel(val, edp->regs + SYS_CTL_3);
+}
+
+void rk32_edp_reset_aux(struct rk32_edp *edp)
+{
+	u32 val;
+
+	/* Disable AUX channel module */
+	val = readl(edp->regs + FUNC_EN_2);
+	val |= AUX_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_2);
+}
+
+void rk32_edp_init_aux(struct rk32_edp *edp)
+{
+	u32 val;
+
+	/* Clear inerrupts related to AUX channel */
+	val = RPLY_RECEIV | AUX_ERR;
+	writel(val, edp->regs + DP_INT_STA);
+
+	rk32_edp_reset_aux(edp);
+
+	/* Disable AUX transaction H/W retry */
+	/*val = AUX_BIT_PERIOD_EXPECTED_DELAY(3) | AUX_HW_RETRY_COUNT_SEL(0)|
+		AUX_HW_RETRY_INTERVAL_600_MICROSECONDS;
+	writel(val, edp->regs + AUX_HW_RETRY_CTL) ;*/
+
+	/* Receive AUX Channel DEFER commands equal to DEFFER_COUNT*64 */
+	val = DEFER_CTRL_EN | DEFER_COUNT(1);
+	writel(val, edp->regs + AUX_CH_DEFER_CTL);
+
+	/* Enable AUX channel module */
+	val = readl(edp->regs + FUNC_EN_2);
+	val &= ~AUX_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_2);
+}
+
+int rk32_edp_get_plug_in_status(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + SYS_CTL_3);
+	if (val & HPD_STATUS)
+		return 0;
+
+	return -EINVAL;
+}
+
+void rk32_edp_enable_sw_function(struct rk32_edp *edp)
+{
+	u32 val;
+	val = readl(edp->regs + FUNC_EN_1);
+	val &= ~SW_FUNC_EN_N;
+	writel(val, edp->regs + FUNC_EN_1);
+}
+
+int rk32_edp_start_aux_transaction(struct rk32_edp *edp)
+{
+	int val;
+	int retval = 0;
+	int timeout_loop = 0;
+	int aux_timeout = 0;
+
+	/* Enable AUX CH operation */
+	val = readl(edp->regs + AUX_CH_CTL_2);
+	val |= AUX_EN;
+	writel(val, edp->regs + AUX_CH_CTL_2);
+
+	/* Is AUX CH operation enabled? */
+	val = readl(edp->regs + AUX_CH_CTL_2);
+	while (val & AUX_EN) {
+		aux_timeout++;
+		if ((DP_TIMEOUT_LOOP_CNT * 10) < aux_timeout) {
+			dev_err(edp->dev, "AUX CH enable timeout!\n");
+			return -ETIMEDOUT;
+		}
+		val = readl(edp->regs + AUX_CH_CTL_2);
+		udelay(100);
+	}
+
+	/* Is AUX CH command redply received? */
+	val = readl(edp->regs + DP_INT_STA);
+	while (!(val & RPLY_RECEIV)) {
+		timeout_loop++;
+		if (DP_TIMEOUT_LOOP_CNT < timeout_loop) {
+			dev_err(edp->dev, "AUX CH command redply failed!\n");
+			return -ETIMEDOUT;
+		}
+		val = readl(edp->regs + DP_INT_STA);
+		udelay(10);
+	}
+
+	/* Clear interrupt source for AUX CH command redply */
+	writel(RPLY_RECEIV, edp->regs + DP_INT_STA);
+
+	/* Clear interrupt source for AUX CH access error */
+	val = readl(edp->regs + DP_INT_STA);
+	if (val & AUX_ERR) {
+		writel(AUX_ERR, edp->regs + DP_INT_STA);
+		return -EREMOTEIO;
+	}
+
+	/* Check AUX CH error access status */
+	val = readl(edp->regs + AUX_CH_STA);
+	if ((val & AUX_STATUS_MASK) != 0) {
+		dev_err(edp->dev, "AUX CH error happens: %d\n\n",
+			val & AUX_STATUS_MASK);
+		return -EREMOTEIO;
+	}
+
+	return retval;
+}
+
+int rk32_edp_write_byte_to_dpcd(struct rk32_edp *edp,
+				unsigned int val_addr,
+				unsigned char data)
+{
+	u32 val;
+	int i;
+	int retval;
+
+	for (i = 0; i < 3; i++) {
+		/* Clear AUX CH data buffer */
+		val = BUF_CLR;
+		writel(val, edp->regs + BUFFER_DATA_CTL);
+
+		/* Select DPCD device address */
+		val = AUX_ADDR_7_0(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_7_0);
+		val = AUX_ADDR_15_8(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_15_8);
+		val = AUX_ADDR_19_16(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_19_16);
+
+		/* Write data buffer */
+		val = (unsigned int)data;
+		writel(val, edp->regs + BUF_DATA_0);
+
+		/*
+		 * Set DisplayPort transaction and write 1 byte
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		val = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;
+		writel(val, edp->regs + AUX_CH_CTL_1);
+
+		/* Start AUX transaction */
+		retval = rk32_edp_start_aux_transaction(edp);
+		if (retval == 0)
+			break;
+		else
+			dev_dbg(edp->dev, "Aux Transaction fail!\n");
+	}
+
+	return retval;
+}
+
+int rk32_edp_read_byte_from_dpcd(struct rk32_edp *edp,
+				unsigned int val_addr,
+				unsigned char *data)
+{
+	u32 val;
+	int i;
+	int retval;
+
+	for (i = 0; i < 10; i++) {
+		/* Clear AUX CH data buffer */
+		val = BUF_CLR;
+		writel(val, edp->regs + BUFFER_DATA_CTL);
+
+		/* Select DPCD device address */
+		val = AUX_ADDR_7_0(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_7_0);
+		val = AUX_ADDR_15_8(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_15_8);
+		val = AUX_ADDR_19_16(val_addr);
+		writel(val, edp->regs + DP_AUX_ADDR_19_16);
+
+		/*
+		 * Set DisplayPort transaction and read 1 byte
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		val = AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;
+		writel(val, edp->regs + AUX_CH_CTL_1);
+
+		/* Start AUX transaction */
+		retval = rk32_edp_start_aux_transaction(edp);
+		if (retval == 0)
+			break;
+		else
+			dev_dbg(edp->dev, "Aux Transaction fail!\n");
+	}
+
+	/* Read data buffer */
+	val = readl(edp->regs + BUF_DATA_0);
+	*data = (unsigned char)(val & 0xff);
+
+	return retval;
+}
+
+int rk32_edp_write_bytes_to_dpcd(struct rk32_edp *edp,
+				unsigned int val_addr,
+				unsigned int count,
+				unsigned char data[])
+{
+	u32 val;
+	unsigned int start_offset;
+	unsigned int cur_data_count;
+	unsigned int cur_data_idx;
+	int i;
+	int retval = 0;
+
+	/* Clear AUX CH data buffer */
+	val = BUF_CLR;
+	writel(val, edp->regs + BUFFER_DATA_CTL);
+
+	start_offset = 0;
+	while (start_offset < count) {
+		/* Buffer size of AUX CH is 16 * 4bytes */
+		if ((count - start_offset) > 16)
+			cur_data_count = 16;
+		else
+			cur_data_count = count - start_offset;
+
+		for (i = 0; i < 10; i++) {
+			/* Select DPCD device address */
+			val = AUX_ADDR_7_0(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_7_0);
+			val = AUX_ADDR_15_8(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_15_8);
+			val = AUX_ADDR_19_16(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_19_16);
+
+			for (cur_data_idx = 0; cur_data_idx < cur_data_count;
+			     cur_data_idx++) {
+				val = data[start_offset + cur_data_idx];
+				writel(val, edp->regs + BUF_DATA_0
+							  + 4 * cur_data_idx);
+			}
+
+			/*
+			 * Set DisplayPort transaction and write
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			val = AUX_LENGTH(cur_data_count) |
+				AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_WRITE;
+			writel(val, edp->regs + AUX_CH_CTL_1);
+
+			/* Start AUX transaction */
+			retval = rk32_edp_start_aux_transaction(edp);
+			if (retval == 0)
+				break;
+			else
+				dev_dbg(edp->dev, "Aux Transaction fail!\n");
+		}
+
+		start_offset += cur_data_count;
+	}
+
+	return retval;
+}
+
+int rk32_edp_read_bytes_from_dpcd(struct rk32_edp *edp,
+				unsigned int val_addr,
+				unsigned int count,
+				unsigned char data[])
+{
+	u32 val;
+	unsigned int start_offset;
+	unsigned int cur_data_count;
+	unsigned int cur_data_idx;
+	int i;
+	int retval = 0;
+
+	/* Clear AUX CH data buffer */
+	val = BUF_CLR;
+	writel(val, edp->regs + BUFFER_DATA_CTL);
+
+	start_offset = 0;
+	while (start_offset < count) {
+		/* Buffer size of AUX CH is 16 * 4bytes */
+		if ((count - start_offset) > 16)
+			cur_data_count = 16;
+		else
+			cur_data_count = count - start_offset;
+
+		/* AUX CH Request Transaction process */
+		for (i = 0; i < 10; i++) {
+			/* Select DPCD device address */
+			val = AUX_ADDR_7_0(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_7_0);
+			val = AUX_ADDR_15_8(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_15_8);
+			val = AUX_ADDR_19_16(val_addr + start_offset);
+			writel(val, edp->regs + DP_AUX_ADDR_19_16);
+
+			/*
+			 * Set DisplayPort transaction and read
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			val = AUX_LENGTH(cur_data_count) |
+				AUX_TX_COMM_DP_TRANSACTION | AUX_TX_COMM_READ;
+			writel(val, edp->regs + AUX_CH_CTL_1);
+
+			/* Start AUX transaction */
+			retval = rk32_edp_start_aux_transaction(edp);
+			if (retval == 0)
+				break;
+			else
+				dev_dbg(edp->dev, "Aux Transaction fail!\n");
+		}
+
+		for (cur_data_idx = 0; cur_data_idx < cur_data_count;
+		    cur_data_idx++) {
+			val = readl(edp->regs + BUF_DATA_0
+						 + 4 * cur_data_idx);
+			data[start_offset + cur_data_idx] =
+				(unsigned char)val;
+		}
+
+		start_offset += cur_data_count;
+	}
+
+	return retval;
+}
+
+int rk32_edp_select_i2c_device(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int val_addr)
+{
+	u32 val;
+	int retval;
+
+	/* Set EDID device address */
+	val = device_addr;
+	writel(val, edp->regs + DP_AUX_ADDR_7_0);
+	writel(0x0, edp->regs + DP_AUX_ADDR_15_8);
+	writel(0x0, edp->regs + DP_AUX_ADDR_19_16);
+
+	/* Set offset from base address of EDID device */
+	writel(val_addr, edp->regs + BUF_DATA_0);
+
+	/*
+	 * Set I2C transaction and write address
+	 * If bit 3 is 1, DisplayPort transaction.
+	 * If Bit 3 is 0, I2C transaction.
+	 */
+	val = AUX_TX_COMM_I2C_TRANSACTION | AUX_TX_COMM_MOT |
+		AUX_TX_COMM_WRITE;
+	writel(val, edp->regs + AUX_CH_CTL_1);
+
+	/* Start AUX transaction */
+	retval = rk32_edp_start_aux_transaction(edp);
+	if (retval != 0)
+		dev_dbg(edp->dev, "Aux Transaction fail!\n");
+
+	return retval;
+}
+
+int rk32_edp_read_byte_from_i2c(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int val_addr,
+				unsigned int *data)
+{
+	u32 val;
+	int i;
+	int retval;
+
+	for (i = 0; i < 10; i++) {
+		/* Clear AUX CH data buffer */
+		val = BUF_CLR;
+		writel(val, edp->regs + BUFFER_DATA_CTL);
+
+		/* Select EDID device */
+		retval = rk32_edp_select_i2c_device(edp, device_addr, val_addr);
+		if (retval != 0) {
+			dev_err(edp->dev, "Select EDID device fail!\n");
+			continue;
+		}
+
+		/*
+		 * Set I2C transaction and read data
+		 * If bit 3 is 1, DisplayPort transaction.
+		 * If Bit 3 is 0, I2C transaction.
+		 */
+		val = AUX_TX_COMM_I2C_TRANSACTION | AUX_TX_COMM_READ;
+		writel(val, edp->regs + AUX_CH_CTL_1);
+
+		/* Start AUX transaction */
+		retval = rk32_edp_start_aux_transaction(edp);
+		if (retval == 0)
+			break;
+		else
+			dev_dbg(edp->dev, "Aux Transaction fail!\n");
+	}
+
+	/* Read data */
+	if (retval == 0)
+		*data = readl(edp->regs + BUF_DATA_0);
+
+	return retval;
+}
+
+int rk32_edp_read_bytes_from_i2c(struct rk32_edp *edp,
+				unsigned int device_addr,
+				unsigned int val_addr,
+				unsigned int count,
+				unsigned char edid[])
+{
+	u32 val;
+	unsigned int i, j;
+	unsigned int cur_data_idx;
+	unsigned int defer = 0;
+	int retval = 0;
+
+	for (i = 0; i < count; i += 16) {
+		for (j = 0; j < 100; j++) {
+			/* Clear AUX CH data buffer */
+			val = BUF_CLR;
+			writel(val, edp->regs + BUFFER_DATA_CTL);
+
+			/* Set normal AUX CH command */
+			val = readl(edp->regs + AUX_CH_CTL_2);
+			val &= ~ADDR_ONLY;
+			writel(val, edp->regs + AUX_CH_CTL_2);
+
+			/*
+			 * If Rx sends defer, Tx sends only reads
+			 * request without sending addres
+			 */
+			if (!defer)
+				retval = rk32_edp_select_i2c_device(edp,
+						device_addr, val_addr + i);
+			else
+				defer = 0;
+
+			/*
+			 * Set I2C transaction and write data
+			 * If bit 3 is 1, DisplayPort transaction.
+			 * If Bit 3 is 0, I2C transaction.
+			 */
+			val = AUX_LENGTH(16) | AUX_TX_COMM_I2C_TRANSACTION |
+				AUX_TX_COMM_READ;
+			writel(val, edp->regs + AUX_CH_CTL_1);
+
+			/* Start AUX transaction */
+			retval = rk32_edp_start_aux_transaction(edp);
+			if (retval == 0)
+				break;
+			else
+				dev_dbg(edp->dev, "Aux Transaction fail!\n");
+
+			/* Check if Rx sends defer */
+			val = readl(edp->regs + AUX_RX_COMM);
+			if (val == AUX_RX_COMM_AUX_DEFER ||
+				val == AUX_RX_COMM_I2C_DEFER) {
+				dev_err(edp->dev, "Defer: %d\n\n", val);
+				defer = 1;
+			}
+		}
+
+		for (cur_data_idx = 0; cur_data_idx < 16; cur_data_idx++) {
+			val = readl(edp->regs + BUF_DATA_0 + 4 * cur_data_idx);
+			edid[i + cur_data_idx] = (unsigned char)val;
+		}
+	}
+
+	return retval;
+}
+
+void rk32_edp_set_link_bandwidth(struct rk32_edp *edp, u32 bwtype)
+{
+	u32 val;
+
+	val = bwtype;
+	if ((bwtype == LINK_RATE_2_70GBPS) || (bwtype == LINK_RATE_1_62GBPS))
+		writel(val, edp->regs + LINK_BW_SET);
+}
+
+void rk32_edp_get_link_bandwidth(struct rk32_edp *edp, u32 *bwtype)
+{
+	u32 val;
+
+	val = readl(edp->regs + LINK_BW_SET);
+	*bwtype = val;
+}
+
+void rk32_edp_hw_link_training_en(struct rk32_edp *edp)
+{
+	u32 val;
+	val = HW_LT_EN;
+	writel(val, edp->regs + HW_LT_CTL);
+}
+
+int rk32_edp_wait_hw_lt_done(struct rk32_edp *edp)
+{
+	u32 val;
+#if 0
+	val = readl(edp->regs + HW_LT_CTL);
+	return val&0x01;
+#else
+	val = readl(edp->regs + DP_INT_STA);
+	if (val&HW_LT_DONE) {
+		writel(val, edp->regs + DP_INT_STA);
+		return 0;
+	} else {
+		return 1;
+	}
+#endif
+}
+
+int rk32_edp_get_hw_lt_status(struct rk32_edp *edp)
+{
+	u32 val;
+	val = readl(edp->regs + HW_LT_CTL);
+	return (val & HW_LT_ERR_CODE_MASK) >> 4;
+}
+void rk32_edp_set_lane_count(struct rk32_edp *edp, u32 count)
+{
+	u32 val;
+
+	val = count;
+	writel(val, edp->regs + LANE_CNT_SET);
+}
+
+void rk32_edp_get_lane_count(struct rk32_edp *edp, u32 *count)
+{
+	u32 val;
+
+	val = readl(edp->regs + LANE_CNT_SET);
+	*count = val;
+}
+
+void rk32_edp_enable_enhanced_mode(struct rk32_edp *edp, bool enable)
+{
+	u32 val;
+
+	if (enable) {
+		val = readl(edp->regs + SYS_CTL_4);
+		val |= ENHANCED;
+		writel(val, edp->regs + SYS_CTL_4);
+	} else {
+		val = readl(edp->regs + SYS_CTL_4);
+		val &= ~ENHANCED;
+		writel(val, edp->regs + SYS_CTL_4);
+	}
+}
+
+void rk32_edp_set_training_pattern(struct rk32_edp *edp,
+				 enum pattern_set pattern)
+{
+	u32 val;
+
+	switch (pattern) {
+	case PRBS7:
+		val = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_PRBS7;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	case D10_2:
+		val = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_D10_2;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	case TRAINING_PTN1:
+		val = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN1;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	case TRAINING_PTN2:
+		val = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN2;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	case DP_NONE:
+		val = SCRAMBLING_ENABLE |
+			LINK_QUAL_PATTERN_SET_DISABLE |
+			SW_TRAINING_PATTERN_SET_DISABLE;
+		writel(val, edp->regs + TRAINING_PTN_SET);
+		break;
+	default:
+		break;
+	}
+}
+
+void rk32_edp_set_lane0_pre_emphasis(struct rk32_edp *edp, u32 level)
+{
+	u32 val;
+
+	val = level << PRE_EMPHASIS_SET_SHIFT;
+	writel(val, edp->regs + LN0_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane1_pre_emphasis(struct rk32_edp *edp, u32 level)
+{
+	u32 val;
+
+	val = level << PRE_EMPHASIS_SET_SHIFT;
+	writel(val, edp->regs + LN1_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane2_pre_emphasis(struct rk32_edp *edp, u32 level)
+{
+	u32 val;
+
+	val = level << PRE_EMPHASIS_SET_SHIFT;
+	writel(val, edp->regs + LN2_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane3_pre_emphasis(struct rk32_edp *edp, u32 level)
+{
+	u32 val;
+
+	val = level << PRE_EMPHASIS_SET_SHIFT;
+	writel(val, edp->regs + LN3_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane0_link_training(struct rk32_edp *edp,
+					u32 training_lane)
+{
+	u32 val;
+
+	val = training_lane;
+	writel(val, edp->regs + LN0_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane1_link_training(struct rk32_edp *edp,
+					u32 training_lane)
+{
+	u32 val;
+
+	val = training_lane;
+	writel(val, edp->regs + LN1_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane2_link_training(struct rk32_edp *edp,
+					u32 training_lane)
+{
+	u32 val;
+
+	val = training_lane;
+	writel(val, edp->regs + LN2_LINK_TRAINING_CTL);
+}
+
+void rk32_edp_set_lane3_link_training(struct rk32_edp *edp,
+					u32 training_lane)
+{
+	u32 val;
+
+	val = training_lane;
+	writel(val, edp->regs + LN3_LINK_TRAINING_CTL);
+}
+
+u32 rk32_edp_get_lane0_link_training(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + LN0_LINK_TRAINING_CTL);
+	return val;
+}
+
+u32 rk32_edp_get_lane1_link_training(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + LN1_LINK_TRAINING_CTL);
+	return val;
+}
+
+u32 rk32_edp_get_lane2_link_training(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + LN2_LINK_TRAINING_CTL);
+	return val;
+}
+
+u32 rk32_edp_get_lane3_link_training(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + LN3_LINK_TRAINING_CTL);
+	return val;
+}
+
+void rk32_edp_reset_macro(struct rk32_edp *edp)
+{
+	/*u32 val;
+
+	val = readl(edp->regs + PHY_TEST);
+	val |= MACRO_RST;
+	writel(val, edp->regs + PHY_TEST);
+
+
+	udelay(10);
+
+	val &= ~MACRO_RST;
+	writel(val, edp->regs + PHY_TEST);*/
+}
+
+int rk32_edp_init_video(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = VSYNC_DET | VID_FORMAT_CHG | VID_CLK_CHG;
+	writel(val, edp->regs + COMMON_INT_STA_1);
+
+	val = 0x0;
+	writel(val, edp->regs + SYS_CTL_1);
+
+	val = CHA_CRI(4) | CHA_CTRL;
+	writel(val, edp->regs + SYS_CTL_2);
+
+	/*val = 0x0;
+	writel(val, edp->regs + SYS_CTL_3);*/
+
+	val = VID_HRES_TH(2) | VID_VRES_TH(0);
+	writel(val, edp->regs + VIDEO_CTL_8);
+
+	return 0;
+}
+
+void rk32_edp_set_video_color_format(struct rk32_edp *edp,
+			u32 color_dedpth,
+			u32 color_space,
+			u32 dynamic_range,
+			u32 coeff)
+{
+	u32 val;
+
+	/* Configure the input color dedpth, color space, dynamic range */
+	val = (dynamic_range << IN_D_RANGE_SHIFT) |
+		(color_dedpth << IN_BPC_SHIFT) |
+		(color_space << IN_COLOR_F_SHIFT);
+	writel(val, edp->regs + VIDEO_CTL_2);
+
+	/* Set Input Color YCbCr Coefficients to ITU601 or ITU709 */
+	val = readl(edp->regs + VIDEO_CTL_3);
+	val &= ~IN_YC_COEFFI_MASK;
+	if (coeff)
+		val |= IN_YC_COEFFI_ITU709;
+	else
+		val |= IN_YC_COEFFI_ITU601;
+	writel(val, edp->regs + VIDEO_CTL_3);
+}
+
+int rk32_edp_is_slave_video_stream_clock_on(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + SYS_CTL_1);
+	writel(val, edp->regs + SYS_CTL_1);
+
+	val = readl(edp->regs + SYS_CTL_1);
+
+	if (!(val & DET_STA)) {
+		dev_dbg(edp->dev, "Input stream clock not detected.\n");
+		return -EINVAL;
+	}
+
+	val = readl(edp->regs + SYS_CTL_2);
+	writel(val, edp->regs + SYS_CTL_2);
+
+	val = readl(edp->regs + SYS_CTL_2);
+	if (val & CHA_STA) {
+		dev_dbg(edp->dev, "Input stream clk is changing\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+void rk32_edp_set_video_cr_mn(struct rk32_edp *edp,
+		enum clock_recovery_m_value_type type,
+		u32 m_value,
+		u32 n_value)
+{
+	u32 val;
+
+	if (type == REGISTER_M) {
+		val = readl(edp->regs + SYS_CTL_4);
+		val |= FIX_M_VID;
+		writel(val, edp->regs + SYS_CTL_4);
+		val = m_value & 0xff;
+		writel(val, edp->regs + M_VID_0);
+		val = (m_value >> 8) & 0xff;
+		writel(val, edp->regs + M_VID_1);
+		val = (m_value >> 16) & 0xff;
+		writel(val, edp->regs + M_VID_2);
+
+		val = n_value & 0xff;
+		writel(val, edp->regs + N_VID_0);
+		val = (n_value >> 8) & 0xff;
+		writel(val, edp->regs + N_VID_1);
+		val = (n_value >> 16) & 0xff;
+		writel(val, edp->regs + N_VID_2);
+	} else  {
+		val = readl(edp->regs + SYS_CTL_4);
+		val &= ~FIX_M_VID;
+		writel(val, edp->regs + SYS_CTL_4);
+
+		writel(0x00, edp->regs + N_VID_0);
+		writel(0x80, edp->regs + N_VID_1);
+		writel(0x00, edp->regs + N_VID_2);
+	}
+}
+
+void rk32_edp_set_video_timing_mode(struct rk32_edp *edp, u32 type)
+{
+	u32 val;
+
+	if (type == VIDEO_TIMING_FROM_CAPTURE) {
+		val = readl(edp->regs + VIDEO_CTL_10);
+		val &= ~F_SEL;
+		writel(val, edp->regs + VIDEO_CTL_10);
+	} else {
+		val = readl(edp->regs + VIDEO_CTL_10);
+		val |= F_SEL;
+		writel(val, edp->regs + VIDEO_CTL_10);
+	}
+}
+
+int rk32_edp_bist_cfg(struct rk32_edp *edp)
+{
+	struct video_info *video_info = &edp->video_info;
+	struct rk_screen *screen = &edp->screen;
+	u16 x_total, y_total, x_act;
+	u32 val;
+	x_total = screen->mode.left_margin + screen->mode.right_margin +
+			screen->mode.xres + screen->mode.hsync_len;
+	y_total = screen->mode.upper_margin + screen->mode.lower_margin +
+			screen->mode.yres + screen->mode.vsync_len;
+	x_act = screen->mode.xres;
+
+	rk32_edp_set_video_cr_mn(edp, CALCULATED_M, 0, 0);
+	rk32_edp_set_video_color_format(edp, video_info->color_depth,
+					video_info->color_space,
+					video_info->dynamic_range,
+					video_info->ycbcr_coeff);
+
+	val = y_total & 0xff;
+	writel(val, edp->regs + TOTAL_LINE_CFG_L);
+	val = (y_total >> 8);
+	writel(val, edp->regs + TOTAL_LINE_CFG_H);
+	val = (screen->mode.yres & 0xff);
+	writel(val, edp->regs + ATV_LINE_CFG_L);
+	val = (screen->mode.yres >> 8);
+	writel(val, edp->regs + ATV_LINE_CFG_H);
+	val = screen->mode.lower_margin;
+	writel(val, edp->regs + VF_PORCH_REG);
+	val = screen->mode.vsync_len;
+	writel(val, edp->regs + VSYNC_CFG_REG);
+	val = screen->mode.upper_margin;
+	writel(val, edp->regs + VB_PORCH_REG);
+	val = x_total & 0xff;
+	writel(val, edp->regs + TOTAL_PIXELL_REG);
+	val = x_total >> 8;
+	writel(val, edp->regs + TOTAL_PIXELH_REG);
+	val = (x_act & 0xff);
+	writel(val, edp->regs + ATV_PIXELL_REG);
+	val = (x_act >> 8);
+	writel(val, edp->regs + ATV_PIXELH_REG);
+	val = screen->mode.right_margin & 0xff;
+	writel(val, edp->regs + HF_PORCHL_REG);
+	val = screen->mode.right_margin >> 8;
+	writel(val, edp->regs + HF_PORCHH_REG);
+	val = screen->mode.hsync_len & 0xff;
+	writel(val, edp->regs + HSYNC_CFGL_REG);
+	val = screen->mode.hsync_len >> 8;
+	writel(val, edp->regs + HSYNC_CFGH_REG);
+	val = screen->mode.left_margin & 0xff;
+	writel(val, edp->regs + HB_PORCHL_REG);
+	val = screen->mode.left_margin  >> 8;
+	writel(val, edp->regs + HB_PORCHH_REG);
+
+	val = BIST_EN | BIST_WH_64 | BIST_TYPE_COLR_BAR;
+	writel(val, edp->regs + VIDEO_CTL_4);
+
+	val = readl(edp->regs + VIDEO_CTL_10);
+	val &= ~F_SEL;
+	writel(val, edp->regs + VIDEO_CTL_10);
+	return 0;
+
+}
+
+void rk32_edp_enable_video_master(struct rk32_edp *edp, bool enable)
+{
+	/*u32 val;
+
+	if (enable) {
+		val = readl(edp->regs + SOC_GENERAL_CTL);
+		val &= ~VIDEO_MODE_MASK;
+		val |= VIDEO_MASTER_MODE_EN | VIDEO_MODE_MASTER_MODE;
+		writel(val, edp->regs + SOC_GENERAL_CTL);
+	} else {
+		val = readl(edp->regs + SOC_GENERAL_CTL);
+		val &= ~VIDEO_MODE_MASK;
+		val |= VIDEO_MODE_SLAVE_MODE;
+		writel(val, edp->regs + SOC_GENERAL_CTL);
+	}*/
+}
+
+void rk32_edp_start_video(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + VIDEO_CTL_1);
+	val |= VIDEO_EN;
+	writel(val, edp->regs + VIDEO_CTL_1);
+}
+
+int rk32_edp_is_video_stream_on(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + SYS_CTL_3);
+	writel(val, edp->regs + SYS_CTL_3);
+
+	val = readl(edp->regs + SYS_CTL_3);
+	if (!(val & STRM_VALID)) {
+		dev_dbg(edp->dev, "Input video stream is not detected.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void rk32_edp_config_video_slave_mode(struct rk32_edp *edp,
+			struct video_info *video_info)
+{
+	u32 val;
+
+	val = readl(edp->regs + FUNC_EN_1);
+	val &= ~(VID_FIFO_FUNC_EN_N | VID_CAP_FUNC_EN_N);
+	writel(val, edp->regs + FUNC_EN_1);
+
+	val = readl(edp->regs + VIDEO_CTL_10);
+	val &= ~INTERACE_SCAN_CFG;
+	val |= (video_info->interlaced << 2);
+	writel(val, edp->regs + VIDEO_CTL_10);
+
+	val = readl(edp->regs + VIDEO_CTL_10);
+	val &= ~VSYNC_POLARITY_CFG;
+	val |= (video_info->v_sync_polarity << 1);
+	writel(val, edp->regs + VIDEO_CTL_10);
+
+	val = readl(edp->regs + VIDEO_CTL_10);
+	val &= ~HSYNC_POLARITY_CFG;
+	val |= (video_info->h_sync_polarity << 0);
+	writel(val, edp->regs + VIDEO_CTL_10);
+
+	/*val = AUDIO_MODE_SPDIF_MODE | VIDEO_MODE_SLAVE_MODE;
+	writel(val, edp->regs + SOC_GENERAL_CTL);*/
+}
+
+void rk32_edp_enable_scrambling(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + TRAINING_PTN_SET);
+	val &= ~SCRAMBLING_DISABLE;
+	writel(val, edp->regs + TRAINING_PTN_SET);
+}
+
+void rk32_edp_disable_scrambling(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = readl(edp->regs + TRAINING_PTN_SET);
+	val |= SCRAMBLING_DISABLE;
+	writel(val, edp->regs + TRAINING_PTN_SET);
+}
+
+enum dp_irq_type rk32_edp_get_irq_type(struct rk32_edp *edp)
+{
+	u32 val;
+
+	/* Parse hotplug interrupt status register */
+	val = readl(edp->regs + COMMON_INT_STA_4);
+	if (val & PLUG)
+		return DP_IRQ_TYPE_HP_CABLE_IN;
+
+	if (val & HPD_LOST)
+		return DP_IRQ_TYPE_HP_CABLE_OUT;
+
+	if (val & HOTPLUG_CHG)
+		return DP_IRQ_TYPE_HP_CHANGE;
+
+	return DP_IRQ_TYPE_UNKNOWN;
+}
+
+void rk32_edp_clear_hotplug_interrupts(struct rk32_edp *edp)
+{
+	u32 val;
+
+	val = HOTPLUG_CHG | HPD_LOST | PLUG;
+	writel(val, edp->regs + COMMON_INT_STA_4);
+
+	val = INT_HPD;
+	writel(val, edp->regs + DP_INT_STA);
+}
diff -Nupr a/drivers/video/rockchip/transmitter/rk32_lvds.c b/drivers/video/rockchip/transmitter/rk32_lvds.c
--- a/drivers/video/rockchip/transmitter/rk32_lvds.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk32_lvds.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,233 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/rk_fb.h>
+#include <linux/rockchip/iomap.h>
+#include <linux/rockchip/grf.h>
+#include "rk32_lvds.h"
+
+
+#define grf_readl(offset)	readl_relaxed(RK_GRF_VIRT + offset)
+#define grf_writel(v,offset) 	do{ writel_relaxed(v, RK_GRF_VIRT + offset);dsb();} while (0)
+
+static struct rk32_lvds *rk32_lvds;
+
+static int rk32_lvds_clk_enable(struct rk32_lvds *lvds)
+{
+	if (!lvds->clk_on) {
+		clk_prepare_enable(lvds->pd);
+		clk_prepare_enable(lvds->pclk);
+		lvds->clk_on = true;
+	}
+
+	return 0;
+}
+
+static int rk32_lvds_clk_disable(struct rk32_lvds *lvds)
+{
+	if (lvds->clk_on) {
+		clk_disable_unprepare(lvds->pclk);
+		clk_disable_unprepare(lvds->pd);
+		lvds->clk_on = false;
+	}
+
+	return 0;
+}
+
+static int rk32_lvds_disable(void)
+{
+	struct rk32_lvds *lvds = rk32_lvds;
+	grf_writel(0xffff8000, RK3288_GRF_SOC_CON7);
+	writel_relaxed(0x00, lvds->regs + LVDS_CFG_REG_21); /*disable tx*/
+	writel_relaxed(0xff, lvds->regs + LVDS_CFG_REG_c); /*disable pll*/
+	rk32_lvds_clk_disable(lvds);
+	return 0;
+}
+
+static int rk32_lvds_en(void)
+{
+	struct rk32_lvds *lvds = rk32_lvds;
+	struct rk_screen *screen = &lvds->screen;
+	u32 h_bp = 0;
+	u32 val = 0;
+
+	rk_fb_get_prmry_screen(screen);
+
+	/* enable clk */
+	rk32_lvds_clk_enable(lvds);
+
+	/* select lcdc source */
+	if (screen->lcdc_id == 1) /*lcdc1 = vop little,lcdc0 = vop big*/
+		val = LVDS_SEL_VOP_LIT | (LVDS_SEL_VOP_LIT << 16);
+	else
+		val = LVDS_SEL_VOP_LIT << 16;
+	grf_writel(val, RK3288_GRF_SOC_CON6);
+
+	/* set lvds format */
+	val = screen->lvds_format;
+	if ((screen->type == SCREEN_DUAL_LVDS) ||
+	    (screen->type == SCREEN_DUAL_LVDS_10BIT))
+		val |= LVDS_DUAL | LVDS_CH0_EN | LVDS_CH1_EN;
+	else if((screen->type == SCREEN_LVDS) ||
+	        (screen->type == SCREEN_LVDS_10BIT))
+		val |= LVDS_CH0_EN;
+	else if (screen->type == SCREEN_RGB)
+		val = LVDS_TTL_EN | LVDS_CH0_EN | LVDS_CH1_EN;
+
+	h_bp = screen->mode.hsync_len + screen->mode.left_margin;
+	if (h_bp & 0x01)
+		val |= LVDS_START_PHASE_RST_1;
+
+	val |= (screen->pin_dclk << 8) | (screen->pin_hsync << 9) |
+		(screen->pin_den << 10);
+	val |= (0xffff << 16);
+	grf_writel(val, RK3288_GRF_SOC_CON7);
+
+	if (screen->type == SCREEN_RGB) {
+		val = 0x007f007f;//0x1<<6 |0x1 <<4;
+		grf_writel(val, RK3288_GRF_GPIO1D_IOMUX);
+
+		lvds_writel(lvds, LVDS_CH0_REG_0, 0x7f);
+		lvds_writel(lvds, LVDS_CH0_REG_1, 0x40);
+		lvds_writel(lvds, LVDS_CH0_REG_2, 0x00);
+
+		lvds_writel(lvds, LVDS_CH0_REG_4, 0x3f);
+		lvds_writel(lvds, LVDS_CH0_REG_5, 0x3f);
+		lvds_writel(lvds, LVDS_CH0_REG_3, 0x46);
+		lvds_writel(lvds, LVDS_CH0_REG_d, 0x0a);
+		lvds_writel(lvds, LVDS_CH0_REG_20,0x44);/* 44:LSB  45:MSB*/
+		writel_relaxed(0x00, lvds->regs + LVDS_CFG_REG_c); /*eanble pll*/
+		writel_relaxed(0x92, lvds->regs + LVDS_CFG_REG_21); /*enable tx*/
+
+		lvds_writel(lvds, 0x100, 0x7f);
+		lvds_writel(lvds, 0x104, 0x40);
+		lvds_writel(lvds, 0x108, 0x00);
+		lvds_writel(lvds, 0x10c, 0x46);
+		lvds_writel(lvds, 0x110, 0x3f);
+		lvds_writel(lvds, 0x114, 0x3f);
+		lvds_writel(lvds, 0x134, 0x0a);
+	} else {
+		lvds_writel(lvds, LVDS_CH0_REG_0, 0xbf);
+		lvds_writel(lvds, LVDS_CH0_REG_1, 0x3f);
+		lvds_writel(lvds, LVDS_CH0_REG_2, 0xfe);
+		lvds_writel(lvds, LVDS_CH0_REG_3, 0x46);
+		lvds_writel(lvds, LVDS_CH0_REG_4, 0x00);
+		lvds_writel(lvds, LVDS_CH0_REG_d, 0x0a);
+		lvds_writel(lvds, LVDS_CH0_REG_20,0x44);/* 44:LSB  45:MSB*/
+		writel_relaxed(0x00, lvds->regs + LVDS_CFG_REG_c); /*eanble pll*/
+		writel_relaxed(0x92, lvds->regs + LVDS_CFG_REG_21); /*enable tx*/
+	}
+
+	return 0;
+}
+
+
+static struct rk_fb_trsm_ops trsm_lvds_ops = {
+	.enable = rk32_lvds_en,
+	.disable = rk32_lvds_disable,
+};
+
+static int rk32_lvds_probe(struct platform_device *pdev)
+{
+	struct rk32_lvds *lvds;
+	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing device tree node.\n");
+		return -EINVAL;
+	}
+
+	lvds = devm_kzalloc(&pdev->dev, sizeof(struct rk32_lvds), GFP_KERNEL);
+	if (!lvds) {
+		dev_err(&pdev->dev, "no memory for state\n");
+		return -ENOMEM;
+	}
+	lvds->dev = &pdev->dev;
+	rk_fb_get_prmry_screen(&lvds->screen);
+	if ((lvds->screen.type != SCREEN_RGB) && 
+		(lvds->screen.type != SCREEN_LVDS) &&
+		(lvds->screen.type != SCREEN_DUAL_LVDS) &&
+		(lvds->screen.type != SCREEN_LVDS_10BIT) &&
+		(lvds->screen.type != SCREEN_DUAL_LVDS_10BIT)) {
+		dev_err(&pdev->dev, "screen is not lvds/rgb!\n");		
+		writel_relaxed(0xffff8000, RK_GRF_VIRT + RK3288_GRF_SOC_CON7);
+		return -EINVAL;
+	}
+	platform_set_drvdata(pdev, lvds);
+	dev_set_name(lvds->dev, "rk32-lvds");
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	lvds->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(lvds->regs)) {
+		dev_err(&pdev->dev, "ioremap reg failed\n");
+		return PTR_ERR(lvds->regs);
+	}
+	lvds->pclk = devm_clk_get(&pdev->dev,"pclk_lvds");
+	if (IS_ERR(lvds->pclk)) {
+		dev_err(&pdev->dev, "get clk failed\n");
+		return PTR_ERR(lvds->pclk);
+	}
+	lvds->pd = devm_clk_get(&pdev->dev,"pd_lvds");
+	if (IS_ERR(lvds->pd)) {
+		dev_err(&pdev->dev, "get clk failed\n");
+		return PTR_ERR(lvds->pd);
+	}	
+	if (support_uboot_display()) {
+		rk32_lvds_clk_enable(lvds);
+	}
+
+	rk32_lvds = lvds;
+	rk_fb_trsm_ops_register(&trsm_lvds_ops,SCREEN_LVDS);
+	dev_info(&pdev->dev, "rk32 lvds driver probe success\n");
+
+	return 0;
+}
+
+static void rk32_lvds_shutdown(struct platform_device *pdev)
+{
+
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk32_lvds_dt_ids[] = {
+	{.compatible = "rockchip,rk32-lvds",},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, rk32_lvds_dt_ids);
+#endif
+
+static struct platform_driver rk32_lvds_driver = {
+	.probe = rk32_lvds_probe,
+	.driver = {
+		   .name = "rk32-lvds",
+		   .owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+		   .of_match_table = of_match_ptr(rk32_lvds_dt_ids),
+#endif
+	},
+	.shutdown = rk32_lvds_shutdown,
+};
+
+static int __init rk32_lvds_module_init(void)
+{
+	return platform_driver_register(&rk32_lvds_driver);
+}
+
+static void __exit rk32_lvds_module_exit(void)
+{
+
+}
+
+fs_initcall(rk32_lvds_module_init);
+module_exit(rk32_lvds_module_exit);
+
diff -Nupr a/drivers/video/rockchip/transmitter/rk32_lvds.h b/drivers/video/rockchip/transmitter/rk32_lvds.h
--- a/drivers/video/rockchip/transmitter/rk32_lvds.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk32_lvds.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RK32_LVDS__
+#define __RK32_LVDS__
+
+#define LVDS_CH0_REG_0			0x00
+#define LVDS_CH0_REG_1			0x04
+#define LVDS_CH0_REG_2			0x08
+#define LVDS_CH0_REG_3			0x0c
+#define LVDS_CH0_REG_4			0x10
+#define LVDS_CH0_REG_5			0x14
+#define LVDS_CH0_REG_9			0x24
+#define LVDS_CFG_REG_c			0x30
+#define LVDS_CH0_REG_d			0x34
+#define LVDS_CH0_REG_f			0x3c
+#define LVDS_CH0_REG_20			0x80
+#define LVDS_CFG_REG_21			0x84
+
+#define LVDS_SEL_VOP_LIT		(1 << 3)
+
+#define LVDS_FMT_MASK			(0x07 << 16)
+#define LVDS_MSB			(0x01 << 3)
+#define LVDS_DUAL			(0x01 << 4)
+#define LVDS_FMT_1			(0x01 << 5)
+#define LVDS_TTL_EN			(0x01 << 6)
+#define LVDS_START_PHASE_RST_1		(0x01 << 7)
+#define LVDS_DCLK_INV			(0x01 << 8)
+#define LVDS_CH0_EN			(0x01 << 11)
+#define LVDS_CH1_EN			(0x01 << 12)
+#define LVDS_PWRDN			(0x01 << 15)
+
+struct rk32_lvds {
+	struct device 		*dev;
+	void __iomem  		*regs;
+	struct clk    		*pclk; /*phb clk*/
+	struct clk              *pd;
+	struct rk_screen	screen;
+	bool			clk_on;
+};
+
+static int inline lvds_writel(struct rk32_lvds *lvds, u32 offset, u32 val)
+{
+	writel_relaxed(val, lvds->regs + offset);
+	//if (lvds->screen.type == SCREEN_DUAL_LVDS)
+		writel_relaxed(val, lvds->regs + offset + 0x100);
+	return 0;
+}
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2127 @@
+/*
+ * Copyright (C) 2014 ROCKCHIP, Inc.
+ * drivers/video/display/transmitter/rk32_mipi_dsi.c
+ * author: libing@rock-chips.com
+ * create date: 2014-04-10
+ * debug /sys/kernel/debug/mipidsi*
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* config */
+#ifndef CONFIG_RK32_MIPI_DSI
+#include <common.h>
+#endif
+
+#ifdef CONFIG_RK32_MIPI_DSI
+#define MIPI_DSI_REGISTER_IO	0
+#define CONFIG_MIPI_DSI_LINUX	0
+#endif
+#define DSI_RK3288		0x3288
+#define DSI_RK312x		0x3128
+#define DSI_RK3368		0x3368
+#define DSI_RK3366		0x3366
+#define DSI_RK3399		0x3399
+#define DSI_ERR			-1
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/rk_fb.h>
+#include <linux/rk_screen.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <asm/div64.h>
+
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/regulator/machine.h>
+
+#include <linux/dma-mapping.h>
+#include "mipi_dsi.h"
+#include "rk32_mipi_dsi.h"
+#include<linux/mfd/syscon.h>
+#include<linux/regmap.h>
+
+#define	MIPI_DBG(x...)	/* printk(KERN_INFO x) */
+
+#ifdef CONFIG_MIPI_DSI_LINUX
+#define	MIPI_TRACE(x...)	/* printk(KERN_INFO x) */
+#else
+#define	MIPI_TRACE(...)    \
+	do {\
+		printf(__VA_ARGS__);\
+		printf("\n");\
+	} while (0);
+
+#endif
+
+/*
+*			 Driver Version Note
+*
+*v1.0 : this driver is rk32 mipi dsi driver of rockchip;
+*v1.1 : add test eye pattern;
+*
+*/
+
+#define RK_MIPI_DSI_VERSION_AND_TIME  "rockchip mipi_dsi v1.1 2014-06-17"
+
+static struct dsi *dsi0;
+static struct dsi *dsi1;
+
+static int rk32_mipi_dsi_is_active(void *arg);
+static int rk32_mipi_dsi_enable_hs_clk(void *arg, u32 enable);
+static int rk32_mipi_dsi_enable_video_mode(void *arg, u32 enable);
+static int rk32_mipi_dsi_enable_command_mode(void *arg, u32 enable);
+static int rk32_mipi_dsi_is_enable(void *arg, u32 enable);
+static int rk32_mipi_power_down_DDR(void);
+static int rk32_mipi_power_up_DDR(void);
+int rk_mipi_screen_standby(u8 enable);
+
+int rockchip_get_screen_type(void)
+{
+	struct device_node *type_node;
+	struct device_node *childnode;
+	u32 val = 0;
+
+	type_node = of_find_node_by_name(NULL, "display-timings");
+	if (!type_node) {
+		pr_err("could not find display-timings node\n");
+		return -1;
+	}
+
+	for_each_child_of_node(type_node, childnode) {
+		if (!of_property_read_u32(childnode, "screen-type", &val))
+			return val;
+	}
+
+	return 0;
+}
+
+static int rk32_dsi_read_reg(struct dsi *dsi, u16 reg, u32 *pval)
+{
+	if (dsi->ops.id == DSI_RK3288 ||
+	    dsi->ops.id == DSI_RK3399)
+		*pval = __raw_readl(dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
+	else if (dsi->ops.id == DSI_RK312x ||
+		 dsi->ops.id == DSI_RK3368 ||
+		 dsi->ops.id == DSI_RK3366) {
+		if (reg >= MIPI_DSI_HOST_OFFSET)
+			*pval = __raw_readl(dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
+		else if (reg >= MIPI_DSI_PHY_OFFSET)
+			*pval = __raw_readl(dsi->phy.membase + (reg - MIPI_DSI_PHY_OFFSET));
+	}
+	return 0;
+}
+
+static int rk32_dsi_write_reg(struct dsi *dsi, u16 reg, u32 *pval)
+{
+	if (dsi->ops.id == DSI_RK3288 ||
+	    dsi->ops.id == DSI_RK3399)
+		__raw_writel(*pval, dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
+	else if (dsi->ops.id == DSI_RK312x ||
+		 dsi->ops.id == DSI_RK3368 ||
+		 dsi->ops.id == DSI_RK3366) {
+		if (reg >= MIPI_DSI_HOST_OFFSET)
+			__raw_writel(*pval, dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
+		else if (reg >= MIPI_DSI_PHY_OFFSET)
+			__raw_writel(*pval, dsi->phy.membase + (reg - MIPI_DSI_PHY_OFFSET));
+	}
+	return 0;
+}
+
+static int rk32_dsi_get_bits(struct dsi *dsi, u32 reg)
+{
+	u32 val = 0;
+	u32 bits = (reg >> 8) & 0xff;
+	u16 reg_addr = (reg >> 16) & 0xffff;
+	u8 offset = reg & 0xff;
+
+	if (bits < 32)
+		bits = (1 << bits) - 1;
+	else
+		bits = 0xffffffff;
+
+	rk32_dsi_read_reg(dsi, reg_addr, &val);
+	val >>= offset;
+	val &= bits;
+	return val;
+}
+
+static int rk32_dsi_set_bits(struct dsi *dsi, u32 data, u32 reg)
+{
+	static u32 val;
+	u32 bits = (reg >> 8) & 0xff;
+	u16 reg_addr = (reg >> 16) & 0xffff;
+	u8 offset = reg & 0xff;
+
+	if (bits < 32)
+		bits = (1 << bits) - 1;
+	else
+		bits = 0xffffffff;
+
+	if (bits != 0xffffffff)
+		rk32_dsi_read_reg(dsi, reg_addr, &val);
+
+	val &= ~(bits << offset);
+	val |= (data & bits) << offset;
+	rk32_dsi_write_reg(dsi, reg_addr, &val);
+
+	if (data > bits) {
+		MIPI_TRACE("%s error reg_addr:0x%04x, offset:%d, bits:0x%04x, value:0x%04x\n",
+				__func__, reg_addr, offset, bits, data);
+	}
+	return 0;
+}
+#if 0
+static int rk32_dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
+{
+	int val = 0;
+	rk32_dsi_set_bits(dsi, 1, phy_testclk);
+	rk32_dsi_set_bits(dsi, test_code, phy_testdin);
+	rk32_dsi_set_bits(dsi, 1, phy_testen);
+	rk32_dsi_set_bits(dsi, 0, phy_testclk);
+	rk32_dsi_set_bits(dsi, 0, phy_testen);;
+
+	rk32_dsi_set_bits(dsi, 0, phy_testen);
+	val = rk32_dsi_get_bits(dsi, phy_testdout);
+	rk32_dsi_set_bits(dsi, 1, phy_testclk);
+	rk32_dsi_set_bits(dsi, 0, phy_testclk);
+
+	return val;
+}
+#endif
+static int rk32_dwc_phy_test_wr(struct dsi *dsi, unsigned char test_code, unsigned char *test_data, unsigned char size)
+{
+	int i = 0;
+
+	MIPI_DBG("test_code=0x%x,test_data=0x%x\n", test_code, test_data[0]);
+	rk32_dsi_set_bits(dsi, 0x10000 | test_code, PHY_TEST_CTRL1);
+	rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
+	rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
+
+	for (i = 0; i < size; i++) {
+		rk32_dsi_set_bits(dsi, test_data[i], PHY_TEST_CTRL1);
+		rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
+		rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
+		MIPI_DBG("rk32_dwc_phy_test_wr:%08x\n", rk32_dsi_get_bits(dsi, PHY_TEST_CTRL1));
+	}
+	return 0;
+}
+
+static int rk32_phy_power_up(struct dsi *dsi)
+{
+	/* enable ref clock */
+	clk_prepare_enable(dsi->phy.refclk);
+	clk_prepare_enable(dsi->dsi_pclk);
+	if (dsi->ops.id == DSI_RK3399)
+		clk_prepare_enable(dsi->dsi_host_pclk);
+	udelay(10);
+
+	switch (dsi->host.lane) {
+	case 4:
+		rk32_dsi_set_bits(dsi, 3, n_lanes);
+		break;
+	case 3:
+		rk32_dsi_set_bits(dsi, 2, n_lanes);
+		break;
+	case 2:
+		rk32_dsi_set_bits(dsi, 1, n_lanes);
+		break;
+	case 1:
+		rk32_dsi_set_bits(dsi, 0, n_lanes);
+		break;
+	default:
+		break;
+	}
+	rk32_dsi_set_bits(dsi, 1, phy_shutdownz);
+	rk32_dsi_set_bits(dsi, 1, phy_rstz);
+	rk32_dsi_set_bits(dsi, 1, phy_enableclk);
+	rk32_dsi_set_bits(dsi, 1, phy_forcepll);
+
+	return 0;
+}
+
+static int rk312x_mipi_dsi_phy_set_gotp(struct dsi *dsi, u32 offset, int n)
+{
+	u32 val = 0, temp = 0, Tlpx = 0;
+	u32 ddr_clk = dsi->phy.ddr_clk;
+	u32 Ttxbyte_clk = dsi->phy.Ttxbyte_clk;
+	u32 Tsys_clk = dsi->phy.Tsys_clk;
+	u32 Ttxclkesc = dsi->phy.Ttxclkesc;
+	printk("%s : ddr_clk %d\n", __func__, ddr_clk);
+	switch (offset) {
+	case DPHY_CLOCK_OFFSET:
+		MIPI_DBG("******set DPHY_CLOCK_OFFSET gotp******\n");
+		break;
+	case DPHY_LANE0_OFFSET:
+		MIPI_DBG("******set DPHY_LANE0_OFFSET gotp******\n");
+		break;
+	case DPHY_LANE1_OFFSET:
+		MIPI_DBG("******set DPHY_LANE1_OFFSET gotp******\n");
+		break;
+	case DPHY_LANE2_OFFSET:
+		MIPI_DBG("******set DPHY_LANE2_OFFSET gotp******\n");
+		break;
+	case DPHY_LANE3_OFFSET:
+		MIPI_DBG("******set DPHY_LANE3_OFFSET gotp******\n");
+		break;
+	default:
+		break;
+	}
+
+	if (ddr_clk < 110 * MHz)
+		val = 0;
+	else if (ddr_clk < 150 * MHz)
+		val = 1;
+	else if (ddr_clk < 200 * MHz)
+		val = 2;
+	else if (ddr_clk < 250 * MHz)
+		val = 3;
+	else if (ddr_clk < 300 * MHz)
+		val = 4;
+	else if (ddr_clk < 400 * MHz)
+		val = 5;
+	else if (ddr_clk < 500 * MHz)
+		val = 6;
+	else if (ddr_clk < 600 * MHz)
+		val = 7;
+	else if (ddr_clk < 700 * MHz)
+		val = 8;
+	else if (ddr_clk < 800 * MHz)
+		val = 9;
+	else if (ddr_clk <= 1000 * MHz)
+		val = 10;
+	printk("%s reg_ths_settle = 0x%x\n", __func__, val);
+	rk32_dsi_set_bits(dsi, val, reg_ths_settle + offset);
+
+	if (ddr_clk < 110 * MHz)
+		val = 0x20;
+	else if (ddr_clk < 150 * MHz)
+		val = 0x06;
+	else if (ddr_clk < 200 * MHz)
+		val = 0x18;
+	else if (ddr_clk < 250 * MHz)
+		val = 0x05;
+	else if (ddr_clk < 300 * MHz)
+		val = 0x51;
+	else if (ddr_clk < 400 * MHz)
+		val = 0x64;
+	else if (ddr_clk < 500 * MHz)
+		val = 0x59;
+	else if (ddr_clk < 600 * MHz)
+		val = 0x6a;
+	else if (ddr_clk < 700 * MHz)
+		val = 0x3e;
+	else if (ddr_clk < 800 * MHz)
+		val = 0x21;
+	else if (ddr_clk <= 1000 * MHz)
+		val = 0x09;
+	printk("%s reg_hs_ths_prepare = 0x%x\n", __func__, val);
+	rk32_dsi_set_bits(dsi, val, reg_hs_ths_prepare + offset);
+
+	if (offset != DPHY_CLOCK_OFFSET) {
+		if (ddr_clk < 110 * MHz)
+			val = 2;
+		else if (ddr_clk < 150 * MHz)
+			val = 3;
+		else if (ddr_clk < 200 * MHz)
+			val = 4;
+		else if (ddr_clk < 250 * MHz)
+			val = 5;
+		else if (ddr_clk < 300 * MHz)
+			val = 6;
+		else if (ddr_clk < 400 * MHz)
+			val = 7;
+		else if (ddr_clk < 500 * MHz)
+			val = 7;
+		else if (ddr_clk < 600 * MHz)
+			val = 8;
+		else if (ddr_clk < 700 * MHz)
+			val = 8;
+		else if (ddr_clk < 800 * MHz)
+			val = 9;
+		else if (ddr_clk <= 1000 * MHz)
+			val = 9;
+	} else {
+		if (ddr_clk < 110 * MHz)
+			val = 0x16;
+		else if (ddr_clk < 150 * MHz)
+			val = 0x16;
+		else if (ddr_clk < 200 * MHz)
+			val = 0x17;
+		else if (ddr_clk < 250 * MHz)
+			val = 0x17;
+		else if (ddr_clk < 300 * MHz)
+			val = 0x18;
+		else if (ddr_clk < 400 * MHz)
+			val = 0x19;
+		else if (ddr_clk < 500 * MHz)
+			val = 0x1b;
+		else if (ddr_clk < 600 * MHz)
+			val = 0x1d;
+		else if (ddr_clk < 700 * MHz)
+			val = 0x1e;
+		else if (ddr_clk < 800 * MHz)
+			val = 0x1f;
+		else if (ddr_clk <= 1000 * MHz)
+			val = 0x20;
+	}
+	printk("%s reg_hs_the_zero = 0x%x\n", __func__, val);
+	rk32_dsi_set_bits(dsi, val, reg_hs_the_zero + offset);
+
+	if (ddr_clk < 110 * MHz)
+		val = 0x22;
+	else if (ddr_clk < 150 * MHz)
+		val = 0x45;
+	else if (ddr_clk < 200 * MHz)
+		val = 0x0b;
+	else if (ddr_clk < 250 * MHz)
+		val = 0x16;
+	else if (ddr_clk < 300 * MHz)
+		val = 0x2c;
+	else if (ddr_clk < 400 * MHz)
+		val = 0x33;
+	else if (ddr_clk < 500 * MHz)
+		val = 0x4e;
+	else if (ddr_clk < 600 * MHz)
+		val = 0x3a;
+	else if (ddr_clk < 700 * MHz)
+		val = 0x6a;
+	else if (ddr_clk < 800 * MHz)
+		val = 0x29;
+	else if (ddr_clk <= 1000 * MHz)
+		val = 0x21;	/* 0x27 */
+
+	printk("%s reg_hs_ths_trail = 0x%x\n", __func__, val);
+
+	rk32_dsi_set_bits(dsi, val, reg_hs_ths_trail + offset);
+	val = 120000 / Ttxbyte_clk + 1;
+	MIPI_DBG("reg_hs_ths_exit: %d, %d\n", val, val*Ttxbyte_clk/1000);
+	rk32_dsi_set_bits(dsi, val, reg_hs_ths_exit + offset);
+
+	if (offset == DPHY_CLOCK_OFFSET) {
+		val = (60000 + 52*dsi->phy.UI) / Ttxbyte_clk + 1;
+		MIPI_DBG("reg_hs_tclk_post: %d, %d\n", val, val*Ttxbyte_clk/1000);
+		rk32_dsi_set_bits(dsi, val, reg_hs_tclk_post + offset);
+		val = 10*dsi->phy.UI / Ttxbyte_clk + 1;
+		MIPI_DBG("reg_hs_tclk_pre: %d, %d\n", val, val*Ttxbyte_clk/1000);
+		rk32_dsi_set_bits(dsi, val, reg_hs_tclk_pre + offset);
+	}
+
+	val = 1010000000 / Tsys_clk + 1;
+	MIPI_DBG("reg_hs_twakup: %d, %d\n", val, val*Tsys_clk/1000);
+	if (val > 0x3ff) {
+		val = 0x2ff;
+		MIPI_DBG("val is too large, 0x3ff is the largest\n");
+	}
+	temp = (val >> 8) & 0x03;
+	val &= 0xff;
+	rk32_dsi_set_bits(dsi, temp, reg_hs_twakup_h + offset);
+	rk32_dsi_set_bits(dsi, val, reg_hs_twakup_l + offset);
+
+	if (Ttxclkesc > 50000) {
+		val = 2*Ttxclkesc;
+		MIPI_DBG("Ttxclkesc:%d\n", Ttxclkesc);
+	}
+	val = val / Ttxbyte_clk;
+	Tlpx = val*Ttxbyte_clk;
+	MIPI_DBG("reg_hs_tlpx: %d, %d\n", val, Tlpx);
+	val -= 2;
+	rk32_dsi_set_bits(dsi, val, reg_hs_tlpx + offset);
+
+	Tlpx = 2*Ttxclkesc;
+	val = 4*Tlpx / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_go: %d, %d\n", val, val*Ttxclkesc);
+	rk32_dsi_set_bits(dsi, val, reg_hs_tta_go + offset);
+	val = 3 * Tlpx / 2 / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_sure: %d, %d\n", val, val*Ttxclkesc);
+	rk32_dsi_set_bits(dsi, val, reg_hs_tta_sure + offset);
+	val = 5 * Tlpx / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_wait: %d, %d\n", val, val*Ttxclkesc);
+	rk32_dsi_set_bits(dsi, val, reg_hs_tta_wait + offset);
+	return 0;
+}
+
+static void rk312x_mipi_dsi_set_hs_clk(struct dsi *dsi)
+{
+	rk32_dsi_set_bits(dsi, dsi->phy.prediv, reg_prediv);
+	rk32_dsi_set_bits(dsi, dsi->phy.fbdiv & 0xff, reg_fbdiv);
+	rk32_dsi_set_bits(dsi, (dsi->phy.fbdiv >> 8) & 0x01, reg_fbdiv_8);
+}
+
+static int rk312x_phy_power_up(struct dsi *dsi)
+{
+	/* enable ref clock */
+	clk_prepare_enable(dsi->phy.refclk);
+	clk_prepare_enable(dsi->dsi_pclk);
+	clk_prepare_enable(dsi->dsi_host_pclk);
+	if (dsi->ops.id == DSI_RK312x)
+		clk_prepare_enable(dsi->h2p_hclk);
+
+	udelay(10);
+
+	rk312x_mipi_dsi_set_hs_clk(dsi);
+	rk32_dsi_set_bits(dsi, 0xe4, DPHY_REGISTER1);
+	switch (dsi->host.lane) {
+	case 4:
+		rk32_dsi_set_bits(dsi, 1, lane_en_3);
+	case 3:
+		rk32_dsi_set_bits(dsi, 1, lane_en_2);
+	case 2:
+		rk32_dsi_set_bits(dsi, 1, lane_en_1);
+	case 1:
+		rk32_dsi_set_bits(dsi, 1, lane_en_0);
+		rk32_dsi_set_bits(dsi, 1, lane_en_ck);
+		break;
+	default:
+		break;
+	}
+
+	rk32_dsi_set_bits(dsi, 0xe0, DPHY_REGISTER1);
+	udelay(10);
+
+	rk32_dsi_set_bits(dsi, 0x1e, DPHY_REGISTER20);
+	rk32_dsi_set_bits(dsi, 0x1f, DPHY_REGISTER20);
+
+	rk32_dsi_set_bits(dsi, 1, phy_enableclk);
+
+	return 0;
+}
+
+static int rk_phy_power_up(struct dsi *dsi)
+{
+	if (dsi->ops.id == DSI_RK3288 ||
+	    dsi->ops.id == DSI_RK3399)
+		rk32_phy_power_up(dsi);
+	else if (dsi->ops.id == DSI_RK312x ||
+		 dsi->ops.id == DSI_RK3368 ||
+		 dsi->ops.id == DSI_RK3366)
+		rk312x_phy_power_up(dsi);
+	return 0;
+}
+
+static int rk32_phy_power_down(struct dsi *dsi)
+{
+	rk32_dsi_set_bits(dsi, 0, phy_shutdownz);
+	clk_disable_unprepare(dsi->phy.refclk);
+	clk_disable_unprepare(dsi->dsi_pclk);
+	if (dsi->ops.id == DSI_RK3399)
+		clk_disable_unprepare(dsi->dsi_host_pclk);
+	return 0;
+}
+
+static int rk312x_phy_power_down(struct dsi *dsi)
+{
+	rk32_dsi_set_bits(dsi, 0x01, DPHY_REGISTER0);
+	rk32_dsi_set_bits(dsi, 0xe3, DPHY_REGISTER1);
+
+	clk_disable_unprepare(dsi->phy.refclk);
+	clk_disable_unprepare(dsi->dsi_pclk);
+	clk_disable_unprepare(dsi->dsi_host_pclk);
+
+	if (dsi->ops.id == DSI_RK312x)
+		clk_disable_unprepare(dsi->h2p_hclk);
+
+	return 0;
+}
+
+static int rk_phy_power_down(struct dsi *dsi)
+{
+	if (dsi->ops.id == DSI_RK3288 ||
+	    dsi->ops.id == DSI_RK3399)
+		rk32_phy_power_down(dsi);
+	else if (dsi->ops.id == DSI_RK312x ||
+		 dsi->ops.id == DSI_RK3368 ||
+		 dsi->ops.id == DSI_RK3366)
+		rk312x_phy_power_down(dsi);
+	return 0;
+}
+
+static int rk32_phy_init(struct dsi *dsi)
+{
+	u32 val = 0 , ddr_clk = 0, fbdiv = 0, prediv = 0;
+	unsigned char test_data[2] = {0};
+
+	ddr_clk	= dsi->phy.ddr_clk;
+	prediv	= dsi->phy.prediv;
+	fbdiv	= dsi->phy.fbdiv;
+
+	if (ddr_clk < 200 * MHz)
+		val = 0x0;
+	else if (ddr_clk < 300 * MHz)
+		val = 0x1;
+	else if (ddr_clk < 500 * MHz)
+		val = 0x2;
+	else if (ddr_clk < 700 * MHz)
+		val = 0x3;
+	else if (ddr_clk < 900 * MHz)
+		val = 0x4;
+	else if (ddr_clk < 1100 * MHz)
+		val = 0x5;
+	else if (ddr_clk < 1300 * MHz)
+		val = 0x6;
+	else if (ddr_clk <= 1500 * MHz)
+		val = 0x7;
+
+	test_data[0] = 0x80 | val << 3 | 0x3;
+	rk32_dwc_phy_test_wr(dsi, 0x10, test_data, 1);
+
+	test_data[0] = 0x8;
+	rk32_dwc_phy_test_wr(dsi, 0x11, test_data, 1);
+
+	test_data[0] = 0x80 | 0x40;
+	rk32_dwc_phy_test_wr(dsi, 0x12, test_data, 1);
+
+	if (ddr_clk < 90 * MHz)
+		val = 0x01;
+	else if (ddr_clk < 100 * MHz)
+		val = 0x10;
+	else if (ddr_clk < 110 * MHz)
+		val = 0x20;
+	else if (ddr_clk < 130 * MHz)
+		val = 0x01;
+	else if (ddr_clk < 140 * MHz)
+		val = 0x11;
+	else if (ddr_clk < 150 * MHz)
+		val = 0x21;
+	else if (ddr_clk < 170 * MHz)
+		val = 0x02;
+	else if (ddr_clk < 180 * MHz)
+		val = 0x12;
+	else if (ddr_clk < 200 * MHz)
+		val = 0x22;
+	else if (ddr_clk < 220 * MHz)
+		val = 0x03;
+	else if (ddr_clk < 240 * MHz)
+		val = 0x13;
+	else if (ddr_clk < 250 * MHz)
+		val = 0x23;
+	else if (ddr_clk < 270 * MHz)
+		val = 0x04;
+	else if (ddr_clk < 300 * MHz)
+		val = 0x14;
+	else if (ddr_clk < 330 * MHz)
+		val = 0x05;
+	else if (ddr_clk < 360 * MHz)
+		val = 0x15;
+	else if (ddr_clk < 400 * MHz)
+		val = 0x25;
+	else if (ddr_clk < 450 * MHz)
+		val = 0x06;
+	else if (ddr_clk < 500 * MHz)
+		val = 0x16;
+	else if (ddr_clk < 550 * MHz)
+		val = 0x07;
+	else if (ddr_clk < 600 * MHz)
+		val = 0x17;
+	else if (ddr_clk < 650 * MHz)
+		val = 0x08;
+	else if (ddr_clk < 700 * MHz)
+		val = 0x18;
+	else if (ddr_clk < 750 * MHz)
+		val = 0x09;
+	else if (ddr_clk < 800 * MHz)
+		val = 0x19;
+	else if (ddr_clk < 850 * MHz)
+		val = 0x29;
+	else if (ddr_clk < 900 * MHz)
+		val = 0x39;
+	else if (ddr_clk < 950 * MHz)
+		val = 0x0a;
+	else if (ddr_clk < 1000 * MHz)
+		val = 0x1a;
+	else if (ddr_clk < 1050 * MHz)
+		val = 0x2a;
+	else if (ddr_clk < 1100 * MHz)
+		val = 0x3a;
+	else if (ddr_clk < 1150 * MHz)
+		val = 0x0b;
+	else if (ddr_clk < 1200 * MHz)
+		val = 0x1b;
+	else if (ddr_clk < 1250 * MHz)
+		val = 0x2b;
+	else if (ddr_clk < 1300 * MHz)
+		val = 0x3b;
+	else if (ddr_clk < 1350 * MHz)
+		val = 0x0c;
+	else if (ddr_clk < 1400 * MHz)
+		val = 0x1c;
+	else if (ddr_clk < 1450 * MHz)
+		val = 0x2c;
+	else if (ddr_clk <= 1500 * MHz)
+		val = 0x3c;
+
+	test_data[0] = val << 1;
+	rk32_dwc_phy_test_wr(dsi, code_hs_rx_lane0, test_data, 1);
+
+	test_data[0] = prediv - 1;
+	rk32_dwc_phy_test_wr(dsi, code_pll_input_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = (fbdiv - 1) & 0x1f;
+	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = (fbdiv - 1) >> 5 | 0x80;
+	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = 0x30;
+	rk32_dwc_phy_test_wr(dsi, code_pll_input_loop_div_rat, test_data, 1);
+	mdelay(2);
+
+	test_data[0] = 0x4d;
+	rk32_dwc_phy_test_wr(dsi, 0x20, test_data, 1);
+
+	test_data[0] = 0x3d;
+	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1);
+
+	test_data[0] = 0xdf;
+	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1);
+
+	test_data[0] =  0x7;
+	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
+
+	test_data[0] = 0x80 | 0x7;
+	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
+
+	test_data[0] = 0x80 | 15;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanerequsetstatetime, test_data, 1);
+
+	test_data[0] = 0x80 | 85;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanepreparestatetime, test_data, 1);
+
+	test_data[0] = 0x40 | 10;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanehszerostatetime, test_data, 1);
+
+	return 0;
+}
+
+static int rk312x_phy_init(struct dsi *dsi, int n)
+{
+	/* DPHY init */
+	if (dsi->ops.id == DSI_RK3366) {
+		rk32_dsi_set_bits(dsi, 0x00, DSI_DPHY_BITS(0x06 << 2, 32, 0));
+		rk32_dsi_set_bits(dsi, 0x00, DSI_DPHY_BITS(0x07 << 2, 32, 0));
+	} else {
+		rk32_dsi_set_bits(dsi, 0x11, DSI_DPHY_BITS(0x06 << 2, 32, 0));
+		rk32_dsi_set_bits(dsi, 0x11, DSI_DPHY_BITS(0x07 << 2, 32, 0));
+	}
+	rk32_dsi_set_bits(dsi, 0xcc, DSI_DPHY_BITS(0x09<<2, 32, 0));
+#if 0
+	dsi_set_bits(0x4e, DSI_DPHY_BITS(0x08<<2, 32, 0));
+	dsi_set_bits(0x84, DSI_DPHY_BITS(0x0a<<2, 32, 0));
+#endif
+
+	/*reg1[4] 0: enable a function of "pll phase for serial data being captured
+				 inside analog part"
+		  1: disable it
+	we disable it here because reg5[6:4] is not compatible with the HS speed.
+	*/
+
+	if (dsi->phy.ddr_clk >= 800*MHz) {
+		if (dsi->ops.id == DSI_RK3366) {
+			rk32_dsi_set_bits(dsi, 0x00,
+					  DSI_DPHY_BITS(0x05 << 2, 32, 0));
+		} else if (dsi->ops.id == DSI_RK3368) {
+			rk32_dsi_set_bits(dsi, 0x10, DSI_DPHY_BITS(0x05<<2, 32, 0));
+		} else {
+			rk32_dsi_set_bits(dsi, 0x30, DSI_DPHY_BITS(0x05<<2, 32, 0));
+		}
+	} else {
+		rk32_dsi_set_bits(dsi, 1, reg_da_ppfc);
+	}
+
+	switch	(dsi->host.lane) {
+	case 4:
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE3_OFFSET, n);
+	case 3:
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE2_OFFSET, n);
+	case 2:
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE1_OFFSET, n);
+	case 1:
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE0_OFFSET, n);
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_CLOCK_OFFSET, n);
+		break;
+	default:
+		break;
+	}
+/*
+	rk32_dsi_set_bits(dsi, 0x00e4, reg1_phy);
+	rk32_dsi_set_bits(dsi, 0x007d, reg0_phy);
+	udelay(1000);
+	rk32_dsi_set_bits(dsi, 0x00e0, reg1_phy);
+	rk32_dsi_set_bits(dsi, 0x001e, reg20_phy);
+	udelay(1000);
+	rk32_dsi_set_bits(dsi, 0x001f, reg20_phy);
+
+	rk32_dsi_set_bits(dsi, 0x0063, reg10_phy);
+	*/
+	if (dsi->ops.id == DSI_RK3366) {
+		/* increasing the driver strength */
+		rk32_dsi_set_bits(dsi, 0x4f, reg8_phy);
+		rk32_dsi_set_bits(dsi, 0x5f, regb_phy);
+		/* increasing the slew rate */
+		rk32_dsi_set_bits(dsi, 0xc6, rega_phy);
+	} else if (dsi->ops.id == DSI_RK3368) {
+		rk32_dsi_set_bits(dsi, 0x1, reg5_phy);
+		rk32_dsi_set_bits(dsi, 0x9, regb_0_3_phy);
+	} else {
+		rk32_dsi_set_bits(dsi, 0x6, reg5_phy);
+		rk32_dsi_set_bits(dsi, 0x9, regb_0_3_phy);
+	}
+	rk32_dsi_set_bits(dsi, 0x6, reg10_4_6_phy);
+
+	return 0;
+}
+
+static int rk_phy_init(struct dsi *dsi)
+{
+	if (dsi->ops.id == DSI_RK3288 ||
+	    dsi->ops.id == DSI_RK3399)
+		rk32_phy_init(dsi);
+	else if (dsi->ops.id == DSI_RK312x ||
+		 dsi->ops.id == DSI_RK3368 ||
+		 dsi->ops.id == DSI_RK3366)
+		rk312x_phy_init(dsi, 4);
+	return 0;
+}
+
+static int rk32_mipi_dsi_host_power_up(struct dsi *dsi)
+{
+	int ret = 0;
+	u32 val;
+
+	/* disable all interrupt */
+	rk32_dsi_set_bits(dsi, 0x1fffff, INT_MKS0);
+	rk32_dsi_set_bits(dsi, 0x3ffff, INT_MKS1);
+
+	rk32_mipi_dsi_is_enable(dsi, 1);
+
+	val = 10;
+	while (!rk32_dsi_get_bits(dsi, phylock) && val--) {
+		udelay(10);
+	};
+
+	if (val == 0) {
+		ret = -1;
+		MIPI_TRACE("%s:phylock fail.\n", __func__);
+	}
+
+	val = 10;
+	while (!rk32_dsi_get_bits(dsi, phystopstateclklane) && val--) {
+		udelay(10);
+	};
+
+	return ret;
+}
+
+static int rk32_mipi_dsi_host_power_down(struct dsi *dsi)
+{
+	rk32_mipi_dsi_enable_video_mode(dsi, 0);
+	rk32_mipi_dsi_enable_hs_clk(dsi, 0);
+	rk32_mipi_dsi_is_enable(dsi, 0);
+	return 0;
+}
+
+static int rk32_mipi_dsi_host_init(struct dsi *dsi)
+{
+	u32 val = 0, bytes_px = 0;
+	struct mipi_dsi_screen *screen = &dsi->screen;
+	u32 decimals = dsi->phy.Ttxbyte_clk, temp = 0, i = 0;
+	u32 m = 1, lane = dsi->host.lane, Tpclk = dsi->phy.Tpclk,
+			Ttxbyte_clk = dsi->phy.Ttxbyte_clk;
+
+	rk32_dsi_set_bits(dsi, dsi->host.lane - 1, n_lanes);
+	rk32_dsi_set_bits(dsi, dsi->vid, dpi_vcid);
+
+	switch (screen->face) {
+	case OUT_P888:
+		rk32_dsi_set_bits(dsi, 5, dpi_color_coding);
+		bytes_px = 3;
+		break;
+	case OUT_D888_P666:
+	case OUT_P666:
+		rk32_dsi_set_bits(dsi, 3, dpi_color_coding);
+		rk32_dsi_set_bits(dsi, 1, en18_loosely);
+		bytes_px = 3;
+		break;
+	case OUT_P565:
+		rk32_dsi_set_bits(dsi, 0, dpi_color_coding);
+		bytes_px = 2;
+	default:
+		break;
+	}
+	if (dsi->ops.id == DSI_RK3288 ||
+	    dsi->ops.id == DSI_RK3368 ||
+	    dsi->ops.id == DSI_RK3366 ||
+	    dsi->ops.id == DSI_RK3399) {
+		rk32_dsi_set_bits(dsi, 1, hsync_active_low);
+		rk32_dsi_set_bits(dsi, 1, vsync_active_low);
+
+		rk32_dsi_set_bits(dsi, 0, dataen_active_low);
+		rk32_dsi_set_bits(dsi, 0, colorm_active_low);
+		rk32_dsi_set_bits(dsi, 0, shutd_active_low);
+	} else if (dsi->ops.id == DSI_RK312x) {
+		rk32_dsi_set_bits(dsi, !screen->pin_hsync, hsync_active_low);
+		rk32_dsi_set_bits(dsi, !screen->pin_vsync, vsync_active_low);
+
+		rk32_dsi_set_bits(dsi, screen->pin_den, dataen_active_low);
+		rk32_dsi_set_bits(dsi, 0, colorm_active_low);
+		rk32_dsi_set_bits(dsi, 0, shutd_active_low);
+	}
+
+	rk32_dsi_set_bits(dsi, dsi->host.video_mode, vid_mode_type); /* burst mode */
+
+	switch (dsi->host.video_mode) {
+	case VM_BM:
+		if (screen->type == SCREEN_DUAL_MIPI)
+			rk32_dsi_set_bits(dsi, screen->x_res / 2 + 4, vid_pkt_size);
+		else
+			rk32_dsi_set_bits(dsi, screen->x_res, vid_pkt_size);
+		break;
+	case VM_NBMWSE:
+	case VM_NBMWSP:
+		for (i = 8; i < 32; i++) {
+			temp = i * lane * Tpclk % Ttxbyte_clk;
+			if (decimals > temp) {
+				decimals = temp;
+				m = i;
+			}
+			if (decimals == 0)
+				break;
+		}
+
+		rk32_dsi_set_bits(dsi, screen->x_res / m + 1, num_chunks);
+		rk32_dsi_set_bits(dsi, m, vid_pkt_size);
+		temp = m * lane * Tpclk / Ttxbyte_clk - m * bytes_px;
+		MIPI_DBG("%s:%d, %d\n", __func__, m, temp);
+
+		if (temp >= 12)
+			rk32_dsi_set_bits(dsi, temp - 12, null_pkt_size);
+		break;
+	default:
+		break;
+	}
+
+	/* rk32_dsi_set_bits(dsi, 0, CMD_MODE_CFG << 16); */
+	if (screen->type == SCREEN_MIPI) {
+		rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->x_res + screen->left_margin +
+					screen->hsync_len + screen->right_margin) \
+						/ dsi->phy.Ttxbyte_clk, vid_hline_time);
+	} else { /* used for dual mipi screen */
+		rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->x_res + 8 + screen->left_margin +
+					screen->hsync_len + screen->right_margin) \
+						/ dsi->phy.Ttxbyte_clk, vid_hline_time);
+	}
+	MIPI_DBG("dsi->phy.Tpclk = %d\n", dsi->phy.Tpclk);
+	MIPI_DBG("screen->left_margin = %d\n", screen->left_margin);
+	MIPI_DBG("dsi->phy.Ttxbyte_clk = %d\n", dsi->phy.Ttxbyte_clk);
+	MIPI_DBG("screen->hsync_len = %d\n", screen->hsync_len);
+	rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->left_margin) / dsi->phy.Ttxbyte_clk,
+					vid_hbp_time);
+	rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->hsync_len) / dsi->phy.Ttxbyte_clk,
+					vid_hsa_time);
+
+	rk32_dsi_set_bits(dsi, screen->y_res , vid_active_lines);
+	rk32_dsi_set_bits(dsi, screen->lower_margin, vid_vfp_lines);
+	rk32_dsi_set_bits(dsi, screen->upper_margin, vid_vbp_lines);
+	rk32_dsi_set_bits(dsi, screen->vsync_len, vid_vsa_lines);
+
+	dsi->phy.txclkesc = 20 * MHz;
+	val = dsi->phy.txbyte_clk / dsi->phy.txclkesc + 1;
+	dsi->phy.txclkesc = dsi->phy.txbyte_clk / val;
+	rk32_dsi_set_bits(dsi, val, TX_ESC_CLK_DIVISION);
+
+	rk32_dsi_set_bits(dsi, 10, TO_CLK_DIVISION);
+	rk32_dsi_set_bits(dsi, 1000, hstx_to_cnt); /* no sure */
+	rk32_dsi_set_bits(dsi, 1000, lprx_to_cnt);
+	if (dsi->ops.id == DSI_RK3399)
+		rk32_dsi_set_bits(dsi, 32, phy_stop_wait_time);
+	else
+		rk32_dsi_set_bits(dsi, 100, phy_stop_wait_time);
+
+	/* enable send command in low power mode */
+	rk32_dsi_set_bits(dsi, 4, outvact_lpcmd_time);
+	rk32_dsi_set_bits(dsi, 4, invact_lpcmd_time);
+	rk32_dsi_set_bits(dsi, 1, lp_cmd_en);
+
+	rk32_dsi_set_bits(dsi, 20, phy_hs2lp_time);
+	rk32_dsi_set_bits(dsi, 16, phy_lp2hs_time);
+	/*
+	rk32_dsi_set_bits(dsi, 87, phy_hs2lp_time_clk_lane);
+	rk32_dsi_set_bits(dsi, 25, phy_hs2hs_time_clk_lane);
+	*/
+	rk32_dsi_set_bits(dsi, 10000, max_rd_time);
+
+	rk32_dsi_set_bits(dsi, 1, lp_hfp_en);
+	/* rk32_dsi_set_bits(dsi, 1, lp_hbp_en); */
+	rk32_dsi_set_bits(dsi, 1, lp_vact_en);
+	rk32_dsi_set_bits(dsi, 1, lp_vfp_en);
+	rk32_dsi_set_bits(dsi, 1, lp_vbp_en);
+	rk32_dsi_set_bits(dsi, 1, lp_vsa_en);
+
+	/* rk32_dsi_set_bits(dsi, 1, frame_bta_ack_en); */
+	rk32_dsi_set_bits(dsi, 1, phy_enableclk);
+	rk32_dsi_set_bits(dsi, 0, phy_tx_triggers);
+
+	if (screen->refresh_mode == COMMAND_MODE) {
+		rk32_dsi_set_bits(dsi, screen->x_res, edpi_cmd_size);
+		rk32_dsi_set_bits(dsi, 1, tear_fx_en);
+	}
+
+	/* enable non-continued function */
+	/* rk32_dsi_set_bits(dsi, 1, auto_clklane_ctrl); */
+	/*
+	rk32_dsi_set_bits(dsi, 1, phy_txexitulpslan);
+	rk32_dsi_set_bits(dsi, 1, phy_txexitulpsclk);
+	*/
+	return 0;
+}
+
+/*
+ *	mipi protocol layer definition
+ */
+static int rk_mipi_dsi_init(void *arg, u32 n)
+{
+	u32 decimals = 1000, i = 0, pre = 0;
+	struct dsi *dsi = arg;
+	struct mipi_dsi_screen *screen = &dsi->screen;
+
+	if (!screen)
+		return -1;
+
+	if ((screen->type != SCREEN_MIPI) && (screen->type != SCREEN_DUAL_MIPI)) {
+		MIPI_TRACE("only mipi dsi lcd is supported!\n");
+		return -1;
+	}
+
+	if (((screen->type == SCREEN_DUAL_MIPI) && (rk_mipi_get_dsi_num() == 1)) || ((screen->type == SCREEN_MIPI) && (rk_mipi_get_dsi_num() == 2))) {
+		MIPI_TRACE("dsi number and mipi type not match!\n");
+		return -1;
+	}
+
+	dsi->phy.Tpclk = rk_fb_get_prmry_screen_pixclock();
+
+	if (dsi->phy.refclk)
+		dsi->phy.ref_clk = clk_get_rate(dsi->phy.refclk) ;
+	if (dsi->ops.id == DSI_RK312x ||
+	    dsi->ops.id == DSI_RK3368 ||
+	    dsi->ops.id == DSI_RK3366)
+		dsi->phy.ref_clk = dsi->phy.ref_clk / 2; /* 1/2 of input refclk */
+
+	dsi->phy.sys_clk = dsi->phy.ref_clk;
+
+	printk("dsi->phy.sys_clk =%d\n", dsi->phy.sys_clk);
+	if (dsi->ops.id == DSI_RK3288 ||
+	    dsi->ops.id == DSI_RK3399) {
+		if ((screen->hs_tx_clk <= 90 * MHz) || (screen->hs_tx_clk >= 1500 * MHz))
+			dsi->phy.ddr_clk = 1500 * MHz; /* default is 1.5HGz */
+		else
+			dsi->phy.ddr_clk = screen->hs_tx_clk;
+	} else if (dsi->ops.id == DSI_RK312x ||
+		dsi->ops.id == DSI_RK3368 ||
+		dsi->ops.id == DSI_RK3366) {
+		if ((screen->hs_tx_clk <= 80 * MHz) || (screen->hs_tx_clk >= 1000 * MHz))
+			dsi->phy.ddr_clk = 1000 * MHz; /* default is 1GHz */
+		else
+			dsi->phy.ddr_clk = screen->hs_tx_clk;
+	}
+
+	if (n != 0)
+		dsi->phy.ddr_clk = n;
+
+	decimals = dsi->phy.ref_clk;
+	for (i = 1; i < 6; i++) {
+		pre = dsi->phy.ref_clk / i;
+		if ((decimals > (dsi->phy.ddr_clk % pre)) && (dsi->phy.ddr_clk / pre < 512)) {
+			decimals = dsi->phy.ddr_clk % pre;
+			dsi->phy.prediv = i;
+			dsi->phy.fbdiv = dsi->phy.ddr_clk / pre;
+		}
+		if (decimals == 0)
+			break;
+	}
+
+	MIPI_DBG("prediv:%d, fbdiv:%d,dsi->phy.ddr_clk:%d\n", dsi->phy.prediv, dsi->phy.fbdiv, dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv);
+
+	dsi->phy.ddr_clk = dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv;
+
+	MIPI_DBG("dsi->phy.ddr_clk =%d\n", dsi->phy.ddr_clk);
+	dsi->phy.txbyte_clk = dsi->phy.ddr_clk / 8;
+
+	dsi->phy.txclkesc = 20 * MHz; /* < 20MHz */
+	dsi->phy.txclkesc = dsi->phy.txbyte_clk / (dsi->phy.txbyte_clk / dsi->phy.txclkesc + 1);
+
+	dsi->phy.pclk = div_u64(1000000000000llu, dsi->phy.Tpclk);
+	dsi->phy.Ttxclkesc = div_u64(1000000000000llu, dsi->phy.txclkesc);
+	dsi->phy.Tsys_clk = div_u64(1000000000000llu, dsi->phy.sys_clk);
+	dsi->phy.Tddr_clk = div_u64(1000000000000llu, dsi->phy.ddr_clk);
+	dsi->phy.Ttxbyte_clk = div_u64(1000000000000llu, dsi->phy.txbyte_clk);
+
+	dsi->phy.UI = dsi->phy.Tddr_clk;
+	dsi->vid = 0;
+
+	if (screen->dsi_lane > 0 && screen->dsi_lane <= 4)
+		dsi->host.lane = screen->dsi_lane;
+	else
+		dsi->host.lane = 4;
+
+	dsi->host.video_mode = VM_BM;
+
+	MIPI_DBG("UI:%d\n", dsi->phy.UI);
+	MIPI_DBG("ref_clk:%d\n", dsi->phy.ref_clk);
+	MIPI_DBG("pclk:%d, Tpclk:%d\n", dsi->phy.pclk, dsi->phy.Tpclk);
+	MIPI_DBG("sys_clk:%d, Tsys_clk:%d\n", dsi->phy.sys_clk, dsi->phy.Tsys_clk);
+	MIPI_DBG("ddr_clk:%d, Tddr_clk:%d\n", dsi->phy.ddr_clk, dsi->phy.Tddr_clk);
+	MIPI_DBG("txbyte_clk:%d, Ttxbyte_clk:%d\n", dsi->phy.txbyte_clk,
+				dsi->phy.Ttxbyte_clk);
+	MIPI_DBG("txclkesc:%d, Ttxclkesc:%d\n", dsi->phy.txclkesc, dsi->phy.Ttxclkesc);
+
+	mdelay(10);
+	rk_phy_power_up(dsi);
+	rk32_mipi_dsi_host_power_up(dsi);
+	rk_phy_init(dsi);
+	rk32_mipi_dsi_host_init(dsi);
+
+	return 0;
+}
+
+static int rk32_mipi_dsi_is_enable(void *arg, u32 enable)
+{
+	struct dsi *dsi = arg;
+
+	rk32_dsi_set_bits(dsi, enable, shutdownz);
+	return 0;
+}
+
+static int rk32_mipi_dsi_enable_video_mode(void *arg, u32 enable)
+{
+	struct dsi *dsi = arg;
+
+	rk32_dsi_set_bits(dsi, !enable, cmd_video_mode);
+	return 0;
+}
+
+static int rk32_mipi_dsi_enable_command_mode(void *arg, u32 enable)
+{
+	struct dsi *dsi = arg;
+
+	rk32_dsi_set_bits(dsi, enable, cmd_video_mode);
+	return 0;
+}
+
+static int rk32_mipi_dsi_enable_hs_clk(void *arg, u32 enable)
+{
+	struct dsi *dsi = arg;
+
+	rk32_dsi_set_bits(dsi, enable, phy_txrequestclkhs);
+	return 0;
+}
+
+static int rk32_mipi_dsi_is_active(void *arg)
+{
+	struct dsi *dsi = arg;
+
+	return rk32_dsi_get_bits(dsi, shutdownz);
+}
+
+static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 length)
+{
+	struct dsi *dsi = arg;
+	unsigned char *regs;
+	u32 type, liTmp = 0, i = 0, j = 0, data = 0;
+
+	if (rk32_dsi_get_bits(dsi, gen_cmd_full) == 1) {
+		MIPI_TRACE("gen_cmd_full\n");
+		return -1;
+	}
+	regs = kmalloc(0x400, GFP_KERNEL);
+	if (!regs) {
+		printk("request regs fail!\n");
+		return -ENOMEM;
+	}
+	memcpy(regs, cmds, length);
+
+	liTmp = length - 2;
+	type = regs[1];
+
+	switch (type) {
+	case DTYPE_DCS_SWRITE_0P:
+		rk32_dsi_set_bits(dsi, regs[0], dcs_sw_0p_tx);
+		data = regs[2] << 8 | type;
+		break;
+	case DTYPE_DCS_SWRITE_1P:
+		rk32_dsi_set_bits(dsi, regs[0], dcs_sw_1p_tx);
+		data = regs[2] << 8 | type;
+		data |= regs[3] << 16;
+		break;
+	case DTYPE_DCS_LWRITE:
+		rk32_dsi_set_bits(dsi, regs[0], dcs_lw_tx);
+		for (i = 0; i < liTmp; i++) {
+			regs[i] = regs[i+2];
+		}
+		for (i = 0; i < liTmp; i++) {
+			j = i % 4;
+			data |= regs[i] << (j * 8);
+			if (j == 3 || ((i + 1) == liTmp)) {
+				if (rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+					MIPI_TRACE("gen_pld_w_full :%d\n", i);
+					break;
+				}
+				rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+				MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+				data = 0;
+			}
+		}
+		data = type;
+		data |= (liTmp & 0xffff) << 8;
+		break;
+	case DTYPE_GEN_LWRITE:
+		rk32_dsi_set_bits(dsi, regs[0], gen_lw_tx);
+		for (i = 0; i < liTmp; i++) {
+			regs[i] = regs[i+2];
+		}
+		for (i = 0; i < liTmp; i++) {
+			j = i % 4;
+			data |= regs[i] << (j * 8);
+			if (j == 3 || ((i + 1) == liTmp)) {
+				if (rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+					MIPI_TRACE("gen_pld_w_full :%d\n", i);
+					break;
+				}
+				rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+				MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+				data = 0;
+			}
+		}
+		data = (dsi->vid << 6) | type;
+		data |= (liTmp & 0xffff) << 8;
+		break;
+	case DTYPE_GEN_SWRITE_2P: /* one command and one parameter */
+		rk32_dsi_set_bits(dsi, regs[0], gen_sw_2p_tx);
+		if (liTmp <= 2) {
+			/* It is used for normal Generic Short WRITE Packet with 2 parameters. */
+			data = type;
+			data |= regs[2] << 8;	/* dcs command */
+			data |= regs[3] << 16;	/* parameter of command */
+			break;
+		}
+
+		/* The below is used for Generic Short WRITE Packet with 2 parameters
+		 * that more than 2 parameters. Though it is illegal dcs command, we can't
+		 * make sure the users do not send that command.
+		 */
+		for (i = 0; i < liTmp; i++) {
+			regs[i] = regs[i+2];
+		}
+		for (i = 0; i < liTmp; i++) {
+			j = i % 4;
+			data |= regs[i] << (j * 8);
+			if (j == 3 || ((i + 1) == liTmp)) {
+				if (rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+					MIPI_TRACE("gen_pld_w_full :%d\n", i);
+					break;
+				}
+				rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+				MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+				data = 0;
+			}
+		}
+		data = type;
+		data |= (liTmp & 0xffff) << 8;
+		break;
+	case DTYPE_GEN_SWRITE_1P: /* one command without parameter */
+		rk32_dsi_set_bits(dsi, regs[0], gen_sw_1p_tx);
+		data = type;
+		data |= regs[2] << 8;
+		break;
+	case DTYPE_GEN_SWRITE_0P: /* nop packet without command and parameter */
+		rk32_dsi_set_bits(dsi, regs[0], gen_sw_0p_tx);
+		data =  type;
+		break;
+	default:
+		printk("0x%x:this type not suppport!\n", type);
+	}
+
+	MIPI_DBG("%d command sent in %s size:%d\n", __LINE__, regs[0] ? "LP mode" : "HS mode", liTmp);
+
+	MIPI_DBG("write GEN_HDR:%08x\n", data);
+	rk32_dsi_set_bits(dsi, data, GEN_HDR);
+
+	i = 10;
+	while (!rk32_dsi_get_bits(dsi, gen_cmd_empty) && i--) {
+		MIPI_DBG(".");
+		udelay(10);
+	}
+	udelay(10);
+	kfree(regs);
+	return 0;
+}
+
+static int rk32_mipi_dsi_read_dcs_packet(void *arg, unsigned char *data1, u32 n)
+{
+	struct dsi *dsi = arg;
+	unsigned char regs[2];
+	u32 data = 0;
+	int type = 0x06;
+	regs[0] = LPDT;
+	regs[1] = 0x0a;
+	n = n - 1;
+
+	rk32_dsi_set_bits(dsi, regs[0], dcs_sr_0p_tx);
+	/*
+	if(type == DTYPE_GEN_SWRITE_0P)
+		data = (dsi->vid << 6) | (n << 4) | type;
+	else
+		data = (dsi->vid << 6) | ((n-1) << 4) | type;
+	*/
+
+	data |= regs[1] << 8 | type;
+
+	printk("write GEN_HDR:%08x\n", data);
+
+	rk32_dsi_set_bits(dsi, 0xFFFF, bta_to_cnt);
+	rk32_dsi_set_bits(dsi, 1, bta_en);
+	rk32_dsi_set_bits(dsi, data, GEN_HDR);
+	udelay(20);
+
+	printk("rk32_mipi_dsi_read_dcs_packet==0x%x\n", rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
+	rk32_dsi_set_bits(dsi, 0, bta_en);
+
+	return 0;
+}
+
+static int rk32_mipi_dsi_power_up(void *arg)
+{
+	struct dsi *dsi = arg;
+
+	rk32_phy_power_up(dsi);
+	rk32_mipi_dsi_host_power_up(dsi);
+	return 0;
+}
+
+static int rk32_mipi_dsi_power_down(void *arg)
+{
+	struct dsi *dsi = arg;
+	struct mipi_dsi_screen *screen = &dsi->screen;
+
+	if (!screen)
+		return -1;
+
+	rk32_mipi_dsi_host_power_down(dsi);
+	rk_phy_power_down(dsi);
+
+	MIPI_TRACE("%s:%d\n", __func__, __LINE__);
+	return 0;
+}
+
+static int rk32_mipi_dsi_get_id(void *arg)
+{
+	u32 id = 0;
+	struct dsi *dsi = arg;
+
+	id = rk32_dsi_get_bits(dsi, VERSION);
+	return id;
+}
+
+#ifdef MIPI_DSI_REGISTER_IO
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+
+ssize_t reg_proc_write(struct file *file, const char __user *buff, size_t count, loff_t *offp)
+{
+	int ret = -1, i = 0;
+	u32 read_val = 0;
+	char *buf = kmalloc(count, GFP_KERNEL);
+	char *data = buf;
+	char str[32];
+	char command = 0;
+	u64 regs_val = 0;
+	memset(buf, 0, count);
+	ret = copy_from_user((void *)buf, buff, count);
+	data = strstr(data, "-");
+	if (data == NULL)
+		goto reg_proc_write_exit;
+	command = *(++data);
+	switch (command) {
+	case 'w':
+		while (1) {
+			data = strstr(data, "0x");
+			if (data == NULL)
+				goto reg_proc_write_exit;
+			sscanf(data, "0x%llx", &regs_val);
+			if ((regs_val & 0xffff00000000ULL) == 0)
+				goto reg_proc_write_exit;
+			read_val = regs_val & 0xffffffff;
+			printk("regs_val=0x%llx\n", regs_val);
+			rk32_dsi_write_reg(dsi0, regs_val >> 32, &read_val);
+			rk32_dsi_read_reg(dsi0, regs_val >> 32, &read_val);
+			regs_val &= 0xffffffff;
+			if (read_val != regs_val)
+				MIPI_TRACE("%s fail:0x%08x\n", __func__, read_val);
+			data += 3;
+			msleep(1);
+		}
+		break;
+	case 'r':
+		data = strstr(data, "0x");
+		if (data == NULL) {
+			goto reg_proc_write_exit;
+		}
+		sscanf(data, "0x%llx", &regs_val);
+		rk32_dsi_read_reg(dsi0, (u16)regs_val, &read_val);
+		MIPI_TRACE("*%04x : %08x\n", (u16)regs_val, read_val);
+		msleep(1);
+		break;
+	case 's':
+		while (*(++data) == ' ')
+			;
+		sscanf(data, "%d", &read_val);
+		if (read_val == 11)
+			read_val = 11289600;
+		else
+			read_val *= MHz;
+		break;
+	case 'd':
+	case 'g':
+	case 'c':
+		while (*(++data) == ' ')
+			;
+		i = 0;
+
+		do {
+			if (i > 31) {
+				MIPI_TRACE("payload entry is larger than 32\n");
+				break;
+			}
+			sscanf(data, "%x,", (unsigned int *)(str + i)); /* -c 1,29,02,03,05,06,> pro */
+			data = strstr(data, ",");
+			if (data == NULL)
+				break;
+			data++;
+			i++;
+		} while (1);
+		read_val = i;
+		i = 2;
+		while (i--) {
+			msleep(10);
+			if (command == 'd')
+				rk32_mipi_dsi_send_packet(dsi0, str, read_val);
+			else
+				rk32_mipi_dsi_send_packet(dsi0, str, read_val);
+		}
+		i = 1;
+		while (i--) {
+			msleep(1000);
+		}
+		break;
+	default:
+		break;
+	}
+
+reg_proc_write_exit:
+	kfree(buf);
+	msleep(20);
+	return count;
+}
+
+int reg_proc_read(struct seq_file *s, void *v)
+{
+	int i = 0;
+	u32 val = 0;
+	struct dsi *dsi = s->private;
+
+	for (i = VERSION; i < (VERSION + (0xdc << 16)); i += 4<<16) {
+		val = rk32_dsi_get_bits(dsi, i);
+		seq_printf(s, "%04x: %08x\n", i>>16, val);
+	}
+	return 0;
+}
+static int reg_proc_open(struct inode *inode, struct file *file)
+{
+	struct dsi *dsi = inode->i_private;
+
+	return single_open(file, reg_proc_read, dsi);
+}
+
+int reg_proc_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+struct file_operations reg_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = reg_proc_open,
+	.release = reg_proc_close,
+	.write = reg_proc_write,
+	.read = seq_read,
+};
+
+ssize_t reg_proc_write1(struct file *file, const char __user *buff, size_t count, loff_t *offp)
+{
+	int ret = -1, i = 0;
+	u32 read_val = 0;
+	char *buf = kmalloc(count, GFP_KERNEL);
+	char *data = buf;
+	char str[32];
+	char command = 0;
+	u64 regs_val = 0;
+	memset(buf, 0, count);
+	ret = copy_from_user((void *)buf, buff, count);
+
+	data = strstr(data, "-");
+	if (data == NULL)
+		goto reg_proc_write_exit;
+	command = *(++data);
+
+	switch (command) {
+	case 'w':
+		while (1) {
+			data = strstr(data, "0x");
+			if (data == NULL)
+				goto reg_proc_write_exit;
+			sscanf(data, "0x%llx", &regs_val);
+			if ((regs_val & 0xffff00000000ULL) == 0)
+				goto reg_proc_write_exit;
+			read_val = regs_val & 0xffffffff;
+			rk32_dsi_write_reg(dsi1, regs_val >> 32, &read_val);
+			rk32_dsi_read_reg(dsi1, regs_val >> 32, &read_val);
+			regs_val &= 0xffffffff;
+			if (read_val != regs_val)
+				MIPI_TRACE("%s fail:0x%08x\n", __func__, read_val);
+			data += 3;
+			msleep(1);
+		}
+		break;
+	case 'r':
+		data = strstr(data, "0x");
+		if (data == NULL)
+			goto reg_proc_write_exit;
+		sscanf(data, "0x%llx", &regs_val);
+		rk32_dsi_read_reg(dsi1, (u16)regs_val, &read_val);
+		MIPI_TRACE("*%04x : %08x\n", (u16)regs_val, read_val);
+		msleep(1);
+		break;
+	case 's':
+		while (*(++data) == ' ')
+			;
+		sscanf(data, "%d", &read_val);
+		if (read_val == 11)
+			read_val = 11289600;
+		else
+			read_val *= MHz;
+		break;
+	case 'd':
+	case 'g':
+	case 'c':
+		while (*(++data) == ' ')
+			;
+		i = 0;
+
+		do {
+			if (i > 31) {
+				MIPI_TRACE("payload entry is larger than 32\n");
+				break;
+			}
+			sscanf(data, "%x,", (unsigned int *)(str + i)); /* -c 1,29,02,03,05,06,> pro */
+			data = strstr(data, ",");
+			if (data == NULL)
+				break;
+			data++;
+			i++;
+		} while (1);
+		read_val = i;
+		i = 2;
+		while (i--) {
+			msleep(10);
+			if (command == 'd')
+				rk32_mipi_dsi_send_packet(dsi1, str, read_val);
+			else
+				rk32_mipi_dsi_send_packet(dsi1, str, read_val);
+		}
+		i = 1;
+		while (i--) {
+			msleep(1000);
+		}
+		break;
+	default:
+		break;
+	}
+
+reg_proc_write_exit:
+	kfree(buf);
+	msleep(20);
+	return count;
+}
+
+int reg_proc_close1(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+struct file_operations reg_proc_fops1 = {
+	.owner = THIS_MODULE,
+	.open = reg_proc_open,
+	.release = reg_proc_close1,
+	.write = reg_proc_write1,
+	.read = seq_read,
+};
+#endif
+#if 0/* def CONFIG_MIPI_DSI_LINUX */
+static irqreturn_t rk32_mipi_dsi_irq_handler(int irq, void *data)
+{
+	printk("-------rk32_mipi_dsi_irq_handler-------\n");
+	return IRQ_HANDLED;
+}
+#endif
+
+#if 0
+static int dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
+{
+	int val = 0;
+
+	rk32_dsi_set_bits(dsi, 0x10000 | test_code, PHY_TEST_CTRL1);
+	rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
+	rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
+
+	val = rk32_dsi_get_bits(dsi, PHY_TEST_CTRL1);
+	return val;
+}
+#endif
+static int rk32_dsi_enable(void)
+{
+	u16 opt_mode = 0;
+	MIPI_DBG("rk32_dsi_enable-------\n");
+	if (!dsi0->clk_on) {
+		dsi0->clk_on = 1;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		pm_runtime_get_sync(&dsi0->pdev->dev);
+#endif
+		opt_mode = dsi0->screen.refresh_mode;
+		rk_fb_get_prmry_screen(dsi0->screen.screen);
+		dsi0->screen.lcdc_id = dsi0->screen.screen->lcdc_id;
+		rk32_init_phy_mode(dsi0->screen.lcdc_id);
+
+		dsi_init(0, 0);
+		if (rk_mipi_get_dsi_num() == 2)
+			dsi_init(1, 0);
+
+		rk_mipi_screen_standby(0);
+
+	/* After the core reset, DPI waits for the first VSYNC
+	active transition to start signal sampling, including pixel data,
+	and preventing image transmission in the middle of a frame.
+	*/
+		dsi_is_enable(0, 0);
+		if (rk_mipi_get_dsi_num() == 2)
+			dsi_is_enable(1, 0);
+
+		if (opt_mode != COMMAND_MODE) {
+			dsi_enable_video_mode(0, 1);
+			if (rk_mipi_get_dsi_num() == 2)
+				dsi_enable_video_mode(1, 1);
+		}
+		dsi_is_enable(0, 1);
+		if (rk_mipi_get_dsi_num() == 2)
+			dsi_is_enable(1, 1);
+	}
+	return 0;
+}
+
+static void rockchip_mipi_cmd_mode_refresh(unsigned int xpos,
+					   unsigned int ypos,
+					   unsigned int xsize,
+					   unsigned int ysize)
+{
+	u32 x0 = xpos;
+	u32 y0 = ypos;
+	u32 x1 = x0 + xsize - 1;
+	u32 y1 = y0 + ysize - 1;
+
+	unsigned char x0_MSB = ((x0 >> 8) & 0xff);
+	unsigned char x0_LSB = (x0 & 0xff);
+	unsigned char x1_MSB = ((x1 >> 8) & 0xff);
+	unsigned char x1_LSB = (x1 & 0xff);
+	unsigned char y0_MSB = ((y0 >> 8) & 0xff);
+	unsigned char y0_LSB = (y0 & 0xff);
+	unsigned char y1_MSB = ((y1 >> 8) & 0xff);
+	unsigned char y1_LSB = (y1 & 0xff);
+
+	unsigned char set_col_cmd[7] = {0};
+	unsigned char set_page_cmd[7] = {0};
+	unsigned char wms[3] = {0};
+	u32 len;
+
+	set_col_cmd[0] = HSDT;
+	set_col_cmd[1] = 0x39;
+	set_col_cmd[2] = 0x2a;
+	set_col_cmd[3] = x0_MSB;
+	set_col_cmd[4] = x0_LSB;
+	set_col_cmd[5] = x1_MSB;
+	set_col_cmd[6] = x1_LSB;
+
+	len = ARRAY_SIZE(set_col_cmd);
+	rk32_mipi_dsi_send_packet(dsi0, set_col_cmd, len);
+	if (rk_mipi_get_dsi_num() == 2)
+		rk32_mipi_dsi_send_packet(dsi1, set_col_cmd, len);
+
+	set_page_cmd[0] = HSDT;
+	set_page_cmd[1] = 0x39;
+	set_page_cmd[2] = 0x2b;
+	set_page_cmd[3] = y0_MSB;
+	set_page_cmd[4] = y0_LSB;
+	set_page_cmd[5] = y1_MSB;
+	set_page_cmd[6] = y1_LSB;
+
+	len = ARRAY_SIZE(set_page_cmd);
+	rk32_mipi_dsi_send_packet(dsi0, set_page_cmd, len);
+	if (rk_mipi_get_dsi_num() == 2)
+		rk32_mipi_dsi_send_packet(dsi1, set_page_cmd, len);
+
+	wms[0] = HSDT;
+	wms[1] = 0x39;
+	wms[2] = 0x2C;
+
+	len = ARRAY_SIZE(wms);
+	rk32_mipi_dsi_send_packet(dsi0, wms, len);
+	if (rk_mipi_get_dsi_num() == 2)
+		rk32_mipi_dsi_send_packet(dsi1, wms, len);
+}
+
+#ifdef CONFIG_MIPI_DSI_LINUX
+static int rk32_dsi_disable(void)
+{
+	MIPI_DBG("rk32_dsi_disable-------\n");
+	if (dsi0->clk_on) {
+		dsi0->clk_on = 0;
+		rk_mipi_screen_standby(1);
+		dsi_power_off(0);
+		if (rk_mipi_get_dsi_num() == 2)
+			dsi_power_off(1);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+		pm_runtime_put(&dsi0->pdev->dev);
+#endif
+	}
+	return 0;
+}
+
+static struct rk_fb_trsm_ops trsm_dsi_ops = {
+	.enable = rk32_dsi_enable,
+	.disable = rk32_dsi_disable,
+	.dsp_pwr_on = rk32_mipi_power_up_DDR,
+	.dsp_pwr_off = rk32_mipi_power_down_DDR,
+	.refresh = rockchip_mipi_cmd_mode_refresh,
+};
+#endif
+
+static void rockchip_3399_grf_config(int lcdc_id)
+{
+	int dsi_num;
+	int val;
+
+	dsi_num = rk_mipi_get_dsi_num();
+	if (dsi_num == 1) {
+		if (lcdc_id == 1) {
+			val = 0x1 << 16 | 0x1;
+			regmap_write(dsi0->grf_base, RK3399_GRF_CON20, val);
+		} else {
+			val = 0x1 << 16 | 0x0;
+			regmap_write(dsi0->grf_base, RK3399_GRF_CON20, val);
+		}
+
+		val = 0x1 << 28 | 0x0 << 12;
+		val |= 0xf << 20 | 0x0 << 4;
+		val |= 0xf << 16 | 0x0;
+		regmap_write(dsi0->grf_base, RK3399_GRF_CON22, val);
+	} else {
+		if (lcdc_id == 1) {
+			val = 0x1 << 16 | 0x1;
+			val |= 0x1 << 20 | 0x1 << 4;
+			regmap_write(dsi0->grf_base, RK3399_GRF_CON20, val);
+		} else {
+			val = 0x1 << 16 | 0x0;
+			val |= 0x1 << 20 | 0x0 << 4;
+			regmap_write(dsi0->grf_base, RK3399_GRF_CON20, val);
+		}
+
+		val = 0x1 << 28 | 0x0 << 12;
+		val |= 0xf << 20 | 0x0 << 4;
+		val |= 0xf << 16 | 0x0;
+		regmap_write(dsi0->grf_base, RK3399_GRF_CON22, val);
+
+		val = 0x1 << 20 | 0x0 << 0x4;
+		regmap_write(dsi0->grf_base, RK3399_GRF_CON7, val);
+
+		val = 0xf << 24 | 0x0 << 8;
+		val |= 0xf << 20 | 0x0 << 4;
+		val |= 0xf << 16 | 0x0;
+		regmap_write(dsi0->grf_base, RK3399_GRF_CON23, val);
+
+		val = 0x1 << 22 | 0x1 << 6;
+		val |= 0x1 << 21 | 0x0 << 5;
+		regmap_write(dsi0->grf_base, RK3399_GRF_CON24, val);
+
+		val = 0xf << 24 | 0x0 << 8;
+		val |= 0xf << 20 | 0x0 << 4;
+		val |= 0xf << 16 | 0xf;
+		regmap_write(dsi0->grf_base, RK3399_GRF_CON23, val);
+	}
+}
+
+static void rk32_init_phy_mode(int lcdc_id)
+{
+
+	MIPI_DBG("rk32_init_phy_mode----------lcdc_id=%d\n", lcdc_id);
+
+	/* Only the rk3288 VOP need setting the VOP output. */
+	if (dsi0->ops.id == DSI_RK3288) {
+#if 0
+		int val0 = 0, val1 = 0;
+
+		/* D-PHY mode select */
+		if (rk_mipi_get_dsi_num() == 1) {
+			if (lcdc_id == 1)
+				/* 1'b1: VOP LIT output to DSI host0;1'b0: VOP BIG output to DSI host0 */
+				val0 = 0x1 << 22 | 0x1 << 6;
+			else
+				val0 = 0x1 << 22 | 0x0 << 6;
+			writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
+		} else {
+			if (lcdc_id == 1) {
+				val0 = 0x1 << 25 | 0x1 <<  9 | 0x1 << 22 | 0x1 <<  6;
+				val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14;
+			} else {
+				val0 = 0x1 << 25 | 0x0 <<  9 | 0x1 << 22 | 0x0 << 14;
+				val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14;
+			}
+			writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
+			writel_relaxed(val1, RK_GRF_VIRT + RK3288_GRF_SOC_CON14);
+		}
+#endif
+	} else if (dsi0->ops.id == DSI_RK3399) {
+		rockchip_3399_grf_config(lcdc_id);
+	}
+}
+
+#ifdef CONFIG_MIPI_DSI_LINUX
+static int rk32_mipi_power_down_DDR(void)
+{
+	dsi_is_enable(0, 0);
+	if (rk_mipi_get_dsi_num() == 2)
+		dsi_is_enable(1, 0);
+	return 0;
+}
+
+static int rk32_mipi_power_up_DDR(void)
+{
+	dsi_is_enable(0, 0);
+	if (rk_mipi_get_dsi_num() == 2)
+		dsi_is_enable(1, 0);
+	dsi_enable_video_mode(0, 1);
+	dsi_enable_video_mode(1, 1);
+	dsi_is_enable(0, 1);
+	if (rk_mipi_get_dsi_num() == 2)
+		dsi_is_enable(1, 1);
+	return 0;
+}
+
+struct dsi_type {
+	char *label;
+	u32 dsi_id;
+};
+
+static struct dsi_type dsi_rk312x = {
+	.label = "rk312-dsi",
+	.dsi_id = DSI_RK312x,
+};
+
+static struct dsi_type dsi_rk32 = {
+	.label = "rk32-dsi",
+	.dsi_id = DSI_RK3288,
+};
+
+static struct dsi_type dsi_rk3368 = {
+	.label = "rk3368-dsi",
+	.dsi_id = DSI_RK3368,
+};
+
+static struct dsi_type dsi_rk3366 = {
+	.label = "rk3366-dsi",
+	.dsi_id = DSI_RK3366,
+};
+
+static struct dsi_type dsi_rk3399 = {
+	.label = "rk3399-dsi",
+	.dsi_id = DSI_RK3399,
+};
+
+static const struct of_device_id of_rk_mipi_dsi_match[] = {
+	{ .compatible = "rockchip,rk32-dsi", .data = &dsi_rk32},
+	{ .compatible = "rockchip,rk312x-dsi", .data = &dsi_rk312x},
+	{ .compatible = "rockchip,rk3368-dsi", .data = &dsi_rk3368},
+	{ .compatible = "rockchip,rk3366-dsi", .data = &dsi_rk3366},
+	{ .compatible = "rockchip,rk3399-dsi", .data = &dsi_rk3399},
+	{ /* Sentinel */ }
+};
+
+static int rk32_mipi_dsi_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	static int id;
+	struct dsi *dsi;
+	struct mipi_dsi_ops *ops;
+	struct rk_screen *screen;
+	struct mipi_dsi_screen *dsi_screen;
+	struct resource *res_host, *res_phy;
+	struct device_node *np = pdev->dev.of_node;
+	const struct dsi_type *data;
+	const struct of_device_id *of_id =
+			of_match_device(of_rk_mipi_dsi_match, &pdev->dev);
+	if (!of_id) {
+		dev_err(&pdev->dev, "failed to match device\n");
+		return -ENODEV;
+	}
+	data = of_id->data;
+
+	dsi = devm_kzalloc(&pdev->dev, sizeof(struct dsi), GFP_KERNEL);
+	if (!dsi) {
+		dev_err(&pdev->dev, "request struct dsi fail!\n");
+		return -ENOMEM;
+	}
+	dsi->ops.id = data->dsi_id;
+	printk(KERN_INFO "%s\n", data->label);
+	if (dsi->ops.id == DSI_RK3288 ||
+	    dsi->ops.id == DSI_RK3399) {
+		res_host = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		dsi->host.membase = devm_ioremap_resource(&pdev->dev, res_host);
+		if (IS_ERR(dsi->host.membase)) {
+			dev_err(&pdev->dev, "get resource mipi host membase fail!\n");
+			return PTR_ERR(dsi->host.membase);
+		}
+	} else if (dsi->ops.id == DSI_RK312x ||
+			dsi->ops.id == DSI_RK3368 ||
+			dsi->ops.id == DSI_RK3366) {
+		res_host = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_dsi_host");
+		dsi->host.membase = devm_ioremap_resource(&pdev->dev, res_host);
+		if (IS_ERR(dsi->host.membase)) {
+			dev_err(&pdev->dev, "get resource mipi host membase fail!\n");
+			return PTR_ERR(dsi->host.membase);
+		}
+		res_phy = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_dsi_phy");
+		dsi->phy.membase = devm_ioremap_resource(&pdev->dev, res_phy);
+		if (IS_ERR(dsi->phy.membase)) {
+			dev_err(&pdev->dev, "get resource mipi phy membase fail!\n");
+			return PTR_ERR(dsi->phy.membase);
+		}
+	}
+
+	dsi->phy.refclk  = devm_clk_get(&pdev->dev, "clk_mipi_24m");
+	if (unlikely(IS_ERR(dsi->phy.refclk))) {
+		dev_err(&pdev->dev, "get clk_mipi_24m clock fail\n");
+		return PTR_ERR(dsi->phy.refclk);
+	}
+
+	/* Get the APB bus clk access mipi phy */
+	dsi->dsi_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi");
+	if (unlikely(IS_ERR(dsi->dsi_pclk))) {
+		dev_err(&pdev->dev, "get pclk_mipi_dsi clock fail\n");
+		return PTR_ERR(dsi->dsi_pclk);
+	}
+
+	if (dsi->ops.id == DSI_RK3368 ||
+	    dsi->ops.id == DSI_RK3366) {
+		/* Get the APB bus clk access mipi host */
+		dsi->dsi_host_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi_host");
+		if (unlikely(IS_ERR(dsi->dsi_host_pclk))) {
+			dev_err(&pdev->dev, "get pclk_mipi_dsi_host clock fail\n");
+			return PTR_ERR(dsi->dsi_host_pclk);
+		}
+	}
+
+	if (dsi->ops.id == DSI_RK312x) {
+		/* Get the APB bus clk access mipi host */
+		dsi->dsi_host_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi_host");
+		if (unlikely(IS_ERR(dsi->dsi_host_pclk))) {
+			dev_err(&pdev->dev, "get pclk_mipi_dsi_host clock fail\n");
+			return PTR_ERR(dsi->dsi_host_pclk);
+		}
+		/* Get the pd_vio AHB h2p bridge clock */
+		dsi->h2p_hclk = devm_clk_get(&pdev->dev, "hclk_vio_h2p");
+		if (unlikely(IS_ERR(dsi->h2p_hclk))) {
+			dev_err(&pdev->dev, "get hclk_vio_h2p clock fail\n");
+			return PTR_ERR(dsi->h2p_hclk);
+		}
+	}
+
+	if (dsi->ops.id == DSI_RK3399) {
+		/* Get mipi phy cfg clk */
+		dsi->dsi_host_pclk = devm_clk_get(&pdev->dev, "mipi_dphy_cfg");
+		if (unlikely(IS_ERR(dsi->dsi_host_pclk))) {
+			dev_err(&pdev->dev, "get mipi_dphy_cfg clock fail\n");
+			return PTR_ERR(dsi->dsi_host_pclk);
+		}
+
+		dsi->grf_base = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+		if (IS_ERR(dsi->grf_base)) {
+			dev_err(&pdev->dev, "can't find mipi grf property\n");
+			dsi->grf_base = NULL;
+		}
+	}
+
+	dsi->host.irq = platform_get_irq(pdev, 0);
+	if (dsi->host.irq < 0) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return dsi->host.irq;
+	}
+	/*
+	ret = request_irq(dsi->host.irq, rk32_mipi_dsi_irq_handler, 0,dev_name(&pdev->dev), dsi);
+	if (ret) {
+		dev_err(&pdev->dev, "request mipi_dsi irq fail\n");
+		return -EINVAL;
+	}
+	*/
+	printk("dsi->host.irq =%d\n", dsi->host.irq);
+
+	disable_irq(dsi->host.irq);
+
+	screen = devm_kzalloc(&pdev->dev, sizeof(struct rk_screen), GFP_KERNEL);
+	if (!screen) {
+		dev_err(&pdev->dev, "request struct rk_screen fail!\n");
+		return -1;
+	}
+	rk_fb_get_prmry_screen(screen);
+
+	dsi->pdev = pdev;
+	ops = &dsi->ops;
+	ops->dsi = dsi;
+
+	ops->get_id = rk32_mipi_dsi_get_id,
+	ops->dsi_send_packet = rk32_mipi_dsi_send_packet;
+	ops->dsi_read_dcs_packet = rk32_mipi_dsi_read_dcs_packet,
+	ops->dsi_enable_video_mode = rk32_mipi_dsi_enable_video_mode,
+	ops->dsi_enable_command_mode = rk32_mipi_dsi_enable_command_mode,
+	ops->dsi_enable_hs_clk = rk32_mipi_dsi_enable_hs_clk,
+	ops->dsi_is_active = rk32_mipi_dsi_is_active,
+	ops->dsi_is_enable = rk32_mipi_dsi_is_enable,
+	ops->power_up = rk32_mipi_dsi_power_up,
+	ops->power_down = rk32_mipi_dsi_power_down,
+	ops->dsi_init = rk_mipi_dsi_init,
+
+	dsi_screen = &dsi->screen;
+	dsi_screen->screen = screen;
+	dsi_screen->type = screen->type;
+	dsi_screen->face = screen->face;
+	dsi_screen->lcdc_id = screen->lcdc_id;
+	dsi_screen->screen_id = screen->screen_id;
+	dsi_screen->pixclock = screen->mode.pixclock;
+	dsi_screen->left_margin = screen->mode.left_margin;
+	dsi_screen->right_margin = screen->mode.right_margin;
+	dsi_screen->hsync_len = screen->mode.hsync_len;
+	dsi_screen->upper_margin = screen->mode.upper_margin;
+	dsi_screen->lower_margin = screen->mode.lower_margin;
+	dsi_screen->vsync_len = screen->mode.vsync_len;
+	dsi_screen->x_res = screen->mode.xres;
+	dsi_screen->y_res = screen->mode.yres;
+	dsi_screen->pin_hsync = screen->pin_hsync;
+	dsi_screen->pin_vsync = screen->pin_vsync;
+	dsi_screen->pin_den = screen->pin_den;
+	dsi_screen->pin_dclk = screen->pin_dclk;
+	dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
+	dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
+	dsi_screen->hs_tx_clk = rk_mipi_get_dsi_clk();
+	/* dsi_screen->lcdc_id = 1; */
+	dsi_screen->refresh_mode = screen->refresh_mode;
+
+	dsi->dsi_id = id++;
+
+	sprintf(ops->name, "rk_mipi_dsi.%d", dsi->dsi_id);
+	platform_set_drvdata(pdev, dsi);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	/* enable power domain */
+	pm_runtime_enable(&pdev->dev);
+#endif
+
+	register_dsi_ops(dsi->dsi_id, &dsi->ops);
+
+	if (id == 1) {
+		/*
+		if(!support_uboot_display())
+			rk32_init_phy_mode(dsi_screen->lcdc_id);
+		*/
+		rk_fb_trsm_ops_register(&trsm_dsi_ops, SCREEN_MIPI);
+#ifdef MIPI_DSI_REGISTER_IO
+		debugfs_create_file("mipidsi0", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi,
+							&reg_proc_fops);
+#endif
+		dsi0 = dsi;
+	} else {
+		dsi1 = dsi;
+#ifdef MIPI_DSI_REGISTER_IO
+		debugfs_create_file("mipidsi1", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi,
+							&reg_proc_fops1);
+#endif
+	}
+
+	if (support_uboot_display()) {
+		clk_prepare_enable(dsi->phy.refclk);
+		clk_prepare_enable(dsi->dsi_pclk);
+		if (dsi->ops.id == DSI_RK312x) {
+			clk_prepare_enable(dsi->dsi_host_pclk);
+			clk_prepare_enable(dsi->h2p_hclk);
+		} else if (dsi->ops.id == DSI_RK3368 ||
+			dsi->ops.id == DSI_RK3366)
+			clk_prepare_enable(dsi->dsi_host_pclk);
+		else if (dsi->ops.id == DSI_RK3399)
+			clk_prepare_enable(dsi->dsi_host_pclk);
+
+		dsi->clk_on = 1;
+		udelay(10);
+	}
+
+	dev_info(&pdev->dev, "rk mipi_dsi probe success!\n");
+	dev_info(&pdev->dev, "%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
+
+	return ret;
+}
+
+static int rockchip_mipi_remove(struct platform_device *pdev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0))
+	pm_runtime_disable(&pdev->dev);
+#endif
+	return 0;
+}
+
+static struct platform_driver rk32_mipi_dsi_driver = {
+	.probe = rk32_mipi_dsi_probe,
+	.remove = rockchip_mipi_remove,
+	.driver = {
+		.name = "rk32-mipi",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table	= of_rk_mipi_dsi_match,
+#endif
+	},
+};
+
+static int __init rk32_mipi_dsi_init(void)
+{
+	return platform_driver_register(&rk32_mipi_dsi_driver);
+}
+fs_initcall(rk32_mipi_dsi_init);
+
+static void __exit rk32_mipi_dsi_exit(void)
+{
+	platform_driver_unregister(&rk32_mipi_dsi_driver);
+}
+module_exit(rk32_mipi_dsi_exit);
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,335 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
+*/
+
+#ifndef RK32_MIPI_DSI_H
+#define RK32_MIPI_DSI_H
+
+#ifdef CONFIG_RK_3288_DSI_UBOOT
+#include <asm/arch/rkplat.h>
+#define RK_GRF_VIRT			RKIO_GRF_PHYS
+#define RK3288_CRU_PHYS			RKIO_CRU_PHYS
+
+#define RK3288_GRF_SOC_CON6		GRF_SOC_CON6
+#define RK3288_GRF_SOC_CON14		GRF_SOC_CON14
+#else
+#include <linux/rockchip/grf.h>
+#endif
+
+#define RK3399_GRF_CON7		0xe21c
+#define RK3399_GRF_CON20	0x6250
+#define RK3399_GRF_CON22	0x6258
+#define RK3399_GRF_CON23	0x625c
+#define RK3399_GRF_CON24	0x6260
+
+#define MIPI_DSI_PHY_OFFSET		0x0C00
+#define MIPI_DSI_PHY_SIZE		0x34c
+
+#define MIPI_DSI_HOST_OFFSET	0x1000
+
+/* function bits definition    register addr | bits | offest */
+#define REG_ADDR(a)			((a) << 16)
+#define REG_BITS(a)			((a) << 8)
+#define BITS_OFFSET(a)		(a)
+#define DSI_HOST_BITS(addr, bits, bit_offset)  (REG_ADDR((addr)+MIPI_DSI_HOST_OFFSET) \
+		| REG_BITS(bits) | BITS_OFFSET(bit_offset))
+#define DSI_DPHY_BITS(addr, bits, bit_offset)  (REG_ADDR((addr)+MIPI_DSI_PHY_OFFSET) \
+		| REG_BITS(bits) | BITS_OFFSET(bit_offset))
+
+/* DWC_DSI_VERSION_0x3133302A */
+#define VERSION 					DSI_HOST_BITS(0x000, 32, 0)
+#define shutdownz 					DSI_HOST_BITS(0x004, 1, 0)
+#define TO_CLK_DIVISION 			DSI_HOST_BITS(0x008, 8, 8)
+#define TX_ESC_CLK_DIVISION 		DSI_HOST_BITS(0x008, 8, 0)
+#define dpi_vcid					DSI_HOST_BITS(0x00c, 2, 0)
+#define en18_loosely 				DSI_HOST_BITS(0x010, 1, 8)
+#define dpi_color_coding 			DSI_HOST_BITS(0x010, 4, 0)	/* need modify in code */
+#define colorm_active_low 			DSI_HOST_BITS(0x014, 1, 4)
+#define shutd_active_low  			DSI_HOST_BITS(0x014, 1, 3)
+#define hsync_active_low  			DSI_HOST_BITS(0x014, 1, 2)
+#define vsync_active_low  			DSI_HOST_BITS(0x014, 1, 1)
+#define dataen_active_low  			DSI_HOST_BITS(0x014, 1, 0)
+#define outvact_lpcmd_time  		DSI_HOST_BITS(0x018, 8, 16)	/* attence */
+#define invact_lpcmd_time 			DSI_HOST_BITS(0x018, 8, 0)
+/* #define dbi_vcid					DSI_HOST_BITS(0x01c, 2, 0) */
+#define crc_rx_en 					DSI_HOST_BITS(0x02c, 1, 4)
+#define ecc_rx_en 					DSI_HOST_BITS(0x02c, 1, 3)
+#define bta_en 						DSI_HOST_BITS(0x02c, 1, 2)
+#define eotp_rx_en 					DSI_HOST_BITS(0x02c, 1, 1)
+#define eotp_tx_en 					DSI_HOST_BITS(0x02c, 1, 0)
+#define gen_vid_rx 					DSI_HOST_BITS(0x030, 2, 0)
+#define cmd_video_mode 				DSI_HOST_BITS(0x034, 1, 0)
+#define vpg_orientation             DSI_HOST_BITS(0x038, 1, 24)
+#define vpg_mode                    DSI_HOST_BITS(0x038, 1, 20)
+#define vpg_en                      DSI_HOST_BITS(0x038, 1, 16)
+#define lp_cmd_en  					DSI_HOST_BITS(0x038, 1, 15)
+#define frame_bta_ack_en 			DSI_HOST_BITS(0x038, 1, 14)
+#define lp_hfp_en 					DSI_HOST_BITS(0x038, 1, 13)
+#define lp_hbp_en 					DSI_HOST_BITS(0x038, 1, 12)
+#define lp_vact_en 					DSI_HOST_BITS(0x038, 1, 11)
+#define lp_vfp_en 					DSI_HOST_BITS(0x038, 1, 10)
+#define lp_vbp_en 					DSI_HOST_BITS(0x038, 1, 9)
+#define lp_vsa_en 					DSI_HOST_BITS(0x038, 1, 8)
+#define vid_mode_type 				DSI_HOST_BITS(0x038, 2, 0)
+#define vid_pkt_size 				DSI_HOST_BITS(0x03c, 14, 0)
+#define num_chunks 					DSI_HOST_BITS(0x040, 13, 0)
+#define null_pkt_size 				DSI_HOST_BITS(0x044, 13, 0)
+#define vid_hsa_time 				DSI_HOST_BITS(0x048, 12, 0)
+#define vid_hbp_time 				DSI_HOST_BITS(0x04c, 12, 0)
+#define vid_hline_time  			DSI_HOST_BITS(0x050, 15, 0)
+#define vid_vsa_lines 				DSI_HOST_BITS(0x054, 10, 0)
+#define vid_vbp_lines 				DSI_HOST_BITS(0x058, 10, 0)
+#define vid_vfp_lines 				DSI_HOST_BITS(0x05c, 10, 0)
+#define vid_active_lines 			DSI_HOST_BITS(0x060, 14, 0)
+#define edpi_cmd_size				DSI_HOST_BITS(0x064, 16, 0)
+#define max_rd_pkt_size 			DSI_HOST_BITS(0x068, 1, 24)
+#define dcs_lw_tx 					DSI_HOST_BITS(0x068, 1, 19)
+#define dcs_sr_0p_tx 				DSI_HOST_BITS(0x068, 1, 18)
+#define dcs_sw_1p_tx 				DSI_HOST_BITS(0x068, 1, 17)
+#define dcs_sw_0p_tx				DSI_HOST_BITS(0x068, 1, 16)
+#define gen_lw_tx 					DSI_HOST_BITS(0x068, 1, 14)
+#define gen_sr_2p_tx				DSI_HOST_BITS(0x068, 1, 13)
+#define gen_sr_1p_tx 				DSI_HOST_BITS(0x068, 1, 12)
+#define gen_sr_0p_tx 				DSI_HOST_BITS(0x068, 1, 11)
+#define gen_sw_2p_tx 				DSI_HOST_BITS(0x068, 1, 10)
+#define gen_sw_1p_tx 				DSI_HOST_BITS(0x068, 1, 9)
+#define gen_sw_0p_tx 				DSI_HOST_BITS(0x068, 1, 8)
+#define ack_rqst_en 				DSI_HOST_BITS(0x068, 1, 1)
+#define tear_fx_en 					DSI_HOST_BITS(0x068, 1, 0)
+#define GEN_HDR						DSI_HOST_BITS(0x06c, 32, 0)
+#define GEN_PLD_DATA				DSI_HOST_BITS(0x070, 32, 0)
+#define gen_rd_cmd_busy  			DSI_HOST_BITS(0x074, 1, 6)
+#define gen_pld_r_full 				DSI_HOST_BITS(0x074, 1, 5)
+#define gen_pld_r_empty 			DSI_HOST_BITS(0x074, 1, 4)
+#define gen_pld_w_full 				DSI_HOST_BITS(0x074, 1, 3)	/* 800byte    write GEN_PLD_DATA */
+#define gen_pld_w_empty				DSI_HOST_BITS(0x074, 1, 2)
+#define gen_cmd_full 				DSI_HOST_BITS(0x074, 1, 1)	/* 20   write GEN_HDR */
+#define gen_cmd_empty 				DSI_HOST_BITS(0x074, 1, 0)
+#define hstx_to_cnt 				DSI_HOST_BITS(0x078, 16, 16)
+#define lprx_to_cnt 				DSI_HOST_BITS(0x078, 16, 0)
+#define hs_rd_to_cnt 				DSI_HOST_BITS(0x07c, 16, 0)
+#define lp_rd_to_cnt 				DSI_HOST_BITS(0x080, 16, 0)
+#define presp_to_mode 				DSI_HOST_BITS(0x084, 1, 24)
+#define hs_wr_to_cnt 				DSI_HOST_BITS(0x084, 16, 0)
+#define lp_wr_to_cnt 				DSI_HOST_BITS(0x088, 16, 0)
+#define bta_to_cnt 					DSI_HOST_BITS(0x08c, 16, 0)
+/*
+#define send_3d_cfg 				DSI_HOST_BITS(0x090, 1, 16)
+#define right_first 				DSI_HOST_BITS(0x090, 1, 5)
+#define second_vsync 				DSI_HOST_BITS(0x090, 1, 4)
+#define format_3d 					DSI_HOST_BITS(0x090, 2, 2)
+#define mode_3d		 				DSI_HOST_BITS(0x090, 2, 0)
+*/
+#define auto_clklane_ctrl 			DSI_HOST_BITS(0x094, 1, 1)
+#define phy_txrequestclkhs 			DSI_HOST_BITS(0x094, 1, 0)
+#define phy_hs2lp_time_clk_lane			DSI_HOST_BITS(0x098, 10, 16)
+#define phy_hs2hs_time_clk_lane			DSI_HOST_BITS(0x098, 10, 0)
+#define phy_hs2lp_time 				DSI_HOST_BITS(0x09c, 8, 24)
+#define phy_lp2hs_time 				DSI_HOST_BITS(0x09c, 8, 16)
+#define max_rd_time 				DSI_HOST_BITS(0x09c, 15, 0)
+/* new Dependency: DSI_HOST_FPGA = 0. Otherwise, this bit is reserved. */
+#define phy_forcepll 				DSI_HOST_BITS(0x0a0, 1, 3)
+#define phy_enableclk 				DSI_HOST_BITS(0x0a0, 1, 2)
+#define phy_rstz 				DSI_HOST_BITS(0x0a0, 1, 1)
+#define phy_shutdownz 				DSI_HOST_BITS(0x0a0, 1, 0)
+#define phy_stop_wait_time 			DSI_HOST_BITS(0x0a4, 8, 8)
+#define n_lanes					DSI_HOST_BITS(0x0a4, 2, 0)
+#define phy_txexitulpslan 			DSI_HOST_BITS(0x0a8, 1, 3)
+#define phy_txrequlpslan 			DSI_HOST_BITS(0x0a8, 1, 2)
+#define phy_txexitulpsclk 			DSI_HOST_BITS(0x0a8, 1, 1)
+#define phy_txrequlpsclk 			DSI_HOST_BITS(0x0a8, 1, 0)
+#define phy_tx_triggers 			DSI_HOST_BITS(0x0ac, 4, 0)
+
+#define phystopstateclklane			DSI_HOST_BITS(0x0b0, 1, 2)
+#define phylock					DSI_HOST_BITS(0x0b0, 1, 0)
+#define phy_testclk				DSI_HOST_BITS(0x0b4, 1, 1)
+#define phy_testclr				DSI_HOST_BITS(0x0b4, 1, 0)
+#define phy_testen				DSI_HOST_BITS(0x0b8, 1, 16)
+#define phy_testdout				DSI_HOST_BITS(0x0b8, 8, 8)
+#define phy_testdin				DSI_HOST_BITS(0x0b8, 8, 0)
+
+#define PHY_TEST_CTRL1 				DSI_HOST_BITS(0x0b8, 17, 0)
+#define PHY_TEST_CTRL0				DSI_HOST_BITS(0x0b4, 2, 0)
+
+#define INT_ST0 					DSI_HOST_BITS(0x0bc, 21, 0)
+#define INT_ST1 					DSI_HOST_BITS(0x0c0, 18, 0)
+#define INT_MKS0 					DSI_HOST_BITS(0x0c4, 21, 0)
+#define INT_MKS1 					DSI_HOST_BITS(0x0c8, 18, 0)
+#define INT_FORCE0 					DSI_HOST_BITS(0x0d8, 21, 0)
+#define INT_FORCE1 					DSI_HOST_BITS(0x0dc, 18, 0)
+
+#define code_hs_rx_clock		0x34
+#define code_hs_rx_lane0		0x44
+#define code_hs_rx_lane1		0x54
+#define code_hs_rx_lane2		0x84
+#define code_hs_rx_lane3		0x94
+
+#define code_pll_input_div_rat		0x17
+#define code_pll_loop_div_rat		0x18
+#define code_pll_input_loop_div_rat	0x19
+
+#define code_hstxdatalanerequsetstatetime	0x70
+#define code_hstxdatalanepreparestatetime	0x71
+#define code_hstxdatalanehszerostatetime	0x72
+
+/* rk312x MIPI DSI DPHY REGISTERS */
+#define DPHY_REGISTER0				DSI_DPHY_BITS(0x00, 32, 0)
+#define DPHY_REGISTER1				DSI_DPHY_BITS(0x04, 32, 0)
+#define DPHY_REGISTER3				DSI_DPHY_BITS(0x0c, 32, 0)
+#define DPHY_REGISTER4				DSI_DPHY_BITS(0x10, 32, 0)
+#define DPHY_REGISTER20				DSI_DPHY_BITS(0X80, 32, 0)
+
+#define lane_en_ck 				DSI_DPHY_BITS(0x00, 1, 6)
+#define lane_en_3 				DSI_DPHY_BITS(0x00, 1, 5)
+#define lane_en_2 				DSI_DPHY_BITS(0x00, 1, 4)
+#define lane_en_1 				DSI_DPHY_BITS(0x00, 1, 3)
+#define lane_en_0 				DSI_DPHY_BITS(0x00, 1, 2)
+#define reg0_phy 				DSI_DPHY_BITS(0x00, 8, 0)
+
+#define reg_da_ppfc 				DSI_DPHY_BITS(0x04, 1, 4)
+#define reg_da_syncrst 				DSI_DPHY_BITS(0x04, 1, 2)
+#define reg_da_ldopd 				DSI_DPHY_BITS(0x04, 1, 1)
+#define reg_da_pllpd 				DSI_DPHY_BITS(0x04, 1, 0)
+#define reg1_phy 				DSI_DPHY_BITS(0x04, 8, 0)
+#define reg5_phy 				DSI_DPHY_BITS(0x14, 3, 0)
+#define reg5_3_phy 				DSI_DPHY_BITS(0x14, 1, 3)
+#define reg5_7_phy 				DSI_DPHY_BITS(0x14, 1, 7)
+#define reg8_phy				DSI_DPHY_BITS(0x20, 8, 0)
+#define rega_phy				DSI_DPHY_BITS(0x28, 8, 0)
+#define regb_phy				DSI_DPHY_BITS(0X2c, 8, 0)
+
+#define reg_fbdiv_8 				DSI_DPHY_BITS(0x0c, 1, 5)
+#define reg_prediv 				DSI_DPHY_BITS(0x0c, 5, 0)
+#define reg_fbdiv 				DSI_DPHY_BITS(0x10, 8, 0)
+#define reg9_phy 				DSI_DPHY_BITS(0x24, 8, 0)
+#define reg10_phy 				DSI_DPHY_BITS(0X40, 8, 0)
+#define reg10_4_6_phy				DSI_DPHY_BITS(0X40, 3, 4)
+#define regb_0_3_phy				DSI_DPHY_BITS(0X2c, 4, 0)
+
+#define reg_dig_rstn 				DSI_DPHY_BITS(0X80, 1, 0)
+#define reg20_phy 				DSI_DPHY_BITS(0X80, 8, 0)
+
+#define DPHY_CLOCK_OFFSET			REG_ADDR(0X0100)
+#define DPHY_LANE0_OFFSET			REG_ADDR(0X0180)
+#define DPHY_LANE1_OFFSET			REG_ADDR(0X0200)
+#define DPHY_LANE2_OFFSET			REG_ADDR(0X0280)
+#define DPHY_LANE3_OFFSET			REG_ADDR(0X0300)
+
+#define reg_ths_settle				DSI_DPHY_BITS(0x0000, 4, 0)
+#define reg_hs_tlpx				DSI_DPHY_BITS(0x0014, 6, 0)
+#define reg_hs_ths_prepare			DSI_DPHY_BITS(0x0018, 7, 0)
+#define reg_hs_the_zero				DSI_DPHY_BITS(0x001c, 6, 0)
+#define reg_hs_ths_trail			DSI_DPHY_BITS(0x0020, 7, 0)
+#define reg_hs_ths_exit				DSI_DPHY_BITS(0x0024, 5, 0)
+#define reg_hs_tclk_post			DSI_DPHY_BITS(0x0028, 4, 0)
+#define reserved				DSI_DPHY_BITS(0x002c, 1, 0)
+#define reg_hs_twakup_h				DSI_DPHY_BITS(0x0030, 2, 0)
+#define reg_hs_twakup_l				DSI_DPHY_BITS(0x0034, 8, 0)
+#define reg_hs_tclk_pre				DSI_DPHY_BITS(0x0038, 4, 0)
+#define reg_hs_tta_go				DSI_DPHY_BITS(0x0040, 6, 0)
+#define reg_hs_tta_sure				DSI_DPHY_BITS(0x0044, 6, 0)
+#define reg_hs_tta_wait				DSI_DPHY_BITS(0x0048, 6, 0)
+/* end of rk312x MIPI DSI DPHY REGISTERS */
+
+/* global operation timing parameter */
+struct gotp_m {
+	/* time uint is ns */
+	u32 min;
+	u32 value;
+	u32 max;
+};
+
+/*
+ * default time unit is ns
+ * Unit Interval, equal to the duration of any HS state on the Clock Lane
+*/
+struct gotp {
+	u32 CLK_MISS;		/* min:no    max:60 */
+	u32 CLK_POST;		/* min:60 ns + 52*UI    max:no */
+	u32 CLK_PRE;		/* min:8*UI    max:no */
+	u32 CLK_PREPARE;	/* min:38    max:95 */
+	u32 CLK_SETTLE;		/* min:95    max:300 */
+	u32 CLK_TERM_EN;	/* min:Time for Dn to reach VTERM-EN    max:38 */
+	u32 CLK_TRAIL;		/* min:60    max:no */
+	u32 CLK_ZERO;		/* min:300 - CLK_PREPARE    max:no */
+	u32 D_TERM_EN;		/* min:Time for Dn to reach VTERM-EN    max:35 ns + 4*UI */
+	u32 EOT;		/* min:no    max:105 ns + n*12*UI */
+	u32 HS_EXIT;		/* min:100    max:no */
+	u32 HS_PREPARE;		/* min:40 ns + 4*UI     max:85 ns + 6*UI */
+	u32 HS_ZERO;		/* min:145 ns + 10*UI - HS_PREPARE    max:no */
+	u32 HS_SETTLE;		/* min:85 ns + 6*UI     max:145 ns + 10*UI */
+	u32 HS_SKIP;		/* min:40    max:55 ns + 4*UI */
+	u32 HS_TRAIL;		/* min: max( n*8*UI, 60 ns + n*4*UI )    max:no */
+	u32 NIT;		/* min:100us    max:no */
+	u32 LPX;		/* min:50    max:no */
+	u32 TA_GET;		/* min:5*TLPX */
+	u32 TA_GO;		/* min:4*TLPX */
+	u32 TA_SURE;		/* min:TLPX    max:2*TLPX */
+	u32 WAKEUP;		/* min:1ms    max:no */
+};
+
+struct dsi_phy {
+	u32 UI;
+	u32 ref_clk;		/* input_clk */
+	u32 ddr_clk;		/* data bit clk */
+	u32 txbyte_clk;		/* 1/8 of ddr_clk */
+	u32 sys_clk;
+	u32 pclk;
+	u32 txclkesc;
+
+	u32 Tddr_clk;		/* ps */
+	u32 Ttxbyte_clk;	/* ps */
+	u32 Tsys_clk;		/* ps */
+	u32 Tpclk;		/* ps */
+	u32 Ttxclkesc;		/* ps */
+
+	struct clk	*refclk;
+	unsigned long iobase;
+	void __iomem *membase;
+	u16 prediv;
+	u16 fbdiv;
+	u8 flag;
+	struct gotp gotp;
+
+};
+
+struct dsi_host {
+	u8 flag;
+	u8 lane;
+	u8 format;
+	u8 video_mode;
+	u32 clk;
+	u32 irq;
+	unsigned long iobase;
+	void __iomem *membase;
+};
+
+struct dsi {
+	u8 dsi_id;
+	u8 lcdc_id;
+	u8 vid;
+	u8 clk_on;
+	struct regmap *grf_base;
+	struct dsi_phy phy;
+	struct dsi_host host;
+	struct mipi_dsi_ops ops;
+	struct mipi_dsi_screen screen;
+#ifdef CONFIG_MIPI_DSI_LINUX
+	struct clk	*dsi_pclk; /* for mipi phy */
+	struct clk	*dsi_host_pclk; /* for mipi host */
+	struct clk	*h2p_hclk;
+#endif
+	struct dentry *debugfs_dir;
+	struct platform_device *pdev;
+};
+
+int rk_mipi_get_dsi_clk(void);
+int rk_mipi_get_dsi_num(void);
+int rk_mipi_get_dsi_lane(void);
+static int rk32_mipi_power_down_DDR(void);
+static int rk32_mipi_power_up_DDR(void);
+static void rk32_init_phy_mode(int lcdc_id);
+
+
+#endif /* end of RK32_MIPI_DSI_H */
diff -Nupr a/drivers/video/rockchip/transmitter/rk610_lcd.c b/drivers/video/rockchip/transmitter/rk610_lcd.c
--- a/drivers/video/rockchip/transmitter/rk610_lcd.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk610_lcd.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,490 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "rk610_lcd.h"
+#include <linux/mfd/rk610_core.h>
+#include <linux/rk_fb.h>
+#include "../hdmi/rk_hdmi.h"
+
+static struct rk610_lcd_info *g_lcd_inf = NULL;
+//static int rk610_scaler_read_p0_reg(struct i2c_client *client, char reg, char *val)
+//{
+	//return i2c_master_reg8_recv(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
+//}
+
+static int rk610_scaler_write_p0_reg(struct i2c_client *client, char reg, char *val)
+{
+	return i2c_master_reg8_send(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
+}
+static void rk610_scaler_pll_enable(struct i2c_client *client)
+{
+    char c;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+
+    g_lcd_inf->scl_inf.pll_pwr = ENABLE;
+    
+    c = S_PLL_PWR(0)|S_PLL_RESET(0)|S_PLL_BYPASS(0);
+	rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
+}
+static void rk610_scaler_pll_disable(struct i2c_client *client)
+{
+    char c;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    
+    g_lcd_inf->scl_inf.pll_pwr = DISABLE;
+
+    c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
+	rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
+}
+static void rk610_scaler_enable(struct i2c_client *client)
+{
+    char c;
+    bool den_inv = 0,hv_sync_inv = 0,clk_inv = 0;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    g_lcd_inf->scl_inf.scl_pwr = ENABLE;
+    #if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+    if(g_lcd_inf->screen !=NULL){
+        den_inv = g_lcd_inf->screen->s_den_inv;
+        hv_sync_inv = g_lcd_inf->screen->s_hv_sync_inv;
+        clk_inv = g_lcd_inf->screen->s_clk_inv;
+    }
+    #endif
+    c= SCL_BYPASS(0) |SCL_DEN_INV(den_inv) |SCL_H_V_SYNC_INV(hv_sync_inv) |SCL_OUT_CLK_INV(clk_inv) |SCL_ENABLE(ENABLE);  
+	rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
+}
+static void rk610_scaler_disable(struct i2c_client *client)
+{
+    char c;
+    bool den_inv = 0,hv_sync_inv = 0,clk_inv = 0;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    
+    g_lcd_inf->scl_inf.scl_pwr = DISABLE;
+    #if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+    if(g_lcd_inf->screen !=NULL){
+        den_inv = g_lcd_inf->screen->s_den_inv;
+        hv_sync_inv = g_lcd_inf->screen->s_hv_sync_inv;
+        clk_inv = g_lcd_inf->screen->s_clk_inv;
+    }
+    #endif
+    c= SCL_BYPASS(1) |SCL_DEN_INV(den_inv) |SCL_H_V_SYNC_INV(hv_sync_inv) |SCL_OUT_CLK_INV(clk_inv) |SCL_ENABLE(DISABLE); 
+    rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
+}
+
+static int rk610_output_config(struct i2c_client *client,struct rk_screen *screen,int mode)
+{
+    char c=0;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+     if(SCREEN_LVDS == screen->type){
+        if(mode == LCD_OUT_SCL || mode == LCD_OUT_BYPASS){
+		c = LVDS_OUT_CLK_PIN(0) |LVDS_OUT_CLK_PWR_PIN(1) |LVDS_PLL_PWR_PIN(0) \
+		    |LVDS_LANE_IN_FORMAT(DATA_D0_MSB) \
+		    |LVDS_OUTPUT_FORMAT(screen->lvds_format) | LVDS_BIASE_PWR(1); 
+#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL) && defined(CONFIG_HDMI_RK610)
+		c |=  LVDS_INPUT_SOURCE(FROM_LCD1);
+#else
+		c |=  LVDS_INPUT_SOURCE(FROM_LCD0_OR_SCL);
+#endif                
+		rk610_scaler_write_p0_reg(client, LVDS_CON0, &c);
+		c = LCD1_OUT_ENABLE(LCD1_AS_IN);
+		rk610_scaler_write_p0_reg(client, LCD1_CON, &c);
+		c = LVDS_OUT_ENABLE(0x0) |LVDS_TX_PWR_ENABLE(0x0); 
+		rk610_scaler_write_p0_reg(client, LVDS_CON1, &c);
+	    }
+	    else{
+		    c = LVDS_OUT_CLK_PIN(0) |LVDS_OUT_CLK_PWR_PIN(0) |LVDS_PLL_PWR_PIN(1) \
+			|LVDS_LANE_IN_FORMAT(DATA_D0_MSB)  \
+			|LVDS_OUTPUT_FORMAT(screen->lvds_format) | LVDS_BIASE_PWR(0); 
+#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL) && defined(CONFIG_HDMI_RK610)
+		    c |=  LVDS_INPUT_SOURCE(FROM_LCD1);
+#else
+		    c |=  LVDS_INPUT_SOURCE(FROM_LCD0_OR_SCL);
+#endif                
+		    rk610_scaler_write_p0_reg(client, LVDS_CON0, &c);
+		    c = LCD1_OUT_ENABLE(LCD1_AS_IN);
+		    rk610_scaler_write_p0_reg(client, LCD1_CON, &c);
+		    c = LVDS_OUT_ENABLE(0xf) |LVDS_TX_PWR_ENABLE(0xf); 
+		    rk610_scaler_write_p0_reg(client, LVDS_CON1, &c);
+             
+	    }
+	}else if(SCREEN_RGB == screen->type){
+	    if(mode == LCD_OUT_SCL || mode == LCD_OUT_BYPASS){
+            c = LCD1_OUT_ENABLE(LCD1_AS_OUT) | LCD1_OUT_SRC((mode == LCD_OUT_SCL)?LCD1_FROM_SCL : LCD1_FROM_LCD0);
+	        rk610_scaler_write_p0_reg(client, LCD1_CON, &c);
+	    }
+	    else {
+            c = LCD1_OUT_ENABLE(LCD1_AS_IN);
+	        rk610_scaler_write_p0_reg(client, LCD1_CON, &c);
+	    }
+	}
+	return 0;
+}
+#if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+static int rk610_scaler_pll_set(struct i2c_client *client,struct rk_screen *screen,u32 clkin )
+{
+    char c=0;
+    char M=0,N=0,OD=0;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+	/***************SET SCALER PLL FROM CLKIN ,DIV 0*/
+    if(screen->s_pixclock != 0){
+        OD = (screen->s_pixclock)&0x3;
+        N = (screen->s_pixclock >>4)&0xf;
+        M = (screen->s_pixclock >>8)&0xff;
+    }else {
+        RK610_ERR(&client->dev,"RK610 Scaler pll not support rate \n");
+    }
+    c = S_PLL_FROM_DIV<<3 | S_PLL_DIV(0);
+	rk610_scaler_write_p0_reg(client, CLOCK_CON0, &c);
+    
+    c = S_DIV_N(N)| S_DIV_OD(OD);
+	rk610_scaler_write_p0_reg(client, S_PLL_CON0, &c);
+    c = S_DIV_M(M);
+    rk610_scaler_write_p0_reg(client, S_PLL_CON1, &c);
+    rk610_scaler_pll_enable(client);
+	return 0;
+}
+
+
+static int  scale_hv_factor(struct i2c_client *client ,u32 Hin_act, u32 Hout_act, u32 Vin_act, u32 Vout_act)
+   {
+    char c;
+  	u32 hfactor_f,vfactor_f,scl_factor_f;
+	int  hfactor;
+	int  vfactor;
+	struct scl_hv_info  HV2;
+	hfactor_f = ((Hin_act-1)*4096)/(Hout_act-1);
+    if(hfactor_f==4096)
+	    {hfactor = 0x1000;}
+ 	else if(hfactor_f>(int)hfactor_f)
+	  	{hfactor = (int)hfactor_f+1;}
+	else
+	  	{hfactor = (int)hfactor_f;}
+	  
+	scl_factor_f = Vin_act/Vout_act;
+	if(scl_factor_f<2)
+	    {vfactor_f = ((Vin_act-1)*4096)/(Vout_act-1);}
+	else
+	  	{vfactor_f = ((Vin_act-2)*4096)/(Vout_act-1);} 
+	if(vfactor_f==4096)
+	    {vfactor = 0x1000;}
+	else if(vfactor_f>(int)vfactor_f)
+	  	{vfactor = (int)vfactor_f+1;}
+	else
+	  	{vfactor = (int)vfactor_f;}
+	  
+    HV2.scl_h= hfactor;
+    HV2.scl_v= vfactor; 
+           /*       SCL FACTOR          */
+    c = SCL_H_FACTOR_LSB(HV2.scl_h);
+	rk610_scaler_write_p0_reg(client, SCL_CON1, &c);
+    c = SCL_H_FACTOR_MSB(HV2.scl_h);
+	rk610_scaler_write_p0_reg(client, SCL_CON2, &c);
+
+    c = SCL_V_FACTOR_LSB(HV2.scl_v);
+	rk610_scaler_write_p0_reg(client, SCL_CON3, &c);
+    c = SCL_V_FACTOR_MSB(HV2.scl_v);
+	rk610_scaler_write_p0_reg(client, SCL_CON4, &c);
+  	return 0;
+   }
+
+static int rk610_scaler_fator_config(struct i2c_client *client ,struct rk_screen *screen)
+{
+    switch(screen->hdmi_resolution){
+        case HDMI_1920x1080p_60Hz:
+        case HDMI_1920x1080p_50Hz:
+            rk610_scaler_pll_set(client,screen,148500000);
+            /***************set scaler factor********************/
+            scale_hv_factor(client,1920,screen->x_res,1080,screen->y_res);
+            break;
+        case HDMI_1280x720p_60Hz:
+        case HDMI_1280x720p_50Hz:
+            rk610_scaler_pll_set(client,screen,74250000);
+            /***************set scaler factor********************/
+            scale_hv_factor(client,1280,screen->x_res,720,screen->y_res);
+        break;
+        case HDMI_720x576p_50Hz_16_9:
+        case HDMI_720x576p_50Hz_4_3:
+            rk610_scaler_pll_set(client,screen,27000000);
+            /***************set scaler factor********************/
+            scale_hv_factor(client,720,screen->x_res,576,screen->y_res);
+            break;
+        case HDMI_720x480p_60Hz_16_9:
+        case HDMI_720x480p_60Hz_4_3:
+            rk610_scaler_pll_set(client,screen,27000000);
+            /***************set scaler factor********************/
+            scale_hv_factor(client,720,screen->x_res,480,screen->y_res);
+        break;
+    default :
+        RK610_ERR(&client->dev,"RK610 not support dual display at hdmi resolution=%d \n",screen->hdmi_resolution); 
+        return -1;
+        break;
+    }
+    return 0;
+}
+static int rk610_scaler_output_timing_config(struct i2c_client *client,struct rk_screen *screen)
+{
+    char c;
+    int h_st = screen->s_hsync_st;
+    int hs_end = screen->s_hsync_len;
+    int h_act_st = hs_end + screen->s_left_margin;
+    int xres = screen->x_res;
+    int h_act_end = h_act_st + xres;
+    int h_total = h_act_end + screen->s_right_margin;
+    int v_st = screen->s_vsync_st;
+    int vs_end = screen->s_vsync_len;
+    int v_act_st = vs_end + screen->s_upper_margin;
+    int yres = screen->y_res;    
+    int v_act_end = v_act_st + yres;
+    int v_total = v_act_end + screen->s_lower_margin;
+
+    /*      SCL display Frame start point   */
+    c = SCL_DSP_HST_LSB(h_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON5, &c);
+    c = SCL_DSP_HST_MSB(h_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON6, &c);
+
+    c = SCL_DSP_VST_LSB(v_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON7, &c);
+    c = SCL_DSP_VST_MSB(v_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON8, &c);
+    /*      SCL output timing       */
+
+    c = SCL_DSP_HTOTAL_LSB(h_total);
+	rk610_scaler_write_p0_reg(client, SCL_CON9, &c);
+    c = SCL_DSP_HTOTAL_MSB(h_total);
+	rk610_scaler_write_p0_reg(client, SCL_CON10, &c);
+
+    c = SCL_DSP_HS_END(hs_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON11, &c);
+
+    c = SCL_DSP_HACT_ST_LSB(h_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON12, &c);
+    c = SCL_DSP_HACT_ST_MSB(h_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON13, &c);
+
+    c = SCL_DSP_HACT_END_LSB(h_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON14, &c);
+    c = SCL_DSP_HACT_END_MSB(h_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON15, &c);
+
+    c = SCL_DSP_VTOTAL_LSB(v_total);
+	rk610_scaler_write_p0_reg(client, SCL_CON16, &c);
+    c = SCL_DSP_VTOTAL_MSB(v_total);
+	rk610_scaler_write_p0_reg(client, SCL_CON17, &c);
+
+    c = SCL_DSP_VS_END(vs_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON18, &c);
+
+    c = SCL_DSP_VACT_ST(v_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON19, &c);
+
+    c = SCL_DSP_VACT_END_LSB(v_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON20, &c);
+    c = SCL_DSP_VACT_END_MSB(v_act_end); 
+	rk610_scaler_write_p0_reg(client, SCL_CON21, &c);
+ 
+    c = SCL_H_BORD_ST_LSB(h_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON22, &c);
+    c = SCL_H_BORD_ST_MSB(h_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON23, &c);
+
+    c = SCL_H_BORD_END_LSB(h_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON24, &c);
+    c = SCL_H_BORD_END_MSB(h_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON25, &c);
+
+    c = SCL_V_BORD_ST(v_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON26, &c);
+
+    c = SCL_V_BORD_END_LSB(v_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON27, &c);
+    c = SCL_V_BORD_END_MSB(v_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON28, &c);
+	
+	return 0;
+}
+static int rk610_scaler_chg(struct i2c_client *client ,struct rk_screen *screen)
+{
+
+    RK610_DBG(&client->dev,"%s screen->hdmi_resolution=%d\n",__FUNCTION__,screen->hdmi_resolution);
+    rk610_scaler_fator_config(client,screen);
+    rk610_scaler_enable(client);
+    rk610_scaler_output_timing_config(client,screen); 
+    
+    return 0;
+
+}
+#endif
+static int rk610_lcd_scaler_bypass(struct i2c_client *client,bool enable)//enable:0 bypass 1: scale
+{
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    
+    rk610_scaler_disable(client);       
+    rk610_scaler_pll_disable(client);
+    
+    return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void rk610_lcd_early_suspend(struct early_suspend *h)
+{
+    struct i2c_client *client = g_lcd_inf->client;
+    char c;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    if(g_lcd_inf->screen != NULL){
+        rk610_output_config(client,g_lcd_inf->screen,LCD_OUT_DISABLE);
+    }
+
+    if(ENABLE == g_lcd_inf->scl_inf.scl_pwr){
+        c= SCL_BYPASS(1) |SCL_DEN_INV(0) |SCL_H_V_SYNC_INV(0) |SCL_OUT_CLK_INV(0) |SCL_ENABLE(DISABLE); 
+        rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
+    }
+    if(ENABLE == g_lcd_inf->scl_inf.pll_pwr ){
+        c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
+	    rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
+    }
+}
+
+static void rk610_lcd_early_resume(struct early_suspend *h)
+{
+    struct i2c_client *client = g_lcd_inf->client;
+    char c;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+
+    if(g_lcd_inf->screen != NULL){
+        rk610_output_config(client,g_lcd_inf->screen,g_lcd_inf->disp_mode);
+    }
+    if(ENABLE == g_lcd_inf->scl_inf.scl_pwr){
+        c= SCL_BYPASS(0) |SCL_DEN_INV(0) |SCL_H_V_SYNC_INV(0) |SCL_OUT_CLK_INV(0) |SCL_ENABLE(ENABLE);  
+	    rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
+    }
+    if(ENABLE == g_lcd_inf->scl_inf.pll_pwr ){
+        c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
+	    rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
+    }
+}
+#endif
+int rk610_lcd_scaler_set_param(struct rk_screen *screen,bool enable )//enable:0 bypass 1: scale
+{
+    int ret=0;
+    struct i2c_client *client = g_lcd_inf->client;
+    if(client == NULL){
+        printk("%s client == NULL FAIL\n",__FUNCTION__);
+        return -1;
+    }
+    if(screen == NULL){
+        printk("%s screen == NULL FAIL\n",__FUNCTION__);
+        return -1;
+    }
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    
+    g_lcd_inf->screen = screen;
+    
+#if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+    if(enable == 1){
+        g_lcd_inf->disp_mode = LCD_OUT_SCL;
+        rk610_output_config(client,screen,LCD_OUT_SCL);
+        ret = rk610_scaler_chg(client,screen);
+	}
+	else 
+#endif
+	{
+	    g_lcd_inf->disp_mode = LCD_OUT_BYPASS;
+	    rk610_output_config(client,screen,LCD_OUT_BYPASS);
+	    ret = rk610_lcd_scaler_bypass(client,enable);
+	}
+	return ret;
+}
+int rk610_lcd_init(struct rk610_core_info *rk610_core_info)
+{
+    if(rk610_core_info->client == NULL){
+        printk("%s client == NULL FAIL\n",__FUNCTION__);
+        return -1;
+    }
+    RK610_DBG(&rk610_core_info->client->dev,"%s \n",__FUNCTION__);
+
+    g_lcd_inf = kmalloc(sizeof(struct rk610_lcd_info), GFP_KERNEL);
+    if(!g_lcd_inf)
+    {
+        dev_err(&rk610_core_info->client->dev, ">> rk610 inf kmalloc fail!");
+        return -ENOMEM;
+    }
+    memset(g_lcd_inf, 0, sizeof(struct rk610_lcd_info));
+
+    g_lcd_inf->client= rk610_core_info->client;
+    
+    rk610_core_info->lcd_pdata = (void *)g_lcd_inf;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	g_lcd_inf->early_suspend.suspend = rk610_lcd_early_suspend;
+	g_lcd_inf->early_suspend.resume = rk610_lcd_early_resume;
+	g_lcd_inf->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB- 1;
+	register_early_suspend(&g_lcd_inf->early_suspend);
+#endif
+    g_lcd_inf->scl_inf.pll_pwr = DISABLE;
+    g_lcd_inf->scl_inf.scl_pwr = DISABLE;
+    g_lcd_inf->disp_mode = LCD_OUT_BYPASS;
+    return 0;
+}
+
+static int rk610_lcd_probe(struct platform_device *pdev)
+{
+	struct rk610_core_info *core_info = NULL;
+	rk_screen *screen = NULL;
+
+	core_info = dev_get_drvdata(pdev->dev.parent);
+	if(!core_info)
+	{
+		dev_err(&pdev->dev,"rk610 core info is null\n");
+		return -ENODEV;
+	}
+	screen = rk_fb_get_prmry_screen();
+	if(!screen)
+	{
+		dev_err(&pdev->dev,"the fb prmry screen is null!\n");
+		return -ENODEV;
+	}
+	
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+	screen->sscreen_set = rk610_lcd_scaler_set_param;
+#endif
+ 	rk610_lcd_init(core_info);
+	rk610_lcd_scaler_set_param(screen,0);
+
+	return 0;
+	
+}
+static int rk610_lcd_remove(struct platform_device *pdev)
+{
+	
+	return 0;
+}
+
+static void rk610_lcd_shutdown(struct platform_device *pdev)
+{
+	
+	return;
+}
+
+static struct platform_driver rk610_lcd_driver = {
+	.driver		= {
+		.name	= "rk610-lcd",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= rk610_lcd_probe,
+	.remove		= rk610_lcd_remove,
+	.shutdown	= rk610_lcd_shutdown,
+};
+
+static int __init rk610_lcd_module_init(void)
+{
+	return platform_driver_register(&rk610_lcd_driver);
+}
+fs_initcall(rk610_lcd_module_init);
+static void __exit rk610_lcd_exit(void)
+{
+	platform_driver_unregister(&rk610_lcd_driver);
+}
+module_exit(rk610_lcd_exit);
+
diff -Nupr a/drivers/video/rockchip/transmitter/rk610_lcd.h b/drivers/video/rockchip/transmitter/rk610_lcd.h
--- a/drivers/video/rockchip/transmitter/rk610_lcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk610_lcd.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,231 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RK610_LCD_H
+#define _RK610_LCD_H
+#include <linux/mfd/rk610_core.h>
+#include <linux/earlysuspend.h>
+#define ENABLE      1
+#define DISABLE     0
+
+//LVDS lane input format
+#define DATA_D0_MSB         0
+#define DATA_D7_MSB         1
+//LVDS input source
+#define FROM_LCD1           0
+#define FROM_LCD0_OR_SCL    1
+
+/*      LCD1 config         */
+#define LCD1_AS_IN      0
+#define LCD1_AS_OUT     1
+
+//LCD1 output source
+#define LCD1_FROM_LCD0  0
+#define LCD1_FROM_SCL   1
+
+//SCALER config
+#define NOBYPASS    0
+#define BYPASS      1
+
+//SCALER PLL config
+#define S_PLL_PWR_ON    0
+#define S_PLL_PWR_DOWN  1
+
+/*      clock config        */
+#define S_PLL_FROM_DIV      0
+#define S_PLL_FROM_CLKIN    1
+#define S_PLL_DIV(x)        ((x)&0x7)
+/*********S_PLL_CON************/
+//S_PLL_CON0
+#define S_DIV_N(x)              (((x)&0xf)<<4)
+#define S_DIV_OD(x)             (((x)&3)<<0)
+//S_PLL_CON1
+#define S_DIV_M(x)              ((x)&0xff)
+//S_PLL_CON2
+#define S_PLL_UNLOCK            (0<<7)    //0:unlock 1:pll_lock
+#define S_PLL_LOCK              (1<<7)    //0:unlock 1:pll_lock
+#define S_PLL_PWR(x)            (((x)&1)<<2)    //0:POWER UP 1:POWER DOWN
+#define S_PLL_RESET(x)          (((x)&1)<<1)    //0:normal  1:reset M/N dividers
+#define S_PLL_BYPASS(x)          (((x)&1)<<0)    //0:normal  1:bypass
+//LVDS_CON0
+#define LVDS_OUT_CLK_PIN(x)     (((x)&1)<<7)    //clk enable pin, 0: enable
+#define LVDS_OUT_CLK_PWR_PIN(x) (((x)&1)<<6)    //clk pwr enable pin, 1: enable 
+#define LVDS_PLL_PWR_PIN(x)     (((x)&1)<<5)    //pll pwr enable pin, 0:enable 
+#define LVDS_BIASE_PWR(x)       (((x)&1)<<4)    //0: power down     1: normal work
+#define LVDS_LANE_IN_FORMAT(x)  (((x)&1)<<3)    //0: msb on D0  1:msb on D7
+#define LVDS_INPUT_SOURCE(x)    (((x)&1)<<2)    //0: from lcd1  1:from lcd0 or scaler
+#define LVDS_OUTPUT_FORMAT(x)   (((x)&3)<<0)    //00:8bit format-1  01:8bit format-2  10:8bit format-3   11:6bit format  
+//LVDS_CON1
+#define LVDS_OUT_ENABLE(x)      (((x)&0xf)<<4)  //0:output enable 1:output disable
+#define LVDS_TX_PWR_ENABLE(x)   (((x)&0xf)<<0)  //0:working mode  1:power down
+//LCD1_CON
+#define LCD1_OUT_ENABLE(x)      (((x)&1)<<1)    //0:lcd1 as input 1:lcd1 as output
+#define LCD1_OUT_SRC(x)         (((x)&1)<<0)    //0:from lcd0   1:from scaler
+//SCL_CON0
+#define SCL_BYPASS(x)           (((x)&1)<<4)    //0:not bypass  1:bypass
+#define SCL_DEN_INV(x)          (((x)&1)<<3)    //scl_den_inv
+#define SCL_H_V_SYNC_INV(x)     (((x)&1)<<2)    //scl_sync_inv
+#define SCL_OUT_CLK_INV(x)      (((x)&1)<<1)    //scl_dclk_inv
+#define SCL_ENABLE(x)           (((x)&1)<<0)    //scaler enable
+//SCL_CON1
+#define SCL_H_FACTOR_LSB(x)     ((x)&0xff)      //scl_h_factor[7:0]
+//SCL_CON2
+#define SCL_H_FACTOR_MSB(x)     (((x)>>8)&0x3f)      //scl_h_factor[13:8]
+//SCL_CON3
+#define SCL_V_FACTOR_LSB(x)     ((x)&0xff)      //scl_v_factor[7:0]
+//SCL_CON4
+#define SCL_V_FACTOR_MSB(x)     (((x)>>8)&0x3f)      //scl_v_factor[13:8]
+//SCL_CON5
+#define SCL_DSP_HST_LSB(x)      ((x)&0xff)      //dsp_frame_hst[7:0]
+//SCL_CON6
+#define SCL_DSP_HST_MSB(x)      (((x)>>8)&0xf)       //dsp_frame_hst[11:8]
+//SCL_CON7
+#define SCL_DSP_VST_LSB(x)      ((x)&0xff)      //dsp_frame_vst[7:0]
+//SCL_CON8
+#define SCL_DSP_VST_MSB(x)      (((x)>>8)&0xf)       //dsp_frame_vst[11:8]
+//SCL_CON9
+#define SCL_DSP_HTOTAL_LSB(x)   ((x)&0xff)      //dsp_frame_htotal[7:0]
+//SCL_CON10
+#define SCL_DSP_HTOTAL_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_htotal[11:8]
+//SCL_CON11
+#define SCL_DSP_HS_END(x)       ((x)&0xff)      //dsp_hs_end
+//SCL_CON12
+#define SCL_DSP_HACT_ST_LSB(x)      ((x)&0xff)      //dsp_hact_st[7:0]
+//SCL_CON13
+#define SCL_DSP_HACT_ST_MSB(x)      (((x)>>8)&0x3)      //dsp_hact_st[9:8]
+//SCL_CON14
+#define SCL_DSP_HACT_END_LSB(x)   ((x)&0xff)      //dsp_hact_end[7:0]
+//SCL_CON15
+#define SCL_DSP_HACT_END_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_htotal[11:8]
+//SCL_CON16
+#define SCL_DSP_VTOTAL_LSB(x)   ((x)&0xff)      //dsp_frame_vtotal[7:0]
+//SCL_CON17
+#define SCL_DSP_VTOTAL_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_vtotal[11:8]
+//SCL_CON18
+#define SCL_DSP_VS_END(x)       ((x)&0xff)      //dsp_vs_end
+//SCL_CON19
+#define SCL_DSP_VACT_ST(x)      ((x)&0xff)      //dsp_vact_st[7:0]
+//SCL_CON20
+#define SCL_DSP_VACT_END_LSB(x)   ((x)&0xff)      //dsp_vact_end[7:0]
+//SCL_CON21
+#define SCL_DSP_VACT_END_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_vtotal[11:8]
+//SCL_CON22
+#define SCL_H_BORD_ST_LSB(x)        ((x)&0xff)      //dsp_hbord_st[7:0]
+//SCL_CON23
+#define SCL_H_BORD_ST_MSB(x)        (((x)>>8)&0x3)      //dsp_hbord_st[9:8]
+//SCL_CON24
+#define SCL_H_BORD_END_LSB(x)        ((x)&0xff)      //dsp_hbord_end[7:0]
+//SCL_CON25
+#define SCL_H_BORD_END_MSB(x)        (((x)>>8)&0xf)      //dsp_hbord_end[11:8]
+//SCL_CON26
+#define SCL_V_BORD_ST(x)            ((x)&0xff)      //dsp_vbord_st[7:0]
+//SCL_CON27
+#define SCL_V_BORD_END_LSB(x)              ((x)&0xff)      //dsp_vbord_end[7:0]
+//SCL_CON25
+#define SCL_V_BORD_END_MSB(x)        (((x)>>8)&0xf)      //dsp_vbord_end[11:8]
+
+/* Scaler PLL CONFIG */
+#define S_PLL_NO_1	0
+#define S_PLL_NO_2	1
+#define S_PLL_NO_4	2
+#define S_PLL_NO_8	3
+#define S_PLL_M(x)  (((x)&0xff)<<8)
+#define S_PLL_N(x)  (((x)&0xf)<<4)
+#define S_PLL_NO(x) ((S_PLL_NO_##x)&0x3)
+
+enum{
+    HDMI_RATE_148500000,
+    HDMI_RATE_74250000,
+    HDMI_RATE_27000000,
+};
+/*     Scaler   clk setting */
+#define SCALE_PLL(_parent_rate,_rate,_m,_n,_no) \
+        HDMI_RATE_ ## _parent_rate ##_S_RATE_ ## _rate \
+        =  S_PLL_M(_m) | S_PLL_N(_n) | S_PLL_NO(_no)    
+#define SCALE_RATE(_parent_rate , _rate) \
+        (HDMI_RATE_ ## _parent_rate ## _S_RATE_ ## _rate)
+        
+enum{
+    SCALE_PLL(148500000,    66000000,   16, 9,  4),
+    SCALE_PLL(148500000,    57375000,   17, 11, 4),
+    SCALE_PLL(148500000,    54000000,   16, 11, 4),    
+    SCALE_PLL(148500000,    33000000,   16, 9,  8),
+    SCALE_PLL(148500000,    30375000,   18, 11, 8),
+    SCALE_PLL(148500000,    29700000,   16, 10, 8),
+    SCALE_PLL(148500000,    25312500,   15, 11, 8),
+    SCALE_PLL(148500000,    74250000,   12, 6, 4),
+    SCALE_PLL(148500000,    50625000,   15, 11, 4),
+     SCALE_PLL(148500000,    79199997,   32, 15,  4),
+    SCALE_PLL(148500000,    45375000,   22, 9, 8),
+
+    SCALE_PLL(74250000,     66000000,   32, 9,  4),
+    SCALE_PLL(74250000,     57375000,   34, 11, 4),
+    SCALE_PLL(74250000,     54000000,   32, 11, 4),
+    SCALE_PLL(74250000,     33000000,   32, 9,  8),
+    SCALE_PLL(74250000,     30375000,   36, 11, 8),
+    SCALE_PLL(74250000,     25312500,   30, 11, 8),
+    SCALE_PLL(74250000,     74250000,   12, 3, 4),
+    SCALE_PLL(74250000,    67500000,   40, 11, 4),
+    SCALE_PLL(74250000,    50625000,   30, 11, 4),
+    SCALE_PLL(74250000,     79199997,   64,15,4),
+    SCALE_PLL(74250000,    44343750,   43, 9, 8),
+
+    SCALE_PLL(27000000,     75000000,   100, 9,  4),
+    SCALE_PLL(27000000,     72000000,   32, 3,  4),
+    SCALE_PLL(27000000,     63281250,   75, 4,  8),
+	SCALE_PLL(27000000,     60000000,   80, 9,  4),
+    SCALE_PLL(27000000,     54375000,   145, 9,  8),
+    SCALE_PLL(27000000,     31500000,   28, 3,  8),
+    SCALE_PLL(27000000,     30000000,   80, 9,  8),
+    SCALE_PLL(27000000,     70312500,   125, 6,  8),
+    SCALE_PLL(27000000,     46875000,   125, 9,  8),
+    SCALE_PLL(27000000,     56250000,   25, 3,  4)
+};
+
+enum {
+    LCD_OUT_SCL,
+    LCD_OUT_BYPASS,
+    LCD_OUT_DISABLE,
+};
+struct rk610_pll_info{
+    u32 parent_rate;
+    u32 rate;
+    int m;
+    int n;
+    int od;
+};
+struct lcd_mode_inf{
+	int h_pw;
+	int h_bp;
+	int h_vd;
+	int h_fp;
+	int v_pw;
+	int v_bp;
+	int v_vd;
+	int v_fp;
+	int f_hst;
+	int f_vst;
+    struct rk610_pll_info pllclk;
+};
+struct scl_hv_info{
+    int scl_h ;
+    int scl_v;
+    };
+
+struct scl_info{
+    bool pll_pwr;
+    bool scl_pwr;
+    struct scl_hv_info scl_hv;
+};
+struct rk610_lcd_info{
+    int disp_mode;
+    
+    struct rk_screen *screen;
+    struct scl_info scl_inf;
+    struct i2c_client *client;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend		early_suspend;
+#endif
+};
+extern int rk610_lcd_init(struct rk610_core_info *rk610_core_info);
+extern int rk610_lcd_scaler_set_param(struct rk_screen *screen,bool enable );
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/rk616_lvds.c b/drivers/video/rockchip/transmitter/rk616_lvds.c
--- a/drivers/video/rockchip/transmitter/rk616_lvds.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk616_lvds.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,221 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include "rk616_lvds.h"
+
+
+struct rk616_lvds *g_lvds;
+
+
+static int rk616_lvds_cfg(struct mfd_rk616 *rk616,rk_screen *screen)
+{
+	struct rk616_route *route = &rk616->route;
+	u32 val = 0;
+	int ret;
+	int odd = (screen->left_margin&0x01)?0:1;
+	
+	if(!route->lvds_en)  //lvds port is not used ,power down lvds
+	{
+		val &= ~(LVDS_CH1TTL_EN | LVDS_CH0TTL_EN | LVDS_CH1_PWR_EN |
+			LVDS_CH0_PWR_EN | LVDS_CBG_PWR_EN);
+		val |= LVDS_PLL_PWR_DN | (LVDS_CH1TTL_EN << 16) | (LVDS_CH0TTL_EN << 16) |
+			(LVDS_CH1_PWR_EN << 16) | (LVDS_CH0_PWR_EN << 16) |
+			(LVDS_CBG_PWR_EN << 16) | (LVDS_PLL_PWR_DN << 16);
+		ret = rk616->write_dev(rk616,CRU_LVDS_CON0,&val);
+
+		if(!route->lcd1_input)  //set lcd1 port for output as RGB interface
+		{
+			val = (LCD1_INPUT_EN << 16);
+			ret = rk616->write_dev(rk616,CRU_IO_CON0,&val);
+		}
+	}
+	else
+	{
+		if(route->lvds_mode)  //lvds mode
+		{
+
+			if(route->lvds_ch_nr == 2) //dual lvds channel
+			{
+				val = 0;
+				val &= ~(LVDS_CH0TTL_EN | LVDS_CH1TTL_EN | LVDS_PLL_PWR_DN);
+				val = (LVDS_DCLK_INV)|(LVDS_CH1_PWR_EN) |(LVDS_CH0_PWR_EN) | LVDS_HBP_ODD(odd) |
+					(LVDS_CBG_PWR_EN) | (LVDS_CH_SEL) | (LVDS_OUT_FORMAT(screen->lvds_format)) | 
+					(LVDS_CH0TTL_EN << 16) | (LVDS_CH1TTL_EN << 16) |(LVDS_CH1_PWR_EN << 16) | 
+					(LVDS_CH0_PWR_EN << 16) | (LVDS_CBG_PWR_EN << 16) | (LVDS_CH_SEL << 16) | 
+					(LVDS_OUT_FORMAT_MASK) | (LVDS_DCLK_INV << 16) | (LVDS_PLL_PWR_DN << 16) |
+					(LVDS_HBP_ODD_MASK);
+				ret = rk616->write_dev(rk616,CRU_LVDS_CON0,&val);
+				
+				rk616_dbg(rk616->dev,"rk616 use dual lvds channel.......\n");
+			}
+			else //single lvds channel
+			{
+				val = 0;
+				val &= ~(LVDS_CH0TTL_EN | LVDS_CH1TTL_EN | LVDS_CH1_PWR_EN | LVDS_PLL_PWR_DN | LVDS_CH_SEL); //use channel 0
+				val |= (LVDS_CH0_PWR_EN) |(LVDS_CBG_PWR_EN) | (LVDS_OUT_FORMAT(screen->lvds_format)) | 
+				      (LVDS_CH0TTL_EN << 16) | (LVDS_CH1TTL_EN << 16) |(LVDS_CH0_PWR_EN << 16) | 
+				       (LVDS_DCLK_INV ) | (LVDS_CH0TTL_EN << 16) | (LVDS_CH1TTL_EN << 16) |(LVDS_CH0_PWR_EN << 16) | 
+				        (LVDS_CBG_PWR_EN << 16)|(LVDS_CH_SEL << 16) | (LVDS_PLL_PWR_DN << 16)| 
+				       (LVDS_OUT_FORMAT_MASK) | (LVDS_DCLK_INV << 16);
+				ret = rk616->write_dev(rk616,CRU_LVDS_CON0,&val);
+
+				rk616_dbg(rk616->dev,"rk616 use single lvds channel.......\n");
+			}
+
+		}
+		else //mux lvds port to RGB mode
+		{
+			val &= ~(LVDS_CBG_PWR_EN| LVDS_CH1_PWR_EN | LVDS_CH0_PWR_EN);
+			val |= (LVDS_CH0TTL_EN)|(LVDS_CH1TTL_EN )|(LVDS_PLL_PWR_DN)|
+				(LVDS_CH0TTL_EN<< 16)|(LVDS_CH1TTL_EN<< 16)|(LVDS_CH1_PWR_EN << 16) | 
+				(LVDS_CH0_PWR_EN << 16)|(LVDS_CBG_PWR_EN << 16)|(LVDS_PLL_PWR_DN << 16);
+			ret = rk616->write_dev(rk616,CRU_LVDS_CON0,&val);
+
+			val &= ~(LVDS_OUT_EN);
+			val |= (LVDS_OUT_EN << 16);
+			ret = rk616->write_dev(rk616,CRU_IO_CON0,&val);
+			rk616_dbg(rk616->dev,"rk616 use RGB output.....\n");
+			
+		}
+	}
+
+	return 0;
+	
+}
+
+
+int rk616_scaler_set_param(rk_screen *screen,bool enable )//enable:0 bypass 1: scale
+{
+	int ret;
+	struct mfd_rk616 *rk616 = g_lvds->rk616;
+	if(!rk616)
+	{
+		printk(KERN_ERR "%s:mfd rk616 is null!\n",__func__);
+		return -1;
+	}
+	ret = rk616_display_router_cfg(rk616,screen,enable);
+	ret = rk616_lvds_cfg(rk616,screen);
+	return ret;
+}
+
+
+static int rk616_lvds_init_cfg(struct mfd_rk616 *rk616,rk_screen *screen)
+{
+	int ret ;
+	ret = rk616_display_router_cfg(rk616,screen,0);
+	ret = rk616_lvds_cfg(rk616,screen);
+	return ret;
+}
+
+#if	defined(CONFIG_HAS_EARLYSUSPEND)
+static void rk616_lvds_early_suspend(struct early_suspend *h)
+{
+	struct rk616_lvds *lvds = container_of(h, struct rk616_lvds,early_suspend);
+	struct mfd_rk616 *rk616 = lvds->rk616;
+	u32 val = 0;
+	int ret = 0;
+
+	val &= ~(LVDS_CH1_PWR_EN | LVDS_CH0_PWR_EN | LVDS_CBG_PWR_EN);
+	val |= LVDS_PLL_PWR_DN |(LVDS_CH1_PWR_EN << 16) | (LVDS_CH0_PWR_EN << 16) |
+		(LVDS_CBG_PWR_EN << 16) | (LVDS_PLL_PWR_DN << 16);
+	ret = rk616->write_dev(rk616,CRU_LVDS_CON0,&val);
+
+	val = LCD1_INPUT_EN | (LCD1_INPUT_EN << 16);
+	ret = rk616->write_dev(rk616,CRU_IO_CON0,&val);
+	
+	
+}
+
+static void rk616_lvds_late_resume(struct early_suspend *h)
+{
+	struct rk616_lvds *lvds = container_of(h, struct rk616_lvds,early_suspend);
+	struct mfd_rk616 *rk616 = lvds->rk616;
+	rk616->resume = 1;
+	rk616_lvds_init_cfg(rk616,lvds->screen);	
+	rk616->resume = 0;
+}
+
+#endif
+
+static int rk616_lvds_probe(struct platform_device *pdev)
+{
+	struct rk616_lvds *lvds = NULL; 
+	struct mfd_rk616 *rk616 = NULL;
+	rk_screen *screen = NULL;
+	lvds = kzalloc(sizeof(struct rk616_lvds),GFP_KERNEL);
+	if(!lvds)
+	{
+		printk(KERN_ALERT "alloc for struct rk616_lvds fail\n");
+		return  -ENOMEM;
+	}
+
+	rk616 = dev_get_drvdata(pdev->dev.parent);
+	if(!rk616)
+	{
+		dev_err(&pdev->dev,"null mfd device rk616!\n");
+		return -ENODEV;
+	}
+	else
+		g_lvds = lvds;
+	lvds->rk616 = rk616;
+	
+	screen = rk_fb_get_prmry_screen();
+	if(!screen)
+	{
+		dev_err(&pdev->dev,"the fb prmry screen is null!\n");
+		return -ENODEV;
+	}
+	lvds->screen = screen;
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+	screen->sscreen_set = rk616_scaler_set_param;
+#endif
+ 	rk616_lvds_init_cfg(rk616,screen);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	lvds->early_suspend.suspend = rk616_lvds_early_suspend;
+	lvds->early_suspend.resume = rk616_lvds_late_resume;
+    	lvds->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 1;
+	register_early_suspend(&lvds->early_suspend);
+#endif
+	
+
+	dev_info(&pdev->dev,"rk616 lvds probe success!\n");
+
+	return 0;
+	
+}
+
+static int rk616_lvds_remove(struct platform_device *pdev)
+{
+	
+	return 0;
+}
+
+static void rk616_lvds_shutdown(struct platform_device *pdev)
+{
+	
+	return;
+}
+
+static struct platform_driver rk616_lvds_driver = {
+	.driver		= {
+		.name	= "rk616-lvds",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= rk616_lvds_probe,
+	.remove		= rk616_lvds_remove,
+	.shutdown	= rk616_lvds_shutdown,
+};
+
+static int __init rk616_lvds_init(void)
+{
+	return platform_driver_register(&rk616_lvds_driver);
+}
+fs_initcall(rk616_lvds_init);
+static void __exit rk616_lvds_exit(void)
+{
+	platform_driver_unregister(&rk616_lvds_driver);
+}
+module_exit(rk616_lvds_exit);
+
diff -Nupr a/drivers/video/rockchip/transmitter/rk616_lvds.h b/drivers/video/rockchip/transmitter/rk616_lvds.h
--- a/drivers/video/rockchip/transmitter/rk616_lvds.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk616_lvds.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RK616_VIF_H__
+#define __RK616_VIF_H__
+#include<linux/mfd/rk616.h>
+#include<linux/earlysuspend.h>
+#include<linux/rk_screen.h>
+
+
+struct rk616_lvds {
+	struct mfd_rk616 *rk616;
+	rk_screen *screen;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif 
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/transmitter/rk616_mipi_dsi.c b/drivers/video/rockchip/transmitter/rk616_mipi_dsi.c
--- a/drivers/video/rockchip/transmitter/rk616_mipi_dsi.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk616_mipi_dsi.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2567 @@
+/*
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ * drivers/video/display/transmitter/rk616_mipi_dsi.c
+ * author: hhb@rock-chips.com
+ * create date: 2013-07-17
+ * debug sys/kernel/debug/rk616/mipi
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+//config
+#define MIPI_DSI_REGISTER_IO	0
+#define CONFIG_MIPI_DSI_LINUX   0
+//#define CONFIG_MIPI_DSI_FT 	1
+//#define CONFIG_MFD_RK616   	1
+//#define CONFIG_ARCH_RK319X    1
+#define CONFIG_ARCH_RK3288    1
+
+#ifdef CONFIG_MIPI_DSI_LINUX
+#if defined(CONFIG_MFD_RK616)
+#define DWC_DSI_VERSION		0x3131302A
+#define DWC_DSI_VERSION_0x3131302A 1
+#elif defined(CONFIG_ARCH_RK319X)
+#define DWC_DSI_VERSION		0x3132312A
+#define DWC_DSI_VERSION_0x3132312A 1
+#elif defined(CONFIG_ARCH_RK3288)
+#define DWC_DSI_VERSION		0x3133302A
+#define DWC_DSI_VERSION_0x3133302A 1
+#else
+#define DWC_DSI_VERSION -1
+#endif  /* CONFIG_MFD_RK616 */
+#else
+#define DWC_DSI_VERSION		0x3131302A
+#endif  /* end of CONFIG_MIPI_DSI_LINUX*/
+
+
+#ifdef CONFIG_MIPI_DSI_LINUX
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mfd/rk616.h>
+#include <linux/rk_fb.h>
+#include <linux/rk_screen.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <asm/div64.h>
+
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/regulator/machine.h>
+
+#else
+#include "ft_lcd.h"
+#endif
+#include <linux/dma-mapping.h>
+#include "mipi_dsi.h"
+#include "rk616_mipi_dsi.h"
+#include <linux/rockchip/iomap.h>
+
+
+
+#if 1
+#define	MIPI_DBG(x...)	printk(KERN_INFO x)
+#else
+#ifdef CONFIG_MIPI_DSI_FT
+#define	MIPI_DBG(...)    \
+    do\
+    {\
+        printf(__VA_ARGS__);\
+        printf("\n");\
+    }while(0);
+#else
+#define	MIPI_DBG(x...)  
+#endif    /* end of CONFIG_MIPI_DSI_FT */
+#endif
+
+#ifdef CONFIG_MIPI_DSI_LINUX
+#define	MIPI_TRACE(x...)	printk(KERN_INFO x)
+#else
+#define	MIPI_TRACE(...)    \
+    do\
+    {\
+        printf(__VA_ARGS__);\
+        printf("\n");\
+    }while(0);
+    
+#endif
+
+/*
+*			 Driver Version Note
+*
+*v1.0 : this driver is mipi dsi driver of rockchip;
+*v1.1 : add FT code 
+*v1.2 : add rk_mipi_dsi_init_lite() for mclk variation
+*v1.3 : add clk_notifier function for mclk variation
+*v1.4 : add register temp to reduce the time driver resume takes when 
+		use I2C.
+*v1.5 : change early suspend level (BLANK_SCREEN + 1)
+*v1.6 : add dsi_rk616->resume to reduce the time driver resume takes
+*v2.0 : add mipi dsi support for rk319x
+*v2.1 : add inset and unplug the hdmi, mipi's lcd will be reset.
+*v2.2 : fix bug of V1.4 register temp, dpicolom
+*v3.0 : support kernel 3.10 and device tree 
+*/
+#define RK_MIPI_DSI_VERSION_AND_TIME  "rockchip mipi_dsi v3.0 2014-03-06"
+
+static struct dsi *dsi0;
+static struct dsi *dsi1;
+
+
+#ifdef CONFIG_MFD_RK616
+static struct mfd_rk616 *dsi_rk616;
+static struct rk29fb_screen *g_rk29fd_screen = NULL;
+#endif
+
+#ifdef CONFIG_MIPI_DSI_FT
+#define udelay 		DRVDelayUs
+#define msleep 		DelayMs_nops
+static u32 fre_to_period(u32 fre);
+#endif
+static int rk_mipi_dsi_is_active(void *arg);
+static int rk_mipi_dsi_enable_hs_clk(void *arg, u32 enable);
+static int rk_mipi_dsi_enable_video_mode(void *arg, u32 enable);
+static int rk_mipi_dsi_enable_command_mode(void *arg, u32 enable);
+static int rk_mipi_dsi_send_dcs_packet(void *arg, unsigned char regs[], u32 n);
+static int rk_mipi_dsi_is_enable(void *arg, u32 enable);
+int rk_mipi_screen_standby(u8 enable);
+
+#ifdef CONFIG_MFD_RK616
+static u32 *host_mem = NULL;
+static u32 *phy_mem = NULL;
+#endif
+
+static int dsi_read_reg(struct dsi *dsi, u16 reg, u32 *pval)
+{
+#ifdef CONFIG_MIPI_DSI_LINUX
+
+#if defined(CONFIG_MFD_RK616)
+	return dsi_rk616->read_dev(dsi_rk616, reg, pval);
+#elif defined(CONFIG_ARCH_RK319X)
+	if(reg >= MIPI_DSI_HOST_OFFSET)
+		*pval = __raw_readl(dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
+	else if(reg >= MIPI_DSI_PHY_OFFSET)
+		*pval = __raw_readl(dsi->phy.membase + (reg - MIPI_DSI_PHY_OFFSET));
+	return 0;
+#elif defined(CONFIG_ARCH_RK3288)
+	*pval = __raw_readl(dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
+	return 0;
+#endif  /* CONFIG_MFD_RK616 */
+
+#else
+
+#ifdef CONFIG_MIPI_DSI_FT
+	return JETTA_ReadControlRegister(reg, pval);
+#endif  /* CONFIG_MIPI_DSI_FT */
+
+#endif  /* end of CONFIG_MIPI_DSI_LINUX */
+}
+
+
+static int dsi_write_reg(struct dsi *dsi, u16 reg, u32 *pval)
+{
+#ifdef CONFIG_MIPI_DSI_LINUX
+
+#if defined(CONFIG_MFD_RK616)
+	return dsi_rk616->write_dev(dsi_rk616, reg, pval);
+#elif defined(CONFIG_ARCH_RK319X)
+	if(reg >= MIPI_DSI_HOST_OFFSET)
+		__raw_writel(*pval, dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
+	else if(reg >= MIPI_DSI_PHY_OFFSET)
+		__raw_writel(*pval, dsi->phy.membase + (reg - MIPI_DSI_PHY_OFFSET));	
+	return 0;
+#elif defined(CONFIG_ARCH_RK3288)
+	__raw_writel(*pval, dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
+	return 0;
+#endif  /* CONFIG_MFD_RK616 */
+
+#else
+
+#ifdef CONFIG_MIPI_DSI_FT
+	return JETTA_WriteControlRegister(reg, *pval);
+#endif  /* CONFIG_MIPI_DSI_FT */
+
+#endif  /* end of CONFIG_MIPI_DSI_LINUX */
+}
+
+#ifdef CONFIG_MFD_RK616
+static int dsi_write_reg_bulk(u16 reg, u32 count, u32 *pval)
+{
+	return dsi_rk616->write_bulk(dsi_rk616, reg, count, pval);
+}
+#endif
+
+static int dsi_get_bits(struct dsi *dsi, u32 reg)
+{
+	u32 val = 0;
+	u32 bits = (reg >> 8) & 0xff;
+	u16 reg_addr = (reg >> 16) & 0xffff;
+	u8 offset = reg & 0xff;
+	if(bits < 32)
+		bits = (1 << bits) - 1;
+	else
+		bits = 0xffffffff;
+	dsi_read_reg(dsi, reg_addr, &val);
+	val >>= offset;
+	val &= bits;
+	return val;
+}
+
+static int dsi_set_bits(struct dsi *dsi, u32 data, u32 reg) 
+{
+	u32 val = 0;
+	u32 bits = (reg >> 8) & 0xff;
+	u16 reg_addr = (reg >> 16) & 0xffff;
+	u8 offset = reg & 0xff;
+	if(bits < 32)
+		bits = (1 << bits) - 1;
+	else
+		bits = 0xffffffff;
+
+	if(bits != 0xffffffff) {
+#ifdef CONFIG_MFD_RK616
+		if(reg_addr >= MIPI_DSI_HOST_OFFSET) {
+			val = host_mem[(reg_addr - MIPI_DSI_HOST_OFFSET)>>2];
+		} else if(reg_addr >= MIPI_DSI_PHY_OFFSET) {
+			val = phy_mem[(reg_addr - MIPI_DSI_PHY_OFFSET)>>2];
+		} else
+			dsi_read_reg(dsi, reg_addr, &val);
+		if(val == 0xaaaaaaaa)
+			dsi_read_reg(dsi, reg_addr, &val);
+#else
+		dsi_read_reg(dsi, reg_addr, &val);
+#endif
+	}
+
+	val &= ~(bits << offset);
+	val |= (data & bits) << offset;
+	//printk("%s:%04x->%08x\n", __func__, reg_addr, val);
+	dsi_write_reg(dsi, reg_addr, &val);
+#ifdef CONFIG_MFD_RK616
+	if(reg_addr >= MIPI_DSI_HOST_OFFSET) {
+		host_mem[(reg_addr - MIPI_DSI_HOST_OFFSET)>>2] = val;
+	} else if(reg_addr >= MIPI_DSI_PHY_OFFSET) {
+		phy_mem[(reg_addr - MIPI_DSI_PHY_OFFSET)>>2] = val;
+	}
+#endif
+
+	if(data > bits) {
+		MIPI_TRACE("%s error reg_addr:0x%04x, offset:%d, bits:0x%04x, value:0x%04x\n", 
+				__func__, reg_addr, offset, bits, data);
+	}
+	return 0;
+}
+
+static int dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
+{
+    int val = 0;
+    dsi_set_bits(dsi, 1, phy_testclk);
+    dsi_set_bits(dsi, test_code, phy_testdin);
+    dsi_set_bits(dsi, 1, phy_testen);
+	dsi_set_bits(dsi, 0, phy_testclk);
+	dsi_set_bits(dsi, 0, phy_testen);;
+
+    dsi_set_bits(dsi, 0, phy_testen);
+    val = dsi_get_bits(dsi,phy_testdout);
+    dsi_set_bits(dsi, 1, phy_testclk);
+    dsi_set_bits(dsi, 0, phy_testclk);
+
+    return val;
+}
+
+
+static int dwc_phy_test_wr(struct dsi *dsi, unsigned char test_code, unsigned char *test_data, unsigned char size)
+{
+	int i = 0;
+ 
+    dsi_set_bits(dsi, 0x10000 | test_code, PHY_TEST_CTRL1);
+    dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
+    dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
+
+	for(i = 0; i < size; i++) {
+    	dsi_set_bits(dsi, test_data[i], PHY_TEST_CTRL1);
+        dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
+        dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
+        MIPI_DBG("dwc_phy_test_wr:%08x\n", dsi_get_bits(dsi, PHY_TEST_CTRL1));
+	}
+	return 0;
+}
+
+#ifdef CONFIG_MFD_RK616
+static int rk_mipi_recover_reg(void) 
+{
+	u32 reg_addr = 0, count = 0, i = 0;
+	
+	for(i = 0x0c; i < MIPI_DSI_PHY_SIZE; i += 4) {
+		if(phy_mem[i>>2] != 0xaaaaaaaa) {
+			count++;
+		}
+			
+		if((phy_mem[i>>2] == 0xaaaaaaaa) && (phy_mem[(i-4) >> 2] != 0xaaaaaaaa)) {
+loop1:		reg_addr = i - (count<<2);
+			dsi_write_reg_bulk(reg_addr + MIPI_DSI_PHY_OFFSET, count, 
+								phy_mem+(reg_addr>>2));
+			//printk("%4x:%08x\n", reg_addr, phy_mem[reg_addr>>2]);
+			count = 0;
+		}
+		if((i == (MIPI_DSI_PHY_SIZE-4)) && (count != 0)) {
+			i = MIPI_DSI_PHY_SIZE;		
+			goto loop1;
+		}
+	}
+	count = 0;
+	for(i = 0x08; i < MIPI_DSI_HOST_SIZE; i += 4) {
+		if(host_mem[i>>2] != 0xaaaaaaaa) {
+			count++;
+		}
+			
+		if((host_mem[i>>2] == 0xaaaaaaaa) && (host_mem[(i-4) >> 2] != 0xaaaaaaaa)) {
+loop2:		reg_addr = i - (count<<2);
+			dsi_write_reg_bulk(reg_addr + MIPI_DSI_HOST_OFFSET, count, 
+								host_mem+(reg_addr>>2));
+			//printk("%4x:%08x\n", reg_addr, host_mem[reg_addr>>2]);
+			count = 0;
+		}
+		if((i == (MIPI_DSI_HOST_SIZE-4)) && (count != 0))		
+			goto loop2;
+	}		
+	return 0;
+}
+#endif
+#if defined(CONFIG_MFD_RK616) || defined(CONFIG_ARCH_RK319X)
+static int inno_phy_set_gotp(struct dsi *dsi, u32 offset) 
+{
+	u32 val = 0, temp = 0, Tlpx = 0;
+	u32 ddr_clk = dsi->phy.ddr_clk;
+	u32 Ttxbyte_clk = dsi->phy.Ttxbyte_clk;
+	u32 Tsys_clk = dsi->phy.Tsys_clk;
+	u32 Ttxclkesc = dsi->phy.Ttxclkesc;
+	
+	switch(offset) {
+		case DPHY_CLOCK_OFFSET:
+			MIPI_DBG("******set DPHY_CLOCK_OFFSET gotp******\n");
+			break;
+		case DPHY_LANE0_OFFSET:
+			MIPI_DBG("******set DPHY_LANE0_OFFSET gotp******\n");
+			break;
+		case DPHY_LANE1_OFFSET:
+			MIPI_DBG("******set DPHY_LANE1_OFFSET gotp******\n");
+			break;
+		case DPHY_LANE2_OFFSET:
+			MIPI_DBG("******set DPHY_LANE2_OFFSET gotp******\n");
+			break;
+		case DPHY_LANE3_OFFSET:
+			MIPI_DBG("******set DPHY_LANE3_OFFSET gotp******\n");
+			break;
+		default:
+			break;					
+	}
+	
+	if(ddr_clk < 110 * MHz)
+		val = 0;
+	else if(ddr_clk < 150 * MHz)
+		val = 1;
+	else if(ddr_clk < 200 * MHz)
+		val = 2;
+	else if(ddr_clk < 250 * MHz)
+		val = 3;
+	else if(ddr_clk < 300 * MHz)
+		val = 4;
+	else if(ddr_clk < 400 * MHz)
+		val = 5;		
+	else if(ddr_clk < 500 * MHz)
+		val = 6;		
+	else if(ddr_clk < 600 * MHz)
+		val = 7;		
+	else if(ddr_clk < 700 * MHz)
+		val = 8;
+	else if(ddr_clk < 800 * MHz)
+		val = 9;		
+	else if(ddr_clk <= 1000 * MHz)
+		val = 10;	
+	dsi_set_bits(dsi, val, reg_ths_settle + offset);
+	
+	if(ddr_clk < 110 * MHz)
+		val = 0x20;
+	else if(ddr_clk < 150 * MHz)
+		val = 0x06;
+	else if(ddr_clk < 200 * MHz)
+		val = 0x18;
+	else if(ddr_clk < 250 * MHz)
+		val = 0x05;
+	else if(ddr_clk < 300 * MHz)
+		val = 0x51;
+	else if(ddr_clk < 400 * MHz)
+		val = 0x64;		
+	else if(ddr_clk < 500 * MHz)
+		val = 0x59;		
+	else if(ddr_clk < 600 * MHz)
+		val = 0x6a;		
+	else if(ddr_clk < 700 * MHz)
+		val = 0x3e;
+	else if(ddr_clk < 800 * MHz)
+		val = 0x21;
+	else if(ddr_clk <= 1000 * MHz)
+		val = 0x09;
+	dsi_set_bits(dsi, val, reg_hs_ths_prepare + offset);
+
+	if(offset != DPHY_CLOCK_OFFSET) {
+	
+		if(ddr_clk < 110 * MHz)
+			val = 2;
+		else if(ddr_clk < 150 * MHz)
+			val = 3;
+		else if(ddr_clk < 200 * MHz)
+			val = 4;
+		else if(ddr_clk < 250 * MHz)
+			val = 5;
+		else if(ddr_clk < 300 * MHz)
+			val = 6;
+		else if(ddr_clk < 400 * MHz)
+			val = 7;		
+		else if(ddr_clk < 500 * MHz)
+			val = 7;		
+		else if(ddr_clk < 600 * MHz)
+			val = 8;		
+		else if(ddr_clk < 700 * MHz)
+			val = 8;
+		else if(ddr_clk < 800 * MHz)
+			val = 9;		
+		else if(ddr_clk <= 1000 * MHz)
+			val = 9;	
+	} else {
+	
+		if(ddr_clk < 110 * MHz)
+			val = 0x16;
+		else if(ddr_clk < 150 * MHz)
+			val = 0x16;
+		else if(ddr_clk < 200 * MHz)
+			val = 0x17;
+		else if(ddr_clk < 250 * MHz)
+			val = 0x17;
+		else if(ddr_clk < 300 * MHz)
+			val = 0x18;
+		else if(ddr_clk < 400 * MHz)
+			val = 0x19;		
+		else if(ddr_clk < 500 * MHz)
+			val = 0x1b;		
+		else if(ddr_clk < 600 * MHz)
+			val = 0x1d;		
+		else if(ddr_clk < 700 * MHz)
+			val = 0x1e;
+		else if(ddr_clk < 800 * MHz)
+			val = 0x1f;		
+		else if(ddr_clk <= 1000 * MHz)
+			val = 0x20;	
+	}				
+	dsi_set_bits(dsi, val, reg_hs_the_zero + offset);
+	
+	if(ddr_clk < 110 * MHz)
+		val = 0x22;
+	else if(ddr_clk < 150 * MHz)
+		val = 0x45;
+	else if(ddr_clk < 200 * MHz)
+		val = 0x0b;
+	else if(ddr_clk < 250 * MHz)
+		val = 0x16;
+	else if(ddr_clk < 300 * MHz)
+		val = 0x2c;
+	else if(ddr_clk < 400 * MHz)
+		val = 0x33;		
+	else if(ddr_clk < 500 * MHz)
+		val = 0x4e;		
+	else if(ddr_clk < 600 * MHz)
+		val = 0x3a;		
+	else if(ddr_clk < 700 * MHz)
+		val = 0x6a;
+	else if(ddr_clk < 800 * MHz)
+		val = 0x29;		
+	else if(ddr_clk <= 1000 * MHz)
+		val = 0x21;   //0x27
+
+	dsi_set_bits(dsi, val, reg_hs_ths_trail + offset);
+	val = 120000 / Ttxbyte_clk + 1;
+	MIPI_DBG("reg_hs_ths_exit: %d, %d\n", val, val*Ttxbyte_clk/1000);
+	dsi_set_bits(dsi, val, reg_hs_ths_exit + offset);
+	
+	if(offset == DPHY_CLOCK_OFFSET) {
+		val = (60000 + 52*dsi->phy.UI) / Ttxbyte_clk + 1;
+		MIPI_DBG("reg_hs_tclk_post: %d, %d\n", val, val*Ttxbyte_clk/1000);
+		dsi_set_bits(dsi, val, reg_hs_tclk_post + offset);
+		val = 10*dsi->phy.UI / Ttxbyte_clk + 1;
+		MIPI_DBG("reg_hs_tclk_pre: %d, %d\n", val, val*Ttxbyte_clk/1000);	
+		dsi_set_bits(dsi, val, reg_hs_tclk_pre + offset);
+	}
+
+	val = 1010000000 / Tsys_clk + 1;
+	MIPI_DBG("reg_hs_twakup: %d, %d\n", val, val*Tsys_clk/1000);
+	if(val > 0x3ff) {
+		val = 0x2ff;
+		MIPI_DBG("val is too large, 0x3ff is the largest\n");	
+	}
+	temp = (val >> 8) & 0x03;
+	val &= 0xff;	
+	dsi_set_bits(dsi, temp, reg_hs_twakup_h + offset);	
+	dsi_set_bits(dsi, val, reg_hs_twakup_l + offset);
+	
+	if(Ttxclkesc > 50000) {
+		val = 2*Ttxclkesc;
+		MIPI_DBG("Ttxclkesc:%d\n", Ttxclkesc);
+	}
+	val = val / Ttxbyte_clk;
+	Tlpx = val*Ttxbyte_clk;
+	MIPI_DBG("reg_hs_tlpx: %d, %d\n", val, Tlpx);
+	val -= 2;
+	dsi_set_bits(dsi, val, reg_hs_tlpx + offset);
+	
+	Tlpx = 2*Ttxclkesc;
+	val = 4*Tlpx / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_go: %d, %d\n", val, val*Ttxclkesc);
+	dsi_set_bits(dsi, val, reg_hs_tta_go + offset);
+	val = 3 * Tlpx / 2 / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_sure: %d, %d\n", val, val*Ttxclkesc);	
+	dsi_set_bits(dsi, val, reg_hs_tta_sure + offset);
+	val = 5 * Tlpx / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_wait: %d, %d\n", val, val*Ttxclkesc);
+	dsi_set_bits(dsi, val, reg_hs_tta_wait + offset);
+	return 0;
+}
+
+static int inno_set_hs_clk(struct dsi *dsi) 
+{
+	dsi_set_bits(dsi, dsi->phy.prediv, reg_prediv);
+	dsi_set_bits(dsi, dsi->phy.fbdiv & 0xff, reg_fbdiv);
+	dsi_set_bits(dsi, (dsi->phy.fbdiv >> 8) & 0x01, reg_fbdiv_8);
+	return 0;
+}
+
+static int inno_phy_power_up(struct dsi *dsi)
+{
+	inno_set_hs_clk(dsi);
+#if defined(CONFIG_ARCH_RK319X)
+	//enable ref clock
+	clk_enable(dsi->phy.refclk);
+	udelay(10);
+#endif
+	dsi_set_bits(dsi, 0xe4, DPHY_REGISTER1);
+	switch(dsi->host.lane) {
+		case 4:
+			dsi_set_bits(dsi, 1, lane_en_3);
+		case 3:
+			dsi_set_bits(dsi, 1, lane_en_2);
+		case 2:
+			dsi_set_bits(dsi, 1, lane_en_1);
+		case 1:
+			dsi_set_bits(dsi, 1, lane_en_0);
+			dsi_set_bits(dsi, 1, lane_en_ck);
+			break;
+		default:
+			break;	
+	}
+
+	dsi_set_bits(dsi, 0xe0, DPHY_REGISTER1);
+	udelay(10);
+
+	dsi_set_bits(dsi, 0x1e, DPHY_REGISTER20);
+	dsi_set_bits(dsi, 0x1f, DPHY_REGISTER20);
+	return 0;
+}
+
+static int inno_phy_power_down(struct dsi *dsi) 
+{
+	dsi_set_bits(dsi, 0x01, DPHY_REGISTER0);
+	dsi_set_bits(dsi, 0xe3, DPHY_REGISTER1);
+#if defined(CONFIG_ARCH_RK319X)
+	//disable ref clock
+	clk_disable(dsi->phy.refclk);
+#endif
+	return 0;
+}
+
+static int inno_phy_init(struct dsi *dsi) 
+{
+	//DPHY init
+	dsi_set_bits(dsi, 0x11, DSI_DPHY_BITS(0x06<<2, 32, 0));
+	dsi_set_bits(dsi, 0x11, DSI_DPHY_BITS(0x07<<2, 32, 0));
+	dsi_set_bits(dsi, 0xcc, DSI_DPHY_BITS(0x09<<2, 32, 0));
+#if 0
+	dsi_set_bits(dsi, 0x4e, DSI_DPHY_BITS(0x08<<2, 32, 0));
+	dsi_set_bits(dsi, 0x84, DSI_DPHY_BITS(0x0a<<2, 32, 0));
+#endif
+
+	/*reg1[4] 0: enable a function of "pll phase for serial data being captured 
+				 inside analog part" 
+	          1: disable it 
+	  we disable it here because reg5[6:4] is not compatible with the HS speed. 		
+	*/
+
+	if(dsi->phy.ddr_clk >= 800*MHz) {
+		dsi_set_bits(dsi, 0x30, DSI_DPHY_BITS(0x05<<2, 32, 0));
+	} else {
+		dsi_set_bits(dsi, 1, reg_da_ppfc);
+	}
+
+	switch(dsi->host.lane) {
+		case 4:
+			inno_phy_set_gotp(dsi, DPHY_LANE3_OFFSET);
+		case 3:
+			inno_phy_set_gotp(dsi, DPHY_LANE2_OFFSET);
+		case 2:
+			inno_phy_set_gotp(dsi, DPHY_LANE1_OFFSET);
+		case 1:
+			inno_phy_set_gotp(dsi, DPHY_LANE0_OFFSET);
+			inno_phy_set_gotp(dsi, DPHY_CLOCK_OFFSET);
+			break;
+		default:
+			break;	
+	}	
+	return 0;
+}
+#endif
+static int rk32_phy_power_up(struct dsi *dsi)
+{
+    //enable ref clock
+    clk_prepare_enable(dsi->phy.refclk); 
+    clk_prepare_enable(dsi->dsi_pclk);
+    udelay(10);
+
+	switch(dsi->host.lane) {
+		case 4:
+			dsi_set_bits(dsi, 3, n_lanes);
+		case 3:
+			dsi_set_bits(dsi, 2, n_lanes);
+		case 2:
+			dsi_set_bits(dsi, 1, n_lanes);
+		case 1:
+			dsi_set_bits(dsi, 0, n_lanes);
+			break;
+		default:
+			break;	
+	}
+    dsi_set_bits(dsi, 1, phy_shutdownz);
+    dsi_set_bits(dsi, 1, phy_rstz);  
+    dsi_set_bits(dsi, 1, phy_enableclk);
+    dsi_set_bits(dsi, 1, phy_forcepll);
+    return 0;
+}
+
+static int rk32_phy_power_down(struct dsi *dsi)
+{
+    dsi_set_bits(dsi, 0, phy_shutdownz);
+    clk_disable_unprepare(dsi->phy.refclk); 
+    clk_disable_unprepare(dsi->dsi_pclk);
+    return 0;
+}
+
+static int rk32_phy_init(struct dsi *dsi)
+{
+    u32 val = 0;
+    u32 ddr_clk = dsi->phy.ddr_clk;
+    u16 prediv = dsi->phy.prediv;
+    u16 fbdiv = dsi->phy.fbdiv;
+    // u32 Ttxclkesc = dsi->phy.Ttxclkesc;
+    unsigned char test_data[2] = {0};
+
+    if(ddr_clk < 90 * MHz)
+        val = 0x01;
+	else if(ddr_clk < 100 * MHz)
+        val = 0x10;
+	else if(ddr_clk < 110 * MHz)
+        val = 0x20;
+	else if(ddr_clk < 130 * MHz)
+        val = 0x01;
+	else if(ddr_clk < 140 * MHz)
+        val = 0x11;
+	else if(ddr_clk < 150 * MHz)
+        val = 0x21; 
+	else if(ddr_clk < 170 * MHz)
+        val = 0x02;
+	else if(ddr_clk < 180 * MHz)
+        val = 0x12;
+	else if(ddr_clk < 200 * MHz)
+        val = 0x22;
+	else if(ddr_clk < 220 * MHz)
+        val = 0x03;
+	else if(ddr_clk < 240 * MHz)
+        val = 0x13;
+	else if(ddr_clk < 250 * MHz)
+        val = 0x23;
+	else if(ddr_clk < 270 * MHz)
+        val = 0x04; 
+	else if(ddr_clk < 300 * MHz)
+        val = 0x14;
+	else if(ddr_clk < 330 * MHz)
+        val = 0x05;
+	else if(ddr_clk < 360 * MHz)
+        val = 0x15; 
+	else if(ddr_clk < 400 * MHz)
+        val = 0x25;
+	else if(ddr_clk < 450 * MHz)
+        val = 0x06; 
+	else if(ddr_clk < 500 * MHz)
+        val = 0x16;
+	else if(ddr_clk < 550 * MHz)
+        val = 0x07;
+	else if(ddr_clk < 600 * MHz)
+        val = 0x17;
+	else if(ddr_clk < 650 * MHz)
+        val = 0x08;
+	else if(ddr_clk < 700 * MHz)
+        val = 0x18;
+	else if(ddr_clk < 750 * MHz)
+        val = 0x09;
+	else if(ddr_clk < 800 * MHz)
+        val = 0x19;
+    else if(ddr_clk < 850 * MHz)
+        val = 0x29;
+    else if(ddr_clk < 900 * MHz)
+        val = 0x39;
+    else if(ddr_clk < 950 * MHz)
+        val = 0x0a;
+    else if(ddr_clk < 1000 * MHz)
+        val = 0x1a;
+    else if(ddr_clk < 1050 * MHz)
+        val = 0x2a;
+    else if(ddr_clk < 1100* MHz)
+        val = 0x3a;
+    else if(ddr_clk < 1150* MHz)
+        val = 0x0b;
+    else if(ddr_clk < 1200 * MHz)
+        val = 0x1b;
+    else if(ddr_clk < 1250 * MHz)
+        val = 0x2b;
+    else if(ddr_clk < 1300 * MHz)
+        val = 0x3b;
+    else if(ddr_clk < 1350 * MHz)
+        val = 0x0c;
+    else if(ddr_clk < 1400* MHz)
+        val = 0x1c;
+    else if(ddr_clk < 1450* MHz)
+        val = 0x2c;
+    else if(ddr_clk <= 1500* MHz)
+        val = 0x3c;
+
+    //N=2,M=84
+    test_data[0] = val << 1;
+    dwc_phy_test_wr(dsi, code_hs_rx_lane0, test_data, 1);
+
+    test_data[0] = prediv- 1;
+    dwc_phy_test_wr(dsi, code_pll_input_div_rat, test_data, 1);
+    
+    test_data[0] = (fbdiv - 1) & 0x1f; //0x14; 
+    dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
+    
+    test_data[0] = (fbdiv - 1) >> 5 | 0x80;  //0x82
+    dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
+    
+    test_data[0] = 0x30;
+    dwc_phy_test_wr(dsi, code_pll_input_loop_div_rat, test_data, 1);
+    mdelay(100);
+
+    test_data[0] = 0x00;
+    // dwc_phy_test_wr(dsi, 0x60, test_data, 1);
+
+    test_data[0] = 0x81;
+    // dwc_phy_test_wr(dsi, 0x61, test_data, 1);
+
+    test_data[0] = 0x0;
+    // dwc_phy_test_wr(dsi, 0x62, test_data, 1);
+
+    test_data[0] = 0x80 | 15;
+    dwc_phy_test_wr(dsi, code_hstxdatalanerequsetstatetime, test_data, 1);
+
+    test_data[0] = 0x80 | 85;
+    dwc_phy_test_wr(dsi, code_hstxdatalanepreparestatetime, test_data, 1);
+
+    test_data[0] = 0x40 | 10;
+    dwc_phy_test_wr(dsi, code_hstxdatalanehszerostatetime, test_data, 1);
+
+
+    // test_data[0] = 0x80 | 127;
+    // dwc_phy_test_wr(dsi, 0x71, test_data, 1);
+
+    // test_data[0] = 0x3;
+    // dwc_phy_test_wr(dsi, 0x57, test_data, 1);
+
+    return 0;
+}
+
+static int rk_mipi_dsi_phy_power_up(struct dsi *dsi)
+{
+#if defined(CONFIG_MFD_RK616) || defined(CONFIG_ARCH_RK319X)
+	return inno_phy_power_up(dsi);
+#else
+	return rk32_phy_power_up(dsi);
+#endif
+}
+
+
+static int rk_mipi_dsi_phy_power_down(struct dsi *dsi) 
+{
+#if defined(CONFIG_MFD_RK616) || defined(CONFIG_ARCH_RK319X)
+	return inno_phy_power_down(dsi);
+#else
+	return rk32_phy_power_down(dsi);
+#endif
+	return 0;
+}
+
+static int rk_mipi_dsi_phy_init(struct dsi *dsi) 
+{
+#if defined(CONFIG_MFD_RK616) || defined(CONFIG_ARCH_RK319X)
+	return inno_phy_init(dsi);
+#else
+	return rk32_phy_init(dsi);
+#endif
+	return 0;
+}
+
+static int rk_mipi_dsi_host_power_up(struct dsi *dsi) 
+{
+	int ret = 0;
+	u32 val = 0;
+	
+	//disable all interrupt            
+#ifdef DWC_DSI_VERSION_0x3131302A
+	dsi_set_bits(dsi, 0x1fffff, ERROR_MSK0);
+	dsi_set_bits(dsi, 0x1ffff, ERROR_MSK1);
+#else
+	dsi_set_bits(dsi, 0x1fffff, INT_MKS0);
+	dsi_set_bits(dsi, 0x1ffff, INT_MKS1);
+#endif
+
+	rk_mipi_dsi_is_enable(dsi, 1);
+	
+	val = 10;
+	while(!dsi_get_bits(dsi, phylock) && val--) {
+		udelay(10);
+	};
+	
+	if(val == 0) {
+		ret = -1;
+		MIPI_TRACE("%s:phylock fail\n", __func__);	
+	}
+	
+	val = 10;
+	while(!dsi_get_bits(dsi, phystopstateclklane) && val--) {
+		udelay(10);
+	};
+	
+	return ret;
+}
+
+static int rk_mipi_dsi_host_power_down(struct dsi *dsi) 
+{	
+	rk_mipi_dsi_enable_video_mode(dsi, 0);
+	rk_mipi_dsi_enable_hs_clk(dsi, 0);
+	rk_mipi_dsi_is_enable(dsi, 0);
+	return 0;
+}
+
+static int rk_mipi_dsi_host_init(struct dsi *dsi) 
+{
+	u32 val = 0, bytes_px = 0;
+	struct mipi_dsi_screen *screen = &dsi->screen;
+	u32 decimals = dsi->phy.Ttxbyte_clk, temp = 0, i = 0;
+	u32 m = 1, lane = dsi->host.lane, Tpclk = dsi->phy.Tpclk, 
+			Ttxbyte_clk = dsi->phy.Ttxbyte_clk;
+#ifdef CONFIG_MFD_RK616
+	val = 0x04000000;
+	dsi_write_reg(dsi, CRU_CRU_CLKSEL1_CON, &val);
+#endif	
+	dsi_set_bits(dsi, dsi->host.lane - 1, n_lanes);
+	dsi_set_bits(dsi, dsi->vid, dpi_vcid);
+	
+	switch(screen->face) {
+		case OUT_P888:
+			dsi_set_bits(dsi, 5, dpi_color_coding);
+			bytes_px = 3;
+			break;
+		case OUT_D888_P666:
+		case OUT_P666:
+			dsi_set_bits(dsi, 3, dpi_color_coding);
+			dsi_set_bits(dsi, 1, en18_loosely);
+			bytes_px = 3;
+			break;
+		case OUT_P565:
+			dsi_set_bits(dsi, 0, dpi_color_coding);
+			bytes_px = 2;
+		default:
+			break;
+	}
+	
+	dsi_set_bits(dsi, 1, hsync_active_low);
+	dsi_set_bits(dsi, 1, vsync_active_low);
+	
+	dsi_set_bits(dsi, 0, dataen_active_low);
+	dsi_set_bits(dsi, 0, colorm_active_low);
+	dsi_set_bits(dsi, 0, shutd_active_low);
+	
+	dsi_set_bits(dsi, dsi->host.video_mode, vid_mode_type);	  //burst mode
+	switch(dsi->host.video_mode) {
+		case VM_BM:
+		    if(screen->type == SCREEN_DUAL_MIPI)
+			    dsi_set_bits(dsi, screen->x_res / 2 + 4, vid_pkt_size);
+			 else
+			    dsi_set_bits(dsi, screen->x_res, vid_pkt_size);
+			break;
+		case VM_NBMWSE:
+		case VM_NBMWSP:
+			for(i = 8; i < 32; i++){
+				temp = i * lane * Tpclk % Ttxbyte_clk;
+				if(decimals > temp) {
+					decimals = temp;
+					m = i;
+				}
+				if(decimals == 0)
+					break;
+			}
+#ifdef CONFIG_MFD_RK616
+			dsi_set_bits(dsi, 1, en_multi_pkt);
+#endif
+			dsi_set_bits(dsi, screen->x_res / m + 1, num_chunks);
+			dsi_set_bits(dsi, m, vid_pkt_size);
+			temp = m * lane * Tpclk / Ttxbyte_clk - m * bytes_px;
+			MIPI_DBG("%s:%d, %d\n", __func__, m, temp);
+			if(temp >= 12) {
+#ifdef CONFIG_MFD_RK616
+				dsi_set_bits(dsi, 1, en_null_pkt);
+#endif
+				dsi_set_bits(dsi, temp - 12, null_pkt_size);
+			}
+			break;
+		default:
+			break;
+	}	
+
+	//dsi_set_bits(dsi, 0, CMD_MODE_CFG << 16);
+	if(rk_mipi_get_dsi_num() ==1){
+		dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->x_res + screen->left_margin + 
+					screen->hsync_len + screen->right_margin) \
+						/ dsi->phy.Ttxbyte_clk, vid_hline_time);
+	}
+	else{
+		dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->x_res + 8 + screen->left_margin + 
+					screen->hsync_len + screen->right_margin) \
+						/ dsi->phy.Ttxbyte_clk, vid_hline_time);	
+	}
+		dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->left_margin) / dsi->phy.Ttxbyte_clk, 
+					vid_hbp_time);
+	dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->hsync_len) / dsi->phy.Ttxbyte_clk, 
+					vid_hsa_time);
+    
+	dsi_set_bits(dsi, screen->y_res , vid_active_lines);
+	dsi_set_bits(dsi, screen->lower_margin, vid_vfp_lines);
+	dsi_set_bits(dsi, screen->upper_margin, vid_vbp_lines);
+	dsi_set_bits(dsi, screen->vsync_len, vid_vsa_lines);
+	
+	dsi->phy.txclkesc = 20 * MHz;
+	val = dsi->phy.txbyte_clk / dsi->phy.txclkesc + 1;
+	dsi->phy.txclkesc = dsi->phy.txbyte_clk / val;
+	dsi_set_bits(dsi, val, TX_ESC_CLK_DIVISION);
+	
+	dsi_set_bits(dsi, 10, TO_CLK_DIVISION);
+    dsi_set_bits(dsi, 1000, hstx_to_cnt); //no sure
+	dsi_set_bits(dsi, 1000, lprx_to_cnt);	
+	dsi_set_bits(dsi, 100, phy_stop_wait_time);
+
+	//dsi_set_bits(dsi, 0, outvact_lpcmd_time);   //byte
+	//dsi_set_bits(dsi, 0, invact_lpcmd_time);
+		
+	dsi_set_bits(dsi, 20, phy_hs2lp_time);
+	dsi_set_bits(dsi, 16, phy_lp2hs_time);	
+    
+#if defined(CONFIG_ARCH_RK3288)	
+   // dsi_set_bits(dsi, 87, phy_hs2lp_time_clk_lane); //no sure
+  //  dsi_set_bits(dsi, 25, phy_hs2hs_time_clk_lane); //no sure
+#endif	
+
+	dsi_set_bits(dsi, 10000, max_rd_time);
+#ifdef DWC_DSI_VERSION_0x3131302A
+	dsi_set_bits(dsi, 1, dpicolom);
+	dsi_set_bits(dsi, 1, dpishutdn);
+#endif
+#if 1
+	dsi_set_bits(dsi, 1, lp_hfp_en);
+	//dsi_set_bits(dsi, 1, lp_hbp_en); //no sure
+	dsi_set_bits(dsi, 1, lp_vact_en);
+	dsi_set_bits(dsi, 1, lp_vfp_en);
+	dsi_set_bits(dsi, 1, lp_vbp_en);
+	dsi_set_bits(dsi, 1, lp_vsa_en);
+#endif	
+	//dsi_set_bits(dsi, 1, frame_bta_ack_en);
+	dsi_set_bits(dsi, 1, phy_enableclk);
+	dsi_set_bits(dsi, 0, phy_tx_triggers);
+	//dsi_set_bits(dsi, 1, phy_txexitulpslan);
+	//dsi_set_bits(dsi, 1, phy_txexitulpsclk);
+	return 0;
+}
+
+/*
+	mipi protocol layer definition
+*/
+static int rk_mipi_dsi_init(void *arg, u32 n)
+{
+	u32 decimals = 1000, i = 0, pre = 0;
+	struct dsi *dsi = arg;
+	struct mipi_dsi_screen *screen = &dsi->screen;
+	
+	if(!screen)
+		return -1;
+	
+	if((screen->type != SCREEN_MIPI) && (screen->type != SCREEN_DUAL_MIPI) ) {
+		MIPI_TRACE("only mipi dsi lcd is supported!\n");
+		return -1;
+	}
+
+	if(((screen->type == SCREEN_DUAL_MIPI) && (rk_mipi_get_dsi_num() == 1)) ||  ((screen->type == SCREEN_MIPI) && (rk_mipi_get_dsi_num() == 2))){
+        MIPI_TRACE("dsi number and mipi type not match!\n");
+	    return -1;
+    }
+	    
+#ifdef CONFIG_MIPI_DSI_FT
+	dsi->phy.pclk = screen->pixclock;
+	dsi->phy.ref_clk = MIPI_DSI_MCLK;
+#else
+	
+	dsi->phy.Tpclk = rk_fb_get_prmry_screen_pixclock();
+
+	printk("dsi->phy.Tpclk=%d\n",dsi->phy.Tpclk);
+
+#if defined(CONFIG_MFD_RK616)
+	if(dsi_rk616->mclk)
+		dsi->phy.ref_clk = clk_get_rate(dsi_rk616->mclk);
+#elif defined(CONFIG_ARCH_RK319X)
+	if(dsi->phy.refclk)
+		dsi->phy.ref_clk = clk_get_rate(dsi->phy.refclk) / 2;  // 1/2 of input refclk
+#endif   /* CONFIG_MFD_RK616 */
+	//dsi->phy.ref_clk = 24 * MHz;
+#endif   /* CONFIG_MIPI_DSI_FT */
+
+    if(dsi->phy.refclk)
+		dsi->phy.ref_clk = clk_get_rate(dsi->phy.refclk) ;
+
+	dsi->phy.sys_clk = dsi->phy.ref_clk;
+
+	printk(
+
+"dsi->phy.sys_clk =%d\n",dsi->phy.sys_clk );
+
+#ifndef CONFIG_ARCH_RK3288	
+	if((screen->hs_tx_clk <= 80 * MHz) || (screen->hs_tx_clk >= 1000 * MHz))
+		dsi->phy.ddr_clk = 1000 * MHz;    //default is 1HGz
+	else
+		dsi->phy.ddr_clk = screen->hs_tx_clk;	
+#else
+    if((screen->hs_tx_clk <= 90 * MHz) || (screen->hs_tx_clk >= 1500 * MHz))
+        dsi->phy.ddr_clk = 1500 * MHz;    //default is 1.5HGz
+    else
+        dsi->phy.ddr_clk = screen->hs_tx_clk;   
+#endif	
+
+
+/*	if(n != 0) {
+		dsi->phy.ddr_clk = n;
+	}
+    */
+
+	decimals = dsi->phy.ref_clk;
+	for(i = 1; i < 6; i++) {
+		pre = dsi->phy.ref_clk / i;
+		if((decimals > (dsi->phy.ddr_clk % pre)) && (dsi->phy.ddr_clk / pre < 512)) {
+			decimals = dsi->phy.ddr_clk % pre;
+			dsi->phy.prediv = i;
+			dsi->phy.fbdiv = dsi->phy.ddr_clk / pre;
+		}	
+		if(decimals == 0) 
+			break;
+	}
+
+	MIPI_DBG("prediv:%d, fbdiv:%d,dsi->phy.ddr_clk:%d\n", dsi->phy.prediv, dsi->phy.fbdiv,dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv);
+
+	dsi->phy.ddr_clk = dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv;	
+	MIPI_DBG("dsi->phy.ddr_clk =%d\n",dsi->phy.ddr_clk);
+	dsi->phy.txbyte_clk = dsi->phy.ddr_clk / 8;
+	
+	dsi->phy.txclkesc = 20 * MHz;        // < 20MHz
+	dsi->phy.txclkesc = dsi->phy.txbyte_clk / (dsi->phy.txbyte_clk / dsi->phy.txclkesc + 1);
+
+#ifdef CONFIG_MIPI_DSI_FT	
+	dsi->phy.Tpclk = fre_to_period(dsi->phy.pclk);
+	dsi->phy.Ttxclkesc = fre_to_period(dsi->phy.txclkesc);
+	dsi->phy.Tsys_clk = fre_to_period(dsi->phy.sys_clk);
+	dsi->phy.Tddr_clk = fre_to_period(dsi->phy.ddr_clk);
+	dsi->phy.Ttxbyte_clk = fre_to_period(dsi->phy.txbyte_clk);	
+#else
+	dsi->phy.pclk = div_u64(1000000000000llu, dsi->phy.Tpclk);
+	dsi->phy.Ttxclkesc = div_u64(1000000000000llu, dsi->phy.txclkesc);
+	dsi->phy.Tsys_clk = div_u64(1000000000000llu, dsi->phy.sys_clk);
+	dsi->phy.Tddr_clk = div_u64(1000000000000llu, dsi->phy.ddr_clk);
+	dsi->phy.Ttxbyte_clk = div_u64(1000000000000llu, dsi->phy.txbyte_clk);	
+#endif
+	
+	dsi->phy.UI = dsi->phy.Tddr_clk;
+	dsi->vid = 0;
+	
+	if(screen->dsi_lane > 0 && screen->dsi_lane <= 4)
+		dsi->host.lane = screen->dsi_lane;
+	else
+		dsi->host.lane = 4;
+		
+	dsi->host.video_mode = VM_BM;
+	
+	MIPI_DBG("UI:%d\n", dsi->phy.UI);	
+	MIPI_DBG("ref_clk:%d\n", dsi->phy.ref_clk);
+	MIPI_DBG("pclk:%d, Tpclk:%d\n", dsi->phy.pclk, dsi->phy.Tpclk);
+	MIPI_DBG("sys_clk:%d, Tsys_clk:%d\n", dsi->phy.sys_clk, dsi->phy.Tsys_clk);
+	MIPI_DBG("ddr_clk:%d, Tddr_clk:%d\n", dsi->phy.ddr_clk, dsi->phy.Tddr_clk);
+	MIPI_DBG("txbyte_clk:%d, Ttxbyte_clk:%d\n", dsi->phy.txbyte_clk, 
+				dsi->phy.Ttxbyte_clk);
+	MIPI_DBG("txclkesc:%d, Ttxclkesc:%d\n", dsi->phy.txclkesc, dsi->phy.Ttxclkesc);
+	
+	rk_mipi_dsi_phy_power_up(dsi);
+	rk_mipi_dsi_host_power_up(dsi);
+	rk_mipi_dsi_phy_init(dsi);
+	rk_mipi_dsi_host_init(dsi);
+		
+	/*
+		After the core reset, DPI waits for the first VSYNC active transition to start signal sampling, including
+		pixel data, and preventing image transmission in the middle of a frame.
+	*/
+#if 0	
+	dsi_set_bits(dsi, 0, shutdownz);
+	rk_mipi_dsi_enable_video_mode(dsi, 1);
+#ifdef CONFIG_MFD_RK616
+	rk616_display_router_cfg(dsi_rk616, g_rk29fd_screen, 0);
+#endif
+	dsi_set_bits(dsi, 1, shutdownz);
+#endif
+	return 0;
+}
+
+
+int rk_mipi_dsi_init_lite(struct dsi *dsi)
+{
+	u32 decimals = 1000, i = 0, pre = 0, ref_clk = 0;
+	struct mipi_dsi_screen *screen = &dsi->screen;
+	
+	if(!screen)
+		return -1;
+	
+	if(rk_mipi_dsi_is_active(dsi) == 0)
+		return -1;
+#if defined(CONFIG_MFD_RK616)
+	ref_clk = clk_get_rate(dsi_rk616->mclk);
+#elif defined(CONFIG_ARCH_RK319X)
+	ref_clk = clk_get_rate(dsi->phy.refclk);
+#endif
+	if(dsi->phy.ref_clk == ref_clk)
+		return -1;
+		
+	dsi->phy.ref_clk = ref_clk;
+	dsi->phy.sys_clk = dsi->phy.ref_clk;
+	
+	if((screen->hs_tx_clk <= 80 * MHz) || (screen->hs_tx_clk >= 1000 * MHz))
+		dsi->phy.ddr_clk = 1000 * MHz;    //default is 1HGz
+	else
+		dsi->phy.ddr_clk = screen->hs_tx_clk;
+		
+	decimals = dsi->phy.ref_clk;
+	for(i = 1; i < 6; i++) {
+		pre = dsi->phy.ref_clk / i;
+		if((decimals > (dsi->phy.ddr_clk % pre)) && (dsi->phy.ddr_clk / pre < 512)) {
+			decimals = dsi->phy.ddr_clk % pre;
+			dsi->phy.prediv = i;
+			dsi->phy.fbdiv = dsi->phy.ddr_clk / pre;
+		}	
+		if(decimals == 0) 
+			break;		
+	}
+
+	MIPI_DBG("prediv:%d, fbdiv:%d\n", dsi->phy.prediv, dsi->phy.fbdiv);
+	dsi->phy.ddr_clk = dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv;	
+	dsi->phy.txbyte_clk = dsi->phy.ddr_clk / 8;
+	
+	dsi->phy.txclkesc = 20 * MHz;        // < 20MHz
+	dsi->phy.txclkesc = dsi->phy.txbyte_clk / (dsi->phy.txbyte_clk / dsi->phy.txclkesc + 1);
+	
+	dsi->phy.pclk = div_u64(1000000000000llu, dsi->phy.Tpclk);
+	dsi->phy.Ttxclkesc = div_u64(1000000000000llu, dsi->phy.txclkesc);
+	dsi->phy.Tsys_clk = div_u64(1000000000000llu, dsi->phy.sys_clk);
+	dsi->phy.Tddr_clk = div_u64(1000000000000llu, dsi->phy.ddr_clk);
+	dsi->phy.Ttxbyte_clk = div_u64(1000000000000llu, dsi->phy.txbyte_clk);
+	dsi->phy.UI = dsi->phy.Tddr_clk;
+		
+	MIPI_DBG("UI:%d\n", dsi->phy.UI);	
+	MIPI_DBG("ref_clk:%d\n", dsi->phy.ref_clk);
+	MIPI_DBG("pclk:%d, Tpclk:%d\n", dsi->phy.pclk, dsi->phy.Tpclk);
+	MIPI_DBG("sys_clk:%d, Tsys_clk:%d\n", dsi->phy.sys_clk, dsi->phy.Tsys_clk);
+	MIPI_DBG("ddr_clk:%d, Tddr_clk:%d\n", dsi->phy.ddr_clk, dsi->phy.Tddr_clk);
+	MIPI_DBG("txbyte_clk:%d, Ttxbyte_clk:%d\n", dsi->phy.txbyte_clk, dsi->phy.Ttxbyte_clk);
+	MIPI_DBG("txclkesc:%d, Ttxclkesc:%d\n", dsi->phy.txclkesc, dsi->phy.Ttxclkesc);
+		
+	rk_mipi_dsi_host_power_down(dsi);
+	rk_mipi_dsi_phy_power_down(dsi);
+	rk_mipi_dsi_phy_power_up(dsi);
+	rk_mipi_dsi_phy_init(dsi);
+	//rk_mipi_dsi_host_power_up(dsi);
+	//rk_mipi_dsi_host_init(dsi);
+	//dsi_set_bits(dsi, 0, shutdownz);
+	rk_mipi_dsi_enable_hs_clk(dsi, 1);
+	rk_mipi_dsi_enable_video_mode(dsi, 1);
+	rk_mipi_dsi_is_enable(dsi, 1);
+	return 0;
+}
+
+static int rk_mipi_dsi_is_enable(void *arg, u32 enable)
+{
+	struct dsi *dsi = arg;
+
+	dsi_set_bits(dsi, enable, shutdownz);
+
+	return 0;
+}
+
+static int rk_mipi_dsi_enable_video_mode(void *arg, u32 enable)
+{
+	struct dsi *dsi = arg;
+#ifdef DWC_DSI_VERSION_0x3131302A
+	dsi_set_bits(dsi, enable, en_video_mode);
+#else
+	dsi_set_bits(dsi, !enable, cmd_video_mode);
+#endif
+
+	return 0;
+}
+
+static int rk_mipi_dsi_enable_command_mode(void *arg, u32 enable)
+{
+	struct dsi *dsi = arg;
+#ifdef DWC_DSI_VERSION_0x3131302A
+	dsi_set_bits(dsi, enable, en_cmd_mode);
+#else
+	dsi_set_bits(dsi, enable, cmd_video_mode);
+#endif
+	return 0;
+}
+
+static int rk_mipi_dsi_enable_hs_clk(void *arg, u32 enable)
+{
+	struct dsi *dsi = arg;
+	dsi_set_bits(dsi, enable, phy_txrequestclkhs);
+	return 0;
+}
+
+static int rk_mipi_dsi_is_active(void *arg)
+{
+	struct dsi *dsi = arg;
+	return dsi_get_bits(dsi, shutdownz);
+}
+
+static int rk_mipi_dsi_send_packet(struct dsi *dsi, u32 type, unsigned char regs[], u32 n)
+{
+	u32 data = 0, i = 0, j = 0;
+#ifdef DWC_DSI_VERSION_0x3131302A	
+	u32 flag = 0;
+#endif	
+	if((n == 0) && (type != DTYPE_GEN_SWRITE_0P))
+		return -1;
+#ifndef CONFIG_MFD_RK616
+	if(dsi_get_bits(dsi, gen_cmd_full) == 1) {
+		MIPI_TRACE("gen_cmd_full\n");
+		return -1;
+	}
+#endif	
+
+#ifdef DWC_DSI_VERSION_0x3131302A
+	if(dsi_get_bits(dsi, en_video_mode) == 1) {
+		//rk_mipi_dsi_enable_video_mode(dsi, 0);
+		flag = 1;
+	}
+#endif
+	//rk_mipi_dsi_enable_command_mode(dsi, 1);
+	udelay(10);
+
+	 if(n <= 2) {
+	    if(type ==  0x29)
+	    {
+            printk("type=0x%x\n", type);
+            data = 0;
+        	for(i = 0; i < n; i++) {
+        		j = i % 4;
+        		data |= regs[i] << (j * 8);
+        		if(j == 3 || ((i + 1) == n)) {
+        			#ifndef CONFIG_MFD_RK616
+        			if(dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+        				MIPI_TRACE("gen_pld_w_full :%d\n", i);
+        				break;
+        			}
+        			#endif
+        			dsi_set_bits(dsi, data, GEN_PLD_DATA);
+        			MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+        			data = 0;
+        		}
+        	}
+        	data = (dsi->vid << 6) | type;		
+        	data |= (n & 0xffff) << 8;   
+	    }
+		else 
+		{
+		    if(type == DTYPE_GEN_SWRITE_0P)
+			    data = (dsi->vid << 6) | (n << 4) | type;
+		    else 
+			    data = (dsi->vid << 6) | ((n-1) << 4) | type;
+			    
+        	data |= regs[0] << 8;
+        	if(n == 2)
+        		data |= regs[1] << 16;
+        }
+	} else {
+		data = 0;
+		for(i = 0; i < n; i++) {
+			j = i % 4;
+			data |= regs[i] << (j * 8);
+			if(j == 3 || ((i + 1) == n)) {
+				#ifndef CONFIG_MFD_RK616
+				if(dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+					MIPI_TRACE("gen_pld_w_full :%d\n", i);
+					break;
+				}
+				#endif
+				dsi_set_bits(dsi, data, GEN_PLD_DATA);
+				MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+				data = 0;
+			}
+		}
+		data = (dsi->vid << 6) | type;		
+		data |= (n & 0xffff) << 8;
+	}
+	
+	MIPI_DBG("write GEN_HDR:%08x\n", data);
+	dsi_set_bits(dsi, data, GEN_HDR);
+#ifndef CONFIG_MFD_RK616
+	i = 10;
+	while(!dsi_get_bits(dsi, gen_cmd_empty) && i--) {
+		MIPI_DBG(".");
+		udelay(10);
+	}
+	udelay(10);
+#endif
+
+#ifdef DWC_DSI_VERSION_0x3131302A
+	//rk_mipi_dsi_enable_command_mode(dsi, 0);
+	if(flag == 1) {
+	//	rk_mipi_dsi_enable_video_mode(dsi, 1);
+	}
+#endif
+	return 0;
+}
+
+static int rk_mipi_dsi_send_dcs_packet(void *arg, unsigned char regs[], u32 n)
+{
+	struct dsi *dsi = arg;
+	n -= 1;
+	if((regs[1] ==0x2c) || (regs[1] ==0x3c))
+	{
+	    dsi_set_bits(dsi, regs[0], dcs_sw_0p_tx);
+		rk_mipi_dsi_send_packet(dsi, DTYPE_DCS_LWRITE, regs + 1, n);
+	}else
+	if(n <= 2) {
+		if(n == 1)
+			dsi_set_bits(dsi, regs[0], dcs_sw_0p_tx);
+		else
+			dsi_set_bits(dsi, regs[0], dcs_sw_1p_tx);
+		rk_mipi_dsi_send_packet(dsi, DTYPE_DCS_SWRITE_0P, regs + 1, n);
+	} else {
+		dsi_set_bits(dsi, regs[0], dcs_lw_tx);
+		rk_mipi_dsi_send_packet(dsi, DTYPE_DCS_LWRITE, regs + 1, n);
+	}
+	MIPI_DBG("***%s:%d command sent in %s size:%d\n", __func__, __LINE__, regs[0] ? "LP mode" : "HS mode", n);
+	return 0;
+}
+
+static int rk_mipi_dsi_send_gen_packet(void *arg, void *data, u32 n)
+{
+	struct dsi *dsi = arg;
+	unsigned char *regs = data;
+	n -= 1;
+	if(regs[1] == 0xb3)
+	{
+	    dsi_set_bits(dsi, regs[0], gen_sw_1p_tx);
+		rk_mipi_dsi_send_packet(dsi, DTYPE_GEN_LWRITE, regs + 1, n);
+	}
+	else{ 
+	if(n <= 2) {
+		if(n == 2)
+			dsi_set_bits(dsi, regs[0], gen_sw_2p_tx);
+		else if(n == 1)
+			dsi_set_bits(dsi, regs[0], gen_sw_1p_tx);
+		else 
+			dsi_set_bits(dsi, regs[0], gen_sw_0p_tx);	
+		rk_mipi_dsi_send_packet(dsi, DTYPE_GEN_SWRITE_0P, regs + 1, n);
+	} else {
+		dsi_set_bits(dsi, regs[0], gen_lw_tx);
+		rk_mipi_dsi_send_packet(dsi, DTYPE_GEN_LWRITE, regs + 1, n);
+	}
+	}
+	MIPI_DBG("***%s:%d command sent in %s size:%d\n", __func__, __LINE__, regs[0] ? "LP mode" : "HS mode", n);
+	return 0;
+}
+
+static int rk_mipi_dsi_read_dcs_packet(void *arg, unsigned char *data1, u32 n)
+{
+    struct dsi *dsi = arg;
+	//DCS READ 
+	//unsigned char *regs = data;
+	unsigned char regs[2];
+	regs[0] = LPDT;
+	regs[1] = 0x0a;
+	 n = n - 1;
+	u32 data = 0;
+	
+	dsi_set_bits(dsi, regs[0], dcs_sr_0p_tx);
+	int type = 0x06;
+
+   /* if(type == DTYPE_GEN_SWRITE_0P)
+        data = (dsi->vid << 6) | (n << 4) | type;
+    else 
+        data = (dsi->vid << 6) | ((n-1) << 4) | type;*/
+        
+    data |= regs[1] << 8 | type;
+   // if(n == 2)
+    //    data |= regs[1] << 16;
+
+    MIPI_DBG("write GEN_HDR:%08x\n", data);
+	dsi_set_bits(dsi, data, GEN_HDR);
+    msleep(100);
+    
+   // dsi_set_bits(dsi, regs[0], gen_sr_0p_tx);
+
+    printk("rk_mipi_dsi_read_dcs_packet==0x%x\n",dsi_get_bits(dsi, GEN_PLD_DATA));
+    msleep(100);
+
+  //  dsi_set_bits(dsi, regs[0], max_rd_pkt_size);
+    
+    msleep(100);
+    // printk("_____rk_mipi_dsi_read_dcs_packet==0x%x\n",dsi_get_bits(dsi, GEN_PLD_DATA));
+	
+    msleep(100);
+	return 0;
+}
+
+static int rk_mipi_dsi_power_up(void *arg)
+{
+	struct dsi *dsi = arg;
+	rk_mipi_dsi_phy_power_up(dsi);
+	rk_mipi_dsi_host_power_up(dsi);
+	return 0;
+}
+
+static int rk_mipi_dsi_power_down(void *arg)
+{
+    u8 dcs[4] = {0};
+	struct dsi *dsi = arg;
+	struct mipi_dsi_screen *screen = &dsi->screen;
+	
+	if(!screen)
+		return -1;
+	
+	if(!screen->standby) {
+		rk_mipi_dsi_enable_video_mode(dsi, 0);
+		dcs[0] = HSDT;
+		dcs[1] = dcs_set_display_off; 
+		rk_mipi_dsi_send_dcs_packet(dsi, dcs, 2);
+		msleep(1);
+		dcs[0] = HSDT;
+		dcs[1] = dcs_enter_sleep_mode; 
+		rk_mipi_dsi_send_dcs_packet(dsi, dcs, 2);
+		msleep(1);
+	} else {
+		screen->standby(1);
+	}	
+		
+	rk_mipi_dsi_host_power_down(dsi);
+	rk_mipi_dsi_phy_power_down(dsi);
+#if defined(CONFIG_ARCH_RK319X)
+	clk_disable(dsi->dsi_pd);
+	clk_disable(dsi->dsi_pclk);
+#endif
+	MIPI_TRACE("%s:%d\n", __func__, __LINE__);
+	return 0;
+}
+
+static int rk_mipi_dsi_get_id(void *arg)
+{
+	u32 id = 0;
+	struct dsi *dsi = arg;
+	id = dsi_get_bits(dsi, VERSION);
+	return id;
+}
+
+/* the most top level of mipi dsi init */
+static int rk_mipi_dsi_probe(struct dsi *dsi)
+{
+	int ret = 0;
+	
+	register_dsi_ops(dsi->dsi_id, &dsi->ops);
+	
+	ret = dsi_probe_current_chip(dsi->dsi_id);
+	if(ret) {
+		MIPI_TRACE("mipi dsi probe fail\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+#ifdef MIPI_DSI_REGISTER_IO
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+
+int reg_proc_write(struct file *file, const char __user *buff, size_t count, loff_t *offp)
+{
+	int ret = -1, i = 0;
+	u32 read_val = 0;
+	char *buf = kmalloc(count, GFP_KERNEL);
+	char *data = buf;
+	char str[32];
+	char command = 0;
+	u64 regs_val = 0;
+	memset(buf, 0, count);
+	ret = copy_from_user((void*)buf, buff, count);
+	data = strstr(data, "-");
+	if(data == NULL)
+		goto reg_proc_write_exit;
+	command = *(++data);
+	switch(command) {
+		case 'w':
+			while(1) {
+				data = strstr(data, "0x");
+				if(data == NULL)
+					goto reg_proc_write_exit;
+
+				sscanf(data, "0x%llx", &regs_val);
+				if((regs_val & 0xffff00000000ULL) == 0)
+					goto reg_proc_write_exit;
+				read_val = regs_val & 0xffffffff;
+				printk("regs_val=0x%llx\n",regs_val);
+				dsi_write_reg(dsi0, regs_val >> 32, &read_val);
+				dsi_read_reg(dsi0, regs_val >> 32, &read_val);
+				regs_val &= 0xffffffff;
+				if(read_val != regs_val)
+					MIPI_TRACE("%s fail:0x%08x\n", __func__, read_val);					
+				data += 3;
+				msleep(1);	
+			}
+		
+			break;
+		case 'r':
+				data = strstr(data, "0x");
+				if(data == NULL){
+					goto reg_proc_write_exit;
+				}
+				sscanf(data, "0x%llx", &regs_val);
+				dsi_read_reg(dsi0, (u16)regs_val, &read_val);
+				MIPI_TRACE("*%04x : %08x\n", (u16)regs_val, read_val);
+				msleep(1);	
+			break;	
+	
+		case 's':
+				while(*(++data) == ' ');
+				sscanf(data, "%d", &read_val);
+				if(read_val == 11)
+					read_val = 11289600;
+				else	
+					read_val *= MHz;
+#ifdef CONFIG_MFD_RK616
+				clk_set_rate(dsi_rk616->mclk, read_val);	
+#endif
+				//rk_mipi_dsi_init_lite(dsi);
+			break;
+		case 'd':
+		case 'g':
+		case 'c':
+				while(*(++data) == ' ');
+				i = 0;
+				MIPI_TRACE("****%d:%d\n", data-buf, count);
+				
+				do {
+					if(i > 31) {
+						MIPI_TRACE("payload entry is larger than 32\n");
+						break;
+					}	
+					sscanf(data, "%x,", str + i);   //-c 1,29,02,03,05,06,> pro
+					data = strstr(data, ",");
+					if(data == NULL)
+						break;
+					data++;	
+					i++;
+				} while(1);
+				read_val = i;
+				
+				i = 2;
+				while(i--) {
+					msleep(10);
+					if(command == 'd')
+						rk_mipi_dsi_send_dcs_packet(dsi0, str, read_val);
+					else
+						rk_mipi_dsi_send_gen_packet(dsi0, str, read_val);
+				}	
+				i = 1;
+				while(i--) {
+					msleep(1000);
+				}
+			break;
+	
+		default:
+			break;
+	}
+
+reg_proc_write_exit:
+	kfree(buf);
+	msleep(20);
+ 	return count;
+}
+
+int reg_proc_read(struct file *file, char __user *buff, size_t count, 
+					loff_t *offp)
+{
+	int i = 0;
+	u32 val = 0;
+
+
+    for(i = VERSION; i < (VERSION + (0xdc<<16)); i += 4<<16) {
+		val = dsi_get_bits(dsi0, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+
+	MIPI_TRACE("\n");
+	/*for(i = DPHY_REGISTER0; i <= DPHY_REGISTER4; i += 4<<16) {
+		val = dsi_get_bits(dsi0, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+	MIPI_TRACE("\n");
+	i = DPHY_REGISTER20;
+	val = dsi_get_bits(dsi0, i);
+	MIPI_TRACE("%04x: %08x\n", i>>16, val);
+	msleep(1);
+
+	MIPI_TRACE("\n");
+	for(i = (DPHY_CLOCK_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_CLOCK_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi0, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+	
+	MIPI_TRACE("\n");
+	for(i = (DPHY_LANE0_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_LANE0_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi0, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+
+	MIPI_TRACE("\n");
+	for(i = (DPHY_LANE1_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_LANE1_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi0, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+
+	MIPI_TRACE("\n");
+	for(i = (DPHY_LANE2_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_LANE2_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi0, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+	
+	MIPI_TRACE("\n");
+	for(i = (DPHY_LANE3_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_LANE3_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi0, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}*/
+	return -1;
+}
+
+int reg_proc_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+int reg_proc_close(struct inode *inode, struct file *file)
+{
+	return 0;   
+}
+
+struct file_operations reg_proc_fops = {
+    .owner  = THIS_MODULE,
+	.open   = reg_proc_open,
+	.release= reg_proc_close,
+	.write  = reg_proc_write,
+	.read   = reg_proc_read,
+};
+
+
+int reg_proc_write1(struct file *file, const char __user *buff, size_t count, loff_t *offp)
+{
+	int ret = -1, i = 0;
+	u32 read_val = 0;
+	char *buf = kmalloc(count, GFP_KERNEL);
+	char *data = buf;
+	char str[32];
+	char command = 0;
+	u64 regs_val = 0;
+	memset(buf, 0, count);
+	ret = copy_from_user((void*)buf, buff, count);
+	
+	data = strstr(data, "-");
+	if(data == NULL)
+		goto reg_proc_write_exit;
+	command = *(++data);
+	
+	switch(command) {
+		case 'w':
+			while(1) {
+		
+				data = strstr(data, "0x");
+				if(data == NULL)
+					goto reg_proc_write_exit;
+				sscanf(data, "0x%llx", &regs_val);
+				if((regs_val & 0xffff00000000ULL) == 0)
+					goto reg_proc_write_exit;
+				read_val = regs_val & 0xffffffff;
+				dsi_write_reg(dsi1, regs_val >> 32, &read_val);
+				dsi_read_reg(dsi1, regs_val >> 32, &read_val);
+				regs_val &= 0xffffffff;
+				if(read_val != regs_val)
+					MIPI_TRACE("%s fail:0x%08x\n", __func__, read_val);	
+				
+				data += 3;
+				msleep(1);	
+			}
+		
+			break;
+		case 'r':
+				data = strstr(data, "0x");
+				if(data == NULL)
+					goto reg_proc_write_exit;
+				sscanf(data, "0x%llx", &regs_val);
+				dsi_read_reg(dsi1, (u16)regs_val, &read_val);
+				MIPI_TRACE("*%04x : %08x\n", (u16)regs_val, read_val);
+				msleep(1);	
+			break;	
+	
+		case 's':
+				while(*(++data) == ' ');
+				sscanf(data, "%d", &read_val);
+				if(read_val == 11)
+					read_val = 11289600;
+				else	
+					read_val *= MHz;
+#ifdef CONFIG_MFD_RK616
+				clk_set_rate(dsi_rk616->mclk, read_val);	
+#endif
+				//rk_mipi_dsi_init_lite(dsi);
+			break;
+		case 'd':
+		case 'g':
+		case 'c':
+				while(*(++data) == ' ');
+				i = 0;
+				MIPI_TRACE("****%d:%d\n", data-buf, count);
+				
+				do {
+					if(i > 31) {
+						MIPI_TRACE("payload entry is larger than 32\n");
+						break;
+					}	
+					sscanf(data, "%x,", str + i);   //-c 1,29,02,03,05,06,> pro
+					data = strstr(data, ",");
+					if(data == NULL)
+						break;
+					data++;	
+					i++;
+				} while(1);
+				read_val = i;
+				
+				i = 2;
+				while(i--) {
+					msleep(10);
+					if(command == 'd')
+						rk_mipi_dsi_send_dcs_packet(dsi1, str, read_val);
+					else
+						rk_mipi_dsi_send_gen_packet(dsi1, str, read_val);
+				}	
+				i = 1;
+				while(i--) {
+					msleep(1000);
+				}
+			break;
+	
+		default:
+			break;
+	}
+
+reg_proc_write_exit:
+	kfree(buf);
+	msleep(20);
+ 	return count;
+}
+
+int reg_proc_read1(struct file *file, char __user *buff, size_t count, 
+					loff_t *offp)
+{
+	int i = 0;
+	u32 val = 0;
+	
+	for(i = VERSION; i < (VERSION + (0xdc<<16)); i += 4<<16) {
+		val = dsi_get_bits(dsi1, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+	
+	MIPI_TRACE("\n");
+/*	for(i = DPHY_REGISTER0; i <= DPHY_REGISTER4; i += 4<<16) {
+		val = dsi_get_bits(dsi1, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+	MIPI_TRACE("\n");
+	i = DPHY_REGISTER20;
+	val = dsi_get_bits(dsi1, i);
+	MIPI_TRACE("%04x: %08x\n", i>>16, val);
+	msleep(1);
+
+	MIPI_TRACE("\n");
+	for(i = (DPHY_CLOCK_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_CLOCK_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi1, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+	
+	MIPI_TRACE("\n");
+	for(i = (DPHY_LANE0_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_LANE0_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi1, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+
+	MIPI_TRACE("\n");
+	for(i = (DPHY_LANE1_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_LANE1_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi1, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+
+	MIPI_TRACE("\n");
+	for(i = (DPHY_LANE2_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_LANE2_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi1, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}
+	
+	MIPI_TRACE("\n");
+	for(i = (DPHY_LANE3_OFFSET + DSI_DPHY_BITS(0x0000, 32, 0)); i <= ((DPHY_LANE3_OFFSET + DSI_DPHY_BITS(0x0048, 32, 0))); i += 4<<16) {
+		val = dsi_get_bits(dsi1, i);
+		MIPI_TRACE("%04x: %08x\n", i>>16, val);
+		msleep(1);
+	}*/
+	return -1;
+}
+
+int reg_proc_open1(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+int reg_proc_close1(struct inode *inode, struct file *file)
+{
+	return 0;   
+}
+
+struct file_operations reg_proc_fops1 = {
+    .owner  = THIS_MODULE,
+	.open   = reg_proc_open1,
+	.release= reg_proc_close1,
+	.write  = reg_proc_write1,
+	.read   = reg_proc_read1,
+};
+
+#if 0
+static int reg_proc_init(char *name)
+{
+	int ret = 0;
+#if 0	
+#ifdef CONFIG_MFD_RK616
+	//debugfs_create_file("mipi", S_IRUSR, dsi_rk616->debugfs_dir, dsi_rk616, 
+							&reg_proc_fops);
+#endif	
+#else
+	static struct proc_dir_entry *reg_proc_entry;
+  	reg_proc_entry = create_proc_entry(name, 0666, NULL);
+	/*if(reg_proc_entry == NULL) {
+		//MIPI_TRACE("Couldn't create proc entry : %s!\n", name);
+		ret = -ENOMEM;
+		return ret;
+	}
+	else {
+		MIPI_TRACE("Create proc entry:%s success!\n", name);
+		reg_proc_entry->proc_fops = &reg_proc_fops;
+	}*/
+#endif	
+	return ret;
+}
+
+static int __init rk_mipi_dsi_reg(void)
+{
+	return 0;//reg_proc_init("mipi_dsi");
+}
+module_init(rk_mipi_dsi_reg);
+#endif
+#endif
+
+
+#ifdef CONFIG_MIPI_DSI_FT
+static struct mipi_dsi_screen ft_screen;
+
+static u32 fre_to_period(u32 fre)
+{
+	u32 interger = 0;
+	u32 decimals = 0;
+	interger = 1000000000UL / fre;
+	decimals = 1000000000UL % fre;
+	if(decimals <= 40000000)
+		decimals = (decimals * 100) / (fre/10);
+	else if(decimals <= 400000000)
+		decimals = (decimals * 10) / (fre/100);
+	else
+		decimals = decimals / (fre/1000);
+	interger = interger * 1000 + decimals;
+	
+	return interger;
+}
+
+static int rk616_mipi_dsi_set_screen_info(void)
+{
+	g_screen = &ft_screen;
+	g_screen->type = SCREEN_MIPI;
+	g_screen->face = MIPI_DSI_OUT_FACE;
+	g_screen->pixclock = MIPI_DSI_DCLK;
+	g_screen->left_margin = MIPI_DSI_H_BP;
+	g_screen->right_margin = MIPI_DSI_H_FP;
+	g_screen->hsync_len = MIPI_DSI_H_PW;
+	g_screen->upper_margin = MIPI_DSI_V_BP;
+	g_screen->lower_margin = MIPI_DSI_V_FP;
+	g_screen->vsync_len = MIPI_DSI_V_PW;
+	g_screen->x_res = MIPI_DSI_H_VD;
+	g_screen->y_res = MIPI_DSI_V_VD;
+	g_screen->pin_hsync = MIPI_DSI_HSYNC_POL;
+	g_screen->pin_vsync = MIPI_DSI_VSYNC_POL;
+	g_screen->pin_den = MIPI_DSI_DEN_POL;
+	g_screen->pin_dclk = MIPI_DSI_DCLK_POL;
+	g_screen->dsi_lane = MIPI_DSI_LANE;
+	g_screen->hs_tx_clk = MIPI_DSI_HS_CLK;
+	g_screen->init = NULL;
+	g_screen->standby = NULL;
+	return 0;
+}
+
+int rk616_mipi_dsi_ft_init(void) 
+{
+	rk616_mipi_dsi_set_screen_info();
+	rk_mipi_dsi_init(g_screen, 0);
+	return 0;
+}
+#endif  /* end of CONFIG_MIPI_DSI_FT */
+
+#ifdef CONFIG_MIPI_DSI_LINUX
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void  rk616_mipi_dsi_suspend(void)
+{
+	u8 dcs[4] = {0};
+	
+	if(!g_screen->standby) {
+		rk_mipi_dsi_enable_video_mode(dsi, 0);
+		dcs[0] = HSDT;
+		dcs[1] = dcs_set_display_off; 
+		rk_mipi_dsi_send_dcs_packet(dsi, dcs, 2);
+		msleep(1);
+		dcs[0] = HSDT;
+		dcs[1] = dcs_enter_sleep_mode; 
+		rk_mipi_dsi_send_dcs_packet(dsi, dcs, 2);
+		msleep(1);
+	} else {
+		g_screen->standby(1);
+	}	
+		
+	rk_mipi_dsi_host_power_down(dsi);
+	rk_mipi_dsi_phy_power_down(dsi);
+#if defined(CONFIG_ARCH_RK319X)
+	clk_disable(dsi->dsi_pd);
+	clk_disable(dsi->dsi_pclk);
+#endif
+	MIPI_TRACE("%s:%d\n", __func__, __LINE__);
+}
+
+void rk616_mipi_dsi_resume(void)
+{
+	u8 dcs[4] = {0};
+#if defined(CONFIG_ARCH_RK319X)
+	clk_enable(dsi->dsi_pd);
+	clk_enable(dsi->dsi_pclk);
+#endif
+	rk_mipi_dsi_phy_power_up(dsi);
+	rk_mipi_dsi_host_power_up(dsi);
+
+#ifdef CONFIG_MFD_RK616
+	rk_mipi_recover_reg();
+#else
+	rk_mipi_dsi_phy_init(dsi);
+	rk_mipi_dsi_host_init(dsi);
+#endif
+
+/*	if(!g_screen->standby) {
+		rk_mipi_dsi_enable_hs_clk(dsi, 1);
+		dcs[0] = HSDT;
+		dcs[1] = dcs_exit_sleep_mode;
+		rk_mipi_dsi_send_dcs_packet(dsi, dcs, 2);
+		msleep(1);
+		dcs[0] = HSDT;
+		dcs[1] = dcs_set_display_on;
+		rk_mipi_dsi_send_dcs_packet(dsi, dcs, 2);
+		//msleep(10);
+	} else {
+		g_screen->standby(0);
+	}*/
+	
+	rk_mipi_dsi_is_enable(dsi, 0);
+	rk_mipi_dsi_enable_video_mode(dsi, 1);
+	
+#ifdef CONFIG_MFD_RK616	
+	dsi_rk616->resume = 1;
+	rk616_display_router_cfg(dsi_rk616, g_rk29fd_screen, 0);
+	dsi_rk616->resume = 0;
+#endif	
+	rk_mipi_dsi_is_enable(dsi, 1, shutdownz);
+	MIPI_TRACE("%s:%d\n", __func__, __LINE__);
+}
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void rk616_mipi_dsi_early_suspend(struct early_suspend *h)
+{
+    rk616_mipi_dsi_suspend();
+}
+
+static void rk616_mipi_dsi_late_resume(struct early_suspend *h)
+{
+    rk616_mipi_dsi_resume();
+}
+#endif  /* end of CONFIG_HAS_EARLYSUSPEND */
+#endif
+
+
+#ifdef CONFIG_MFD_RK616
+static int rk616_mipi_dsi_notifier_event(struct notifier_block *this,
+		unsigned long event, void *ptr) {
+   
+#ifdef CONFIG_RK616_MIPI_DSI_RST
+   if(event == 1)
+    {
+        g_screen->standby(0);
+        mdelay(5);
+        rk616_mipi_dsi_suspend();
+        mdelay(10);
+    }
+    else if(event == 2)
+    {
+        rk_mipi_dsi_init_lite(dsi);
+        mdelay(5);
+        g_screen->standby(1);
+        mdelay(5);
+        rk616_mipi_dsi_resume();
+    }
+#else
+      	rk_mipi_dsi_init_lite(dsi);
+#endif
+	return 0;
+}		
+
+struct notifier_block mipi_dsi_nb= {
+	.notifier_call = rk616_mipi_dsi_notifier_event,
+};
+#endif
+
+#ifndef CONFIG_MFD_RK616
+static irqreturn_t rk616_mipi_dsi_irq_handler(int irq, void *data)
+{
+	return IRQ_HANDLED;
+	//return IRQ_NONE;
+}
+#endif
+
+static int rk32_dsi_enable(void)
+{   
+    MIPI_DBG("rk32_dsi_enable-------\n");
+    
+    dsi_init(0, NULL, 0);
+    if (rk_mipi_get_dsi_num() ==2)
+        dsi_init(1, NULL, 0);
+		
+    rk_mipi_screen_standby(0);    
+
+	/*
+		After the core reset, DPI waits for the first VSYNC active transition to start signal sampling, including
+		pixel data, and preventing image transmission in the middle of a frame.
+	*/
+    dsi_is_enable(0, 0);
+    if (rk_mipi_get_dsi_num() ==2)
+        dsi_is_enable(1, 0);     
+
+    dsi_enable_video_mode(0, 1);
+    dsi_enable_video_mode(1, 1);
+
+#ifdef CONFIG_MFD_RK616
+        rk616_display_router_cfg(dsi_rk616, g_rk29fd_screen, 0);
+#endif
+
+    dsi_is_enable(0, 1);
+    if (rk_mipi_get_dsi_num() ==2)
+        dsi_is_enable(1, 1);
+
+    return 0;
+}
+
+static int rk32_dsi_disable(void)
+{
+    MIPI_DBG("rk32_dsi_disable-------\n");
+    
+	rk_mipi_screen_standby(1); 
+    dsi_power_off(0);
+    if (rk_mipi_get_dsi_num() ==2)
+        dsi_power_off(1);
+    
+    return 0;
+}
+
+
+static struct rk_fb_trsm_ops trsm_dsi_ops = 
+{
+    .enable = rk32_dsi_enable,
+    .disable = rk32_dsi_disable,
+};
+
+static void rk32_init_phy_mode(int lcdc_id)
+{ 
+    int val0 = 0, val1 = 0;
+
+    MIPI_DBG("rk32_init_phy_mode----------lcdc_id=%d\n",lcdc_id);
+    //D-PHY mode select
+    if( rk_mipi_get_dsi_num() ==1 ){
+    
+        if(lcdc_id == 1)
+        //val0 =0x1 << 25 | 0x1 << 9;
+           val0 = 0x1 << 22 | 0x1 << 6;  //1'b1: VOP LIT output to DSI host0;1'b0: VOP BIG output to DSI host0
+        else
+           val0 = 0x1 << 22 | 0x0 << 6; 
+
+        writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
+    }
+    else{
+        if(lcdc_id == 1){
+            val0 = 0x1 << 25 | 0x1 <<  9 | 0x1 << 22 | 0x1 <<  6; 
+            val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14; 
+         }
+         else{
+            val0 = 0x1 << 25 | 0x0 <<  9 | 0x1 << 22 | 0x0 << 14; 
+            val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14;        
+         }
+         
+         writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
+         writel_relaxed(val1, RK_GRF_VIRT + RK3288_GRF_SOC_CON14);    
+    }
+
+}
+
+static int rk616_mipi_dsi_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct dsi *dsi;
+	struct mipi_dsi_ops *ops;
+	struct rk_screen *screen;
+	struct mipi_dsi_screen *dsi_screen;
+	static int id = 0;
+	
+#if defined(CONFIG_ARCH_RK319X) || defined(CONFIG_ARCH_RK3288)
+	struct resource *res_host, *res_phy, *res_irq;
+#endif
+#if defined(CONFIG_MFD_RK616)
+	struct mfd_rk616 *rk616;
+#endif
+	dsi = devm_kzalloc(&pdev->dev, sizeof(struct dsi), GFP_KERNEL);
+	if(!dsi) {
+		dev_err(&pdev->dev,"request struct dsi fail!\n");
+		return -ENOMEM;
+	}
+
+#if defined(CONFIG_MFD_RK616)
+	rk616 = dev_get_drvdata(pdev->dev.parent);
+	if(!rk616) {
+		dev_err(&pdev->dev,"null mfd device rk616!\n");
+		ret = -ENODEV;
+		goto probe_err1;
+	} else {
+		dsi_rk616 = rk616;
+	}
+	clk_notifier_register(rk616->mclk, &mipi_dsi_nb);
+#elif defined(CONFIG_ARCH_RK319X)
+	res_host = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_dsi_host");
+	if (!res_host) {
+		dev_err(&pdev->dev, "get resource mipi_dsi_host fail\n");
+		ret = -EINVAL;
+		goto probe_err1;
+	}
+	if (!request_mem_region(res_host->start, resource_size(res_host), pdev->name)) {
+		dev_err(&pdev->dev, "host memory region already claimed\n");
+		ret = -EBUSY;
+		goto probe_err1;
+	}
+	dsi->host.iobase = res_host->start;
+	dsi->host.membase = ioremap_nocache(res_host->start, resource_size(res_host));
+	if (!dsi->host.membase) {
+		dev_err(&pdev->dev, "ioremap mipi_dsi_host fail\n");
+		ret = -ENXIO;
+		goto probe_err2;
+	}
+
+	res_phy = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_dsi_phy");
+	if (!res_phy) {
+		dev_err(&pdev->dev, "get resource mipi_dsi_phy fail\n");
+		ret = -EINVAL;
+		goto probe_err3;
+	}
+	if (!request_mem_region(res_phy->start, resource_size(res_phy), pdev->name)) {
+		dev_err(&pdev->dev, "phy memory region already claimed\n");
+		ret = -EBUSY;
+		goto probe_err3;
+	}
+	dsi->phy.iobase = res_phy->start;
+	dsi->phy.membase = ioremap_nocache(res_phy->start, resource_size(res_phy));
+	if (!dsi->phy.membase) {
+		dev_err(&pdev->dev, "ioremap mipi_dsi_phy fail\n");
+		ret = -ENXIO;
+		goto probe_err4;
+	}
+
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res_irq) {
+		dev_err(&pdev->dev, "get resource mipi_dsi irq fail\n");
+		ret = -EINVAL;
+		goto probe_err5;
+	}
+	dsi->host.irq = res_irq->start;
+	ret = request_irq(dsi->host.irq, rk616_mipi_dsi_irq_handler, 0,
+					dev_name(&pdev->dev), dsi);
+	if(ret) {
+		dev_err(&pdev->dev, "request mipi_dsi irq fail\n");
+		ret = -EINVAL;
+		goto probe_err5;
+	}
+	disable_irq(dsi->host.irq);
+	
+	dsi->phy.refclk = clk_get(NULL, "mipi_ref");
+	if (unlikely(IS_ERR(dsi->phy.refclk))) {
+		dev_err(&pdev->dev, "get mipi_ref clock fail\n");
+		ret = PTR_ERR(dsi->phy.refclk);
+		goto probe_err6;
+	}
+	dsi->dsi_pclk = clk_get(NULL, "pclk_mipi_dsi");
+	if (unlikely(IS_ERR(dsi->dsi_pclk))) {
+		dev_err(&pdev->dev, "get pclk_mipi_dsi clock fail\n");
+		ret = PTR_ERR(dsi->dsi_pclk);
+		goto probe_err7;
+	}
+	dsi->dsi_pd = clk_get(NULL, "pd_mipi_dsi");
+	if (unlikely(IS_ERR(dsi->dsi_pd))) {
+		dev_err(&pdev->dev, "get pd_mipi_dsi clock fail\n");
+		ret = PTR_ERR(dsi->dsi_pd);
+		goto probe_err8;
+	}
+
+	clk_enable(dsi->dsi_pd);
+	clk_enable(dsi->dsi_pclk);
+	clk_enable(clk_get(NULL, "pclk_mipiphy_dsi"));
+
+#elif defined(CONFIG_ARCH_RK3288)
+
+	res_host = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dsi->host.membase = devm_request_and_ioremap(&pdev->dev, res_host);
+	if (!dsi->host.membase)
+		return -ENOMEM;
+
+    dsi->phy.refclk  = devm_clk_get(&pdev->dev, "clk_mipi_24m"); 
+	if (unlikely(IS_ERR(dsi->phy.refclk))) {
+		dev_err(&pdev->dev, "get mipi_ref clock fail\n");
+		ret = PTR_ERR(dsi->phy.refclk);
+		//goto probe_err6;
+	}
+
+   dsi->dsi_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi");
+   if (unlikely(IS_ERR(dsi->dsi_pclk))) {
+       dev_err(&pdev->dev, "get pclk_mipi_dsi clock fail\n");
+       ret = PTR_ERR(dsi->dsi_pclk);
+       //goto probe_err7;
+   }
+
+    
+
+   // printk("dsi->phy.refclk =%x\n",dsi->phy.refclk);
+    
+    //clk_prepare_enable(dsi->phy.refclk);
+
+    //clk_disable_unprepare(dsi->phy.refclk);
+
+		
+	dsi->host.irq = platform_get_irq(pdev, 0);
+	if (dsi->host.irq < 0) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return dsi->host.irq;
+	}
+	
+	ret = request_irq(dsi->host.irq, rk616_mipi_dsi_irq_handler, 0,dev_name(&pdev->dev), dsi);
+	if(ret) {
+		dev_err(&pdev->dev, "request mipi_dsi irq fail\n");
+		ret = -EINVAL;
+		goto probe_err1;
+	}
+    printk("dsi->host.irq =%d\n",dsi->host.irq); 
+
+    disable_irq(dsi->host.irq);
+
+#endif  /* CONFIG_MFD_RK616 */
+
+	screen = devm_kzalloc(&pdev->dev, sizeof(struct rk_screen), GFP_KERNEL);
+	if(!screen) {
+		dev_err(&pdev->dev,"request struct rk_screen fail!\n");
+		goto probe_err9;
+	}
+	rk_fb_get_prmry_screen(screen);
+
+#ifdef CONFIG_MFD_RK616
+	g_rk29fd_screen = screen;
+#endif
+
+	dsi->pdev = pdev;
+	ops = &dsi->ops;
+	ops->dsi = dsi;
+	ops->id = DWC_DSI_VERSION,
+	ops->get_id = rk_mipi_dsi_get_id,
+	ops->dsi_send_packet = rk_mipi_dsi_send_gen_packet,
+	ops->dsi_send_dcs_packet = rk_mipi_dsi_send_dcs_packet,
+	ops->dsi_read_dcs_packet = rk_mipi_dsi_read_dcs_packet,
+	ops->dsi_enable_video_mode = rk_mipi_dsi_enable_video_mode,
+	ops->dsi_enable_command_mode = rk_mipi_dsi_enable_command_mode,
+	ops->dsi_enable_hs_clk = rk_mipi_dsi_enable_hs_clk,
+	ops->dsi_is_active = rk_mipi_dsi_is_active,
+	ops->dsi_is_enable= rk_mipi_dsi_is_enable,
+	ops->power_up = rk_mipi_dsi_power_up,
+	ops->power_down = rk_mipi_dsi_power_down,
+	ops->dsi_init = rk_mipi_dsi_init,
+
+	dsi_screen = &dsi->screen;
+	dsi_screen->type = screen->type;
+	dsi_screen->face = screen->face;
+	dsi_screen->lcdc_id = screen->lcdc_id;
+	dsi_screen->screen_id = screen->screen_id;
+	dsi_screen->pixclock = screen->mode.pixclock;
+	dsi_screen->left_margin = screen->mode.left_margin;
+	dsi_screen->right_margin = screen->mode.right_margin;
+	dsi_screen->hsync_len = screen->mode.hsync_len;
+	dsi_screen->upper_margin = screen->mode.upper_margin;
+	dsi_screen->lower_margin = screen->mode.lower_margin;
+	dsi_screen->vsync_len = screen->mode.vsync_len;
+	dsi_screen->x_res = screen->mode.xres;
+	dsi_screen->y_res = screen->mode.yres;
+	dsi_screen->pin_hsync = screen->pin_hsync;
+    dsi_screen->pin_vsync = screen->pin_vsync;
+	dsi_screen->pin_den = screen->pin_den;
+	dsi_screen->pin_dclk = screen->pin_dclk;
+    dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
+//  dsi_screen->dsi_video_mode = screen->dsi_video_mode; //no sure
+	dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
+	dsi_screen->hs_tx_clk = rk_mipi_get_dsi_clk();  
+	dsi_screen->lcdc_id = 1;
+    
+	dsi->dsi_id = id++;//of_alias_get_id(pdev->dev.of_node, "dsi");
+
+	sprintf(ops->name, "rk_mipi_dsi.%d", dsi->dsi_id);
+	platform_set_drvdata(pdev, dsi);
+
+#ifdef CONFIG_MFD_RK616
+	host_mem = kzalloc(MIPI_DSI_HOST_SIZE, GFP_KERNEL);
+	if(!host_mem) {
+		dev_err(&pdev->dev,"request host_mem fail!\n");
+		ret = -ENOMEM;
+		goto probe_err10;
+	}
+	phy_mem = kzalloc(MIPI_DSI_PHY_SIZE, GFP_KERNEL);
+	if(!phy_mem) {
+		kfree(host_mem);
+		dev_err(&pdev->dev,"request phy_mem fail!\n");
+		ret = -ENOMEM;
+		goto probe_err10;
+	}
+	
+	memset(host_mem, 0xaa, MIPI_DSI_HOST_SIZE);	
+	memset(phy_mem, 0xaa, MIPI_DSI_PHY_SIZE);
+#endif
+
+	ret = rk_mipi_dsi_probe(dsi);
+	if(ret) {
+		dev_err(&pdev->dev,"rk mipi_dsi probe fail!\n");
+		dev_err(&pdev->dev,"%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
+		goto probe_err11;
+	}	
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	dsi->early_suspend.suspend = rk616_mipi_dsi_early_suspend;
+	dsi->early_suspend.resume = rk616_mipi_dsi_late_resume;
+	dsi->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	register_early_suspend(&dsi->early_suspend);
+#endif
+    
+    if(id == 1){
+        rk32_init_phy_mode(dsi_screen->lcdc_id);
+        rk_fb_trsm_ops_register(&trsm_dsi_ops, SCREEN_MIPI);
+        
+#ifdef MIPI_DSI_REGISTER_IO        
+		debugfs_create_file("mipidsi0", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi, 
+							&reg_proc_fops);
+#endif
+        dsi0 = dsi;
+        
+    }else{   
+        dsi1 = dsi;
+        
+#ifdef MIPI_DSI_REGISTER_IO  
+        debugfs_create_file("mipidsi1", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi, 
+							&reg_proc_fops1);
+#endif
+
+    }
+    
+	dev_info(&pdev->dev,"rk mipi_dsi probe success!\n");
+	dev_info(&pdev->dev,"%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
+	return 0;
+
+probe_err11:
+#ifdef CONFIG_MFD_RK616
+	kfree(host_mem);
+	kfree(phy_mem);
+probe_err10:
+#endif
+
+probe_err9:
+#if defined(CONFIG_ARCH_RK319X)
+	clk_put(dsi->dsi_pd);
+probe_err8:
+	clk_put(dsi->dsi_pclk);
+probe_err7:
+	clk_put(dsi->phy.refclk);
+probe_err6:
+	free_irq(dsi->host.irq, dsi);
+probe_err5:
+	iounmap(dsi->phy.membase);
+probe_err4:
+	release_mem_region(res_phy->start, resource_size(res_phy));
+probe_err3:
+	iounmap(dsi->host.membase);
+probe_err2:
+	release_mem_region(res_host->start, resource_size(res_host));
+#endif
+
+probe_err1:
+
+	return ret;
+	
+}
+
+static int rk616_mipi_dsi_remove(struct platform_device *pdev)
+{
+	//struct dsi *dsi = platform_get_drvdata(pdev);
+#ifdef CONFIG_MFD_RK616
+	clk_notifier_unregister(dsi_rk616->mclk, &mipi_dsi_nb);
+#endif
+	return 0;
+}
+
+static void rk616_mipi_dsi_shutdown(struct platform_device *pdev)
+{
+	u8 dcs[4] = {0};
+	struct dsi *dsi = platform_get_drvdata(pdev);	
+
+	if(!dsi->screen.standby) {
+		rk_mipi_dsi_enable_video_mode(dsi, 0);
+		dcs[0] = HSDT;
+		dcs[1] = dcs_set_display_off; 
+		rk_mipi_dsi_send_dcs_packet(dsi, dcs, 2);
+		msleep(1);
+		dcs[0] = HSDT;
+		dcs[1] = dcs_enter_sleep_mode; 
+		rk_mipi_dsi_send_dcs_packet(dsi, dcs, 2);
+		msleep(1);
+	} else {
+		dsi->screen.standby(1);
+	}
+
+	rk_mipi_dsi_host_power_down(dsi);
+	rk_mipi_dsi_phy_power_down(dsi);
+
+	MIPI_TRACE("%s:%d\n", __func__, __LINE__);
+	return;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id of_rk_mipi_dsi_match[] = {
+	{ .compatible = "rockchip,rk32-dsi" }, 
+	{ /* Sentinel */ } 
+}; 
+#endif
+
+static struct platform_driver rk616_mipi_dsi_driver = {
+	.driver		= {
+		.name	= "rk616-mipi",
+#ifdef CONFIG_OF
+		.of_match_table	= of_rk_mipi_dsi_match,
+#endif
+		.owner	= THIS_MODULE,
+	},
+	.probe		= rk616_mipi_dsi_probe,
+	.remove		= rk616_mipi_dsi_remove,
+	.shutdown	= rk616_mipi_dsi_shutdown,
+};
+
+static int __init rk616_mipi_dsi_init(void)
+{
+	return platform_driver_register(&rk616_mipi_dsi_driver);
+}
+fs_initcall(rk616_mipi_dsi_init);
+
+static void __exit rk616_mipi_dsi_exit(void)
+{
+	platform_driver_unregister(&rk616_mipi_dsi_driver);
+}
+module_exit(rk616_mipi_dsi_exit);
+#endif  /* end of CONFIG_MIPI_DSI_LINUX */
diff -Nupr a/drivers/video/rockchip/transmitter/rk616_mipi_dsi.h b/drivers/video/rockchip/transmitter/rk616_mipi_dsi.h
--- a/drivers/video/rockchip/transmitter/rk616_mipi_dsi.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/rk616_mipi_dsi.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,453 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+drivers/video/rockchip/transmitter/rk616_mipi_dsi.h
+*/
+#include <linux/rockchip/grf.h>
+#ifndef RK616_MIPI_DSI_H
+#define RK616_MIPI_DSI_H
+
+#define MIPI_DSI_PHY_OFFSET		0x0C00
+#define MIPI_DSI_PHY_SIZE		0x34c
+#define MIPI_DSI_HOST_OFFSET	0x1000
+
+#ifdef DWC_DSI_VERSION_0x3131302A
+#define MIPI_DSI_HOST_SIZE		0x74
+#else
+#define MIPI_DSI_HOST_SIZE		0xcc
+#endif
+
+//function bits definition    register addr | bits | offest
+#define REG_ADDR(a)			((a) << 16)
+#define REG_BITS(a)			((a) << 8)
+#define BITS_OFFSET(a)		(a)
+#define DSI_HOST_BITS(addr, bits, bit_offset)  (REG_ADDR((addr)+MIPI_DSI_HOST_OFFSET) \
+		| REG_BITS(bits) | BITS_OFFSET(bit_offset))  
+#define DSI_DPHY_BITS(addr, bits, bit_offset)  (REG_ADDR((addr)+MIPI_DSI_PHY_OFFSET) \
+		| REG_BITS(bits) | BITS_OFFSET(bit_offset))
+
+#ifdef DWC_DSI_VERSION_0x3131302A
+
+#define VERSION 					DSI_HOST_BITS(0x00, 32, 0)
+#define GEN_HDR 					DSI_HOST_BITS(0x34, 32, 0)
+#define GEN_PLD_DATA 				DSI_HOST_BITS(0x38, 32, 0)
+#define ERROR_ST0 					DSI_HOST_BITS(0x44, 21, 0)
+#define ERROR_ST1 					DSI_HOST_BITS(0x48, 18, 0)
+#define ERROR_MSK0 					DSI_HOST_BITS(0x4C, 21, 0)
+#define ERROR_MSK1 					DSI_HOST_BITS(0x50, 18, 0)
+
+#define shutdownz 					DSI_HOST_BITS(0x04, 1, 0)
+#define en18_loosely 				DSI_HOST_BITS(0x0c, 1, 10)
+#define colorm_active_low 			DSI_HOST_BITS(0x0c, 1, 9)
+#define shutd_active_low  			DSI_HOST_BITS(0x0c, 1, 8)
+#define hsync_active_low  			DSI_HOST_BITS(0x0c, 1, 7)
+#define vsync_active_low  			DSI_HOST_BITS(0x0c, 1, 6)
+#define dataen_active_low  			DSI_HOST_BITS(0x0c, 1, 5)
+#define dpi_color_coding 			DSI_HOST_BITS(0x0c, 3, 2)
+#define dpi_vcid					DSI_HOST_BITS(0x0c, 1, 0)
+#define vid_hline_time  			DSI_HOST_BITS(0x28, 14, 18)
+#define vid_hbp_time 				DSI_HOST_BITS(0x28, 9, 9)
+#define vid_hsa_time 				DSI_HOST_BITS(0x28, 9, 0)
+#define vid_active_lines 			DSI_HOST_BITS(0x2c, 11, 16)
+#define vid_vfp_lines 				DSI_HOST_BITS(0x2c, 6, 10)
+#define vid_vbp_lines 				DSI_HOST_BITS(0x2c, 6, 4)
+#define vid_vsa_lines 				DSI_HOST_BITS(0x2c, 4, 0)
+#define TO_CLK_DIVISION 			DSI_HOST_BITS(0x08, 8, 8)
+#define TX_ESC_CLK_DIVISION 		DSI_HOST_BITS(0x08, 8, 0)
+#define gen_vid_rx 					DSI_HOST_BITS(0x18, 2, 5)
+#define crc_rx_en 					DSI_HOST_BITS(0x18, 1, 4)
+#define ecc_rx_en 					DSI_HOST_BITS(0x18, 1, 3)
+#define bta_en 						DSI_HOST_BITS(0x18, 1, 2)
+#define eotp_rx_en 					DSI_HOST_BITS(0x18, 1, 1)
+#define eotp_tx_en 					DSI_HOST_BITS(0x18, 1, 0)
+#define lp_cmd_en  					DSI_HOST_BITS(0x1c, 1, 12)
+#define frame_bta_ack_en 			DSI_HOST_BITS(0x1c, 1, 11)
+#define en_null_pkt 				DSI_HOST_BITS(0x1c, 1, 10)
+#define en_multi_pkt 				DSI_HOST_BITS(0x1c, 1, 9)
+#define lp_hfp_en 					DSI_HOST_BITS(0x1c, 1, 8)
+#define lp_hbp_en 					DSI_HOST_BITS(0x1c, 1, 7)
+#define lp_vact_en 					DSI_HOST_BITS(0x1c, 1, 6)
+#define lp_vfp_en 					DSI_HOST_BITS(0x1c, 1, 5)
+#define lp_vbp_en 					DSI_HOST_BITS(0x1c, 1, 4)
+#define lp_vsa_en 					DSI_HOST_BITS(0x1c, 1, 3)
+#define vid_mode_type 				DSI_HOST_BITS(0x1c, 2, 1)
+#define en_video_mode 				DSI_HOST_BITS(0x1c, 1, 0)
+#define null_pkt_size 				DSI_HOST_BITS(0x20, 10, 21)
+#define num_chunks 					DSI_HOST_BITS(0x20, 10, 11)
+#define vid_pkt_size 				DSI_HOST_BITS(0x20, 11, 0)
+#define tear_fx_en 					DSI_HOST_BITS(0x24, 1, 14)
+#define ack_rqst_en 				DSI_HOST_BITS(0x24, 1, 13)
+#define dcs_lw_tx 					DSI_HOST_BITS(0x24, 1, 12)
+#define gen_lw_tx 					DSI_HOST_BITS(0x24, 1, 11)
+#define max_rd_pkt_size 			DSI_HOST_BITS(0x24, 1, 10)
+#define dcs_sr_0p_tx 				DSI_HOST_BITS(0x24, 1, 9)
+#define dcs_sw_1p_tx 				DSI_HOST_BITS(0x24, 1, 8)
+#define dcs_sw_0p_tx				DSI_HOST_BITS(0x24, 1, 7)
+#define gen_sr_2p_tx				DSI_HOST_BITS(0x24, 1, 6)
+#define gen_sr_1p_tx 				DSI_HOST_BITS(0x24, 1, 5)
+#define gen_sr_0p_tx 				DSI_HOST_BITS(0x24, 1, 4)
+#define gen_sw_2p_tx 				DSI_HOST_BITS(0x24, 1, 3)
+#define gen_sw_1p_tx 				DSI_HOST_BITS(0x24, 1, 2)
+#define gen_sw_0p_tx 				DSI_HOST_BITS(0x24, 1, 1)
+#define en_cmd_mode 				DSI_HOST_BITS(0x24, 1, 0)
+#define phy_hs2lp_time 				DSI_HOST_BITS(0x30, 8, 24)
+#define phy_lp2hs_time 				DSI_HOST_BITS(0x30, 8, 16)
+#define max_rd_time 				DSI_HOST_BITS(0x30, 15, 0)
+#define lprx_to_cnt 				DSI_HOST_BITS(0x40, 16, 16)
+#define hstx_to_cnt 				DSI_HOST_BITS(0x40, 16, 0)
+#define phy_enableclk 				DSI_HOST_BITS(0x54, 1, 2)
+//#define phy_rstz 					DSI_HOST_BITS(0x54, 1, 1)
+//#define phy_shutdownz 				DSI_HOST_BITS(0x54, 1, 0)
+
+#define phy_stop_wait_time 			DSI_HOST_BITS(0x58, 8, 2)
+#define n_lanes 					DSI_HOST_BITS(0x58, 2, 0)
+#define phy_tx_triggers 			DSI_HOST_BITS(0x5c, 4, 5)
+#define phy_txexitulpslan 			DSI_HOST_BITS(0x5c, 1, 4)
+#define phy_txrequlpslan 			DSI_HOST_BITS(0x5c, 1, 3)
+#define phy_txexitulpsclk 			DSI_HOST_BITS(0x5c, 1, 2)
+#define phy_txrequlpsclk 			DSI_HOST_BITS(0x5c, 1, 1)
+#define phy_txrequestclkhs 			DSI_HOST_BITS(0x5c, 1, 0)
+#define phy_testclk 				DSI_HOST_BITS(0x64, 1, 1)
+#define phy_testclr 				DSI_HOST_BITS(0x64, 1, 0)
+#define phy_testen  				DSI_HOST_BITS(0x68, 1, 16)
+#define phy_testdout 				DSI_HOST_BITS(0x68, 8, 8)
+#define phy_testdin 				DSI_HOST_BITS(0x68, 8, 0)
+#define outvact_lpcmd_time  		DSI_HOST_BITS(0x70, 8, 8)
+#define invact_lpcmd_time 			DSI_HOST_BITS(0x70, 8, 0)
+#define gen_rd_cmd_busy  			DSI_HOST_BITS(0x3c, 1, 6)
+#define gen_pld_r_full 				DSI_HOST_BITS(0x3c, 1, 5)
+#define gen_pld_r_empty 			DSI_HOST_BITS(0x3c, 1, 4)
+#define gen_pld_w_full 				DSI_HOST_BITS(0x3c, 1, 3)     //800byte    write GEN_PLD_DATA
+#define gen_pld_w_empty 			DSI_HOST_BITS(0x3c, 1, 2)
+#define gen_cmd_full 				DSI_HOST_BITS(0x3c, 1, 1)     //20   write GEN_HDR
+#define gen_cmd_empty 				DSI_HOST_BITS(0x3c, 1, 0)
+#define phystopstateclklane 		DSI_HOST_BITS(0x60, 1, 2)
+#define phylock 					DSI_HOST_BITS(0x60, 1, 0)
+
+#else  //***************************************************************//
+//DWC_DSI_VERSION_0x3133302A
+#define VERSION 					DSI_HOST_BITS(0x000, 32, 0)
+#define shutdownz 					DSI_HOST_BITS(0x004, 1, 0)
+#define TO_CLK_DIVISION 			DSI_HOST_BITS(0x008, 8, 8)
+#define TX_ESC_CLK_DIVISION 		DSI_HOST_BITS(0x008, 8, 0)
+#define dpi_vcid					DSI_HOST_BITS(0x00c, 2, 0)
+#define en18_loosely 				DSI_HOST_BITS(0x010, 1, 8)
+#define dpi_color_coding 			DSI_HOST_BITS(0x010, 4, 0)        //need modify in code
+#define colorm_active_low 			DSI_HOST_BITS(0x014, 1, 4)
+#define shutd_active_low  			DSI_HOST_BITS(0x014, 1, 3)
+#define hsync_active_low  			DSI_HOST_BITS(0x014, 1, 2)
+#define vsync_active_low  			DSI_HOST_BITS(0x014, 1, 1)
+#define dataen_active_low  			DSI_HOST_BITS(0x014, 1, 0)
+#define outvact_lpcmd_time  		DSI_HOST_BITS(0x018, 8, 16)   //attence
+#define invact_lpcmd_time 			DSI_HOST_BITS(0x018, 8, 0)
+//#define dbi_vcid					DSI_HOST_BITS(0x01c, 2, 0)
+#define crc_rx_en 					DSI_HOST_BITS(0x02c, 1, 4)
+#define ecc_rx_en 					DSI_HOST_BITS(0x02c, 1, 3)
+#define bta_en 						DSI_HOST_BITS(0x02c, 1, 2)
+#define eotp_rx_en 					DSI_HOST_BITS(0x02c, 1, 1)
+#define eotp_tx_en 					DSI_HOST_BITS(0x02c, 1, 0)
+#define gen_vid_rx 					DSI_HOST_BITS(0x030, 2, 0) //libing (0x030, 2, 5)-> (0x030, 2, 0)
+#define cmd_video_mode 				DSI_HOST_BITS(0x034, 1, 0)
+#define vpg_orientation             DSI_HOST_BITS(0x038, 1, 24) //libing 
+#define vpg_mode                    DSI_HOST_BITS(0x038, 1, 20) //libing 
+#define vpg_en                      DSI_HOST_BITS(0x038, 1, 16) //libing 
+#define lp_cmd_en  					DSI_HOST_BITS(0x038, 1, 15)
+#define frame_bta_ack_en 			DSI_HOST_BITS(0x038, 1, 14)
+#define lp_hfp_en 					DSI_HOST_BITS(0x038, 1, 13)
+#define lp_hbp_en 					DSI_HOST_BITS(0x038, 1, 12)
+#define lp_vact_en 					DSI_HOST_BITS(0x038, 1, 11)
+#define lp_vfp_en 					DSI_HOST_BITS(0x038, 1, 10)
+#define lp_vbp_en 					DSI_HOST_BITS(0x038, 1, 9)
+#define lp_vsa_en 					DSI_HOST_BITS(0x038, 1, 8)
+#define vid_mode_type 				DSI_HOST_BITS(0x038, 2, 0)
+#define vid_pkt_size 				DSI_HOST_BITS(0x03c, 14, 0)
+#define num_chunks 					DSI_HOST_BITS(0x040, 13, 0)
+#define null_pkt_size 				DSI_HOST_BITS(0x044, 13, 0)
+#define vid_hsa_time 				DSI_HOST_BITS(0x048, 12, 0)
+#define vid_hbp_time 				DSI_HOST_BITS(0x04c, 12, 0)
+#define vid_hline_time  			DSI_HOST_BITS(0x050, 15, 0)
+#define vid_vsa_lines 				DSI_HOST_BITS(0x054, 10, 0)
+#define vid_vbp_lines 				DSI_HOST_BITS(0x058, 10, 0)
+#define vid_vfp_lines 				DSI_HOST_BITS(0x05c, 10, 0)
+#define vid_active_lines 			DSI_HOST_BITS(0x060, 14, 0)
+#define max_rd_pkt_size 			DSI_HOST_BITS(0x068, 1, 24)
+#define dcs_lw_tx 					DSI_HOST_BITS(0x068, 1, 19)
+#define dcs_sr_0p_tx 				DSI_HOST_BITS(0x068, 1, 18)
+#define dcs_sw_1p_tx 				DSI_HOST_BITS(0x068, 1, 17)
+#define dcs_sw_0p_tx				DSI_HOST_BITS(0x068, 1, 16)
+#define gen_lw_tx 					DSI_HOST_BITS(0x068, 1, 14)
+#define gen_sr_2p_tx				DSI_HOST_BITS(0x068, 1, 13)
+#define gen_sr_1p_tx 				DSI_HOST_BITS(0x068, 1, 12)
+#define gen_sr_0p_tx 				DSI_HOST_BITS(0x068, 1, 11)
+#define gen_sw_2p_tx 				DSI_HOST_BITS(0x068, 1, 10)
+#define gen_sw_1p_tx 				DSI_HOST_BITS(0x068, 1, 9)
+#define gen_sw_0p_tx 				DSI_HOST_BITS(0x068, 1, 8)
+#define ack_rqst_en 				DSI_HOST_BITS(0x068, 1, 1)
+#define tear_fx_en 					DSI_HOST_BITS(0x068, 1, 0)
+#define GEN_HDR						DSI_HOST_BITS(0x06c, 32, 0)    
+#define GEN_PLD_DATA				DSI_HOST_BITS(0x070, 32, 0)	  //need modify
+#define gen_rd_cmd_busy  			DSI_HOST_BITS(0x074, 1, 6)
+#define gen_pld_r_full 				DSI_HOST_BITS(0x074, 1, 5)
+#define gen_pld_r_empty 			DSI_HOST_BITS(0x074, 1, 4)
+#define gen_pld_w_full 				DSI_HOST_BITS(0x074, 1, 3)     //800byte    write GEN_PLD_DATA
+#define gen_pld_w_empty				DSI_HOST_BITS(0x074, 1, 2)
+#define gen_cmd_full 				DSI_HOST_BITS(0x074, 1, 1)     //20   write GEN_HDR
+#define gen_cmd_empty 				DSI_HOST_BITS(0x074, 1, 0)
+#define hstx_to_cnt 				DSI_HOST_BITS(0x078, 16, 16)   //need modify
+#define lprx_to_cnt 				DSI_HOST_BITS(0x078, 16, 0)
+#define hs_rd_to_cnt 				DSI_HOST_BITS(0x07c, 16, 0)     //new(read)
+#define lp_rd_to_cnt 				DSI_HOST_BITS(0x080, 16, 0)		//new(read)
+#define presp_to_mode 				DSI_HOST_BITS(0x084, 1, 24)		//new
+#define hs_wr_to_cnt 				DSI_HOST_BITS(0x084, 16, 0)		//new
+#define lp_wr_to_cnt 				DSI_HOST_BITS(0x088, 16, 0)		//new
+#define bta_to_cnt 					DSI_HOST_BITS(0x08c, 16, 0)		//new
+//#define send_3d_cfg 				DSI_HOST_BITS(0x090, 1, 16)		//new
+//#define right_first 				DSI_HOST_BITS(0x090, 1, 5)		//new
+//#define second_vsync 				DSI_HOST_BITS(0x090, 1, 4)		//new
+//#define format_3d 					DSI_HOST_BITS(0x090, 2, 2)		//new
+//#define mode_3d		 				DSI_HOST_BITS(0x090, 2, 0)		//new
+#define auto_clklane_ctrl 			DSI_HOST_BITS(0x094, 1, 1)		//new
+#define phy_txrequestclkhs 			DSI_HOST_BITS(0x094, 1, 0)
+#define phy_hs2lp_time_clk_lane     DSI_HOST_BITS(0x098, 10, 16) //libing
+#define phy_hs2hs_time_clk_lane     DSI_HOST_BITS(0x098, 10, 0) //libing
+#define phy_hs2lp_time 				DSI_HOST_BITS(0x09c, 8, 24)
+#define phy_lp2hs_time 				DSI_HOST_BITS(0x09c, 8, 16)
+#define max_rd_time 				DSI_HOST_BITS(0x09c, 15, 0)
+#define phy_forcepll 				DSI_HOST_BITS(0x0a0, 1, 3)		//new Dependency: DSI_HOST_FPGA = 0. Otherwise, this bit is reserved.
+#define phy_enableclk 				DSI_HOST_BITS(0x0a0, 1, 2)
+#define phy_rstz 					DSI_HOST_BITS(0x0a0, 1, 1)  //libing
+#define phy_shutdownz 				DSI_HOST_BITS(0x0a0, 1, 0) //libing 
+#define phy_stop_wait_time 			DSI_HOST_BITS(0x0a4, 8, 8)
+#define n_lanes 					DSI_HOST_BITS(0x0a4, 2, 0)
+#define phy_txexitulpslan 			DSI_HOST_BITS(0x0a8, 1, 3)
+#define phy_txrequlpslan 			DSI_HOST_BITS(0x0a8, 1, 2)
+#define phy_txexitulpsclk 			DSI_HOST_BITS(0x0a8, 1, 1)
+#define phy_txrequlpsclk 			DSI_HOST_BITS(0x0a8, 1, 0)
+#define phy_tx_triggers 			DSI_HOST_BITS(0x0ac, 4, 0)
+
+#define phystopstateclklane 		DSI_HOST_BITS(0x0b0, 1, 2)
+#define phylock 					DSI_HOST_BITS(0x0b0, 1, 0)
+#define phy_testclk 				DSI_HOST_BITS(0x0b4, 1, 1)
+#define phy_testclr 				DSI_HOST_BITS(0x0b4, 1, 0)
+#define phy_testen  				DSI_HOST_BITS(0x0b8, 1, 16)
+#define phy_testdout 				DSI_HOST_BITS(0x0b8, 8, 8)
+#define phy_testdin 				DSI_HOST_BITS(0x0b8, 8, 0)
+
+#define PHY_TEST_CTRL1 				DSI_HOST_BITS(0x0b8, 17, 0)
+#define PHY_TEST_CTRL0              DSI_HOST_BITS(0x0b4, 2, 0)
+
+#define INT_ST0 					DSI_HOST_BITS(0x0bc, 21, 0)
+#define INT_ST1 					DSI_HOST_BITS(0x0c0, 18, 0)
+#define INT_MKS0 					DSI_HOST_BITS(0x0c4, 21, 0)
+#define INT_MKS1 					DSI_HOST_BITS(0x0c8, 18, 0) //libing
+#define INT_FORCE0 					DSI_HOST_BITS(0x0d8, 21, 0) //libing
+#define INT_FORCE1 					DSI_HOST_BITS(0x0dc, 18, 0) //libing
+
+#define code_hs_rx_clock            0x34
+#define code_hs_rx_lane0            0x44
+#define code_hs_rx_lane1            0x54
+#define code_hs_rx_lane2            0x84
+#define code_hs_rx_lane3            0x94
+
+#define code_pll_input_div_rat      0x17
+#define code_pll_loop_div_rat       0x18 
+#define code_pll_input_loop_div_rat 0x19 
+
+#define code_hstxdatalanerequsetstatetime   0x70
+#define code_hstxdatalanepreparestatetime   0x71
+#define code_hstxdatalanehszerostatetime    0x72
+
+
+
+
+
+//#define en_null_pkt				DSI_HOST_BITS(0x1c, 1, 13)  //delete
+//#define en_multi_pkt				DSI_HOST_BITS(0x1c, 1, 13)  //delete
+#endif  /* end of DWC_DSI_VERSION_0x3131302A */
+
+
+
+//MIPI DSI DPHY REGISTERS
+#define DPHY_REGISTER0				DSI_DPHY_BITS(0x00, 32, 0)
+#define DPHY_REGISTER1				DSI_DPHY_BITS(0x04, 32, 0)
+#define DPHY_REGISTER3				DSI_DPHY_BITS(0x0c, 32, 0)
+#define DPHY_REGISTER4				DSI_DPHY_BITS(0x10, 32, 0)
+#define DPHY_REGISTER20				DSI_DPHY_BITS(0X80, 32, 0)
+
+#define lane_en_ck 					DSI_DPHY_BITS(0x00, 1, 6)
+#define lane_en_3 					DSI_DPHY_BITS(0x00, 1, 5)
+#define lane_en_2 					DSI_DPHY_BITS(0x00, 1, 4)
+#define lane_en_1 					DSI_DPHY_BITS(0x00, 1, 3)
+#define lane_en_0 					DSI_DPHY_BITS(0x00, 1, 2)
+
+#define reg_da_ppfc 				DSI_DPHY_BITS(0x04, 1, 4)
+#define reg_da_syncrst 				DSI_DPHY_BITS(0x04, 1, 2)
+#define reg_da_ldopd 				DSI_DPHY_BITS(0x04, 1, 1)
+#define reg_da_pllpd 				DSI_DPHY_BITS(0x04, 1, 0)
+
+#define reg_fbdiv_8 				DSI_DPHY_BITS(0x0c, 1, 5)
+#define reg_prediv 					DSI_DPHY_BITS(0x0c, 5, 0)
+#define reg_fbdiv 					DSI_DPHY_BITS(0x10, 8, 0)
+
+#define reg_dig_rstn 				DSI_DPHY_BITS(0X80, 1, 0)
+
+#define DPHY_CLOCK_OFFSET			REG_ADDR(0X0100)
+#define DPHY_LANE0_OFFSET			REG_ADDR(0X0180)
+#define DPHY_LANE1_OFFSET			REG_ADDR(0X0200)
+#define DPHY_LANE2_OFFSET			REG_ADDR(0X0280)
+#define DPHY_LANE3_OFFSET			REG_ADDR(0X0300)
+
+#define reg_ths_settle				DSI_DPHY_BITS(0x0000, 4, 0)
+#define reg_hs_tlpx					DSI_DPHY_BITS(0x0014, 6, 0)
+#define reg_hs_ths_prepare			DSI_DPHY_BITS(0x0018, 7, 0)
+#define reg_hs_the_zero				DSI_DPHY_BITS(0x001c, 6, 0)
+#define reg_hs_ths_trail			DSI_DPHY_BITS(0x0020, 7, 0)
+#define reg_hs_ths_exit				DSI_DPHY_BITS(0x0024, 5, 0)
+#define reg_hs_tclk_post			DSI_DPHY_BITS(0x0028, 4, 0)
+#define reserved					DSI_DPHY_BITS(0x002c, 1, 0)
+#define reg_hs_twakup_h				DSI_DPHY_BITS(0x0030, 2, 0)
+#define reg_hs_twakup_l				DSI_DPHY_BITS(0x0034, 8, 0)
+#define reg_hs_tclk_pre				DSI_DPHY_BITS(0x0038, 4, 0)
+#define reg_hs_tta_go				DSI_DPHY_BITS(0x0040, 6, 0)
+#define reg_hs_tta_sure				DSI_DPHY_BITS(0x0044, 6, 0)
+#define reg_hs_tta_wait				DSI_DPHY_BITS(0x0048, 6, 0)
+
+
+#ifdef DWC_DSI_VERSION_0x3131302A
+//MISC REGISTERS
+#define DSI_MISC_BITS(addr, bits, bit_offset)  (REG_ADDR(addr) \
+		| REG_BITS(bits) | BITS_OFFSET(bit_offset))
+
+#define CRU_CRU_CLKSEL1_CON			(0x005c)
+#define CRU_CFG_MISC_CON			(0x009c)
+
+#define cfg_mipiclk_gaten 			DSI_MISC_BITS(CRU_CRU_CLKSEL1_CON, 1, 10)
+
+#define mipi_int 					DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 19)
+#define mipi_edpihalt 				DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 16)
+#define pin_forcetxstopmode_3 		DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 11)
+#define pin_forcetxstopmode_2 		DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 10)
+#define pin_forcetxstopmode_1 		DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 9)
+#define pin_forcetxstopmode_0 		DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 8)
+#define pin_forcerxmode_0 			DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 7)
+#define pin_turndisable_0 			DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 6)
+#define dpicolom 					DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 2)
+#define dpishutdn 					DSI_MISC_BITS(CRU_CFG_MISC_CON, 1, 1)
+
+#else
+
+//#define mipi_int 					
+//#define mipi_edpihalt 				
+#define pin_forcetxstopmode_3 		
+#define pin_forcetxstopmode_2 		
+#define pin_forcetxstopmode_1 		
+#define pin_forcetxstopmode_0 		
+#define pin_forcerxmode_0 			
+#define pin_turndisable_0 			
+#define dpicolom 					
+#define dpishutdn 					
+
+#endif
+
+
+//global operation timing parameter
+struct gotp_m {
+	//time uint is ns
+	u32 min;
+	u32 value;
+	u32 max;
+};
+
+//default time unit is ns 
+//Unit Interval, equal to the duration of any HS state on the Clock Lane
+struct gotp {
+	u32 CLK_MISS;    			//min:no    max:60
+	u32 CLK_POST;    			//min:60 ns + 52*UI    max:no
+	u32 CLK_PRE;     			//min:8*UI    max:no
+	u32 CLK_PREPARE;  			//min:38    max:95
+	u32 CLK_SETTLE;    			//min:95    max:300
+	u32 CLK_TERM_EN;    		//min:Time for Dn to reach VTERM-EN    max:38
+	u32 CLK_TRAIL;    			//min:60    max:no
+	u32 CLK_ZERO;    			//min:300 - CLK_PREPARE    max:no
+	u32 D_TERM_EN;    			//min:Time for Dn to reach VTERM-EN    max:35 ns + 4*UI
+	u32 EOT;    				//min:no    max:105 ns + n*12*UI
+	u32 HS_EXIT;    			//min:100    max:no
+	u32 HS_PREPARE;    			//min:40 ns + 4*UI     max:85 ns + 6*UI	
+	u32 HS_ZERO;    			//min:145 ns + 10*UI - HS_PREPARE    max:no
+	u32 HS_SETTLE;    			//min:85 ns + 6*UI     max:145 ns + 10*UI
+	u32 HS_SKIP;    			//min:40    max:55 ns + 4*UI
+	u32 HS_TRAIL;    			//min: max( n*8*UI, 60 ns + n*4*UI )    max:no
+	u32 NIT;    				//min:100us    max:no
+	u32 LPX;    				//min:50    max:no
+	u32 TA_GET;    				//min:5*TLPX    
+	u32 TA_GO;    				//min:4*TLPX    	
+	u32 TA_SURE;    			//min:TLPX    max:2*TLPX
+	u32 WAKEUP;    				//min:1ms    max:no
+};
+
+
+struct dsi_phy {
+	u32 UI;
+	u32 ref_clk;     	//input_clk
+	u32 ddr_clk;		//data bit clk
+	u32 txbyte_clk;		//1/8 of ddr_clk
+	u32 sys_clk;		//
+	u32 pclk;			//
+	u32 txclkesc;
+	
+	u32 Tddr_clk;		//ps
+	u32 Ttxbyte_clk;   	//ps
+	u32 Tsys_clk;   	//ps
+	u32 Tpclk;   		//ps
+	u32 Ttxclkesc;		//ps
+
+#ifdef CONFIG_MIPI_DSI_LINUX
+	struct clk	*refclk; 
+	unsigned long iobase;
+	void __iomem *membase;
+#endif	
+	u16 prediv;
+	u16 fbdiv;
+	u8 flag;
+	struct gotp gotp;
+
+};
+
+struct dsi_host {
+	u8 flag;
+	u8 lane;
+	u8 format;
+	u8 video_mode;
+	u32 clk;
+	u32 irq;
+#ifdef CONFIG_MIPI_DSI_LINUX
+	unsigned long iobase;
+	void __iomem *membase;
+#endif
+};
+
+struct dsi {
+	u8 dsi_id;
+	u8 lcdc_id;
+	u8 vid;
+	struct dsi_phy phy;
+	struct dsi_host host;
+	struct mipi_dsi_ops ops;
+	struct mipi_dsi_screen screen;
+#ifdef CONFIG_MIPI_DSI_LINUX
+	struct clk	*dsi_pclk;
+	struct clk	*dsi_pd;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+#endif
+    struct dentry *debugfs_dir;
+	struct platform_device *pdev;
+};
+
+int rk_mipi_get_dsi_clk(void);
+int rk_mipi_get_dsi_num(void);
+int rk_mipi_get_dsi_lane(void);
+
+extern int rk616_mipi_dsi_ft_init(void);
+int rk_mipi_dsi_init_lite(struct dsi *dsi);
+#endif /* end of RK616_MIPI_DSI_H */
diff -Nupr a/drivers/video/rockchip/transmitter/ssd2828.c b/drivers/video/rockchip/transmitter/ssd2828.c
--- a/drivers/video/rockchip/transmitter/ssd2828.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/ssd2828.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,689 @@
+/*
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ * drivers/video/display/transmitter/ssd2828.c
+ * author: hhb@rock-chips.com
+ * create date: 2013-01-17
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/rk_fb.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include <linux/rk_screen.h>
+#include <linux/regulator/machine.h>
+#include "mipi_dsi.h"
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+
+
+/* define spi gpio*/
+#define TXD_PORT        ssd2828->spi.mosi
+#define CLK_PORT        ssd2828->spi.sck
+#define CS_PORT         ssd2828->spi.cs
+#define RXD_PORT        ssd2828->spi.miso
+
+#define CS_OUT()        gpio_direction_output(CS_PORT, 0)
+#define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
+#define CS_CLR()        gpio_set_value(CS_PORT, GPIO_LOW)
+#define CLK_OUT()       gpio_direction_output(CLK_PORT, 0)
+#define CLK_SET()       gpio_set_value(CLK_PORT, GPIO_HIGH)
+#define CLK_CLR()       gpio_set_value(CLK_PORT, GPIO_LOW)
+#define TXD_OUT()       gpio_direction_output(TXD_PORT, 0)
+#define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
+#define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
+#define RXD_INPUT()		gpio_direction_input(RXD_PORT)
+#define RXD_GET()  		gpio_get_value(RXD_PORT)
+
+
+struct ssd2828_t *ssd2828 = NULL;
+void ssd_set_register(unsigned int reg_and_value);
+
+int ssd2828_gpio_init(void *data) {
+	int ret = 0;
+	struct reset_t *reset = &ssd2828->reset;
+	struct power_t *vdd = &ssd2828->vddio;
+	struct spi_t *spi = &ssd2828->spi;
+	
+	if(reset->reset_pin > INVALID_GPIO) {
+		ret = gpio_request(reset->reset_pin, "ssd2828_reset");
+		if (ret != 0) {
+			//gpio_free(reset->reset_pin);
+			printk("%s: request ssd2828_RST_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX
+			if(reset->mux_name)
+				rk30_mux_api_set(reset->mux_name, 0);
+#endif				
+			gpio_direction_output(reset->reset_pin, !reset->effect_value);
+		}
+	}
+	
+	if(vdd->enable_pin > INVALID_GPIO) {
+		ret = gpio_request(vdd->enable_pin, "ssd2828_vddio");
+		if (ret != 0) {
+			//gpio_free(vdd->enable_pin);
+			printk("%s: request ssd2828_vddio_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(vdd->mux_name)
+				rk30_mux_api_set(vdd->mux_name, 0);	
+#endif			
+			gpio_direction_output(vdd->enable_pin, !vdd->effect_value);	
+		}
+	}
+	
+	vdd = &ssd2828->vdd_mipi;
+	if(vdd->enable_pin > INVALID_GPIO) {
+		ret = gpio_request(vdd->enable_pin, "ssd2828_vdd_mipi");
+		if (ret != 0) {
+			//gpio_free(vdd->enable_pin);
+			printk("%s: request ssd2828_vdd_mipi_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(vdd->mux_name)
+				rk30_mux_api_set(vdd->mux_name, 0);	
+#endif			
+			gpio_direction_output(vdd->enable_pin, !vdd->effect_value);	
+		}
+	}
+	
+	vdd = &ssd2828->shut;
+	if(vdd->enable_pin > INVALID_GPIO) {
+		ret = gpio_request(vdd->enable_pin, "ssd2828_shut");
+		if (ret != 0) {
+			//gpio_free(vdd->enable_pin);
+			printk("%s: request ssd2828_shut_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(vdd->mux_name)
+				rk30_mux_api_set(vdd->mux_name, 0);	
+#endif			
+			gpio_direction_output(vdd->enable_pin, !vdd->effect_value);	
+		}
+	}
+	
+	if(spi->cs > INVALID_GPIO) {
+		ret = gpio_request(spi->cs, "ssd2828_spi_cs");
+		if (ret != 0) {
+			//gpio_free(spi->cs);
+			printk("%s: request ssd2828_spi->cs_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(spi->cs_mux_name)
+				rk30_mux_api_set(spi->cs_mux_name, 0);	
+#endif				
+			gpio_direction_output(spi->cs, GPIO_HIGH);	
+		}
+	}
+	if(spi->sck > INVALID_GPIO) {
+		ret = gpio_request(spi->sck, "ssd2828_spi_sck");
+		if (ret != 0) {
+			//gpio_free(spi->sck);
+			printk("%s: request ssd2828_spi->sck_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(spi->sck_mux_name)
+				rk30_mux_api_set(spi->sck_mux_name, 0);	
+#endif
+			gpio_direction_output(spi->sck, GPIO_HIGH);	
+		}
+	}	
+	if(spi->mosi > INVALID_GPIO) {
+		ret = gpio_request(spi->mosi, "ssd2828_spi_mosi");
+		if (ret != 0) {
+			//gpio_free(spi->mosi);
+			printk("%s: request ssd2828_spi->mosi_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(spi->mosi_mux_name)
+				rk30_mux_api_set(spi->mosi_mux_name, 0);	
+#endif
+			gpio_direction_output(spi->mosi, GPIO_HIGH);	
+		}
+	}	
+	if(spi->miso > INVALID_GPIO) {
+		ret = gpio_request(spi->miso, "ssd2828_spi_miso");
+		if (ret != 0) {
+			//gpio_free(spi->miso);
+			printk("%s: request ssd2828_spi->miso_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(spi->miso_mux_name)
+				rk30_mux_api_set(spi->miso_mux_name, 0);	
+#endif
+			gpio_direction_input(spi->miso);	
+		}
+	}	
+	
+	return 0;
+
+}
+
+int ssd2828_gpio_deinit(void *data) {
+	struct reset_t *reset = &ssd2828->reset;
+	struct power_t *vdd = &ssd2828->vddio;
+	struct spi_t *spi = &ssd2828->spi;
+	
+	if(reset->reset_pin > INVALID_GPIO) {
+		gpio_direction_input(reset->reset_pin);
+		gpio_free(reset->reset_pin);
+	}
+	if(vdd->enable_pin > INVALID_GPIO) {
+		gpio_direction_input(vdd->enable_pin);
+		gpio_free(vdd->enable_pin);
+	}
+	vdd = &ssd2828->vdd_mipi;
+	if(vdd->enable_pin > INVALID_GPIO) {
+		gpio_direction_input(vdd->enable_pin);
+		gpio_free(vdd->enable_pin);
+	}
+	vdd = &ssd2828->shut;
+	if(vdd->enable_pin > INVALID_GPIO) {
+		gpio_direction_input(vdd->enable_pin);
+		gpio_free(vdd->enable_pin);
+	}
+	if(spi->cs > INVALID_GPIO) {
+		gpio_direction_input(spi->cs);
+		gpio_free(spi->cs);
+	}
+	if(spi->sck > INVALID_GPIO) {
+		gpio_direction_input(spi->sck);
+		gpio_free(spi->sck);
+	}
+	if(spi->mosi > INVALID_GPIO) {
+		gpio_direction_input(spi->mosi);
+		gpio_free(spi->mosi);
+	}
+	if(spi->miso > INVALID_GPIO) {
+		gpio_free(spi->miso);
+	}
+	return 0;
+}
+
+int ssd2828_reset(void *data) {
+	int ret = 0;
+	struct reset_t *reset = &ssd2828->reset;
+	if(reset->reset_pin <= INVALID_GPIO)
+		return -1;
+	gpio_set_value(reset->reset_pin, reset->effect_value);
+	if(reset->time_before_reset <= 0)
+		msleep(10);
+	else
+		msleep(reset->time_before_reset);
+	
+	gpio_set_value(reset->reset_pin, !reset->effect_value);
+	if(reset->time_after_reset <= 0)
+		msleep(5);
+	else
+		msleep(reset->time_after_reset);
+	return ret;	
+}
+
+int ssd2828_vdd_enable(void *data) {
+	int ret = 0;
+	struct power_t *vdd = (struct power_t *)data;
+	if(vdd->enable_pin > INVALID_GPIO) {
+		gpio_set_value(vdd->enable_pin, vdd->effect_value);
+	} else if(vdd->name) {
+		struct regulator *ldo = regulator_get(NULL, vdd->name);
+		if (ldo == NULL || IS_ERR(ldo) ){
+			printk("%s: get %s ldo failed!\n", __func__, vdd->name);
+			ret = -1;
+			return ret;
+		}
+		regulator_set_voltage(ldo, vdd->voltage, vdd->voltage);
+		regulator_enable(ldo);
+		printk(" %s set %s=%dmV end\n", __func__, vdd->name, regulator_get_voltage(ldo));
+		regulator_put(ldo);		
+	}
+	return ret;
+}
+
+int ssd2828_vdd_disable(void *data) {
+	int ret = 0;
+	struct power_t *vdd = (struct power_t *)data;
+	
+	if(vdd->enable_pin > INVALID_GPIO) {
+		gpio_set_value(vdd->enable_pin, !vdd->effect_value);
+	} else if(vdd->name) {
+		struct regulator *ldo = regulator_get(NULL, vdd->name);
+		if (ldo == NULL || IS_ERR(ldo) ){
+			printk("%s: get %s ldo failed!\n", __func__, vdd->name);
+			ret = -1;
+			return ret;
+		}
+		while(regulator_is_enabled(ldo) > 0){
+			regulator_disable(ldo);
+		}
+		regulator_put(ldo);
+	}
+	return ret;
+}
+
+
+int ssd2828_power_up(void) {
+
+	int ret = 0;
+	struct ssd2828_t *ssd = (struct ssd2828_t *)ssd2828;
+	struct spi_t *spi = &ssd2828->spi;
+	ssd->vdd_mipi.enable(&ssd->vdd_mipi);
+	ssd->vddio.enable(&ssd->vddio);
+	ssd->reset.do_reset(&ssd->reset);
+	ssd->shut.enable(&ssd->shut);
+	
+	gpio_direction_output(spi->cs, GPIO_HIGH);
+	gpio_direction_output(spi->sck, GPIO_LOW);
+	gpio_direction_input(spi->miso);
+	gpio_direction_output(spi->mosi, GPIO_LOW);
+	
+	return ret;
+}
+
+int ssd2828_power_down(void) {
+
+	int ret = 0;
+	struct ssd2828_t *ssd = (struct ssd2828_t *)ssd2828;
+	struct spi_t *spi = &ssd2828->spi;
+	
+	ssd->shut.disable(&ssd->shut);
+	msleep(10);
+	
+	ssd_set_register(0x00b70300);
+	msleep(1);
+	ssd_set_register(0x00b70304);
+	msleep(1);
+	ssd_set_register(0x00b90000);
+	msleep(10);
+	
+	//set all gpio to low to avoid current leakage
+	gpio_direction_output(spi->cs, GPIO_LOW);
+	gpio_direction_output(spi->sck, GPIO_LOW);
+	gpio_direction_output(spi->miso, GPIO_LOW);
+	gpio_direction_output(spi->mosi, GPIO_LOW);
+	gpio_direction_output(ssd->reset.reset_pin, GPIO_LOW);
+
+	ssd->vddio.disable(&ssd->vddio);
+	ssd->vdd_mipi.disable(&ssd->vdd_mipi);
+	ssd->shut.enable(&ssd->shut);
+	
+	return ret;
+}
+
+
+
+/* spi write a data frame,type mean command or data 
+	3 wire 24 bit SPI interface
+*/
+
+static void spi_send_data(unsigned int data)
+{
+    unsigned int i;
+
+    CS_SET();
+    udelay(1);
+    CLK_SET();
+    TXD_SET();
+
+    CS_CLR();
+    udelay(1);
+
+    for (i = 0; i < 24; i++)
+    {
+        //udelay(1); 
+        CLK_CLR();
+        udelay(1);
+        if (data & 0x00800000) {
+            TXD_SET();
+        } else {
+            TXD_CLR();
+        }
+        udelay(1);
+        CLK_SET();
+        udelay(1);
+        data <<= 1;
+    }
+
+    TXD_SET();
+    CS_SET();
+}
+
+static void spi_recv_data(unsigned int* data)
+{
+    unsigned int i = 0, temp = 0x73;   //read data
+
+    CS_SET();
+    udelay(1);
+    CLK_SET();
+    TXD_SET();
+
+    CS_CLR();
+    udelay(1);
+
+	for(i = 0; i < 8; i++) // 8 bits Data
+    {
+		udelay(1); 
+		CLK_CLR();
+		if (temp & 0x80)
+		   TXD_SET();
+		else
+		   TXD_CLR();
+		temp <<= 1;
+		udelay(1); 
+		CLK_SET();
+		udelay(1); 
+	}
+	udelay(1);
+	temp = 0;
+	for(i = 0; i < 16; i++) // 16 bits Data
+	{
+		udelay(1); 
+		CLK_CLR();
+		udelay(1); 
+		CLK_SET();
+		udelay(1); 
+		temp <<= 1;
+		if(RXD_GET() == GPIO_HIGH)
+		   temp |= 0x01;
+		
+	}
+
+    TXD_SET();
+    CS_SET();
+    *data = temp;
+}
+
+#define DEVIE_ID (0x70 << 16)
+void send_ctrl_cmd(unsigned int cmd)
+{
+    unsigned int out = (DEVIE_ID | cmd );
+    spi_send_data(out);
+}
+
+static void send_data_cmd(unsigned int data)
+{
+    unsigned int out = (DEVIE_ID | (0x2 << 16) | data );
+    spi_send_data(out);
+}
+
+unsigned int ssd_read_register(unsigned int reg) {
+	unsigned int data = 0;
+	send_ctrl_cmd(reg);
+	spi_recv_data(&data);
+	return data;
+}
+
+void ssd_set_register(unsigned int reg_and_value)
+{
+    send_ctrl_cmd(reg_and_value >> 16);
+    send_data_cmd(reg_and_value & 0x0000ffff);
+}
+
+int ssd_set_registers(unsigned int reg_array[], int n) {
+
+	int i = 0;
+	for(i = 0; i < n; i++) {
+		if(reg_array[i] < 0x00b00000) {      //the lowest address is 0xb0 of ssd2828
+		    if(reg_array[i] < 20000)
+		    	udelay(reg_array[i]);
+		    else {
+		    	mdelay(reg_array[i]/1000);
+		    }
+		} else {
+			ssd_set_register(reg_array[i]);
+		}
+	}
+	return 0;
+}
+
+int ssd_mipi_dsi_send_dcs_packet(unsigned char regs[], u32 n) {
+	//unsigned int data = 0, i = 0;
+	ssd_set_register(0x00B70343);   //
+	ssd_set_register(0x00B80000);
+	ssd_set_register(0x00Bc0001);
+	
+	ssd_set_register(0x00Bf0000 | regs[0]);
+	msleep(1);
+	ssd_set_register(0x00B7034b);
+	return 0;
+}
+
+
+int _ssd2828_send_packet(unsigned char type, unsigned char regs[], u32 n) {
+
+	
+	return 0;
+}
+
+int ssd2828_send_packet(unsigned char type, unsigned char regs[], u32 n) {
+	return _ssd2828_send_packet(type, regs, n);
+}
+
+int ssd_mipi_dsi_read_dcs_packet(unsigned char *data, u32 n) {
+	//DCS READ 
+	unsigned int i = 0;
+	
+	i = ssd_read_register(0xc6);
+	printk("read mipi slave error:%04x\n", i);
+	ssd_set_register(0x00B70382);
+	ssd_set_register(0x00BB0008);
+	ssd_set_register(0x00C1000A);
+	ssd_set_register(0x00C00001);
+	ssd_set_register(0x00Bc0001);
+	ssd_set_register(0x00Bf0000 | *data);
+	msleep(10);
+	i = ssd_read_register(0xc6);
+	printk("read mipi slave error:%04x\n", i);
+	
+	if(i & 1) {
+		i = ssd_read_register(0xff);
+		printk("read %02x:%04x\n", *data, i);
+		i = ssd_read_register(0xff);
+		printk("read %02x:%04x\n", *data, i);
+		i = ssd_read_register(0xff);
+		printk("read %02x:%04x\n", *data, i);
+	
+	} 
+		
+	return 0;
+}
+
+
+int ssd2828_get_id(void) {
+	
+	int id = -1;
+	ssd2828_power_up();
+	id = ssd_read_register(0xb0);
+	
+	return id;
+}
+
+static struct mipi_dsi_ops ssd2828_ops = {
+	.id = 0x2828,
+	.name = "ssd2828",
+	.get_id = ssd2828_get_id,
+	.dsi_set_regs = ssd_set_registers,
+	.dsi_send_dcs_packet = ssd_mipi_dsi_send_dcs_packet,
+	.dsi_read_dcs_packet = ssd_mipi_dsi_read_dcs_packet,
+	.power_up = ssd2828_power_up,
+	.power_down = ssd2828_power_down,
+	
+};
+
+static struct proc_dir_entry *reg_proc_entry;
+
+int reg_proc_write(struct file *file, const char __user *buff, size_t count, loff_t *offp)
+{
+	int ret = -1;
+	char *buf = kmalloc(count, GFP_KERNEL);
+	char *data = buf;
+	unsigned int regs_val = 0, read_val = 0;
+	ret = copy_from_user((void*)buf, buff, count);
+	
+	while(1) {
+		data = strstr(data, "0x");
+		if(data == NULL)
+			goto reg_proc_write_exit;
+		sscanf(data, "0x%x", &regs_val);
+		ssd_set_register(regs_val);
+		read_val = ssd_read_register(regs_val >> 16);
+		regs_val &= 0xffff;
+		if(read_val != regs_val)
+			printk("%s fail:0x%04x\n", __func__, read_val);	
+		data += 3;
+	}
+
+reg_proc_write_exit:		
+	kfree(buf);	
+	msleep(10);
+ 	return count;
+}
+
+int reg_proc_read(struct file *file, char __user *buff, size_t count, loff_t *offp)
+{
+#if 0	
+	int ret = -1;
+	const char buf[32] = {0};
+	unsigned int regs_val = 0;
+	ret = copy_from_user((void*)buf, buff, count);
+	sscanf(buf, "0x%x", &regs_val);
+	regs_val = ssd_read_register(regs_val);
+	sprintf(buf, "0x%04x\n", regs_val);
+	copy_to_user(buff, buf, 4);
+	
+	printk("%s:%04x\n", __func__, regs_val);
+	msleep(10);
+#endif	
+	return count;
+}
+
+int reg_proc_open(struct inode *inode, struct file *file)
+{
+	//printk("%s\n", __func__);
+	//msleep(10);
+	return 0;
+}
+
+int reg_proc_close(struct inode *inode, struct file *file)
+{
+	//printk("%s\n", __func__);
+	//msleep(10);
+	return 0;   
+}
+
+struct file_operations reg_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = reg_proc_open,
+	.release = reg_proc_close,
+	.write = reg_proc_write,
+	.read = reg_proc_read,
+};
+
+static int reg_proc_init(char *name)
+{
+	int ret = 0;
+  	reg_proc_entry = create_proc_entry(name, 0666, NULL);
+	if(reg_proc_entry == NULL) {
+		printk("Couldn't create proc entry : %s!\n", name);
+		ret = -ENOMEM;
+		return ret ;
+	}
+	else {
+		printk("Create proc entry:%s success!\n", name);
+		reg_proc_entry->proc_fops = &reg_proc_fops;
+	}
+	
+	return 0;
+}
+
+
+static int ssd2828_probe(struct platform_device *pdev) {
+
+	if(pdev->dev.platform_data)
+		ssd2828 = pdev->dev.platform_data;
+		
+    if(!ssd2828->gpio_init)
+    	ssd2828->gpio_init = ssd2828_gpio_init;
+    	
+    if(!ssd2828->gpio_deinit)
+    	ssd2828->gpio_deinit = ssd2828_gpio_deinit;    
+    
+    if(!ssd2828->power_up)
+    	ssd2828->power_up = ssd2828_power_up;  
+    if(!ssd2828->power_down)
+    	ssd2828->power_down = ssd2828_power_down;  	
+    
+    if(!ssd2828->reset.do_reset)
+    	ssd2828->reset.do_reset = ssd2828_reset;
+    
+    if(!ssd2828->vddio.enable)
+    	ssd2828->vddio.enable = ssd2828_vdd_enable;    
+    if(!ssd2828->vddio.disable)
+    	ssd2828->vddio.disable = ssd2828_vdd_disable;
+    
+    if(!ssd2828->vdd_mipi.enable)
+    	ssd2828->vdd_mipi.enable = ssd2828_vdd_enable;    
+    if(!ssd2828->vdd_mipi.disable)
+    	ssd2828->vdd_mipi.disable = ssd2828_vdd_disable;	
+    	
+    if(!ssd2828->shut.enable)
+    	ssd2828->shut.enable = ssd2828_vdd_enable;    
+    if(!ssd2828->shut.disable)
+    	ssd2828->shut.disable = ssd2828_vdd_disable;		
+    	
+    	
+	ssd2828_gpio_init(NULL);
+	reg_proc_init(ssd2828_ops.name);
+	return 0;
+}
+
+
+static int ssd2828_remove(struct platform_device *pdev) {
+
+	if(ssd2828) {
+		ssd2828_gpio_deinit(NULL);
+		ssd2828 = NULL;
+	}
+	return 0;
+}
+
+
+static struct platform_driver ssd2828_driver = {
+	.probe		= ssd2828_probe,
+	.remove		= ssd2828_remove,
+	//.suspend		= mipi_dsi_suspend,
+	//.resume		= mipi_dsi_resume,
+	.driver = {
+		.name = "ssd2828",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int __init ssd2828_init(void)
+{
+	platform_driver_register(&ssd2828_driver);
+	if(!ssd2828)
+		return -1;
+	register_dsi_ops(&ssd2828_ops);
+	if(ssd2828->id > 0)
+		ssd2828_ops.id = ssd2828->id;
+	return 0;
+}
+
+static void __exit ssd2828_exit(void)
+{
+	platform_driver_unregister(&ssd2828_driver);
+	del_dsi_ops(&ssd2828_ops);
+}
+
+subsys_initcall_sync(ssd2828_init);
+module_exit(ssd2828_exit);
diff -Nupr a/drivers/video/rockchip/transmitter/tc358768.c b/drivers/video/rockchip/transmitter/tc358768.c
--- a/drivers/video/rockchip/transmitter/tc358768.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/tc358768.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,744 @@
+/*
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ * drivers/video/display/transmitter/tc358768.c
+ * author: hhb@rock-chips.com
+ * create date: 2012-10-26
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/rk_fb.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include <linux/rk_screen.h>
+#include <linux/ktime.h>
+#include "mipi_dsi.h"
+
+#define CONFIG_TC358768_I2C     1
+#define CONFIG_TC358768_I2C_CLK     400*1000
+
+
+#if 0
+#define dsi_debug   printk
+#else
+#define dsi_debug(fmt...)   do { } while (0)
+#endif
+
+#ifdef CONFIG_TC358768_I2C
+static struct tc358768_t *tc358768 = NULL;
+static struct i2c_client *tc358768_client = NULL;
+static struct mipi_dsi_ops tc358768_ops;
+
+
+u32 i2c_write_32bits(u32 value) 
+{
+	struct i2c_msg msgs;
+	int ret = -1;
+	char buf[4];
+	buf[0] = value>>24;
+	buf[1] = value>>16;
+	buf[2] = value>>8;
+	buf[3] = value;
+	
+	msgs.addr = tc358768_client->addr;
+	msgs.flags = tc358768_client->flags;
+	msgs.len = 4;
+	msgs.buf = buf;
+	msgs.scl_rate = CONFIG_TC358768_I2C_CLK;
+	msgs.udelay = tc358768_client->udelay;
+
+	ret = i2c_transfer(tc358768_client->adapter, &msgs, 1);
+	if(ret < 0)
+		printk("%s:i2c_transfer fail =%d\n",__func__, ret);
+	return ret;
+}
+
+u32 i2c_read_32bits(u32 value) 
+{
+	struct i2c_msg msgs[2];
+	int ret = -1;
+	char buf[4];
+	buf[0] = value>>8;
+	buf[1] = value;
+	
+	msgs[0].addr = tc358768_client->addr;
+	msgs[0].flags = tc358768_client->flags;
+	msgs[0].len = 2;
+	msgs[0].buf = buf;
+	msgs[0].scl_rate = CONFIG_TC358768_I2C_CLK;
+	msgs[0].udelay = tc358768_client->udelay;
+
+	msgs[1].addr = tc358768_client->addr;
+	msgs[1].flags = tc358768_client->flags | I2C_M_RD;
+	msgs[1].len = 2;
+	msgs[1].buf = buf;
+	msgs[1].scl_rate = CONFIG_TC358768_I2C_CLK;
+	msgs[1].udelay = tc358768_client->udelay;
+
+	ret = i2c_transfer(tc358768_client->adapter, msgs, 2);
+	if(ret < 0)
+		printk("%s:i2c_transfer fail =%d\n",__func__, ret);
+	else
+		ret = (buf[0]<<8) | buf[1];	
+	
+	return ret;
+}
+
+
+int tc358768_gpio_init(void *data) {
+	int ret = 0;
+	struct reset_t *reset = &tc358768->reset;
+	struct power_t *vdd = &tc358768->vddc;
+	if(reset->reset_pin > INVALID_GPIO) {
+		ret = gpio_request(reset->reset_pin, "tc358768_reset");
+		if (ret != 0) {
+			//gpio_free(reset->reset_pin);
+			printk("%s: request TC358768_RST_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(reset->mux_name)
+				rk30_mux_api_set(reset->mux_name, reset->mux_mode);
+#endif
+			gpio_direction_output(reset->reset_pin, !reset->effect_value);
+		}
+	}
+	
+	if(vdd->enable_pin > INVALID_GPIO) {
+		ret = gpio_request(vdd->enable_pin, "tc358768_vddc");
+		if (ret != 0) {
+			//gpio_free(vdd->enable_pin);
+			printk("%s: request TC358768_vddc_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(vdd->mux_name)
+				rk30_mux_api_set(vdd->mux_name, vdd->mux_mode);	
+#endif
+			gpio_direction_output(vdd->enable_pin, !vdd->effect_value);
+		}
+	}
+	
+	vdd = &tc358768->vddio;
+	if(vdd->enable_pin > INVALID_GPIO) {
+		ret = gpio_request(vdd->enable_pin, "tc358768_vddio");
+		if (ret != 0) {
+			//gpio_free(vdd->enable_pin);
+			printk("%s: request TC358768_vddio_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(vdd->mux_name)
+				rk30_mux_api_set(vdd->mux_name, vdd->mux_mode);	
+#endif
+			gpio_direction_output(vdd->enable_pin, !vdd->effect_value);	
+		}
+	}
+	
+	vdd = &tc358768->vdd_mipi;
+	if(vdd->enable_pin > INVALID_GPIO) {
+		ret = gpio_request(vdd->enable_pin, "tc358768_vdd_mipi");
+		if (ret != 0) {
+			//gpio_free(vdd->enable_pin);
+			printk("%s: request TC358768_vdd_mipi_PIN error\n", __func__);
+		} else {
+#if OLD_RK_IOMUX		
+			if(vdd->mux_name)
+				rk30_mux_api_set(vdd->mux_name, vdd->mux_mode);	
+#endif
+			gpio_direction_output(vdd->enable_pin, !vdd->effect_value);	
+		}
+	}
+	return 0;
+
+}
+
+int tc358768_gpio_deinit(void *data) {
+	struct reset_t *reset = &tc358768->reset;
+	struct power_t *vdd = &tc358768->vddc;
+	gpio_direction_input(reset->reset_pin);
+	gpio_free(reset->reset_pin);
+	
+	gpio_direction_input(vdd->enable_pin);
+	gpio_free(vdd->enable_pin);
+	
+	vdd = &tc358768->vddio;
+	gpio_direction_input(vdd->enable_pin);
+	gpio_free(vdd->enable_pin);
+	
+	vdd = &tc358768->vdd_mipi;
+	gpio_direction_input(vdd->enable_pin);
+	gpio_free(vdd->enable_pin);
+	return 0;
+}
+
+int tc358768_reset(void *data) {
+	int ret = 0;
+	struct reset_t *reset = &tc358768->reset;
+	if(reset->reset_pin <= INVALID_GPIO)
+		return -1;
+	gpio_set_value(reset->reset_pin, reset->effect_value);
+	if(reset->time_before_reset <= 0)
+		msleep(1);
+	else
+		msleep(reset->time_before_reset);
+	
+	gpio_set_value(reset->reset_pin, !reset->effect_value);
+	if(reset->time_after_reset <= 0)
+		msleep(5);
+	else
+		msleep(reset->time_after_reset);
+	return ret;	
+}
+
+int tc358768_vdd_enable(void *data) {
+	int ret = 0;
+	struct power_t *vdd = (struct power_t *)data;
+	if(vdd->enable_pin > INVALID_GPIO) {
+		gpio_set_value(vdd->enable_pin, vdd->effect_value);
+	} else {
+		//for other control
+	}
+	return ret;
+}
+
+int tc358768_vdd_disable(void *data) {
+	int ret = 0;
+	struct power_t *vdd = (struct power_t *)data;
+	
+	if(vdd->enable_pin > INVALID_GPIO) {
+		gpio_set_value(vdd->enable_pin, !vdd->effect_value);
+	} else {
+		//for other control
+	}
+	return ret;
+}
+
+
+int tc358768_power_up(void) {
+
+	int ret = 0;
+	struct tc358768_t *tc = (struct tc358768_t *)tc358768;
+	
+	tc->vddc.enable(&tc->vddc);
+	tc->vdd_mipi.enable(&tc->vdd_mipi);
+	tc->vddio.enable(&tc->vddio);
+	tc->reset.do_reset(&tc->reset);
+	
+	return ret;
+}
+
+int tc358768_power_down(void) {
+
+	int ret = 0;
+	struct tc358768_t *tc = (struct tc358768_t *)tc358768;
+	
+	tc->vddio.disable(&tc->vddio);
+	tc->vdd_mipi.disable(&tc->vdd_mipi);
+	tc->vddc.disable(&tc->vddc);
+	gpio_set_value(tc358768->reset.reset_pin, 0);
+	
+	return ret;
+}
+
+static int tc358768_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did) 
+{
+    struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+    int ret = 0;
+
+    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+        dev_warn(&adapter->dev,
+        	 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
+        return -EIO;
+    }
+    
+    tc358768 = (struct tc358768_t *)client->dev.platform_data;
+    if(!tc358768) {
+    	ret = -1;
+    	printk("%s:%d tc358768 is null\n", __func__, __LINE__);
+    	return ret;
+    }	
+
+    tc358768_client = client;
+    if(!tc358768_client) {
+    	ret = -1;
+    	printk("%s:%d tc358768_client is null\n", __func__, __LINE__);
+    	return ret;
+    }
+    
+    if(!tc358768->gpio_init)
+    	tc358768->gpio_init = tc358768_gpio_init;
+    	
+    if(!tc358768->gpio_deinit)
+    	tc358768->gpio_deinit = tc358768_gpio_deinit;    
+    
+    if(!tc358768->power_up)
+    	tc358768->power_up = tc358768_power_up;  
+    if(!tc358768->power_down)
+    	tc358768->power_down = tc358768_power_down;  	
+    
+    if(!tc358768->reset.do_reset)
+    	tc358768->reset.do_reset = tc358768_reset;
+    
+    if(!tc358768->vddc.enable)
+    	tc358768->vddc.enable = tc358768_vdd_enable;    
+    if(!tc358768->vddc.disable)
+    	tc358768->vddc.disable = tc358768_vdd_disable;
+    
+    if(!tc358768->vddio.enable)
+    	tc358768->vddio.enable = tc358768_vdd_enable;    
+    if(!tc358768->vddio.disable)
+    	tc358768->vddio.disable = tc358768_vdd_disable;
+    
+    if(!tc358768->vdd_mipi.enable)
+    	tc358768->vdd_mipi.enable = tc358768_vdd_enable;    
+    if(!tc358768->vdd_mipi.disable)
+    	tc358768->vdd_mipi.disable = tc358768_vdd_disable;
+    	
+    tc358768_gpio_init(NULL);
+    
+    return ret;
+}
+static int tc358768_remove(struct i2c_client *client)
+{
+    tc358768_gpio_deinit(NULL);
+    tc358768_client = NULL;
+    tc358768 = NULL;
+    return 0;
+}
+
+static const struct i2c_device_id tc358768_id[] = {
+	{"tc358768", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tc358768_id);
+
+static struct i2c_driver tc358768_driver = {
+	.probe		= tc358768_probe,
+	.remove		= tc358768_remove,
+	.id_table	= tc358768_id,
+	.driver = {
+		.name	= "tc358768",
+	},
+};
+#else
+
+u32 spi_read_32bits(u32 addr)
+{
+	unsigned int i = 32;
+	//a frame starts
+	CS_CLR();
+	CLK_SET();
+
+	addr <<= 16;
+	addr &= 0xfffe0000;
+	addr |= 0x00010000;
+
+	udelay(2);
+	while(i--) {
+		CLK_CLR();
+		if(addr & 0x80000000)
+			TXD_SET();
+        else
+			TXD_CLR();
+		addr <<= 1;
+		udelay(2);
+		CLK_SET();
+		udelay(2);
+	}
+	//a frame ends
+    CS_SET();
+
+
+    udelay(2);
+    CS_CLR();
+    addr = 0xfffe0000;
+    i = 16;
+	while(i--) {
+		CLK_CLR();
+		if(addr & 0x80000000)
+			TXD_SET();
+        else
+			TXD_CLR();
+		addr <<= 1;
+		udelay(2);
+		CLK_SET();
+		udelay(2);
+	}
+
+	TXD_SET();
+
+	addr = 0;
+    i = 16;
+	while(i--) {
+		CLK_CLR();
+		udelay(1);
+		CLK_SET();
+		udelay(1);
+		if (gpio_get_value(gLcd_info->rxd_pin) == 1)
+			addr |= 1 << i;
+		udelay(1);
+	}
+    CS_SET();
+
+    return addr;
+}
+
+
+//32 bits per frame
+u32 spi_write_32bits(u32 value)
+{
+	int i = 32;
+
+    //a frame starts
+	CS_CLR();
+	CLK_SET();
+
+	while(i--) {
+		CLK_CLR();
+		if(value & 0x80000000)
+			TXD_SET();
+        else
+			TXD_CLR();
+		value <<= 1;
+		CLK_SET();
+	}
+	//a frame ends
+    CS_SET();
+
+    return 0;
+}
+
+#endif
+
+u32 tc358768_wr_reg_32bits(u32 data) {
+#ifdef CONFIG_TC358768_I2C
+	i2c_write_32bits(data);
+#else
+	spi_write_32bits(data);
+#endif
+	return 0;
+}
+
+
+u32 tc358768_wr_reg_32bits_delay(u32 delay, u32 data) {
+	//wait a minute  according to the source format
+    if(delay < 20000)
+    	udelay(delay);
+    else {
+    	mdelay(delay/1000);
+    }
+
+#ifdef CONFIG_TC358768_I2C
+	i2c_write_32bits(data);
+#else
+	spi_write_32bits(data);
+#endif
+	return 0;
+}
+
+
+
+u32 tc358768_rd_reg_32bits(u32 addr) {
+#ifdef CONFIG_TC358768_I2C
+	return i2c_read_32bits(addr);
+#else
+	return spi_read_32bits(addr);
+#endif
+}
+
+
+
+void tc_print(u32 addr) {
+	dsi_debug("+++++++++++addr->%04x: %04x\n", addr, tc358768_rd_reg_32bits(addr));
+}
+
+#define tc358768_wr_regs_32bits(reg_array)  _tc358768_wr_regs_32bits(reg_array, ARRAY_SIZE(reg_array))
+int _tc358768_wr_regs_32bits(unsigned int reg_array[], u32 n) {
+
+	int i = 0;
+	dsi_debug("%s:%d\n", __func__, n);
+	for(i = 0; i < n; i++) {
+		if(reg_array[i] < 0x00020000) {
+		    if(reg_array[i] < 20000)
+		    	udelay(reg_array[i]);
+		    else {
+		    	mdelay(reg_array[i]/1000);
+		    }
+		} else {
+			tc358768_wr_reg_32bits(reg_array[i]);
+		}
+	}
+	return 0;
+}
+
+int tc358768_command_tx_less8bytes(unsigned char type, unsigned char *regs, u32 n) {
+	int i = 0;
+	unsigned int command[] = {
+			0x06020000,
+			0x06040000,
+			0x06100000,
+			0x06120000,
+			0x06140000,
+			0x06160000,
+	};
+
+	if(n <= 2)
+		command[0] |= 0x1000;   //short packet
+	else {
+		command[0] |= 0x4000;   //long packet
+		command[1] |= n;		//word count byte
+	}
+	command[0] |= type;         //data type
+
+	//dsi_debug("*cmd:\n");
+	//dsi_debug("0x%08x\n", command[0]);
+	//dsi_debug("0x%08x\n", command[1]);
+
+	for(i = 0; i < (n + 1)/2; i++) {
+		command[i+2] |= regs[i*2];
+		if((i*2 + 1) < n)
+			command[i+2] |= regs[i*2 + 1] << 8;
+		dsi_debug("0x%08x\n", command[i+2]);
+	}
+
+	_tc358768_wr_regs_32bits(command, (n + 1)/2 + 2);
+	tc358768_wr_reg_32bits(0x06000001);   //Packet Transfer
+	//wait until packet is out
+	i = 100;
+	while(tc358768_rd_reg_32bits(0x0600) & 0x01) {
+		if(i-- == 0)
+			break;
+		tc_print(0x0600);
+	}
+	//udelay(50);
+	return 0;
+}
+
+int tc358768_command_tx_more8bytes_hs(unsigned char type, unsigned char regs[], u32 n) {
+
+	int i = 0;
+	unsigned int dbg_data = 0x00E80000, temp = 0;
+	unsigned int command[] = {
+			0x05000080,    //HS data 4 lane, EOT is added
+			0x0502A300,
+			0x00080001,
+			0x00500000,    //Data ID setting
+			0x00220000,    //Transmission byte count= byte
+			0x00E08000,	   //Enable I2C/SPI write to VB
+			0x00E20048,    //Total word count = 0x48 (max 0xFFF). This value should be adjusted considering trade off between transmission time and transmission start/stop time delay
+			0x00E4007F,    //Vertical blank line = 0x7F
+	};
+
+
+	command[3] |= type;        //data type
+	command[4] |= n & 0xffff;           //Transmission byte count
+
+	tc358768_wr_regs_32bits(command);
+
+	for(i = 0; i < (n + 1)/2; i++) {
+		temp = dbg_data | regs[i*2];
+		if((i*2 + 1) < n)
+			temp |= (regs[i*2 + 1] << 8);
+		//dsi_debug("0x%08x\n", temp);
+		tc358768_wr_reg_32bits(temp);
+	}
+	if((n % 4 == 1) ||  (n % 4 == 2))     //4 bytes align
+		tc358768_wr_reg_32bits(dbg_data);
+
+	tc358768_wr_reg_32bits(0x00E0C000);     //Start command transmisison
+	tc358768_wr_reg_32bits(0x00E00000);	 //Stop command transmission. This setting should be done just after above setting to prevent multiple output
+	udelay(200);
+	//Re-Initialize
+	//tc358768_wr_regs_32bits(re_initialize);
+	return 0;
+}
+
+//low power mode only for tc358768a
+int tc358768_command_tx_more8bytes_lp(unsigned char type, unsigned char regs[], u32 n) {
+
+	int i = 0;
+	unsigned int dbg_data = 0x00E80000, temp = 0;
+	unsigned int command[] = {
+			0x00080001,
+			0x00500000,    //Data ID setting
+			0x00220000,    //Transmission byte count= byte
+			0x00E08000,	   //Enable I2C/SPI write to VB
+	};
+
+	command[1] |= type;        //data type
+	command[2] |= n & 0xffff;           //Transmission byte count
+
+	tc358768_wr_regs_32bits(command);
+
+	for(i = 0; i < (n + 1)/2; i++) {
+		temp = dbg_data | regs[i*2];
+		if((i*2 + 1) < n)
+			temp |= (regs[i*2 + 1] << 8);
+		//dsi_debug("0x%08x\n", temp);
+		tc358768_wr_reg_32bits(temp);
+
+	}
+	if((n % 4 == 1) ||  (n % 4 == 2))     //4 bytes align
+		tc358768_wr_reg_32bits(dbg_data);
+
+	tc358768_wr_reg_32bits(0x00E0E000);     //Start command transmisison
+	udelay(1000);
+	tc358768_wr_reg_32bits(0x00E02000);	 //Keep Mask High to prevent short packets send out
+	tc358768_wr_reg_32bits(0x00E00000);	 //Stop command transmission. This setting should be done just after above setting to prevent multiple output
+	udelay(10);
+	return 0;
+}
+
+int _tc358768_send_packet(unsigned char type, unsigned char regs[], u32 n) {
+
+	if(n <= 8) {
+		tc358768_command_tx_less8bytes(type, regs, n);
+	} else {
+		//tc358768_command_tx_more8bytes_hs(type, regs, n);
+		tc358768_command_tx_more8bytes_lp(type, regs, n);
+	}
+	return 0;
+}
+
+int tc358768_send_packet(unsigned char type, unsigned char regs[], u32 n) {
+	return _tc358768_send_packet(type, regs, n);
+}
+
+
+/*
+The DCS is separated into two functional areas: the User Command Set and the Manufacturer Command
+Set. Each command is an eight-bit code with 00h to AFh assigned to the User Command Set and all other
+codes assigned to the Manufacturer Command Set.
+*/
+int _mipi_dsi_send_dcs_packet(unsigned char regs[], u32 n) {
+
+	unsigned char type = 0;
+	if(n == 1) {
+		type = DTYPE_DCS_SWRITE_0P;
+	} else if (n == 2) {
+		type = DTYPE_DCS_SWRITE_1P;
+	} else if (n > 2) {
+		type = DTYPE_DCS_LWRITE;
+	} 
+	_tc358768_send_packet(type, regs, n);
+	return 0;
+}
+
+int mipi_dsi_send_dcs_packet(unsigned char regs[], u32 n) {
+	return _mipi_dsi_send_dcs_packet(regs, n);
+}
+
+
+int _tc358768_rd_lcd_regs(unsigned char type, char comd, int size, unsigned char* buf) {
+
+	unsigned char regs[8];
+	u32 count = 0, data30, data32;
+	regs[0] = size;
+	regs[1] = 0;
+	tc358768_command_tx_less8bytes(0x37, regs, 2);
+	tc358768_wr_reg_32bits(0x05040010);
+	tc358768_wr_reg_32bits(0x05060000);
+	regs[0] = comd;
+	tc358768_command_tx_less8bytes(type, regs, 1);
+
+	while (!(tc358768_rd_reg_32bits(0x0410) & 0x20)){
+		printk("error 0x0410:%04x\n", tc358768_rd_reg_32bits(0x0410));
+		msleep(1);
+		if(count++ > 10) {
+			break;
+		}
+	}
+	
+	data30 = tc358768_rd_reg_32bits(0x0430);	  //data id , word count[0:7]
+	//printk("0x0430:%04x\n", data30);
+	data32 = tc358768_rd_reg_32bits(0x0432);	  //word count[8:15]  ECC
+	//printk("0x0432:%04x\n", data32);
+	
+	while(size > 0) {
+		data30 = tc358768_rd_reg_32bits(0x0430);	  
+		//printk("0x0430:%04x\n", data30);
+		data32 = tc358768_rd_reg_32bits(0x0432);	  
+		//printk("0x0432:%04x\n", data32);
+	
+		if(size-- > 0)
+			*buf++ = (u8)data30;
+		else
+			break;
+		if(size-- > 0)
+			*buf++ = (u8)(data30 >> 8);
+		else
+			break;
+		if(size-- > 0) {
+			*buf++ = (u8)data32;
+			if(size-- > 0)
+				*buf++ = (u8)(data32 >> 8);
+		}
+	}	
+	
+	data30 = tc358768_rd_reg_32bits(0x0430);	  
+	//printk("0x0430:%04x\n", data30);
+	data32 = tc358768_rd_reg_32bits(0x0432);	  
+	//printk("0x0432:%04x\n", data32);
+	return 0;
+}
+
+int mipi_dsi_read_dcs_packet(unsigned char *data, u32 n) {
+	//DCS READ 
+	_tc358768_rd_lcd_regs(0x06, *data, n, data);
+	return 0;
+}
+
+int tc358768_get_id(void) {
+	
+	int id = -1;
+	
+	tc358768_power_up();
+	id = tc358768_rd_reg_32bits(0);
+	return id;
+}
+
+static struct mipi_dsi_ops tc358768_ops = {
+	.id = 0x4401,
+	.name = "tc358768a",
+	.get_id = tc358768_get_id,
+	.dsi_set_regs = _tc358768_wr_regs_32bits,
+	.dsi_send_dcs_packet = mipi_dsi_send_dcs_packet,
+	.dsi_read_dcs_packet = mipi_dsi_read_dcs_packet,
+	.power_up = tc358768_power_up,
+	.power_down = tc358768_power_down,
+	
+};
+
+static int __init tc358768_module_init(void)
+{
+#ifdef CONFIG_TC358768_I2C    
+    i2c_add_driver(&tc358768_driver);
+    
+	if(!tc358768 || !tc358768_client)
+		return -1;
+#endif		
+		
+	register_dsi_ops(&tc358768_ops);
+	if(tc358768->id > 0)
+		tc358768_ops.id = tc358768->id;
+    return 0;
+}
+
+static void __exit tc358768_module_exit(void)
+{
+	del_dsi_ops(&tc358768_ops);
+#ifdef CONFIG_TC358768_I2C
+	i2c_del_driver(&tc358768_driver);
+#endif
+}
+
+subsys_initcall_sync(tc358768_module_init);
+//module_exit(tc358768_module_init);
+module_exit(tc358768_module_exit);
diff -Nupr a/drivers/video/rockchip/transmitter/vga.c b/drivers/video/rockchip/transmitter/vga.c
--- a/drivers/video/rockchip/transmitter/vga.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/transmitter/vga.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,343 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/display-sys.h>
+#include <linux/rk_screen.h>
+#include <linux/rk_fb.h>
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "../../edid.h"
+
+#ifdef CONFIG_SWITCH
+#include <linux/switch.h>
+#endif
+	
+
+#define DDC_ADDR		0x50
+#define DDC_I2C_RATE		100*1000
+#define INVALID_GPIO		-1
+#define GPIO_HIGH		1
+#define GPIO_LOW		0
+#define DISPLAY_SOURCE_LCDC0    0
+#define DISPLAY_SOURCE_LCDC1    1
+
+//static char *vgaenvent[] = {"INTERFACE=VGA", NULL}; 
+
+static const struct fb_videomode rk29_mode[] = {
+	//name			refresh		xres	yres	pixclock			h_bp	h_fp	v_bp	v_fp	h_pw	v_pw	polariry	PorI	flag(used for vic)
+{	"1024x768p@60Hz",	60,		1024,	768,	KHZ2PICOS(65000),	160,	24,	29,	3,	136,	6,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		0	},
+{	"1280x720p@60Hz",	60,		1280,	720,	KHZ2PICOS(74250),	220,	110,	20,	5,	40,	5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		0	},	
+{	"1280x1024p@60Hz",	60,		1280,	1024,	KHZ2PICOS(108000),	248,	48,	38,	1,	112,	3,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		0	},
+{	"1366x768p@60Hz",	60,		1366,	768,	KHZ2PICOS(85500),	213,	70,	24,	3,	143,	3,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		0	},
+{	"1440x900p@60Hz",	60,		1440,	900,	KHZ2PICOS(116500),	232,	80,	25,	3,	152,	6,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		0	},
+{	"1680x1050p@60Hz",	60,		1680,	1050,	KHZ2PICOS(146250),	280,	104,	30,	3,	176,	6,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		0	},
+{	"1920x1080p@60Hz",	60,		1920,	1080,	KHZ2PICOS(148500),	148,	88,	36,	4,	44,	5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		0	},
+};
+
+struct rockchip_vga {
+	struct device 		 *dev;	/*i2c device*/
+	struct rk_display_device *ddev; /*display device*/
+	struct i2c_client 	 *client;
+	struct list_head	 modelist;
+	struct fb_monspecs	 specs;
+	struct rk_screen	 screen;
+	int 			 indx;
+	int 			 en_pin;
+	int 			 en_val;
+	int 			 lcdc_id;
+#ifdef CONFIG_SWITCH
+	struct switch_dev	 switch_vga;
+#endif
+};
+
+static int i2c_master_reg8_recv(const struct i2c_client *client,
+		const char reg, char *buf, int count, int scl_rate)
+{
+        struct i2c_adapter *adap=client->adapter;
+        struct i2c_msg msgs[2];
+        int ret;
+        char reg_buf = reg;
+
+        msgs[0].addr = client->addr;
+        msgs[0].flags = client->flags;
+        msgs[0].len = 1;
+        msgs[0].buf = &reg_buf;
+        msgs[0].scl_rate = scl_rate;
+
+        msgs[1].addr = client->addr;
+        msgs[1].flags = client->flags | I2C_M_RD;
+        msgs[1].len = count;
+        msgs[1].buf = (char *)buf;
+        msgs[1].scl_rate = scl_rate;
+
+        ret = i2c_transfer(adap, msgs, 2);
+
+        return (ret == 2)? count : ret;
+}
+
+
+
+static unsigned char *rk29fb_ddc_read(struct i2c_client *client)
+{
+	int rc;
+	unsigned char *buf = kzalloc(EDID_LENGTH, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&client->dev, "unable to allocate memory for EDID\n");
+		return NULL;
+	}
+	
+	/*Check ddc i2c communication is available or not*/
+	rc = i2c_master_reg8_recv(client, 0, buf, 6, DDC_I2C_RATE);
+	if (rc == 6) {
+		memset(buf, 0, EDID_LENGTH);
+		rc = i2c_master_reg8_recv(client, 0, buf, EDID_LENGTH, DDC_I2C_RATE);
+		if(rc == EDID_LENGTH)
+			return buf;
+	}
+
+	dev_err(&client->dev, "unable to read EDID block.\n");
+	kfree(buf);
+	return NULL;
+}
+
+static int vga_mode2screen(struct fb_videomode *modedb, struct rk_screen *screen)
+{
+	if(modedb == NULL || screen == NULL)
+		return -1;
+		
+	memset(screen, 0, sizeof(struct rk_screen));
+	memcpy(&screen->mode, modedb, sizeof(*modedb));
+	screen->mode.pixclock = PICOS2KHZ(screen->mode.pixclock);
+	screen->mode.pixclock /= 250;
+	screen->mode.pixclock *= 250;
+	screen->mode.pixclock *= 1000;
+	screen->xsize = screen->mode.xres;
+	screen->ysize = screen->mode.yres;
+	screen->overscan.left = 100;
+	screen->overscan.top = 100;
+	screen->overscan.right = 100;
+	screen->overscan.bottom = 100;
+	/* screen type & face */
+	screen->type = SCREEN_RGB;
+	screen->face = OUT_P888;
+
+	screen->pin_vsync = (screen->mode.sync & FB_SYNC_VERT_HIGH_ACT) ? 1:0;
+	screen->pin_hsync = (screen->mode.sync & FB_SYNC_HOR_HIGH_ACT) ? 1:0;
+	screen->pin_den = 0;
+	screen->pin_dclk = 0;
+
+	/* Swap rule */
+	screen->swap_rb = 0;
+	screen->swap_rg = 0;
+	screen->swap_gb = 0;
+	screen->swap_delta = 0;
+	screen->swap_dumy = 0;
+	/* Operation function*/
+	screen->init = NULL;
+	screen->standby = NULL;
+	return 0;
+}
+
+
+static int vga_switch_screen(struct rockchip_vga *vga, int indx)
+{
+	struct fb_videomode *mode = &vga->specs.modedb[indx];
+	struct rk_screen *screen = &vga->screen;
+	vga_mode2screen(mode, screen);
+	rk_fb_switch_screen(screen, 1 ,vga->lcdc_id);
+	vga->indx = indx;
+	return 0;
+	
+	
+}
+static int vga_get_screen_info(struct rockchip_vga *vga)
+{
+	u8 *edid;
+	int i;
+	struct fb_monspecs *specs = &vga->specs;
+	struct list_head *modelist = &vga->modelist;
+	edid = rk29fb_ddc_read(vga->client);
+	if (!edid) {
+		dev_info(vga->dev, "get edid failed!\n");
+		return -EINVAL;
+	}
+	fb_edid_to_monspecs(edid,specs);
+	INIT_LIST_HEAD(modelist);
+	for (i = 0; i < specs->modedb_len; i++) {
+		fb_add_videomode(&specs->modedb[i], modelist);
+		dev_dbg(vga->dev, "%4dx%4d@%d---dclk:%ld\n",
+			specs->modedb[i].xres, specs->modedb[i].yres,
+			specs->modedb[i].refresh,
+			(PICOS2KHZ(specs->modedb[i].pixclock)/250)*250*1000);
+	}
+	return 0;
+	
+}
+
+
+
+static int vga_get_modelist(struct rk_display_device *device,
+			     struct list_head **modelist)
+{
+	struct rockchip_vga *vga = device->priv_data;
+	*modelist = &vga->modelist;
+	return 0;
+}
+
+static int vga_set_mode(struct rk_display_device *device,
+			 struct fb_videomode *mode)
+{
+	struct rockchip_vga *vga = device->priv_data;
+	struct rk_screen *screen = &vga->screen;
+	vga_mode2screen(mode, screen);
+	rk_fb_switch_screen(screen, 1 ,vga->lcdc_id);
+	return 0;
+}
+
+static int vga_get_mode(struct rk_display_device *device,
+			 struct fb_videomode *mode)
+{
+	//struct vga *vga = device->priv_data;
+	//struct fb_videomode *vmode;
+
+	return 0;
+}
+
+struct rk_display_ops vga_display_ops = {
+	.getmodelist = vga_get_modelist,
+	.setmode = vga_set_mode,
+	.getmode = vga_get_mode,
+};
+
+static int vga_display_probe(struct rk_display_device *device, void *devdata)
+{
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "VGA");
+	device->priority = DISPLAY_PRIORITY_VGA;
+	device->priv_data = devdata;
+	device->ops = &vga_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_vga = {
+	.probe = vga_display_probe,
+};
+
+
+
+struct rk_display_device * vga_register_display_sysfs(struct rockchip_vga *vga)
+{
+	return rk_display_device_register(&display_vga, vga->dev, vga);
+}
+
+void vga_unregister_display_sysfs(struct rockchip_vga *vga)
+{
+	if (vga->ddev)
+		rk_display_device_unregister(vga->ddev);
+}
+
+
+static int vga_i2c_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{    
+	int ret;
+	struct rockchip_vga *vga;
+	struct device_node *np = client->dev.of_node;
+	enum of_gpio_flags pwr_flags;
+
+	if (!np) {
+		dev_err(&client->dev, "no device node found!\n");
+		return -EINVAL;
+	} 
+
+	vga = devm_kzalloc(&client->dev, sizeof(*vga), GFP_KERNEL);
+	if (!vga) {
+		dev_err(&client->dev, "allocate for vga failed!\n");
+		return -ENOMEM;
+	}
+
+	vga->client = client;
+	vga->dev = &client->dev;
+	i2c_set_clientdata(client, vga);
+	vga->ddev = vga_register_display_sysfs(vga);
+	if (IS_ERR(vga->ddev))
+		dev_warn(vga->dev, "Unable to create device for vga :%ld",
+			PTR_ERR(vga->ddev));
+	
+	vga->en_pin = of_get_named_gpio_flags(np, "pwr_gpio", 0, &pwr_flags);
+	if (!gpio_is_valid(vga->en_pin)) {
+		dev_err(vga->dev, "failed to get pwr_gpio!\n");
+		ret =  -EINVAL;
+		goto err;
+	}
+
+	vga->en_val = (pwr_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+	vga->lcdc_id = DISPLAY_SOURCE_LCDC1;
+	
+	ret = devm_gpio_request(vga->dev, vga->en_pin, "pwr_pin");
+	if(ret < 0) {
+		dev_err(vga->dev, "request for pwr_pin failed!\n ");
+		goto err;
+	}
+	gpio_direction_output(vga->en_pin, vga->en_val);
+	ret = vga_get_screen_info(vga);
+	if (ret < 0)
+		goto err;
+	vga_switch_screen(vga, 7);
+	
+	printk("VGA probe successful\n");
+	return 0;
+err:
+	vga_unregister_display_sysfs(vga);
+	return ret;
+	
+}
+
+
+static int vga_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+
+#if defined(CONFIG_OF)
+static struct of_device_id vga_dt_ids[] = {
+	{.compatible = "rockchip,vga" },
+	{ }
+};
+#endif
+
+static const struct i2c_device_id vga_id[] = {
+	{ "vga_i2c", 0 },
+	{ }
+};
+
+static struct i2c_driver vga_i2c_driver  = {
+	.driver = {
+		.name  = "vga_i2c",
+		.owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(vga_dt_ids),
+#endif
+	},
+	.probe		= &vga_i2c_probe,
+	.remove		= &vga_i2c_remove,
+	.id_table	= vga_id,
+};
+
+static int __init rockchip_vga_init(void)
+{
+    return i2c_add_driver(&vga_i2c_driver);
+}
+
+static void __exit rockchip_vga_exit(void)
+{
+    i2c_del_driver(&vga_i2c_driver);
+}
+
+module_init(rockchip_vga_init);
+module_exit(rockchip_vga_exit);
diff -Nupr a/drivers/video/rockchip/tve/gm7122/gm7122_tve.c b/drivers/video/rockchip/tve/gm7122/gm7122_tve.c
--- a/drivers/video/rockchip/tve/gm7122/gm7122_tve.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/gm7122/gm7122_tve.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,491 @@
+/*
+ * gm7122_tve.c
+ *
+ * Driver for rockchip gm7122 tv encoder control
+ * Copyright (C) 2015
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *
+ */
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#include <linux/display-sys.h>
+#include <linux/rockchip/grf.h>
+#include <linux/rockchip/iomap.h>
+#include "gm7122_tve.h"
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/mfd/core.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/mfd/syscon.h>
+
+static const struct fb_videomode gm7122_cvbs_mode[] = {
+/*name		refresh		xres	yres	pixclock	h_bp	h_fp	v_bp	v_fp	h_pw	v_pw	polariry	PorI				flag */
+{"NTSC",	60,		720,	480,	27000000,	57,	19,	15,	4,	62,	3,	0,		FB_VMODE_INTERLACED,		0},
+{"PAL",		50,		720,	576,	27000000,	62,	14,	17,	2,	68,	5,	0,		FB_VMODE_INTERLACED,		0},
+};
+
+static struct gm7122_tve *gm7122_tve;
+
+static int cvbsformat;
+
+#define tve_writel(offset, v)	gm7122_i2c_send(offset, v)
+/*#define tve_readl(offset, *v)	gm7122_i2c_recv(offset, v)*/
+
+#ifdef DEBUG
+#define TVEDBG(format, ...) \
+		dev_info(gm7122_tve->dev,\
+		 "GM7122 TVE: " format "\n", ## __VA_ARGS__)
+#else
+#define TVEDBG(format, ...)
+#endif
+
+int gm7122_i2c_send(const u8 reg, const u8 value)
+{
+	char buf[2];
+	int ret;
+
+	buf[0] = reg;
+	buf[1] = value;
+	ret = i2c_master_send(gm7122_tve->client, buf, 2);
+	if (ret != 2) {
+		TVEDBG("gm7122 control i2c write err,ret =%d\n", ret);
+		return -1;
+	}
+	return 0;
+}
+
+int gm7122_i2c_recv(const u8 reg, char *value)
+{
+	int ret;
+
+	ret = i2c_master_send(gm7122_tve->client, &reg, 1);
+	i2c_master_recv(gm7122_tve->client, value, 1);
+	pr_info("%s reg = 0x%x , value = 0x%c\n", __func__, reg, *value);
+	return (ret == 2) ? 0 : -1;
+}
+
+
+static void tve_set_mode(int mode)
+{
+	TVEDBG("%s mode %d\n", __func__, mode);
+	if (cvbsformat >= 0)
+		return;
+
+	if (mode == TVOUT_CVBS_NTSC) {
+		tve_writel(BURST_START, V_D0_BS0(1) | V_D0_BS5(1));
+		tve_writel(BURST_END, V_D0_BE0(1) | V_D0_BE2(1) |
+			V_D0_BE3(1) | V_D0_BE4(1));
+		tve_writel(INPUT_PORT_CTL, V_SYMP(1) | V_UV2C(1) | V_Y2C(1));
+		tve_writel(COLOR_DIFF_CTL, 0x00);
+		tve_writel(U_GAIN_CTL, V_GAINU0(1) | V_GAINU2(1) |
+			V_GAINU3(3) | V_GAINU5(1) | V_GAINU6(1));
+		tve_writel(V_GAIN_CTL, V_GAINV0(1) | V_GAINV1(1) |
+			V_GAINV2(1) | V_GAINV3(1) | V_GAINV4(1) |
+			V_GAINV7(1));
+		tve_writel(UMSB_BLACK_GAIN,	V_BLACK1(1) | V_BLACK2(1) |
+			V_BLACK3(1));
+		tve_writel(VMSB_BLNNL_GAIN, V_BLNNL2(1) | V_BLNNL3(1) |
+			V_BLNNL4(1));
+		tve_writel(STANDARD_CTL, V_PAL(0) | V_BIT0(1));
+		tve_writel(RTCEN_BURST_CTL, V_BSTA0(1) | V_BSTA1(1)|
+			V_BSTA3(1) | V_BSTA4(1) | V_BSTA5(1));
+		tve_writel(SUBCARRIER0, V_FSC00(1) | V_FSC01(1)|
+			V_FSC02(1) | V_FSC03(1) | V_FSC04(1));
+		tve_writel(SUBCARRIER1, V_FSC10(1) | V_FSC11(1)|
+			V_FSC12(1) | V_FSC13(1) | V_FSC14(1));
+		tve_writel(SUBCARRIER2, V_FSC20(1) | V_FSC21(1) |
+			V_FSC22(1) | V_FSC23(1));
+		tve_writel(SUBCARRIER3, V_FSC29(1) | V_FSC24(1));
+		tve_writel(RCV_PORT_CTL, 0x00);
+		tve_writel(TRIG0_CTL, V_HTRIG0(1) | V_HTRIG2(1) | V_HTRIG4(1) |
+				       V_HTRIG5(1) | V_HTRIG6(1) | V_HTRIG7(1));
+		tve_writel(TRIG1_CTL, V_VTRIG0(1) | V_VTRIG4(1) | V_HTRIG8(1) |
+				      V_HTRIG10(1));
+	} else if (mode == TVOUT_CVBS_PAL) {
+		tve_writel(BURST_START, V_D0_BS0(1) | V_D0_BS5(1));
+		tve_writel(BURST_END, V_D0_BE0(1) | V_D0_BE2(1) |
+			V_D0_BE3(1) | V_D0_BE4(1));
+		tve_writel(INPUT_PORT_CTL, V_SYMP(1) | V_UV2C(1) | V_Y2C(1));
+		/*tve_writel(INPUT_PORT_CTL, 0x93);*//*color bar for debug*/
+		tve_writel(COLOR_DIFF_CTL, V_CHPS0(1));
+		tve_writel(U_GAIN_CTL, V_GAINU1(1) | V_GAINU3(1) |
+			V_GAINU5(1) | V_GAINU6(1));
+		tve_writel(V_GAIN_CTL, V_GAINV0(1) | V_GAINV1(1) |
+			V_GAINV2(1) | V_GAINV3(1) | V_GAINV4(1) |
+			V_GAINV7(1));
+		tve_writel(UMSB_BLACK_GAIN,	V_BLACK1(1) | V_BLACK4(1));
+		tve_writel(VMSB_BLNNL_GAIN, V_BLNNL0(1) | V_BLNNL1(1) |
+			V_BLNNL2(1) | V_BLNNL3(1) | V_BLNNL4(1));
+		tve_writel(STANDARD_CTL, V_PAL(1) | V_SCBW(1));
+		tve_writel(RTCEN_BURST_CTL, V_BSTA0(1) | V_BSTA1(1)|
+			V_BSTA3(1) | V_BSTA4(1) | V_BSTA5(1));
+		tve_writel(SUBCARRIER0, V_FSC00(1) | V_FSC01(1)|
+			V_FSC03(1) | V_FSC06(1) | V_FSC07(1));
+		tve_writel(SUBCARRIER1, V_FSC15(1) | V_FSC11(1)|
+			V_FSC09(1));
+		tve_writel(SUBCARRIER2, V_FSC19(1) | V_FSC16(1));
+		tve_writel(SUBCARRIER3, V_FSC29(1) | V_FSC27(1) | V_FSC25(1));
+		tve_writel(RCV_PORT_CTL, 0x00);
+		tve_writel(TRIG0_CTL, V_HTRIG0(1) | V_HTRIG2(1) | V_HTRIG4(1) |
+				       V_HTRIG5(1) | V_HTRIG6(1) | V_HTRIG7(1));
+		tve_writel(TRIG1_CTL, V_VTRIG0(1) | V_VTRIG4(1) | V_HTRIG8(1) |
+				      V_HTRIG10(1));
+	}
+}
+
+static int tve_switch_fb(const struct fb_videomode *modedb, int enable)
+{
+	struct rk_screen *screen = &gm7122_tve->screen;
+
+	if (modedb == NULL)
+		return -1;
+
+	memset(screen, 0, sizeof(struct rk_screen));
+	/* screen type & face */
+	/*screen->type = SCREEN_TVOUT;*/
+	screen->type = SCREEN_RGB;
+	screen->face = OUT_CCIR656;
+	screen->color_mode = COLOR_YCBCR;
+	screen->mode = *modedb;
+	/*screen->mode.vmode = 0;*/
+
+	/* Pin polarity */
+	if (FB_SYNC_HOR_HIGH_ACT & modedb->sync)
+		screen->pin_hsync = 1;
+	else
+		screen->pin_hsync = 0;
+	if (FB_SYNC_VERT_HIGH_ACT & modedb->sync)
+		screen->pin_vsync = 1;
+	else
+		screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = 1;
+	/*screen->pixelrepeat = 1;*/
+
+	/* Swap rule */
+	screen->swap_rb = 0;
+	screen->swap_rg = 0;
+	screen->swap_gb = 0;
+	screen->swap_delta = 0;
+	screen->swap_dumy = 0;
+	screen->overscan.left = 100;
+	screen->overscan.top = 100;
+	screen->overscan.right = 100;
+	screen->overscan.bottom = 100;
+	/* Operation function*/
+	screen->init = NULL;
+	screen->standby = NULL;
+	rk_fb_switch_screen(screen, enable, gm7122_tve->lcdcid);
+	if (enable) {
+		if (screen->mode.yres == 480)
+			tve_set_mode(TVOUT_CVBS_NTSC);
+		else
+			tve_set_mode(TVOUT_CVBS_PAL);
+	}
+	return 0;
+}
+
+static int cvbs_set_enable(struct rk_display_device *device, int enable)
+{
+	if (gm7122_tve->enable != enable) {
+		gm7122_tve->enable = enable;
+		if (gm7122_tve->suspend)
+			return 0;
+
+		if (enable == 0) {
+			/*tve_enable(false);*/
+			cvbsformat = -1;
+			tve_switch_fb(gm7122_tve->mode, 0);
+		} else if (enable == 1) {
+			tve_switch_fb(gm7122_tve->mode, 1);
+			/*tve_enable(true);*/
+		}
+	}
+	return 0;
+}
+
+static int cvbs_get_enable(struct rk_display_device *device)
+{
+	TVEDBG("%s enable %d\n", __func__, gm7122_tve->enable);
+	return gm7122_tve->enable;
+}
+
+static int cvbs_get_status(struct rk_display_device *device)
+{
+	return 1;
+}
+
+static int
+cvbs_get_modelist(struct rk_display_device *device, struct list_head **modelist)
+{
+	*modelist = &(gm7122_tve->modelist);
+	return 0;
+}
+
+static int
+cvbs_set_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(gm7122_cvbs_mode); i++) {
+		if (fb_mode_is_equal(&gm7122_cvbs_mode[i], mode)) {
+			if (gm7122_tve->mode != &gm7122_cvbs_mode[i]) {
+				gm7122_tve->mode =
+				(struct fb_videomode *)&gm7122_cvbs_mode[i];
+				if (gm7122_tve->enable &&
+				    !gm7122_tve->suspend) {
+					/*tve_enable(false);*/
+					if (!fb_mode_is_equal(gm7122_tve->mode,
+							      mode)) {
+						gpio_set_value(
+						gm7122_tve->io_sleep.gpio,
+						gm7122_tve->io_sleep.active);
+						msleep(20);
+						gpio_set_value(
+						gm7122_tve->io_sleep.gpio,
+						!(gm7122_tve->io_sleep.active));
+					}
+					tve_switch_fb(gm7122_tve->mode, 1);
+				}
+					/*tve_enable(true);*/
+			}
+			return 0;
+		}
+	}
+	TVEDBG("%s\n", __func__);
+	return -1;
+}
+
+static int
+cvbs_get_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	*mode = *(gm7122_tve->mode);
+	return 0;
+}
+
+static int
+tve_fb_event_notify(struct notifier_block *self,
+		    unsigned long action, void *data)
+{
+	struct fb_event *event = data;
+
+	if (action == FB_EARLY_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			break;
+		default:
+			TVEDBG("suspend tve\n");
+			if (!gm7122_tve->suspend) {
+				gm7122_tve->suspend = 1;
+				if (gm7122_tve->enable) {
+					tve_switch_fb(gm7122_tve->mode, 0);
+					/*tve_enable(false);*/
+				}
+			}
+			break;
+		}
+	} else if (action == FB_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			TVEDBG("resume tve\n");
+			if (gm7122_tve->suspend) {
+				gm7122_tve->suspend = 0;
+				if (gm7122_tve->enable) {
+					tve_switch_fb(gm7122_tve->mode, 1);
+					/*tve_enable(true);*/
+				}
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block tve_fb_notifier = {
+	.notifier_call = tve_fb_event_notify,
+};
+
+static struct rk_display_ops cvbs_display_ops = {
+	.setenable = cvbs_set_enable,
+	.getenable = cvbs_get_enable,
+	.getstatus = cvbs_get_status,
+	.getmodelist = cvbs_get_modelist,
+	.setmode = cvbs_set_mode,
+	.getmode = cvbs_get_mode,
+};
+
+static int
+display_cvbs_probe(struct rk_display_device *device, void *devdata)
+{
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "TV");
+	device->name = "cvbs";
+	device->priority = DISPLAY_PRIORITY_TV;
+	device->property = 0;/*just for test*/
+	device->priv_data = devdata;
+	device->ops = &cvbs_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_cvbs = {
+	.probe = display_cvbs_probe,
+};
+
+#if defined(CONFIG_OF)
+static const struct i2c_device_id gm7122_tve_dt_ids[] = {
+	{ "gm7122_tve", 0 },
+	{}
+};
+#endif
+
+static int __init bootloader_tve_setup(char *str)
+{
+	if (str) {
+		pr_info("cvbs init tve.format is %s\n", str);
+		if (kstrtoint(str, 0, &cvbsformat) < 0)
+			cvbsformat = -1;
+	}
+	return 0;
+}
+
+early_param("tve.format", bootloader_tve_setup);
+
+
+static int gm7122_tve_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int i;
+	struct device_node *gm7122_np;
+	enum of_gpio_flags flags;
+	int ret;
+
+	gm7122_tve = kmalloc(sizeof(*gm7122_tve), GFP_KERNEL);
+	if (!gm7122_tve) {
+		dev_err(&client->dev, "gm7122 tv encoder device kmalloc fail!\n");
+		return -ENOMEM;
+	}
+	memset(gm7122_tve, 0, sizeof(*gm7122_tve));
+	gm7122_tve->client = client;
+	gm7122_tve->dev = &client->dev;
+	gm7122_np = gm7122_tve->dev->of_node;
+	of_property_read_u32(gm7122_np, "rockchip,source", &(ret));
+	gm7122_tve->lcdcid = ret;
+	of_property_read_u32(gm7122_np, "rockchip,prop", &(ret));
+	gm7122_tve->property = ret;
+	/********Get reset pin***********/
+	gm7122_tve->io_reset.gpio = of_get_named_gpio_flags(gm7122_np, "gpio-reset",
+							    0, &flags);
+	if (!gpio_is_valid(gm7122_tve->io_reset.gpio)) {
+		TVEDBG("invalid gm7122_tve->io_reset.gpio: %d\n",
+		       gm7122_tve->io_reset.gpio);
+		goto failout;
+		}
+	ret = gpio_request(gm7122_tve->io_reset.gpio, "gm7122-reset-io");
+	if (ret != 0) {
+		TVEDBG("gpio_request gm7122_tve->io_reset.gpio invalid: %d\n",
+		       gm7122_tve->io_reset.gpio);
+		goto failout;
+		}
+	gm7122_tve->io_reset.active = (flags & OF_GPIO_ACTIVE_LOW);
+	gpio_direction_output(gm7122_tve->io_reset.gpio,
+			      !(gm7122_tve->io_reset.active));
+	gpio_set_value(gm7122_tve->io_reset.gpio,
+		       !(gm7122_tve->io_reset.active));
+	/********Reset pin end***********/
+	/********Get sleep pin***********/
+	gm7122_tve->io_sleep.gpio = of_get_named_gpio_flags(gm7122_np, "gpio-sleep", 0, &flags);
+	if (!gpio_is_valid(gm7122_tve->io_sleep.gpio)) {
+		TVEDBG("invalid gm7122_tve->io_reset.gpio: %d\n",
+		       gm7122_tve->io_sleep.gpio);
+		}
+	ret = gpio_request(gm7122_tve->io_sleep.gpio, "gm7122-sleep-io");
+	if (ret != 0) {
+		TVEDBG("gpio_request gm7122_tve->io_reset.gpio invalid: %d\n",
+		       gm7122_tve->io_sleep.gpio);
+		goto failout;
+		}
+	gm7122_tve->io_sleep.active = !(flags & OF_GPIO_ACTIVE_LOW);
+	gpio_direction_output(gm7122_tve->io_sleep.gpio,
+			      !(gm7122_tve->io_sleep.active));
+	gpio_set_value(gm7122_tve->io_sleep.gpio,
+		       !(gm7122_tve->io_sleep.active));
+	/********Sleep pin end***********/
+	INIT_LIST_HEAD(&(gm7122_tve->modelist));
+	for (i = 0; i < ARRAY_SIZE(gm7122_cvbs_mode); i++)
+		fb_add_videomode(&gm7122_cvbs_mode[i], &(gm7122_tve->modelist));
+	if (cvbsformat >= 0) {
+		gm7122_tve->mode =
+			(struct fb_videomode *)&gm7122_cvbs_mode[cvbsformat];
+		/*gm7122_tve->enable = 1;
+		tve_switch_fb(gm7122_tve->mode, 1);*/
+	} else {
+		gm7122_tve->mode = (struct fb_videomode *)&gm7122_cvbs_mode[1];
+	}
+	gm7122_tve->ddev =
+		rk_display_device_register(&display_cvbs,
+					   gm7122_tve->dev, NULL);
+	rk_display_device_enable(gm7122_tve->ddev);
+	fb_register_client(&tve_fb_notifier);
+	cvbsformat = -1;
+	pr_info("%s tv encoder probe ok!\n", __func__);
+	return 0;
+
+failout:
+	kfree(gm7122_tve);
+	return -ENODEV;
+}
+
+/*static void gm7122_tve_shutdown(struct platform_device *pdev)
+{
+}*/
+static int gm7122_tve_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, gm7122_tve_dt_ids);
+
+static struct i2c_driver gm7122_tve_driver = {
+	.probe = gm7122_tve_probe,
+	.remove = gm7122_tve_remove,
+	.driver = {
+		.name = "gm7122_tve",
+		.owner = THIS_MODULE,
+	},
+	/*.shutdown = gm7122_tve_shutdown,*/
+	.id_table = gm7122_tve_dt_ids,
+};
+
+static int __init gm7122_tve_init(void)
+{
+	return  i2c_add_driver(&gm7122_tve_driver);
+}
+
+static void __exit gm7122_tve_exit(void)
+{
+	i2c_del_driver(&gm7122_tve_driver);
+}
+
+module_init(gm7122_tve_init);
+module_exit(gm7122_tve_exit);
+
+
+MODULE_DESCRIPTION("ROCKCHIP GM7122 TV Encoder ");
+MODULE_AUTHOR("Rock-chips, <www.rock-chips.com>");
+MODULE_LICENSE("GPL");
diff -Nupr a/drivers/video/rockchip/tve/gm7122/gm7122_tve.h b/drivers/video/rockchip/tve/gm7122/gm7122_tve.h
--- a/drivers/video/rockchip/tve/gm7122/gm7122_tve.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/gm7122/gm7122_tve.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,356 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __GM7122_TVE_H__
+#define __GM7122_TVE_H__
+
+#include<linux/regmap.h>
+#include<linux/io.h>
+
+#define BURST_START			(0x28)
+	#define M_D5_BS0		(1 << 5)
+	#define M_D4_BS0		(1 << 4)
+	#define M_D3_BS0		(1 << 3)
+	#define M_D2_BS0		(1 << 2)
+	#define M_D1_BS0		(1 << 1)
+	#define M_D0_BS0		(1 << 0)
+
+	#define V_D0_BS5(x)		((x & 1) << 5)
+	#define V_D0_BS4(x)		((x & 1) << 4)
+	#define V_D0_BS3(x)		((x & 1) << 3)
+	#define V_D0_BS2(x)		((x & 1) << 2)
+	#define V_D0_BS1(x)		((x & 1) << 1)
+	#define V_D0_BS0(x)		((x & 1) << 0)
+
+#define BURST_END			(0x29)
+	#define M_D5_BE0		(1 << 5)
+	#define M_D4_BE0		(1 << 4)
+	#define M_D3_BE0		(1 << 3)
+	#define M_D2_BE0		(1 << 2)
+	#define M_D1_BE0		(1 << 1)
+	#define M_D0_BE0		(1 << 0)
+
+	#define V_D0_BE5(x)		((x & 1) << 5)
+	#define V_D0_BE4(x)		((x & 1) << 4)
+	#define V_D0_BE3(x)		((x & 1) << 3)
+	#define V_D0_BE2(x)		((x & 1) << 2)
+	#define V_D0_BE1(x)		((x & 1) << 1)
+	#define V_D0_BE0(x)		((x & 1) << 0)
+
+#define DA_MODE_CTL			(0x2F)
+	#define M_DA7			(1 << 7)
+	#define M_DA3			(1 << 3)
+	#define M_DA2			(1 << 2)
+
+	#define V_DA7(x)		((x & 1) << 7)
+	#define V_DA3(x)		((x & 1) << 3)
+	#define V_DA2(x)		((x & 1) << 2)
+
+#define INPUT_PORT_CTL			(0x3A)
+	#define M_CBENB			(1 << 7)
+	#define M_SYMP			(1 << 4)
+	#define M_Y2C			(1 << 1)
+	#define M_UV2C			(1 << 0)
+
+	#define V_CBENB(x)		((x & 1) << 7)
+	#define V_SYMP(x)		((x & 1) << 4)
+	#define V_Y2C(x)		((x & 1) << 1)
+	#define V_UV2C(x)		((x & 1) << 0)
+
+#define COLOR_DIFF_CTL			(0x5A)
+	#define M_CHPS7			(1 << 7)
+	#define M_CHPS6			(1 << 6)
+	#define M_CHPS5			(1 << 5)
+	#define M_CHPS4			(1 << 4)
+	#define M_CHPS3			(1 << 3)
+	#define M_CHPS2			(1 << 2)
+	#define M_CHPS1			(1 << 1)
+	#define M_CHPS0			(1 << 0)
+
+	#define V_CHPS7(x)		((x & 1) << 7)
+	#define V_CHPS6(x)		((x & 1) << 6)
+	#define V_CHPS5(x)		((x & 1) << 5)
+	#define V_CHPS4(x)		((x & 1) << 4)
+	#define V_CHPS3(x)		((x & 1) << 3)
+	#define V_CHPS2(x)		((x & 1) << 2)
+	#define V_CHPS1(x)		((x & 1) << 1)
+	#define V_CHPS0(x)		((x & 1) << 0)
+
+#define U_GAIN_CTL			(0x5B)
+	#define M_GAINU7		(1 << 7)
+	#define M_GAINU6		(1 << 6)
+	#define M_GAINU5		(1 << 5)
+	#define M_GAINU4		(1 << 4)
+	#define M_GAINU3		(1 << 3)
+	#define M_GAINU2		(1 << 2)
+	#define M_GAINU1		(1 << 1)
+	#define M_GAINU0		(1 << 0)
+
+	#define V_GAINU7(x)		((x & 1) << 7)
+	#define V_GAINU6(x)		((x & 1) << 6)
+	#define V_GAINU5(x)		((x & 1) << 5)
+	#define V_GAINU4(x)		((x & 1) << 4)
+	#define V_GAINU3(x)		((x & 1) << 3)
+	#define V_GAINU2(x)		((x & 1) << 2)
+	#define V_GAINU1(x)		((x & 1) << 1)
+	#define V_GAINU0(x)		((x & 1) << 0)
+
+#define V_GAIN_CTL			(0x5C)
+	#define M_GAINV7		(1 << 7)
+	#define M_GAINV6		(1 << 6)
+	#define M_GAINV5		(1 << 5)
+	#define M_GAINV4		(1 << 4)
+	#define M_GAINV3		(1 << 3)
+	#define M_GAINV2		(1 << 2)
+	#define M_GAINV1		(1 << 1)
+	#define M_GAINV0		(1 << 0)
+
+	#define V_GAINV7(x)		((x & 1) << 7)
+	#define V_GAINV6(x)		((x & 1) << 6)
+	#define V_GAINV5(x)		((x & 1) << 5)
+	#define V_GAINV4(x)		((x & 1) << 4)
+	#define V_GAINV3(x)		((x & 1) << 3)
+	#define V_GAINV2(x)		((x & 1) << 2)
+	#define V_GAINV1(x)		((x & 1) << 1)
+	#define V_GAINV0(x)		((x & 1) << 0)
+
+#define UMSB_BLACK_GAIN			(0x5D)
+	#define M_GAINU8		(1 << 7)
+	#define M_BLACK5		(1 << 5)
+	#define M_BLACK4		(1 << 4)
+	#define M_BLACK3		(1 << 3)
+	#define M_BLACK2		(1 << 2)
+	#define M_BLACK1		(1 << 1)
+	#define M_BLACK0		(1 << 0)
+
+	#define V_GAINU8(x)		((x & 1) << 7)
+	#define V_BLACK5(x)		((x & 1) << 5)
+	#define V_BLACK4(x)		((x & 1) << 4)
+	#define V_BLACK3(x)		((x & 1) << 3)
+	#define V_BLACK2(x)		((x & 1) << 2)
+	#define V_BLACK1(x)		((x & 1) << 1)
+	#define V_BLACK0(x)		((x & 1) << 0)
+
+#define VMSB_BLNNL_GAIN			(0x5E)
+	#define M_GAINV8		(1 << 7)
+	#define M_BLNNL5		(1 << 5)
+	#define M_BLNNL4		(1 << 4)
+	#define M_BLNNL3		(1 << 3)
+	#define M_BLNNL2		(1 << 2)
+	#define M_BLNNL1		(1 << 1)
+	#define M_BLNNL0		(1 << 0)
+
+	#define V_GAINV8(x)		((x & 1) << 7)
+	#define V_BLNNL5(x)		((x & 1) << 5)
+	#define V_BLNNL4(x)		((x & 1) << 4)
+	#define V_BLNNL3(x)		((x & 1) << 3)
+	#define V_BLNNL2(x)		((x & 1) << 2)
+	#define V_BLNNL1(x)		((x & 1) << 1)
+	#define V_BLNNL0(x)		((x & 1) << 0)
+
+#define STANDARD_CTL			(0x61)
+	#define M_SCBW			(1 << 2)
+	#define M_PAL			(1 << 1)
+	#define M_BIT0			(1 << 0)
+
+	#define V_SCBW(x)		((x & 1) << 2)
+	#define V_PAL(x)		((x & 1) << 1)
+	#define V_BIT0(x)		((x & 1) << 0)
+
+#define RTCEN_BURST_CTL			(0x62)
+	#define M_RTCEN			(1 << 7)
+	#define M_BSTA6			(1 << 6)
+	#define M_BSTA5			(1 << 5)
+	#define M_BSTA4			(1 << 4)
+	#define M_BSTA3			(1 << 3)
+	#define M_BSTA2			(1 << 2)
+	#define M_BSTA1			(1 << 1)
+	#define M_BSTA0			(1 << 0)
+
+	#define V_RTCEN(x)		((x & 1) << 7)
+	#define V_BSTA6(x)		((x & 1) << 6)
+	#define V_BSTA5(x)		((x & 1) << 5)
+	#define V_BSTA4(x)		((x & 1) << 4)
+	#define V_BSTA3(x)		((x & 1) << 3)
+	#define V_BSTA2(x)		((x & 1) << 2)
+	#define V_BSTA1(x)		((x & 1) << 1)
+	#define V_BSTA0(x)		((x & 1) << 0)
+
+#define SUBCARRIER0			(0x63)
+	#define M_FSC07			(1 << 7)
+	#define M_FSC06			(1 << 6)
+	#define M_FSC05			(1 << 5)
+	#define M_FSC04			(1 << 4)
+	#define M_FSC03			(1 << 3)
+	#define M_FSC02			(1 << 2)
+	#define M_FSC01			(1 << 1)
+	#define M_FSC00			(1 << 0)
+
+	#define V_FSC07(x)		((x & 1) << 7)
+	#define V_FSC06(x)		((x & 1) << 6)
+	#define V_FSC05(x)		((x & 1) << 5)
+	#define V_FSC04(x)		((x & 1) << 4)
+	#define V_FSC03(x)		((x & 1) << 3)
+	#define V_FSC02(x)		((x & 1) << 2)
+	#define V_FSC01(x)		((x & 1) << 1)
+	#define V_FSC00(x)		((x & 1) << 0)
+
+#define SUBCARRIER1			(0x64)
+	#define M_FSC15			(1 << 7)
+	#define M_FSC14			(1 << 6)
+	#define M_FSC13			(1 << 5)
+	#define M_FSC12			(1 << 4)
+	#define M_FSC11			(1 << 3)
+	#define M_FSC10			(1 << 2)
+	#define M_FSC09			(1 << 1)
+	#define M_FSC08			(1 << 0)
+
+	#define V_FSC15(x)		((x & 1) << 7)
+	#define V_FSC14(x)		((x & 1) << 6)
+	#define V_FSC13(x)		((x & 1) << 5)
+	#define V_FSC12(x)		((x & 1) << 4)
+	#define V_FSC11(x)		((x & 1) << 3)
+	#define V_FSC10(x)		((x & 1) << 2)
+	#define V_FSC09(x)		((x & 1) << 1)
+	#define V_FSC08(x)		((x & 1) << 0)
+
+#define SUBCARRIER2			(0x65)
+	#define M_FSC23			(1 << 7)
+	#define M_FSC22			(1 << 6)
+	#define M_FSC21			(1 << 5)
+	#define M_FSC20			(1 << 4)
+	#define M_FSC19			(1 << 3)
+	#define M_FSC18			(1 << 2)
+	#define M_FSC17			(1 << 1)
+	#define M_FSC16			(1 << 0)
+
+	#define V_FSC23(x)		((x & 1) << 7)
+	#define V_FSC22(x)		((x & 1) << 6)
+	#define V_FSC21(x)		((x & 1) << 5)
+	#define V_FSC20(x)		((x & 1) << 4)
+	#define V_FSC19(x)		((x & 1) << 3)
+	#define V_FSC18(x)		((x & 1) << 2)
+	#define V_FSC17(x)		((x & 1) << 1)
+	#define V_FSC16(x)		((x & 1) << 0)
+
+#define SUBCARRIER3			(0x66)
+	#define M_FSC31			(1 << 7)
+	#define M_FSC30			(1 << 6)
+	#define M_FSC29			(1 << 5)
+	#define M_FSC28			(1 << 4)
+	#define M_FSC27			(1 << 3)
+	#define M_FSC26			(1 << 2)
+	#define M_FSC25			(1 << 1)
+	#define M_FSC24			(1 << 0)
+
+	#define V_FSC31(x)		((x & 1) << 7)
+	#define V_FSC30(x)		((x & 1) << 6)
+	#define V_FSC29(x)		((x & 1) << 5)
+	#define V_FSC28(x)		((x & 1) << 4)
+	#define V_FSC27(x)		((x & 1) << 3)
+	#define V_FSC26(x)		((x & 1) << 2)
+	#define V_FSC25(x)		((x & 1) << 1)
+	#define V_FSC24(x)		((x & 1) << 0)
+
+#define RCV_PORT_CTL			(0x6B)
+	#define M_ORCV1			(1 << 4)
+	#define M_PRCV1			(1 << 3)
+	#define M_ORCV2			(1 << 1)
+	#define M_PRCV2			(1 << 0)
+
+	#define V_ORCV1(x)		((x & 1) << 4)
+	#define V_PRCV1(x)		((x & 1) << 3)
+	#define V_ORCV2(x)		((x & 1) << 1)
+	#define V_PRCV2(x)		((x & 1) << 0)
+
+
+#define TRIG0_CTL			(0x6C)
+	#define M_HTRIG7		(1 << 7)
+	#define M_HTRIG6		(1 << 6)
+	#define M_HTRIG5		(1 << 5)
+	#define M_HTRIG4		(1 << 4)
+	#define M_HTRIG3		(1 << 3)
+	#define M_HTRIG2		(1 << 2)
+	#define M_HTRIG1		(1 << 1)
+	#define M_HTRIG0		(1 << 0)
+
+	#define V_HTRIG7(x)		((x & 1) << 7)
+	#define V_HTRIG6(x)		((x & 1) << 6)
+	#define V_HTRIG5(x)		((x & 1) << 5)
+	#define V_HTRIG4(x)		((x & 1) << 4)
+	#define V_HTRIG3(x)		((x & 1) << 3)
+	#define V_HTRIG2(x)		((x & 1) << 2)
+	#define V_HTRIG1(x)		((x & 1) << 1)
+	#define V_HTRIG0(x)		((x & 1) << 0)
+
+#define TRIG1_CTL			(0x6D)
+	#define M_HTRIG10		(1 << 7)
+	#define M_HTRIG9		(1 << 6)
+	#define M_HTRIG8		(1 << 5)
+	#define M_VTRIG4		(1 << 4)
+	#define M_VTRIG3		(1 << 3)
+	#define M_VTRIG2		(1 << 2)
+	#define M_VTRIG1		(1 << 1)
+	#define M_VTRIG0		(1 << 0)
+
+	#define V_HTRIG10(x)		((x & 1) << 7)
+	#define V_HTRIG9(x)		((x & 1) << 6)
+	#define V_HTRIG8(x)		((x & 1) << 5)
+	#define V_VTRIG4(x)		((x & 1) << 4)
+	#define V_VTRIG3(x)		((x & 1) << 3)
+	#define V_VTRIG2(x)		((x & 1) << 2)
+	#define V_VTRIG1(x)		((x & 1) << 1)
+	#define V_VTRIG0(x)		((x & 1) << 0)
+
+#define TRIG2_CTL			(0x75)
+	#define M_VTRIG8		(1 << 7)
+	#define M_VTRIG7		(1 << 6)
+	#define M_VTRIG6		(1 << 5)
+	#define M_VTRIG5		(1 << 4)
+
+	#define V_VTRIG8(x)		((x & 1) << 7)
+	#define V_VTRIG7(x)		((x & 1) << 6)
+	#define V_VTRIG6(x)		((x & 1) << 5)
+	#define V_VTRIG5(x)		((x & 1) << 4)
+
+enum {
+	TVOUT_CVBS_NTSC = 0,
+	TVOUT_CVBS_PAL,
+};
+
+enum {
+	INPUT_FORMAT_RGB = 0,
+	INPUT_FORMAT_YUV,
+	INPUT_FORMAT_CCIR656
+};
+
+enum {
+	SOC_RK1000 = 0,
+	SOC_GM7122
+};
+
+#define TVOUT_DEAULT TVOUT_CVBS_PAL
+
+struct ioctrl {
+	int gpio;
+	int active;
+};
+
+struct gm7122_tve {
+	struct device			*dev;
+	u32				reg_phy_base;
+	u32				len;
+	unsigned int			lcdcid;
+	unsigned int			property;
+	struct rk_display_device	*ddev;
+	unsigned int			enable;
+	unsigned int			suspend;
+	struct fb_videomode		*mode;
+	struct list_head		modelist;
+	struct rk_screen		screen;
+	struct i2c_client		*client;
+	struct ioctrl			io_reset;
+	struct ioctrl			io_sleep;
+};
+
+#define GM7122_I2C_RATE	(100*1000)
+
+#endif
diff -Nupr a/drivers/video/rockchip/tve/gm7122/Kconfig b/drivers/video/rockchip/tve/gm7122/Kconfig
--- a/drivers/video/rockchip/tve/gm7122/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/gm7122/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+config GM7122_TV_ENCODER
+	bool "gm7122 tv encoder support"
+	depends on RK_TVENCODER
+	default n
+	help
+		Support GM7122 output CVBS.
diff -Nupr a/drivers/video/rockchip/tve/gm7122/Makefile b/drivers/video/rockchip/tve/gm7122/Makefile
--- a/drivers/video/rockchip/tve/gm7122/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/gm7122/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the gm7122 tv encoder control.
+#
+obj-$(CONFIG_GM7122_TV_ENCODER)	+= gm7122_tve.o
diff -Nupr a/drivers/video/rockchip/tve/Kconfig b/drivers/video/rockchip/tve/Kconfig
--- a/drivers/video/rockchip/tve/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# TV Encoder drivers configuration
+#
+
+menuconfig RK_TVENCODER
+	bool "Rockchip TV Encoder support"
+   	depends on FB_ROCKCHIP
+	help
+		Support RockChip TV Encoder if you say y here.
+
+source "drivers/video/rockchip/tve/rk1000/Kconfig"
+source "drivers/video/rockchip/tve/rk3036/Kconfig"
+source "drivers/video/rockchip/tve/rk610/Kconfig"
+source "drivers/video/rockchip/tve/gm7122/Kconfig"
diff -Nupr a/drivers/video/rockchip/tve/Makefile b/drivers/video/rockchip/tve/Makefile
--- a/drivers/video/rockchip/tve/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for tv encoder.
+#
+
+obj-$(CONFIG_RK610_TVOUT)		+= rk610/
+obj-$(CONFIG_RK3036_TV_ENCODER)		+= rk3036/
+obj-$(CONFIG_RK1000_TVOUT)		+= rk1000/
+obj-$(CONFIG_GM7122_TV_ENCODER)		+= gm7122/
diff -Nupr a/drivers/video/rockchip/tve/rk1000/Kconfig b/drivers/video/rockchip/tve/rk1000/Kconfig
--- a/drivers/video/rockchip/tve/rk1000/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk1000/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,19 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# TV Encoder RK1000 drivers configuration
+#
+
+config RK1000_TVOUT
+	bool "RK1000 TV Encoder support"
+	depends on RK_TVENCODER
+	select MFD_RK1000
+	help
+		Support rk1000 to output YPbPr and CVBS.
+		
+config RK1000_TVOUT_YPbPr
+	bool "Support YPbPr Output"
+	depends on RK1000_TVOUT
+config RK1000_TVOUT_CVBS
+	bool "Support CVBS Output"
+	depends on RK1000_TVOUT
+
diff -Nupr a/drivers/video/rockchip/tve/rk1000/Makefile b/drivers/video/rockchip/tve/rk1000/Makefile
--- a/drivers/video/rockchip/tve/rk1000/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk1000/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the RK1000 tv control.
+#
+obj-$(CONFIG_RK1000_TVOUT)		+= rk1000_tve.o
+obj-$(CONFIG_RK1000_TVOUT_YPbPr)	+= rk1000_tve_ypbpr.o
+obj-$(CONFIG_RK1000_TVOUT_CVBS)		+= rk1000_tve_cvbs.o
diff -Nupr a/drivers/video/rockchip/tve/rk1000/rk1000_tve.c b/drivers/video/rockchip/tve/rk1000/rk1000_tve.c
--- a/drivers/video/rockchip/tve/rk1000/rk1000_tve.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk1000/rk1000_tve.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,397 @@
+/*
+ * rk1000_tv.c
+ *
+ * Driver for rockchip rk1000 tv control
+ *  Copyright (C) 2009
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *
+ */
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <dt-bindings/rkfb/rk_fb.h>
+#endif
+#include "rk1000_tve.h"
+
+struct rk1000_tve rk1000_tve;
+int cvbsformat = -1;
+
+int rk1000_tv_write_block(u8 reg, u8 *buf, u8 len)
+{
+	int i, ret;
+
+	for (i = 0; i < len; i++) {
+		ret = rk1000_i2c_send(I2C_ADDR_TVE, reg + i, buf[i]);
+		if (ret)
+			break;
+	}
+	return ret;
+}
+
+int rk1000_control_write_block(u8 reg, u8 *buf, u8 len)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < len; i++) {
+		ret = rk1000_i2c_send(I2C_ADDR_CTRL, reg + i, buf[i]);
+		if (ret)
+			break;
+	}
+	return ret;
+}
+
+static int __init bootloader_rk1000_setup(char *str)
+{
+	if (str) {
+		pr_info("cvbs init tve.format is %s\n", str);
+		if (kstrtoint(str, 0, &cvbsformat) < 0)
+			cvbsformat = -1;
+	}
+	return 0;
+}
+
+early_param("tve.format", bootloader_rk1000_setup);
+
+int rk1000_switch_fb(const struct fb_videomode *modedb, int tv_mode)
+{
+	struct rk_screen *screen;
+
+	if (modedb == NULL)
+		return -1;
+	screen =  kzalloc(sizeof(*screen), GFP_KERNEL);
+	if (screen == NULL)
+		return -1;
+	memset(screen, 0, sizeof(*screen));
+	/* screen type & face */
+	screen->type = SCREEN_RGB;
+	screen->face = OUT_P888;
+	screen->mode = *modedb;
+	screen->mode.vmode = 0;
+	/* Pin polarity */
+	if (FB_SYNC_HOR_HIGH_ACT & modedb->sync)
+		screen->pin_hsync = 1;
+	else
+		screen->pin_hsync = 0;
+	if (FB_SYNC_VERT_HIGH_ACT & modedb->sync)
+		screen->pin_vsync = 1;
+	else
+		screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = 0;
+	/* Swap rule */
+	screen->swap_rb = 0;
+	screen->swap_rg = 0;
+	screen->swap_gb = 0;
+	screen->swap_delta = 0;
+	screen->swap_dumy = 0;
+	screen->overscan.left = 95;
+	screen->overscan.top = 95;
+	screen->overscan.right = 95;
+	screen->overscan.bottom = 95;
+	/* Operation function*/
+	screen->init = NULL;
+	screen->standby = NULL;
+	switch (tv_mode) {
+	#ifdef CONFIG_RK1000_TVOUT_CVBS
+	case TVOUT_CVBS_NTSC:
+		screen->init = rk1000_tv_ntsc_init;
+	break;
+	case TVOUT_CVBS_PAL:
+		screen->init = rk1000_tv_pal_init;
+	break;
+	#endif
+	#ifdef CONFIG_RK1000_TVOUT_YPBPR
+	case TVOUT_YPBPR_720X480P_60:
+		screen->init = rk1000_tv_ypbpr480_init;
+	break;
+	case TVOUT_YPBPR_720X576P_50:
+		screen->init = rk1000_tv_ypbpr576_init;
+	break;
+	case TVOUT_YPBPR_1280X720P_50:
+		screen->init = rk1000_tv_ypbpr720_50_init;
+	break;
+	case TVOUT_YPBPR_1280X720P_60:
+		screen->init = rk1000_tv_ypbpr720_60_init;
+	break;
+	#endif
+	default:
+		kfree(screen);
+		return -1;
+	}
+	rk_fb_switch_screen(screen, 1 , rk1000_tve.video_source);
+	rk1000_tve.mode = tv_mode;
+	kfree(screen);
+	if (gpio_is_valid(rk1000_tve.io_switch.gpio)) {
+		if (tv_mode < TVOUT_YPBPR_720X480P_60)
+			gpio_direction_output(rk1000_tve.io_switch.gpio,
+					      !(rk1000_tve.io_switch.active));
+		else
+			gpio_direction_output(rk1000_tve.io_switch.gpio,
+					      rk1000_tve.io_switch.active);
+	}
+	return 0;
+}
+
+int rk1000_tv_standby(int type)
+{
+	unsigned char val;
+	int ret;
+	int ypbpr;
+	int cvbs;
+	struct rk_screen screen;
+
+	ypbpr = 0;
+	cvbs = 0;
+	if (rk1000_tve.ypbpr)
+		ypbpr = rk1000_tve.ypbpr->enable;
+	if (rk1000_tve.cvbs)
+		cvbs = rk1000_tve.cvbs->enable;
+	if (cvbs || ypbpr)
+		return 0;
+/*	val = 0x00;
+	ret = rk1000_control_write_block(0x03, &val, 1);
+	if (ret < 0) {
+		pr_err("rk1000_control_write_block err!\n");
+		return ret;
+	} */
+	val = 0x07;
+	ret = rk1000_tv_write_block(0x03, &val, 1);
+	if (ret < 0) {
+		pr_err("rk1000_tv_write_block err!\n");
+		return ret;
+	}
+	screen.type = SCREEN_RGB;
+	rk_fb_switch_screen(&screen, 0 , rk1000_tve.video_source);
+	pr_err("rk1000 tve standby\n");
+	return 0;
+}
+
+static int rk1000_tve_initial(void)
+{
+	struct rk_screen screen;
+
+	/* RK1000 tvencoder i2c reg need dclk, so we open lcdc.*/
+	memset(&screen, 0, sizeof(struct rk_screen));
+	/* screen type & face */
+	screen.type = SCREEN_RGB;
+	screen.face = OUT_P888;
+	/* Screen size */
+	screen.mode.xres = 720;
+	screen.mode.yres = 480;
+	/* Timing */
+	screen.mode.pixclock = 27000000;
+	screen.mode.refresh = 60;
+	screen.mode.left_margin = 116;
+	screen.mode.right_margin = 16;
+	screen.mode.hsync_len = 6;
+	screen.mode.upper_margin = 25;
+	screen.mode.lower_margin = 14;
+	screen.mode.vsync_len = 6;
+	rk_fb_switch_screen(&screen, 2 , rk1000_tve.video_source);
+	/* Power down RK1000 output DAC. */
+	if (cvbsformat < 0)
+		return rk1000_i2c_send(I2C_ADDR_TVE, 0x03, 0x07);
+	else
+		return 0;
+}
+
+
+static void rk1000_early_suspend(void *h)
+{
+	pr_info("rk1000_early_suspend\n");
+	if (rk1000_tve.ypbpr) {
+		if (rk1000_tve.ypbpr->enable)
+			rk1000_tve.ypbpr->ddev->ops->setenable(
+			rk1000_tve.ypbpr->ddev, 0);
+		if (!rk1000_tve.ypbpr->suspend)
+			rk1000_tve.ypbpr->suspend = 1;
+	}
+	if (rk1000_tve.cvbs) {
+		if (rk1000_tve.cvbs->enable)
+			rk1000_tve.cvbs->ddev->ops->setenable(
+			rk1000_tve.cvbs->ddev, 0);
+		if (!rk1000_tve.cvbs->suspend)
+			rk1000_tve.cvbs->suspend = 1;
+	}
+}
+
+
+static void rk1000_early_resume(void *h)
+{
+	pr_info("rk1000 tve exit early resume\n");
+	if (rk1000_tve.cvbs) {
+		if (rk1000_tve.cvbs->suspend)
+			rk1000_tve.cvbs->suspend = 0;
+		if (rk1000_tve.mode < TVOUT_YPBPR_720X480P_60) {
+			rk_display_device_enable(
+			(rk1000_tve.cvbs)->ddev);
+		}
+	}
+	if (rk1000_tve.ypbpr) {
+		if (rk1000_tve.ypbpr->suspend)
+			rk1000_tve.ypbpr->suspend = 0;
+		if (rk1000_tve.mode > TVOUT_CVBS_PAL) {
+			rk_display_device_enable(
+			(rk1000_tve.ypbpr)->ddev);
+		}
+	}
+}
+
+
+static int rk1000_fb_event_notify(struct notifier_block *self,
+				  unsigned long action, void *data)
+{
+	struct fb_event *event;
+
+	event = data;
+	if (action == FB_EARLY_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+		break;
+		default:
+		rk1000_early_suspend(NULL);
+		break;
+		}
+	} else if (action == FB_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			rk1000_early_resume(NULL);
+		break;
+		default:
+		break;
+		}
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block rk1000_fb_notifier = {
+	.notifier_call = rk1000_fb_event_notify,
+};
+
+static int rk1000_tve_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct device_node *tve_np;
+	enum of_gpio_flags flags;
+	int rc;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	memset(&rk1000_tve, 0, sizeof(struct rk1000_tve));
+	rk1000_tve.client = client;
+#ifdef CONFIG_OF
+	tve_np = client->dev.of_node;
+	rk1000_tve.io_switch.gpio = of_get_named_gpio_flags(tve_np,
+							    "gpio-reset",
+							    0, &flags);
+	if (gpio_is_valid(rk1000_tve.io_switch.gpio)) {
+		rc = gpio_request(rk1000_tve.io_switch.gpio,
+				  "rk1000-tve-swicth-io");
+		if (!rc) {
+			rk1000_tve.io_switch.active = !(flags &
+							OF_GPIO_ACTIVE_LOW);
+			gpio_direction_output(rk1000_tve.io_switch.gpio,
+					      !(rk1000_tve.io_switch.active));
+		} else
+			pr_err("gpio request rk1000-tve-swicth-io err: %d\n",
+			       rk1000_tve.io_switch.gpio);
+	}
+	of_property_read_u32(tve_np, "rockchip,source", &(rc));
+	rk1000_tve.video_source = rc;
+	of_property_read_u32(tve_np, "rockchip,prop", &(rc));
+	rk1000_tve.property = rc - 1;
+	pr_err("video src is lcdc%d, prop is %d\n", rk1000_tve.video_source,
+	       rk1000_tve.property);
+#endif
+	if (cvbsformat >= 0) {
+		rk1000_tve.mode = cvbsformat + 1;
+	} else {
+		rk1000_tve.mode = RK1000_TVOUT_DEAULT;
+		rc = rk1000_tve_initial();
+		if (rc) {
+			dev_err(&client->dev,
+				"rk1000 tvencoder probe error %d\n", rc);
+			return -EINVAL;
+		}
+	}
+
+#ifdef CONFIG_RK1000_TVOUT_YPBPR
+	rk1000_register_display_ypbpr(&client->dev);
+#endif
+
+#ifdef CONFIG_RK1000_TVOUT_CVBS
+	rk1000_register_display_cvbs(&client->dev);
+#endif
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	rk1000_tve.early_suspend.suspend = rk1000_early_suspend;
+	rk1000_tve.early_suspend.resume = rk1000_early_resume;
+	rk1000_tve.early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 11;
+	register_early_suspend(&(rk1000_tve.early_suspend));
+	#endif
+	fb_register_client(&rk1000_fb_notifier);
+	pr_info("rk1000 tvencoder ver 2.0 probe ok\n");
+	return 0;
+}
+
+static int rk1000_tve_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static void rk1000_tve_shutdown(struct i2c_client *client)
+{
+	rk1000_i2c_send(I2C_ADDR_TVE, 0x03, 0x07);
+}
+
+static const struct i2c_device_id rk1000_tve_id[] = {
+	{ "rk1000_tve", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, rk1000_tve_id);
+
+static struct i2c_driver rk1000_tve_driver = {
+	.driver		= {
+		.name	= "rk1000_tve",
+	},
+	.id_table = rk1000_tve_id,
+	.probe = rk1000_tve_probe,
+	.remove = rk1000_tve_remove,
+	.shutdown = rk1000_tve_shutdown,
+};
+
+static int __init rk1000_tve_init(void)
+{
+	int ret;
+
+	ret = i2c_add_driver(&rk1000_tve_driver);
+	if (ret < 0)
+		pr_err("i2c_add_driver err, ret = %d\n", ret);
+	return ret;
+}
+
+static void __exit rk1000_tve_exit(void)
+{
+	i2c_del_driver(&rk1000_tve_driver);
+}
+
+late_initcall(rk1000_tve_init);
+module_exit(rk1000_tve_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ROCKCHIP rk1000 TV Encoder ");
+MODULE_LICENSE("GPL");
diff -Nupr a/drivers/video/rockchip/tve/rk1000/rk1000_tve_cvbs.c b/drivers/video/rockchip/tve/rk1000/rk1000_tve_cvbs.c
--- a/drivers/video/rockchip/tve/rk1000/rk1000_tve_cvbs.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk1000/rk1000_tve_cvbs.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,208 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include "rk1000_tve.h"
+
+
+
+static const struct fb_videomode rk1000_cvbs_mode[] = {
+	{"NTSC", 60, 720, 480, 27000000, 116, 16, 25, 14, 6, 6, 0, 1, 0},
+	{"PAL", 50, 720, 576, 27000000, 126, 12, 37, 6, 6, 6, 0, 1, 0},
+};
+
+static struct rk1000_monspecs cvbs_monspecs;
+extern int cvbsformat;
+static int changeflag;
+
+int rk1000_tv_ntsc_init(void)
+{
+	unsigned char tv_encoder_regs[] = {0x00, 0x00, 0x00, 0x03, 0x00, 0x00};
+	unsigned char tv_encoder_control_regs[] = {0x43, 0x01};
+	int i;
+	int ret;
+
+	if (cvbsformat >= 0)
+		return 0;
+
+	for (i = 0; i < sizeof(tv_encoder_regs); i++) {
+		ret = rk1000_tv_write_block(i, tv_encoder_regs + i, 1);
+		if (ret < 0) {
+			pr_err("rk1000_tv_write_block err!\n");
+			return ret;
+		}
+	}
+
+	for (i = 0; i < sizeof(tv_encoder_control_regs); i++) {
+		ret = rk1000_control_write_block(i + 3,
+						 tv_encoder_control_regs + i,
+						 1);
+		if (ret < 0) {
+			pr_err("rk1000_control_write_block err!\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int rk1000_tv_pal_init(void)
+{
+	unsigned char tv_encoder_regs[] = {0x06, 0x00, 0x00, 0x03, 0x00, 0x00};
+	unsigned char tv_encoder_control_regs[] = {0x41, 0x01};
+	int i;
+	int ret;
+
+	if (cvbsformat >= 0)
+		return 0;
+
+	for (i = 0; i < sizeof(tv_encoder_regs); i++) {
+		ret = rk1000_tv_write_block(i, tv_encoder_regs+i, 1);
+		if (ret < 0) {
+			pr_err("rk1000_tv_write_block err!\n");
+			return ret;
+		}
+	}
+
+	for (i = 0; i < sizeof(tv_encoder_control_regs); i++) {
+		ret = rk1000_control_write_block(i + 3,
+						 tv_encoder_control_regs + i,
+						 1);
+		if (ret < 0) {
+			pr_err("rk1000_control_write_block err!\n");
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int rk1000_cvbs_set_enable(struct rk_display_device *device, int enable)
+{
+	unsigned char val;
+
+	if (cvbs_monspecs.suspend)
+		return 0;
+	if ((cvbs_monspecs.enable != enable) ||
+	    (cvbs_monspecs.mode_set != rk1000_tve.mode)) {
+		if ((enable == 0) && cvbs_monspecs.enable) {
+			cvbs_monspecs.enable = 0;
+			rk1000_tv_standby(RK1000_TVOUT_CVBS);
+		} else if (enable == 1) {
+			if (cvbsformat >= 0) {
+				rk1000_switch_fb(cvbs_monspecs.mode,
+						 cvbs_monspecs.mode_set);
+				cvbsformat = -1;
+			} else{
+				val = 0x07;
+				rk1000_tv_write_block(0x03, &val, 1);
+				rk1000_switch_fb(cvbs_monspecs.mode,
+						 cvbs_monspecs.mode_set);
+				if (changeflag == 1)
+					msleep(600);
+				val = 0x03;
+				rk1000_tv_write_block(0x03, &val, 1);
+			}
+			cvbs_monspecs.enable = 1;
+			changeflag = 0;
+		}
+	}
+	return 0;
+}
+
+static int rk1000_cvbs_get_enable(struct rk_display_device *device)
+{
+	return cvbs_monspecs.enable;
+}
+
+static int rk1000_cvbs_get_status(struct rk_display_device *device)
+{
+	if (rk1000_tve.mode < TVOUT_YPBPR_720X480P_60)
+		return 1;
+	else
+		return 0;
+}
+
+static int rk1000_cvbs_get_modelist(struct rk_display_device *device,
+				    struct list_head **modelist)
+{
+	*modelist = &(cvbs_monspecs.modelist);
+	return 0;
+}
+
+static int rk1000_cvbs_set_mode(struct rk_display_device *device,
+				struct fb_videomode *mode)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rk1000_cvbs_mode); i++) {
+		if (fb_mode_is_equal(&rk1000_cvbs_mode[i], mode)) {
+			if (((i + 1) != rk1000_tve.mode)) {
+				cvbs_monspecs.mode_set = i + 1;
+				cvbs_monspecs.mode = (struct fb_videomode *)
+							&rk1000_cvbs_mode[i];
+				changeflag = 1;
+			}
+			return 0;
+		}
+	}
+	return -1;
+}
+
+static int rk1000_cvbs_get_mode(struct rk_display_device *device,
+				struct fb_videomode *mode)
+{
+	*mode = *(cvbs_monspecs.mode);
+	return 0;
+}
+
+static struct rk_display_ops rk1000_cvbs_display_ops = {
+	.setenable = rk1000_cvbs_set_enable,
+	.getenable = rk1000_cvbs_get_enable,
+	.getstatus = rk1000_cvbs_get_status,
+	.getmodelist = rk1000_cvbs_get_modelist,
+	.setmode = rk1000_cvbs_set_mode,
+	.getmode = rk1000_cvbs_get_mode,
+};
+
+static int rk1000_display_cvbs_probe(struct rk_display_device *device,
+				     void *devdata)
+{
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "TV");
+	device->name = "cvbs";
+	device->priority = DISPLAY_PRIORITY_TV;
+	device->property = rk1000_tve.property;
+	device->priv_data = devdata;
+	device->ops = &rk1000_cvbs_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_rk1000_cvbs = {
+	.probe = rk1000_display_cvbs_probe,
+};
+
+int rk1000_register_display_cvbs(struct device *parent)
+{
+	int i;
+
+	memset(&cvbs_monspecs, 0, sizeof(struct rk1000_monspecs));
+	INIT_LIST_HEAD(&cvbs_monspecs.modelist);
+	for (i = 0; i < ARRAY_SIZE(rk1000_cvbs_mode); i++)
+		display_add_videomode(&rk1000_cvbs_mode[i],
+				      &cvbs_monspecs.modelist);
+	if (rk1000_tve.mode < TVOUT_YPBPR_720X480P_60) {
+		cvbs_monspecs.mode = (struct fb_videomode *)
+				      &(rk1000_cvbs_mode[rk1000_tve.mode - 1]);
+		cvbs_monspecs.mode_set = rk1000_tve.mode;
+	} else {
+		cvbs_monspecs.mode = (struct fb_videomode *)
+					&(rk1000_cvbs_mode[0]);
+		cvbs_monspecs.mode_set = TVOUT_CVBS_NTSC;
+	}
+	cvbs_monspecs.ddev = rk_display_device_register(&display_rk1000_cvbs,
+							parent, NULL);
+	rk1000_tve.cvbs = &cvbs_monspecs;
+	if (rk1000_tve.mode < TVOUT_YPBPR_720X480P_60)
+		rk_display_device_enable(cvbs_monspecs.ddev);
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/tve/rk1000/rk1000_tve.h b/drivers/video/rockchip/tve/rk1000/rk1000_tve.h
--- a/drivers/video/rockchip/tve/rk1000/rk1000_tve.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk1000/rk1000_tve.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,79 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RK1000_TVE_H
+#define _RK1000_TVE_H
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#include <linux/display-sys.h>
+#include <linux/mfd/rk1000.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+/******************* TVOUT OUTPUT TYPE **********************/
+struct rk1000_monspecs {
+	struct rk_display_device *ddev;
+	unsigned int enable;
+	unsigned int suspend;
+	struct fb_videomode *mode;
+	struct list_head modelist;
+	unsigned int mode_set;
+};
+
+struct rk1000_tve {
+	struct device *dev;
+	struct i2c_client *client;
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+	#endif
+	struct ioctrl io_switch;
+	int video_source;
+	int property;
+	int mode;
+	struct rk1000_monspecs *cvbs;
+	struct rk1000_monspecs *ypbpr;
+};
+
+extern struct rk1000_tve rk1000_tve;
+
+enum {
+	TVOUT_CVBS_NTSC = 1,
+	TVOUT_CVBS_PAL,
+	TVOUT_YPBPR_720X480P_60,
+	TVOUT_YPBPR_720X576P_50,
+	TVOUT_YPBPR_1280X720P_50,
+	TVOUT_YPBPR_1280X720P_60
+};
+
+enum {
+	RK1000_TVOUT_CVBS = 0,
+	RK1000_TVOUT_YC,
+	RK1000_TVOUT_YPBPR,
+};
+#ifdef CONFIG_RK1000_TVOUT_CVBS
+#define RK1000_TVOUT_DEAULT TVOUT_CVBS_PAL
+#else
+#define RK1000_TVOUT_DEAULT TVOUT_YPBPR_1280X720P_60
+#endif
+
+int rk1000_control_write_block(u8 reg, u8 *buf, u8 len);
+int rk1000_tv_write_block(u8 reg, u8 *buf, u8 len);
+int rk1000_tv_standby(int type);
+int rk1000_switch_fb(const struct fb_videomode *modedb, int tv_mode);
+int rk1000_register_display(struct device *parent);
+
+#ifdef CONFIG_RK1000_TVOUT_YPBPR
+int rk1000_tv_ypbpr480_init(void);
+int rk1000_tv_ypbpr576_init(void);
+int rk1000_tv_ypbpr720_50_init(void);
+int rk1000_tv_ypbpr720_60_init(void);
+int rk1000_register_display_ypbpr(struct device *parent);
+#endif
+
+#ifdef CONFIG_RK1000_TVOUT_CVBS
+int rk1000_tv_ntsc_init(void);
+int rk1000_tv_pal_init(void);
+int rk1000_register_display_cvbs(struct device *parent);
+#endif
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/tve/rk1000/rk1000_tve_ypbpr.c b/drivers/video/rockchip/tve/rk1000/rk1000_tve_ypbpr.c
--- a/drivers/video/rockchip/tve/rk1000/rk1000_tve_ypbpr.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk1000/rk1000_tve_ypbpr.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,240 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include "rk1000_tve.h"
+
+static const struct fb_videomode rk1000_ypbpr_mode[] = {
+	{"YPBPR480P", 60, 720, 480, 27000000, 70, 6, 30, 9, 62, 6, 0, 0, 0},
+	{"YPBPR576P", 50, 720, 576, 27000000, 74, 6, 39, 5, 64, 5, 0, 0, 0},
+	{"YPBPR720P@50", 50, 1280, 720, 74250000, 660, 0, 20, 5, 40,
+	 5, 0, 0, 0},
+	{"YPbPR720P@60", 60, 1280, 720, 74250000, 330, 0, 20, 5, 40,
+	 5, 0, 0, 0},
+};
+
+static struct rk1000_monspecs ypbpr_monspecs;
+
+int rk1000_tv_ypbpr480_init(void)
+{
+	unsigned char tv_encoder_regs[] = {0x00, 0x00, 0x40, 0x08, 0x00,
+					   0x02, 0x17, 0x0A, 0x0A};
+	unsigned char tv_encoder_control_regs[] = {0x00};
+	int i;
+	int ret;
+
+	for (i = 0; i < sizeof(tv_encoder_regs); i++) {
+		ret = rk1000_tv_write_block(i, tv_encoder_regs + i, 1);
+		if (ret < 0) {
+			pr_err("rk1000_tv_write_block err!\n");
+			return ret;
+		}
+	}
+	for (i = 0; i < sizeof(tv_encoder_control_regs); i++) {
+		ret = rk1000_control_write_block(i+3,
+						 tv_encoder_control_regs+i,
+						 1);
+		if (ret < 0) {
+			pr_err("rk1000_control_write_block err!\n");
+			return ret;
+		}
+	}
+	return 0;
+}
+
+int rk1000_tv_ypbpr576_init(void)
+{
+	unsigned char tv_encoder_regs[] = {0x06, 0x00, 0x40, 0x08, 0x00,
+					   0x01, 0x17, 0x0A, 0x0A};
+	unsigned char tv_encoder_control_regs[] = {0x00};
+	int i;
+	int ret;
+
+	for (i = 0; i < sizeof(tv_encoder_regs); i++) {
+		ret = rk1000_tv_write_block(i, tv_encoder_regs+i, 1);
+		if (ret < 0) {
+			pr_err("rk1000_tv_write_block err!\n");
+			return ret;
+		}
+	}
+	for (i = 0; i < sizeof(tv_encoder_control_regs); i++) {
+		ret = rk1000_control_write_block(i + 3,
+						 tv_encoder_control_regs + i,
+						 1);
+		if (ret < 0) {
+			pr_err("rk1000_control_write_block err!\n");
+			return ret;
+		}
+	}
+	return 0;
+}
+
+int rk1000_tv_ypbpr720_50_init(void)
+{
+	unsigned char tv_encoder_regs[] = {0x06, 0x00, 0x40, 0x08,
+					   0x00, 0x13, 0x17, 0x0A, 0x0A};
+	unsigned char tv_encoder_control_regs[] = {0x00};
+	int i;
+	int ret;
+
+	for (i = 0; i < sizeof(tv_encoder_regs); i++) {
+		ret = rk1000_tv_write_block(i, tv_encoder_regs+i, 1);
+		if (ret < 0) {
+			pr_err("rk1000_tv_write_block err!\n");
+			return ret;
+		}
+	}
+
+	for (i = 0; i < sizeof(tv_encoder_control_regs); i++) {
+		ret = rk1000_control_write_block(i+3,
+						 tv_encoder_control_regs+i,
+						 1);
+		if (ret < 0) {
+			pr_err("rk1000_control_write_block err!\n");
+			return ret;
+		}
+	}
+	return 0;
+}
+
+int rk1000_tv_ypbpr720_60_init(void)
+{
+	unsigned char tv_encoder_regs[] = {0x06, 0x00, 0x40, 0x08, 0x00,
+					   0x17, 0x17, 0x0A, 0x0A};
+	unsigned char tv_encoder_control_regs[] = {0x00};
+	int i;
+	int ret;
+
+	for (i = 0; i < sizeof(tv_encoder_regs); i++) {
+		ret = rk1000_tv_write_block(i, tv_encoder_regs + i, 1);
+		if (ret < 0) {
+			pr_err("rk1000_tv_write_block err!\n");
+			return ret;
+		}
+	}
+	for (i = 0; i < sizeof(tv_encoder_control_regs); i++) {
+		ret = rk1000_control_write_block(i + 3,
+						 tv_encoder_control_regs + i,
+						 1);
+		if (ret < 0) {
+			pr_err("rk1000_control_write_block err!\n");
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int rk1000_ypbpr_set_enable(struct rk_display_device *device,
+				   int enable)
+{
+	if (ypbpr_monspecs.suspend)
+		return 0;
+	if (ypbpr_monspecs.enable != enable ||
+	    ypbpr_monspecs.mode_set != rk1000_tve.mode) {
+		if (enable == 0 && ypbpr_monspecs.enable) {
+			ypbpr_monspecs.enable = 0;
+			rk1000_tv_standby(RK1000_TVOUT_YPBPR);
+		} else if (enable == 1) {
+			rk1000_switch_fb(ypbpr_monspecs.mode,
+					 ypbpr_monspecs.mode_set);
+			ypbpr_monspecs.enable = 1;
+		}
+	}
+	return 0;
+}
+
+static int rk1000_ypbpr_get_enable(struct rk_display_device *device)
+{
+	return ypbpr_monspecs.enable;
+}
+
+static int rk1000_ypbpr_get_status(struct rk_display_device *device)
+{
+	if (rk1000_tve.mode > TVOUT_CVBS_PAL)
+		return 1;
+	else
+		return 0;
+}
+
+static int rk1000_ypbpr_get_modelist(struct rk_display_device *device,
+				     struct list_head **modelist)
+{
+	*modelist = &(ypbpr_monspecs.modelist);
+	return 0;
+}
+
+static int rk1000_ypbpr_set_mode(struct rk_display_device *device,
+				 struct fb_videomode *mode)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rk1000_ypbpr_mode); i++) {
+		if (fb_mode_is_equal(&rk1000_ypbpr_mode[i], mode)) {
+			if ((i + 3) != rk1000_tve.mode) {
+				ypbpr_monspecs.mode_set = i + 3;
+				ypbpr_monspecs.mode = (struct fb_videomode *)
+							&rk1000_ypbpr_mode[i];
+			}
+			return 0;
+		}
+	}
+	return -1;
+}
+
+static int rk1000_ypbpr_get_mode(struct rk_display_device *device,
+				 struct fb_videomode *mode)
+{
+	*mode = *(ypbpr_monspecs.mode);
+	return 0;
+}
+
+static struct rk_display_ops rk1000_ypbpr_display_ops = {
+	.setenable = rk1000_ypbpr_set_enable,
+	.getenable = rk1000_ypbpr_get_enable,
+	.getstatus = rk1000_ypbpr_get_status,
+	.getmodelist = rk1000_ypbpr_get_modelist,
+	.setmode = rk1000_ypbpr_set_mode,
+	.getmode = rk1000_ypbpr_get_mode,
+};
+
+static int rk1000_display_ypbpr_probe(struct rk_display_device *device,
+				      void *devdata)
+{
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "YPbPr");
+	device->name = "ypbpr";
+	device->priority = DISPLAY_PRIORITY_YPBPR;
+	device->property = rk1000_tve.property;
+	device->priv_data = devdata;
+	device->ops = &rk1000_ypbpr_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_rk1000_ypbpr = {
+	.probe = rk1000_display_ypbpr_probe,
+};
+
+int rk1000_register_display_ypbpr(struct device *parent)
+{
+	int i;
+
+	memset(&ypbpr_monspecs, 0, sizeof(struct rk1000_monspecs));
+	INIT_LIST_HEAD(&ypbpr_monspecs.modelist);
+	for (i = 0; i < ARRAY_SIZE(rk1000_ypbpr_mode); i++)
+		display_add_videomode(&rk1000_ypbpr_mode[i],
+				      &ypbpr_monspecs.modelist);
+	if (rk1000_tve.mode > TVOUT_CVBS_PAL) {
+		ypbpr_monspecs.mode = (struct fb_videomode *)
+				     &(rk1000_ypbpr_mode[rk1000_tve.mode - 3]);
+		ypbpr_monspecs.mode_set = rk1000_tve.mode;
+	} else {
+		ypbpr_monspecs.mode = (struct fb_videomode *)
+					&(rk1000_ypbpr_mode[3]);
+		ypbpr_monspecs.mode_set = TVOUT_YPBPR_1280X720P_60;
+	}
+	ypbpr_monspecs.ddev = rk_display_device_register(&display_rk1000_ypbpr,
+							 parent, NULL);
+	rk1000_tve.ypbpr = &ypbpr_monspecs;
+	if (rk1000_tve.mode > TVOUT_CVBS_PAL)
+		rk_display_device_enable(ypbpr_monspecs.ddev);
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/tve/rk3036/Kconfig b/drivers/video/rockchip/tve/rk3036/Kconfig
--- a/drivers/video/rockchip/tve/rk3036/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk3036/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+config RK3036_TV_ENCODER
+	bool "rk3036/3128 tv encoder support"
+	depends on (LCDC_RK3036 || LCDC_RK312X) && RK_TVENCODER
+	default n
+	help
+		Support RK3036 output CVBS.
+
diff -Nupr a/drivers/video/rockchip/tve/rk3036/Makefile b/drivers/video/rockchip/tve/rk3036/Makefile
--- a/drivers/video/rockchip/tve/rk3036/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk3036/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the rk3036 tv encoder control.
+#
+obj-$(CONFIG_RK3036_TV_ENCODER)	+= rk3036_tve.o
diff -Nupr a/drivers/video/rockchip/tve/rk3036/rk3036_tve.c b/drivers/video/rockchip/tve/rk3036/rk3036_tve.c
--- a/drivers/video/rockchip/tve/rk3036/rk3036_tve.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk3036/rk3036_tve.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,573 @@
+/*
+ * rk3036_tve.c
+ *
+ * Driver for rockchip rk3036 tv encoder control
+ * Copyright (C) 2014
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *
+ */
+#include <linux/clk.h>
+#include <linux/display-sys.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/rk_fb.h>
+#include <linux/rockchip/grf.h>
+#include <linux/rockchip/iomap.h>
+#include "../../hdmi/rockchip-hdmiv2/rockchip_hdmiv2.h"
+#include "rk3036_tve.h"
+
+static const struct fb_videomode rk3036_cvbs_mode[] = {
+	/*name		refresh	xres	yres	pixclock	h_bp	h_fp	v_bp	v_fp	h_pw	v_pw			polariry				PorI		flag*/
+/*	{"NTSC",        60,     720,    480,    27000000,       57,     19,     19,     0,      62,     3,      FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,   FB_VMODE_INTERLACED,    0},
+	{"PAL",         50,     720,    576,    27000000,       69,     12,     19,     2,      63,     3,      FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,   FB_VMODE_INTERLACED,    0},
+*/	{"NTSC",	60,	720,	480,	27000000,	43,	33,	19,	0,	62,	3,	FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,	FB_VMODE_INTERLACED,	0},
+	{"PAL",		50,	720,	576,	27000000,	48,	33,	19,	2,	63,	3,	FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,	FB_VMODE_INTERLACED,	0},
+};
+
+static struct rk3036_tve *rk3036_tve;
+
+static int cvbsformat = -1;
+
+#define tve_writel(offset, v)	writel_relaxed(v, rk3036_tve->regbase + offset)
+#define tve_readl(offset)	readl_relaxed(rk3036_tve->regbase + offset)
+
+#define tve_dac_writel(offset, v)   writel_relaxed(v, rk3036_tve->vdacbase + offset)
+#define tve_dac_readl(offset)	readl_relaxed(rk3036_tve->vdacbase + offset)
+
+#ifdef DEBUG
+#define TVEDBG(format, ...) \
+		dev_info(rk3036_tve->dev,\
+		 "RK3036 TVE: " format "\n", ## __VA_ARGS__)
+#else
+#define TVEDBG(format, ...)
+#endif
+
+static void dac_enable(bool enable)
+{
+	u32 mask, val;
+	u32 grfreg = 0;
+
+	TVEDBG("%s enable %d\n", __func__, enable);
+
+	if (enable) {
+		mask = m_VBG_EN | m_DAC_EN | m_DAC_GAIN;
+		if (rk3036_tve->soctype == SOC_RK312X) {
+			val = m_VBG_EN | m_DAC_EN |
+			      v_DAC_GAIN(rk3036_tve->daclevel);
+			grfreg = RK312X_GRF_TVE_CON;
+		} else if (rk3036_tve->soctype == SOC_RK3036) {
+			val = m_VBG_EN | m_DAC_EN |
+			      v_DAC_GAIN(rk3036_tve->daclevel);
+			grfreg = RK3036_GRF_SOC_CON3;
+		} else if (rk3036_tve->soctype == SOC_RK322X) {
+			val = 0x70;
+		}
+	} else {
+		mask = m_VBG_EN | m_DAC_EN;
+		val = 0;
+		if (rk3036_tve->soctype == SOC_RK312X)
+			grfreg = RK312X_GRF_TVE_CON;
+		else if (rk3036_tve->soctype == SOC_RK3036)
+			grfreg = RK3036_GRF_SOC_CON3;
+		else if (rk3036_tve->soctype == SOC_RK322X)
+			val = v_CUR_REG(0x7) | m_DR_PWR_DOWN | m_BG_PWR_DOWN;
+	}
+	if (grfreg)
+		grf_writel(grfreg, (mask << 16) | val);
+	else if (rk3036_tve->vdacbase)
+		tve_dac_writel(VDAC_VDAC1, val);
+}
+
+static void rk322x_dac_init(void)
+{
+	/*tve_dac_writel(VDAC_VDAC0, 0x0);*/
+	tve_dac_writel(VDAC_VDAC1, v_CUR_REG(0x7) |
+				   m_DR_PWR_DOWN | m_BG_PWR_DOWN);
+	tve_dac_writel(VDAC_VDAC2, v_CUR_CTR(rk3036_tve->daclevel));
+	tve_dac_writel(VDAC_VDAC3, v_CAB_EN(0));
+}
+
+static void tve_set_mode(int mode)
+{
+	TVEDBG("%s mode %d\n", __func__, mode);
+	if (cvbsformat >= 0)
+		return;
+	if (rk3036_tve->soctype != SOC_RK322X) {
+		tve_writel(TV_RESET, v_RESET(1));
+		usleep_range(100, 110);
+		tve_writel(TV_RESET, v_RESET(0));
+	}
+	if (rk3036_tve->inputformat == INPUT_FORMAT_RGB)
+		tve_writel(TV_CTRL, v_CVBS_MODE(mode) | v_CLK_UPSTREAM_EN(2) |
+			   v_TIMING_EN(2) | v_LUMA_FILTER_GAIN(0) |
+			   v_LUMA_FILTER_UPSAMPLE(1) | v_CSC_PATH(0));
+	else
+		tve_writel(TV_CTRL, v_CVBS_MODE(mode) | v_CLK_UPSTREAM_EN(2) |
+			   v_TIMING_EN(2) | v_LUMA_FILTER_GAIN(0) |
+			   v_LUMA_FILTER_UPSAMPLE(1) | v_CSC_PATH(3));
+
+	tve_writel(TV_LUMA_FILTER0, rk3036_tve->lumafilter0);
+	tve_writel(TV_LUMA_FILTER1, rk3036_tve->lumafilter1);
+	tve_writel(TV_LUMA_FILTER2, rk3036_tve->lumafilter2);
+
+	if (mode == TVOUT_CVBS_NTSC) {
+		tve_writel(TV_ROUTING, v_DAC_SENSE_EN(0) | v_Y_IRE_7_5(1) |
+			v_Y_AGC_PULSE_ON(0) | v_Y_VIDEO_ON(1) |
+			v_YPP_MODE(1) | v_Y_SYNC_ON(1) | v_PIC_MODE(mode));
+		tve_writel(TV_BW_CTRL, v_CHROMA_BW(BP_FILTER_NTSC) |
+			v_COLOR_DIFF_BW(COLOR_DIFF_FILTER_BW_1_3));
+		tve_writel(TV_SATURATION, 0x0042543C);
+		if (rk3036_tve->test_mode)
+			tve_writel(TV_BRIGHTNESS_CONTRAST, 0x00008300);
+		else
+			tve_writel(TV_BRIGHTNESS_CONTRAST, 0x00007900);
+
+		tve_writel(TV_FREQ_SC,	0x21F07BD7);
+		tve_writel(TV_SYNC_TIMING, 0x00C07a81);
+		tve_writel(TV_ADJ_TIMING, 0x96B40000 | 0x70);
+		tve_writel(TV_ACT_ST,	0x001500D6);
+		tve_writel(TV_ACT_TIMING, 0x069800FC | (1 << 12) | (1 << 28));
+
+	} else if (mode == TVOUT_CVBS_PAL) {
+		tve_writel(TV_ROUTING, v_DAC_SENSE_EN(0) | v_Y_IRE_7_5(0) |
+			v_Y_AGC_PULSE_ON(0) | v_Y_VIDEO_ON(1) |
+			v_YPP_MODE(1) | v_Y_SYNC_ON(1) | v_PIC_MODE(mode));
+		tve_writel(TV_BW_CTRL, v_CHROMA_BW(BP_FILTER_PAL) |
+			v_COLOR_DIFF_BW(COLOR_DIFF_FILTER_BW_1_3));
+
+		tve_writel(TV_SATURATION, rk3036_tve->saturation);
+		tve_writel(TV_BRIGHTNESS_CONTRAST, rk3036_tve->brightcontrast);
+
+		tve_writel(TV_FREQ_SC,	0x2A098ACB);
+		tve_writel(TV_SYNC_TIMING, 0x00C28381);
+		tve_writel(TV_ADJ_TIMING, (0xc << 28) | 0x06c00800 | 0x80);
+		tve_writel(TV_ACT_ST,	0x001500F6);
+		tve_writel(TV_ACT_TIMING, 0x0694011D | (1 << 12) | (2 << 28));
+
+		tve_writel(TV_ADJ_TIMING, rk3036_tve->adjtiming);
+		tve_writel(TV_ACT_TIMING, 0x0694011D |
+				(1 << 12) | (2 << 28));
+	}
+}
+
+static int tve_switch_fb(const struct fb_videomode *modedb, int enable)
+{
+	struct rk_screen *screen = &rk3036_tve->screen;
+
+	if (!modedb)
+		return -1;
+
+	memset(screen, 0, sizeof(struct rk_screen));
+	/* screen type & face */
+	if (rk3036_tve->test_mode)
+		screen->type = SCREEN_TVOUT_TEST;
+	else
+		screen->type = SCREEN_TVOUT;
+	screen->face = OUT_P888;
+	screen->color_mode = COLOR_YCBCR;
+	screen->mode = *modedb;
+
+	/* Pin polarity */
+	if (FB_SYNC_HOR_HIGH_ACT & modedb->sync)
+		screen->pin_hsync = 1;
+	else
+		screen->pin_hsync = 0;
+	if (FB_SYNC_VERT_HIGH_ACT & modedb->sync)
+		screen->pin_vsync = 1;
+	else
+		screen->pin_vsync = 0;
+
+	screen->pin_den = 0;
+	screen->pin_dclk = 0;
+	screen->pixelrepeat = 1;
+
+	/* Swap rule */
+	screen->swap_rb = 0;
+	screen->swap_rg = 0;
+	screen->swap_gb = 0;
+	screen->swap_delta = 0;
+	screen->swap_dumy = 0;
+
+	/* Operation function*/
+	screen->init = NULL;
+	screen->standby = NULL;
+	rk_fb_switch_screen(screen, enable, 0);
+
+	if (enable) {
+		if (rk3036_tve->soctype == SOC_RK322X)
+			ext_pll_set_27m_out();
+		if (screen->mode.yres == 480)
+			tve_set_mode(TVOUT_CVBS_NTSC);
+		else
+			tve_set_mode(TVOUT_CVBS_PAL);
+	}
+	return 0;
+}
+
+static int cvbs_set_enable(struct rk_display_device *device, int enable)
+{
+	TVEDBG("%s enable %d\n", __func__, enable);
+	mutex_lock(&rk3036_tve->tve_lock);
+	if (rk3036_tve->enable != enable) {
+		rk3036_tve->enable = enable;
+		if (rk3036_tve->suspend) {
+			mutex_unlock(&rk3036_tve->tve_lock);
+			return 0;
+		}
+
+		if (enable == 0) {
+			dac_enable(false);
+			cvbsformat = -1;
+			tve_switch_fb(rk3036_tve->mode, 0);
+		} else if (enable == 1) {
+			tve_switch_fb(rk3036_tve->mode, 1);
+			dac_enable(true);
+		}
+	}
+	mutex_unlock(&rk3036_tve->tve_lock);
+	return 0;
+}
+
+static int cvbs_get_enable(struct rk_display_device *device)
+{
+	TVEDBG("%s enable %d\n", __func__, rk3036_tve->enable);
+	return rk3036_tve->enable;
+}
+
+static int cvbs_get_status(struct rk_display_device *device)
+{
+	return 1;
+}
+
+static int
+cvbs_get_modelist(struct rk_display_device *device, struct list_head **modelist)
+{
+	*modelist = &rk3036_tve->modelist;
+	return 0;
+}
+
+static int
+cvbs_set_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rk3036_cvbs_mode); i++) {
+		if (fb_mode_is_equal(&rk3036_cvbs_mode[i], mode)) {
+			if (rk3036_tve->mode != &rk3036_cvbs_mode[i]) {
+				rk3036_tve->mode =
+				(struct fb_videomode *)&rk3036_cvbs_mode[i];
+				if (rk3036_tve->enable && !rk3036_tve->suspend) {
+					dac_enable(false);
+					msleep(200);
+					tve_switch_fb(rk3036_tve->mode, 1);
+					dac_enable(true);
+				}
+			}
+			return 0;
+		}
+	}
+	TVEDBG("%s\n", __func__);
+	return -1;
+}
+
+static int
+cvbs_get_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	*mode = *rk3036_tve->mode;
+	return 0;
+}
+
+static int
+tve_fb_event_notify(struct notifier_block *self,
+		    unsigned long action, void *data)
+{
+	struct fb_event *event = data;
+
+	if (action == FB_EARLY_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			break;
+		default:
+			TVEDBG("suspend tve\n");
+			if (!rk3036_tve->suspend) {
+				rk3036_tve->suspend = 1;
+				if (rk3036_tve->enable) {
+					tve_switch_fb(rk3036_tve->mode, 0);
+					dac_enable(false);
+					if (rk3036_tve->soctype == SOC_RK322X)
+						clk_disable_unprepare(rk3036_tve->dac_clk);
+				}
+			}
+			break;
+		}
+	} else if (action == FB_EVENT_BLANK) {
+		switch (*((int *)event->data)) {
+		case FB_BLANK_UNBLANK:
+			TVEDBG("resume tve\n");
+			mutex_lock(&rk3036_tve->tve_lock);
+			if (rk3036_tve->suspend) {
+				if (rk3036_tve->soctype == SOC_RK322X) {
+					clk_prepare_enable(rk3036_tve->dac_clk);
+					rk322x_dac_init();
+				}
+				rk3036_tve->suspend = 0;
+				if (rk3036_tve->enable) {
+					tve_switch_fb(rk3036_tve->mode, 1);
+					dac_enable(true);
+				}
+			}
+			mutex_unlock(&rk3036_tve->tve_lock);
+			break;
+		default:
+			break;
+		}
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block tve_fb_notifier = {
+	.notifier_call = tve_fb_event_notify,
+};
+
+static struct rk_display_ops cvbs_display_ops = {
+	.setenable = cvbs_set_enable,
+	.getenable = cvbs_get_enable,
+	.getstatus = cvbs_get_status,
+	.getmodelist = cvbs_get_modelist,
+	.setmode = cvbs_set_mode,
+	.getmode = cvbs_get_mode,
+};
+
+static int
+display_cvbs_probe(struct rk_display_device *device, void *devdata)
+{
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "TV");
+	device->name = "cvbs";
+	device->priority = DISPLAY_PRIORITY_TV;
+	device->priv_data = devdata;
+	device->ops = &cvbs_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_cvbs = {
+	.probe = display_cvbs_probe,
+};
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk3036_tve_dt_ids[] = {
+	{.compatible = "rockchip,rk3036-tve",},
+	{.compatible = "rockchip,rk312x-tve",},
+	{.compatible = "rockchip,rk322x-tve",},
+	{}
+};
+#endif
+
+static int __init bootloader_tve_setup(char *str)
+{
+	static int ret;
+
+	if (str) {
+		pr_info("cvbs init tve.format is %s\n", str);
+		ret = sscanf(str, "%d", &cvbsformat);
+	}
+
+	return 0;
+}
+
+early_param("tve.format", bootloader_tve_setup);
+
+static int rk3036_tve_parse_dt(struct device_node *np,
+			       struct rk3036_tve *rk3036_tve)
+{
+	int ret;
+	u32 val;
+
+	if (rk3036_tve->soctype == SOC_RK312X) {
+		ret = of_property_read_u32(np, "test_mode", &val);
+		if (ret < 0)
+			goto errer;
+		else
+			rk3036_tve->test_mode = val;
+	}
+
+	ret = of_property_read_u32(np, "saturation", &val);
+	if ((val == 0) || (ret < 0))
+		goto errer;
+	else
+		rk3036_tve->saturation = val;
+
+	ret = of_property_read_u32(np, "brightcontrast", &val);
+	if ((val == 0) || (ret < 0))
+		goto errer;
+	else
+		rk3036_tve->brightcontrast = val;
+
+	ret = of_property_read_u32(np, "adjtiming", &val);
+	if ((val == 0) || (ret < 0))
+		goto errer;
+	else
+		rk3036_tve->adjtiming = val;
+
+	ret = of_property_read_u32(np, "lumafilter0", &val);
+	if ((val == 0) || (ret < 0))
+		goto errer;
+	else
+		rk3036_tve->lumafilter0 = val;
+
+	ret = of_property_read_u32(np, "lumafilter1", &val);
+	if ((val == 0) || (ret < 0))
+		goto errer;
+	else
+		rk3036_tve->lumafilter1 = val;
+
+	ret = of_property_read_u32(np, "lumafilter2", &val);
+	if ((val == 0) || (ret < 0))
+		goto errer;
+	else
+		rk3036_tve->lumafilter2 = val;
+
+	ret = of_property_read_u32(np, "daclevel", &val);
+	if ((val == 0) || (ret < 0))
+		goto errer;
+	else
+		rk3036_tve->daclevel = val;
+
+	return 0;
+errer:
+	return -1;
+}
+
+static int rk3036_tve_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *res;
+	const struct of_device_id *match;
+	int i;
+	int ret;
+
+	match = of_match_node(rk3036_tve_dt_ids, np);
+	if (!match)
+		return PTR_ERR(match);
+
+	rk3036_tve = devm_kzalloc(&pdev->dev,
+				  sizeof(struct rk3036_tve), GFP_KERNEL);
+	if (!rk3036_tve) {
+		dev_err(&pdev->dev, "rk3036 tv encoder device kmalloc fail!");
+		return -ENOMEM;
+	}
+
+	if (!strcmp(match->compatible, "rockchip,rk3036-tve")) {
+		rk3036_tve->soctype = SOC_RK3036;
+		rk3036_tve->inputformat = INPUT_FORMAT_RGB;
+	} else if (!strcmp(match->compatible, "rockchip,rk312x-tve")) {
+		rk3036_tve->soctype = SOC_RK312X;
+		rk3036_tve->inputformat = INPUT_FORMAT_YUV;
+	} else if (!strcmp(match->compatible, "rockchip,rk322x-tve")) {
+		rk3036_tve->soctype = SOC_RK322X;
+		rk3036_tve->inputformat = INPUT_FORMAT_YUV;
+	} else {
+		dev_err(&pdev->dev, "It is not a valid tv encoder!");
+		return -ENOMEM;
+	}
+
+	ret = rk3036_tve_parse_dt(np, rk3036_tve);
+	if (ret) {
+		dev_err(&pdev->dev, "TVE parse dts error!");
+		return -EINVAL;
+	}
+
+	platform_set_drvdata(pdev, rk3036_tve);
+	rk3036_tve->dev = &pdev->dev;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	rk3036_tve->reg_phy_base = res->start;
+	rk3036_tve->len = resource_size(res);
+	rk3036_tve->regbase = ioremap(res->start, rk3036_tve->len);
+	if (IS_ERR(rk3036_tve->regbase)) {
+		dev_err(&pdev->dev,
+			"rk3036 tv encoder device map registers failed!");
+		return PTR_ERR(rk3036_tve->regbase);
+	}
+	if (rk3036_tve->soctype == SOC_RK322X) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		rk3036_tve->len = resource_size(res);
+		rk3036_tve->vdacbase = devm_ioremap(rk3036_tve->dev,
+						    res->start,
+						    rk3036_tve->len);
+		if (IS_ERR(rk3036_tve->vdacbase)) {
+			dev_err(&pdev->dev,
+				"rk3036 tv encoder device dac map registers failed!");
+			return PTR_ERR(rk3036_tve->vdacbase);
+		}
+		rk3036_tve->dac_clk =
+				devm_clk_get(rk3036_tve->dev, "pclk_vdac");
+		if (IS_ERR(rk3036_tve->dac_clk)) {
+			dev_err(&pdev->dev,
+				"Unable to get vdac_clk\n");
+			return PTR_ERR(rk3036_tve->dac_clk);
+		}
+		clk_prepare_enable(rk3036_tve->dac_clk);
+		if (cvbsformat < 0)
+			rk322x_dac_init();
+	}
+	mutex_init(&rk3036_tve->tve_lock);
+	INIT_LIST_HEAD(&rk3036_tve->modelist);
+	for (i = 0; i < ARRAY_SIZE(rk3036_cvbs_mode); i++)
+		fb_add_videomode(&rk3036_cvbs_mode[i], &rk3036_tve->modelist);
+	 if (cvbsformat >= 0) {
+		rk3036_tve->mode =
+			(struct fb_videomode *)&rk3036_cvbs_mode[cvbsformat];
+		rk3036_tve->enable = 1;
+		tve_switch_fb(rk3036_tve->mode, 1);
+	} else {
+		rk3036_tve->mode = (struct fb_videomode *)&rk3036_cvbs_mode[1];
+	}
+	rk3036_tve->ddev =
+		rk_display_device_register(&display_cvbs, &pdev->dev, NULL);
+	rk_display_device_enable(rk3036_tve->ddev);
+
+	fb_register_client(&tve_fb_notifier);
+	cvbsformat = -1;
+	dev_info(&pdev->dev, "%s tv encoder probe ok\n", match->compatible);
+	return 0;
+}
+
+static void rk3036_tve_shutdown(struct platform_device *pdev)
+{
+}
+
+static struct platform_driver rk3036_tve_driver = {
+	.probe = rk3036_tve_probe,
+	.remove = NULL,
+	.driver = {
+		.name = "rk3036-tve",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(rk3036_tve_dt_ids),
+	},
+	.shutdown = rk3036_tve_shutdown,
+};
+
+static int __init rk3036_tve_init(void)
+{
+	return platform_driver_register(&rk3036_tve_driver);
+}
+
+static void __exit rk3036_tve_exit(void)
+{
+	platform_driver_unregister(&rk3036_tve_driver);
+}
+
+module_init(rk3036_tve_init);
+module_exit(rk3036_tve_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ROCKCHIP RK3036 TV Encoder ");
+MODULE_LICENSE("GPL");
diff -Nupr a/drivers/video/rockchip/tve/rk3036/rk3036_tve.h b/drivers/video/rockchip/tve/rk3036/rk3036_tve.h
--- a/drivers/video/rockchip/tve/rk3036/rk3036_tve.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk3036/rk3036_tve.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,159 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __RK3036_TVE_H__
+#define __RK3036_TVE_H__
+
+#define TV_CTRL			(0x00)
+	#define m_CVBS_MODE			(1 << 24)
+	#define m_CLK_UPSTREAM_EN		(3 << 18)
+	#define m_TIMING_EN			(3 << 16)
+	#define m_LUMA_FILTER_GAIN		(3 << 9)
+	#define m_LUMA_FILTER_BW		(1 << 8)
+	#define m_CSC_PATH			(3 << 1)
+
+	#define v_CVBS_MODE(x)			((x & 1) << 24)
+	#define v_CLK_UPSTREAM_EN(x)		((x & 3) << 18)
+	#define v_TIMING_EN(x)			((x & 3) << 16)
+	#define v_LUMA_FILTER_GAIN(x)		((x & 3) << 9)
+	#define v_LUMA_FILTER_UPSAMPLE(x)	((x & 1) << 8)
+	#define v_CSC_PATH(x)			((x & 3) << 1)
+
+#define TV_SYNC_TIMING		(0x04)
+#define TV_ACT_TIMING		(0x08)
+#define TV_ADJ_TIMING		(0x0c)
+#define TV_FREQ_SC		(0x10)
+#define TV_LUMA_FILTER0		(0x14)
+#define TV_LUMA_FILTER1		(0x18)
+#define TV_LUMA_FILTER2		(0x1C)
+#define TV_ACT_ST		(0x34)
+#define TV_ROUTING		(0x38)
+	#define m_DAC_SENSE_EN		(1 << 27)
+	#define m_Y_IRE_7_5		(1 << 19)
+	#define m_Y_AGC_PULSE_ON	(1 << 15)
+	#define m_Y_VIDEO_ON		(1 << 11)
+	#define m_Y_SYNC_ON		(1 << 7)
+	#define m_YPP_MODE		(1 << 3)
+	#define m_MONO_EN		(1 << 2)
+	#define m_PIC_MODE		(1 << 1)
+
+	#define v_DAC_SENSE_EN(x)	((x & 1) << 27)
+	#define v_Y_IRE_7_5(x)		((x & 1) << 19)
+	#define v_Y_AGC_PULSE_ON(x)	((x & 1) << 15)
+	#define v_Y_VIDEO_ON(x)		((x & 1) << 11)
+	#define v_Y_SYNC_ON(x)		((x & 1) << 7)
+	#define v_YPP_MODE(x)		((x & 1) << 3)
+	#define v_MONO_EN(x)		((x & 1) << 2)
+	#define v_PIC_MODE(x)		((x & 1) << 1)
+
+#define TV_SYNC_ADJUST		(0x50)
+#define TV_STATUS		(0x54)
+#define TV_RESET		(0x68)
+	#define m_RESET			(1 << 1)
+	#define v_RESET(x)		((x & 1) << 1)
+#define TV_SATURATION		(0x78)
+#define TV_BW_CTRL		(0x8C)
+	#define m_CHROMA_BW	(3 << 4)
+	#define m_COLOR_DIFF_BW	(0xf)
+
+	enum {
+		BP_FILTER_PASS = 0,
+		BP_FILTER_NTSC,
+		BP_FILTER_PAL,
+	};
+	enum {
+		COLOR_DIFF_FILTER_OFF = 0,
+		COLOR_DIFF_FILTER_BW_0_6,
+		COLOR_DIFF_FILTER_BW_1_3,
+		COLOR_DIFF_FILTER_BW_2_0
+	};
+
+	#define v_CHROMA_BW(x)		((3 & x) << 4)
+	#define v_COLOR_DIFF_BW(x)	(0xF & x)
+
+#define TV_BRIGHTNESS_CONTRAST	(0x90)
+
+#define m_EXTREF_EN		(1 << 0)
+#define m_VBG_EN		(1 << 1)
+#define m_DAC_EN		(1 << 2)
+#define m_SENSE_EN		(1 << 3)
+#define m_BIAS_EN		(7 << 4)
+#define m_DAC_GAIN		(0x3f << 7)
+#define v_DAC_GAIN(x)		((x & 0x3f) << 7)
+
+#define VDAC_VDAC0             (0x00)
+       #define m_RST_ANA               (1 << 7)
+       #define m_RST_DIG               (1 << 6)
+
+       #define v_RST_ANA(x)            ((x & 1) << 7)
+       #define v_RST_DIG(x)            ((x & 1) << 6)
+#define VDAC_VDAC1             (0x280)
+       #define m_CUR_REG               (0xf << 4)
+       #define m_DR_PWR_DOWN           (1 << 1)
+       #define m_BG_PWR_DOWN           (1 << 0)
+
+       #define v_CUR_REG(x)            ((x & 0xf) << 4)
+       #define v_DR_PWR_DOWN(x)        ((x & 1) << 1)
+       #define v_BG_PWR_DOWN(x)        ((x & 1) << 0)
+#define VDAC_VDAC2             (0x284)
+       #define m_CUR_CTR               (0X3f)
+
+       #define v_CUR_CTR(x)            ((x & 0X3f))
+#define VDAC_VDAC3             (0x288)
+       #define m_CAB_EN                (1 << 5)
+       #define m_CAB_REF               (1 << 4)
+       #define m_CAB_FLAG              (1 << 0)
+
+       #define v_CAB_EN(x)             ((x & 1) << 5)
+       #define v_CAB_REF(x)            ((x & 1) << 4)
+       #define v_CAB_FLAG(x)           ((x & 1) << 0)
+
+enum {
+	TVOUT_CVBS_NTSC = 0,
+	TVOUT_CVBS_PAL,
+};
+
+enum {
+	INPUT_FORMAT_RGB = 0,
+	INPUT_FORMAT_YUV
+};
+
+enum {
+	SOC_RK3036 = 0,
+	SOC_RK312X,
+	SOC_RK322X
+};
+
+#define TVOUT_DEAULT TVOUT_CVBS_PAL
+
+#define grf_writel(offset, v)	do { \
+	writel_relaxed(v, RK_GRF_VIRT + offset); \
+	dsb(sy); \
+	} while (0)
+
+struct rk3036_tve {
+	struct device			*dev;
+	void __iomem			*regbase;
+	void __iomem			*vdacbase;
+	struct clk			*dac_clk;
+	u32				reg_phy_base;
+	u32				len;
+	int				soctype;
+	int				inputformat;
+	struct rk_display_device	*ddev;
+	unsigned int			enable;
+	unsigned int			suspend;
+	struct fb_videomode		*mode;
+	struct list_head		modelist;
+	struct rk_screen		screen;
+	u32 test_mode;
+	u32 saturation;
+	u32 brightcontrast;
+	u32 adjtiming;
+	u32 lumafilter0;
+	u32 lumafilter1;
+	u32 lumafilter2;
+	u32 daclevel;
+	struct mutex tve_lock;	/* mutex for tve resume operation*/
+};
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/tve/rk610/Kconfig b/drivers/video/rockchip/tve/rk610/Kconfig
--- a/drivers/video/rockchip/tve/rk610/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk610/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0
+config RK610_TVOUT
+	bool "RK610(Jetta) tvout support"
+	depends on MFD_RK610
+	default n
+	help
+		Support Jetta(RK610) to output YPbPr and CVBS.
+		
+config RK610_TVOUT_YPbPr
+	bool "support YPbPr output"
+	depends on RK610_TVOUT
+
+config RK610_TVOUT_CVBS
+	bool "support CVBS output"
+	depends on RK610_TVOUT
diff -Nupr a/drivers/video/rockchip/tve/rk610/Makefile b/drivers/video/rockchip/tve/rk610/Makefile
--- a/drivers/video/rockchip/tve/rk610/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk610/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the jetta tv control.
+#
+obj-$(CONFIG_RK610_TVOUT)			+= rk610_tv.o
+obj-$(CONFIG_RK610_TVOUT_YPbPr)		+= rk610_tv_ypbpr.o
+obj-$(CONFIG_RK610_TVOUT_CVBS)		+= rk610_tv_cvbs.o
\ No newline at end of file
diff -Nupr a/drivers/video/rockchip/tve/rk610/rk610_tv.c b/drivers/video/rockchip/tve/rk610/rk610_tv.c
--- a/drivers/video/rockchip/tve/rk610/rk610_tv.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk610/rk610_tv.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,246 @@
+/*
+ * rk610_tv.c 
+ *
+ * Driver for rockchip rk610 tv control
+ *  Copyright (C) 2009 
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *
+ */
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <asm/uaccess.h>
+#include "rk610_tv.h"
+#include "../../rk29_fb.h"
+
+#define DRV_NAME "rk610_tvout"
+#define RK610_I2C_RATE     100*1000
+
+volatile int rk610_tv_output_status = RK610_TVOUT_DEAULT;
+static struct i2c_client *rk610_tv_i2c_client = NULL;
+
+int rk610_tv_wirte_reg(u8 reg, u8 data)
+{
+    int ret;
+	if(rk610_tv_i2c_client == NULL)
+		return -1;
+    ret = i2c_master_reg8_send(rk610_tv_i2c_client, reg, &data, 1, RK610_I2C_RATE);
+	if (ret > 0)
+		ret = 0;
+	return ret;
+}
+
+int rk610_switch_fb(const struct fb_videomode *modedb, int tv_mode)
+{	
+	struct rk_screen *screen;
+	
+	if(modedb == NULL)
+		return -1;
+	screen =  kzalloc(sizeof(struct rk_screen), GFP_KERNEL);
+	if(screen == NULL)
+		return -1;
+	
+	memset(screen, 0, sizeof(struct rk_screen));	
+	/* screen type & face */
+    screen->type = SCREEN_HDMI;
+	screen->mode = modedb->vmode;
+	screen->face = modedb->flag;
+	/* Screen size */
+	screen->x_res = modedb->xres;
+    screen->y_res = modedb->yres;
+
+    /* Timing */
+    screen->pixclock = modedb->pixclock;
+
+	screen->lcdc_aclk = 500000000;
+	screen->left_margin = modedb->left_margin;
+	screen->right_margin = modedb->right_margin;
+	screen->hsync_len = modedb->hsync_len;
+	screen->upper_margin = modedb->upper_margin;
+	screen->lower_margin = modedb->lower_margin;
+	screen->vsync_len = modedb->vsync_len;
+
+	/* Pin polarity */
+	if(FB_SYNC_HOR_HIGH_ACT & modedb->sync)
+		screen->pin_hsync = 1;
+	else
+		screen->pin_hsync = 0;
+	if(FB_SYNC_VERT_HIGH_ACT & modedb->sync)
+		screen->pin_vsync = 1;
+	else
+		screen->pin_vsync = 0;	
+	screen->pin_den = 0;
+	screen->pin_dclk = 0;
+
+	/* Swap rule */
+    screen->swap_rb = 0;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = NULL;
+    screen->standby = NULL;	
+    
+    switch(tv_mode)
+   	{
+#ifdef CONFIG_RK610_TVOUT_CVBS
+   		case TVOUT_CVBS_NTSC:
+		case TVOUT_CVBS_PAL:
+            screen->init = rk610_tv_cvbs_init;;
+		break;
+#endif
+
+#ifdef CONFIG_RK610_TVOUT_YPbPr
+		case TVOUT_YPbPr_720x480p_60:
+		case TVOUT_YPbPr_720x576p_50:
+		case TVOUT_YPbPr_1280x720p_50:
+		case TVOUT_YPbPr_1280x720p_60:
+		//case TVOUT_YPbPr_1920x1080i_50:
+		case TVOUT_YPbPr_1920x1080i_60:
+		case TVOUT_YPbPr_1920x1080p_50:
+		case TVOUT_YPbPr_1920x1080p_60:
+			screen->init = rk610_tv_ypbpr_init;
+			break;
+#endif
+		default:{
+			kfree(screen);
+			return -1;
+   		}
+   		break;
+   	}
+   	rk610_tv_output_status = tv_mode;
+   	FB_Switch_Screen(screen, 1);
+   	kfree(screen);
+	return 0;
+}
+
+int rk610_tv_standby(int type)
+{
+	int ret;
+
+	switch(type)
+	{
+		#ifdef CONFIG_RK610_TVOUT_CVBS
+		case RK610_TVOUT_CVBS:
+			if(rk610_cvbs_monspecs.enable == 0)
+				return 0;
+			#ifdef CONFIG_RK610_TVOUT_YPbPr
+			if(rk610_ypbpr_monspecs.enable == 1)
+				return 0;
+			#endif
+			break;
+		#endif
+		#ifdef CONFIG_RK610_TVOUT_YPbPr
+		case RK610_TVOUT_YPBPR:
+			if(rk610_ypbpr_monspecs.enable == 0)
+				return 0;
+			#ifdef CONFIG_RK610_TVOUT_CVBS
+			if(rk610_cvbs_monspecs.enable == 1)
+				return 0;
+			#endif
+			break;
+		#endif
+		default:
+			break;
+	}
+
+	ret = rk610_tv_wirte_reg(TVE_POWERCR, 0);
+	if(ret < 0){
+		printk("[%s] rk610_tv_wirte_reg err!\n", __FUNCTION__);
+		return ret;
+	}
+	
+	ret = rk610_control_send_byte(RK610_CONTROL_REG_TVE_CON, 0);
+	if(ret < 0){
+		printk("[%s] rk610_control_send_byte err!\n", __FUNCTION__);
+		return ret;
+	}
+	return 0;
+}
+
+static int rk610_tv_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{
+	int rc = 0;
+	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		rc = -ENODEV;
+		goto failout;
+	}
+	rk610_tv_i2c_client = client;
+
+#ifdef CONFIG_RK610_TVOUT_YPbPr
+	rk610_register_display_ypbpr(&client->dev);
+	if(rk610_tv_output_status > TVOUT_CVBS_PAL)
+		rk_display_device_enable(rk610_ypbpr_monspecs.ddev);
+#endif
+
+#ifdef CONFIG_RK610_TVOUT_CVBS
+	rk610_register_display_cvbs(&client->dev);
+	if(rk610_tv_output_status < TVOUT_YPbPr_720x480p_60)
+		rk_display_device_enable(rk610_cvbs_monspecs.ddev);
+#endif
+	
+    printk(KERN_INFO "rk610_tv ver 1.0 probe ok\n");
+    return 0;
+failout:
+	kfree(client);
+	return rc;
+}
+
+static int rk610_tv_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+
+static const struct i2c_device_id rk610_tv_id[] = {
+	{ DRV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, rk610_tv_id);
+
+static struct i2c_driver rk610_tv_driver = {
+	.driver 	= {
+		.name	= DRV_NAME,
+	},
+	.id_table = rk610_tv_id,
+	.probe = rk610_tv_probe,
+	.remove = rk610_tv_remove,
+};
+
+static int __init rk610_tv_init(void)
+{
+	int ret = 0;
+	ret = i2c_add_driver(&rk610_tv_driver);
+	if(ret < 0){
+		printk("i2c_add_driver err, ret = %d\n", ret);
+	}
+	return ret;
+}
+
+static void __exit rk610_tv_exit(void)
+{
+    i2c_del_driver(&rk610_tv_driver);
+}
+
+module_init(rk610_tv_init);
+//late_initcall(rk610_tv_init);
+module_exit(rk610_tv_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ROCKCHIP RK610 TV Output");
+MODULE_LICENSE("GPL");
+
+
diff -Nupr a/drivers/video/rockchip/tve/rk610/rk610_tv_cvbs.c b/drivers/video/rockchip/tve/rk610/rk610_tv_cvbs.c
--- a/drivers/video/rockchip/tve/rk610/rk610_tv_cvbs.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk610/rk610_tv_cvbs.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,210 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/display-sys.h>
+#include "rk610_tv.h"
+
+
+#ifdef CONFIG_DISPLAY_KEY_LED_CONTROL
+#define RK610_LED_CVBS_PIN	RK29_PIN4_PD3
+#else
+#define RK610_LED_CVBS_PIN	INVALID_GPIO
+#endif
+
+#ifdef USE_RGB2CCIR
+static const struct fb_videomode rk610_cvbs_mode [] = {
+		//name				refresh		xres	yres	pixclock	h_bp	h_fp	v_bp	v_fp	h_pw	v_pw	polariry	PorI	flag
+	{	"NTSC",				60,			720,	480,	27000000,	116,	16,		25,		14,		6,		6,		0,			1,		OUT_P888	},
+	{	"PAL",				50,			720,	576,	27000000,	126,	12,		37,		6,		6,		6,		0,			1,		OUT_P888	},
+};
+#else
+static const struct fb_videomode rk610_cvbs_mode [] = {
+		//name				refresh		xres	yres	pixclock	h_bp	h_fp	v_bp	v_fp	h_pw	v_pw	polariry	PorI	flag
+	{	"NTSC",				60,			720,	480,	27000000,	116,	16,		16,		3,		6,		3,		0,			1,		OUT_CCIR656	},
+	{	"PAL",				50,			720,	576,	27000000,	126,	12,		19,		2,		6,		3,		0,			1,		OUT_CCIR656	},
+};
+#endif
+
+struct rk610_monspecs rk610_cvbs_monspecs;
+
+
+int rk610_tv_cvbs_init(void)
+{
+	unsigned char TVE_Regs[9];
+	unsigned char TVE_CON_Reg;
+	int ret, i;
+	
+	rk610_tv_wirte_reg(TVE_HDTVCR, TVE_RESET);
+
+	memset(TVE_Regs, 0, 9);
+	TVE_CON_Reg = TVE_CONTROL_CVBS_3_CHANNEL_ENALBE;
+	TVE_Regs[TVE_VINCR] 	=	TVE_VINCR_PIX_DATA_DELAY(0) | TVE_VINCR_H_SYNC_POLARITY_NEGTIVE | TVE_VINCR_V_SYNC_POLARITY_NEGTIVE | TVE_VINCR_VSYNC_FUNCTION_VSYNC;
+	TVE_Regs[TVE_POWERCR]	=	TVE_DAC_Y_ENABLE | TVE_DAC_U_ENABLE | TVE_DAC_V_ENABLE;
+	TVE_Regs[TVE_VOUTCR]	=	TVE_VOUTCR_OUTPUT_CVBS;
+	TVE_Regs[TVE_YADJCR]	=	0x17;
+	TVE_Regs[TVE_YCBADJCR]	=	0x10;
+	TVE_Regs[TVE_YCRADJCR]	=	0x10;
+	
+	switch(rk610_tv_output_status) {
+		case TVOUT_CVBS_NTSC:
+			TVE_Regs[TVE_VFCR] 		= TVE_VFCR_ENABLE_SUBCARRIER_RESET | TVE_VFCR_VIN_RANGE_16_235 | TVE_VFCR_BLACK_7_5_IRE | TVE_VFCR_NTSC;
+			#ifdef USE_RGB2CCIR
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT601_SLAVE);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_COLOR_CONVERT_REC601 | TVE_INPUT_DATA_RGB | TVE_OUTPUT_MODE_PAL_NTSC;
+			TVE_CON_Reg |= RGB2CCIR_INPUT_DATA_FORMAT(0) | RGB2CCIR_RGB_SWAP_DISABLE | RGB2CCIR_INPUT_PROGRESSIVE | RGB2CCIR_CVBS_NTSC | RGB2CCIR_ENABLE;
+			#else
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT656);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_INPUT_DATA_YUV | TVE_OUTPUT_MODE_PAL_NTSC;
+			#endif			
+			break;
+		case TVOUT_CVBS_PAL:
+			TVE_Regs[TVE_VFCR] 		= TVE_VFCR_ENABLE_SUBCARRIER_RESET | TVE_VFCR_VIN_RANGE_16_235 | TVE_VFCR_BLACK_0_IRE | TVE_VFCR_PAL_B_N;		
+			#ifdef USE_RGB2CCIR
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT601_SLAVE);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_COLOR_CONVERT_REC601 | TVE_INPUT_DATA_RGB | TVE_OUTPUT_MODE_PAL_NTSC;
+			TVE_CON_Reg |= RGB2CCIR_INPUT_DATA_FORMAT(0) | RGB2CCIR_RGB_SWAP_DISABLE | RGB2CCIR_INPUT_PROGRESSIVE | RGB2CCIR_CVBS_PAL | RGB2CCIR_ENABLE;
+			#else
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT656);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_INPUT_DATA_YUV | TVE_OUTPUT_MODE_PAL_NTSC;
+			#endif			
+			break;
+		default:
+			return -1;
+	}
+	
+	for(i = 0; i < sizeof(TVE_Regs); i++){
+//		printk(KERN_ERR "reg[%d] = 0x%02x\n", i, TVE_Regs[i]);
+		ret = rk610_tv_wirte_reg(i, TVE_Regs[i]);
+		if(ret < 0){
+			printk(KERN_ERR "rk610_tv_wirte_reg %d err!\n", i);
+			return ret;
+		}
+	}
+//	printk(KERN_ERR "TVE_CON_Reg = 0x%02x\n", TVE_CON_Reg);
+	rk610_control_send_byte(RK610_CONTROL_REG_TVE_CON, TVE_CON_Reg);
+	#ifdef USE_RGB2CCIR
+	rk610_control_send_byte(RK610_CONTROL_REG_CCIR_RESET, 0x01);
+	#endif
+	return 0;
+}
+
+static int rk610_cvbs_set_enable(struct rk_display_device *device, int enable)
+{
+	if(rk610_cvbs_monspecs.enable != enable || rk610_cvbs_monspecs.mode_set != rk610_tv_output_status)
+	{
+		if(enable == 0)
+		{
+			rk610_tv_standby(RK610_TVOUT_CVBS);
+			rk610_cvbs_monspecs.enable = 0;
+			if(RK610_LED_CVBS_PIN != INVALID_GPIO)
+				gpio_direction_output(RK610_LED_CVBS_PIN, GPIO_HIGH);
+		}
+		else if(enable == 1)
+		{
+			rk610_switch_fb(rk610_cvbs_monspecs.mode, rk610_cvbs_monspecs.mode_set);
+			rk610_cvbs_monspecs.enable = 1;
+			if(RK610_LED_CVBS_PIN != INVALID_GPIO)
+				gpio_direction_output(RK610_LED_CVBS_PIN, GPIO_LOW);
+		}
+	}
+	return 0;
+}
+
+static int rk610_cvbs_get_enable(struct rk_display_device *device)
+{
+	return rk610_cvbs_monspecs.enable;
+}
+
+static int rk610_cvbs_get_status(struct rk_display_device *device)
+{
+	if(rk610_tv_output_status < TVOUT_YPbPr_720x480p_60)
+		return 1;
+	else
+		return 0;
+}
+
+static int rk610_cvbs_get_modelist(struct rk_display_device *device, struct list_head **modelist)
+{
+	*modelist = &(rk610_cvbs_monspecs.modelist);
+	return 0;
+}
+
+static int rk610_cvbs_set_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(rk610_cvbs_mode); i++)
+	{
+		if(fb_mode_is_equal(&rk610_cvbs_mode[i], mode))
+		{	
+			if( ((i + 1) != rk610_tv_output_status) )
+			{
+				rk610_cvbs_monspecs.mode_set = i + 1;
+				rk610_cvbs_monspecs.mode = (struct fb_videomode *)&rk610_cvbs_mode[i];
+			}
+			return 0;
+		}
+	}
+	
+	return -1;
+}
+
+static int rk610_cvbs_get_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	*mode = *(rk610_cvbs_monspecs.mode);
+	return 0;
+}
+
+static struct rk_display_ops rk610_cvbs_display_ops = {
+	.setenable = rk610_cvbs_set_enable,
+	.getenable = rk610_cvbs_get_enable,
+	.getstatus = rk610_cvbs_get_status,
+	.getmodelist = rk610_cvbs_get_modelist,
+	.setmode = rk610_cvbs_set_mode,
+	.getmode = rk610_cvbs_get_mode,
+};
+
+static int rk610_display_cvbs_probe(struct rk_display_device *device, void *devdata)
+{
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "TV");
+	device->priority = DISPLAY_PRIORITY_TV;
+	device->priv_data = devdata;
+	device->ops = &rk610_cvbs_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_rk610_cvbs = {
+	.probe = rk610_display_cvbs_probe,
+};
+
+int rk610_register_display_cvbs(struct device *parent)
+{
+	int i;
+	
+	memset(&rk610_cvbs_monspecs, 0, sizeof(struct rk610_monspecs));
+	INIT_LIST_HEAD(&rk610_cvbs_monspecs.modelist);
+	for(i = 0; i < ARRAY_SIZE(rk610_cvbs_mode); i++)
+		fb_add_videomode(&rk610_cvbs_mode[i], &rk610_cvbs_monspecs.modelist);
+	if(rk610_tv_output_status < TVOUT_YPbPr_720x480p_60) {
+		rk610_cvbs_monspecs.mode = (struct fb_videomode *)&(rk610_cvbs_mode[rk610_tv_output_status - 1]);
+		rk610_cvbs_monspecs.mode_set = rk610_tv_output_status;
+	}
+	else {
+		rk610_cvbs_monspecs.mode = (struct fb_videomode *)&(rk610_cvbs_mode[0]);
+		rk610_cvbs_monspecs.mode_set = TVOUT_CVBS_NTSC;
+	}
+	rk610_cvbs_monspecs.ddev = rk_display_device_register(&display_rk610_cvbs, parent, NULL);
+	if(RK610_LED_CVBS_PIN != INVALID_GPIO)
+    {        
+        if(gpio_request(RK610_LED_CVBS_PIN, NULL) != 0)
+        {
+            gpio_free(RK610_LED_CVBS_PIN);
+            dev_err(rk610_cvbs_monspecs.ddev->dev, ">>>>>> RK610_LED_CVBS_PIN gpio_request err \n ");
+            return -1;
+        }
+		gpio_pull_updown(RK610_LED_CVBS_PIN,GPIOPullUp);
+		gpio_direction_output(RK610_LED_CVBS_PIN, GPIO_HIGH);
+    }
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/tve/rk610/rk610_tv.h b/drivers/video/rockchip/tve/rk610/rk610_tv.h
--- a/drivers/video/rockchip/tve/rk610/rk610_tv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk610/rk610_tv.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,132 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _RK610_TV_H
+#define _RK610_TV_H
+#include <linux/display-sys.h>
+#include <linux/rk_fb.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#ifdef CONFIG_ARCH_RK29
+#include <mach/rk29_iomap.h>
+#endif
+#include "../screen/screen.h"
+#include "../../rk29_fb.h"
+#include <linux/mfd/rk610_core.h>
+
+#define TVE_VFCR		0x00
+	#define TVE_VFCR_ENABLE_SUBCARRIER_RESET	0 << 6
+	#define TVE_VFCR_DISABLE_SUBCARRIER_RESET	1 << 6
+	#define TVE_VFCR_VIN_RANGE_16_235			0 << 3
+	#define TVE_VFCR_VIN_RANGE_1_254			1 << 3
+	#define TVE_VFCR_BLACK_7_5_IRE				0 << 2
+	#define TVE_VFCR_BLACK_0_IRE				1 << 2
+	#define TVE_VFCR_NTSC						0
+	#define TVE_VFCR_PAL_M						1
+	#define TVE_VFCR_PAL_B_N					2
+	#define TVE_VFCR_PAL_NC						3
+
+#define TVE_VINCR		0x01
+	#define TVE_VINCR_PIX_DATA_DELAY(n)			(n << 5)
+	#define TVE_VINCR_H_SYNC_POLARITY_NEGTIVE	0 << 4
+	#define TVE_VINCR_H_SYNC_POLARITY_POSITIVE	1 << 4
+	#define TVE_VINCR_V_SYNC_POLARITY_NEGTIVE	0 << 3
+	#define TVE_VINCR_V_SYNC_POLARITY_POSITIVE	1 << 3
+enum {
+	INPUT_FORMAT_BT601_SLAVE = 0,
+	INPUT_FORMAT_BT656,
+	INPUT_FORMAT_BT601_MASTER,
+	INPUT_FORMAT_INTERNAL_COLLOR_BAR
+};
+	#define TVE_VINCR_INPUT_FORMAT(n)			(n << 1)
+	#define TVE_VINCR_VSYNC_FUNCTION_VSYNC		0
+	#define TVE_VINCR_VSYNC_FUNCTION_FIELD		1
+
+#define TVE_VOUTCR		0x02
+	#define TVE_VOUTCR_OUTPUT_CVBS				0 << 6
+	#define TVE_VOUTCR_OUTPUT_YPBPR				1 << 6
+	#define TVE_VOUTCR_OUTPUT_ENABLE_BLUE		1 << 5
+	#define TVE_VOUTCR_OUTPUT_ENABLE_BLACK		1 << 4
+	#define TVE_VOUTCR_DISABLE_CVBS_COLOR		1 << 3
+	#define TVE_VOUTCR_CVBS_Y2C_DELAY(n)				(n << 0)
+
+#define TVE_POWERCR		0x03
+	#define TVE_PIX_CLK_INVERSE_ENABLE			1 << 4
+	#define TVE_DAC_CLK_INVERSE_DISABLE			1 << 3
+	#define TVE_DAC_Y_ENABLE					1 << 2
+	#define TVE_DAC_U_ENABLE					1 << 1
+	#define TVE_DAC_V_ENABLE					1 << 0
+
+#define TVE_HDTVCR		0x05
+	#define TVE_RESET							1 << 7
+	#define TVE_FILTER(n)						(n << 5)
+	#define TVE_COLOR_CONVERT_REC601			0 << 4
+	#define TVE_COLOR_CONVERT_REC709			1 << 4
+	#define TVE_INPUT_DATA_RGB					0 << 3
+	#define TVE_INPUT_DATA_YUV					1 << 3
+	#define TVE_OUTPUT_50HZ						0 << 2
+	#define TVE_OUTPUT_60HZ						1 << 2
+	#define TVE_OUTPUT_MODE_PAL_NTSC			0
+	#define TVE_OUTPUT_MODE_576P				1
+	#define TVE_OUTPUT_MODE_480P				2
+	#define TVE_OUTPUT_MODE_720P				3
+
+#define TVE_YADJCR		0x06
+	#define TVE_OUTPUT_MODE_1080P				1 << 6
+	#define TVE_OUTPUT_MODE_1080I				1 << 5
+	#define TVE_Y_ADJ_VALUE(n)					n
+#define TVE_YCBADJCR	0x07
+#define TVE_YCRADJCR	0x08
+
+/******************* TVOUT OUTPUT TYPE **********************/
+struct rk610_monspecs {
+	struct rk_display_device	*ddev;
+	unsigned int				enable;
+	struct fb_videomode			*mode;
+	struct list_head			modelist;
+	unsigned int 				mode_set;
+};
+
+enum {
+	TVOUT_CVBS_NTSC = 1,
+	TVOUT_CVBS_PAL,
+	TVOUT_YPbPr_720x480p_60,
+	TVOUT_YPbPr_720x576p_50,
+	TVOUT_YPbPr_1280x720p_50,
+	TVOUT_YPbPr_1280x720p_60,
+	//TVOUT_YPbPr_1920x1080i_50,
+	TVOUT_YPbPr_1920x1080i_60,
+	TVOUT_YPbPr_1920x1080p_50,
+	TVOUT_YPbPr_1920x1080p_60
+};
+
+#define RK610_TVOUT_DEAULT TVOUT_CVBS_NTSC
+
+enum {
+	RK610_TVOUT_CVBS = 0,
+	RK610_TVOUT_YC,
+	RK610_TVOUT_YPBPR,
+};
+
+extern volatile int rk610_tv_output_status;
+extern struct rk_display_ops rk610_display_ops;
+
+extern int FB_Switch_Screen( struct rk_screen *screen, u32 enable );
+
+extern int rk610_tv_wirte_reg(u8 reg, u8 data);
+extern int rk610_tv_standby(int type);
+extern int rk610_switch_fb(const struct fb_videomode *modedb, int tv_mode);
+extern int rk610_register_display(struct device *parent);
+
+#ifdef CONFIG_RK610_TVOUT_YPbPr
+extern int rk610_tv_ypbpr_init(void);
+extern int rk610_register_display_ypbpr(struct device *parent);
+extern struct rk610_monspecs rk610_ypbpr_monspecs;
+#endif
+
+#ifdef CONFIG_RK610_TVOUT_CVBS
+extern int rk610_tv_cvbs_init(void);
+extern int rk610_register_display_cvbs(struct device *parent);
+extern struct rk610_monspecs rk610_cvbs_monspecs;
+#endif
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/tve/rk610/rk610_tv_ypbpr.c b/drivers/video/rockchip/tve/rk610/rk610_tv_ypbpr.c
--- a/drivers/video/rockchip/tve/rk610/rk610_tv_ypbpr.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/tve/rk610/rk610_tv_ypbpr.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,230 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/display-sys.h>
+#include "rk610_tv.h"
+
+
+#ifdef CONFIG_DISPLAY_KEY_LED_CONTROL
+#define RK610_LED_YPbPr_PIN	RK29_PIN4_PD5
+#else
+#define RK610_LED_YPbPr_PIN	INVALID_GPIO
+#endif
+#define E(fmt, arg...) printk("<3>!!!%s:%d: " fmt, __FILE__, __LINE__, ##arg)
+
+static const struct fb_videomode rk610_YPbPr_mode [] = {
+		//name				refresh		xres	yres	pixclock	h_bp	h_fp	v_bp	v_fp	h_pw	v_pw	polariry	PorI	flag
+	{	"YPbPr480p",		60,			720,	480,	27000000,	55,		19,		37,		5,		64,		5,		0,			0,		OUT_P888	},
+	{	"YPbPr576p",		50,			720,	576,	27000000,	68,		12,		39,		5,		64,		5,		0,			0,		OUT_P888	},
+	{	"YPbPr720p@50",		50,			1280,	720,	74250000,	600,	0,		20,		5,		100,	5,		0,			0,		OUT_P888	},
+	{	"YPbPr720p@60",		60,			1280,	720,	74250000,	270,	0,		20,		5,		100,	5,		0,			0,		OUT_P888	},
+	//{	"YPbPr1080i@50",	50,			1920,	1080,	148500000,	620,	0,		15,		2,		100,	5,		0,			1,		OUT_CCIR656	},
+	{	"YPbPr1080i@60",	60,			1920,	1080,	148500000,	180,	0,		15,		2,		100,	5,		0,			1,		OUT_CCIR656	},
+	{	"YPbPr1080p@50",	50,			1920,	1080,	148500000,	620,	0,		36,		4,		100,	5,		0,			0,		OUT_P888	},
+	{	"YPbPr1080p@60",	60,			1920,	1080,	148500000,	180,	0,		36,		4,		100,	5,		0,			0,		OUT_P888	},
+};
+
+struct rk610_monspecs rk610_ypbpr_monspecs;
+
+int rk610_tv_ypbpr_init(void)
+{
+	unsigned char TVE_Regs[9];
+	unsigned char TVE_CON_Reg;
+	int i, ret;
+	
+	rk610_tv_wirte_reg(TVE_HDTVCR, TVE_RESET);
+	memset(TVE_Regs, 0, 9);	
+	
+	TVE_CON_Reg = 0x00;
+	
+	TVE_Regs[TVE_VINCR] 	=	TVE_VINCR_PIX_DATA_DELAY(0) | TVE_VINCR_H_SYNC_POLARITY_NEGTIVE | TVE_VINCR_V_SYNC_POLARITY_NEGTIVE | TVE_VINCR_VSYNC_FUNCTION_VSYNC;
+	TVE_Regs[TVE_POWERCR]	=	TVE_DAC_CLK_INVERSE_DISABLE | TVE_DAC_Y_ENABLE | TVE_DAC_U_ENABLE | TVE_DAC_V_ENABLE;
+	TVE_Regs[TVE_VOUTCR]	=	TVE_VOUTCR_OUTPUT_YPBPR;
+	TVE_Regs[TVE_YADJCR]	=	0x17;
+	TVE_Regs[TVE_YCBADJCR]	=	0x10;
+	TVE_Regs[TVE_YCRADJCR]	=	0x10;
+	
+	switch(rk610_tv_output_status)
+	{
+		case TVOUT_YPbPr_720x480p_60:
+			TVE_Regs[TVE_VFCR]		=	TVE_VFCR_BLACK_0_IRE;
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT601_SLAVE);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_COLOR_CONVERT_REC601 | TVE_INPUT_DATA_RGB | TVE_OUTPUT_60HZ | TVE_OUTPUT_MODE_480P;
+			break;
+		case TVOUT_YPbPr_720x576p_50:
+			TVE_Regs[TVE_VFCR]		=	TVE_VFCR_BLACK_0_IRE | TVE_VFCR_PAL_NC;
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT601_SLAVE);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_COLOR_CONVERT_REC601 | TVE_INPUT_DATA_RGB | TVE_OUTPUT_50HZ | TVE_OUTPUT_MODE_576P;
+			break;
+		case TVOUT_YPbPr_1280x720p_50:
+			TVE_Regs[TVE_VFCR]		=	TVE_VFCR_BLACK_0_IRE | TVE_VFCR_PAL_NC;
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT601_SLAVE);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_COLOR_CONVERT_REC709 | TVE_INPUT_DATA_RGB | TVE_OUTPUT_50HZ | TVE_OUTPUT_MODE_720P;
+			break;
+		case TVOUT_YPbPr_1280x720p_60:
+			TVE_Regs[TVE_VFCR]		=	TVE_VFCR_BLACK_0_IRE | TVE_VFCR_PAL_NC;
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT601_SLAVE);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_COLOR_CONVERT_REC709 | TVE_INPUT_DATA_RGB | TVE_OUTPUT_60HZ | TVE_OUTPUT_MODE_720P;
+			break;
+		/*case TVOUT_YPbPr_1920x1080i_50:
+			TVE_Regs[TVE_VFCR]		=	TVE_VFCR_BLACK_0_IRE | TVE_VFCR_PAL_NC;
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT656);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_INPUT_DATA_YUV | TVE_OUTPUT_50HZ;
+			TVE_Regs[TVE_YADJCR]	|=	TVE_OUTPUT_MODE_1080I;
+			break;
+			*/
+		case TVOUT_YPbPr_1920x1080i_60:
+			TVE_Regs[TVE_VFCR]		=	TVE_VFCR_BLACK_0_IRE | TVE_VFCR_PAL_NC;
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT656);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_INPUT_DATA_YUV | TVE_OUTPUT_60HZ;
+			TVE_Regs[TVE_YADJCR]	|=	TVE_OUTPUT_MODE_1080I;
+			break;
+		case TVOUT_YPbPr_1920x1080p_50:
+			TVE_Regs[TVE_VFCR]		=	TVE_VFCR_BLACK_0_IRE | TVE_VFCR_PAL_NC;
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT601_SLAVE);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_COLOR_CONVERT_REC709 | TVE_INPUT_DATA_RGB | TVE_OUTPUT_50HZ;
+			TVE_Regs[TVE_YADJCR]	|=	TVE_OUTPUT_MODE_1080P;
+			break;
+		case TVOUT_YPbPr_1920x1080p_60:
+			TVE_Regs[TVE_VFCR]		=	TVE_VFCR_BLACK_0_IRE | TVE_VFCR_PAL_NC;
+			TVE_Regs[TVE_VINCR]		|=	TVE_VINCR_INPUT_FORMAT(INPUT_FORMAT_BT601_SLAVE);
+			TVE_Regs[TVE_HDTVCR]	=	TVE_FILTER(0) | TVE_COLOR_CONVERT_REC709 | TVE_INPUT_DATA_RGB | TVE_OUTPUT_60HZ;
+			TVE_Regs[TVE_YADJCR]	|=	TVE_OUTPUT_MODE_1080P;
+			break;
+		default:
+			return -1;
+	}
+	
+	rk610_control_send_byte(RK610_CONTROL_REG_TVE_CON, TVE_CON_Reg);
+	
+	for(i = 0; i < sizeof(TVE_Regs); i++){
+//		printk(KERN_ERR "reg[%d] = 0x%02x\n", i, TVE_Regs[i]);
+		ret = rk610_tv_wirte_reg(i, TVE_Regs[i]);
+		if(ret < 0){
+			E("rk610_tv_wirte_reg %d err!\n", i);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int rk610_ypbpr_set_enable(struct rk_display_device *device, int enable)
+{
+	if(rk610_ypbpr_monspecs.enable != enable || rk610_ypbpr_monspecs.mode_set != rk610_tv_output_status)
+	{
+		if(enable == 0)
+		{
+			rk610_tv_standby(RK610_TVOUT_YPBPR);
+			rk610_ypbpr_monspecs.enable = 0;
+			if(RK610_LED_YPbPr_PIN != INVALID_GPIO)
+				gpio_direction_output(RK610_LED_YPbPr_PIN, GPIO_HIGH);
+		}
+		else if(enable == 1)
+		{
+			rk610_switch_fb(rk610_ypbpr_monspecs.mode, rk610_ypbpr_monspecs.mode_set);
+			rk610_ypbpr_monspecs.enable = 1;
+			if(RK610_LED_YPbPr_PIN != INVALID_GPIO)
+				gpio_direction_output(RK610_LED_YPbPr_PIN, GPIO_LOW);
+		}
+	}
+	return 0;
+}
+
+static int rk610_ypbpr_get_enable(struct rk_display_device *device)
+{
+	return rk610_ypbpr_monspecs.enable;
+}
+
+static int rk610_ypbpr_get_status(struct rk_display_device *device)
+{
+	if(rk610_tv_output_status > TVOUT_CVBS_PAL)
+		return 1;
+	else
+		return 0;
+}
+
+static int rk610_ypbpr_get_modelist(struct rk_display_device *device, struct list_head **modelist)
+{
+	*modelist = &(rk610_ypbpr_monspecs.modelist);
+	return 0;
+}
+
+static int rk610_ypbpr_set_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	int i;
+
+	for(i = 0; i < ARRAY_SIZE(rk610_YPbPr_mode); i++)
+	{
+		if(fb_mode_is_equal(&rk610_YPbPr_mode[i], mode))
+		{	
+			if( (i + 3) != rk610_tv_output_status )
+			{
+				rk610_ypbpr_monspecs.mode_set = i + 3;
+				rk610_ypbpr_monspecs.mode = (struct fb_videomode *)&rk610_YPbPr_mode[i];
+			}
+			return 0;
+		}
+	}
+	
+	return -1;
+}
+
+static int rk610_ypbpr_get_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	*mode = *(rk610_ypbpr_monspecs.mode);
+	return 0;
+}
+
+static struct rk_display_ops rk610_ypbpr_display_ops = {
+	.setenable = rk610_ypbpr_set_enable,
+	.getenable = rk610_ypbpr_get_enable,
+	.getstatus = rk610_ypbpr_get_status,
+	.getmodelist = rk610_ypbpr_get_modelist,
+	.setmode = rk610_ypbpr_set_mode,
+	.getmode = rk610_ypbpr_get_mode,
+};
+
+static int rk610_display_YPbPr_probe(struct rk_display_device *device, void *devdata)
+{
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "YPbPr");
+	device->priority = DISPLAY_PRIORITY_YPbPr;
+	device->priv_data = devdata;
+	device->ops = &rk610_ypbpr_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_rk610_YPbPr = {
+	.probe = rk610_display_YPbPr_probe,
+};
+
+int rk610_register_display_ypbpr(struct device *parent)
+{
+	int i;
+	
+	memset(&rk610_ypbpr_monspecs, 0, sizeof(struct rk610_monspecs));
+	INIT_LIST_HEAD(&rk610_ypbpr_monspecs.modelist);
+	for(i = 0; i < ARRAY_SIZE(rk610_YPbPr_mode); i++)
+		fb_add_videomode(&rk610_YPbPr_mode[i], &rk610_ypbpr_monspecs.modelist);
+	if(rk610_tv_output_status > TVOUT_CVBS_PAL) {
+		rk610_ypbpr_monspecs.mode = (struct fb_videomode *)&(rk610_YPbPr_mode[rk610_tv_output_status - 3]);
+		rk610_ypbpr_monspecs.mode_set = rk610_tv_output_status;
+	}
+	else {
+		rk610_ypbpr_monspecs.mode = (struct fb_videomode *)&(rk610_YPbPr_mode[3]);
+		rk610_ypbpr_monspecs.mode_set = TVOUT_YPbPr_1280x720p_60;
+	}
+	rk610_ypbpr_monspecs.ddev = rk_display_device_register(&display_rk610_YPbPr, parent, NULL);
+	if(RK610_LED_YPbPr_PIN != INVALID_GPIO)
+    {        
+        if(gpio_request(RK610_LED_YPbPr_PIN, NULL) != 0)
+        {
+            gpio_free(RK610_LED_YPbPr_PIN);
+            dev_err(rk610_ypbpr_monspecs.ddev->dev, ">>>>>> RK610_LED_YPbPr_PIN gpio_request err \n ");
+            return -1;
+        }
+		gpio_pull_updown(RK610_LED_YPbPr_PIN,GPIOPullUp);
+		gpio_direction_output(RK610_LED_YPbPr_PIN, GPIO_HIGH);
+    }
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/vcodec/Kconfig b/drivers/video/rockchip/vcodec/Kconfig
--- a/drivers/video/rockchip/vcodec/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+menu "VCODEC"
+	depends on ARCH_ROCKCHIP
+
+config RK_VCODEC
+	tristate "VCODEC (VPU HEVC) service driver in kernel"
+	depends on ARCH_ROCKCHIP
+	default n
+
+endmenu
diff -Nupr a/drivers/video/rockchip/vcodec/Makefile b/drivers/video/rockchip/vcodec/Makefile
--- a/drivers/video/rockchip/vcodec/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0
+rk-vcodec-objs := vcodec_service.o vcodec_iommu_ops.o
+
+ifdef CONFIG_DRM
+rk-vcodec-objs += vcodec_iommu_drm.o
+endif
+
+ifdef CONFIG_ION
+rk-vcodec-objs += vcodec_iommu_ion.o
+endif
+
+obj-$(CONFIG_RK_VCODEC) += rk-vcodec.o
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_hw_info.h b/drivers/video/rockchip/vcodec/vcodec_hw_info.h
--- a/drivers/video/rockchip/vcodec/vcodec_hw_info.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_hw_info.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,240 @@
+/**
+ * Copyright (C) 2015 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Herman Chen herman.chen@rock-chips.com
+ *         Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_ROCKCHIP_VCODEC_HW_INFO_H
+#define __ARCH_ARM_MACH_ROCKCHIP_VCODEC_HW_INFO_H
+
+/*
+ * Hardware id is for hardware detection
+ * Driver will read the hardware ID register first, then try to find a mactch
+ * hardware from the enum ID below.
+ */
+enum VPU_HW_ID {
+	VPU_DEC_ID_9190		= 0x6731,
+	VPU_ID_8270		= 0x8270,
+	VPU_ID_4831		= 0x4831,
+	HEVC_ID			= 0x6867,
+	RKV_DEC_ID		= 0x6876,
+	RKV_DEC_ID2             = 0x3410,
+	VPU2_ID			= 0x0000,
+};
+
+/*
+ * Different hardware has different feature. So we catalogue these features
+ * into three class:
+ *
+ * 1. register io feature determined by hardware type
+ *    including register offset, register file size, etc
+ *
+ * 2. runtime register config feature determined by task type
+ *    including irq / enable / length register, bit mask, etc
+ *
+ * 3. file handle translate feature determined by vcodec format type
+ *    register translation map table
+ *
+ * These three type features composite a complete codec information structure
+ */
+
+/* VPU1 and VPU2 */
+#define VCODEC_DEVICE_TYPE_VPUX		0x56505558
+/* VPU Combo */
+#define VCODEC_DEVICE_TYPE_VPUC		0x56505543
+#define VCODEC_DEVICE_TYPE_HEVC		0x56505532
+#define VCODEC_DEVICE_TYPE_RKVD		0x524B5644
+
+enum TASK_TYPE {
+	TASK_ENC,
+	TASK_DEC,
+	TASK_PP,
+	TASK_DEC_PP,
+	TASK_TYPE_BUTT,
+};
+
+enum FORMAT_TYPE {
+	FMT_DEC_BASE = 0,
+	FMT_JPEGD = FMT_DEC_BASE,
+
+	FMT_H263D,
+	FMT_H264D,
+	FMT_H265D,
+
+	FMT_MPEG1D,
+	FMT_MPEG2D,
+	FMT_MPEG4D,
+
+	FMT_VP6D,
+	FMT_VP7D,
+	FMT_VP8D,
+	FMT_VP9D,
+
+	FMT_VC1D,
+	FMT_AVSD,
+
+	FMT_DEC_BUTT,
+
+	FMT_PP_BASE = FMT_DEC_BUTT,
+	FMT_PP = FMT_PP_BASE,
+	FMT_PP_BUTT,
+
+	FMT_ENC_BASE = FMT_PP_BUTT,
+	FMT_JPEGE = FMT_ENC_BASE,
+
+	FMT_H264E,
+
+	FMT_VP8E,
+
+	FMT_ENC_BUTT,
+	FMT_TYPE_BUTT = FMT_ENC_BUTT,
+};
+
+/**
+ * struct for hardware task operation
+ */
+struct vpu_hw_info {
+	enum VPU_HW_ID	hw_id;
+	u32		enc_offset;
+	u32		enc_reg_num;
+	u32		enc_io_size;
+
+	u32		dec_offset;
+	u32		dec_reg_num;
+	u32		dec_io_size;
+
+	/*
+	 * register range for enc/dec/pp/dec_pp
+	 * base/end of dec/pp/dec_pp specify the register range to config
+	 */
+	u32		base_dec;
+	u32		base_pp;
+	u32		base_dec_pp;
+	u32		end_dec;
+	u32		end_pp;
+	u32		end_dec_pp;
+};
+
+struct vpu_task_info {
+	char *name;
+	struct timeval start;
+	struct timeval end;
+
+	/*
+	 * input stream register
+	 * use for map/unmap drm buffer for avoiding
+	 * cache sync issue
+	 */
+	int reg_rlc;
+	/*
+	 * task enable register
+	 * use for enable hardware task process
+	 *  -1 for invalid
+	 */
+	int reg_en;
+
+	/* register of task auto gating, alway valid */
+	int reg_gating;
+
+	/* register of task irq, alway valid */
+	int reg_irq;
+
+	/*
+	 * stream length register
+	 * only valid for decoder task
+	 * -1 for invalid (encoder)
+	 */
+	int reg_len;
+
+	/*
+	 * direct mv register
+	 * special offset scale, offset multiply by 16
+	 *
+	 * valid on vpu & vpu2
+	 * -1 for invalid
+	 */
+	int reg_dir_mv;
+
+	/*
+	 * pps register
+	 * special register for scaling list address process
+	 *
+	 * valid on rkv
+	 * -1 for invalid
+	 */
+	int reg_pps;
+
+	/*
+	 * decoder pipeline mode register
+	 *
+	 * valid on vpu & vpu2
+	 * -1 for invalid
+	 */
+	int reg_pipe;
+
+	/* task enable bit mask for enable register */
+	u32 enable_mask;
+
+	/* task auto gating mask for enable register */
+	u32 gating_mask;
+
+	/* task pipeline mode mask for pipe register */
+	u32 pipe_mask;
+
+	/* task inturrpt bit mask for irq register */
+	u32 irq_mask;
+
+	/* task ready bit mask for irq register */
+	u32 ready_mask;
+
+	/* task error bit mask for irq register */
+	u32 error_mask;
+
+	enum FORMAT_TYPE (*get_fmt)(u32 *regs);
+};
+
+struct vpu_trans_info {
+	const int count;
+	const char * const table;
+};
+
+struct vcodec_info {
+	enum VPU_HW_ID			hw_id;
+	struct vpu_hw_info		*hw_info;
+	struct vpu_task_info		*task_info;
+	const struct vpu_trans_info	*trans_info;
+};
+
+struct vcodec_device_info {
+	int32_t device_type;
+	int8_t *name;
+};
+
+#define DEF_FMT_TRANS_TBL(fmt, args...) \
+	static const char trans_tbl_##fmt[] = { \
+		args \
+	}
+
+#define SETUP_FMT_TBL(id, fmt) \
+	[id] = { \
+		.count = sizeof(trans_tbl_##fmt), \
+		.table = trans_tbl_##fmt, \
+	}
+
+#define EMPTY_FMT_TBL(id) \
+	[id] = { \
+		.count = 0, \
+		.table = NULL, \
+	}
+
+#endif
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_hw_rkv.h b/drivers/video/rockchip/vcodec/vcodec_hw_rkv.h
--- a/drivers/video/rockchip/vcodec/vcodec_hw_rkv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_hw_rkv.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,227 @@
+/**
+ * Copyright (C) 2015 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_ROCKCHIP_VCODEC_HW_RKV_H
+#define __ARCH_ARM_MACH_ROCKCHIP_VCODEC_HW_RKV_H
+
+#include "vcodec_hw_info.h"
+
+/* hardware information */
+#define REG_NUM_HEVC_DEC		(68)
+#define REG_NUM_RKV_DEC			(78)
+
+/* enable and gating register */
+#define RKV_REG_EN_DEC			1
+#define RKV_REG_DEC_GATING_BIT		BIT(1)
+
+/* interrupt and error status register */
+#define HEVC_INTERRUPT_REGISTER		1
+#define HEVC_INTERRUPT_BIT		BIT(8)
+#define HEVC_DEC_INT_RAW_BIT		BIT(9)
+#define HEVC_READY_BIT			BIT(12)
+#define HEVC_DEC_BUS_ERROR_BIT		BIT(13)
+#define HEVC_DEC_STR_ERROR_BIT		BIT(14)
+#define HEVC_DEC_TIMEOUT_BIT		BIT(15)
+#define HEVC_DEC_BUFFER_EMPTY_BIT	BIT(16)
+#define HEVC_DEC_COLMV_ERROR_BIT	BIT(17)
+#define HEVC_DEC_ERR_MASK		(HEVC_DEC_BUS_ERROR_BIT \
+					|HEVC_DEC_STR_ERROR_BIT \
+					|HEVC_DEC_TIMEOUT_BIT \
+					|HEVC_DEC_BUFFER_EMPTY_BIT \
+					|HEVC_DEC_COLMV_ERROR_BIT)
+
+#define RKV_DEC_INTERRUPT_REGISTER	1
+#define RKV_DEC_INTERRUPT_BIT		BIT(8)
+#define RKV_DEC_INT_RAW_BIT		BIT(9)
+#define RKV_DEC_READY_BIT		BIT(12)
+#define RKV_DEC_BUS_ERROR_BIT		BIT(13)
+#define RKV_DEC_STR_ERROR_BIT		BIT(14)
+#define RKV_DEC_TIMEOUT_BIT		BIT(15)
+#define RKV_DEC_BUFFER_EMPTY_BIT	BIT(16)
+#define RKV_DEC_COLMV_ERROR_BIT		BIT(17)
+#define RKV_DEC_ERR_MASK		(RKV_DEC_BUS_ERROR_BIT \
+					|RKV_DEC_STR_ERROR_BIT \
+					|RKV_DEC_TIMEOUT_BIT \
+					|RKV_DEC_BUFFER_EMPTY_BIT \
+					|RKV_DEC_COLMV_ERROR_BIT)
+
+static const enum FORMAT_TYPE rkv_dec_fmt_tbl[] = {
+	[0]  = FMT_H265D,
+	[1]  = FMT_H264D,
+	[2]  = FMT_VP9D,
+	[3]  = FMT_TYPE_BUTT,
+};
+
+static enum FORMAT_TYPE rkv_dec_get_fmt(u32 *regs)
+{
+	u32 fmt_id = (regs[2] >> 20) & 0x3;
+	enum FORMAT_TYPE type = rkv_dec_fmt_tbl[fmt_id];
+	return type;
+}
+
+static struct vpu_task_info task_rkv[TASK_TYPE_BUTT] = {
+	{
+		.name = "invalid",
+		.reg_en = 0,
+		.reg_irq = 0,
+		.reg_len = 0,
+		.reg_dir_mv = 0,
+		.reg_pps = -1,
+		.reg_pipe = 0,
+		.enable_mask = 0,
+		.gating_mask = 0,
+		.pipe_mask = 0,
+		.irq_mask = 0,
+		.ready_mask = 0,
+		.error_mask = 0,
+		.get_fmt = NULL,
+	},
+	{
+		.name = "rkvdec",
+		.reg_rlc = 4,
+		.reg_en = RKV_REG_EN_DEC,
+		.reg_irq = RKV_DEC_INTERRUPT_REGISTER,
+		.reg_len = 4,
+		.reg_dir_mv = 52,
+		.reg_pps = 42,
+		.reg_pipe = 0,
+		.enable_mask = 0,
+		.gating_mask = RKV_REG_DEC_GATING_BIT,
+		.irq_mask = HEVC_INTERRUPT_BIT,
+		.pipe_mask = 0,
+		.ready_mask = HEVC_READY_BIT,
+		.error_mask = HEVC_DEC_ERR_MASK,
+		.get_fmt = rkv_dec_get_fmt,
+	},
+	{
+		.name = "invalid",
+		.reg_en = 0,
+		.reg_irq = 0,
+		.reg_len = 0,
+		.reg_dir_mv = 0,
+		.reg_pps = -1,
+		.reg_pipe = 0,
+		.enable_mask = 0,
+		.gating_mask = 0,
+		.pipe_mask = 0,
+		.irq_mask = 0,
+		.ready_mask = 0,
+		.error_mask = 0,
+		.get_fmt = NULL,
+	},
+	{
+		.name = "invalid",
+		.reg_en = 0,
+		.reg_irq = 0,
+		.reg_len = 0,
+		.reg_dir_mv = 0,
+		.reg_pps = -1,
+		.reg_pipe = 0,
+		.enable_mask = 0,
+		.gating_mask = 0,
+		.pipe_mask = 0,
+		.irq_mask = 0,
+		.ready_mask = 0,
+		.error_mask = 0,
+		.get_fmt = NULL,
+	},};
+
+static struct vpu_hw_info hw_rkhevc = {
+	.hw_id		= HEVC_ID,
+
+	.enc_offset	= 0,
+	.enc_reg_num	= 0,
+	.enc_io_size	= 0,
+
+	.dec_offset	= 0,
+	.dec_reg_num	= REG_NUM_HEVC_DEC,
+	.dec_io_size	= REG_NUM_HEVC_DEC * 4,
+
+	/* NOTE: can not write to register 0 */
+	.base_dec	= 1,
+	.base_pp	= 0,
+	.base_dec_pp	= 0,
+	.end_dec	= REG_NUM_HEVC_DEC,
+	.end_pp		= 0,
+	.end_dec_pp	= 0,
+};
+
+static struct vpu_hw_info hw_rkvdec = {
+	.hw_id		= RKV_DEC_ID,
+
+	.enc_offset	= 0,
+	.enc_reg_num	= 0,
+	.enc_io_size	= 0,
+
+	.dec_offset	= 0x0,
+	.dec_reg_num	= REG_NUM_RKV_DEC,
+	.dec_io_size	= REG_NUM_RKV_DEC * 4,
+
+	/* NOTE: can not write to register 0 */
+	.base_dec	= 1,
+	.base_pp	= 0,
+	.base_dec_pp	= 0,
+	.end_dec	= REG_NUM_RKV_DEC,
+	.end_pp		= 0,
+	.end_dec_pp	= 0,
+};
+
+/*
+ * file handle translate information
+ */
+DEF_FMT_TRANS_TBL(rkv_h264d,
+		  4,  6,  7,  10, 11, 12, 13, 14,
+		  15, 16, 17, 18, 19, 20, 21, 22,
+		  23, 24, 41, 42, 43, 48, 75
+);
+
+DEF_FMT_TRANS_TBL(rkv_h265d,
+		  4,  6,  7,  10, 11, 12, 13, 14,
+		  15, 16, 17, 18, 19, 20, 21, 22,
+		  23, 24, 42, 43
+);
+
+DEF_FMT_TRANS_TBL(rkv_vp9d,
+		  4,  6,  7,  11, 12, 13, 14, 15,
+		  16, 52
+);
+
+const struct vpu_trans_info trans_rkv[FMT_TYPE_BUTT] = {
+	EMPTY_FMT_TBL(FMT_JPEGD),
+	EMPTY_FMT_TBL(FMT_H263D),
+	SETUP_FMT_TBL(FMT_H264D , rkv_h264d),
+	SETUP_FMT_TBL(FMT_H265D , rkv_h265d),
+
+	EMPTY_FMT_TBL(FMT_MPEG1D),
+	EMPTY_FMT_TBL(FMT_MPEG2D),
+	EMPTY_FMT_TBL(FMT_MPEG4D),
+
+	EMPTY_FMT_TBL(FMT_VP6D),
+	EMPTY_FMT_TBL(FMT_VP7D),
+	EMPTY_FMT_TBL(FMT_VP8D),
+	SETUP_FMT_TBL(FMT_VP9D  , rkv_vp9d),
+
+	EMPTY_FMT_TBL(FMT_PP),
+
+	EMPTY_FMT_TBL(FMT_VC1D),
+	EMPTY_FMT_TBL(FMT_AVSD),
+
+	EMPTY_FMT_TBL(FMT_JPEGE),
+	EMPTY_FMT_TBL(FMT_H264E),
+	EMPTY_FMT_TBL(FMT_VP8E),
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_hw_vpu2.h b/drivers/video/rockchip/vcodec/vcodec_hw_vpu2.h
--- a/drivers/video/rockchip/vcodec/vcodec_hw_vpu2.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_hw_vpu2.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,278 @@
+/**
+ * Copyright (C) 2015 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_ROCKCHIP_VCODEC_HW_VPU2_H
+#define __ARCH_ARM_MACH_ROCKCHIP_VCODEC_HW_VPU2_H
+
+#include "vcodec_hw_info.h"
+
+/* hardware information */
+#define REG_NUM_VPU2_DEC		(159)
+#define REG_NUM_VPU2_DEC_START		(50)
+#define REG_NUM_VPU2_DEC_END		(159)
+#define REG_NUM_VPU2_PP			(41)
+#define REG_NUM_VPU2_DEC_PP		(159)
+#define REG_NUM_VPU2_ENC		(184)
+#define REG_NUM_VPU2_DEC_OFFSET		(0x400)
+
+/* enable and gating register */
+#define VPU2_REG_EN_ENC			103
+#define VPU2_REG_ENC_GATE		109
+#define VPU2_REG_ENC_GATE_BIT		BIT(4)
+
+#define VPU2_REG_EN_DEC			57
+#define VPU2_REG_DEC_GATE		57
+#define VPU2_REG_DEC_GATE_BIT		BIT(4)
+#define VPU2_REG_EN_PP			41
+#define VPU2_REG_PP_GATE		1
+#define VPU2_REG_PP_GATE_BIT		BIT(8)
+#define VPU2_REG_EN_DEC_PP		57
+#define VPU2_REG_DEC_PP_GATE		57
+#define VPU2_REG_DEC_PP_GATE_BIT	BIT(4)
+
+/* interrupt and error status register */
+#define VPU2_DEC_INTERRUPT_REGISTER	55
+#define VPU2_DEC_INTERRUPT_BIT		BIT(0)
+#define VPU2_DEC_READY_BIT		BIT(4)
+#define VPU2_DEC_BUS_ERROR_BIT		BIT(5)
+#define VPU2_DEC_BUFFER_EMPTY_BIT	BIT(6)
+#define VPU2_DEC_ASO_ERROR_BIT		BIT(8)
+#define VPU2_DEC_SLICE_DONE_BIT		BIT(9)
+#define VPU2_DEC_STREAM_ERROR_BIT	BIT(12)
+#define VPU2_DEC_TIMEOUT_BIT		BIT(13)
+#define VPU2_DEC_ERR_MASK		(VPU2_DEC_BUS_ERROR_BIT \
+					|VPU2_DEC_BUFFER_EMPTY_BIT \
+					|VPU2_DEC_STREAM_ERROR_BIT \
+					|VPU2_DEC_TIMEOUT_BIT)
+
+#define VPU2_PP_INTERRUPT_REGISTER	40
+#define VPU2_PP_INTERRUPT_BIT		BIT(0)
+#define VPU2_PP_READY_BIT		BIT(2)
+#define VPU2_PP_BUS_ERROR_BIT		BIT(3)
+#define VPU2_PP_ERR_MASK		VPU2_PP_BUS_ERROR_BIT
+#define VPU2_PP_PIPELINE_REGISTER	41
+#define VPU2_PP_PIPELINE_MODE_BIT	BIT(4)
+
+#define VPU2_ENC_INTERRUPT_REGISTER	109
+#define VPU2_ENC_INTERRUPT_BIT		BIT(0)
+#define VPU2_ENC_READY_BIT		BIT(1)
+#define VPU2_ENC_BUS_ERROR_BIT		BIT(4)
+#define VPU2_ENC_BUFFER_FULL_BIT	BIT(5)
+#define VPU2_ENC_TIMEOUT_BIT		BIT(6)
+#define VPU2_ENC_ERR_MASK		(VPU2_ENC_BUS_ERROR_BIT \
+					|VPU2_ENC_BUFFER_FULL_BIT \
+					|VPU2_ENC_TIMEOUT_BIT)
+
+static const enum FORMAT_TYPE vpu2_dec_fmt_tbl[] = {
+	[0]  = FMT_H264D,
+	[1]  = FMT_MPEG4D,
+	[2]  = FMT_H263D,
+	[3]  = FMT_JPEGD,
+	[4]  = FMT_VC1D,
+	[5]  = FMT_MPEG2D,
+	[6]  = FMT_MPEG1D,
+	[7]  = FMT_VP6D,
+	[8]  = FMT_TYPE_BUTT,
+	[9]  = FMT_VP7D,
+	[10] = FMT_VP8D,
+	[11] = FMT_AVSD,
+	[12] = FMT_TYPE_BUTT,
+	[13] = FMT_TYPE_BUTT,
+	[14] = FMT_TYPE_BUTT,
+	[15] = FMT_TYPE_BUTT,
+};
+
+static enum FORMAT_TYPE vpu2_dec_get_fmt(u32 *regs)
+{
+	u32 fmt_id = regs[53] & 0xf;
+	enum FORMAT_TYPE type = vpu2_dec_fmt_tbl[fmt_id];
+	return type;
+}
+
+static enum FORMAT_TYPE vpu2_pp_get_fmt(u32 *regs)
+{
+	return FMT_PP;
+}
+
+static const enum FORMAT_TYPE vpu2_enc_fmt_tbl[] = {
+	[0]  = FMT_TYPE_BUTT,
+	[1]  = FMT_VP8E,
+	[2]  = FMT_JPEGE,
+	[3]  = FMT_H264E,
+};
+
+static enum FORMAT_TYPE vpu2_enc_get_fmt(u32 *regs)
+{
+	u32 fmt_id = (regs[VPU2_REG_EN_ENC] >> 4) & 0x3;
+	enum FORMAT_TYPE type = vpu2_enc_fmt_tbl[fmt_id];
+	return type;
+}
+
+static struct vpu_task_info task_vpu2[TASK_TYPE_BUTT] = {
+	{
+		.name = "vpu2_enc",
+		.reg_rlc = 48,
+		.reg_en = VPU2_REG_EN_ENC,
+		.reg_gating = VPU2_REG_ENC_GATE,
+		.reg_irq = VPU2_ENC_INTERRUPT_REGISTER,
+		.reg_len = -1,
+		.reg_dir_mv = -1,
+		.reg_pps = -1,
+		.reg_pipe = -1,
+		.enable_mask = 0x30,
+		.gating_mask = VPU2_REG_ENC_GATE_BIT,
+		.pipe_mask = 0,
+		.irq_mask = VPU2_ENC_INTERRUPT_BIT,
+		.ready_mask = VPU2_ENC_READY_BIT,
+		.error_mask = VPU2_ENC_ERR_MASK,
+		.get_fmt = vpu2_enc_get_fmt,
+	},
+	{
+		.name = "vpu2_dec",
+		.reg_rlc = 64,
+		.reg_en = VPU2_REG_EN_DEC,
+		.reg_irq = VPU2_DEC_INTERRUPT_REGISTER,
+		.reg_len = 64,
+		.reg_dir_mv = 62,
+		.reg_pps = -1,
+		.reg_pipe = VPU2_PP_PIPELINE_REGISTER,
+		.enable_mask = 0,
+		.gating_mask = VPU2_REG_DEC_GATE_BIT,
+		.pipe_mask = VPU2_PP_PIPELINE_MODE_BIT,
+		.irq_mask = VPU2_DEC_INTERRUPT_BIT,
+		.ready_mask = VPU2_DEC_READY_BIT,
+		.error_mask = VPU2_DEC_ERR_MASK,
+		.get_fmt = vpu2_dec_get_fmt,
+	},
+	{
+		.name = "vpu2_pp",
+		.reg_en = VPU2_REG_EN_PP,
+		.reg_irq = VPU2_PP_INTERRUPT_REGISTER,
+		.reg_len = -1,
+		.reg_dir_mv = -1,
+		.reg_pps = -1,
+		.reg_pipe = VPU2_PP_PIPELINE_REGISTER,
+		.enable_mask = 0,
+		.gating_mask = VPU2_REG_PP_GATE_BIT,
+		.pipe_mask = VPU2_PP_PIPELINE_MODE_BIT,
+		.irq_mask = VPU2_PP_INTERRUPT_BIT,
+		.ready_mask = VPU2_PP_READY_BIT,
+		.error_mask = VPU2_PP_ERR_MASK,
+		.get_fmt = vpu2_pp_get_fmt,
+	},
+	{
+		.name = "vpu2_dec_pp",
+		.reg_rlc = 64,
+		.reg_en = VPU2_REG_EN_DEC_PP,
+		.reg_irq = VPU2_DEC_INTERRUPT_REGISTER,
+		.reg_len = 64,
+		.reg_dir_mv = 62,
+		.reg_pps = -1,
+		.reg_pipe = VPU2_PP_PIPELINE_REGISTER,
+		.enable_mask = 0,
+		.gating_mask = VPU2_REG_DEC_GATE_BIT,
+		.pipe_mask = VPU2_PP_PIPELINE_MODE_BIT,
+		.irq_mask = VPU2_DEC_INTERRUPT_BIT,
+		.ready_mask = VPU2_DEC_READY_BIT,
+		.error_mask = VPU2_DEC_ERR_MASK,
+		.get_fmt = vpu2_dec_get_fmt,
+	},
+};
+
+static struct vpu_hw_info hw_vpu2 = {
+	.hw_id		= VPU2_ID,
+
+	.enc_offset	= 0x0,
+	.enc_reg_num	= REG_NUM_VPU2_ENC,
+	.enc_io_size	= REG_NUM_VPU2_ENC * 4,
+
+	.dec_offset	= REG_NUM_VPU2_DEC_OFFSET,
+	.dec_reg_num	= REG_NUM_VPU2_DEC_PP,
+	.dec_io_size	= REG_NUM_VPU2_DEC_PP * 4,
+
+	.base_dec	= REG_NUM_VPU2_DEC_START,
+	.base_pp	= 0,
+	.base_dec_pp	= 0,
+	.end_dec	= REG_NUM_VPU2_DEC_END,
+	.end_pp		= REG_NUM_VPU2_PP,
+	.end_dec_pp	= REG_NUM_VPU2_DEC_END,
+};
+
+/*
+ * file handle translate information
+ */
+DEF_FMT_TRANS_TBL(vpu2_jpegd,
+		  131, 64, 63, 61, 21, 22
+);
+
+DEF_FMT_TRANS_TBL(vpu2_h264d,
+		  64, 63, 84, 85, 86, 87, 88, 89,
+		  90, 91, 92, 93, 94, 95, 96, 97,
+		  98, 99, 61, 62
+);
+
+DEF_FMT_TRANS_TBL(vpu2_vp6d,
+		  64, 63, 131, 136, 145, 61
+);
+
+DEF_FMT_TRANS_TBL(vpu2_vp8d,
+		  149,  64,  63, 131, 136, 137, 140, 141,
+		  142, 143, 144, 145, 146, 147, 61
+);
+
+DEF_FMT_TRANS_TBL(vpu2_vc1d,
+		  64, 63, 131, 148, 134, 135, 145, 62
+);
+
+DEF_FMT_TRANS_TBL(vpu2_default_dec,
+		  64, 63, 131, 148, 134, 135, 61, 62
+);
+
+DEF_FMT_TRANS_TBL(vpu2_default_pp,
+		  12, 13, 18, 19, 20, 21, 22
+);
+
+DEF_FMT_TRANS_TBL(vpu2_default_enc,
+		  77, 78, 56, 57, 63, 64, 48, 49,
+		  50, 81
+);
+
+const struct vpu_trans_info trans_vpu2[FMT_TYPE_BUTT] = {
+	SETUP_FMT_TBL(FMT_JPEGD , vpu2_jpegd),
+	SETUP_FMT_TBL(FMT_H263D , vpu2_default_dec),
+	SETUP_FMT_TBL(FMT_H264D , vpu2_h264d),
+	EMPTY_FMT_TBL(FMT_H265D),
+
+	SETUP_FMT_TBL(FMT_MPEG1D, vpu2_default_dec),
+	SETUP_FMT_TBL(FMT_MPEG2D, vpu2_default_dec),
+	SETUP_FMT_TBL(FMT_MPEG4D, vpu2_default_dec),
+
+	SETUP_FMT_TBL(FMT_VP6D  , vpu2_vp6d),
+	SETUP_FMT_TBL(FMT_VP7D  , vpu2_default_dec),
+	SETUP_FMT_TBL(FMT_VP8D  , vpu2_vp8d),
+	EMPTY_FMT_TBL(FMT_VP9D),
+
+	SETUP_FMT_TBL(FMT_PP    , vpu2_default_pp),
+
+	SETUP_FMT_TBL(FMT_VC1D  , vpu2_vc1d),
+	SETUP_FMT_TBL(FMT_AVSD  , vpu2_default_dec),
+
+	SETUP_FMT_TBL(FMT_JPEGE , vpu2_default_enc),
+	SETUP_FMT_TBL(FMT_H264E , vpu2_default_enc),
+	SETUP_FMT_TBL(FMT_VP8E  , vpu2_default_enc),
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_hw_vpu.h b/drivers/video/rockchip/vcodec/vcodec_hw_vpu.h
--- a/drivers/video/rockchip/vcodec/vcodec_hw_vpu.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_hw_vpu.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,325 @@
+/**
+ * Copyright (C) 2015 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ARCH_ARM_MACH_ROCKCHIP_VCODEC_HW_VPU_H
+#define __ARCH_ARM_MACH_ROCKCHIP_VCODEC_HW_VPU_H
+
+#include "vcodec_hw_info.h"
+
+/* hardware information */
+#define REG_NUM_9190_DEC		(60)
+#define REG_NUM_9190_PP			(41)
+#define REG_NUM_9190_DEC_PP		(REG_NUM_9190_DEC + REG_NUM_9190_PP)
+
+#define REG_NUM_DEC_PP			(REG_NUM_9190_DEC + REG_NUM_9190_PP)
+
+#define REG_NUM_ENC_8270		(96)
+#define REG_SIZE_ENC_8270		(0x200)
+#define REG_NUM_ENC_4831		(164)
+#define REG_SIZE_ENC_4831		(0x400)
+
+
+/* enable and gating register */
+#define VPU_REG_EN_ENC			14
+#define VPU_REG_ENC_GATE		2
+#define VPU_REG_ENC_GATE_BIT		BIT(4)
+
+#define VPU_REG_EN_DEC			1
+#define VPU_REG_DEC_GATE		2
+#define VPU_REG_DEC_GATE_BIT		BIT(10)
+#define VPU_REG_EN_PP			0
+#define VPU_REG_PP_GATE			1
+#define VPU_REG_PP_GATE_BIT		BIT(8)
+#define VPU_REG_EN_DEC_PP		1
+#define VPU_REG_DEC_PP_GATE		61
+#define VPU_REG_DEC_PP_GATE_BIT		BIT(8)
+
+/* interrupt and error status register */
+#define VPU_DEC_INTERRUPT_REGISTER      1
+#define VPU_DEC_INTERRUPT_BIT	        BIT(8)
+#define VPU_DEC_READY_BIT	        BIT(12)
+#define VPU_DEC_BUS_ERROR_BIT		BIT(13)
+#define VPU_DEC_BUFFER_EMPTY_BIT	BIT(14)
+#define VPU_DEC_ASO_ERROR_BIT		BIT(15)
+#define VPU_DEC_STREAM_ERROR_BIT	BIT(16)
+#define VPU_DEC_SLICE_DONE_BIT		BIT(17)
+#define VPU_DEC_TIMEOUT_BIT		BIT(18)
+#define VPU_DEC_ERR_MASK		(VPU_DEC_BUS_ERROR_BIT \
+					|VPU_DEC_BUFFER_EMPTY_BIT \
+					|VPU_DEC_STREAM_ERROR_BIT \
+					|VPU_DEC_TIMEOUT_BIT)
+
+#define VPU_PP_INTERRUPT_REGISTER	60
+#define VPU_PP_PIPELINE_MODE_BIT	BIT(1)
+#define VPU_PP_INTERRUPT_BIT		BIT(8)
+#define VPU_PP_READY_BIT		BIT(12)
+#define VPU_PP_BUS_ERROR_BIT		BIT(13)
+#define VPU_PP_ERR_MASK			VPU_PP_BUS_ERROR_BIT
+
+#define VPU_ENC_INTERRUPT_REGISTER	1
+#define VPU_ENC_INTERRUPT_BIT		BIT(0)
+#define VPU_ENC_READY_BIT		BIT(2)
+#define VPU_ENC_BUS_ERROR_BIT		BIT(3)
+#define VPU_ENC_BUFFER_FULL_BIT		BIT(5)
+#define VPU_ENC_TIMEOUT_BIT		BIT(6)
+#define VPU_ENC_ERR_MASK		(VPU_ENC_BUS_ERROR_BIT \
+					|VPU_ENC_BUFFER_FULL_BIT \
+					|VPU_ENC_TIMEOUT_BIT)
+
+static const enum FORMAT_TYPE vpu_dec_fmt_tbl[] = {
+	[0]  = FMT_H264D,
+	[1]  = FMT_MPEG4D,
+	[2]  = FMT_H263D,
+	[3]  = FMT_JPEGD,
+	[4]  = FMT_VC1D,
+	[5]  = FMT_MPEG2D,
+	[6]  = FMT_MPEG1D,
+	[7]  = FMT_VP6D,
+	[8]  = FMT_TYPE_BUTT,
+	[9]  = FMT_VP7D,
+	[10] = FMT_VP8D,
+	[11] = FMT_AVSD,
+	[12] = FMT_TYPE_BUTT,
+	[13] = FMT_TYPE_BUTT,
+	[14] = FMT_TYPE_BUTT,
+	[15] = FMT_TYPE_BUTT,
+};
+
+static enum FORMAT_TYPE vpu_dec_get_fmt(u32 *regs)
+{
+	u32 fmt_id = (regs[3] >> 28) & 0xf;
+	enum FORMAT_TYPE type = vpu_dec_fmt_tbl[fmt_id];
+	return type;
+}
+
+static enum FORMAT_TYPE vpu_pp_get_fmt(u32 *regs)
+{
+	return FMT_PP;
+}
+
+static const enum FORMAT_TYPE vpu_enc_fmt_tbl[] = {
+	[0]  = FMT_TYPE_BUTT,
+	[1]  = FMT_VP8E,
+	[2]  = FMT_JPEGE,
+	[3]  = FMT_H264E,
+};
+
+static enum FORMAT_TYPE vpu_enc_get_fmt(u32 *regs)
+{
+	u32 fmt_id = (regs[VPU_REG_EN_ENC] >> 1) & 0x3;
+	enum FORMAT_TYPE type = vpu_enc_fmt_tbl[fmt_id];
+	return type;
+}
+
+static struct vpu_task_info task_vpu[TASK_TYPE_BUTT] = {
+	{
+		.name = "vpu_enc",
+		.reg_rlc = 11,
+		.reg_en = VPU_REG_EN_ENC,
+		.reg_irq = VPU_ENC_INTERRUPT_REGISTER,
+		.reg_len = -1,
+		.reg_dir_mv = -1,
+		.reg_pps = -1,
+		.reg_pipe = -1,
+		.enable_mask = 0x6,
+		.gating_mask = 0,
+		.pipe_mask = 0,
+		.irq_mask = VPU_ENC_INTERRUPT_BIT,
+		.ready_mask = VPU_ENC_READY_BIT,
+		.error_mask = VPU_ENC_ERR_MASK,
+		.get_fmt = vpu_enc_get_fmt,
+	},
+	{
+		.name = "vpu_dec",
+		.reg_rlc = 12,
+		.reg_en = VPU_REG_EN_DEC,
+		.reg_irq = VPU_DEC_INTERRUPT_REGISTER,
+		.reg_len = 12,
+		.reg_dir_mv = 41,
+		.reg_pps = -1,
+		.reg_pipe = VPU_PP_INTERRUPT_REGISTER,
+		.enable_mask = 0,
+		.gating_mask = 0,
+		.pipe_mask = VPU_PP_PIPELINE_MODE_BIT,
+		.irq_mask = VPU_DEC_INTERRUPT_BIT,
+		.ready_mask = VPU_DEC_READY_BIT,
+		.error_mask = VPU_DEC_ERR_MASK,
+		.get_fmt = vpu_dec_get_fmt,
+	},
+	{
+		.name = "vpu_pp",
+		.reg_en = VPU_REG_EN_PP,
+		.reg_irq = VPU_PP_INTERRUPT_REGISTER,
+		.reg_len = -1,
+		.reg_dir_mv = -1,
+		.reg_pps = -1,
+		.reg_pipe = VPU_PP_INTERRUPT_REGISTER,
+		.enable_mask = 0,
+		.gating_mask = 0,
+		.pipe_mask = VPU_PP_PIPELINE_MODE_BIT,
+		.irq_mask = VPU_PP_INTERRUPT_BIT,
+		.ready_mask = VPU_PP_READY_BIT,
+		.error_mask = VPU_PP_ERR_MASK,
+		.get_fmt = vpu_pp_get_fmt,
+	},
+	{
+		.name = "vpu_dec_pp",
+		.reg_rlc = 12,
+		.reg_en = VPU_REG_EN_DEC,
+		.reg_irq = VPU_DEC_INTERRUPT_REGISTER,
+		.reg_len = 12,
+		.reg_dir_mv = 41,
+		.reg_pps = -1,
+		.reg_pipe = VPU_PP_INTERRUPT_REGISTER,
+		.enable_mask = 0,
+		.gating_mask = 0,
+		.pipe_mask = VPU_PP_PIPELINE_MODE_BIT,
+		.irq_mask = VPU_DEC_INTERRUPT_BIT,
+		.ready_mask = VPU_DEC_READY_BIT,
+		.error_mask = VPU_DEC_ERR_MASK,
+		.get_fmt = vpu_dec_get_fmt,
+	},
+};
+
+static struct vpu_hw_info hw_vpu_8270 = {
+	.hw_id		= VPU_ID_8270,
+
+	.enc_offset	= 0x0,
+	.enc_reg_num	= REG_NUM_ENC_8270,
+	.enc_io_size	= REG_NUM_ENC_8270 * 4,
+
+	.dec_offset	= REG_SIZE_ENC_8270,
+	.dec_reg_num	= REG_NUM_9190_DEC_PP,
+	.dec_io_size	= REG_NUM_9190_DEC_PP * 4,
+
+	.base_dec	= 0,
+	.base_pp	= VPU_PP_INTERRUPT_REGISTER,
+	.base_dec_pp	= 0,
+	.end_dec	= REG_NUM_9190_DEC,
+	.end_pp		= REG_NUM_9190_DEC_PP,
+	.end_dec_pp	= REG_NUM_9190_DEC_PP,
+};
+
+static struct vpu_hw_info hw_vpu_4831 = {
+	.hw_id		= VPU_ID_4831,
+
+	.enc_offset	= 0x0,
+	.enc_reg_num	= REG_NUM_ENC_4831,
+	.enc_io_size	= REG_NUM_ENC_4831 * 4,
+
+	.dec_offset	= REG_SIZE_ENC_4831,
+	.dec_reg_num	= REG_NUM_9190_DEC_PP,
+	.dec_io_size	= REG_NUM_9190_DEC_PP * 4,
+
+	.base_dec	= 0,
+	.base_pp	= VPU_PP_INTERRUPT_REGISTER,
+	.base_dec_pp	= 0,
+	.end_dec	= REG_NUM_9190_DEC,
+	.end_pp		= REG_NUM_9190_DEC_PP,
+	.end_dec_pp	= REG_NUM_9190_DEC_PP,
+};
+
+static struct vpu_hw_info hw_vpu_9190 = {
+	.hw_id		= VPU_DEC_ID_9190,
+
+	.enc_offset	= 0x0,
+	.enc_reg_num	= 0,
+	.enc_io_size	= 0,
+
+	.dec_offset	= 0,
+	.dec_reg_num	= REG_NUM_9190_DEC_PP,
+	.dec_io_size	= REG_NUM_9190_DEC_PP * 4,
+
+	.base_dec	= 0,
+	.base_pp	= VPU_PP_INTERRUPT_REGISTER,
+	.base_dec_pp	= 0,
+	.end_dec	= REG_NUM_9190_DEC,
+	.end_pp		= REG_NUM_9190_DEC_PP,
+	.end_dec_pp	= REG_NUM_9190_DEC_PP,
+};
+
+/*
+ * file handle translate information
+ */
+DEF_FMT_TRANS_TBL(vpu_jpegd,
+		  12, 13, 14, 40, 66, 67
+);
+
+DEF_FMT_TRANS_TBL(vpu_h264d,
+		  12, 13, 14, 15, 16, 17, 18, 19,
+		  20, 21, 22, 23, 24, 25, 26, 27,
+		  28, 29, 40, 41
+);
+
+DEF_FMT_TRANS_TBL(vpu_vp6d,
+		  12, 13, 14, 18, 27, 40
+);
+
+DEF_FMT_TRANS_TBL(vpu_vp8d,
+		  10, 12, 13, 14, 18, 19, 22, 23,
+		  24, 25, 26, 27, 28, 29, 40
+);
+
+DEF_FMT_TRANS_TBL(vpu_vc1d,
+		  12, 13, 14, 15, 16, 17, 27, 41
+);
+
+DEF_FMT_TRANS_TBL(vpu_avsd,
+		  12, 13, 14, 15, 16, 17, 40, 41, 45
+);
+
+DEF_FMT_TRANS_TBL(vpu_defaultd,
+		  12, 13, 14, 15, 16, 17, 40, 41
+);
+
+DEF_FMT_TRANS_TBL(vpu_default_pp,
+		  63, 64, 65, 66, 67, 73, 74
+);
+
+DEF_FMT_TRANS_TBL(vpu_vp8e,
+		  5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17, 26, 51, 52, 58, 59
+);
+
+DEF_FMT_TRANS_TBL(vpu_defaulte,
+		  5, 6, 7, 8, 9, 10, 11, 12, 13, 51
+);
+
+static const struct vpu_trans_info trans_vpu[FMT_TYPE_BUTT] = {
+	SETUP_FMT_TBL(FMT_JPEGD, vpu_jpegd),
+	SETUP_FMT_TBL(FMT_H263D, vpu_defaultd),
+	SETUP_FMT_TBL(FMT_H264D, vpu_h264d),
+	EMPTY_FMT_TBL(FMT_H265D),
+
+	SETUP_FMT_TBL(FMT_MPEG1D, vpu_defaultd),
+	SETUP_FMT_TBL(FMT_MPEG2D, vpu_defaultd),
+	SETUP_FMT_TBL(FMT_MPEG4D, vpu_defaultd),
+
+	SETUP_FMT_TBL(FMT_VP6D, vpu_vp6d),
+	SETUP_FMT_TBL(FMT_VP7D, vpu_defaultd),
+	SETUP_FMT_TBL(FMT_VP8D, vpu_vp8d),
+	EMPTY_FMT_TBL(FMT_VP9D),
+
+	SETUP_FMT_TBL(FMT_VC1D, vpu_vc1d),
+	SETUP_FMT_TBL(FMT_AVSD, vpu_avsd),
+
+	SETUP_FMT_TBL(FMT_PP, vpu_default_pp),
+
+	SETUP_FMT_TBL(FMT_JPEGE, vpu_defaulte),
+	SETUP_FMT_TBL(FMT_H264E, vpu_defaulte),
+	SETUP_FMT_TBL(FMT_VP8E, vpu_vp8e),
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_iommu_drm.c b/drivers/video/rockchip/vcodec/vcodec_iommu_drm.c
--- a/drivers/video/rockchip/vcodec/vcodec_iommu_drm.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_iommu_drm.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,982 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/dma-iommu.h>
+#include <linux/dma-buf.h>
+#include <linux/dma-mapping.h>
+#include <linux/fence.h>
+#include <linux/iova.h>
+#include <linux/kref.h>
+#include <linux/ktime.h>
+#include <linux/memblock.h>
+
+#include "vcodec_iommu_ops.h"
+
+/*
+ * there two type drm buffer, one is through import interface and
+ * the other is through alloc. there are some differents between
+ * import and alloc buffer when free them. this flag is used to
+ * inform driver which type of this buffer.
+ */
+#define VCODEC_DRM_BUFFER_ALLOC	0x00000001
+
+struct vcodec_drm_buffer {
+	struct list_head list;
+	struct dma_buf *dma_buf;
+	union {
+		dma_addr_t iova;
+		unsigned long phys;
+	};
+	/* this is used for page fault */
+	unsigned long iova_out;
+	void *cpu_addr;
+	unsigned long size;
+	int index;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct sg_table *copy_sgt;
+	struct page **pages;
+	struct kref ref;
+	struct vcodec_iommu_session_info *session_info;
+	ktime_t last_used;
+	int flags;
+};
+
+struct vcodec_iommu_drm_info {
+	struct iommu_domain *domain;
+	bool attached;
+};
+
+static struct vcodec_drm_buffer *
+vcodec_drm_get_buffer_no_lock(struct vcodec_iommu_session_info *session_info,
+			      int idx)
+{
+	struct vcodec_drm_buffer *drm_buffer = NULL, *n;
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		if (drm_buffer->index == idx) {
+			drm_buffer->last_used = ktime_get();
+			return drm_buffer;
+		}
+	}
+
+	return NULL;
+}
+
+static struct vcodec_drm_buffer *
+vcodec_drm_get_buffer_fd_no_lock(struct vcodec_iommu_session_info *session_info,
+				 int fd)
+{
+	struct vcodec_drm_buffer *drm_buffer = NULL, *n;
+	struct dma_buf *dma_buf = NULL;
+
+	dma_buf = dma_buf_get(fd);
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		if (drm_buffer->dma_buf == dma_buf) {
+			drm_buffer->last_used = ktime_get();
+			dma_buf_put(dma_buf);
+			return drm_buffer;
+		}
+	}
+
+	dma_buf_put(dma_buf);
+
+	return NULL;
+}
+
+static void *vcodec_drm_sgt_map_kernel(struct vcodec_drm_buffer *drm_buffer)
+{
+	struct vcodec_iommu_session_info *session_info =
+						      drm_buffer->session_info;
+	struct device *dev = session_info->dev;
+	struct scatterlist *sgl, *sg;
+	int nr_pages = PAGE_ALIGN(drm_buffer->size) >> PAGE_SHIFT;
+	int i = 0, j = 0, k = 0;
+	struct page *page;
+
+	drm_buffer->pages = kmalloc_array(nr_pages, sizeof(*drm_buffer->pages),
+					  GFP_KERNEL);
+	if (!(drm_buffer->pages)) {
+		dev_err(dev, "drm map alloc %d pages failed!\n", nr_pages);
+
+		return NULL;
+	}
+
+	sgl = drm_buffer->copy_sgt->sgl;
+
+	for_each_sg(sgl, sg, drm_buffer->copy_sgt->nents, i) {
+		page = sg_page(sg);
+		for (j = 0; j < sg->length / PAGE_SIZE; j++)
+			drm_buffer->pages[k++] = page++;
+	}
+
+	return vmap(drm_buffer->pages, nr_pages, VM_MAP,
+		    pgprot_noncached(PAGE_KERNEL));
+}
+
+static void vcodec_drm_sgt_unmap_kernel(struct vcodec_drm_buffer *drm_buffer)
+{
+	vunmap(drm_buffer->cpu_addr);
+	kfree(drm_buffer->pages);
+}
+
+static int vcodec_finalise_sg(struct scatterlist *sg,
+			      int nents,
+			      dma_addr_t dma_addr)
+{
+	struct scatterlist *s, *cur = sg;
+	unsigned long seg_mask = DMA_BIT_MASK(32);
+	unsigned int cur_len = 0, max_len = DMA_BIT_MASK(32);
+	int i, count = 0;
+
+	for_each_sg(sg, s, nents, i) {
+		/* Restore this segment's original unaligned fields first */
+		unsigned int s_iova_off = sg_dma_address(s);
+		unsigned int s_length = sg_dma_len(s);
+		unsigned int s_iova_len = s->length;
+
+		s->offset += s_iova_off;
+		s->length = s_length;
+		sg_dma_address(s) = DMA_ERROR_CODE;
+		sg_dma_len(s) = 0;
+
+		/*
+		 * Now fill in the real DMA data. If...
+		 * - there is a valid output segment to append to
+		 * - and this segment starts on an IOVA page boundary
+		 * - but doesn't fall at a segment boundary
+		 * - and wouldn't make the resulting output segment too long
+		 */
+		if (cur_len && !s_iova_off && (dma_addr & seg_mask) &&
+		    (cur_len + s_length <= max_len)) {
+			/* ...then concatenate it with the previous one */
+			cur_len += s_length;
+		} else {
+			/* Otherwise start the next output segment */
+			if (i > 0)
+				cur = sg_next(cur);
+			cur_len = s_length;
+			count++;
+
+			sg_dma_address(cur) = dma_addr + s_iova_off;
+		}
+
+		sg_dma_len(cur) = cur_len;
+		dma_addr += s_iova_len;
+
+		if (s_length + s_iova_off < s_iova_len)
+			cur_len = 0;
+	}
+	return count;
+}
+
+static void vcodec_invalidate_sg(struct scatterlist *sg, int nents)
+{
+	struct scatterlist *s;
+	int i;
+
+	for_each_sg(sg, s, nents, i) {
+		if (sg_dma_address(s) != DMA_ERROR_CODE)
+			s->offset += sg_dma_address(s);
+		if (sg_dma_len(s))
+			s->length = sg_dma_len(s);
+		sg_dma_address(s) = DMA_ERROR_CODE;
+		sg_dma_len(s) = 0;
+	}
+}
+
+static void vcodec_dma_unmap_sg(struct iommu_domain *domain,
+				dma_addr_t dma_addr)
+{
+	struct iova_domain *iovad = domain->iova_cookie;
+	unsigned long shift = iova_shift(iovad);
+	unsigned long pfn = dma_addr >> shift;
+	struct iova *iova = find_iova(iovad, pfn);
+	size_t size;
+
+	if (WARN_ON(!iova))
+		return;
+
+	size = iova_size(iova) << shift;
+	size -= iommu_unmap(domain, pfn << shift, size);
+	/* ...and if we can't, then something is horribly, horribly wrong */
+	WARN_ON(size > 0);
+	__free_iova(iovad, iova);
+}
+
+static void vcodec_drm_clear_map(struct kref *ref)
+{
+	struct vcodec_drm_buffer *drm_buffer =
+		container_of(ref, struct vcodec_drm_buffer, ref);
+	struct vcodec_iommu_session_info *session_info =
+		drm_buffer->session_info;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+					      struct sg_table *table;
+					      struct scatterlist *sg;
+					      struct page *page;
+					      int i;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+	drm_info = session_info->iommu_info->private;
+
+	if (drm_buffer->cpu_addr) {
+		vcodec_drm_sgt_unmap_kernel(drm_buffer);
+		drm_buffer->cpu_addr = NULL;
+	}
+
+	vcodec_dma_unmap_sg(drm_info->domain, drm_buffer->iova);
+	if (drm_buffer->flags & VCODEC_DRM_BUFFER_ALLOC) {
+		table = drm_buffer->copy_sgt;
+		for_each_sg(table->sgl, sg, table->nents, i) {
+			page = sg_page(sg);
+			__free_pages(page, compound_order(page));
+		}
+	}
+	sg_free_table(drm_buffer->copy_sgt);
+	kfree(drm_buffer->copy_sgt);
+
+	if (drm_buffer->attach) {
+		dma_buf_unmap_attachment(drm_buffer->attach, drm_buffer->sgt,
+					 DMA_BIDIRECTIONAL);
+		dma_buf_detach(drm_buffer->dma_buf, drm_buffer->attach);
+		dma_buf_put(drm_buffer->dma_buf);
+		drm_buffer->attach = NULL;
+	}
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static int
+vcodec_drm_unmap_iommu_with_iova(struct vcodec_iommu_session_info *session_info,
+				 int idx)
+{
+	struct device *dev = session_info->dev;
+	struct vcodec_drm_buffer *drm_buffer;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+	struct iommu_domain *domain = drm_info->domain;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vcodec_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return -EINVAL;
+	}
+
+	iommu_unmap(domain, drm_buffer->iova_out, PAGE_SIZE);
+
+	return 0;
+}
+
+static int
+vcodec_drm_map_iommu_with_iova(struct vcodec_iommu_session_info *session_info,
+			       int idx,
+			       unsigned long iova,
+			       unsigned long size)
+{
+	struct device *dev = session_info->dev;
+	struct vcodec_drm_buffer *drm_buffer;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vcodec_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return -EINVAL;
+	}
+
+	drm_buffer->iova_out = iova;
+
+	return iommu_map(drm_info->domain,
+			 iova,
+			 sg_phys(drm_buffer->copy_sgt->sgl),
+			 size, IOMMU_READ | IOMMU_WRITE);
+}
+
+static void*
+vcodec_drm_map_kernel(struct vcodec_iommu_session_info *session_info, int idx)
+{
+	struct device *dev = session_info->dev;
+	struct vcodec_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vcodec_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return NULL;
+	}
+
+	if (!drm_buffer->cpu_addr)
+		drm_buffer->cpu_addr =
+				       vcodec_drm_sgt_map_kernel(drm_buffer);
+
+	kref_get(&drm_buffer->ref);
+
+	return drm_buffer->cpu_addr;
+}
+
+static int
+vcodec_drm_unmap_kernel(struct vcodec_iommu_session_info *session_info, int idx)
+{
+	struct device *dev = session_info->dev;
+	struct vcodec_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vcodec_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+
+		return -EINVAL;
+	}
+
+	if (drm_buffer->cpu_addr) {
+		vcodec_drm_sgt_unmap_kernel(drm_buffer);
+		drm_buffer->cpu_addr = NULL;
+	}
+
+	kref_put(&drm_buffer->ref, vcodec_drm_clear_map);
+	return 0;
+}
+
+static void
+vcodec_drm_remove_extra_buffer_no_lock(struct vcodec_iommu_session_info
+				       *session_info)
+{
+	struct vcodec_drm_buffer *oldest_buffer = NULL, *loop_buffer = NULL;
+	struct vcodec_drm_buffer *n;
+	ktime_t oldest_time = ktime_set(0, 0);
+
+	if (session_info->buffer_nums > BUFFER_LIST_MAX_NUMS) {
+		list_for_each_entry_safe(loop_buffer, n,
+					 &session_info->buffer_list, list) {
+			if (loop_buffer->flags & VCODEC_DRM_BUFFER_ALLOC)
+				continue;
+
+			if (ktime_to_ns(oldest_time) == 0 ||
+			    ktime_after(oldest_time,
+					loop_buffer->last_used)) {
+				oldest_time = loop_buffer->last_used;
+				oldest_buffer = loop_buffer;
+			}
+		}
+		kref_put(&oldest_buffer->ref, vcodec_drm_clear_map);
+		dma_buf_put(oldest_buffer->dma_buf);
+		list_del_init(&oldest_buffer->list);
+		kfree(oldest_buffer);
+		session_info->buffer_nums--;
+	}
+}
+
+static void vcodec_drm_detach(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = iommu_info->dev;
+	struct iommu_domain *domain = drm_info->domain;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (!drm_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return;
+	}
+
+	iommu_detach_device(domain, dev);
+	drm_info->attached = false;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static int vcodec_drm_attach_unlock(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = iommu_info->dev;
+	struct iommu_domain *domain = drm_info->domain;
+	int ret = 0;
+
+	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
+	ret = iommu_attach_device(domain, dev);
+	if (ret) {
+		dev_err(dev, "Failed to attach iommu device\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int vcodec_drm_attach(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+	int ret;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (drm_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return 0;
+	}
+
+	ret = vcodec_drm_attach_unlock(iommu_info);
+	if (ret) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return ret;
+	}
+
+	drm_info->attached = true;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return ret;
+}
+
+static dma_addr_t vcodec_dma_map_sg(struct iommu_domain *domain,
+				    struct scatterlist *sg,
+				    int nents, int prot)
+{
+	struct iova_domain *iovad = domain->iova_cookie;
+	struct iova *iova;
+	struct scatterlist *s, *prev = NULL;
+	dma_addr_t dma_addr;
+	size_t iova_len = 0;
+	unsigned long mask = DMA_BIT_MASK(32);
+	unsigned long shift = iova_shift(iovad);
+	int i;
+
+	/*
+	 * Work out how much IOVA space we need, and align the segments to
+	 * IOVA granules for the IOMMU driver to handle. With some clever
+	 * trickery we can modify the list in-place, but reversibly, by
+	 * stashing the unaligned parts in the as-yet-unused DMA fields.
+	 */
+	for_each_sg(sg, s, nents, i) {
+		size_t s_iova_off = iova_offset(iovad, s->offset);
+		size_t s_length = s->length;
+		size_t pad_len = (mask - iova_len + 1) & mask;
+
+		sg_dma_address(s) = s_iova_off;
+		sg_dma_len(s) = s_length;
+		s->offset -= s_iova_off;
+		s_length = iova_align(iovad, s_length + s_iova_off);
+		s->length = s_length;
+
+		/*
+		 * Due to the alignment of our single IOVA allocation, we can
+		 * depend on these assumptions about the segment boundary mask:
+		 * - If mask size >= IOVA size, then the IOVA range cannot
+		 *   possibly fall across a boundary, so we don't care.
+		 * - If mask size < IOVA size, then the IOVA range must start
+		 *   exactly on a boundary, therefore we can lay things out
+		 *   based purely on segment lengths without needing to know
+		 *   the actual addresses beforehand.
+		 * - The mask must be a power of 2, so pad_len == 0 if
+		 *   iova_len == 0, thus we cannot dereference prev the first
+		 *   time through here (i.e. before it has a meaningful value).
+		 */
+		if (pad_len && pad_len < s_length - 1) {
+			prev->length += pad_len;
+			iova_len += pad_len;
+		}
+
+		iova_len += s_length;
+		prev = s;
+	}
+
+	iova = alloc_iova(iovad, iova_align(iovad, iova_len) >> shift,
+			  mask >> shift, true);
+	if (!iova)
+		goto out_restore_sg;
+
+	/*
+	 * We'll leave any physical concatenation to the IOMMU driver's
+	 * implementation - it knows better than we do.
+	 */
+	dma_addr = iova_dma_addr(iovad, iova);
+	if (iommu_map_sg(domain, dma_addr, sg, nents, prot) < iova_len)
+		goto out_free_iova;
+
+	return vcodec_finalise_sg(sg, nents, dma_addr);
+
+out_free_iova:
+	__free_iova(iovad, iova);
+out_restore_sg:
+	vcodec_invalidate_sg(sg, nents);
+	return 0;
+}
+
+static void vcdoec_drm_dump_info(struct vcodec_iommu_session_info *session_info)
+{
+	struct vcodec_drm_buffer *drm_buffer = NULL, *n;
+
+	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_OPS_DUMP,
+			"still there are below buffers stored in list\n");
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_OPS_DUMP,
+				"index %d drm_buffer dma_buf %p\n",
+				drm_buffer->index,
+				drm_buffer->dma_buf);
+	}
+}
+
+static int vcodec_drm_free(struct vcodec_iommu_session_info *session_info,
+			   int idx)
+{
+	struct device *dev = session_info->dev;
+	/* please double-check all maps have been release */
+	struct vcodec_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vcodec_drm_get_buffer_no_lock(session_info, idx);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		mutex_unlock(&session_info->list_mutex);
+
+		return -EINVAL;
+	}
+
+	if (atomic_read(&drm_buffer->ref.refcount) == 0) {
+		dma_buf_put(drm_buffer->dma_buf);
+		list_del_init(&drm_buffer->list);
+		kfree(drm_buffer);
+		session_info->buffer_nums--;
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+				"buffer nums %d\n", session_info->buffer_nums);
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	return 0;
+}
+
+static int
+vcodec_drm_unmap_iommu(struct vcodec_iommu_session_info *session_info,
+		       int idx)
+{
+	struct device *dev = session_info->dev;
+	struct vcodec_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vcodec_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return -EINVAL;
+	}
+
+	kref_put(&drm_buffer->ref, vcodec_drm_clear_map);
+
+	return 0;
+}
+
+static int vcodec_drm_map_iommu(struct vcodec_iommu_session_info *session_info,
+				int idx,
+				dma_addr_t *iova,
+				unsigned long *size)
+{
+	struct device *dev = session_info->dev;
+	struct vcodec_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vcodec_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return -EINVAL;
+	}
+
+	kref_get(&drm_buffer->ref);
+	if (iova)
+		*iova = drm_buffer->iova;
+	if (size)
+		*size = drm_buffer->size;
+	return 0;
+}
+
+static int
+vcodec_drm_free_fd(struct vcodec_iommu_session_info *session_info, int fd)
+{
+	struct device *dev = session_info->dev;
+	/* please double-check all maps have been release */
+	struct vcodec_drm_buffer *drm_buffer = NULL;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vcodec_drm_get_buffer_fd_no_lock(session_info, fd);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", fd);
+		mutex_unlock(&session_info->list_mutex);
+
+		return -EINVAL;
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	vcodec_drm_unmap_iommu(session_info, drm_buffer->index);
+
+	mutex_lock(&session_info->list_mutex);
+	if (atomic_read(&drm_buffer->ref.refcount) == 0) {
+		dma_buf_put(drm_buffer->dma_buf);
+		list_del_init(&drm_buffer->list);
+		kfree(drm_buffer);
+		session_info->buffer_nums--;
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+				"buffer nums %d\n", session_info->buffer_nums);
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	return 0;
+}
+
+static void
+vcodec_drm_clear_session(struct vcodec_iommu_session_info *session_info)
+{
+	struct vcodec_drm_buffer *drm_buffer = NULL, *n;
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		kref_put(&drm_buffer->ref, vcodec_drm_clear_map);
+		vcodec_drm_free(session_info, drm_buffer->index);
+	}
+}
+
+static int vcodec_drm_import(struct vcodec_iommu_session_info *session_info,
+			     int fd)
+{
+	struct vcodec_drm_buffer *drm_buffer = NULL, *n;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = session_info->dev;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct dma_buf *dma_buf;
+	struct scatterlist *sg, *s;
+	int i;
+	int ret = 0;
+
+	dma_buf = dma_buf_get(fd);
+	if (IS_ERR(dma_buf)) {
+		ret = PTR_ERR(dma_buf);
+		return ret;
+	}
+
+	list_for_each_entry_safe(drm_buffer, n,
+				 &session_info->buffer_list, list) {
+		if (drm_buffer->dma_buf == dma_buf) {
+			dma_buf_put(dma_buf);
+			drm_buffer->last_used = ktime_get();
+			return drm_buffer->index;
+		}
+	}
+
+	drm_buffer = kzalloc(sizeof(*drm_buffer), GFP_KERNEL);
+	if (!drm_buffer) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	drm_buffer->dma_buf = dma_buf;
+	drm_buffer->session_info = session_info;
+	drm_buffer->last_used = ktime_get();
+
+	kref_init(&drm_buffer->ref);
+
+	mutex_lock(&iommu_info->iommu_mutex);
+	drm_info = session_info->iommu_info->private;
+
+	attach = dma_buf_attach(drm_buffer->dma_buf, dev);
+	if (IS_ERR(attach)) {
+		ret = PTR_ERR(attach);
+		goto fail_out;
+	}
+
+	get_dma_buf(drm_buffer->dma_buf);
+
+	sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+	if (IS_ERR(sgt)) {
+		ret = PTR_ERR(sgt);
+		goto fail_detach;
+	}
+
+	/*
+	 * Since we call dma_buf_map_attachment outside attach/detach, this
+	 * will cause incorrectly map. we have to re-build map table native
+	 * and for avoiding destroy their origin map table, we need use a
+	 * copy one sg_table.
+	 */
+	drm_buffer->copy_sgt = kmalloc(sizeof(*drm_buffer->copy_sgt),
+				       GFP_KERNEL);
+	if (!drm_buffer->copy_sgt) {
+		ret = -ENOMEM;
+		goto fail_detach;
+	}
+
+	ret = sg_alloc_table(drm_buffer->copy_sgt, sgt->nents, GFP_KERNEL);
+	s = drm_buffer->copy_sgt->sgl;
+	for_each_sg(sgt->sgl, sg, sgt->nents, i) {
+		sg_set_page(s, sg_page(sg),
+			    PAGE_SIZE << compound_order(sg_page(sg)), 0);
+		sg_dma_address(s) = page_to_phys(sg_page(sg));
+		s->offset = sg->offset;
+		s->length = sg->length;
+		s = sg_next(s);
+	}
+
+	ret = vcodec_dma_map_sg(drm_info->domain, drm_buffer->copy_sgt->sgl,
+				drm_buffer->copy_sgt->nents,
+				IOMMU_READ | IOMMU_WRITE);
+	if (!ret) {
+		ret = -ENOMEM;
+		goto fail_alloc;
+	}
+	drm_buffer->iova = sg_dma_address(drm_buffer->copy_sgt->sgl);
+	drm_buffer->size = drm_buffer->dma_buf->size;
+
+	drm_buffer->attach = attach;
+	drm_buffer->sgt = sgt;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	INIT_LIST_HEAD(&drm_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	session_info->buffer_nums++;
+	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+			"buffer nums %d\n", session_info->buffer_nums);
+	vcodec_drm_remove_extra_buffer_no_lock(session_info);
+	drm_buffer->index = session_info->max_idx;
+	list_add_tail(&drm_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return drm_buffer->index;
+
+fail_alloc:
+	sg_free_table(drm_buffer->copy_sgt);
+	kfree(drm_buffer->copy_sgt);
+	dma_buf_unmap_attachment(attach, sgt,
+				 DMA_BIDIRECTIONAL);
+fail_detach:
+	dma_buf_detach(drm_buffer->dma_buf, attach);
+	dma_buf_put(drm_buffer->dma_buf);
+fail_out:
+	kfree(drm_buffer);
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return ret;
+}
+
+static int vcodec_drm_alloc(struct vcodec_iommu_session_info *session_info,
+			    unsigned long size,
+			    unsigned long align)
+{
+	struct sg_table *table;
+	struct scatterlist *sg;
+	struct list_head pages;
+	struct page *page, *tmp_page;
+	long size_remaining = PAGE_ALIGN(size);
+	struct vcodec_drm_buffer *drm_buffer;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+	int i;
+
+	if (align > PAGE_SIZE)
+		return -EINVAL;
+
+	if (size / PAGE_SIZE > totalram_pages / 2)
+		return -ENOMEM;
+
+	drm_buffer = kzalloc(sizeof(*drm_buffer), GFP_KERNEL);
+	if (!drm_buffer)
+		return -ENOMEM;
+
+	drm_buffer->session_info = session_info;
+	drm_buffer->last_used = ktime_set(0, 0);
+
+	kref_init(&drm_buffer->ref);
+
+	INIT_LIST_HEAD(&pages);
+
+	i = 0;
+	while (size_remaining > 0) {
+		gfp_t gfp_flags = (GFP_HIGHUSER | __GFP_ZERO | __GFP_NOWARN |
+				   __GFP_NORETRY) & ~__GFP_DIRECT_RECLAIM;
+		page = alloc_pages(gfp_flags | __GFP_COMP, 1);
+		if (!page)
+			goto free_pages;
+
+		size_remaining -= PAGE_SIZE;
+		list_add_tail(&page->lru, &pages);
+		i++;
+	}
+
+	table = kmalloc(sizeof(*table), GFP_KERNEL);
+	if (!table)
+		goto free_pages;
+
+	if (sg_alloc_table(table, i, GFP_KERNEL))
+		goto free_table;
+
+	sg = table->sgl;
+	list_for_each_entry_safe(page, tmp_page, &pages, lru) {
+		sg_set_page(sg, page, PAGE_SIZE, 0);
+		sg = sg_next(sg);
+		list_del(&page->lru);
+	}
+
+	mutex_lock(&iommu_info->iommu_mutex);
+	drm_info = session_info->iommu_info->private;
+	drm_buffer->copy_sgt = table;
+
+	vcodec_dma_map_sg(drm_info->domain, drm_buffer->copy_sgt->sgl,
+			  drm_buffer->copy_sgt->nents,
+			  IOMMU_READ | IOMMU_WRITE);
+	drm_buffer->iova = sg_dma_address(drm_buffer->copy_sgt->sgl);
+	drm_buffer->size = size;
+	drm_buffer->flags = VCODEC_DRM_BUFFER_ALLOC;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	INIT_LIST_HEAD(&drm_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	session_info->buffer_nums++;
+	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+			"buffer nums %d\n", session_info->buffer_nums);
+	vcodec_drm_remove_extra_buffer_no_lock(session_info);
+	drm_buffer->index = session_info->max_idx;
+	list_add_tail(&drm_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return drm_buffer->index;
+
+free_table:
+	kfree(table);
+free_pages:
+	list_for_each_entry_safe(page, tmp_page, &pages, lru)
+		__free_pages(page, 8);
+
+	kfree(drm_buffer);
+
+	return -ENOMEM;
+}
+
+static int vcodec_drm_create(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_drm_info *drm_info;
+	struct iommu_group *group;
+	int ret;
+
+	iommu_info->private = kzalloc(sizeof(*drm_info),
+				      GFP_KERNEL);
+	drm_info = iommu_info->private;
+	if (!drm_info)
+		return -ENOMEM;
+
+	drm_info->domain = iommu_domain_alloc(&platform_bus_type);
+	drm_info->attached = false;
+	if (!drm_info->domain)
+		return -ENOMEM;
+
+	ret = iommu_get_dma_cookie(drm_info->domain);
+	if (ret)
+		goto err_free_domain;
+
+	group = iommu_group_get(iommu_info->dev);
+	if (!group) {
+		group = iommu_group_alloc();
+		if (IS_ERR(group)) {
+			dev_err(iommu_info->dev,
+				"Failed to allocate IOMMU group\n");
+			goto err_put_cookie;
+		}
+		ret = iommu_group_add_device(group, iommu_info->dev);
+		if (ret) {
+			dev_err(iommu_info->dev,
+				"failed to add device to IOMMU group\n");
+			goto err_put_cookie;
+		}
+	}
+	iommu_dma_init_domain(drm_info->domain, 0x10000000, SZ_2G);
+	iommu_group_put(group);
+
+	return 0;
+
+err_put_cookie:
+	iommu_put_dma_cookie(drm_info->domain);
+err_free_domain:
+	iommu_domain_free(drm_info->domain);
+
+	return ret;
+}
+
+static int vcodec_drm_destroy(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_drm_info *drm_info = iommu_info->private;
+
+	iommu_put_dma_cookie(drm_info->domain);
+	iommu_domain_free(drm_info->domain);
+
+	kfree(drm_info);
+	iommu_info->private = NULL;
+
+	return 0;
+}
+
+static struct vcodec_iommu_ops drm_ops = {
+	.create = vcodec_drm_create,
+	.alloc = vcodec_drm_alloc,
+	.import = vcodec_drm_import,
+	.free = vcodec_drm_free,
+	.free_fd = vcodec_drm_free_fd,
+	.map_kernel = vcodec_drm_map_kernel,
+	.unmap_kernel = vcodec_drm_unmap_kernel,
+	.map_iommu = vcodec_drm_map_iommu,
+	.unmap_iommu = vcodec_drm_unmap_iommu,
+	.map_iommu_with_iova = vcodec_drm_map_iommu_with_iova,
+	.unmap_iommu_with_iova = vcodec_drm_unmap_iommu_with_iova,
+	.destroy = vcodec_drm_destroy,
+	.dump = vcdoec_drm_dump_info,
+	.attach = vcodec_drm_attach,
+	.detach = vcodec_drm_detach,
+	.clear = vcodec_drm_clear_session,
+};
+
+void vcodec_iommu_drm_set_ops(struct vcodec_iommu_info *iommu_info)
+{
+	if (!iommu_info)
+		return;
+	iommu_info->ops = &drm_ops;
+}
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_iommu_ion.c b/drivers/video/rockchip/vcodec/vcodec_iommu_ion.c
--- a/drivers/video/rockchip/vcodec/vcodec_iommu_ion.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_iommu_ion.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/fence.h>
+#include <linux/kref.h>
+#include <linux/memblock.h>
+#include <linux/module.h>
+#include <linux/rockchip_ion.h>
+#include <linux/rockchip-iovmm.h>
+#include <linux/slab.h>
+
+#include "vcodec_iommu_ops.h"
+
+struct vcodec_ion_buffer {
+	struct list_head list;
+	struct ion_handle *handle;
+	int index;
+};
+
+struct vcodec_iommu_ion_info {
+	struct ion_client *ion_client;
+	bool attached;
+};
+
+static struct vcodec_ion_buffer *
+vcodec_ion_get_buffer_no_lock(struct vcodec_iommu_session_info *session_info,
+			      int idx)
+{
+	struct vcodec_ion_buffer *ion_buffer = NULL, *n;
+
+	list_for_each_entry_safe(ion_buffer, n,
+				 &session_info->buffer_list, list) {
+		if (ion_buffer->index == idx)
+			return ion_buffer;
+	}
+
+	return NULL;
+}
+
+static void
+vcodec_ion_clear_session(struct vcodec_iommu_session_info *session_info)
+{
+	/* do nothing */
+}
+
+static int vcodec_ion_attach(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_ion_info *ion_info = iommu_info->private;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (ion_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return 0;
+	}
+
+	rockchip_iovmm_activate(iommu_info->dev);
+
+	ion_info->attached = true;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return 0;
+}
+
+static void vcodec_ion_detach(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_ion_info *ion_info = iommu_info->private;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (!ion_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return;
+	}
+
+	rockchip_iovmm_deactivate(iommu_info->dev);
+	ion_info->attached = false;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static int vcodec_ion_destroy(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_ion_info *ion_info = iommu_info->private;
+
+	vcodec_ion_detach(iommu_info);
+	kfree(ion_info);
+	iommu_info->private = NULL;
+
+	return 0;
+}
+
+static int
+vcodec_ion_free(struct vcodec_iommu_session_info *session_info, int idx)
+{
+	struct vcodec_ion_buffer *ion_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vcodec_ion_get_buffer_no_lock(session_info, idx);
+
+	if (!ion_buffer) {
+		mutex_unlock(&session_info->list_mutex);
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	list_del_init(&ion_buffer->list);
+	mutex_unlock(&session_info->list_mutex);
+	kfree(ion_buffer);
+
+	return 0;
+}
+
+static int
+vcodec_ion_unmap_iommu(struct vcodec_iommu_session_info *session_info, int idx)
+{
+	struct vcodec_ion_buffer *ion_buffer;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_ion_info *ion_info = iommu_info->private;
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vcodec_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	ion_free(ion_info->ion_client, ion_buffer->handle);
+
+	return 0;
+}
+
+static int
+vcodec_ion_map_iommu(struct vcodec_iommu_session_info *session_info, int idx,
+		     dma_addr_t *iova, unsigned long *size)
+{
+	struct vcodec_ion_buffer *ion_buffer;
+	struct device *dev = session_info->dev;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_ion_info *ion_info = iommu_info->private;
+	int ret = 0;
+
+	/* Force to flush iommu table */
+	rockchip_iovmm_invalidate_tlb(session_info->dev);
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vcodec_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	if (session_info->mmu_dev)
+		ret = ion_map_iommu(dev, ion_info->ion_client,
+				    ion_buffer->handle, (unsigned long *)iova,
+				    size);
+	else
+		ret = ion_phys(ion_info->ion_client, ion_buffer->handle,
+			       (ion_phys_addr_t *)iova, (size_t *)size);
+
+	return ret;
+}
+
+static int
+vcodec_ion_import(struct vcodec_iommu_session_info *session_info, int fd)
+{
+	struct vcodec_ion_buffer *ion_buffer = NULL;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_ion_info *ion_info = iommu_info->private;
+
+	ion_buffer = kzalloc(sizeof(*ion_buffer), GFP_KERNEL);
+	if (!ion_buffer)
+		return -ENOMEM;
+
+	ion_buffer->handle = ion_import_dma_buf(ion_info->ion_client, fd);
+
+	INIT_LIST_HEAD(&ion_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer->index = session_info->max_idx;
+	list_add_tail(&ion_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return ion_buffer->index;
+}
+
+static int
+vcodec_ion_unmap_kernel(struct vcodec_iommu_session_info *session_info,
+			int idx)
+{
+	struct vcodec_ion_buffer *ion_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vcodec_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void*
+vcodec_ion_map_kernel(struct vcodec_iommu_session_info *session_info, int idx)
+{
+	struct vcodec_ion_buffer *ion_buffer;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_ion_info *ion_info = iommu_info->private;
+
+	rockchip_iovmm_invalidate_tlb(session_info->dev);
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vcodec_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return NULL;
+	}
+
+	return ion_map_kernel(ion_info->ion_client, ion_buffer->handle);
+}
+
+static int vcodec_ion_alloc(struct vcodec_iommu_session_info *session_info,
+			    unsigned long size,
+			    unsigned long align)
+{
+	struct vcodec_ion_buffer *ion_buffer = NULL;
+	struct vcodec_iommu_info *iommu_info = session_info->iommu_info;
+	struct vcodec_iommu_ion_info *ion_info = iommu_info->private;
+	unsigned int heap_id_mask;
+
+	if (iommu_info->mmu_dev)
+		heap_id_mask = ION_HEAP_TYPE_SYSTEM;
+	else
+		heap_id_mask = ION_HEAP_TYPE_DMA;
+
+	ion_buffer = kzalloc(sizeof(*ion_buffer), GFP_KERNEL);
+	if (!ion_buffer)
+		return -ENOMEM;
+
+	ion_buffer->handle = ion_alloc(ion_info->ion_client, size,
+				       align, heap_id_mask, 0);
+
+	INIT_LIST_HEAD(&ion_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer->index = session_info->max_idx;
+	list_add_tail(&ion_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return ion_buffer->index;
+}
+
+static int vcodec_ion_create(struct vcodec_iommu_info *iommu_info)
+{
+	struct vcodec_iommu_ion_info *ion_info;
+
+	iommu_info->private = kmalloc(sizeof(*ion_info), GFP_KERNEL);
+
+	ion_info = iommu_info->private;
+	if (!ion_info)
+		return -ENOMEM;
+
+	ion_info->ion_client = rockchip_ion_client_create("vpu");
+	ion_info->attached = false;
+
+	vcodec_ion_attach(iommu_info);
+
+	return IS_ERR(ion_info->ion_client) ? -1 : 0;
+}
+
+static struct vcodec_iommu_ops ion_ops = {
+	.create = vcodec_ion_create,
+	.destroy = vcodec_ion_destroy,
+	.alloc = vcodec_ion_alloc,
+	.import = vcodec_ion_import,
+	.free = vcodec_ion_free,
+	.free_fd = NULL,
+	.map_kernel = vcodec_ion_map_kernel,
+	.unmap_kernel = vcodec_ion_unmap_kernel,
+	.map_iommu = vcodec_ion_map_iommu,
+	.unmap_iommu = vcodec_ion_unmap_iommu,
+	.map_iommu_with_iova = NULL,
+	.unmap_iommu_with_iova = NULL,
+	.dump = NULL,
+	.attach = vcodec_ion_attach,
+	.detach = vcodec_ion_detach,
+	.clear = vcodec_ion_clear_session,
+};
+
+/*
+ * we do not manage the ref number ourselves,
+ * since ion will help us to do that. what we
+ * need to do is just map/unmap and import/free
+ * every time
+ */
+void vcodec_iommu_ion_set_ops(struct vcodec_iommu_info *iommu_info)
+{
+	if (!iommu_info)
+		return;
+	iommu_info->ops = &ion_ops;
+}
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_iommu_ops.c b/drivers/video/rockchip/vcodec/vcodec_iommu_ops.c
--- a/drivers/video/rockchip/vcodec/vcodec_iommu_ops.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_iommu_ops.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,294 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/slab.h>
+
+#include "vcodec_iommu_ops.h"
+
+static
+struct vcodec_iommu_session_info *vcodec_iommu_get_session_info
+	(struct vcodec_iommu_info *iommu_info, struct vpu_session *session)
+{
+	struct vcodec_iommu_session_info *session_info = NULL, *n;
+
+	list_for_each_entry_safe(session_info, n, &iommu_info->session_list,
+				 head) {
+		if (session_info->session == session)
+			return session_info;
+	}
+
+	return NULL;
+}
+
+int vcodec_iommu_create(struct vcodec_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->create)
+		return -EINVAL;
+
+	return iommu_info->ops->create(iommu_info);
+}
+
+int vcodec_iommu_alloc(struct vcodec_iommu_info *iommu_info,
+		       struct vpu_session *session,
+		       unsigned long size,
+		       unsigned long align)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info || !iommu_info->ops->alloc || !session)
+		return -EINVAL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+	if (!session_info) {
+		session_info = kzalloc(sizeof(*session_info), GFP_KERNEL);
+		if (!session_info)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&session_info->head);
+		INIT_LIST_HEAD(&session_info->buffer_list);
+		mutex_init(&session_info->list_mutex);
+		session_info->max_idx = 0;
+		session_info->session = session;
+		session_info->mmu_dev = iommu_info->mmu_dev;
+		session_info->dev = iommu_info->dev;
+		session_info->iommu_info = iommu_info;
+		session_info->buffer_nums = 0;
+		mutex_lock(&iommu_info->list_mutex);
+		list_add_tail(&session_info->head, &iommu_info->session_list);
+		mutex_unlock(&iommu_info->list_mutex);
+	}
+
+	session_info->debug_level = iommu_info->debug_level;
+
+	return iommu_info->ops->alloc(session_info, size, align);
+}
+
+int vcodec_iommu_import(struct vcodec_iommu_info *iommu_info,
+			struct vpu_session *session, int fd)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info || !iommu_info->ops->import || !session)
+		return -EINVAL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+	if (!session_info) {
+		session_info = kzalloc(sizeof(*session_info), GFP_KERNEL);
+		if (!session_info)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&session_info->head);
+		INIT_LIST_HEAD(&session_info->buffer_list);
+		mutex_init(&session_info->list_mutex);
+		session_info->max_idx = 0;
+		session_info->session = session;
+		session_info->mmu_dev = iommu_info->mmu_dev;
+		session_info->dev = iommu_info->dev;
+		session_info->iommu_info = iommu_info;
+		session_info->buffer_nums = 0;
+		mutex_lock(&iommu_info->list_mutex);
+		list_add_tail(&session_info->head, &iommu_info->session_list);
+		mutex_unlock(&iommu_info->list_mutex);
+	}
+
+	session_info->debug_level = iommu_info->debug_level;
+
+	return iommu_info->ops->import(session_info, fd);
+}
+
+int vcodec_iommu_free(struct vcodec_iommu_info *iommu_info,
+		      struct vpu_session *session, int idx)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->free || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->free(session_info, idx);
+}
+
+int vcodec_iommu_free_fd(struct vcodec_iommu_info *iommu_info,
+			 struct vpu_session *session, int fd)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->free_fd || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->free_fd(session_info, fd);
+}
+
+int vcodec_iommu_map_iommu_with_iova(struct vcodec_iommu_info *iommu_info,
+				     void *session,
+				     int idx, unsigned long iova,
+				     unsigned long size)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->map_iommu || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->map_iommu_with_iova(session_info,
+						    idx, iova, size);
+}
+
+int vcodec_iommu_unmap_iommu_with_iova(struct vcodec_iommu_info *iommu_info,
+				       void *session, int idx)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->unmap_iommu || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->unmap_iommu_with_iova(session_info, idx);
+}
+
+int vcodec_iommu_map_iommu(struct vcodec_iommu_info *iommu_info,
+			   struct vpu_session *session,
+			   int idx, dma_addr_t *iova,
+			   unsigned long *size)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->map_iommu || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->map_iommu(session_info, idx, iova, size);
+}
+
+int vcodec_iommu_unmap_iommu(struct vcodec_iommu_info *iommu_info,
+			     struct vpu_session *session, int idx)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->unmap_iommu || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->unmap_iommu(session_info, idx);
+}
+
+static int vcodec_iommu_destroy(struct vcodec_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->destroy)
+		return -EINVAL;
+
+	return iommu_info->ops->destroy(iommu_info);
+}
+
+void vcodec_iommu_dump(struct vcodec_iommu_info *iommu_info,
+		       struct vpu_session *session)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->dump || !session_info)
+		return;
+
+	iommu_info->ops->dump(session_info);
+}
+
+void vcodec_iommu_clear(struct vcodec_iommu_info *iommu_info,
+			struct vpu_session *session)
+{
+	struct vcodec_iommu_session_info *session_info = NULL;
+
+	session_info = vcodec_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->clear || !session_info)
+		return;
+
+	iommu_info->ops->clear(session_info);
+
+	mutex_lock(&iommu_info->list_mutex);
+	list_del_init(&session_info->head);
+	kfree(session_info);
+	mutex_unlock(&iommu_info->list_mutex);
+}
+
+int vcodec_iommu_attach(struct vcodec_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->attach)
+		return 0;
+
+	return iommu_info->ops->attach(iommu_info);
+}
+
+void vcodec_iommu_detach(struct vcodec_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->detach)
+		return;
+
+	return iommu_info->ops->detach(iommu_info);
+}
+
+struct vcodec_iommu_info *
+vcodec_iommu_info_create(struct device *dev,
+			 struct device *mmu_dev,
+			 int alloc_type)
+{
+	struct vcodec_iommu_info *iommu_info = NULL;
+
+	iommu_info = kzalloc(sizeof(*iommu_info), GFP_KERNEL);
+	if (!iommu_info)
+		return NULL;
+
+	iommu_info->dev = dev;
+	INIT_LIST_HEAD(&iommu_info->session_list);
+	mutex_init(&iommu_info->list_mutex);
+	mutex_init(&iommu_info->iommu_mutex);
+	switch (alloc_type) {
+#ifdef CONFIG_DRM
+	case ALLOCATOR_USE_DRM:
+		vcodec_iommu_drm_set_ops(iommu_info);
+		break;
+#endif
+#ifdef CONFIG_ION
+	case ALLOCATOR_USE_ION:
+		vcodec_iommu_ion_set_ops(iommu_info);
+		break;
+#endif
+	default:
+		iommu_info->ops = NULL;
+		break;
+	}
+
+	iommu_info->mmu_dev = mmu_dev;
+
+	vcodec_iommu_create(iommu_info);
+
+	return iommu_info;
+}
+
+int vcodec_iommu_info_destroy(struct vcodec_iommu_info *iommu_info)
+{
+	vcodec_iommu_destroy(iommu_info);
+	kfree(iommu_info);
+
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_iommu_ops.h b/drivers/video/rockchip/vcodec/vcodec_iommu_ops.h
--- a/drivers/video/rockchip/vcodec/vcodec_iommu_ops.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_iommu_ops.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,149 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __VCODEC_IOMMU_OPS_H__
+#define __VCODEC_IOMMU_OPS_H__
+
+#include <linux/platform_device.h>
+#include "vcodec_service.h"
+
+#define BUFFER_LIST_MAX_NUMS	30
+
+#define ALLOCATOR_USE_ION		0x00000000
+#define ALLOCATOR_USE_DRM		0x00000001
+
+#define DEBUG_IOMMU_OPS_DUMP	0x00020000
+#define DEBUG_IOMMU_NORMAL	0x00040000
+
+#define vpu_iommu_debug_func(debug_level, type, fmt, args...)	\
+	do {							\
+		if (unlikely(debug_level & type)) {		\
+			pr_info("%s:%d: " fmt,			\
+				 __func__, __LINE__, ##args);	\
+		}						\
+	} while (0)
+#define vpu_iommu_debug(debug_level, type, fmt, args...)	\
+	do {							\
+		if (unlikely(debug_level & type)) {		\
+			pr_info(fmt, ##args);			\
+		}						\
+	} while (0)
+
+struct vcodec_iommu_info;
+struct vcodec_iommu_session_info;
+
+struct vcodec_iommu_ops {
+	int (*create)(struct vcodec_iommu_info *iommu_info);
+	int (*alloc)(struct vcodec_iommu_session_info *session_info,
+		     unsigned long size,
+		     unsigned long align);
+	int (*import)(struct vcodec_iommu_session_info *session_info, int fd);
+	int (*free)(struct vcodec_iommu_session_info *session_info, int idx);
+	int (*free_fd)(struct vcodec_iommu_session_info *session_info, int fd);
+	void* (*map_kernel)(struct vcodec_iommu_session_info *session_info,
+			    int idx);
+	int (*unmap_kernel)(struct vcodec_iommu_session_info *session_info,
+			    int idx);
+	int (*map_iommu)(struct vcodec_iommu_session_info *session_info,
+			 int idx,
+			 dma_addr_t *iova, unsigned long *size);
+	int (*unmap_iommu)(struct vcodec_iommu_session_info *session_info,
+			   int idx);
+	int (*map_iommu_with_iova)(struct vcodec_iommu_session_info
+				   *session_info,
+				   int idx,
+				   unsigned long iova, unsigned long size);
+	int (*unmap_iommu_with_iova)(struct vcodec_iommu_session_info
+				     *session_info,
+				     int idx);
+	int (*destroy)(struct vcodec_iommu_info *iommu_info);
+	void (*dump)(struct vcodec_iommu_session_info *session_info);
+	int (*attach)(struct vcodec_iommu_info *iommu_info);
+	void (*detach)(struct vcodec_iommu_info *iommu_info);
+	void (*clear)(struct vcodec_iommu_session_info *session_info);
+};
+
+struct vcodec_iommu_session_info {
+	struct list_head head;
+	struct vpu_session *session;
+	int buffer_nums;
+	struct list_head buffer_list;
+	struct mutex list_mutex;
+	int max_idx;
+	struct device *dev;
+	struct device *mmu_dev;
+	struct vcodec_iommu_info *iommu_info;
+	int debug_level;
+};
+
+struct vcodec_iommu_info {
+	struct list_head session_list;
+	struct mutex list_mutex;
+	struct mutex iommu_mutex;
+	struct device *dev;
+	struct device *mmu_dev;
+	struct vcodec_iommu_ops *ops;
+	int debug_level;
+	void *private;
+};
+
+#ifdef CONFIG_DRM
+void vcodec_iommu_drm_set_ops(struct vcodec_iommu_info *iommu_info);
+#endif
+#ifdef CONFIG_ION
+void vcodec_iommu_ion_set_ops(struct vcodec_iommu_info *iommu_info);
+#endif
+
+struct vcodec_iommu_info *vcodec_iommu_info_create(struct device *dev,
+						   struct device *mmu_dev,
+						   int alloc_type);
+int vcodec_iommu_info_destroy(struct vcodec_iommu_info *iommu_info);
+
+int vcodec_iommu_create(struct vcodec_iommu_info *iommu_info);
+int vcodec_iommu_alloc(struct vcodec_iommu_info *iommu_info,
+		       struct vpu_session *session,
+		       unsigned long size,
+		       unsigned long align);
+int vcodec_iommu_import(struct vcodec_iommu_info *iommu_info,
+			struct vpu_session *session, int fd);
+int vcodec_iommu_free(struct vcodec_iommu_info *iommu_info,
+		      struct vpu_session *session, int idx);
+int vcodec_iommu_free_fd(struct vcodec_iommu_info *iommu_info,
+			 struct vpu_session *session, int fd);
+int vcodec_iommu_map_iommu(struct vcodec_iommu_info *iommu_info,
+			   struct vpu_session *session,
+			   int idx,
+			   dma_addr_t *iova,
+			   unsigned long *size);
+int vcodec_iommu_unmap_iommu(struct vcodec_iommu_info *iommu_info,
+			     struct vpu_session *session,
+			     int idx);
+int vcodec_iommu_map_iommu_with_iova(struct vcodec_iommu_info *iommu_info,
+				     void *session,
+				     int idx,
+				     unsigned long iova,
+				     unsigned long size);
+int vcodec_iommu_unmap_iommu_with_iova(struct vcodec_iommu_info *iommu_info,
+				       void *session,
+				       int idx);
+void vcodec_iommu_dump(struct vcodec_iommu_info *iommu_info,
+		       struct vpu_session *session);
+void vcodec_iommu_clear(struct vcodec_iommu_info *iommu_info,
+			struct vpu_session *session);
+
+int vcodec_iommu_attach(struct vcodec_iommu_info *iommu_info);
+void vcodec_iommu_detach(struct vcodec_iommu_info *iommu_info);
+
+#endif
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_service.c b/drivers/video/rockchip/vcodec/vcodec_service.c
--- a/drivers/video/rockchip/vcodec/vcodec_service.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_service.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,3827 @@
+/**
+ * Copyright (C) 2015 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming, chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *	   Jung Zhao, jung.zhao@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/clk.h>
+#include <linux/compat.h>
+#include <linux/delay.h>
+#include <linux/devfreq.h>
+#include <linux/devfreq_cooling.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/wakelock.h>
+#include <linux/cdev.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+#include <linux/pm_opp.h>
+#include <linux/pm_runtime.h>
+#include <linux/iopoll.h>
+
+#include <linux/regulator/consumer.h>
+#include <linux/rockchip/grf.h>
+#include <linux/rockchip/rockchip_sip.h>
+#include <linux/thermal.h>
+
+#include <linux/dma-iommu.h>
+#include <linux/dma-buf.h>
+#include <linux/rockchip-iovmm.h>
+#include <video/rk_vpu_service.h>
+#include <soc/rockchip/pm_domains.h>
+#include <soc/rockchip/rockchip_opp_select.h>
+
+#include "vcodec_hw_info.h"
+#include "vcodec_hw_vpu.h"
+#include "vcodec_hw_rkv.h"
+#include "vcodec_hw_vpu2.h"
+
+#include "vcodec_service.h"
+
+#include "vcodec_iommu_ops.h"
+
+#include "../../../devfreq/governor.h"
+
+/*
+ * debug flag usage:
+ * +------+-------------------+
+ * | 8bit |      24bit        |
+ * +------+-------------------+
+ *  0~23 bit is for different information type
+ * 24~31 bit is for information print format
+ */
+
+#define DEBUG_POWER				0x00000001
+#define DEBUG_CLOCK				0x00000002
+#define DEBUG_IRQ_STATUS			0x00000004
+#define DEBUG_IOMMU				0x00000008
+#define DEBUG_IOCTL				0x00000010
+#define DEBUG_FUNCTION				0x00000020
+#define DEBUG_REGISTER				0x00000040
+#define DEBUG_EXTRA_INFO			0x00000080
+#define DEBUG_TIMING				0x00000100
+#define DEBUG_TASK_INFO				0x00000200
+
+#define DEBUG_SET_REG				0x00001000
+#define DEBUG_GET_REG				0x00002000
+#define DEBUG_PPS_FILL				0x00004000
+#define DEBUG_IRQ_CHECK				0x00008000
+#define DEBUG_CACHE_32B				0x00010000
+
+#define PRINT_FUNCTION				0x80000000
+#define PRINT_LINE				0x40000000
+
+#define MHZ					(1000 * 1000)
+#define SIZE_REG(reg)				((reg) * 4)
+
+#define VCODEC_CLOCK_ENABLE			1
+#define IOMMU_PAGE_SIZE				4096
+#define EXTRA_INFO_MAGIC			0x4C4A46
+
+#define RK3328_VCODEC_RATE_ON			(500 * MHZ)
+#define RK3328_CODE_RATE_ON			(250 * MHZ)
+#define RK3328_CABAC_RATE_ON			(400 * MHZ)
+#define RK3328_VCODEC_RATE_OFF			(100 * MHZ)
+#define RK3328_CODE_RATE_OFF			(100 * MHZ)
+#define RK3328_CABAC_RATE_OFF			(100 * MHZ)
+
+#define FALLBACK_STATIC_TEMPERATURE		55000
+
+static int debug;
+module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "bit switch for vcodec_service debug information");
+/*
+ * hardware information organization
+ *
+ * In order to support multiple hardware with different version the hardware
+ * information is organized as follow:
+ *
+ * 1. First, index hardware by register size / position.
+ *    These information is fix for each hardware and do not relate to runtime
+ *    work flow. It only related to resource allocation.
+ *    Descriptor: struct vpu_hw_info
+ *
+ * 2. Then, index hardware by runtime configuration
+ *    These information is related to runtime setting behave including enable
+ *    register, irq register and other key control flag
+ *    Descriptor: struct vpu_task_info
+ *
+ * 3. Final, on iommu case the fd translation is required
+ *    Descriptor: struct vpu_trans_info
+ */
+
+enum SET_CLK_EVENT {
+	EVENT_POWER_ON = 0,
+	EVENT_POWER_OFF,
+	EVENT_ADJUST,
+	EVENT_THERMAL,
+};
+
+enum VPU_FREQ {
+	VPU_FREQ_200M,
+	VPU_FREQ_266M,
+	VPU_FREQ_300M,
+	VPU_FREQ_400M,
+	VPU_FREQ_500M,
+	VPU_FREQ_600M,
+	VPU_FREQ_DEFAULT,
+	VPU_FREQ_BUT,
+};
+
+struct extra_info_elem {
+	u32 index;
+	u32 offset;
+};
+
+struct extra_info_for_iommu {
+	u32 magic;
+	u32 cnt;
+	struct extra_info_elem elem[20];
+};
+
+struct vcodec_iommu_drm_info {
+	struct iommu_domain *domain;
+	bool attached;
+};
+
+static const struct vcodec_info vcodec_info_set[] = {
+	{
+		.hw_id		= VPU_ID_8270,
+		.hw_info	= &hw_vpu_8270,
+		.task_info	= task_vpu,
+		.trans_info	= trans_vpu,
+	},
+	{
+		.hw_id		= VPU_ID_4831,
+		.hw_info	= &hw_vpu_4831,
+		.task_info	= task_vpu,
+		.trans_info	= trans_vpu,
+	},
+	{
+		.hw_id		= VPU_DEC_ID_9190,
+		.hw_info	= &hw_vpu_9190,
+		.task_info	= task_vpu,
+		.trans_info	= trans_vpu,
+	},
+	{
+		.hw_id		= HEVC_ID,
+		.hw_info	= &hw_rkhevc,
+		.task_info	= task_rkv,
+		.trans_info	= trans_rkv,
+	},
+	{
+		.hw_id		= RKV_DEC_ID,
+		.hw_info	= &hw_rkvdec,
+		.task_info	= task_rkv,
+		.trans_info	= trans_rkv,
+	},
+	{
+		.hw_id          = VPU2_ID,
+		.hw_info        = &hw_vpu2,
+		.task_info      = task_vpu2,
+		.trans_info     = trans_vpu2,
+	},
+	{
+		.hw_id		= RKV_DEC_ID2,
+		.hw_info	= &hw_rkvdec,
+		.task_info	= task_rkv,
+		.trans_info	= trans_rkv,
+	},
+};
+
+#define DEBUG
+#ifdef DEBUG
+#define vpu_debug_func(type, fmt, args...)			\
+	do {							\
+		if (unlikely(debug & type)) {			\
+			pr_info("%s:%d: " fmt,			\
+				 __func__, __LINE__, ##args);	\
+		}						\
+	} while (0)
+#define vpu_debug(type, fmt, args...)				\
+	do {							\
+		if (unlikely(debug & type)) {			\
+			pr_info(fmt, ##args);			\
+		}						\
+	} while (0)
+#else
+#define vpu_debug_func(level, fmt, args...)
+#define vpu_debug(level, fmt, args...)
+#endif
+
+#define vpu_debug_enter() vpu_debug_func(DEBUG_FUNCTION, "enter\n")
+#define vpu_debug_leave() vpu_debug_func(DEBUG_FUNCTION, "leave\n")
+
+#define vpu_err(fmt, args...)				\
+		pr_err("%s:%d: " fmt, __func__, __LINE__, ##args)
+
+struct vpu_device {
+	atomic_t irq_count_codec;
+	atomic_t irq_count_pp;
+	unsigned int iosize;
+	u32 *regs;
+};
+
+enum VCODEC_RUNNING_MODE {
+	VCODEC_RUNNING_MODE_NONE = -1,
+	VCODEC_RUNNING_MODE_VPU,
+	VCODEC_RUNNING_MODE_HEVC,
+	VCODEC_RUNNING_MODE_RKVDEC
+};
+
+struct vcodec_mem_region {
+	struct list_head srv_lnk;
+	struct list_head reg_lnk;
+	struct list_head session_lnk;
+	/* virtual address for iommu */
+	dma_addr_t iova;
+	unsigned long len;
+	int reg_idx;
+	int hdl;
+};
+
+/* struct for process register set */
+struct vpu_reg {
+	enum VPU_CLIENT_TYPE type;
+	enum VPU_FREQ freq;
+	struct vpu_session *session;
+	struct vpu_subdev_data *data;
+	struct vpu_task_info *task;
+	const struct vpu_trans_info *trans;
+
+	/* link to vpu service session */
+	struct list_head session_link;
+	/* link to register set list */
+	struct list_head status_link;
+
+	unsigned long size;
+	struct list_head mem_region_list;
+	u32 dec_base;
+	u32 *reg;
+};
+
+enum vpu_ctx_state {
+	MMU_ACTIVATED	= BIT(0),
+	MMU_PAGEFAULT	= BIT(1)
+};
+
+struct vpu_subdev_data {
+	struct cdev cdev;
+	dev_t dev_t;
+	struct class *cls;
+	struct device *child_dev;
+
+	int irq_enc;
+	int irq_dec;
+	struct vpu_service_info *pservice;
+
+	u32 *regs;
+	enum VCODEC_RUNNING_MODE mode;
+	struct list_head lnk_service;
+
+	struct device *dev;
+
+	struct vpu_device enc_dev;
+	struct vpu_device dec_dev;
+
+	enum VPU_HW_ID hw_id;
+	struct vpu_hw_info *hw_info;
+	struct vpu_task_info *task_info;
+	const struct vpu_trans_info *trans_info;
+
+	u32 reg_size;
+	unsigned long state;
+
+	struct device *mmu_dev;
+	struct vcodec_iommu_info *iommu_info;
+	int pa_hdl;
+	unsigned long pa_iova;
+	struct work_struct set_work;
+};
+
+struct vpu_service_info {
+	struct wake_lock wake_lock;
+	struct delayed_work power_off_work;
+	struct wake_lock set_wake_lock;
+	struct workqueue_struct *set_workq;
+	ktime_t last; /* record previous power-on time */
+	/* vpu service structure global lock */
+	struct mutex lock;
+	/* link to link_reg in struct vpu_reg */
+	struct list_head waiting;
+	/* link to link_reg in struct vpu_reg */
+	struct list_head running;
+	/* link to link_reg in struct vpu_reg */
+	struct list_head done;
+	/* link to list_session in struct vpu_session */
+	struct list_head session;
+	atomic_t total_running;
+	atomic_t enabled;
+	atomic_t power_on_cnt;
+	atomic_t power_off_cnt;
+	atomic_t service_on;
+	struct mutex shutdown_lock;
+	/*
+	 * FIXME: if someone call iommu translate function during vpu_reset,
+	 * it may cause system core dump without any message. we suggest
+	 * modify iommu driver to avoid this situation. before that,
+	 * this is a temporary solution.
+	 */
+	struct mutex reset_lock;
+	struct mutex sip_reset_lock; /* sip smc reset lock */
+	struct vpu_reg *reg_codec;
+	struct vpu_reg *reg_pproc;
+	struct vpu_reg *reg_resev;
+	struct vpu_dec_config dec_config;
+	struct vpu_enc_config enc_config;
+
+	bool auto_freq;
+	bool bug_dec_addr;
+	atomic_t freq_status;
+
+	bool secure_isr;
+	bool secure_irq_status;
+	atomic_t secure_mode;
+	wait_queue_head_t *wait_secure_isr;
+
+	struct devfreq *devfreq;
+	struct regulator *vdd_vcodec;
+	struct mutex set_clk_lock; /* set clk lock */
+
+	unsigned long volt;
+	unsigned long vcodec_rate;
+	unsigned long core_rate;
+	unsigned long cabac_rate;
+
+	struct thermal_cooling_device *devfreq_cooling;
+	u32 static_coefficient;
+	s32 ts[4];
+	struct thermal_zone_device *vcodec_tz;
+
+	struct clk *aclk_vcodec;
+	struct clk *hclk_vcodec;
+	struct clk *clk_core;
+	struct clk *clk_cabac;
+	struct clk *pd_video;
+
+	unsigned long aclk_vcodec_default_rate;
+	unsigned long clk_core_default_rate;
+	unsigned long clk_cabac_default_rate;
+
+#ifdef CONFIG_RESET_CONTROLLER
+	struct reset_control *rst_a;
+	struct reset_control *rst_h;
+	struct reset_control *rst_v;
+	struct reset_control *rst_core;
+	struct reset_control *rst_cabac;
+	struct reset_control *rst_niu_a;
+	struct reset_control *rst_niu_h;
+#endif
+	struct device *dev;
+
+	u32 irq_status;
+	atomic_t reset_request;
+	struct list_head mem_region_list;
+
+	enum vcodec_device_id dev_id;
+
+	enum VCODEC_RUNNING_MODE curr_mode;
+	u32 prev_mode;
+
+	struct delayed_work simulate_work;
+
+	u32 mode_bit;
+	u32 mode_ctrl;
+	u32 *reg_base;
+	u32 ioaddr;
+	struct regmap *grf;
+
+	char *name;
+
+	u32 subcnt;
+	struct list_head subdev_list;
+
+	u32 alloc_type;
+
+	struct vcodec_hw_ops *hw_ops;
+	const struct vcodec_hw_var *hw_var;
+	struct devfreq *parent_devfreq;
+	struct notifier_block devfreq_nb;
+};
+
+struct vcodec_hw_ops {
+	void (*power_on)(struct vpu_service_info *pservice);
+	void (*power_off)(struct vpu_service_info *pservice);
+	void (*get_freq)(struct vpu_subdev_data *data, struct vpu_reg *reg);
+	void (*set_freq)(struct vpu_service_info *pservice,
+			 struct vpu_reg *reg);
+	void (*reduce_freq)(struct vpu_service_info *pservice);
+};
+
+struct vcodec_hw_var {
+	s32 device_type;
+	u8 *name;
+	struct vcodec_hw_ops *ops;
+	int (*init)(struct vpu_service_info *pservice);
+	void (*config)(struct vpu_subdev_data *data);
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_vpu_request {
+	compat_uptr_t req;
+	u32 size;
+};
+#endif
+
+#define VDPU_SOFT_RESET_REG	101
+#define VDPU_CLEAN_CACHE_REG	516
+#define VEPU_CLEAN_CACHE_REG	772
+#define HEVC_CLEAN_CACHE_REG	260
+
+#define VPU_REG_ENABLE(base, reg)	writel_relaxed(1, base + reg)
+
+#define VDPU_SOFT_RESET(base)	VPU_REG_ENABLE(base, VDPU_SOFT_RESET_REG)
+#define VDPU_CLEAN_CACHE(base)	VPU_REG_ENABLE(base, VDPU_CLEAN_CACHE_REG)
+#define VEPU_CLEAN_CACHE(base)	VPU_REG_ENABLE(base, VEPU_CLEAN_CACHE_REG)
+#define HEVC_CLEAN_CACHE(base)	VPU_REG_ENABLE(base, HEVC_CLEAN_CACHE_REG)
+
+#define VPU_POWER_OFF_DELAY		(4 * HZ) /* 4s */
+#define VPU_TIMEOUT_DELAY		(2 * HZ) /* 2s */
+
+static void vcodec_reduce_freq_rk3328(struct vpu_service_info *pservice);
+
+static void vpu_service_power_on(struct vpu_subdev_data *data,
+				 struct vpu_service_info *pservice);
+
+static void time_record(struct vpu_task_info *task, int is_end)
+{
+	if (unlikely(debug & DEBUG_TIMING) && task)
+		do_gettimeofday((is_end) ? (&task->end) : (&task->start));
+}
+
+static void time_diff(struct vpu_task_info *task)
+{
+	vpu_debug(DEBUG_TIMING, "%s task: %ld ms\n", task->name,
+		  (task->end.tv_sec  - task->start.tv_sec)  * 1000 +
+		  (task->end.tv_usec - task->start.tv_usec) / 1000);
+}
+
+static inline int try_reset_assert(struct reset_control *rst)
+{
+	if (rst)
+		return reset_control_assert(rst);
+	return -EINVAL;
+}
+
+static inline int try_reset_deassert(struct reset_control *rst)
+{
+	if (rst)
+		return reset_control_deassert(rst);
+	return -EINVAL;
+}
+
+static inline int grf_combo_switch(const struct vpu_subdev_data *data)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	int bits;
+	u32 raw = 0;
+
+	bits = 1 << pservice->mode_bit;
+	if (pservice->grf) {
+		regmap_read(pservice->grf, pservice->mode_ctrl, &raw);
+
+		if (data->mode == VCODEC_RUNNING_MODE_HEVC)
+			regmap_write(pservice->grf, pservice->mode_ctrl,
+				     raw | bits | (bits << 16));
+		else
+			regmap_write(pservice->grf, pservice->mode_ctrl,
+				     (raw & (~bits)) | (bits << 16));
+	} else {
+		vpu_err("no grf resource define, switch decoder failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void vcodec_enter_mode(struct vpu_subdev_data *data)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_subdev_data *subdata, *n;
+
+	/*
+	 * For the RK3228H, it is not necessary to write a register to
+	 * switch vpu combo mode, it is unsafe to write the grf.
+	 */
+	if (pservice->subcnt < 2 || pservice->mode_ctrl == 0) {
+		if (data->mmu_dev && !test_bit(MMU_ACTIVATED, &data->state)) {
+			set_bit(MMU_ACTIVATED, &data->state);
+
+			if (atomic_read(&pservice->enabled)) {
+				if (vcodec_iommu_attach(data->iommu_info))
+					dev_err(data->dev,
+						"vcodec service attach failed\n"
+						);
+				else
+					/* Stop here is enough */
+					return;
+			}
+		}
+		return;
+	}
+
+	if (pservice->curr_mode == data->mode)
+		return;
+
+	vpu_debug(DEBUG_REGISTER, "vcodec enter mode %d\n", data->mode);
+	list_for_each_entry_safe(subdata, n,
+				 &pservice->subdev_list, lnk_service) {
+		if (data != subdata && subdata->mmu_dev &&
+		    test_bit(MMU_ACTIVATED, &subdata->state)) {
+			clear_bit(MMU_ACTIVATED, &subdata->state);
+			vcodec_iommu_detach(subdata->iommu_info);
+		}
+	}
+
+	if (grf_combo_switch(data))
+		return;
+
+	if (data->mmu_dev && !test_bit(MMU_ACTIVATED, &data->state)) {
+		set_bit(MMU_ACTIVATED, &data->state);
+		if (atomic_read(&pservice->enabled))
+			vcodec_iommu_attach(data->iommu_info);
+		else
+			/* FIXME BUG_ON should not be used in mass produce */
+			BUG_ON(!atomic_read(&pservice->enabled));
+	}
+
+	pservice->prev_mode = pservice->curr_mode;
+	pservice->curr_mode = data->mode;
+}
+
+static void vcodec_exit_mode(struct vpu_subdev_data *data)
+{
+	/*
+	 * In case of VPU Combo, it require HW switch its running mode
+	 * before the other HW component start work. set current HW running
+	 * mode to none, can ensure HW switch to its reqired mode properly.
+	 */
+	data->pservice->curr_mode = VCODEC_RUNNING_MODE_NONE;
+}
+
+static int vpu_get_clk(struct vpu_service_info *pservice)
+{
+#if VCODEC_CLOCK_ENABLE
+	struct device *dev = pservice->dev;
+
+	switch (pservice->dev_id) {
+	case VCODEC_DEVICE_ID_HEVC:
+		/* We won't regard the power domain as clocks at 4.4 */
+		pservice->pd_video = devm_clk_get(dev, "pd_hevc");
+		if (IS_ERR(pservice->pd_video)) {
+			pservice->pd_video = NULL;
+			dev_dbg(dev, "failed on clk_get pd_hevc\n");
+		}
+	case VCODEC_DEVICE_ID_COMBO:
+	case VCODEC_DEVICE_ID_RKVDEC:
+		pservice->clk_cabac = devm_clk_get(dev, "clk_cabac");
+		if (IS_ERR(pservice->clk_cabac)) {
+			dev_err(dev, "failed on clk_get clk_cabac\n");
+			pservice->clk_cabac = NULL;
+		} else {
+			pservice->clk_cabac_default_rate =
+				clk_get_rate(pservice->clk_cabac);
+		}
+		pservice->clk_core = devm_clk_get(dev, "clk_core");
+		if (IS_ERR(pservice->clk_core)) {
+			dev_err(dev, "failed on clk_get clk_core\n");
+			pservice->clk_core = NULL;
+		} else {
+			pservice->clk_core_default_rate =
+				clk_get_rate(pservice->clk_core);
+		}
+	case VCODEC_DEVICE_ID_VPU:
+		pservice->aclk_vcodec = devm_clk_get(dev, "aclk_vcodec");
+		if (IS_ERR(pservice->aclk_vcodec)) {
+			dev_err(dev, "failed on clk_get aclk_vcodec\n");
+			return -1;
+		} else {
+			pservice->aclk_vcodec_default_rate =
+				clk_get_rate(pservice->aclk_vcodec);
+		}
+
+		pservice->hclk_vcodec = devm_clk_get(dev, "hclk_vcodec");
+		if (IS_ERR(pservice->hclk_vcodec)) {
+			dev_err(dev, "failed on clk_get hclk_vcodec\n");
+			pservice->hclk_vcodec = NULL;
+			return -1;
+		}
+		if (pservice->pd_video == NULL) {
+			pservice->pd_video = devm_clk_get(dev, "pd_video");
+			if (IS_ERR(pservice->pd_video)) {
+				pservice->pd_video = NULL;
+				dev_dbg(dev, "do not have pd_video\n");
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+#else
+	return 0;
+#endif
+}
+
+static void rkvdec_dvfs_set_clk(struct vpu_service_info *pservice,
+				u32 vcodec_rate, u32 core_rate,
+				u32 cabac_rate)
+{
+	struct devfreq *devfreq = pservice->devfreq;
+
+	mutex_lock(&devfreq->lock);
+
+	pservice->vcodec_rate = vcodec_rate;
+	pservice->core_rate = core_rate;
+	pservice->cabac_rate = cabac_rate;
+
+	devfreq->min_freq = vcodec_rate;
+	devfreq->max_freq = vcodec_rate;
+	update_devfreq(devfreq);
+
+	mutex_unlock(&devfreq->lock);
+}
+
+static void _vpu_reset(struct vpu_subdev_data *data)
+{
+	struct vpu_service_info *pservice = data->pservice;
+
+	dev_info(pservice->dev, "resetting...\n");
+	WARN_ON(pservice->reg_codec != NULL);
+	WARN_ON(pservice->reg_pproc != NULL);
+	WARN_ON(pservice->reg_resev != NULL);
+	pservice->reg_codec = NULL;
+	pservice->reg_pproc = NULL;
+	pservice->reg_resev = NULL;
+
+#ifdef CONFIG_RESET_CONTROLLER
+
+	rockchip_save_qos(pservice->dev);
+
+	/* rk3328 need to use sip_smc_vpu_reset to reset vpu */
+	if (pservice->hw_ops->reduce_freq == vcodec_reduce_freq_rk3328) {
+		mutex_lock(&pservice->sip_reset_lock);
+		sip_smc_vpu_reset(0, 0, 0);
+		mutex_unlock(&pservice->sip_reset_lock);
+	} else {
+		rockchip_pmu_idle_request(pservice->dev, true);
+		if (pservice->hw_ops->reduce_freq)
+			pservice->hw_ops->reduce_freq(pservice);
+
+		try_reset_assert(pservice->rst_niu_a);
+		try_reset_assert(pservice->rst_niu_h);
+		try_reset_assert(pservice->rst_v);
+		try_reset_assert(pservice->rst_a);
+		try_reset_assert(pservice->rst_h);
+		try_reset_assert(pservice->rst_core);
+		try_reset_assert(pservice->rst_cabac);
+		udelay(5);
+
+		try_reset_deassert(pservice->rst_niu_h);
+		try_reset_deassert(pservice->rst_niu_a);
+		try_reset_deassert(pservice->rst_v);
+		try_reset_deassert(pservice->rst_h);
+		try_reset_deassert(pservice->rst_a);
+		try_reset_deassert(pservice->rst_core);
+		try_reset_deassert(pservice->rst_cabac);
+
+		rockchip_pmu_idle_request(pservice->dev, false);
+	}
+
+	rockchip_restore_qos(pservice->dev);
+
+	dev_info(pservice->dev, "reset done\n");
+#endif
+}
+
+static void vpu_reset(struct vpu_subdev_data *data)
+{
+	struct vpu_service_info *pservice = data->pservice;
+
+	_vpu_reset(data);
+	if (data->mmu_dev && test_bit(MMU_ACTIVATED, &data->state)) {
+		clear_bit(MMU_ACTIVATED, &data->state);
+		clear_bit(MMU_PAGEFAULT, &data->state);
+		if (atomic_read(&pservice->enabled)) {
+			/* Need to reset iommu */
+			vcodec_iommu_detach(data->iommu_info);
+		} else {
+			/* FIXME BUG_ON should not be used in mass produce */
+			BUG_ON(!atomic_read(&pservice->enabled));
+		}
+	}
+
+	atomic_set(&pservice->reset_request, 0);
+	dev_info(pservice->dev, "reset done\n");
+}
+
+static void reg_deinit(struct vpu_subdev_data *data, struct vpu_reg *reg);
+static void vpu_service_session_clear(struct vpu_subdev_data *data,
+				      struct vpu_session *session)
+{
+	struct vpu_reg *reg, *n;
+
+	list_for_each_entry_safe(reg, n, &session->waiting, session_link) {
+		reg_deinit(data, reg);
+	}
+	list_for_each_entry_safe(reg, n, &session->running, session_link) {
+		reg_deinit(data, reg);
+	}
+	list_for_each_entry_safe(reg, n, &session->done, session_link) {
+		reg_deinit(data, reg);
+	}
+}
+
+#if VCODEC_CLOCK_ENABLE
+static unsigned long get_div_rate(struct clk *clock, int divide)
+{
+	struct clk *parent = clk_get_parent(clock);
+	unsigned long rate = clk_get_rate(parent);
+
+	return (rate / divide) + 1;
+}
+#endif
+
+static void vpu_service_power_off(struct vpu_service_info *pservice)
+{
+	int total_running;
+	struct vpu_subdev_data *data = NULL, *n;
+	int ret = atomic_add_unless(&pservice->enabled, -1, 0);
+
+	if (!ret)
+		return;
+
+	total_running = atomic_read(&pservice->total_running);
+	if (total_running) {
+		pr_alert("alert: power off when %d task running!!\n",
+			 total_running);
+		mdelay(50);
+		pr_alert("alert: delay 50 ms for running task\n");
+	}
+
+	dev_dbg(pservice->dev, "power off...\n");
+
+	udelay(5);
+
+	list_for_each_entry_safe(data, n, &pservice->subdev_list, lnk_service) {
+		if (data->mmu_dev && test_bit(MMU_ACTIVATED, &data->state)) {
+			clear_bit(MMU_ACTIVATED, &data->state);
+			vcodec_iommu_detach(data->iommu_info);
+		}
+	}
+	pservice->curr_mode = VCODEC_RUNNING_MODE_NONE;
+	if (pservice->hw_ops->power_off)
+		pservice->hw_ops->power_off(pservice);
+
+	atomic_add(1, &pservice->power_off_cnt);
+	wake_unlock(&pservice->wake_lock);
+	dev_dbg(pservice->dev, "power off done\n");
+}
+
+static inline void vpu_queue_power_off_work(struct vpu_service_info *pservice)
+{
+	queue_delayed_work(system_wq, &pservice->power_off_work,
+			   VPU_POWER_OFF_DELAY);
+}
+
+static void vpu_power_off_work(struct work_struct *work_s)
+{
+	struct delayed_work *dlwork = container_of(work_s,
+			struct delayed_work, work);
+	struct vpu_service_info *pservice = container_of(dlwork,
+			struct vpu_service_info, power_off_work);
+
+	if (mutex_trylock(&pservice->lock)) {
+		vpu_service_power_off(pservice);
+		mutex_unlock(&pservice->lock);
+	} else {
+		/* Come back later if the device is busy... */
+		vpu_queue_power_off_work(pservice);
+	}
+}
+
+static void vpu_service_power_on(struct vpu_subdev_data *data,
+				 struct vpu_service_info *pservice)
+{
+	int ret;
+	ktime_t now = ktime_get();
+
+	if (ktime_to_ns(ktime_sub(now, pservice->last)) > NSEC_PER_SEC ||
+	    atomic_read(&pservice->power_on_cnt)) {
+		/* NSEC_PER_SEC */
+		cancel_delayed_work_sync(&pservice->power_off_work);
+		vpu_queue_power_off_work(pservice);
+		pservice->last = now;
+	}
+	ret = atomic_add_unless(&pservice->enabled, 1, 1);
+	if (!ret)
+		return;
+
+	dev_dbg(pservice->dev, "power on\n");
+
+	if (pservice->hw_ops->power_on)
+		pservice->hw_ops->power_on(pservice);
+
+	udelay(5);
+	atomic_add(1, &pservice->power_on_cnt);
+	wake_lock(&pservice->wake_lock);
+}
+
+static inline bool reg_check_interlace(struct vpu_reg *reg)
+{
+	u32 type = (reg->reg[3] & (1 << 23));
+
+	return (type > 0);
+}
+
+static inline enum VPU_DEC_FMT reg_check_fmt(struct vpu_reg *reg)
+{
+	enum VPU_DEC_FMT type = (enum VPU_DEC_FMT)((reg->reg[3] >> 28) & 0xf);
+
+	return type;
+}
+
+static inline int reg_probe_width(struct vpu_reg *reg)
+{
+	int width_in_mb = reg->reg[4] >> 23;
+
+	return width_in_mb * 16;
+}
+
+static inline int reg_probe_hevc_y_stride(struct vpu_reg *reg)
+{
+	int y_virstride = reg->reg[8];
+
+	return y_virstride;
+}
+
+static dma_addr_t vcodec_fd_to_iova(struct vpu_subdev_data *data,
+				    struct vpu_session *session,
+				    struct vpu_reg *reg, int fd, int idx)
+{
+	int hdl;
+	int ret = 0;
+	struct vcodec_mem_region *mem_region;
+
+	hdl = vcodec_iommu_import(data->iommu_info, session, fd);
+	if (hdl < 0)
+		return hdl;
+
+	mem_region = kzalloc(sizeof(*mem_region), GFP_KERNEL);
+	if (mem_region == NULL) {
+		vpu_err("allocate memory for iommu memory region failed\n");
+		vcodec_iommu_free(data->iommu_info, session, hdl);
+		return -ENOMEM;
+	}
+
+	mem_region->hdl = hdl;
+	mem_region->reg_idx = idx;
+	ret = vcodec_iommu_map_iommu(data->iommu_info, session, mem_region->hdl,
+				     &mem_region->iova, &mem_region->len);
+	if (ret < 0) {
+		vpu_err("fd %d iommu map to device failed\n", fd);
+		kfree(mem_region);
+		vcodec_iommu_free(data->iommu_info, session, hdl);
+
+		return -EFAULT;
+	}
+	INIT_LIST_HEAD(&mem_region->reg_lnk);
+	list_add_tail(&mem_region->reg_lnk, &reg->mem_region_list);
+
+	return mem_region->iova;
+}
+
+/*
+ * NOTE: rkvdec/rkhevc put scaling list address in pps buffer hardware will read
+ * it by pps id in video stream data.
+ *
+ * So we need to translate the address in iommu case. The address data is also
+ * 10bit fd + 22bit offset mode.
+ * Because userspace decoder do not give the pps id in the register file sets
+ * kernel driver need to translate each scaling list address in pps buffer which
+ * means 256 pps for H.264, 64 pps for H.265.
+ *
+ * In order to optimize the performance kernel driver ask userspace decoder to
+ * set all scaling list address in pps buffer to the same one which will be used
+ * on current decoding task. Then kernel driver can only translate the first
+ * address then copy it all pps buffer.
+ */
+static int fill_scaling_list_pps(struct vpu_subdev_data *data,
+				 struct vpu_reg *reg, int fd,
+				 int offset, int count,
+				 int pps_info_size,
+				 int sub_addr_offset)
+{
+	struct dma_buf *dmabuf = NULL;
+	void *vaddr = NULL;
+	u8 *pps = NULL;
+	u32 base = sub_addr_offset;
+	u32 scaling_fd = 0;
+	u32 scaling_offset;
+	int ret = 0;
+
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR_OR_NULL(dmabuf)) {
+		dev_err(data->dev, "invliad pps buffer\n");
+		return -ENOENT;
+	}
+
+	ret = dma_buf_begin_cpu_access(dmabuf, 0, dmabuf->size,
+				       DMA_FROM_DEVICE);
+	if (ret) {
+		dev_err(data->dev, "can't access the pps buffer\n");
+		return ret;
+	}
+
+	vaddr = dma_buf_vmap(dmabuf);
+	if (!vaddr) {
+		dev_err(data->dev, "can't access the pps buffer\n");
+		return -EIO;
+	}
+	pps = vaddr + offset;
+
+	memcpy(&scaling_offset, pps + base, sizeof(scaling_offset));
+	scaling_offset = le32_to_cpu(scaling_offset);
+
+	scaling_fd = scaling_offset & 0x3ff;
+	scaling_offset = scaling_offset >> 10;
+
+	if (scaling_fd > 0) {
+		int i = 0;
+		u32 tmp = vcodec_fd_to_iova(data, reg->session, reg,
+					    scaling_fd, -1);
+
+		if (IS_ERR_VALUE(tmp))
+			return tmp;
+		tmp += scaling_offset;
+		tmp = cpu_to_le32(tmp);
+
+		/* Fill the scaling list address in each pps entries */
+		for (i = 0; i < count; i++, base += pps_info_size)
+			memcpy(pps + base, &tmp, sizeof(tmp));
+	}
+
+	dma_buf_vunmap(dmabuf, vaddr);
+	dma_buf_end_cpu_access(dmabuf, 0, dmabuf->size, DMA_FROM_DEVICE);
+	dma_buf_put(dmabuf);
+
+	return 0;
+}
+
+static int vcodec_bufid_to_iova(struct vpu_subdev_data *data,
+				struct vpu_session *session,
+				const u8 *tbl,
+				int size, struct vpu_reg *reg,
+				struct extra_info_for_iommu *ext_inf)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_task_info *task = reg->task;
+	enum FORMAT_TYPE type;
+	int offset = 0;
+	int ret = 0;
+	int i;
+
+	if (tbl == NULL || size <= 0) {
+		dev_err(pservice->dev, "input arguments invalidate\n");
+		return -EINVAL;
+	}
+
+	if (task->get_fmt) {
+		type = task->get_fmt(reg->reg);
+	} else {
+		dev_err(pservice->dev, "invalid task with NULL get_fmt\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < size; i++) {
+		int usr_fd = reg->reg[tbl[i]] & 0x3FF;
+		dma_addr_t iova = 0;
+
+		/* if userspace do not set the fd at this register, skip */
+		if (usr_fd == 0)
+			continue;
+
+		/*
+		 * special offset scale case
+		 *
+		 * This translation is for fd + offset translation.
+		 * One register has 32bits. We need to transfer both buffer file
+		 * handle and the start address offset so we packet file handle
+		 * and offset together using below format.
+		 *
+		 *  0~9  bit for buffer file handle range 0 ~ 1023
+		 * 10~31 bit for offset range 0 ~ 4M
+		 *
+		 * But on 4K case the offset can be larger the 4M
+		 * So on H.264 4K vpu/vpu2 decoder we scale the offset by 16
+		 * But MPEG4 will use the same register for colmv and it do not
+		 * need scale.
+		 *
+		 * RKVdec do not have this issue.
+		 */
+		if ((type == FMT_H264D || type == FMT_VP9D) &&
+		    task->reg_dir_mv > 0 && task->reg_dir_mv == tbl[i])
+			offset = reg->reg[tbl[i]] >> 10 << 4;
+		else
+			offset = reg->reg[tbl[i]] >> 10;
+
+		vpu_debug(DEBUG_IOMMU, "pos %3d fd %3d offset %10d i %d\n",
+			  tbl[i], usr_fd, offset, i);
+
+		/* Only apply for RKVDEC */
+		if (task->reg_pps > 0 && task->reg_pps == tbl[i]) {
+			int pps_info_count;
+			int pps_info_size;
+			int scaling_offset;
+
+			switch (type) {
+			case FMT_H264D: {
+				pps_info_count = 256;
+				pps_info_size = 32;
+				scaling_offset = 23;
+			} break;
+			case FMT_H265D: {
+				pps_info_count = 64;
+				pps_info_size = 80;
+				scaling_offset = 74;
+				offset = 0;
+			} break;
+			default: {
+				offset = 0;
+				pps_info_count = 0;
+				pps_info_size = 0;
+				scaling_offset = 0;
+			} break;
+			}
+
+			vpu_debug(DEBUG_PPS_FILL,
+				  "scaling list filling parameter:\n");
+			vpu_debug(DEBUG_PPS_FILL,
+				  "pps_info_count = %d\n", pps_info_count);
+			vpu_debug(DEBUG_PPS_FILL,
+				  "pps_info_size = %d\n", pps_info_size);
+			vpu_debug(DEBUG_PPS_FILL,
+				  "scaling_list_addr_offset = %d\n",
+				  scaling_offset);
+
+			if (pps_info_count) {
+				ret = fill_scaling_list_pps(data, reg, usr_fd,
+							    offset,
+							    pps_info_count,
+							    pps_info_size,
+							    scaling_offset);
+				if (ret)
+					return ret;
+			}
+		}
+
+		iova = vcodec_fd_to_iova(data, session, reg, usr_fd, tbl[i]);
+		if (IS_ERR_VALUE(iova))
+			return iova;
+
+		/*
+		 * special for vpu dec num 12: record decoded length
+		 * hacking for decoded length
+		 * NOTE: not a perfect fix, the fd is not recorded
+		 */
+		if (task->reg_len > 0 && task->reg_len == tbl[i]) {
+			reg->dec_base = iova + offset;
+			vpu_debug(DEBUG_REGISTER, "dec_set %08x\n",
+				  reg->dec_base);
+		}
+
+		reg->reg[tbl[i]] = iova + offset;
+	}
+
+	if (ext_inf != NULL && ext_inf->magic == EXTRA_INFO_MAGIC) {
+		for (i = 0; i < ext_inf->cnt; i++) {
+			vpu_debug(DEBUG_IOMMU, "reg[%d] + offset %d\n",
+				  ext_inf->elem[i].index,
+				  ext_inf->elem[i].offset);
+			reg->reg[ext_inf->elem[i].index] +=
+				ext_inf->elem[i].offset;
+		}
+	}
+
+	return 0;
+}
+
+static int vcodec_reg_address_translate(struct vpu_subdev_data *data,
+					struct vpu_session *session,
+					struct vpu_reg *reg,
+					struct extra_info_for_iommu *ext_inf)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	enum FORMAT_TYPE type = reg->task->get_fmt(reg->reg);
+
+	if (type < FMT_TYPE_BUTT) {
+		const struct vpu_trans_info *info = &reg->trans[type];
+		const u8 *tbl = info->table;
+		int size = info->count;
+
+		return vcodec_bufid_to_iova(data, session, tbl, size, reg,
+					    ext_inf);
+	}
+
+	dev_err(pservice->dev, "found invalid format type!\n");
+	return -EINVAL;
+}
+
+static struct vpu_reg *reg_init(struct vpu_subdev_data *data,
+				struct vpu_session *session,
+				void __user *src, u32 size)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	int extra_size = 0;
+	struct extra_info_for_iommu extra_info;
+	struct vpu_reg *reg = kzalloc(sizeof(*reg) + data->reg_size,
+				      GFP_KERNEL);
+
+	vpu_debug_enter();
+
+	if (!reg) {
+		vpu_err("error: kzalloc failed\n");
+		return NULL;
+	}
+
+	if (size > data->reg_size) {
+		extra_size = size - data->reg_size;
+		size = data->reg_size;
+	}
+	reg->session = session;
+	reg->data = data;
+	reg->type = session->type;
+	reg->size = size;
+	reg->freq = VPU_FREQ_DEFAULT;
+	reg->task = &data->task_info[session->type];
+	reg->trans = data->trans_info;
+	reg->reg = (u32 *)&reg[1];
+	INIT_LIST_HEAD(&reg->session_link);
+	INIT_LIST_HEAD(&reg->status_link);
+
+	INIT_LIST_HEAD(&reg->mem_region_list);
+
+	if (copy_from_user(&reg->reg[0], (void __user *)src, size)) {
+		vpu_err("error: copy_from_user failed\n");
+		kfree(reg);
+		return NULL;
+	}
+
+	if (copy_from_user(&extra_info, (u8 *)src + size, extra_size)) {
+		vpu_err("error: copy_from_user failed\n");
+		kfree(reg);
+		return NULL;
+	}
+
+	mutex_lock(&pservice->reset_lock);
+	if (vcodec_reg_address_translate(data, session, reg, &extra_info) < 0) {
+		int i = 0;
+
+		mutex_unlock(&pservice->reset_lock);
+		vpu_err("error: translate reg address failed, dumping regs\n");
+		for (i = 0; i < size >> 2; i++)
+			dev_err(pservice->dev, "reg[%02d]: %08x\n",
+				i, reg->reg[i]);
+
+		kfree(reg);
+		return NULL;
+	}
+	mutex_unlock(&pservice->reset_lock);
+
+	mutex_lock(&pservice->lock);
+	list_add_tail(&reg->status_link, &pservice->waiting);
+	list_add_tail(&reg->session_link, &session->waiting);
+	mutex_unlock(&pservice->lock);
+
+	if (pservice->auto_freq && pservice->hw_ops->get_freq)
+		pservice->hw_ops->get_freq(data, reg);
+
+	vpu_debug_leave();
+
+	return reg;
+}
+
+static void reg_deinit(struct vpu_subdev_data *data, struct vpu_reg *reg)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	struct vcodec_mem_region *mem_region = NULL, *n;
+
+	list_del_init(&reg->session_link);
+	list_del_init(&reg->status_link);
+	if (reg == pservice->reg_codec)
+		pservice->reg_codec = NULL;
+	if (reg == pservice->reg_pproc)
+		pservice->reg_pproc = NULL;
+
+	/* release memory region attach to this registers table. */
+	list_for_each_entry_safe(mem_region, n,
+			&reg->mem_region_list, reg_lnk) {
+		vcodec_iommu_unmap_iommu(data->iommu_info, reg->session,
+					 mem_region->hdl);
+		vcodec_iommu_free(data->iommu_info, reg->session,
+				  mem_region->hdl);
+		list_del_init(&mem_region->reg_lnk);
+		kfree(mem_region);
+	}
+
+	kfree(reg);
+}
+
+static void reg_from_wait_to_run(struct vpu_service_info *pservice,
+				 struct vpu_reg *reg)
+{
+	vpu_debug_enter();
+	list_del_init(&reg->status_link);
+	list_add_tail(&reg->status_link, &pservice->running);
+
+	list_del_init(&reg->session_link);
+	list_add_tail(&reg->session_link, &reg->session->running);
+	vpu_debug_leave();
+}
+
+static void reg_copy_from_hw(struct vpu_reg *reg, u32 *src, u32 count)
+{
+	int i;
+	u32 *dst = reg->reg;
+
+	vpu_debug_enter();
+	for (i = 0; i < count; i++, src++)
+		*dst++ = readl_relaxed(src);
+
+	dst = (u32 *)&reg->reg[0];
+	for (i = 0; i < count; i++)
+		vpu_debug(DEBUG_GET_REG, "get reg[%02d] %08x\n", i, dst[i]);
+
+	vpu_debug_leave();
+}
+
+static void reg_from_run_to_done(struct vpu_subdev_data *data,
+				 struct vpu_reg *reg)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_hw_info *hw_info = data->hw_info;
+	struct vpu_task_info *task = reg->task;
+
+	vpu_debug_enter();
+
+	list_del_init(&reg->status_link);
+	list_add_tail(&reg->status_link, &pservice->done);
+
+	list_del_init(&reg->session_link);
+	list_add_tail(&reg->session_link, &reg->session->done);
+
+	switch (reg->type) {
+	case VPU_ENC: {
+		pservice->reg_codec = NULL;
+		reg_copy_from_hw(reg, data->enc_dev.regs, hw_info->enc_reg_num);
+		reg->reg[task->reg_irq] = pservice->irq_status;
+	} break;
+	case VPU_DEC: {
+		pservice->reg_codec = NULL;
+		reg_copy_from_hw(reg, data->dec_dev.regs, hw_info->dec_reg_num);
+
+		/* revert hack for decoded length */
+		if (task->reg_len > 0) {
+			int reg_len = task->reg_len;
+			u32 dec_get = reg->reg[reg_len];
+			s32 dec_length = dec_get - reg->dec_base;
+
+			vpu_debug(DEBUG_REGISTER,
+				  "dec_get %08x dec_length %d\n",
+				  dec_get, dec_length);
+			reg->reg[reg_len] = dec_length << 10;
+		}
+
+		reg->reg[task->reg_irq] = pservice->irq_status;
+	} break;
+	case VPU_PP: {
+		pservice->reg_pproc = NULL;
+		reg_copy_from_hw(reg, data->dec_dev.regs, hw_info->dec_reg_num);
+		writel_relaxed(0, data->dec_dev.regs + task->reg_irq);
+	} break;
+	case VPU_DEC_PP: {
+		u32 pipe_mode;
+		u32 *regs = data->dec_dev.regs;
+
+		pservice->reg_codec = NULL;
+		pservice->reg_pproc = NULL;
+
+		reg_copy_from_hw(reg, data->dec_dev.regs, hw_info->dec_reg_num);
+
+		/* NOTE: remove pp pipeline mode flag first */
+		pipe_mode = readl_relaxed(regs + task->reg_pipe);
+		pipe_mode &= ~task->pipe_mask;
+		writel_relaxed(pipe_mode, regs + task->reg_pipe);
+
+		/* revert hack for decoded length */
+		if (task->reg_len > 0) {
+			int reg_len = task->reg_len;
+			u32 dec_get = reg->reg[reg_len];
+			s32 dec_length = dec_get - reg->dec_base;
+
+			vpu_debug(DEBUG_REGISTER,
+				  "dec_get %08x dec_length %d\n",
+				  dec_get, dec_length);
+			reg->reg[reg_len] = dec_length << 10;
+		}
+
+		reg->reg[task->reg_irq] = pservice->irq_status;
+	} break;
+	default: {
+		vpu_err("error: copy reg from hw with unknown type %d\n",
+			reg->type);
+	} break;
+	}
+	vcodec_exit_mode(data);
+
+	atomic_sub(1, &reg->session->task_running);
+	atomic_sub(1, &pservice->total_running);
+	wake_up(&reg->session->wait);
+
+	vpu_debug_leave();
+}
+
+static void reg_copy_to_hw(struct vpu_subdev_data *data, struct vpu_reg *reg)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_task_info *task = reg->task;
+	struct vpu_hw_info *hw_info = data->hw_info;
+	int i;
+	u32 *src = (u32 *)&reg->reg[0];
+	u32 enable_mask = task->enable_mask;
+	u32 gating_mask = task->gating_mask;
+	u32 reg_en = task->reg_en;
+
+	vpu_debug_enter();
+
+	atomic_add(1, &pservice->total_running);
+	atomic_add(1, &reg->session->task_running);
+
+	if (pservice->auto_freq && pservice->hw_ops->set_freq)
+		pservice->hw_ops->set_freq(pservice, reg);
+
+	vcodec_enter_mode(data);
+
+	switch (reg->type) {
+	case VPU_ENC: {
+		u32 *dst = data->enc_dev.regs;
+		u32 base = 0;
+		u32 end  = hw_info->enc_reg_num;
+		/* u32 reg_gating = task->reg_gating; */
+
+		pservice->reg_codec = reg;
+
+		vpu_debug(DEBUG_TASK_INFO,
+			  "reg: base %3d end %d en %2d mask: en %x gate %x\n",
+			  base, end, reg_en, enable_mask, gating_mask);
+
+		VEPU_CLEAN_CACHE(dst);
+
+		if (debug & DEBUG_SET_REG)
+			for (i = base; i < end; i++)
+				vpu_debug(DEBUG_SET_REG, "set reg[%02d] %08x\n",
+					  i, src[i]);
+
+		/*
+		 * NOTE: encoder need to setup mode first
+		 */
+		writel_relaxed(src[reg_en] & enable_mask, dst + reg_en);
+
+		/* NOTE: encoder gating is not on enable register */
+		/* src[reg_gating] |= gating_mask; */
+
+		for (i = base; i < end; i++) {
+			if (i != reg_en)
+				writel_relaxed(src[i], dst + i);
+		}
+
+		writel(src[reg_en], dst + reg_en);
+		dsb(sy);
+
+		time_record(reg->task, 0);
+	} break;
+	case VPU_DEC: {
+		u32 *dst = data->dec_dev.regs;
+		u32 len = hw_info->dec_reg_num;
+		u32 base = hw_info->base_dec;
+		u32 end  = hw_info->end_dec;
+
+		pservice->reg_codec = reg;
+
+		vpu_debug(DEBUG_TASK_INFO,
+			  "reg: base %3d end %d en %2d mask: en %x gate %x\n",
+			  base, end, reg_en, enable_mask, gating_mask);
+
+		VDPU_CLEAN_CACHE(dst);
+
+		/* on rkvdec set cache size to 64byte */
+		if (pservice->dev_id == VCODEC_DEVICE_ID_RKVDEC) {
+			u32 *cache_base = dst + 0x100;
+			u32 val = (debug & DEBUG_CACHE_32B) ? (0x3) : (0x13);
+
+			writel_relaxed(val, cache_base + 0x07);
+			writel_relaxed(val, cache_base + 0x17);
+		}
+
+		if (debug & DEBUG_SET_REG)
+			for (i = 0; i < len; i++)
+				vpu_debug(DEBUG_SET_REG, "set reg[%02d] %08x\n",
+					  i, src[i]);
+		/*
+		 * NOTE: The end register is invalid. Do NOT write to it
+		 *       Also the base register must be written
+		 */
+		for (i = base; i < end; i++) {
+			if (i != reg_en)
+				writel_relaxed(src[i], dst + i);
+		}
+
+		if (pservice->hw_var && pservice->hw_var->config)
+			pservice->hw_var->config(data);
+
+		writel(src[reg_en] | gating_mask, dst + reg_en);
+		dsb(sy);
+
+		time_record(reg->task, 0);
+	} break;
+	case VPU_PP: {
+		u32 *dst = data->dec_dev.regs;
+		u32 base = hw_info->base_pp;
+		u32 end  = hw_info->end_pp;
+
+		pservice->reg_pproc = reg;
+
+		vpu_debug(DEBUG_TASK_INFO,
+			  "reg: base %3d end %d en %2d mask: en %x gate %x\n",
+			  base, end, reg_en, enable_mask, gating_mask);
+
+		if (debug & DEBUG_SET_REG)
+			for (i = base; i < end; i++)
+				vpu_debug(DEBUG_SET_REG, "set reg[%02d] %08x\n",
+					  i, src[i]);
+
+		for (i = base; i < end; i++) {
+			if (i != reg_en)
+				writel_relaxed(src[i], dst + i);
+		}
+
+		writel(src[reg_en] | gating_mask, dst + reg_en);
+		dsb(sy);
+
+		time_record(reg->task, 0);
+	} break;
+	case VPU_DEC_PP: {
+		u32 *dst = data->dec_dev.regs;
+		u32 base = hw_info->base_dec_pp;
+		u32 end  = hw_info->end_dec_pp;
+
+		pservice->reg_codec = reg;
+		pservice->reg_pproc = reg;
+
+		vpu_debug(DEBUG_TASK_INFO,
+			  "reg: base %3d end %d en %2d mask: en %x gate %x\n",
+			  base, end, reg_en, enable_mask, gating_mask);
+
+		/* VDPU_SOFT_RESET(dst); */
+		VDPU_CLEAN_CACHE(dst);
+
+		if (debug & DEBUG_SET_REG)
+			for (i = base; i < end; i++)
+				vpu_debug(DEBUG_SET_REG, "set reg[%02d] %08x\n",
+					  i, src[i]);
+
+		for (i = base; i < end; i++) {
+			if (i != reg_en)
+				writel_relaxed(src[i], dst + i);
+		}
+
+		/* NOTE: dec output must be disabled */
+
+		writel(src[reg_en] | gating_mask, dst + reg_en);
+		dsb(sy);
+
+		time_record(reg->task, 0);
+	} break;
+	default: {
+		vpu_err("error: unsupport session type %d", reg->type);
+
+		atomic_sub(1, &pservice->total_running);
+		atomic_sub(1, &reg->session->task_running);
+	} break;
+	}
+
+	vpu_debug_leave();
+}
+
+static void try_set_reg(struct vpu_subdev_data *data)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	int reset_request = atomic_read(&pservice->reset_request);
+	struct vpu_reg *reg_codec = pservice->reg_codec;
+	struct vpu_reg *reg_pproc = pservice->reg_pproc;
+	bool change_able = (!reg_codec) && (!reg_pproc);
+
+	vpu_debug_enter();
+
+	mutex_lock(&pservice->shutdown_lock);
+	if (atomic_read(&pservice->service_on) == 0) {
+		mutex_unlock(&pservice->shutdown_lock);
+		return;
+	}
+
+	if (change_able && reset_request) {
+		vpu_service_power_on(data, pservice);
+		mutex_lock(&pservice->reset_lock);
+		vpu_reset(data);
+		mutex_unlock(&pservice->reset_lock);
+	}
+
+	if (!list_empty(&pservice->waiting)) {
+		int can_set = 0;
+		struct vpu_reg *reg = list_entry(pservice->waiting.next,
+				struct vpu_reg, status_link);
+
+		vpu_service_power_on(data, pservice);
+
+		if (change_able) {
+			switch (reg->type) {
+			case VPU_ENC:
+			case VPU_DEC:
+			case VPU_PP:
+			case VPU_DEC_PP: {
+				can_set = 1;
+			} break;
+			default: {
+				dev_err(pservice->dev,
+					"undefined reg type %d\n",
+					reg->type);
+			} break;
+			}
+		}
+
+		if (can_set) {
+			reg_from_wait_to_run(pservice, reg);
+			reg_copy_to_hw(reg->data, reg);
+		}
+	} else {
+		if (pservice->hw_ops->reduce_freq)
+			pservice->hw_ops->reduce_freq(pservice);
+	}
+
+	mutex_unlock(&pservice->shutdown_lock);
+	vpu_debug_leave();
+}
+
+static void vpu_set_register_work(struct work_struct *work_s)
+{
+	struct vpu_subdev_data *data = container_of(work_s,
+						    struct vpu_subdev_data,
+						    set_work);
+	struct vpu_service_info *pservice = data->pservice;
+
+	mutex_lock(&pservice->lock);
+	try_set_reg(data);
+	mutex_unlock(&pservice->lock);
+}
+
+static int return_reg(struct vpu_subdev_data *data,
+		      struct vpu_reg *reg, u32 __user *dst)
+{
+	struct vpu_hw_info *hw_info = data->hw_info;
+	size_t size = reg->size;
+	u32 base;
+
+	vpu_debug_enter();
+	switch (reg->type) {
+	case VPU_ENC: {
+		base = 0;
+	} break;
+	case VPU_DEC: {
+		base = hw_info->base_dec_pp;
+	} break;
+	case VPU_PP: {
+		base = hw_info->base_pp;
+	} break;
+	case VPU_DEC_PP: {
+		base = hw_info->base_dec_pp;
+	} break;
+	default: {
+		vpu_err("error: copy reg to user with unknown type %d\n",
+			reg->type);
+		return -EFAULT;
+	} break;
+	}
+
+	if (copy_to_user(dst, &reg->reg[base], size)) {
+		vpu_err("error: copy_to_user failed\n");
+		return -EFAULT;
+	}
+
+	reg_deinit(data, reg);
+	vpu_debug_leave();
+	return 0;
+}
+
+static long vpu_service_ioctl(struct file *filp, unsigned int cmd,
+			      unsigned long arg)
+{
+	struct vpu_subdev_data *data =
+		container_of(filp->f_path.dentry->d_inode->i_cdev,
+			     struct vpu_subdev_data, cdev);
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_session *session = (struct vpu_session *)filp->private_data;
+
+	vpu_debug_enter();
+
+	vpu_debug(DEBUG_IOCTL, "cmd %x, VPU_IOC_SET_CLIENT_TYPE %x\n", cmd,
+		  (u32)VPU_IOC_SET_CLIENT_TYPE);
+
+	if (NULL == session)
+		return -EINVAL;
+
+	switch (cmd) {
+	case VPU_IOC_SET_CLIENT_TYPE: {
+		int secure_mode;
+
+		secure_mode = (arg & 0xffff0000) >> 16;
+		session->type = (enum VPU_CLIENT_TYPE)(arg & 0xffff);
+		atomic_set(&pservice->secure_mode, secure_mode);
+
+		session->type = (enum VPU_CLIENT_TYPE)arg;
+		vpu_debug(DEBUG_IOCTL, "pid %d set client type %d, secure mode = %d\n",
+			  session->pid, session->type, secure_mode);
+	} break;
+	case VPU_IOC_GET_HW_FUSE_STATUS: {
+		struct vpu_request req;
+
+		vpu_debug(DEBUG_IOCTL, "pid %d get hw status %d\n",
+			  session->pid, session->type);
+		if (copy_from_user(&req, (void __user *)arg, sizeof(req))) {
+			vpu_err("error: get hw status copy_from_user failed\n");
+			return -EFAULT;
+		} else {
+			void *config = (session->type != VPU_ENC) ?
+				       ((void *)&pservice->dec_config) :
+				       ((void *)&pservice->enc_config);
+			size_t size = (session->type != VPU_ENC) ?
+				      (sizeof(struct vpu_dec_config)) :
+				      (sizeof(struct vpu_enc_config));
+			if (copy_to_user((void __user *)req.req,
+					 config, size)) {
+				vpu_err("error: get hw status copy_to_user failed type %d\n",
+					session->type);
+				return -EFAULT;
+			}
+		}
+	} break;
+	case VPU_IOC_SET_REG: {
+		struct vpu_request req;
+		struct vpu_reg *reg;
+
+		vpu_debug(DEBUG_IOCTL, "pid %d set reg type %d\n",
+			  session->pid, session->type);
+
+		if (atomic_read(&pservice->secure_mode) == 1) {
+			vpu_service_power_on(data, pservice);
+			pservice->wait_secure_isr = &session->wait;
+			if (!pservice->secure_isr &&
+			    !pservice->secure_irq_status)
+				enable_irq(data->irq_dec);
+			break;
+		}
+
+		if (copy_from_user(&req, (void __user *)arg,
+				   sizeof(struct vpu_request))) {
+			vpu_err("error: set reg copy_from_user failed\n");
+			return -EFAULT;
+		}
+
+		reg = reg_init(data, session, (void __user *)req.req, req.size);
+		if (NULL == reg) {
+			return -EFAULT;
+		} else {
+			queue_work(pservice->set_workq, &data->set_work);
+		}
+	} break;
+	case VPU_IOC_GET_REG: {
+		struct vpu_request req;
+		struct vpu_reg *reg;
+		int ret;
+
+		vpu_debug(DEBUG_IOCTL, "pid %d get reg type %d\n",
+			  session->pid, session->type);
+
+		if (atomic_read(&pservice->secure_mode) == 1) {
+			ret = wait_event_timeout(session->wait,
+						 pservice->secure_isr,
+						 VPU_TIMEOUT_DELAY);
+			if (ret < 0)
+				pr_info("warning: secure wait timeout\n");
+			pservice->secure_isr = false;
+			break;
+		}
+
+		if (copy_from_user(&req, (void __user *)arg,
+				   sizeof(struct vpu_request))) {
+			vpu_err("error: get reg copy_from_user failed\n");
+			return -EFAULT;
+		}
+
+		ret = wait_event_timeout(session->wait,
+					 !list_empty(&session->done),
+					 VPU_TIMEOUT_DELAY);
+
+		while (atomic_read(&pservice->reset_request))
+			msleep(10);
+
+		if (!list_empty(&session->done)) {
+			if (ret < 0)
+				vpu_err("warning: pid %d wait task error ret %d\n",
+					session->pid, ret);
+			ret = 0;
+		} else {
+			if (unlikely(ret < 0)) {
+				vpu_err("error: pid %d wait task ret %d\n",
+					session->pid, ret);
+			} else if (ret == 0) {
+				vpu_err("error: pid %d wait %d task done timeout\n",
+					session->pid,
+					atomic_read(&session->task_running));
+				ret = -ETIMEDOUT;
+			}
+		}
+
+		if (ret < 0) {
+			int task_running = atomic_read(&session->task_running);
+
+			/*
+			 * if reaching here, no irq return, and need to do
+			 * vpu_reset immediately. there is no need to care
+			 * reset_lock at this situation.
+			 */
+			mutex_lock(&pservice->lock);
+			if (task_running) {
+				atomic_set(&session->task_running, 0);
+				atomic_sub(task_running,
+					   &pservice->total_running);
+				dev_err(pservice->dev,
+					"%d task is running but not return, reset hardware...",
+					task_running);
+				vpu_reset(data);
+			}
+			vpu_service_session_clear(data, session);
+			mutex_unlock(&pservice->lock);
+
+			return ret;
+		}
+		mutex_lock(&pservice->lock);
+		reg = list_entry(session->done.next,
+				 struct vpu_reg, session_link);
+		return_reg(data, reg, (u32 __user *)req.req);
+		mutex_unlock(&pservice->lock);
+	} break;
+	case VPU_IOC_PROBE_IOMMU_STATUS: {
+		/* It must be 1, keeping backward compatibility */
+		int iommu_enable = 1;
+
+		vpu_debug(DEBUG_IOCTL, "VPU_IOC_PROBE_IOMMU_STATUS\n");
+
+		if (copy_to_user((void __user *)arg,
+				 &iommu_enable, sizeof(int))) {
+			vpu_err("error: iommu status copy_to_user failed\n");
+			return -EFAULT;
+		}
+	} break;
+	case VPU_IOC_SET_DRIVER_DATA: {
+		u32 val;
+
+		if (copy_from_user(&val, (void __user *)arg,
+				   sizeof(int))) {
+			vpu_err("error: COMPAT_VPU_IOC_SET_DRIVER_DATA copy_from_user failed\n");
+			return -EFAULT;
+		}
+
+		if (pservice->grf)
+			regmap_write(pservice->grf, 0x5d8, val);
+	} break;
+	default: {
+		vpu_err("error: unknow vpu service ioctl cmd %x\n", cmd);
+		return -ENOIOCTLCMD;
+	} break;
+	}
+
+	vpu_debug_leave();
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+#define VPU_IOC_SET_CLIENT_TYPE32          _IOW(VPU_IOC_MAGIC, 1, u32)
+#define VPU_IOC_GET_HW_FUSE_STATUS32       _IOW(VPU_IOC_MAGIC, 2, \
+						compat_ulong_t)
+#define VPU_IOC_SET_REG32                  _IOW(VPU_IOC_MAGIC, 3, \
+						compat_ulong_t)
+#define VPU_IOC_GET_REG32                  _IOW(VPU_IOC_MAGIC, 4, \
+						compat_ulong_t)
+#define VPU_IOC_PROBE_IOMMU_STATUS32       _IOR(VPU_IOC_MAGIC, 5, u32)
+#define VPU_IOC_SET_DRIVER_DATA32		_IOW(VPU_IOC_MAGIC, 64, u32)
+
+static long native_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long ret = -ENOIOCTLCMD;
+
+	if (file->f_op->unlocked_ioctl)
+		ret = file->f_op->unlocked_ioctl(file, cmd, arg);
+
+	return ret;
+}
+
+static long compat_vpu_service_ioctl(struct file *file, unsigned int cmd,
+				     unsigned long arg)
+{
+	struct vpu_request req;
+	void __user *up = compat_ptr(arg);
+	int compatible_arg = 1;
+	long err = 0;
+
+	vpu_debug_enter();
+	vpu_debug(DEBUG_IOCTL, "cmd %x, VPU_IOC_SET_CLIENT_TYPE32 %x\n", cmd,
+		  (u32)VPU_IOC_SET_CLIENT_TYPE32);
+	/* First, convert the command. */
+	switch (cmd) {
+	case VPU_IOC_SET_CLIENT_TYPE32:
+		cmd = VPU_IOC_SET_CLIENT_TYPE;
+		break;
+	case VPU_IOC_GET_HW_FUSE_STATUS32:
+		cmd = VPU_IOC_GET_HW_FUSE_STATUS;
+		break;
+	case VPU_IOC_SET_REG32:
+		cmd = VPU_IOC_SET_REG;
+		break;
+	case VPU_IOC_GET_REG32:
+		cmd = VPU_IOC_GET_REG;
+		break;
+	case VPU_IOC_PROBE_IOMMU_STATUS32:
+		cmd = VPU_IOC_PROBE_IOMMU_STATUS;
+		break;
+	case VPU_IOC_SET_DRIVER_DATA32:
+		cmd = VPU_IOC_SET_DRIVER_DATA;
+		break;
+	}
+
+	switch (cmd) {
+	case VPU_IOC_SET_REG:
+	case VPU_IOC_GET_REG:
+	case VPU_IOC_GET_HW_FUSE_STATUS: {
+		compat_uptr_t req_ptr;
+		struct compat_vpu_request __user *req32 = NULL;
+
+		req32 = (struct compat_vpu_request __user *)up;
+		memset(&req, 0, sizeof(req));
+
+		if (get_user(req_ptr, &req32->req) ||
+		    get_user(req.size, &req32->size)) {
+			vpu_err("error: compat get hw status copy_from_user failed\n");
+			return -EFAULT;
+		}
+		req.req = compat_ptr(req_ptr);
+		compatible_arg = 0;
+	} break;
+	}
+
+	if (compatible_arg) {
+		err = native_ioctl(file, cmd, (unsigned long)up);
+	} else {
+		mm_segment_t old_fs = get_fs();
+
+		set_fs(KERNEL_DS);
+		err = native_ioctl(file, cmd, (unsigned long)&req);
+		set_fs(old_fs);
+	}
+
+	vpu_debug_leave();
+	return err;
+}
+#endif
+
+static int vpu_service_check_hw(struct vpu_subdev_data *data)
+{
+	int ret = -EINVAL, i = 0;
+	u32 hw_id = readl_relaxed(data->regs);
+
+	hw_id = (hw_id >> 16) & 0xFFFF;
+	dev_info(data->dev, "checking hw id %x\n", hw_id);
+	data->hw_info = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(vcodec_info_set); i++) {
+		const struct vcodec_info *info = &vcodec_info_set[i];
+
+		if (hw_id == info->hw_id) {
+			data->hw_id = info->hw_id;
+			data->hw_info = info->hw_info;
+			data->task_info = info->task_info;
+			data->trans_info = info->trans_info;
+			ret = 0;
+			break;
+		}
+	}
+	return ret;
+}
+
+static int vpu_service_open(struct inode *inode, struct file *filp)
+{
+	struct vpu_subdev_data *data = container_of(
+			inode->i_cdev, struct vpu_subdev_data, cdev);
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_session *session = NULL;
+
+	vpu_debug_enter();
+
+	session = kzalloc(sizeof(*session), GFP_KERNEL);
+	if (!session) {
+		vpu_err("error: unable to allocate memory for vpu_session.");
+		return -ENOMEM;
+	}
+
+	data->iommu_info->debug_level = debug;
+
+	session->type	= VPU_TYPE_BUTT;
+	session->pid	= current->pid;
+	INIT_LIST_HEAD(&session->waiting);
+	INIT_LIST_HEAD(&session->running);
+	INIT_LIST_HEAD(&session->done);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	atomic_set(&session->task_running, 0);
+	mutex_lock(&pservice->lock);
+	list_add_tail(&session->list_session, &pservice->session);
+	filp->private_data = (void *)session;
+	mutex_unlock(&pservice->lock);
+
+	dev_dbg(pservice->dev, "dev opened\n");
+	vpu_debug_leave();
+	return nonseekable_open(inode, filp);
+}
+
+static int vpu_service_release(struct inode *inode, struct file *filp)
+{
+	struct vpu_subdev_data *data = container_of(
+			inode->i_cdev, struct vpu_subdev_data, cdev);
+	struct vpu_service_info *pservice = data->pservice;
+	int task_running;
+	struct vpu_session *session = (struct vpu_session *)filp->private_data;
+
+	vpu_debug_enter();
+	if (NULL == session)
+		return -EINVAL;
+
+	task_running = atomic_read(&session->task_running);
+	if (task_running) {
+		dev_err(pservice->dev,
+			"error: session %d still has %d task running when closing\n",
+			session->pid, task_running);
+		msleep(50);
+	}
+	wake_up(&session->wait);
+
+	if (atomic_read(&pservice->secure_mode)) {
+		atomic_set(&pservice->secure_mode, 0);
+		if (!pservice->secure_irq_status) {
+			enable_irq(data->irq_dec);
+			pservice->secure_irq_status = true;
+		}
+	}
+
+	mutex_lock(&pservice->lock);
+	/* remove this filp from the asynchronusly notified filp's */
+	list_del_init(&session->list_session);
+	vpu_service_session_clear(data, session);
+	vcodec_iommu_clear(data->iommu_info, session);
+	kfree(session);
+	filp->private_data = NULL;
+	mutex_unlock(&pservice->lock);
+
+	dev_info(pservice->dev, "closed\n");
+	vpu_debug_leave();
+	return 0;
+}
+
+static const struct file_operations vpu_service_fops = {
+	.unlocked_ioctl = vpu_service_ioctl,
+	.open		= vpu_service_open,
+	.release	= vpu_service_release,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = compat_vpu_service_ioctl,
+#endif
+};
+
+static irqreturn_t vdpu_irq(int irq, void *dev_id);
+static irqreturn_t vdpu_isr(int irq, void *dev_id);
+static irqreturn_t vepu_irq(int irq, void *dev_id);
+static irqreturn_t vepu_isr(int irq, void *dev_id);
+static void get_hw_info(struct vpu_subdev_data *data);
+
+static struct device *rockchip_get_sysmmu_dev(const char *compt)
+{
+	struct device_node *dn = NULL;
+	struct platform_device *pd = NULL;
+	struct device *ret = NULL;
+
+	dn = of_find_compatible_node(NULL, NULL, compt);
+	if (!dn) {
+		pr_err("can't find device node %s \r\n", compt);
+		return NULL;
+	}
+
+	pd = of_find_device_by_node(dn);
+	if (!pd) {
+		pr_err("can't find platform device in device node %s\n", compt);
+		return  NULL;
+	}
+	ret = &pd->dev;
+
+	return ret;
+}
+
+/* special hw ops */
+static void vcodec_power_on_default(struct vpu_service_info *pservice)
+{
+#if VCODEC_CLOCK_ENABLE
+	if (pservice->aclk_vcodec)
+		clk_prepare_enable(pservice->aclk_vcodec);
+	if (pservice->hclk_vcodec)
+		clk_prepare_enable(pservice->hclk_vcodec);
+	if (pservice->clk_core)
+		clk_prepare_enable(pservice->clk_core);
+	if (pservice->clk_cabac)
+		clk_prepare_enable(pservice->clk_cabac);
+	if (pservice->pd_video)
+		clk_prepare_enable(pservice->pd_video);
+#endif
+	pm_runtime_get_sync(pservice->dev);
+}
+
+static void vcodec_power_on_rk312x(struct vpu_service_info *pservice)
+{
+#define BIT_VCODEC_CLK_SEL	BIT(10)
+	if (of_machine_is_compatible("rockchip,rk3126") ||
+	    of_machine_is_compatible("rockchip,rk3128"))
+		regmap_write(pservice->grf, RK312X_GRF_SOC_CON1,
+			     BIT_VCODEC_CLK_SEL |
+			     (BIT_VCODEC_CLK_SEL << 16));
+
+	vcodec_power_on_default(pservice);
+}
+
+static void vcodec_power_on_rk322x(struct vpu_service_info *pservice)
+{
+	struct devfreq_dev_status *stat;
+	unsigned long rate = 300 * MHZ;
+
+	if (pservice->dev_id == VCODEC_DEVICE_ID_RKVDEC)
+		rate = 500 * MHZ;
+
+	if (pservice->devfreq) {
+		stat = &pservice->devfreq->last_status;
+		stat->busy_time = 1;
+		stat->total_time = 1;
+		rkvdec_dvfs_set_clk(pservice,
+				    rate,
+				    300 * MHZ,
+				    300 * MHZ);
+	} else {
+		clk_set_rate(pservice->aclk_vcodec, rate);
+		clk_set_rate(pservice->clk_core, 300 * MHZ);
+		clk_set_rate(pservice->clk_cabac, 300 * MHZ);
+	}
+
+	vcodec_power_on_default(pservice);
+}
+
+static void vcodec_power_on_rk3328(struct vpu_service_info *pservice)
+{
+	struct devfreq_dev_status *stat;
+
+	if (pservice->devfreq) {
+		stat = &pservice->devfreq->last_status;
+		stat->busy_time = 1;
+		stat->total_time = 1;
+		rkvdec_dvfs_set_clk(pservice,
+				    RK3328_VCODEC_RATE_ON,
+				    RK3328_CODE_RATE_ON,
+				    RK3328_CABAC_RATE_ON);
+	} else {
+		clk_set_rate(pservice->aclk_vcodec, RK3328_VCODEC_RATE_ON);
+		clk_set_rate(pservice->clk_core, RK3328_CODE_RATE_ON);
+		clk_set_rate(pservice->clk_cabac, RK3328_CABAC_RATE_ON);
+	}
+
+	vcodec_power_on_default(pservice);
+}
+
+static void vcodec_power_off_default(struct vpu_service_info *pservice)
+{
+	if (pservice->pd_video)
+		clk_disable_unprepare(pservice->pd_video);
+	if (pservice->hclk_vcodec)
+		clk_disable_unprepare(pservice->hclk_vcodec);
+	if (pservice->aclk_vcodec)
+		clk_disable_unprepare(pservice->aclk_vcodec);
+	if (pservice->clk_core)
+		clk_disable_unprepare(pservice->clk_core);
+	if (pservice->clk_cabac)
+		clk_disable_unprepare(pservice->clk_cabac);
+	pm_runtime_put(pservice->dev);
+}
+
+static void vcodec_power_off_rk322x(struct vpu_service_info *pservice)
+{
+	struct devfreq_dev_status *stat;
+
+	vcodec_power_off_default(pservice);
+
+	if (pservice->devfreq) {
+		stat = &pservice->devfreq->last_status;
+		stat->busy_time = 0;
+		stat->total_time = 1;
+		rkvdec_dvfs_set_clk(pservice,
+				    get_div_rate(pservice->aclk_vcodec, 32),
+				    get_div_rate(pservice->clk_core, 32),
+				    get_div_rate(pservice->clk_cabac, 32));
+	} else {
+		clk_set_rate(pservice->aclk_vcodec,
+			     get_div_rate(pservice->aclk_vcodec, 32));
+		clk_set_rate(pservice->clk_core,
+			     get_div_rate(pservice->clk_core, 32));
+		clk_set_rate(pservice->clk_cabac,
+			     get_div_rate(pservice->clk_cabac, 32));
+	}
+}
+
+static void vcodec_power_off_rk3328(struct vpu_service_info *pservice)
+{
+	struct devfreq_dev_status *stat;
+
+	vcodec_power_off_default(pservice);
+
+	if (pservice->devfreq) {
+		stat = &pservice->devfreq->last_status;
+		stat->busy_time = 0;
+		stat->total_time = 1;
+		rkvdec_dvfs_set_clk(pservice,
+				    RK3328_VCODEC_RATE_OFF,
+				    RK3328_CODE_RATE_OFF,
+				    RK3328_CABAC_RATE_OFF);
+	} else {
+		clk_set_rate(pservice->aclk_vcodec, RK3328_VCODEC_RATE_OFF);
+		clk_set_rate(pservice->clk_core, RK3328_CODE_RATE_OFF);
+		clk_set_rate(pservice->clk_cabac, RK3328_CABAC_RATE_OFF);
+	}
+}
+
+static void vcodec_get_reg_freq_default(struct vpu_subdev_data *data,
+					struct vpu_reg *reg)
+{
+	reg->freq = VPU_FREQ_300M;
+
+	if (data->hw_id == HEVC_ID) {
+		if (reg_probe_hevc_y_stride(reg) > 60000)
+			reg->freq = VPU_FREQ_400M;
+	}
+
+	if (reg->type == VPU_PP)
+		reg->freq = VPU_FREQ_400M;
+}
+
+static void vcodec_get_reg_freq_rk3288(struct vpu_subdev_data *data,
+				       struct vpu_reg *reg)
+{
+	vcodec_get_reg_freq_default(data, reg);
+
+	if (reg->type == VPU_DEC || reg->type == VPU_DEC_PP) {
+		if (reg_check_fmt(reg) == VPU_DEC_FMT_H264) {
+			if (reg_probe_width(reg) > 2560) {
+				/*
+				 * raise frequency for resolution larger
+				 * than 1440p avc.
+				 */
+				reg->freq = VPU_FREQ_600M;
+			}
+		} else if (reg_check_interlace(reg)) {
+			reg->freq = VPU_FREQ_400M;
+		}
+	}
+}
+
+static void vcodec_set_freq_default(struct vpu_service_info *pservice,
+				    struct vpu_reg *reg)
+{
+	enum VPU_FREQ curr = atomic_read(&pservice->freq_status);
+
+	if (curr == reg->freq)
+		return;
+
+	atomic_set(&pservice->freq_status, reg->freq);
+	switch (reg->freq) {
+	case VPU_FREQ_200M: {
+		clk_set_rate(pservice->aclk_vcodec, 200 * MHZ);
+	} break;
+	case VPU_FREQ_266M: {
+		clk_set_rate(pservice->aclk_vcodec, 266 * MHZ);
+	} break;
+	case VPU_FREQ_300M: {
+		clk_set_rate(pservice->aclk_vcodec, 300 * MHZ);
+	} break;
+	case VPU_FREQ_400M: {
+		clk_set_rate(pservice->aclk_vcodec, 400 * MHZ);
+	} break;
+	case VPU_FREQ_500M: {
+		clk_set_rate(pservice->aclk_vcodec, 500 * MHZ);
+	} break;
+	case VPU_FREQ_600M: {
+		clk_set_rate(pservice->aclk_vcodec, 600 * MHZ);
+	} break;
+	default: {
+		clk_set_rate(pservice->aclk_vcodec,
+			     pservice->aclk_vcodec_default_rate);
+		clk_set_rate(pservice->clk_core,
+			     pservice->clk_core_default_rate);
+		clk_set_rate(pservice->clk_cabac,
+			     pservice->clk_cabac_default_rate);
+		break;
+	}
+	}
+}
+
+static void rkvdec_set_clk(struct vpu_service_info *pservice,
+			   unsigned long vcodec_rate,
+			   unsigned long core_rate,
+			   unsigned long cabac_rate,
+			   unsigned int event)
+{
+	static unsigned int div;
+
+	mutex_lock(&pservice->set_clk_lock);
+
+	switch (event) {
+	case EVENT_POWER_ON:
+		clk_set_rate(pservice->aclk_vcodec, pservice->vcodec_rate);
+		clk_set_rate(pservice->clk_core, pservice->core_rate);
+		clk_set_rate(pservice->clk_cabac, pservice->cabac_rate);
+		div = 0;
+		break;
+	case EVENT_POWER_OFF:
+		clk_set_rate(pservice->aclk_vcodec, vcodec_rate);
+		clk_set_rate(pservice->clk_core, core_rate);
+		clk_set_rate(pservice->clk_cabac, cabac_rate);
+		div = 0;
+		break;
+	case EVENT_ADJUST:
+		if (!div) {
+			clk_set_rate(pservice->aclk_vcodec, vcodec_rate);
+			clk_set_rate(pservice->clk_core, core_rate);
+			clk_set_rate(pservice->clk_cabac, cabac_rate);
+		} else {
+			clk_set_rate(pservice->aclk_vcodec, vcodec_rate / div);
+			clk_set_rate(pservice->clk_core, vcodec_rate / div);
+			clk_set_rate(pservice->clk_cabac, vcodec_rate / div);
+		}
+		pservice->vcodec_rate = vcodec_rate;
+		pservice->core_rate = core_rate;
+		pservice->cabac_rate = cabac_rate;
+		break;
+	case EVENT_THERMAL:
+		div = pservice->vcodec_rate / vcodec_rate;
+		if (div > 4)
+			div = 4;
+		if (div) {
+			clk_set_rate(pservice->aclk_vcodec,
+				     pservice->vcodec_rate / div);
+			clk_set_rate(pservice->clk_core,
+				     pservice->core_rate / div);
+			clk_set_rate(pservice->clk_cabac,
+				     pservice->cabac_rate / div);
+		}
+		break;
+	}
+
+	mutex_unlock(&pservice->set_clk_lock);
+}
+
+static void vcodec_set_freq_rk3328(struct vpu_service_info *pservice,
+				    struct vpu_reg *reg)
+{
+	enum VPU_FREQ curr = atomic_read(&pservice->freq_status);
+
+	if (curr == reg->freq)
+		return;
+
+	if (pservice->dev_id == VCODEC_DEVICE_ID_RKVDEC) {
+		if (reg->reg[1] & 0x00800000) {
+			if (rkv_dec_get_fmt(reg->reg) == FMT_H264D)
+				rkvdec_set_clk(pservice, 400 * MHZ, 250 * MHZ,
+					       400 * MHZ, EVENT_ADJUST);
+			else
+				rkvdec_set_clk(pservice, 500 * MHZ, 250 * MHZ,
+					       400 * MHZ, EVENT_ADJUST);
+		} else {
+			if (rkv_dec_get_fmt(reg->reg) == FMT_H264D)
+				rkvdec_set_clk(pservice, 400 * MHZ, 300 * MHZ,
+					       400 * MHZ, EVENT_ADJUST);
+			else
+				rkvdec_set_clk(pservice, 500 * MHZ, 300 * MHZ,
+					       400 * MHZ, EVENT_ADJUST);
+		}
+	}
+}
+
+static void vcodec_set_freq_rk322x(struct vpu_service_info *pservice,
+				   struct vpu_reg *reg)
+{
+	enum VPU_FREQ curr = atomic_read(&pservice->freq_status);
+
+	if (curr == reg->freq)
+		return;
+
+	/*
+	 * special process for rk322x
+	 * rk322x rkvdec has more clocks to set
+	 * vpu/vpu2 still only need to set aclk
+	 */
+	if (pservice->dev_id == VCODEC_DEVICE_ID_RKVDEC) {
+		rkvdec_set_clk(pservice,
+			       500 * MHZ,
+			       300 * MHZ,
+			       300 * MHZ,
+			       EVENT_ADJUST);
+	} else {
+		rkvdec_set_clk(pservice,
+			       300 * MHZ,
+			       300 * MHZ,
+			       300 * MHZ,
+			       EVENT_ADJUST);
+
+	}
+}
+
+#ifdef CONFIG_IOMMU_API
+static inline void platform_set_sysmmu(struct device *iommu,
+				       struct device *dev)
+{
+	dev->archdata.iommu = iommu;
+}
+#else
+static inline void platform_set_sysmmu(struct device *iommu,
+				       struct device *dev)
+{
+}
+#endif
+
+#define IOMMU_GET_BUS_ID(x)    (((x) >> 6) & 0x1f)
+
+static int
+_vcodec_sys_fault_hdl(struct device *dev, unsigned long iova, int status)
+{
+	struct platform_device *pdev;
+	struct vpu_service_info *pservice;
+	struct vpu_subdev_data *data;
+	struct vpu_session *session = NULL;
+
+	vpu_debug_enter();
+
+	if (!dev) {
+		pr_err("invalid NULL dev\n");
+		return 0;
+	}
+
+	pdev = container_of(dev, struct platform_device, dev);
+	if (!pdev) {
+		pr_err("invalid NULL platform_device\n");
+		return 0;
+	}
+
+	data = platform_get_drvdata(pdev);
+	if (!data) {
+		pr_err("invalid NULL vpu_subdev_data\n");
+		return 0;
+	}
+
+	pservice = data->pservice;
+	if (!pservice) {
+		pr_err("invalid NULL vpu_service_info\n");
+		return 0;
+	}
+
+	session = list_first_entry(&pservice->session,
+				   struct vpu_session, list_session);
+
+	if (pservice->reg_codec) {
+		struct vpu_reg *reg = pservice->reg_codec;
+		struct vcodec_mem_region *mem = NULL, *n = NULL;
+		int i = 0;
+
+		dev_err(dev, "vcodec, fault addr 0x%08lx status %x\n", iova,
+			status);
+		if (!list_empty(&reg->mem_region_list)) {
+			list_for_each_entry_safe(mem, n, &reg->mem_region_list,
+						 reg_lnk) {
+				unsigned long tmp_iova = mem->iova;
+
+				dev_err(dev, "vcodec, reg[%3d] mem region [%02d] 0x%lx %lx\n",
+					mem->reg_idx, i, tmp_iova, mem->len);
+				i++;
+			}
+		} else {
+			dev_err(dev, "no memory region mapped\n");
+		}
+
+		if (reg->data) {
+			struct vpu_subdev_data *data = reg->data;
+			u32 *base;
+			u32 len;
+
+			if (reg->session->type == VPU_ENC) {
+				base = (u32 *)data->enc_dev.regs;
+				len = data->hw_info->enc_reg_num;
+				dev_err(dev, "dumping enc register set:\n");
+			} else {
+				base = (u32 *)data->dec_dev.regs;
+				len = data->hw_info->dec_reg_num;
+				dev_err(dev, "dumping dec register set:\n");
+			}
+
+			for (i = 0; i < len; i++)
+				dev_err(dev, "reg[%02d] %08x\n",
+					i, readl_relaxed(base + i));
+		}
+
+		set_bit(MMU_PAGEFAULT, &data->state);
+
+		/*
+		 * defeat workaround, invalidate address generated when rk322x
+		 * vdec pre-fetch colmv data.
+		 */
+		if (IOMMU_GET_BUS_ID(status) == 2 && data->pa_hdl >= 0) {
+			/* avoid another page fault occur after page fault */
+			if (data->pa_iova != -1)
+				vcodec_iommu_unmap_iommu_with_iova(data->iommu_info,
+								   session,
+								   data->pa_hdl);
+
+			/* get the page align iova */
+			data->pa_iova = round_down(iova, IOMMU_PAGE_SIZE);
+
+			vcodec_iommu_map_iommu_with_iova(data->iommu_info,
+							 session,
+							 data->pa_hdl,
+							 data->pa_iova,
+							 IOMMU_PAGE_SIZE);
+		} else {
+			clear_bit(MMU_PAGEFAULT, &data->state);
+		}
+	}
+
+	return 0;
+}
+
+int vcodec_iommu_fault_hdl(struct iommu_domain *iommu,
+			   struct device *iommu_dev,
+			   unsigned long iova, int status, void *arg)
+{
+	struct device *dev = (struct device *)arg;
+
+	return _vcodec_sys_fault_hdl(dev, iova, status);
+}
+
+int vcodec_iovmm_fault_hdl(struct device *dev,
+			   enum rk_iommu_inttype itype,
+			   unsigned long pgtable_base,
+			   unsigned long fault_addr, unsigned int status)
+{
+	return _vcodec_sys_fault_hdl(dev, fault_addr, status);
+}
+
+static void vcodec_reduce_freq_rk322x(struct vpu_service_info *pservice)
+{
+	if (list_empty(&pservice->running)) {
+		unsigned long rate = clk_get_rate(pservice->aclk_vcodec);
+
+		rkvdec_set_clk(pservice,
+			       get_div_rate(pservice->aclk_vcodec, 32),
+			       get_div_rate(pservice->clk_core, 32),
+			       get_div_rate(pservice->clk_cabac, 32),
+			       EVENT_ADJUST);
+		atomic_set(&pservice->freq_status, rate / 32);
+	}
+}
+
+static void vcodec_reduce_freq_rk3328(struct vpu_service_info *pservice)
+{
+	if (list_empty(&pservice->running))
+		rkvdec_set_clk(pservice, 100 * MHZ, 100 * MHZ, 100 * MHZ,
+			       EVENT_ADJUST);
+}
+
+static int vcodec_spec_init_rk3328(struct vpu_service_info *pservice)
+{
+	/* todo */
+
+	return 0;
+}
+
+static void vcodec_spec_config_rk3328(struct vpu_subdev_data *data)
+{
+	u32 *dst = data->dec_dev.regs;
+	struct vpu_reg *reg = data->pservice->reg_codec;
+	u32 cfg;
+
+	/*
+	 * HW defeat workaround: VP9 power save optimization cause decoding
+	 * corruption, disable optimization here.
+	 */
+	if (rkv_dec_get_fmt(reg->reg) == FMT_VP9D) {
+		cfg = readl(dst + 99);
+		writel(cfg & (~(1 << 12)), dst + 99);
+	}
+}
+
+static struct vcodec_hw_ops hw_ops_default = {
+	.power_on = vcodec_power_on_default,
+	.power_off = vcodec_power_off_default,
+	.get_freq = vcodec_get_reg_freq_default,
+	.set_freq = vcodec_set_freq_default,
+	.reduce_freq = NULL,
+};
+
+static struct vcodec_hw_ops hw_ops_rk3328_rkvdec = {
+	.power_on = vcodec_power_on_rk3328,
+	.power_off = vcodec_power_off_rk3328,
+	.get_freq = vcodec_get_reg_freq_default,
+	.set_freq = vcodec_set_freq_rk3328,
+	.reduce_freq = vcodec_reduce_freq_rk3328,
+};
+
+static struct vcodec_hw_var rk3328_rkvdec_var = {
+	.device_type = VCODEC_DEVICE_TYPE_RKVD,
+	.name = "rkvdec",
+	.ops = &hw_ops_rk3328_rkvdec,
+	.init = vcodec_spec_init_rk3328,
+	.config = vcodec_spec_config_rk3328,
+};
+
+static struct vcodec_hw_var rk3328_vpucombo_var = {
+	.device_type = VCODEC_DEVICE_TYPE_VPUC,
+	.name = "vpu-combo",
+	.ops = NULL,
+	.init = NULL,
+	.config = NULL,
+};
+
+/* Both VPU1 and VPU2 */
+static struct vcodec_hw_var vpu_device_info = {
+	.device_type = VCODEC_DEVICE_TYPE_VPUX,
+	.name = "vpu-service",
+	.ops = NULL,
+	.init = NULL,
+	.config = NULL,
+};
+
+static struct vcodec_hw_var vpu_combo_device_info = {
+	.device_type = VCODEC_DEVICE_TYPE_VPUC,
+	.name = "vpu-combo",
+	.ops = NULL,
+	.init = NULL,
+	.config = NULL,
+};
+
+static struct vcodec_hw_var hevc_device_info = {
+	.device_type = VCODEC_DEVICE_TYPE_HEVC,
+	.name = "hevc-service",
+	.ops = NULL,
+	.init = NULL,
+	.config = NULL,
+};
+
+static struct vcodec_hw_var rkvd_device_info = {
+	.device_type = VCODEC_DEVICE_TYPE_RKVD,
+	.name = "rkvdec",
+	.ops = NULL,
+	.init = NULL,
+	.config = NULL,
+};
+
+static void vcodec_set_hw_ops(struct vpu_service_info *pservice)
+{
+	if (pservice->hw_var) {
+		pservice->hw_ops = pservice->hw_var->ops;
+	}
+
+	if (!pservice->hw_ops) {
+		pservice->hw_ops = &hw_ops_default;
+		if (of_machine_is_compatible("rockchip,rk3328") ||
+		    of_machine_is_compatible("rockchip,rk3228") ||
+		    of_machine_is_compatible("rockchip,rk3229")) {
+			pservice->hw_ops->power_on = vcodec_power_on_rk322x;
+			pservice->hw_ops->power_off = vcodec_power_off_rk322x;
+			pservice->hw_ops->get_freq = NULL;
+			pservice->hw_ops->set_freq = vcodec_set_freq_rk322x;
+			pservice->hw_ops->reduce_freq =
+						vcodec_reduce_freq_rk322x;
+		} else if (of_machine_is_compatible("rockchip,rk3126") ||
+				of_machine_is_compatible("rockchip,rk3128")) {
+			pservice->hw_ops->power_on = vcodec_power_on_rk312x;
+		} else if (of_machine_is_compatible("rockchip,rk3288") ||
+				of_machine_is_compatible("rockchip,rk3288w")) {
+			pservice->hw_ops->get_freq = vcodec_get_reg_freq_rk3288;
+		}
+	}
+}
+
+static int vcodec_subdev_probe(struct platform_device *pdev,
+			       struct vpu_service_info *pservice)
+{
+	u8 *regs = NULL;
+	s32 ret = 0;
+	struct resource *res = NULL;
+	struct vpu_hw_info *hw_info = NULL;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct vpu_subdev_data *data = NULL;
+	struct platform_device *sub_dev = NULL;
+	struct device_node *sub_np = NULL;
+	struct vpu_session *session = list_first_entry(&pservice->session,
+						       struct vpu_session,
+						       list_session);
+	const char *name  = np->name;
+	char mmu_dev_dts_name[40];
+
+	dev_info(dev, "probe device");
+
+	data = devm_kzalloc(dev, sizeof(struct vpu_subdev_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->pservice = pservice;
+	data->dev = dev;
+	platform_set_drvdata(pdev, data);
+
+	INIT_WORK(&data->set_work, vpu_set_register_work);
+
+	switch (pservice->dev_id) {
+	case VCODEC_DEVICE_ID_VPU:
+		data->mode = VCODEC_RUNNING_MODE_VPU;
+		break;
+	case VCODEC_DEVICE_ID_HEVC:
+		data->mode = VCODEC_RUNNING_MODE_HEVC;
+		break;
+	case VCODEC_DEVICE_ID_RKVDEC:
+		data->mode = VCODEC_RUNNING_MODE_RKVDEC;
+		break;
+	case VCODEC_DEVICE_ID_COMBO:
+	default:
+		of_property_read_u32(np, "dev_mode", (u32 *)&data->mode);
+		break;
+	}
+
+	if (!pservice->reg_base) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		data->regs = devm_ioremap_resource(dev, res);
+		if (IS_ERR(data->regs)) {
+			ret = PTR_ERR(data->regs);
+			goto err;
+		}
+	} else {
+		data->regs = pservice->reg_base;
+	}
+
+	sub_np = of_parse_phandle(np, "iommus", 0);
+	if (sub_np) {
+		sub_dev = of_find_device_by_node(sub_np);
+		data->mmu_dev = &sub_dev->dev;
+	}
+
+	/* Back to legacy iommu probe */
+	if (!data->mmu_dev) {
+		switch (data->mode) {
+		case VCODEC_RUNNING_MODE_VPU:
+			sprintf(mmu_dev_dts_name,
+				VPU_IOMMU_COMPATIBLE_NAME);
+			break;
+		case VCODEC_RUNNING_MODE_RKVDEC:
+			sprintf(mmu_dev_dts_name,
+				VDEC_IOMMU_COMPATIBLE_NAME);
+			break;
+		case VCODEC_RUNNING_MODE_HEVC:
+		default:
+			sprintf(mmu_dev_dts_name,
+				HEVC_IOMMU_COMPATIBLE_NAME);
+			break;
+		}
+
+		data->mmu_dev =
+			rockchip_get_sysmmu_dev(mmu_dev_dts_name);
+		if (data->mmu_dev)
+			platform_set_sysmmu(data->mmu_dev, dev);
+
+		rockchip_iovmm_set_fault_handler
+			(dev, vcodec_iovmm_fault_hdl);
+	}
+
+	dev_info(dev, "vpu mmu dec %p\n", data->mmu_dev);
+
+#define BIT_VCODEC_CLK_SEL	BIT(10)
+	if (of_machine_is_compatible("rockchip,rk3126") ||
+	    of_machine_is_compatible("rockchip,rk3128"))
+		regmap_write(pservice->grf, RK312X_GRF_SOC_CON1,
+			     BIT_VCODEC_CLK_SEL |
+			     (BIT_VCODEC_CLK_SEL << 16));
+
+	clear_bit(MMU_ACTIVATED, &data->state);
+	vpu_service_power_on(data, pservice);
+
+	of_property_read_u32(np, "allocator", (u32 *)&pservice->alloc_type);
+	data->iommu_info = vcodec_iommu_info_create(dev, data->mmu_dev,
+						    pservice->alloc_type);
+	dev_info(dev, "allocator is %s\n", pservice->alloc_type == 1 ? "drm" :
+		(pservice->alloc_type == 2 ? "ion" : "null"));
+	if (pservice->alloc_type == 1) {
+		struct vcodec_iommu_drm_info *drm_info =
+			data->iommu_info->private;
+		iommu_set_fault_handler(drm_info->domain,
+					vcodec_iommu_fault_hdl, dev);
+	}
+	vcodec_enter_mode(data);
+	ret = vpu_service_check_hw(data);
+	if (ret < 0) {
+		dev_err(dev, "error: hw info check failed\n");
+		goto err;
+	}
+	data->pa_hdl = vcodec_iommu_alloc(data->iommu_info,
+					  session, 4096, 4096);
+
+	if (data->pa_hdl < 0) {
+		dev_err(dev, "allocate page fault hdl failed\n");
+		return -1;
+	}
+
+	vcodec_iommu_map_iommu(data->iommu_info, session,
+			       data->pa_hdl, NULL, NULL);
+	data->pa_iova = -1;
+	vcodec_exit_mode(data);
+
+	hw_info = data->hw_info;
+	regs = (u8 *)data->regs;
+
+	if (hw_info->dec_reg_num) {
+		data->dec_dev.iosize = hw_info->dec_io_size;
+		data->dec_dev.regs = (u32 *)(regs + hw_info->dec_offset);
+	}
+
+	if (hw_info->enc_reg_num) {
+		data->enc_dev.iosize = hw_info->enc_io_size;
+		data->enc_dev.regs = (u32 *)(regs + hw_info->enc_offset);
+	}
+
+	data->reg_size = max(hw_info->dec_io_size, hw_info->enc_io_size);
+
+	data->irq_enc = platform_get_irq_byname(pdev, "irq_enc");
+	if (data->irq_enc > 0) {
+		ret = devm_request_threaded_irq(dev, data->irq_enc,
+						vepu_irq, vepu_isr,
+						IRQF_SHARED, dev_name(dev),
+						(void *)data);
+		if (ret) {
+			dev_err(dev, "error: can't request vepu irq %d\n",
+				data->irq_enc);
+			goto err;
+		}
+	}
+
+	data->irq_dec = platform_get_irq_byname(pdev, "irq_dec");
+	if (data->irq_dec > 0) {
+		ret = devm_request_threaded_irq(dev, data->irq_dec,
+						vdpu_irq, vdpu_isr,
+						IRQF_SHARED, dev_name(dev),
+						(void *)data);
+		if (ret) {
+			dev_err(dev, "error: can't request vdpu irq %d\n",
+				data->irq_dec);
+			goto err;
+		}
+	}
+	atomic_set(&data->dec_dev.irq_count_codec, 0);
+	atomic_set(&data->dec_dev.irq_count_pp, 0);
+	atomic_set(&data->enc_dev.irq_count_codec, 0);
+	atomic_set(&data->enc_dev.irq_count_pp, 0);
+
+	get_hw_info(data);
+
+	/* create device node */
+	ret = alloc_chrdev_region(&data->dev_t, 0, 1, name);
+	if (ret) {
+		dev_err(dev, "alloc dev_t failed\n");
+		goto err;
+	}
+
+	cdev_init(&data->cdev, &vpu_service_fops);
+
+	data->cdev.owner = THIS_MODULE;
+	data->cdev.ops = &vpu_service_fops;
+
+	ret = cdev_add(&data->cdev, data->dev_t, 1);
+
+	if (ret) {
+		dev_err(dev, "add dev_t failed\n");
+		goto err;
+	}
+
+	data->cls = class_create(THIS_MODULE, name);
+
+	if (IS_ERR(data->cls)) {
+		ret = PTR_ERR(data->cls);
+		dev_err(dev, "class_create err:%d\n", ret);
+		goto err;
+	}
+
+	data->child_dev = device_create(data->cls, dev,
+		data->dev_t, NULL, "%s", name);
+
+	INIT_LIST_HEAD(&data->lnk_service);
+	list_add_tail(&data->lnk_service, &pservice->subdev_list);
+
+	/* After the subdev was appened to the list of pservice */
+	vpu_service_power_off(pservice);
+
+	return 0;
+err:
+	dev_err(dev, "probe err:%d\n", ret);
+	if (data->child_dev) {
+		device_destroy(data->cls, data->dev_t);
+		cdev_del(&data->cdev);
+		unregister_chrdev_region(data->dev_t, 1);
+	}
+
+	if (data->cls)
+		class_destroy(data->cls);
+	vpu_service_power_off(pservice);
+	return -1;
+}
+
+static void vcodec_subdev_remove(struct vpu_subdev_data *data)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_session *session = list_first_entry(&pservice->session,
+						       struct vpu_session,
+						       list_session);
+
+	vcodec_iommu_clear(data->iommu_info, session);
+	vcodec_iommu_info_destroy(data->iommu_info);
+	data->iommu_info = NULL;
+	kfree(session);
+
+	mutex_lock(&pservice->lock);
+	cancel_delayed_work_sync(&pservice->power_off_work);
+	vpu_service_power_off(pservice);
+	mutex_unlock(&pservice->lock);
+
+	device_destroy(data->cls, data->dev_t);
+	class_destroy(data->cls);
+	cdev_del(&data->cdev);
+	unregister_chrdev_region(data->dev_t, 1);
+}
+
+static void vcodec_read_property(struct device_node *np,
+				 struct vpu_service_info *pservice)
+{
+	pservice->mode_bit = 0;
+	pservice->mode_ctrl = 0;
+	pservice->subcnt = 0;
+
+	of_property_read_u32(np, "subcnt", &pservice->subcnt);
+
+	if (pservice->subcnt > 1) {
+		of_property_read_u32(np, "mode_bit", &pservice->mode_bit);
+		of_property_read_u32(np, "mode_ctrl", &pservice->mode_ctrl);
+	}
+
+	pservice->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR_OR_NULL(pservice->grf)) {
+		pservice->grf = NULL;
+		vpu_err("can't find vpu grf property\n");
+		return;
+	}
+
+#ifdef CONFIG_RESET_CONTROLLER
+	pservice->rst_a = devm_reset_control_get(pservice->dev, "video_a");
+	pservice->rst_h = devm_reset_control_get(pservice->dev, "video_h");
+	pservice->rst_v = devm_reset_control_get(pservice->dev, "video");
+	pservice->rst_niu_a = devm_reset_control_get(pservice->dev, "niu_a");
+	pservice->rst_niu_h = devm_reset_control_get(pservice->dev, "niu_h");
+	pservice->rst_core = devm_reset_control_get(pservice->dev,
+						    "video_core");
+	pservice->rst_cabac = devm_reset_control_get(pservice->dev,
+						     "video_cabac");
+
+	if (IS_ERR_OR_NULL(pservice->rst_a)) {
+		dev_dbg(pservice->dev, "No aclk reset resource define\n");
+		pservice->rst_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(pservice->rst_h)) {
+		dev_dbg(pservice->dev, "No hclk reset resource define\n");
+		pservice->rst_h = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(pservice->rst_v)) {
+		dev_dbg(pservice->dev, "No core rst_v reset resource define\n");
+		pservice->rst_v = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(pservice->rst_niu_a)) {
+		dev_dbg(pservice->dev, "No NIU aclk reset resource define\n");
+		pservice->rst_niu_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(pservice->rst_niu_h)) {
+		dev_dbg(pservice->dev, "No NIU hclk reset resource define\n");
+		pservice->rst_niu_h = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(pservice->rst_core)) {
+		dev_dbg(pservice->dev, "No core reset resource define\n");
+		pservice->rst_core = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(pservice->rst_cabac)) {
+		dev_dbg(pservice->dev, "No cabac reset resource define\n");
+		pservice->rst_cabac = NULL;
+	}
+#endif
+
+	of_property_read_string(np, "name", (const char **)&pservice->name);
+}
+
+static const struct of_device_id vcodec_service_dt_ids[] = {
+	{
+		.compatible = "rockchip,rk3328-rkvdec",
+		.data = &rk3328_rkvdec_var,
+	},
+	{
+		.compatible = "rockchip,rk3328-vpu-combo",
+		.data = &rk3328_vpucombo_var,
+	},
+	{
+		.compatible = "rockchip,vpu_service",
+		.data = &vpu_device_info,
+	},
+	{
+		.compatible = "rockchip,hevc_service",
+		.data = &hevc_device_info,
+	},
+	{
+		.compatible = "rockchip,vpu_combo",
+		.data = &vpu_combo_device_info,
+	},
+	{
+		.compatible = "rockchip,rkvdec",
+		.data = &rkvd_device_info,
+	},
+	{},
+};
+
+static void vcodec_init_drvdata(struct vpu_service_info *pservice)
+{
+	pservice->dev_id = VCODEC_DEVICE_ID_VPU;
+	pservice->curr_mode = -1;
+
+	wake_lock_init(&pservice->wake_lock, WAKE_LOCK_SUSPEND, "vpu");
+	INIT_LIST_HEAD(&pservice->waiting);
+	INIT_LIST_HEAD(&pservice->running);
+	mutex_init(&pservice->lock);
+	mutex_init(&pservice->shutdown_lock);
+	mutex_init(&pservice->reset_lock);
+	mutex_init(&pservice->sip_reset_lock);
+	mutex_init(&pservice->set_clk_lock);
+	atomic_set(&pservice->service_on, 1);
+
+	INIT_LIST_HEAD(&pservice->done);
+	INIT_LIST_HEAD(&pservice->session);
+	INIT_LIST_HEAD(&pservice->subdev_list);
+
+	pservice->reg_pproc	= NULL;
+	atomic_set(&pservice->total_running, 0);
+	atomic_set(&pservice->enabled,       0);
+	atomic_set(&pservice->power_on_cnt,  0);
+	atomic_set(&pservice->power_off_cnt, 0);
+	atomic_set(&pservice->reset_request, 0);
+
+	INIT_DELAYED_WORK(&pservice->power_off_work, vpu_power_off_work);
+	pservice->last.tv64 = 0;
+
+	pservice->alloc_type = 0;
+
+	vcodec_set_hw_ops(pservice);
+	if (pservice->hw_var && pservice->hw_var->init)
+		pservice->hw_var->init(pservice);
+}
+
+static int devfreq_vcodec_target(struct device *dev, unsigned long *freq,
+				 u32 flags)
+{
+	struct vpu_subdev_data *data = dev_get_drvdata(dev);
+	struct vpu_service_info *pservice = data->pservice;
+	struct devfreq *devfreq = pservice->devfreq;
+	struct devfreq_dev_status *stat = &devfreq->last_status;
+	struct dev_pm_opp *opp;
+	unsigned long old_clk_rate = stat->current_frequency;
+	unsigned long target_volt, target_rate;
+	unsigned long vcodec_rate, core_rate, cabac_rate;
+	unsigned long req_rate = *freq;
+	unsigned int clk_event;
+	int ret = 0;
+
+	rcu_read_lock();
+
+	opp = devfreq_recommended_opp(dev, freq, flags);
+	if (IS_ERR(opp)) {
+		rcu_read_unlock();
+		return PTR_ERR(opp);
+	}
+	target_rate = dev_pm_opp_get_freq(opp);
+	target_volt = dev_pm_opp_get_voltage(opp);
+
+	rcu_read_unlock();
+
+	if (target_rate < req_rate) {
+		clk_event = EVENT_THERMAL;
+		vcodec_rate = target_rate;
+		core_rate = target_rate;
+		cabac_rate = target_rate;
+	} else {
+		clk_event = stat->busy_time ? EVENT_POWER_ON : EVENT_POWER_OFF;
+		vcodec_rate = pservice->vcodec_rate;
+		core_rate = pservice->core_rate;
+		cabac_rate = pservice->cabac_rate;
+	}
+
+	if (old_clk_rate == target_rate) {
+		if (pservice->volt == target_volt)
+			return ret;
+		ret = regulator_set_voltage(pservice->vdd_vcodec, target_volt,
+					    INT_MAX);
+		if (ret) {
+			dev_err(dev, "Cannot set voltage %lu uV\n",
+				target_volt);
+			return ret;
+		}
+		pservice->volt = target_volt;
+		return 0;
+	}
+
+	if (old_clk_rate < target_rate) {
+		ret = regulator_set_voltage(pservice->vdd_vcodec, target_volt,
+					    INT_MAX);
+		if (ret) {
+			dev_err(dev, "Cannot set voltage %lu uV\n",
+				target_volt);
+			return ret;
+		}
+	}
+
+	dev_dbg(dev, "%lu-->%lu\n", old_clk_rate, target_rate);
+	rkvdec_set_clk(pservice, vcodec_rate, core_rate, cabac_rate, clk_event);
+
+	stat->current_frequency = target_rate;
+
+	if (old_clk_rate > target_rate) {
+		ret = regulator_set_voltage(pservice->vdd_vcodec, target_volt,
+					    INT_MAX);
+		if (ret) {
+			dev_err(dev, "Cannot set vol %lu uV\n", target_volt);
+			return ret;
+		}
+	}
+
+	pservice->volt = target_volt;
+
+	return ret;
+}
+
+static int devfreq_vcodec_get_cur_freq(struct device *dev,
+				       unsigned long *freq)
+{
+	struct vpu_subdev_data *data = dev_get_drvdata(dev);
+	struct vpu_service_info *pservice = data->pservice;
+
+	*freq = clk_get_rate(pservice->aclk_vcodec);
+
+	return 0;
+}
+
+static struct devfreq_dev_profile devfreq_vcodec_profile = {
+	.target		= devfreq_vcodec_target,
+	.get_cur_freq	= devfreq_vcodec_get_cur_freq,
+};
+
+static unsigned long model_static_power(struct devfreq *devfreq,
+					unsigned long voltage)
+{
+	struct device *dev = devfreq->dev.parent;
+	struct vpu_subdev_data *data = dev_get_drvdata(dev);
+	struct vpu_service_info *pservice = data->pservice;
+
+	int temperature;
+	unsigned long temp;
+	unsigned long temp_squared, temp_cubed, temp_scaling_factor;
+	const unsigned long voltage_cubed = (voltage * voltage * voltage) >> 10;
+
+	if (!IS_ERR_OR_NULL(pservice->vcodec_tz) &&
+	    pservice->vcodec_tz->ops->get_temp) {
+		int ret;
+
+		ret = pservice->vcodec_tz->ops->get_temp(pservice->vcodec_tz,
+							 &temperature);
+		if (ret) {
+			dev_warn_ratelimited(dev,
+					     "failed to read temp for ddr thermal zone: %d\n",
+					     ret);
+			temperature = FALLBACK_STATIC_TEMPERATURE;
+		}
+	} else {
+		temperature = FALLBACK_STATIC_TEMPERATURE;
+	}
+
+	/*
+	 * Calculate the temperature scaling factor. To be applied to the
+	 * voltage scaled power.
+	 */
+	temp = temperature / 1000;
+	temp_squared = temp * temp;
+	temp_cubed = temp_squared * temp;
+	temp_scaling_factor = (pservice->ts[3] * temp_cubed)
+	    + (pservice->ts[2] * temp_squared)
+	    + (pservice->ts[1] * temp)
+	    + pservice->ts[0];
+
+	return (((pservice->static_coefficient * voltage_cubed) >> 20)
+		* temp_scaling_factor) / 1000000;
+}
+
+static struct devfreq_cooling_power vcodec_cooling_power_data = {
+	.get_static_power = model_static_power,
+	.dyn_power_coeff = 120,
+};
+
+static int vcodec_power_model_simple_init(struct vpu_service_info *pservice)
+{
+	struct device_node *power_model_node;
+	const char *tz_name;
+	u32 temp;
+
+	power_model_node = of_get_child_by_name(pservice->dev->of_node,
+						"vcodec_power_model");
+	if (!power_model_node) {
+		dev_err(pservice->dev, "could not find power_model node\n");
+		return -ENODEV;
+	}
+
+	if (of_property_read_string(power_model_node, "thermal-zone", &tz_name)) {
+		dev_err(pservice->dev, "ts in power_model not available\n");
+		return -EINVAL;
+	}
+
+	pservice->vcodec_tz = thermal_zone_get_zone_by_name(tz_name);
+	if (IS_ERR(pservice->vcodec_tz)) {
+		pr_warn_ratelimited
+		    ("Error getting ddr thermal zone (%ld), not yet ready?\n",
+		     PTR_ERR(pservice->vcodec_tz));
+		pservice->vcodec_tz = NULL;
+
+		return -EPROBE_DEFER;
+	}
+
+	if (of_property_read_u32(power_model_node, "static-power-coefficient",
+				 &pservice->static_coefficient)) {
+		dev_err(pservice->dev,
+			"static-power-coefficient not available\n");
+		return -EINVAL;
+	}
+	if (of_property_read_u32(power_model_node, "dynamic-power-coefficient",
+				 &temp)) {
+		dev_err(pservice->dev,
+			"dynamic-power-coefficient not available\n");
+		return -EINVAL;
+	}
+	vcodec_cooling_power_data.dyn_power_coeff = (unsigned long)temp;
+
+	if (of_property_read_u32_array
+	    (power_model_node, "ts", (u32 *)pservice->ts, 4)) {
+		dev_err(pservice->dev, "ts in power_model not available\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int vcodec_devfreq_notifier_call(struct notifier_block *nb,
+					unsigned long event,
+					void *data)
+{
+	struct vpu_service_info *ps = container_of(nb, struct vpu_service_info,
+						   devfreq_nb);
+
+	if (!ps)
+		return NOTIFY_OK;
+
+	if (event == DEVFREQ_PRECHANGE)
+		mutex_lock(&ps->sip_reset_lock);
+	else if (event == DEVFREQ_POSTCHANGE)
+		mutex_unlock(&ps->sip_reset_lock);
+
+	return NOTIFY_OK;
+}
+
+static int vcodec_probe(struct platform_device *pdev)
+{
+	int i;
+	int ret = 0;
+	const struct of_device_id *match = NULL;
+	struct resource *res = NULL;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *parent_np;
+	struct devfreq_dev_profile *devp = &devfreq_vcodec_profile;
+	struct devfreq_dev_status *stat;
+	struct vpu_service_info *pservice = NULL;
+	struct vpu_session *session = NULL;
+#define MAX_PROP_NAME_LEN	3
+	char name[MAX_PROP_NAME_LEN];
+	int lkg_volt_sel;
+
+	pservice = devm_kzalloc(dev, sizeof(struct vpu_service_info),
+				GFP_KERNEL);
+	if (!pservice)
+		return -ENOMEM;
+	pservice->dev = dev;
+
+	pservice->vdd_vcodec = devm_regulator_get_optional(dev, "vcodec");
+	if (IS_ERR(pservice->vdd_vcodec)) {
+		ret = PTR_ERR(pservice->vdd_vcodec);
+		if (ret == -EPROBE_DEFER) {
+			dev_warn(dev, "vcodec regulator not ready, retry\n");
+			return ret;
+		}
+		dev_warn(dev, "no regulator for vcodec\n");
+	}
+
+	match = of_match_node(vcodec_service_dt_ids, pservice->dev->of_node);
+	if (match)
+		pservice->hw_var = match->data;
+	else
+		return -EINVAL;
+
+	if (pservice->hw_var->ops &&
+	    pservice->hw_var->ops->reduce_freq == vcodec_reduce_freq_rk3328) {
+		pservice->parent_devfreq = devfreq_get_devfreq_by_phandle(dev,
+									  0);
+		if (IS_ERR(pservice->parent_devfreq)) {
+			ret = PTR_ERR(pservice->parent_devfreq);
+			if (ret == -EPROBE_DEFER) {
+				parent_np = of_parse_phandle(np, "devfreq", 0);
+				if (parent_np &&
+				    of_device_is_available(parent_np)) {
+					dev_warn(dev,
+						 "parent devfreq retry\n");
+					return ret;
+				}
+				dev_warn(dev, "parent devfreq is disabled\n");
+				pservice->parent_devfreq = NULL;
+			} else {
+				dev_err(dev, "parent devfreq is error\n");
+				return -EINVAL;
+			}
+		} else {
+			dev_info(dev, "parent devfreq is ok\n");
+		}
+	}
+
+	pservice->set_workq = create_singlethread_workqueue("vcodec");
+	if (!pservice->set_workq) {
+		dev_err(dev, "failed to create workqueue\n");
+		return -ENOMEM;
+	}
+
+	vcodec_read_property(np, pservice);
+	vcodec_init_drvdata(pservice);
+
+	if (pservice->parent_devfreq) {
+		pservice->devfreq_nb.notifier_call =
+			vcodec_devfreq_notifier_call;
+		devm_devfreq_register_notifier(dev,
+					       pservice->parent_devfreq,
+					       &pservice->devfreq_nb,
+					       DEVFREQ_TRANSITION_NOTIFIER);
+	}
+
+	/* Underscore for label, hyphens for name */
+	switch (pservice->hw_var->device_type) {
+	case VCODEC_DEVICE_TYPE_VPUX:
+		pservice->dev_id = VCODEC_DEVICE_ID_VPU;
+		break;
+	case VCODEC_DEVICE_TYPE_VPUC:
+		pservice->dev_id = VCODEC_DEVICE_ID_COMBO;
+		break;
+	case VCODEC_DEVICE_TYPE_HEVC:
+		pservice->dev_id = VCODEC_DEVICE_ID_HEVC;
+		break;
+	case VCODEC_DEVICE_TYPE_RKVD:
+		pservice->dev_id = VCODEC_DEVICE_ID_RKVDEC;
+		break;
+	default:
+		dev_err(dev, "unsupported device type\n");
+		ret = -ENODEV;
+		goto err;
+	}
+
+	pservice->secure_isr = false;
+	pservice->secure_irq_status = true;
+
+	if (0 > vpu_get_clk(pservice))
+		goto err;
+
+	if (!IS_ERR(pservice->vdd_vcodec)) {
+		lkg_volt_sel = rockchip_of_get_lkg_volt_sel(dev,
+							    "rkvdec_leakage");
+		if (lkg_volt_sel >= 0) {
+			snprintf(name, MAX_PROP_NAME_LEN, "L%d", lkg_volt_sel);
+			ret = dev_pm_opp_set_prop_name(dev, name);
+			if (ret)
+				dev_err(dev, "Failed to set prop name\n");
+		}
+
+		if (dev_pm_opp_of_add_table(dev)) {
+			dev_err(dev, "Invalid operating-points\n");
+			ret = -EINVAL;
+			goto err;
+		}
+
+		pservice->devfreq = devm_devfreq_add_device(dev, devp,
+							    "userspace", NULL);
+		if (IS_ERR(pservice->devfreq)) {
+			ret = PTR_ERR(pservice->devfreq);
+			goto err;
+		}
+
+		stat = &pservice->devfreq->last_status;
+		stat->current_frequency = clk_get_rate(pservice->aclk_vcodec);
+
+		ret = devfreq_register_opp_notifier(dev, pservice->devfreq);
+		if (ret)
+			goto err;
+	}
+
+	if (of_property_read_bool(np, "reg")) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+		pservice->reg_base = devm_ioremap_resource(pservice->dev, res);
+		if (IS_ERR(pservice->reg_base)) {
+			vpu_err("ioremap registers base failed\n");
+			ret = PTR_ERR(pservice->reg_base);
+			goto err;
+		}
+		pservice->ioaddr = res->start;
+	} else {
+		pservice->reg_base = 0;
+	}
+
+	pm_runtime_enable(dev);
+
+	/*
+	 * this session is global session, each dev
+	 * only has one global session, and will be
+	 * release when dev remove
+	 */
+	session = kzalloc(sizeof(*session), GFP_KERNEL);
+	if (!session) {
+		vpu_err("error: unable to allocate memory for vpu_session.");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	session->type	= VPU_TYPE_BUTT;
+	session->pid	= current->pid;
+	INIT_LIST_HEAD(&session->waiting);
+	INIT_LIST_HEAD(&session->running);
+	INIT_LIST_HEAD(&session->done);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	atomic_set(&session->task_running, 0);
+	mutex_lock(&pservice->lock);
+	list_add_tail(&session->list_session, &pservice->session);
+	mutex_unlock(&pservice->lock);
+
+	if (of_property_read_bool(np, "subcnt")) {
+		struct vpu_subdev_data *data = NULL;
+
+		data = devm_kzalloc(dev, sizeof(struct vpu_subdev_data),
+				    GFP_KERNEL);
+		if (!data) {
+			vpu_err("error: unable to allocate memory for vpu_subdev_data");
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		data->pservice = pservice;
+		platform_set_drvdata(pdev, data);
+
+		for (i = 0; i < pservice->subcnt; i++) {
+			struct device_node *sub_np;
+			struct platform_device *sub_pdev;
+
+			sub_np = of_parse_phandle(np, "rockchip,sub", i);
+			sub_pdev = of_find_device_by_node(sub_np);
+
+			vcodec_subdev_probe(sub_pdev, pservice);
+		}
+	} else {
+		vcodec_subdev_probe(pdev, pservice);
+	}
+
+	ret = vcodec_power_model_simple_init(pservice);
+
+	if (!ret && pservice->devfreq) {
+		pservice->devfreq_cooling =
+		    of_devfreq_cooling_register_power(pservice->dev->of_node,
+						      pservice->devfreq,
+						      &vcodec_cooling_power_data);
+		if (IS_ERR_OR_NULL(pservice->devfreq_cooling)) {
+			ret = PTR_ERR(pservice->devfreq_cooling);
+			dev_err(pservice->dev,
+				"Failed to register cooling device (%d)\n",
+				ret);
+		}
+	}
+
+	dev_info(dev, "init success\n");
+
+	return 0;
+
+err:
+	dev_info(dev, "init failed\n");
+	kfree(session);
+	destroy_workqueue(pservice->set_workq);
+	wake_lock_destroy(&pservice->wake_lock);
+
+	return ret;
+}
+
+static int vcodec_remove(struct platform_device *pdev)
+{
+	struct vpu_subdev_data *data = platform_get_drvdata(pdev);
+
+	vcodec_subdev_remove(data);
+
+	pm_runtime_disable(data->pservice->dev);
+
+	return 0;
+}
+
+static void vcodec_shutdown(struct platform_device *pdev)
+{
+	struct vpu_subdev_data *data = platform_get_drvdata(pdev);
+	struct vpu_service_info *pservice = data->pservice;
+	int val;
+	int ret;
+
+	dev_info(&pdev->dev, "vcodec shutdown");
+
+	/*
+	 * just wait for hardware finishing his work
+	 * and do nothing else.
+	 */
+	mutex_lock(&pservice->shutdown_lock);
+	atomic_set(&pservice->service_on, 0);
+	mutex_unlock(&pservice->shutdown_lock);
+
+	ret = readx_poll_timeout(atomic_read,
+				 &pservice->total_running,
+				 val, val == 0, 20000, 200000);
+	if (ret == -ETIMEDOUT)
+		dev_err(&pdev->dev, "wait total running time out\n");
+
+	data->pservice->curr_mode = VCODEC_RUNNING_MODE_NONE;
+}
+
+MODULE_DEVICE_TABLE(of, vcodec_service_dt_ids);
+
+static struct platform_driver vcodec_driver = {
+	.probe = vcodec_probe,
+	.remove = vcodec_remove,
+	.shutdown = vcodec_shutdown,
+	.driver = {
+		.name = "rk-vcodec",
+		.of_match_table = of_match_ptr(vcodec_service_dt_ids),
+	},
+};
+
+static void get_hw_info(struct vpu_subdev_data *data)
+{
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_dec_config *dec = &pservice->dec_config;
+	struct vpu_enc_config *enc = &pservice->enc_config;
+
+	switch (data->mode) {
+	case VCODEC_RUNNING_MODE_VPU:
+		dec->h264_support = 3;
+		dec->jpeg_support = 1;
+		dec->mpeg4_support = 2;
+		dec->vc1_support = 3;
+		dec->mpeg2_support = 1;
+		dec->pp_support = 1;
+		dec->sorenson_support = 1;
+		dec->ref_buf_support = 3;
+		dec->vp6_support = 1;
+		dec->vp7_support = 1;
+		dec->vp8_support = 1;
+		dec->avs_support = 1;
+		dec->jpeg_ext_support = 0;
+		dec->custom_mpeg4_support = 1;
+		dec->reserve = 0;
+		dec->mvc_support = 1;
+
+		if (data->enc_dev.regs) {
+			u32 config_reg = readl_relaxed(data->enc_dev.regs + 63);
+
+			enc->max_encoded_width = config_reg & ((1 << 11) - 1);
+			enc->h264_enabled = 1;
+			enc->mpeg4_enabled = (config_reg >> 26) & 1;
+			enc->jpeg_enabled = 1;
+			enc->vs_enabled = (config_reg >> 24) & 1;
+			enc->rgb_enabled = (config_reg >> 28) & 1;
+			enc->reg_size = data->reg_size;
+			enc->reserv[0] = 0;
+			enc->reserv[1] = 0;
+		}
+
+		pservice->auto_freq = true;
+		vpu_debug(DEBUG_EXTRA_INFO,
+			  "vpu_service set to auto frequency mode\n");
+		atomic_set(&pservice->freq_status, VPU_FREQ_BUT);
+
+		pservice->bug_dec_addr = of_machine_is_compatible
+			("rockchip,rk30xx");
+		break;
+	case VCODEC_RUNNING_MODE_HEVC:
+	case VCODEC_RUNNING_MODE_RKVDEC:
+		pservice->auto_freq = true;
+		atomic_set(&pservice->freq_status, VPU_FREQ_BUT);
+		break;
+	default:
+		/* disable frequency switch in hevc.*/
+		pservice->auto_freq = false;
+	}
+
+	if (of_machine_is_compatible("rockchip,rk2928") ||
+			of_machine_is_compatible("rockchip,rk3036") ||
+			of_machine_is_compatible("rockchip,rk3066") ||
+			of_machine_is_compatible("rockchip,rk3126") ||
+			of_machine_is_compatible("rockchip,rk3128") ||
+			of_machine_is_compatible("rockchip,rk3188")) {
+		dec->max_dec_pic_width = 1920;
+		pservice->auto_freq = false;
+	} else {
+		dec->max_dec_pic_width = 4096;
+	}
+}
+
+static bool check_irq_err(struct vpu_task_info *task, u32 irq_status)
+{
+	vpu_debug(DEBUG_IRQ_CHECK, "task %s status %08x mask %08x\n",
+		  task->name, irq_status, task->error_mask);
+
+	return (task->error_mask & irq_status) ? true : false;
+}
+
+static irqreturn_t vdpu_irq(int irq, void *dev_id)
+{
+	struct vpu_subdev_data *data = (struct vpu_subdev_data *)dev_id;
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_task_info *task = NULL;
+	struct vpu_device *dev = &data->dec_dev;
+	u32 hw_id = data->hw_info->hw_id;
+	u32 raw_status;
+	u32 dec_status;
+
+	/* this interrupt can be cleared here, no need in security zone */
+	if (atomic_read(&pservice->secure_mode)) {
+		disable_irq_nosync(data->irq_dec);
+		pservice->secure_isr = true;
+		pservice->secure_irq_status = false;
+		wake_up(pservice->wait_secure_isr);
+		return IRQ_WAKE_THREAD;
+	}
+
+	task = &data->task_info[TASK_DEC];
+
+	raw_status = readl_relaxed(dev->regs + task->reg_irq);
+	dec_status = raw_status;
+
+	vpu_debug(DEBUG_TASK_INFO,
+		  "vdpu_irq reg %d status %x mask: irq %x ready %x error %0x\n",
+		  task->reg_irq, dec_status,
+		  task->irq_mask, task->ready_mask, task->error_mask);
+
+	if (dec_status & task->irq_mask) {
+		time_record(task, 1);
+		vpu_debug(DEBUG_IRQ_STATUS, "vdpu_irq dec status %08x\n",
+			  dec_status);
+		if ((dec_status & 0x40001) == 0x40001) {
+			do {
+				dec_status = readl_relaxed(dev->regs +
+							   task->reg_irq);
+			} while ((dec_status & 0x40001) == 0x40001);
+		}
+
+		if (check_irq_err(task, dec_status))
+			atomic_add(1, &pservice->reset_request);
+
+		writel_relaxed(0, dev->regs + task->reg_irq);
+
+		/* set clock gating to save power */
+		writel(task->gating_mask, dev->regs + task->reg_en);
+
+		atomic_add(1, &dev->irq_count_codec);
+		time_diff(task);
+		pservice->irq_status = raw_status;
+	}
+
+	task = &data->task_info[TASK_PP];
+	if (hw_id != HEVC_ID && hw_id != RKV_DEC_ID) {
+		u32 pp_status = readl_relaxed(dev->regs + task->irq_mask);
+
+		if (pp_status & task->irq_mask) {
+			time_record(task, 1);
+			vpu_debug(DEBUG_IRQ_STATUS, "vdpu_irq pp status %08x\n",
+				  pp_status);
+
+			if (check_irq_err(task, dec_status))
+				atomic_add(1, &pservice->reset_request);
+
+			/* clear pp IRQ */
+			writel_relaxed(pp_status & (~task->reg_irq),
+				       dev->regs + task->irq_mask);
+			atomic_add(1, &dev->irq_count_pp);
+			time_diff(task);
+		}
+	}
+
+	if (atomic_read(&dev->irq_count_pp) ||
+	    atomic_read(&dev->irq_count_codec))
+		return IRQ_WAKE_THREAD;
+	else
+		return IRQ_NONE;
+}
+
+static irqreturn_t vdpu_isr(int irq, void *dev_id)
+{
+	struct vpu_subdev_data *data = (struct vpu_subdev_data *)dev_id;
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_device *dev = &data->dec_dev;
+	struct vpu_session *session = list_first_entry(&pservice->session,
+						       struct vpu_session,
+						       list_session);
+
+
+	if (atomic_read(&pservice->secure_mode))
+		return IRQ_HANDLED;
+
+	mutex_lock(&pservice->lock);
+	if (atomic_read(&dev->irq_count_codec)) {
+		atomic_sub(1, &dev->irq_count_codec);
+		if (pservice->reg_codec == NULL) {
+			vpu_err("error: dec isr with no task waiting\n");
+		} else {
+			if (test_bit(MMU_PAGEFAULT, &data->state) &&
+			    data->pa_iova != -1) {
+				vcodec_iommu_unmap_iommu_with_iova(data->iommu_info,
+								   session,
+								   data->pa_hdl);
+				data->pa_iova = -1;
+				clear_bit(MMU_PAGEFAULT, &data->state);
+			}
+			reg_from_run_to_done(data, pservice->reg_codec);
+			/* avoid vpu timeout and can't recover problem */
+			if (data->mode == VCODEC_RUNNING_MODE_VPU)
+				VDPU_SOFT_RESET(data->regs);
+		}
+	}
+
+	if (atomic_read(&dev->irq_count_pp)) {
+		atomic_sub(1, &dev->irq_count_pp);
+		if (pservice->reg_pproc == NULL)
+			vpu_err("error: pp isr with no task waiting\n");
+		else
+			reg_from_run_to_done(data, pservice->reg_pproc);
+	}
+
+	queue_work(pservice->set_workq, &data->set_work);
+	mutex_unlock(&pservice->lock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t vepu_irq(int irq, void *dev_id)
+{
+	struct vpu_subdev_data *data = (struct vpu_subdev_data *)dev_id;
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_task_info *task = &data->task_info[TASK_ENC];
+	struct vpu_device *dev = &data->enc_dev;
+	u32 irq_status;
+
+	irq_status = readl_relaxed(dev->regs + task->reg_irq);
+
+	vpu_debug(DEBUG_TASK_INFO,
+		  "vepu_irq reg %d status %x mask: irq %x ready %x error %0x\n",
+		  task->reg_irq, irq_status,
+		  task->irq_mask, task->ready_mask, task->error_mask);
+
+	vpu_debug(DEBUG_IRQ_STATUS, "vepu_irq enc status %08x\n", irq_status);
+
+	if (likely(irq_status & task->irq_mask)) {
+		time_record(task, 1);
+
+		if (check_irq_err(task, irq_status))
+			atomic_add(1, &pservice->reset_request);
+
+		/* clear enc IRQ */
+		writel_relaxed(irq_status & (~task->irq_mask),
+			       dev->regs + task->reg_irq);
+
+		atomic_add(1, &dev->irq_count_codec);
+		time_diff(task);
+	}
+
+	pservice->irq_status = irq_status;
+
+	if (atomic_read(&dev->irq_count_codec))
+		return IRQ_WAKE_THREAD;
+	else
+		return IRQ_NONE;
+}
+
+static irqreturn_t vepu_isr(int irq, void *dev_id)
+{
+	struct vpu_subdev_data *data = (struct vpu_subdev_data *)dev_id;
+	struct vpu_service_info *pservice = data->pservice;
+	struct vpu_device *dev = &data->enc_dev;
+
+	mutex_lock(&pservice->lock);
+	if (atomic_read(&dev->irq_count_codec)) {
+		atomic_sub(1, &dev->irq_count_codec);
+		if (NULL == pservice->reg_codec)
+			vpu_err("error: enc isr with no task waiting\n");
+		else
+			reg_from_run_to_done(data, pservice->reg_codec);
+	}
+	queue_work(pservice->set_workq, &data->set_work);
+	mutex_unlock(&pservice->lock);
+
+	return IRQ_HANDLED;
+}
+
+module_platform_driver(vcodec_driver);
+MODULE_LICENSE("GPL v2");
diff -Nupr a/drivers/video/rockchip/vcodec/vcodec_service.h b/drivers/video/rockchip/vcodec/vcodec_service.h
--- a/drivers/video/rockchip/vcodec/vcodec_service.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vcodec/vcodec_service.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2015 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ROCKCHIP_VCODEC_SERVICE_H__
+#define __ROCKCHIP_VCODEC_SERVICE_H__
+
+enum VPU_DEC_FMT {
+	VPU_DEC_FMT_H264,
+	VPU_DEC_FMT_MPEG4,
+	VPU_DEC_FMT_H263,
+	VPU_DEC_FMT_JPEG,
+	VPU_DEC_FMT_VC1,
+	VPU_DEC_FMT_MPEG2,
+	VPU_DEC_FMT_MPEG1,
+	VPU_DEC_FMT_VP6,
+	VPU_DEC_FMT_RESERV0,
+	VPU_DEC_FMT_VP7,
+	VPU_DEC_FMT_VP8,
+	VPU_DEC_FMT_AVS,
+	VPU_DEC_FMT_RES
+};
+
+enum vcodec_device_id {
+	VCODEC_DEVICE_ID_VPU,
+	VCODEC_DEVICE_ID_HEVC,
+	VCODEC_DEVICE_ID_COMBO,
+	VCODEC_DEVICE_ID_RKVDEC,
+	VCODEC_DEVICE_ID_BUTT
+};
+
+enum VPU_CLIENT_TYPE {
+	VPU_ENC                 = 0x0,
+	VPU_DEC                 = 0x1,
+	VPU_PP                  = 0x2,
+	VPU_DEC_PP              = 0x3,
+	VPU_TYPE_BUTT,
+};
+
+/* struct for process session which connect to vpu */
+struct vpu_session {
+	enum VPU_CLIENT_TYPE type;
+	/* a linked list of data so we can access them for debugging */
+	struct list_head list_session;
+	/* a linked list of register data waiting for process */
+	struct list_head waiting;
+	/* a linked list of register data in processing */
+	struct list_head running;
+	/* a linked list of register data processed */
+	struct list_head done;
+	wait_queue_head_t wait;
+	pid_t pid;
+	atomic_t task_running;
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/vpu/Kconfig b/drivers/video/rockchip/vpu/Kconfig
--- a/drivers/video/rockchip/vpu/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/Kconfig	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,18 @@
+# SPDX-License-Identifier: GPL-2.0
+menu "ROCKCHIP_MPP"
+	depends on ARCH_ROCKCHIP
+
+config ROCKCHIP_MPP_SERVICE
+	tristate "ROCKCHIP MPP SERVICE driver"
+	default n
+	help
+	  rockchip mpp service.
+
+config ROCKCHIP_MPP_DEVICE
+	tristate "ROCKCHIP MPP DEVICE driver"
+	depends on ROCKCHIP_MPP_SERVICE
+	default n
+	help
+	  rockchip mpp module.
+
+endmenu
diff -Nupr a/drivers/video/rockchip/vpu/Makefile b/drivers/video/rockchip/vpu/Makefile
--- a/drivers/video/rockchip/vpu/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/Makefile	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_ROCKCHIP_MPP_SERVICE) += mpp_service.o
+obj-$(CONFIG_ROCKCHIP_MPP_DEVICE) += mpp_dev_rkvenc.o mpp_dev_vepu.o \
+	mpp_dev_h265e.o mpp_dev_common.o vpu_iommu_drm.o vpu_iommu_ion.o \
+	vpu_iommu_ops.o
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_common.c b/drivers/video/rockchip/vpu/mpp_dev_common.c
--- a/drivers/video/rockchip/vpu/mpp_dev_common.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_common.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1087 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "vpu_iommu_ops.h"
+#include "mpp_dev_common.h"
+#include "mpp_service.h"
+
+int mpp_dev_debug;
+module_param(mpp_dev_debug, int, 0644);
+MODULE_PARM_DESC(mpp_dev_debug, "bit switch for mpp_dev debug information");
+
+static int mpp_bufid_to_iova(struct rockchip_mpp_dev *mpp, const u8 *tbl,
+			     int size, u32 *reg, struct mpp_ctx *ctx)
+{
+	int hdl;
+	int ret = 0;
+	struct mpp_mem_region *mem_region, *n;
+	int i;
+	int offset = 0;
+	int retval = 0;
+
+	if (!tbl || size <= 0) {
+		mpp_err("input arguments invalidate, table %p, size %d\n",
+			tbl, size);
+		return -1;
+	}
+
+	for (i = 0; i < size; i++) {
+		int usr_fd = reg[tbl[i]] & 0x3FF;
+
+		mpp_debug(DEBUG_IOMMU, "reg[%03d] fd = %d\n", tbl[i], usr_fd);
+
+		/* if userspace do not set the fd at this register, skip */
+		if (usr_fd == 0)
+			continue;
+
+		offset = reg[tbl[i]] >> 10;
+
+		mpp_debug(DEBUG_IOMMU, "pos %3d fd %3d offset %10d\n",
+			  tbl[i], usr_fd, offset);
+
+		hdl = vpu_iommu_import(mpp->iommu_info, ctx->session, usr_fd);
+		if (hdl < 0) {
+			mpp_err("import dma-buf from fd %d failed, reg[%d]\n",
+				usr_fd, tbl[i]);
+			retval = hdl;
+			goto fail;
+		}
+
+		mem_region = kzalloc(sizeof(*mem_region), GFP_KERNEL);
+
+		if (!mem_region) {
+			vpu_iommu_free(mpp->iommu_info, ctx->session, hdl);
+			retval = -1;
+			goto fail;
+		}
+
+		mem_region->hdl = hdl;
+		mem_region->reg_idx = tbl[i];
+
+		ret = vpu_iommu_map_iommu(mpp->iommu_info, ctx->session,
+					  hdl, (void *)&mem_region->iova,
+					  &mem_region->len);
+
+		if (ret < 0) {
+			mpp_err("reg %d fd %d ion map iommu failed\n",
+				tbl[i], usr_fd);
+			kfree(mem_region);
+			vpu_iommu_free(mpp->iommu_info, ctx->session, hdl);
+			retval = -1;
+			goto fail;
+		}
+
+		reg[tbl[i]] = mem_region->iova + offset;
+		INIT_LIST_HEAD(&mem_region->reg_lnk);
+		list_add_tail(&mem_region->reg_lnk, &ctx->mem_region_list);
+	}
+
+	return 0;
+
+fail:
+	list_for_each_entry_safe(mem_region, n,
+				 &ctx->mem_region_list, reg_lnk) {
+		vpu_iommu_free(mpp->iommu_info, ctx->session, mem_region->hdl);
+		list_del_init(&mem_region->reg_lnk);
+		kfree(mem_region);
+	}
+
+	return retval;
+}
+
+int mpp_reg_address_translate(struct rockchip_mpp_dev *mpp,
+			      u32 *reg,
+			      struct mpp_ctx *ctx,
+			      int idx)
+{
+	struct mpp_trans_info *trans_info = mpp->variant->trans_info;
+	const u8 *tbl = trans_info[idx].table;
+	int size = trans_info[idx].count;
+
+	return mpp_bufid_to_iova(mpp, tbl, size, reg, ctx);
+}
+
+void mpp_translate_extra_info(struct mpp_ctx *ctx,
+			      struct extra_info_for_iommu *ext_inf,
+			      u32 *reg)
+{
+	if (ext_inf) {
+		int i;
+
+		for (i = 0; i < ext_inf->cnt; i++) {
+			mpp_debug(DEBUG_IOMMU, "reg[%d] + offset %d\n",
+				  ext_inf->elem[i].index,
+				  ext_inf->elem[i].offset);
+			reg[ext_inf->elem[i].index] += ext_inf->elem[i].offset;
+		}
+	}
+}
+
+void mpp_dump_reg(void __iomem *regs, int count)
+{
+	int i;
+
+	pr_info("dumping registers:");
+
+	for (i = 0; i < count; i++)
+		pr_info("reg[%02d]: %08x\n", i, readl_relaxed(regs + i * 4));
+}
+
+void mpp_dump_reg_mem(u32 *regs, int count)
+{
+	int i;
+
+	pr_info("Dumping mpp_service registers:\n");
+
+	for (i = 0; i < count; i++)
+		pr_info("reg[%03d]: %08x\n", i, regs[i]);
+}
+
+int mpp_dev_common_ctx_init(struct rockchip_mpp_dev *mpp, struct mpp_ctx *cfg)
+{
+	INIT_LIST_HEAD(&cfg->session_link);
+	INIT_LIST_HEAD(&cfg->status_link);
+	INIT_LIST_HEAD(&cfg->mem_region_list);
+
+	return 0;
+}
+
+struct mpp_request {
+	u32 *req;
+	u32 size;
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_mpp_request {
+	compat_uptr_t req;
+	u32 size;
+};
+#endif
+
+#define MPP_TIMEOUT_DELAY		(2 * HZ)
+#define MPP_POWER_OFF_DELAY		(4 * HZ)
+
+static void mpp_dev_session_clear(struct rockchip_mpp_dev *mpp,
+				  struct mpp_session *session)
+{
+	struct mpp_ctx *ctx, *n;
+
+	list_for_each_entry_safe(ctx, n, &session->done, session_link) {
+		mpp_dev_common_ctx_deinit(mpp, ctx);
+	}
+}
+
+static struct mpp_ctx *ctx_init(struct rockchip_mpp_dev *mpp,
+				struct mpp_session *session,
+				void __user *src, u32 size)
+{
+	struct mpp_ctx *ctx;
+
+	mpp_debug_enter();
+
+	if (mpp->ops->init)
+		ctx = mpp->ops->init(mpp, session, src, size);
+	else
+		ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+
+	if (!ctx)
+		return NULL;
+
+	ctx->session = session;
+	ctx->mpp = mpp;
+
+	mpp_srv_pending_locked(mpp->srv, ctx);
+
+	mpp_debug_leave();
+
+	return ctx;
+}
+
+void mpp_dev_common_ctx_deinit(struct rockchip_mpp_dev *mpp,
+			       struct mpp_ctx *ctx)
+{
+	struct mpp_mem_region *mem_region = NULL, *n;
+
+	list_del_init(&ctx->session_link);
+	list_del_init(&ctx->status_link);
+
+	/* release memory region attach to this registers table. */
+	list_for_each_entry_safe(mem_region, n,
+				 &ctx->mem_region_list, reg_lnk) {
+		vpu_iommu_unmap_iommu(mpp->iommu_info, ctx->session,
+				      mem_region->hdl);
+		vpu_iommu_free(mpp->iommu_info, ctx->session, mem_region->hdl);
+		list_del_init(&mem_region->reg_lnk);
+		kfree(mem_region);
+	}
+
+	kfree(ctx);
+}
+
+static inline void mpp_queue_power_off_work(struct rockchip_mpp_dev *mpp)
+{
+	queue_delayed_work(system_wq, &mpp->power_off_work,
+			   MPP_POWER_OFF_DELAY);
+}
+
+static void mpp_power_off_work(struct work_struct *work_s)
+{
+	struct delayed_work *dlwork = container_of(work_s,
+						   struct delayed_work, work);
+	struct rockchip_mpp_dev *mpp =
+				       container_of(dlwork,
+						    struct rockchip_mpp_dev,
+						    power_off_work);
+
+	if (mutex_trylock(&mpp->srv->lock)) {
+		mpp_dev_power_off(mpp);
+		mutex_unlock(&mpp->srv->lock);
+	} else {
+		/* Come back later if the device is busy... */
+		mpp_queue_power_off_work(mpp);
+	}
+}
+
+static void mpp_dev_reset(struct rockchip_mpp_dev *mpp)
+{
+	mpp_debug_enter();
+
+	atomic_set(&mpp->reset_request, 0);
+
+	mpp->variant->reset(mpp);
+
+	if (!mpp->iommu_enable)
+		return;
+
+	if (test_bit(MMU_ACTIVATED, &mpp->state)) {
+		if (atomic_read(&mpp->enabled))
+			vpu_iommu_detach(mpp->iommu_info);
+		else
+			WARN_ON(!atomic_read(&mpp->enabled));
+
+		vpu_iommu_attach(mpp->iommu_info);
+	}
+
+	mpp_debug_leave();
+}
+
+void mpp_dev_power_on(struct rockchip_mpp_dev *mpp)
+{
+	int ret;
+	ktime_t now = ktime_get();
+
+	if (ktime_to_ns(ktime_sub(now, mpp->last)) > NSEC_PER_SEC) {
+		cancel_delayed_work_sync(&mpp->power_off_work);
+		mpp_queue_power_off_work(mpp);
+		mpp->last = now;
+	}
+	ret = atomic_add_unless(&mpp->enabled, 1, 1);
+	if (!ret)
+		return;
+
+	pr_info("%s: power on\n", dev_name(mpp->dev));
+
+	mpp->variant->power_on(mpp);
+	if (mpp->iommu_enable) {
+		set_bit(MMU_ACTIVATED, &mpp->state);
+		vpu_iommu_attach(mpp->iommu_info);
+	}
+	atomic_add(1, &mpp->power_on_cnt);
+	wake_lock(&mpp->wake_lock);
+}
+
+void mpp_dev_power_off(struct rockchip_mpp_dev *mpp)
+{
+	int total_running;
+	int ret = atomic_add_unless(&mpp->enabled, -1, 0);
+
+	if (!ret)
+		return;
+
+	total_running = atomic_read(&mpp->total_running);
+	if (total_running) {
+		pr_alert("alert: power off when %d task running!!\n",
+			 total_running);
+		mdelay(50);
+		pr_alert("alert: delay 50 ms for running task\n");
+	}
+
+	pr_info("%s: power off...", dev_name(mpp->dev));
+
+	if (mpp->iommu_enable) {
+		clear_bit(MMU_ACTIVATED, &mpp->state);
+		vpu_iommu_detach(mpp->iommu_info);
+	}
+	mpp->variant->power_off(mpp);
+
+	atomic_add(1, &mpp->power_off_cnt);
+	wake_unlock(&mpp->wake_lock);
+	pr_info("done\n");
+}
+
+bool mpp_dev_is_power_on(struct rockchip_mpp_dev *mpp)
+{
+	return !!atomic_read(&mpp->enabled);
+}
+
+static void rockchip_mpp_run(struct rockchip_mpp_dev *mpp)
+{
+	struct mpp_ctx *ctx;
+
+	mpp_debug_enter();
+
+	mpp_srv_run(mpp->srv);
+
+	ctx = mpp_srv_get_last_running_ctx(mpp->srv);
+	mpp_time_record(ctx);
+
+	mpp_dev_power_on(mpp);
+
+	mpp_debug(DEBUG_TASK_INFO, "pid %d, start hw %s\n",
+		  ctx->session->pid, dev_name(mpp->dev));
+
+	if (atomic_read(&mpp->reset_request))
+		mpp_dev_reset(mpp);
+
+	if (unlikely(mpp_dev_debug & DEBUG_REGISTER))
+		mpp_dump_reg(mpp->reg_base, mpp->variant->reg_len);
+
+	atomic_add(1, &mpp->total_running);
+	if (mpp->ops->run)
+		mpp->ops->run(mpp);
+
+	mpp_debug_leave();
+}
+
+static void rockchip_mpp_try_run(struct rockchip_mpp_dev *mpp)
+{
+	int ret = 0;
+	struct rockchip_mpp_dev *pending;
+	struct mpp_ctx *ctx;
+
+	mpp_debug_enter();
+
+	if (!mpp_srv_pending_is_empty(mpp->srv)) {
+		/*
+		 * if prepare func in hw driver define, state will be determined
+		 * by hw driver prepare func, or state will be determined by
+		 * service. ret = 0, run ready ctx.
+		 */
+		ctx = mpp_srv_get_pending_ctx(mpp->srv);
+		pending = ctx->mpp;
+		if (mpp->ops->prepare)
+			ret = mpp->ops->prepare(pending);
+		else if (mpp_srv_is_running(mpp->srv))
+			ret = -1;
+
+		if (ret == 0)
+			rockchip_mpp_run(pending);
+	}
+
+	mpp_debug_leave();
+}
+
+static int rockchip_mpp_result(struct rockchip_mpp_dev *mpp,
+			       struct mpp_ctx *ctx, u32 __user *dst)
+{
+	mpp_debug_enter();
+
+	if (mpp->ops->result)
+		mpp->ops->result(mpp, ctx, dst);
+
+	mpp_dev_common_ctx_deinit(mpp, ctx);
+
+	mpp_debug_leave();
+	return 0;
+}
+
+static int mpp_dev_wait_result(struct mpp_session *session,
+			       struct rockchip_mpp_dev *mpp,
+			       u32 __user *req)
+{
+	struct mpp_ctx *ctx;
+	int ret;
+
+	ret = wait_event_timeout(session->wait,
+				 !list_empty(&session->done),
+				 MPP_TIMEOUT_DELAY);
+
+	if (!list_empty(&session->done)) {
+		if (ret < 0)
+			mpp_err("warning: pid %d wait task error ret %d\n",
+				session->pid, ret);
+		ret = 0;
+	} else {
+		if (unlikely(ret < 0)) {
+			mpp_err("error: pid %d wait task ret %d\n",
+				session->pid, ret);
+		} else if (ret == 0) {
+			mpp_err("error: pid %d wait %d task done timeout\n",
+				session->pid,
+				atomic_read(&session->task_running));
+			ret = -ETIMEDOUT;
+
+			mpp_dump_reg(mpp->reg_base, mpp->variant->reg_len);
+		}
+	}
+
+	if (ret < 0) {
+		mpp_srv_lock(mpp->srv);
+		atomic_sub(1, &mpp->total_running);
+
+		if (mpp->variant->reset)
+			mpp->variant->reset(mpp);
+		mpp_srv_unlock(mpp->srv);
+		return ret;
+	}
+
+	mpp_srv_lock(mpp->srv);
+	ctx = mpp_srv_get_done_ctx(session);
+	rockchip_mpp_result(mpp, ctx, req);
+	mpp_srv_unlock(mpp->srv);
+
+	return 0;
+}
+
+static long mpp_dev_ioctl(struct file *filp, unsigned int cmd,
+			  unsigned long arg)
+{
+	struct rockchip_mpp_dev *mpp =
+			container_of(filp->f_path.dentry->d_inode->i_cdev,
+				     struct rockchip_mpp_dev,
+				     cdev);
+	struct mpp_session *session = (struct mpp_session *)filp->private_data;
+
+	mpp_debug_enter();
+	if (!session)
+		return -EINVAL;
+
+	switch (cmd) {
+	case MPP_IOC_SET_CLIENT_TYPE:
+		break;
+	case MPP_IOC_SET_REG:
+		{
+			struct mpp_request req;
+			struct mpp_ctx *ctx;
+
+			mpp_debug(DEBUG_IOCTL, "pid %d set reg\n",
+				  session->pid);
+			if (copy_from_user(&req, (void __user *)arg,
+					   sizeof(struct mpp_request))) {
+				mpp_err("error: set reg copy_from_user failed\n");
+				return -EFAULT;
+			}
+			ctx = ctx_init(mpp, session, (void __user *)req.req,
+				       req.size);
+			if (!ctx)
+				return -EFAULT;
+
+			mpp_srv_lock(mpp->srv);
+			rockchip_mpp_try_run(mpp);
+			mpp_srv_unlock(mpp->srv);
+		}
+		break;
+	case MPP_IOC_GET_REG:
+		{
+			struct mpp_request req;
+
+			mpp_debug(DEBUG_IOCTL, "pid %d get reg\n",
+				  session->pid);
+			if (copy_from_user(&req, (void __user *)arg,
+					   sizeof(struct mpp_request))) {
+				mpp_err("error: get reg copy_from_user failed\n");
+				return -EFAULT;
+			}
+
+			return mpp_dev_wait_result(session, mpp, req.req);
+		}
+		break;
+	case MPP_IOC_PROBE_IOMMU_STATUS:
+		{
+			int iommu_enable = 1;
+
+			mpp_debug(DEBUG_IOCTL, "VPU_IOC_PROBE_IOMMU_STATUS\n");
+
+			if (copy_to_user((void __user *)arg,
+					 &iommu_enable, sizeof(int))) {
+				mpp_err("error: iommu status copy_to_user failed\n");
+				return -EFAULT;
+			}
+		}
+		break;
+	default:
+		{
+			if (mpp->ops->ioctl)
+				return mpp->ops->ioctl(session, cmd, arg);
+
+			mpp_err("unknown mpp ioctl cmd %x\n", cmd);
+		}
+		break;
+	}
+
+	mpp_debug_leave();
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long compat_mpp_dev_ioctl(struct file *filp, unsigned int cmd,
+				 unsigned long arg)
+{
+	struct rockchip_mpp_dev *mpp =
+			container_of(filp->f_path.dentry->d_inode->i_cdev,
+				     struct rockchip_mpp_dev, cdev);
+	struct mpp_session *session = (struct mpp_session *)filp->private_data;
+
+	mpp_debug_enter();
+
+	if (!session)
+		return -EINVAL;
+
+	switch (cmd) {
+	case MPP_IOC_SET_CLIENT_TYPE:
+		break;
+	case MPP_IOC_SET_REG:
+		{
+			struct compat_mpp_request req;
+			struct mpp_ctx *ctx;
+
+			mpp_debug(DEBUG_IOCTL, "compat set reg\n");
+			if (copy_from_user(&req, compat_ptr((compat_uptr_t)arg),
+					   sizeof(struct compat_mpp_request))) {
+				mpp_err("compat set_reg copy_from_user failed\n");
+				return -EFAULT;
+			}
+			ctx = ctx_init(mpp, session,
+				       compat_ptr((compat_uptr_t)req.req),
+				       req.size);
+			if (!ctx)
+				return -EFAULT;
+
+			mpp_srv_lock(mpp->srv);
+			rockchip_mpp_try_run(mpp);
+			mpp_srv_unlock(mpp->srv);
+		}
+		break;
+	case MPP_IOC_GET_REG:
+		{
+			struct compat_mpp_request req;
+
+			mpp_debug(DEBUG_IOCTL, "compat get reg\n");
+			if (copy_from_user(&req, compat_ptr((compat_uptr_t)arg),
+					   sizeof(struct compat_mpp_request))) {
+				mpp_err("compat get reg copy_from_user failed\n");
+				return -EFAULT;
+			}
+
+			return mpp_dev_wait_result(session,
+						   mpp,
+						   compat_ptr((compat_uptr_t)req.req));
+		}
+		break;
+	case MPP_IOC_PROBE_IOMMU_STATUS:
+		{
+			int iommu_enable = 1;
+
+			mpp_debug(DEBUG_IOCTL, "COMPAT_VPU_IOC_PROBE_IOMMU_STATUS\n");
+
+			if (copy_to_user(compat_ptr((compat_uptr_t)arg),
+					 &iommu_enable, sizeof(int))) {
+				mpp_err("error: VPU_IOC_PROBE_IOMMU_STATUS failed\n");
+				return -EFAULT;
+			}
+		}
+		break;
+	default:
+		{
+			if (mpp->ops->ioctl)
+				return mpp->ops->ioctl(session, cmd, arg);
+
+			mpp_err("unknown mpp ioctl cmd %x\n", cmd);
+		}
+		break;
+	}
+	mpp_debug_leave();
+	return 0;
+}
+#endif
+
+static int mpp_dev_open(struct inode *inode, struct file *filp)
+{
+	struct rockchip_mpp_dev *mpp =
+				       container_of(inode->i_cdev,
+						    struct rockchip_mpp_dev,
+						    cdev);
+	struct mpp_session *session;
+
+	mpp_debug_enter();
+
+	if (mpp->ops->open)
+		session = mpp->ops->open(mpp);
+	else
+		session = kzalloc(sizeof(*session), GFP_KERNEL);
+
+	if (!session)
+		return -ENOMEM;
+
+	session->pid = current->pid;
+	session->mpp = mpp;
+	INIT_LIST_HEAD(&session->done);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	atomic_set(&session->task_running, 0);
+	mpp_srv_lock(mpp->srv);
+	list_add_tail(&session->list_session, &mpp->srv->session);
+	filp->private_data = (void *)session;
+	mpp_srv_unlock(mpp->srv);
+
+	mpp_debug_leave();
+
+	return nonseekable_open(inode, filp);
+}
+
+static int mpp_dev_release(struct inode *inode, struct file *filp)
+{
+	struct rockchip_mpp_dev *mpp = container_of(
+						    inode->i_cdev,
+						    struct rockchip_mpp_dev,
+						    cdev);
+	int task_running;
+	struct mpp_session *session = filp->private_data;
+
+	mpp_debug_enter();
+	if (!session)
+		return -EINVAL;
+
+	task_running = atomic_read(&session->task_running);
+	if (task_running) {
+		pr_err("session %d still has %d task running when closing\n",
+		       session->pid, task_running);
+		msleep(50);
+	}
+	wake_up(&session->wait);
+
+	if (mpp->ops->release)
+		mpp->ops->release(session);
+	mpp_srv_lock(mpp->srv);
+	/* remove this filp from the asynchronusly notified filp's */
+	list_del_init(&session->list_session);
+	mpp_dev_session_clear(mpp, session);
+	vpu_iommu_clear(mpp->iommu_info, session);
+	filp->private_data = NULL;
+	mpp_srv_unlock(mpp->srv);
+	if (mpp->ops->free)
+		mpp->ops->free(session);
+	else
+		kfree(session);
+
+	pr_debug("dev closed\n");
+	mpp_debug_leave();
+	return 0;
+}
+
+static const struct file_operations mpp_dev_fops = {
+	.unlocked_ioctl = mpp_dev_ioctl,
+	.open		= mpp_dev_open,
+	.release	= mpp_dev_release,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = compat_mpp_dev_ioctl,
+#endif
+};
+
+static irqreturn_t mpp_irq(int irq, void *dev_id)
+{
+	struct rockchip_mpp_dev *mpp = dev_id;
+
+	int ret = -1;
+
+	if (mpp->ops->irq)
+		ret = mpp->ops->irq(mpp);
+
+	if (ret < 0)
+		return IRQ_NONE;
+	else
+		return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t mpp_isr(int irq, void *dev_id)
+{
+	struct rockchip_mpp_dev *mpp = dev_id;
+	struct mpp_ctx *ctx;
+	int ret = 0;
+
+	ctx = mpp_srv_get_current_ctx(mpp->srv);
+	if (IS_ERR_OR_NULL(ctx)) {
+		mpp_err("no current context present\n");
+		return IRQ_HANDLED;
+	}
+
+	mpp_time_diff(ctx);
+	mpp_srv_lock(mpp->srv);
+
+	if (mpp->ops->done)
+		ret = mpp->ops->done(mpp);
+
+	if (ret == 0)
+		mpp_srv_done(mpp->srv);
+
+	atomic_sub(1, &mpp->total_running);
+	rockchip_mpp_try_run(mpp);
+
+	mpp_srv_unlock(mpp->srv);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_IOMMU_API
+static inline void platform_set_sysmmu(struct device *iommu,
+				       struct device *dev)
+{
+	dev->archdata.iommu = iommu;
+}
+#else
+static inline void platform_set_sysmmu(struct device *iommu,
+				       struct device *dev)
+{
+}
+#endif
+
+static int mpp_sysmmu_fault_hdl(struct device *dev,
+				enum rk_iommu_inttype itype,
+				unsigned long pgtable_base,
+				unsigned long fault_addr, unsigned int status)
+{
+	struct platform_device *pdev;
+	struct rockchip_mpp_dev *mpp;
+	struct mpp_ctx *ctx;
+
+	mpp_debug_enter();
+
+	if (!dev) {
+		mpp_err("invalid NULL dev\n");
+		return 0;
+	}
+
+	pdev = container_of(dev, struct platform_device, dev);
+	if (!pdev) {
+		mpp_err("invalid NULL platform_device\n");
+		return 0;
+	}
+
+	mpp = platform_get_drvdata(pdev);
+	if (!mpp || !mpp->srv) {
+		mpp_err("invalid mpp_dev or mpp_srv\n");
+		return 0;
+	}
+
+	ctx = mpp_srv_get_current_ctx(mpp->srv);
+	if (ctx) {
+		struct mpp_mem_region *mem, *n;
+		int i = 0;
+
+		mpp_err("mpp, fault addr 0x%08lx\n", fault_addr);
+		if (!list_empty(&ctx->mem_region_list)) {
+			list_for_each_entry_safe(mem, n, &ctx->mem_region_list,
+						 reg_lnk) {
+				mpp_err("mpp, reg[%02u] mem[%02d] 0x%lx %lx\n",
+					mem->reg_idx, i, mem->iova, mem->len);
+				i++;
+			}
+		} else {
+			mpp_err("no memory region mapped\n");
+		}
+
+		if (ctx->mpp) {
+			struct rockchip_mpp_dev *mpp = ctx->mpp;
+
+			mpp_err("current errror register set:\n");
+			mpp_dump_reg(mpp->reg_base, mpp->variant->reg_len);
+		}
+
+		if (mpp->variant->reset)
+			mpp->variant->reset(mpp);
+	}
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static struct device *rockchip_get_sysmmu_dev(const char *compt)
+{
+	struct device_node *dn = NULL;
+	struct platform_device *pd = NULL;
+	struct device *ret = NULL;
+
+	dn = of_find_compatible_node(NULL, NULL, compt);
+	if (!dn) {
+		pr_err("can't find device node %s \r\n", compt);
+		return NULL;
+	}
+
+	pd = of_find_device_by_node(dn);
+	if (!pd) {
+		pr_err("can't find platform device in device node %s\n", compt);
+		return  NULL;
+	}
+	ret = &pd->dev;
+
+	return ret;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id mpp_dev_dt_ids[] = {
+	{ .compatible = "rockchip,rkvenc", .data = &rkvenc_variant, },
+	{ .compatible = "rockchip,vepu", .data = &vepu_variant, },
+	{ .compatible = "rockchip,h265e", .data = &h265e_variant, },
+	{ },
+};
+#endif
+
+static int mpp_dev_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *dev = &pdev->dev;
+	char *name = (char *)dev_name(dev);
+	struct device_node *np = pdev->dev.of_node;
+	struct rockchip_mpp_dev *mpp = NULL;
+	const struct of_device_id *match;
+	const struct rockchip_mpp_dev_variant *variant;
+	struct device_node *srv_np, *mmu_np;
+	struct platform_device *srv_pdev;
+	struct resource *res = NULL;
+	struct mpp_session *session;
+	int allocator_type;
+
+	pr_info("probe device %s\n", dev_name(dev));
+
+	match = of_match_node(mpp_dev_dt_ids, dev->of_node);
+	variant = match->data;
+
+	mpp = devm_kzalloc(dev, variant->data_len, GFP_KERNEL);
+
+	/* Get service */
+	srv_np = of_parse_phandle(np, "rockchip,srv", 0);
+	srv_pdev = of_find_device_by_node(srv_np);
+
+	mpp->srv = platform_get_drvdata(srv_pdev);
+
+	mpp->dev = dev;
+	mpp->state = 0;
+	mpp->variant = variant;
+
+	wake_lock_init(&mpp->wake_lock, WAKE_LOCK_SUSPEND, "mpp");
+	atomic_set(&mpp->enabled, 0);
+	atomic_set(&mpp->power_on_cnt, 0);
+	atomic_set(&mpp->power_off_cnt, 0);
+	atomic_set(&mpp->total_running, 0);
+	atomic_set(&mpp->reset_request, 0);
+
+	INIT_DELAYED_WORK(&mpp->power_off_work, mpp_power_off_work);
+	mpp->last.tv64 = 0;
+
+	of_property_read_string(np, "name", (const char **)&name);
+	of_property_read_u32(np, "iommu_enabled", &mpp->iommu_enable);
+
+	if (mpp->srv->reg_base == 0) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		mpp->reg_base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(mpp->reg_base)) {
+			ret = PTR_ERR(mpp->reg_base);
+			goto err;
+		}
+	} else {
+		mpp->reg_base = mpp->srv->reg_base;
+	}
+
+	mpp->irq = platform_get_irq(pdev, 0);
+	if (mpp->irq > 0) {
+		ret = devm_request_threaded_irq(dev, mpp->irq,
+						mpp_irq, mpp_isr,
+						IRQF_SHARED, dev_name(dev),
+						(void *)mpp);
+		if (ret) {
+			dev_err(dev, "error: can't request vepu irq %d\n",
+				mpp->irq);
+			goto err;
+		}
+	} else {
+		dev_info(dev, "No interrupt resource found\n");
+	}
+
+	mmu_np = of_parse_phandle(np, "iommus", 0);
+	if (mmu_np) {
+		struct platform_device *pd = NULL;
+
+		pd = of_find_device_by_node(mmu_np);
+		mpp->mmu_dev = &pd->dev;
+		if (!mpp->mmu_dev) {
+			mpp->iommu_enable = false;
+			dev_err(dev, "get iommu dev failed");
+		}
+	} else {
+		mpp->mmu_dev =
+			rockchip_get_sysmmu_dev(mpp->variant->mmu_dev_dts_name);
+		if (mpp->mmu_dev) {
+			platform_set_sysmmu(mpp->mmu_dev, dev);
+			rockchip_iovmm_set_fault_handler(dev,
+							 mpp_sysmmu_fault_hdl);
+		} else {
+			dev_err(dev,
+				"get iommu dev %s failed, set iommu_enable to false\n",
+				mpp->variant->mmu_dev_dts_name);
+			mpp->iommu_enable = false;
+		}
+	}
+
+	dev_info(dev, "try to get iommu dev %p\n",
+		 mpp->mmu_dev);
+
+	of_property_read_u32(np, "allocator", &allocator_type);
+	mpp->iommu_info = vpu_iommu_info_create(dev, mpp->mmu_dev,
+						allocator_type);
+	if (IS_ERR(mpp->iommu_info)) {
+		dev_err(dev, "failed to create ion client for mpp ret %ld\n",
+			PTR_ERR(mpp->iommu_info));
+	}
+
+	/*
+	 * this session is global session, each dev
+	 * only has one global session, and will be
+	 * release when dev remove
+	 */
+	session = devm_kzalloc(dev, sizeof(*session), GFP_KERNEL);
+
+	if (!session)
+		return -ENOMEM;
+
+	session->mpp = mpp;
+	INIT_LIST_HEAD(&session->done);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	atomic_set(&session->task_running, 0);
+	/* this first session of each dev is global session */
+	list_add_tail(&session->list_session, &mpp->srv->session);
+
+	ret = mpp->variant->hw_probe(mpp);
+	if (ret)
+		goto err;
+
+	dev_info(dev, "resource ready, register device\n");
+	/* create device node */
+	ret = alloc_chrdev_region(&mpp->dev_t, 0, 1, name);
+	if (ret) {
+		dev_err(dev, "alloc dev_t failed\n");
+		goto err;
+	}
+
+	cdev_init(&mpp->cdev, &mpp_dev_fops);
+
+	mpp->cdev.owner = THIS_MODULE;
+	mpp->cdev.ops = &mpp_dev_fops;
+
+	ret = cdev_add(&mpp->cdev, mpp->dev_t, 1);
+	if (ret) {
+		unregister_chrdev_region(mpp->dev_t, 1);
+		dev_err(dev, "add dev_t failed\n");
+		goto err;
+	}
+
+	mpp->child_dev = device_create(mpp->srv->cls, dev,
+				       mpp->dev_t, NULL, name);
+
+	mpp_srv_attach(mpp->srv, &mpp->lnk_service);
+
+	platform_set_drvdata(pdev, mpp);
+
+	return 0;
+err:
+	wake_lock_destroy(&mpp->wake_lock);
+	return ret;
+}
+
+static int mpp_dev_remove(struct platform_device *pdev)
+{
+	struct rockchip_mpp_dev *mpp = platform_get_drvdata(pdev);
+	struct mpp_session *session = list_first_entry(&mpp->srv->session,
+						       struct mpp_session,
+						       list_session);
+
+	mpp->variant->hw_remove(mpp);
+
+	vpu_iommu_clear(mpp->iommu_info, session);
+	vpu_iommu_destroy(mpp->iommu_info);
+	kfree(session);
+
+	mpp_srv_lock(mpp->srv);
+	cancel_delayed_work_sync(&mpp->power_off_work);
+	mpp_dev_power_off(mpp);
+	mpp_srv_detach(mpp->srv, &mpp->lnk_service);
+	mpp_srv_unlock(mpp->srv);
+
+	device_destroy(mpp->srv->cls, mpp->dev_t);
+	cdev_del(&mpp->cdev);
+	unregister_chrdev_region(mpp->dev_t, 1);
+
+	return 0;
+}
+
+static struct platform_driver mpp_dev_driver = {
+	.probe = mpp_dev_probe,
+	.remove = mpp_dev_remove,
+	.driver = {
+		.name = "mpp_dev",
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(mpp_dev_dt_ids),
+#endif
+	},
+};
+
+static int __init mpp_dev_init(void)
+{
+	int ret = platform_driver_register(&mpp_dev_driver);
+
+	if (ret) {
+		mpp_err("Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit mpp_dev_exit(void)
+{
+	platform_driver_unregister(&mpp_dev_driver);
+}
+
+module_init(mpp_dev_init);
+module_exit(mpp_dev_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.build.201610121711");
+MODULE_AUTHOR("Alpha Lin alpha.lin@rock-chips.com");
+MODULE_DESCRIPTION("Rockchip mpp device driver");
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_common.h b/drivers/video/rockchip/vpu/mpp_dev_common.h
--- a/drivers/video/rockchip/vpu/mpp_dev_common.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_common.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,310 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ROCKCHIP_MPP_DEV_COMMON_H
+#define __ROCKCHIP_MPP_DEV_COMMON_H
+
+#include <linux/cdev.h>
+#include <linux/dma-buf.h>
+#include <linux/rockchip_ion.h>
+#include <linux/rockchip-iovmm.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/wakelock.h>
+
+extern int mpp_dev_debug;
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'l' as magic number */
+#define MPP_IOC_MAGIC			'l'
+
+#define MPP_IOC_SET_CLIENT_TYPE		_IOW(MPP_IOC_MAGIC, 1, u32)
+#define MPP_IOC_GET_HW_FUSE_STATUS	_IOW(MPP_IOC_MAGIC, 2, u32)
+
+#define MPP_IOC_SET_REG			_IOW(MPP_IOC_MAGIC, 3, u32)
+#define MPP_IOC_GET_REG			_IOW(MPP_IOC_MAGIC, 4, u32)
+
+#define MPP_IOC_PROBE_IOMMU_STATUS	_IOR(MPP_IOC_MAGIC, 5, u32)
+#define MPP_IOC_CUSTOM_BASE			0x1000
+
+/*
+ * debug flag usage:
+ * +------+-------------------+
+ * | 8bit |      24bit        |
+ * +------+-------------------+
+ *  0~23 bit is for different information type
+ * 24~31 bit is for information print format
+ */
+
+#define DEBUG_POWER				0x00000001
+#define DEBUG_CLOCK				0x00000002
+#define DEBUG_IRQ_STATUS			0x00000004
+#define DEBUG_IOMMU				0x00000008
+#define DEBUG_IOCTL				0x00000010
+#define DEBUG_FUNCTION				0x00000020
+#define DEBUG_REGISTER				0x00000040
+#define DEBUG_EXTRA_INFO			0x00000080
+#define DEBUG_TIMING				0x00000100
+#define DEBUG_TASK_INFO				0x00000200
+#define DEBUG_DUMP_ERR_REG			0x00000400
+
+#define DEBUG_SET_REG				0x00001000
+#define DEBUG_GET_REG				0x00002000
+#define DEBUG_PPS_FILL				0x00004000
+#define DEBUG_IRQ_CHECK				0x00008000
+#define DEBUG_CACHE_32B				0x00010000
+
+#define DEBUG_RESET				0x00020000
+
+#define PRINT_FUNCTION				0x80000000
+#define PRINT_LINE				0x40000000
+
+#define DEBUG
+#ifdef DEBUG
+#define mpp_debug_func(type, fmt, args...)			\
+	do {							\
+		if (unlikely(mpp_dev_debug & type)) {		\
+			pr_info("%s:%d: " fmt,			\
+				 __func__, __LINE__, ##args);	\
+		}						\
+	} while (0)
+#define mpp_debug(type, fmt, args...)				\
+	do {							\
+		if (unlikely(mpp_dev_debug & type)) {		\
+			pr_info(fmt, ##args);			\
+		}						\
+	} while (0)
+#else
+#define mpp_debug_func(level, fmt, args...)
+#define mpp_debug(level, fmt, args...)
+#endif
+
+#define mpp_debug_enter() mpp_debug_func(DEBUG_FUNCTION, "enter\n")
+#define mpp_debug_leave() mpp_debug_func(DEBUG_FUNCTION, "leave\n")
+
+#define mpp_err(fmt, args...)				\
+		pr_err("%s:%d: " fmt, __func__, __LINE__, ##args)
+
+struct mpp_trans_info {
+	const int count;
+	const char * const table;
+};
+
+enum RKVENC_MODE {
+	RKVENC_MODE_NONE,
+	RKVENC_MODE_ONEFRAME,
+	RKVENC_MODE_LINKTABLE_FIX,
+	RKVENC_MODE_LINKTABLE_UPDATE,
+	RKVENC_MODE_NUM
+};
+
+struct rockchip_mpp_dev;
+struct mpp_service;
+struct mpp_ctx;
+
+struct mpp_mem_region {
+	struct list_head srv_lnk;
+	struct list_head reg_lnk;
+	struct list_head session_lnk;
+	/* virtual address for iommu */
+	unsigned long iova;
+	unsigned long len;
+	u32 reg_idx;
+	int hdl;
+};
+
+/**
+ * struct for process register set
+ *
+ * @author ChenHengming (2011-5-4)
+ */
+struct mpp_ctx {
+	/* context belong to */
+	struct rockchip_mpp_dev *mpp;
+	struct mpp_session *session;
+
+	/* link to service session */
+	struct list_head session_link;
+	/* link to service list */
+	struct list_head status_link;
+
+	struct list_head mem_region_list;
+
+	/* record context running start time */
+	struct timeval start;
+};
+
+enum vpu_ctx_state {
+	MMU_ACTIVATED	= BIT(0),
+};
+
+struct extra_info_elem {
+	u32 index;
+	u32 offset;
+};
+
+#define EXTRA_INFO_MAGIC	0x4C4A46
+
+struct extra_info_for_iommu {
+	u32 magic;
+	u32 cnt;
+	struct extra_info_elem elem[20];
+};
+
+struct rockchip_mpp_dev_variant {
+	u32 data_len;
+	u32 reg_len;
+	struct mpp_trans_info *trans_info;
+	char *mmu_dev_dts_name;
+
+	int (*hw_probe)(struct rockchip_mpp_dev *mpp);
+	void (*hw_remove)(struct rockchip_mpp_dev *mpp);
+	void (*power_on)(struct rockchip_mpp_dev *mpp);
+	void (*power_off)(struct rockchip_mpp_dev *mpp);
+	int (*reset)(struct rockchip_mpp_dev *mpp);
+};
+
+struct rockchip_mpp_dev {
+	struct mpp_dev_ops *ops;
+
+	struct cdev cdev;
+	dev_t dev_t;
+	struct device *child_dev;
+
+	int irq;
+	struct mpp_service *srv;
+
+	void __iomem *reg_base;
+	struct list_head lnk_service;
+
+	struct device *dev;
+
+	unsigned long state;
+	struct vpu_iommu_info *iommu_info;
+
+	const struct rockchip_mpp_dev_variant *variant;
+
+	struct device *mmu_dev;
+	u32 iommu_enable;
+
+	struct wake_lock wake_lock;
+	struct delayed_work power_off_work;
+	/* record previous power-on time */
+	ktime_t last;
+	atomic_t power_on_cnt;
+	atomic_t power_off_cnt;
+	atomic_t total_running;
+	atomic_t enabled;
+	atomic_t reset_request;
+};
+
+/**
+ * struct mpp_dev_ops - context specific operations for mpp_device
+ *
+ * @init	Prepare for registers file for specific hardware.
+ * @prepare	Check HW status for determining run next task or not.
+ * @run		Start a single {en,de}coding run. Set registers to hardware.
+ * @done	Read back processing results and additional data from hardware.
+ * @result	Read status to userspace.
+ * @deinit	Release the resource allocate during init.
+ * @ioctl	ioctl for special HW besides the common ioctl.
+ * @irq		interrupt service for specific hardware.
+ * @open	a specific instance open operation for hardware.
+ * @release	a specific instance release operation for hardware.
+ */
+struct mpp_dev_ops {
+	/* size: in bytes, data sent from userspace, length in bytes */
+	struct mpp_ctx *(*init)(struct rockchip_mpp_dev *mpp,
+				struct mpp_session *session,
+				void __user *src, u32 size);
+	int (*prepare)(struct rockchip_mpp_dev *mpp);
+	int (*run)(struct rockchip_mpp_dev *mpp);
+	int (*done)(struct rockchip_mpp_dev *mpp);
+	int (*irq)(struct rockchip_mpp_dev *mpp);
+	int (*result)(struct rockchip_mpp_dev *mpp, struct mpp_ctx *ctx,
+		      u32 __user *dst);
+	void (*deinit)(struct rockchip_mpp_dev *mpp);
+	long (*ioctl)(struct mpp_session *isession,
+		      unsigned int cmd, unsigned long arg);
+	struct mpp_session *(*open)(struct rockchip_mpp_dev *mpp);
+	void (*release)(struct mpp_session *session);
+	void (*free)(struct mpp_session *session);
+};
+
+void mpp_dump_reg(void __iomem *regs, int count);
+void mpp_dump_reg_mem(u32 *regs, int count);
+int mpp_reg_address_translate(struct rockchip_mpp_dev *data,
+			      u32 *reg,
+			      struct mpp_ctx *ctx,
+			      int idx);
+void mpp_translate_extra_info(struct mpp_ctx *ctx,
+			      struct extra_info_for_iommu *ext_inf,
+			      u32 *reg);
+
+int mpp_dev_common_ctx_init(struct rockchip_mpp_dev *mpp, struct mpp_ctx *cfg);
+void mpp_dev_common_ctx_deinit(struct rockchip_mpp_dev *mpp,
+			       struct mpp_ctx *ctx);
+void mpp_dev_power_on(struct rockchip_mpp_dev *mpp);
+void mpp_dev_power_off(struct rockchip_mpp_dev *mpp);
+bool mpp_dev_is_power_on(struct rockchip_mpp_dev *mpp);
+
+static inline void mpp_write_relaxed(struct rockchip_mpp_dev *mpp,
+				     u32 val, u32 reg)
+{
+	mpp_debug(DEBUG_SET_REG, "MARK: set reg[%03d]: %08x\n", reg / 4, val);
+	writel_relaxed(val, mpp->reg_base + reg);
+}
+
+static inline void mpp_write(struct rockchip_mpp_dev *mpp,
+			     u32 val, u32 reg)
+{
+	mpp_debug(DEBUG_SET_REG, "MARK: set reg[%03d]: %08x\n", reg / 4, val);
+	writel(val, mpp->reg_base + reg);
+}
+
+static inline u32 mpp_read(struct rockchip_mpp_dev *mpp, u32 reg)
+{
+	u32 val = readl(mpp->reg_base + reg);
+
+	mpp_debug(DEBUG_GET_REG, "MARK: get reg[%03d] 0x%x: %08x\n", reg / 4,
+		  reg, val);
+	return val;
+}
+
+static inline void mpp_time_record(struct mpp_ctx *ctx)
+{
+	if (unlikely(mpp_dev_debug & DEBUG_TIMING) && ctx)
+		do_gettimeofday(&ctx->start);
+}
+
+static inline void mpp_time_diff(struct mpp_ctx *ctx)
+{
+	struct timeval end;
+
+	do_gettimeofday(&end);
+	mpp_debug(DEBUG_TIMING, "consume: %ld us\n",
+		  (end.tv_sec  - ctx->start.tv_sec)  * 1000000 +
+		  (end.tv_usec - ctx->start.tv_usec));
+}
+
+extern const struct rockchip_mpp_dev_variant rkvenc_variant;
+extern const struct rockchip_mpp_dev_variant vepu_variant;
+extern const struct rockchip_mpp_dev_variant h265e_variant;
+
+#endif
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_h265e.c b/drivers/video/rockchip/vpu/mpp_dev_h265e.c
--- a/drivers/video/rockchip/vpu/mpp_dev_h265e.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_h265e.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,2148 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: hehua,hh@rock-chips.com
+ * lixinhuang, buluess.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/clk.h>
+#include <linux/compiler.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/rk_fb.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+
+#include "vpu_iommu_ops.h"
+#include "mpp_dev_common.h"
+#include "mpp_dev_h265e.h"
+#include "mpp_dev_h265e_define.h"
+#include "mpp_dev_h265e_reg.h"
+
+#define MPP_ALIGN_SIZE	0x1000
+
+#define H265E_FIRMWARE_NAME "monet.bin"
+#define PRINT_BS_DATA 0
+#if PRINT_BS_DATA
+#define H265E_BS_DATA_PATH "/h265e/bs_data"
+static char buff[1000000];
+static struct file *fp_bs[H265E_INSTANCE_NUM];
+static u32 w_bs_size;
+#endif
+
+#define H265E_WORK_BUFFER_SIZE			(128 * 1024)
+#define H265E_TEMP_BUFFER_SIZE			(1024 * 1024)
+#define H265E_CODE_BUFFER_SIZE			(1024 * 1024)
+#define H265E_SEC_AXI_BUF_SIZE			0x12800
+#define H265E_INT_CLOSE 0
+#define H265E_INT_OPEN  0x08
+#define H265E_REMAP_CODE_INDEX			0
+
+#define H265E_BUSY_CHECK_TIMEOUT		5000
+
+#define DEBUG_H265E_INFO				0x00100000
+#define DEBUG_H265E_ENCODE_ONE_FRAME	0x00200000
+#define H265E_POWER_SAVE 0
+#define H265E_CLK 1
+#ifdef CONFIG_MFD_SYSCON
+#define H265E_AXI_STATUS 1
+#endif
+static ktime_t h265e_now, h265e_last;
+
+static
+struct mpp_session *rockchip_mpp_h265e_open(struct rockchip_mpp_dev *mpp);
+static void rockchip_mpp_h265e_free(struct mpp_session *isession);
+static void rockchip_mpp_h265e_release(struct mpp_session *isession);
+static int rockchip_mpp_h265e_load_firmware(struct rockchip_mpp_dev *mpp,
+					    struct mpp_session *session);
+static int rockchip_mpp_h265e_encode_one_frame(struct rockchip_mpp_dev *mpp,
+					       struct h265e_ctx *ctx,
+					       int index);
+static int rockchip_mpp_h265e_get_encode_result(struct rockchip_mpp_dev *mpp,
+						struct h265e_ctx *result);
+static int rockchip_mpp_h265e_set_gop_parameter(struct rockchip_mpp_dev *mpp,
+						int index);
+static
+int rockchip_mpp_h265e_register_frame_buffer(struct rockchip_mpp_dev *mpp,
+					     int index);
+static void rockchip_mpp_h265e_enable_clk(struct rockchip_mpp_dev *mpp);
+static void rockchip_mpp_h265e_disable_clk(struct rockchip_mpp_dev *mpp);
+
+static void rockchip_mpp_h265e_dma_free(struct rockchip_mpp_dev *mpp,
+					struct mpp_session *session,
+					int hdl)
+{
+	if (hdl >= 0) {
+		vpu_iommu_unmap_iommu(mpp->iommu_info, session, hdl);
+		vpu_iommu_free(mpp->iommu_info, session, hdl);
+	}
+}
+
+static int rockchip_mpp_h265e_dma_alloc(struct rockchip_mpp_dev *mpp,
+					struct mpp_session *session,
+					size_t len,
+					size_t align,
+					unsigned long *addr)
+{
+	int ret = 0;
+	unsigned long tmp;
+	int tmp_hdl;
+
+	tmp_hdl = vpu_iommu_alloc(mpp->iommu_info, session, len, align);
+	if (tmp_hdl < 0) {
+		dev_err(mpp->dev, "error: ion_alloc fail\n");
+		return -1;
+	}
+
+	ret = vpu_iommu_map_iommu(mpp->iommu_info,
+				  session, tmp_hdl, addr, &tmp);
+	if (ret < 0) {
+		dev_err(mpp->dev, "get link table dma_addr failed\n");
+		goto FAIL;
+	}
+	return tmp_hdl;
+FAIL:
+	if (tmp_hdl)
+		vpu_iommu_free(mpp->iommu_info, session, tmp_hdl);
+	return -1;
+}
+
+static void rockchip_mpp_h265e_free_frame_buffer(struct rockchip_mpp_dev *mpp,
+						 struct rockchip_h265e_instance *instance)
+{
+	unsigned int i = 0;
+	struct mpp_h265e_buffer *buf = NULL;
+	struct mpp_h265e_frame_buffer *fb = NULL;
+	struct mpp_session *session = instance->session;
+
+	mpp_debug_enter();
+	buf = &instance->mv;
+	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
+	buf = &instance->fbc_luma;
+	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
+	buf = &instance->fbc_chroma;
+	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
+	buf = &instance->sub_sample;
+	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
+
+	for (i = 0; i < ARRAY_SIZE(instance->frame_buffer); i++) {
+		fb = &instance->frame_buffer[i];
+		buf = &fb->buffer;
+		rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
+		fb->y = 0;
+		fb->cb = 0;
+		fb->cr = 0;
+	}
+	mpp_debug_leave();
+}
+
+static void rockchip_mpp_h265e_free_instance(struct rockchip_mpp_dev *mpp,
+					     int index)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct rockchip_h265e_instance *instance = &enc->instance[index];
+	struct mpp_h265e_buffer *buf = &instance->work;
+	struct mpp_session *session = instance->session;
+
+	mpp_debug_enter();
+#if PRINT_BS_DATA
+	filp_close(fp_bs[index], NULL);
+#endif
+	if (!mpp || !instance)
+		return;
+	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
+	rockchip_mpp_h265e_free_frame_buffer(mpp, instance);
+	atomic_set(&enc->instance[index].is_used, 0);
+	mpp_debug_leave();
+}
+
+static int rockchip_mpp_h265e_wait_busy(struct rockchip_mpp_dev *mpp)
+{
+	int reg_val = 0xFFFFFFFF, time_count = 0;
+
+	while (reg_val != 0x0) {
+		reg_val = mpp_read(mpp, H265E_VPU_BUSY_STATUS);
+		if (time_count++ > H265E_BUSY_CHECK_TIMEOUT)
+			return -1;
+	}
+	return 0;
+}
+
+static void rockchip_mpp_h265e_issue_command(struct rockchip_mpp_dev *mpp,
+					     u32 index, u32 cmd)
+{
+	u32 value = 0;
+
+	mpp_write(mpp, 1, H265E_VPU_BUSY_STATUS);
+	value = ((index & 0xffff) | (1 << 16));
+	mpp_write(mpp, value, H265E_INST_INDEX);
+	mpp_write(mpp, cmd, H265E_COMMAND);
+	if (cmd != H265E_CMD_INIT_VPU)
+		mpp_write(mpp, 1, H265E_VPU_HOST_INT_REQ);
+}
+
+#if PRINT_BS_DATA
+static int rockchip_mpp_h265e_write_encoder_file(struct rockchip_mpp_dev *mpp)
+{
+	struct h265e_ctx *ctx = container_of(mpp_srv_get_current_ctx(mpp->srv),
+					     struct h265e_ctx, ictx);
+	struct h265e_session *session =
+					container_of(ctx->ictx.session,
+						     struct h265e_session,
+						     isession);
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	int index = session->instance_index;
+	int nread = 0;
+	loff_t pos = 0;
+	mm_segment_t old_fs;
+	u32 value = 0;
+	u32 i = 0;
+	char file_name[30];
+
+	mutex_lock(&enc->lock);
+	mpp_debug_enter();
+	value = w_bs_size;
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	sprintf(file_name, "%s_%d.bin", H265E_BS_DATA_PATH, index);
+	fp_bs[index] = filp_open(file_name, O_RDWR | O_CREAT | O_APPEND, 0x777);
+	if (IS_ERR(fp_bs[index])) {
+		mpp_err("error: open yuv failed in load_yuv\n");
+		set_fs(old_fs);
+		mutex_unlock(&enc->lock);
+		return -1;
+	}
+	for (i = 0; i < (value * 3); i++) {
+		if (ctx->bs_data[i] < 0x10) {
+			sprintf(&buff[3 * i], "0");
+			sprintf(&buff[3 * i + 1], "%-2x", ctx->bs_data[i]);
+		} else {
+			sprintf(&buff[3 * i], "%-3x", ctx->bs_data[i]);
+		}
+	}
+	nread = (int)vfs_write(fp_bs[index], buff, value * 3, &pos);
+	set_fs(old_fs);
+	mutex_unlock(&enc->lock);
+	mpp_debug_leave();
+	return 0;
+}
+#endif
+
+static int rockchip_mpp_h265e_load_firmware(struct rockchip_mpp_dev *mpp,
+					    struct mpp_session *session)
+{
+	const struct firmware *firmware;
+	u32 size = 0;
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+
+	if (request_firmware(&firmware, H265E_FIRMWARE_NAME, mpp->dev) < 0) {
+		mpp_err("firmware request failed\n");
+		release_firmware(firmware);
+		return -1;
+	}
+	mpp_debug(DEBUG_H265E_INFO, "h265e firmware data %p size %zu\n",
+		  firmware->data, firmware->size);
+	size = ALIGN(firmware->size, H265E_CODE_BUFFER_SIZE);
+	enc->firmware.hdl =
+		rockchip_mpp_h265e_dma_alloc(mpp,
+					     session,
+					     size,
+					     MPP_ALIGN_SIZE,
+					     &enc->firmware.dma_addr);
+	if (enc->firmware.hdl < 0) {
+		mpp_err("error: alloc firmware buffer error\n");
+		goto FAIL;
+	}
+	enc->firmware.size = ALIGN(firmware->size, MPP_ALIGN_SIZE);
+	enc->firmware_cpu_addr = vpu_iommu_map_kernel(mpp->iommu_info,
+						      session,
+						      enc->firmware.hdl);
+	mpp_debug(DEBUG_H265E_INFO,
+		  "firmware_buffer_size = %d,firmware size = %zd,code_base = %x\n",
+		  size, firmware->size, (u32)enc->firmware.dma_addr);
+	memcpy(enc->firmware_cpu_addr, firmware->data, firmware->size);
+	release_firmware(firmware);
+	return 0;
+FAIL:
+	release_firmware(firmware);
+	if (enc->firmware.hdl >= 0) {
+		vpu_iommu_unmap_kernel(mpp->iommu_info, session,
+				       enc->firmware.hdl);
+		vpu_iommu_free(mpp->iommu_info, session, enc->firmware.hdl);
+	}
+	return -1;
+}
+
+static struct mpp_ctx *rockchip_mpp_h265e_ctx_init(struct rockchip_mpp_dev *mpp,
+						   struct mpp_session *session,
+						   void __user *src, u32 dwsize)
+{
+	struct h265e_ctx *ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct mpp_mem_region *mem_bs_region = NULL;
+	struct mpp_mem_region *mem_src_region = NULL;
+	unsigned long size = 0;
+	int ret = 0;
+
+	mutex_lock(&enc->lock);
+	mpp_debug_enter();
+	if (!ctx) {
+		mutex_unlock(&enc->lock);
+		return NULL;
+	}
+	mpp_dev_common_ctx_init(mpp, &ctx->ictx);
+	ctx->ictx.session = session;
+	if (copy_from_user(&ctx->cfg, src, dwsize)) {
+		mpp_err("error: copy_from_user failed in reg_init\n");
+		kfree(ctx);
+		mutex_unlock(&enc->lock);
+		return NULL;
+	}
+#if H265E_POWER_SAVE
+	rockchip_mpp_h265e_enable_clk(mpp);
+#endif
+	ctx->bs.hdl = vpu_iommu_import(mpp->iommu_info, session,
+				       ctx->cfg.bs_fd);
+	if (ctx->bs.hdl < 0) {
+		mpp_err("import dma-buf from fd %d failed\n", ctx->cfg.bs_fd);
+		mutex_unlock(&enc->lock);
+		return NULL;
+	}
+
+	ret = vpu_iommu_map_iommu(mpp->iommu_info, session,
+				  ctx->bs.hdl, &ctx->bs.dma_addr, &size);
+	ctx->bs.size = (u32)size;
+#if PRINT_BS_DATA
+	ctx->bs_data = vpu_iommu_map_kernel(mpp->iommu_info, session,
+					    ctx->bs.hdl);
+#endif
+
+	if (ret < 0) {
+		mpp_err("bs fd %d ion map iommu failed\n", ctx->cfg.bs_fd);
+		goto FAIL;
+	}
+
+	ctx->src.hdl = vpu_iommu_import(mpp->iommu_info, session,
+					ctx->cfg.src_fd);
+	if (ctx->src.hdl < 0) {
+		mpp_err("import dma-buf from fd %d failed\n", ctx->cfg.src_fd);
+		goto FAIL;
+	}
+	ret = vpu_iommu_map_iommu(mpp->iommu_info, session,
+				  ctx->src.hdl, &ctx->src.dma_addr, &size);
+	ctx->src.size = (u32)size;
+
+	if (ret < 0) {
+		mpp_err("source fd %d ion map iommu failed\n", ctx->cfg.src_fd);
+		goto FAIL;
+	}
+
+	mem_bs_region = kzalloc(sizeof(*mem_bs_region), GFP_KERNEL);
+	if (!mem_bs_region)
+		goto FAIL;
+	mem_src_region = kzalloc(sizeof(*mem_src_region), GFP_KERNEL);
+	if (!mem_src_region)
+		goto FAIL;
+	mem_bs_region->hdl = ctx->bs.hdl;
+	INIT_LIST_HEAD(&mem_bs_region->reg_lnk);
+	list_add_tail(&mem_bs_region->reg_lnk, &ctx->ictx.mem_region_list);
+
+	mem_src_region->hdl = ctx->src.hdl;
+	INIT_LIST_HEAD(&mem_src_region->reg_lnk);
+	list_add_tail(&mem_src_region->reg_lnk, &ctx->ictx.mem_region_list);
+
+	ctx->mode = H265E_MODE_ONEFRAME;
+	mpp_debug_leave();
+	mutex_unlock(&enc->lock);
+
+	return &ctx->ictx;
+
+FAIL:
+	if (ctx->bs.hdl >= 0) {
+		vpu_iommu_unmap_kernel(mpp->iommu_info, session, ctx->bs.hdl);
+		vpu_iommu_free(mpp->iommu_info, session, ctx->bs.hdl);
+	}
+
+	if (ctx->src.hdl >= 0) {
+		vpu_iommu_unmap_kernel(mpp->iommu_info, session, ctx->src.hdl);
+		vpu_iommu_free(mpp->iommu_info, session, ctx->src.hdl);
+	}
+
+	if (!IS_ERR_OR_NULL(mem_bs_region)) {
+		kfree(mem_bs_region);
+		mem_bs_region = NULL;
+	}
+
+	if (!IS_ERR_OR_NULL(mem_src_region)) {
+		kfree(mem_src_region);
+		mem_src_region = NULL;
+	}
+
+	if (!IS_ERR_OR_NULL(ctx)) {
+		kfree(ctx);
+		ctx = NULL;
+	}
+	mutex_unlock(&enc->lock);
+	return NULL;
+}
+
+static int rockchip_mpp_h265e_run(struct rockchip_mpp_dev *mpp)
+{
+	struct h265e_ctx *ctx = container_of(mpp_srv_get_current_ctx(mpp->srv),
+					     struct h265e_ctx, ictx);
+	struct h265e_session *session =
+					container_of(ctx->ictx.session,
+						     struct h265e_session,
+						     isession);
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	int index = session->instance_index;
+
+	mpp_debug_enter();
+#ifdef CONFIG_MFD_SYSCON
+	if (enc->grf) {
+		u32 raw;
+		u32 bits = BIT(enc->mode_bit);
+
+		regmap_read(enc->grf, enc->mode_ctrl, &raw);
+		regmap_write(enc->grf, enc->mode_ctrl,
+			     (raw | bits) | (bits << 16));
+	}
+#endif
+	rockchip_mpp_h265e_encode_one_frame(mpp, ctx, index);
+	mpp_debug_leave();
+	return 0;
+}
+
+static int rockchip_mpp_h265e_done(struct rockchip_mpp_dev *mpp)
+{
+	struct mpp_ctx *ictx = mpp_srv_get_current_ctx(mpp->srv);
+	struct h265e_ctx *ctx = container_of(ictx, struct h265e_ctx, ictx);
+	int ret = 0;
+
+	mpp_debug_enter();
+	if (IS_ERR_OR_NULL(ictx)) {
+		mpp_err("Invaidate context to save result\n");
+		return -1;
+	}
+	ret = rockchip_mpp_h265e_get_encode_result(mpp, ctx);
+#if PRINT_BS_DATA
+	rockchip_mpp_h265e_write_encoder_file(mpp);
+#endif
+	mpp_debug_leave();
+
+	return ret;
+}
+
+static int rockchip_mpp_h265e_irq(struct rockchip_mpp_dev *mpp)
+{
+	int reason = -1;
+
+	reason = mpp_read(mpp, H265E_VPU_VINT_REASON_USR);
+	mpp_write(mpp, reason, H265E_VPU_VINT_REASON_CLR);
+	mpp_write(mpp, 1, H265E_VPU_VINT_CLEAR);
+	mpp_write(mpp, 0, H265E_VPU_VINT_REASON_USR);
+	if (reason & (1 << INT_BIT_BIT_BUF_FULL))
+		return -1;
+	else if (reason == 0x02)
+		return -1;
+
+	return 0;
+}
+
+static int rockchip_mpp_h265e_result(struct rockchip_mpp_dev *mpp,
+				     struct mpp_ctx *ictx, u32 __user *dst)
+{
+	struct h265e_ctx *ctx = container_of(ictx, struct h265e_ctx, ictx);
+
+	switch (ctx->mode) {
+	case H265E_MODE_ONEFRAME:
+		if (copy_to_user(dst, &ctx->result,
+				 sizeof(struct h265e_result))) {
+			mpp_err("copy result to user failed\n");
+			return -1;
+		}
+		break;
+	default:
+		mpp_err("invalid context mode %d\n", (int)ctx->mode);
+		return -1;
+	}
+
+	return 0;
+}
+
+#ifdef H265E_STREAM_HEADER
+static int rockchip_mpp_h265e_get_stream_header(struct rockchip_mpp_dev *mpp,
+						int index,
+						struct hal_h265e_header *head)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+
+	struct rockchip_h265e_instance *instance = NULL;
+	struct mpp_h265e_cfg *cfg = NULL;
+	u32 value = 0;
+	u32 address = 0;
+	int bs_hd;
+	unsigned long bs_address;
+	unsigned long bs_size;
+	int ret = 0;
+
+	if (index < 0 || index >= H265E_INSTANCE_NUM || !head) {
+		mpp_err("index = %d is invalid", index);
+		return -1;
+	}
+	mutex_lock(&enc->lock);
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_enable_clk(mpp);
+#endif
+	mpp_debug_enter();
+	head->size = 0;
+	instance = &enc->instance[index];
+	cfg = &instance->cfg;
+	address = head->buf;
+
+	bs_hd = vpu_iommu_import(mpp->iommu_info, instance->session, address);
+	if (bs_hd < 0) {
+		mpp_err("import dma-buf from fd %d failed\n", address);
+		mutex_unlock(&enc->lock);
+		return -1;
+	}
+	ret = vpu_iommu_map_iommu(mpp->iommu_info,
+				  instance->session, bs_hd, &bs_address,
+				  &bs_size);
+	if (ret < 0) {
+		mpp_err("bs fd %d ion map iommu failed\n", address);
+		goto FAIL;
+	}
+	mpp_write(mpp, (u32)bs_address, H265E_BS_START_ADDR);
+	mpp_write(mpp, (u32)bs_address, H265E_BS_SIZE);
+
+	mpp_write(mpp, (u32)bs_address, H265E_BS_RD_PTR);
+	mpp_write(mpp, (u32)bs_address, H265E_BS_WR_PTR);
+
+	value = (cfg->line_buf_int_en << 6) |
+		(cfg->slice_int_enable << 5) |
+		(cfg->ring_buffer_enable << 4) |
+		cfg->bs_endian;
+	mpp_write(mpp, value, H265E_BS_PARAM);
+	mpp_write(mpp, 0, H265E_BS_OPTION);
+
+	/* Set up work-buffer */
+	mpp_write(mpp, instance->work.dma_addr, H265E_ADDR_WORK_BASE);
+	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
+	mpp_write(mpp, 0, H265E_WORK_PARAM);
+
+	/* Set up temp-buffer */
+	mpp_write(mpp, enc->temp.dma_addr, H265E_ADDR_TEMP_BASE);
+	mpp_write(mpp, enc->temp.size, H265E_TEMP_SIZE);
+	mpp_write(mpp, 0, H265E_TEMP_PARAM);
+
+	mpp_write(mpp, 0, H265E_ENC_SRC_PIC_IDX);
+	if (cfg->code_option.implicit_header_encode == 1) {
+		value = CODEOPT_ENC_HEADER_IMPLICIT |
+			CODEOPT_ENC_VCL |
+			(cfg->code_option.encode_aud << 5) |
+			(cfg->code_option.encode_eos << 6) |
+			(cfg->code_option.encode_eob << 7);
+	} else {
+		value = (cfg->code_option.implicit_header_encode << 0) |
+			(cfg->code_option.encode_vcl << 1) |
+			(cfg->code_option.encode_vps << 2) |
+			(cfg->code_option.encode_sps << 3) |
+			(cfg->code_option.encode_pps << 4) |
+			(cfg->code_option.encode_aud << 5) |
+			(cfg->code_option.encode_eos << 6) |
+			(cfg->code_option.encode_eob << 7) |
+			(cfg->code_option.encode_vui << 9);
+	}
+	mpp_write(mpp, value, H265E_CMD_ENC_CODE_OPTION);
+	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_ENC_PIC);
+	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
+		mpp_err("read return register fail\n");
+		goto FAIL;
+	}
+	head->size = mpp_read(mpp, H265E_RET_ENC_PIC_BYTE);
+	mpp_debug(DEBUG_H265E_INFO, "%s %d head->size=%d\n",
+		  __func__, __LINE__, head->size);
+	if (bs_hd >= 0)
+		vpu_iommu_free(mpp->iommu_info, instance->session, bs_hd);
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_disable_clk(mpp);
+#endif
+	mutex_unlock(&enc->lock);
+	mpp_debug_leave();
+
+	return 0;
+FAIL:
+	if (bs_hd >= 0)
+		vpu_iommu_free(mpp->iommu_info, instance->session, bs_hd);
+	mutex_unlock(&enc->lock);
+	mpp_err("fail, index = %d\n", index);
+	return -1;
+}
+#endif
+
+/*
+ * set/change common parameter
+ * when first run this function ,the cfg_mask is 0xffffffff,
+ * and to configure all parameter.
+ * when dynamically changed in the encoding process,
+ * the configure register according to cfg_mask
+ */
+static int rockchip_mpp_h265e_set_common_parameter(struct rockchip_mpp_dev *mpp,
+						   int index)
+{
+	u32 value = 0;
+	struct mpp_h265e_cfg *cfg = NULL;
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct rockchip_h265e_instance *instance = NULL;
+
+	mpp_debug_enter();
+	if (!mpp || index < 0 || index >= H265E_INSTANCE_NUM) {
+		mpp_err("param is invalid,index = %d", index);
+		return -1;
+	}
+
+	instance = &enc->instance[index];
+	cfg = &instance->cfg;
+
+	mpp_write(mpp, 0x00010000 | index, H265E_INST_INDEX);
+	mpp_write(mpp, (cfg->line_buf_int_en << 6) |
+		  (cfg->slice_int_enable << 5) |
+		  (cfg->ring_buffer_enable << 4) |
+		  cfg->bs_endian, H265E_BS_PARAM);
+	mpp_debug(DEBUG_H265E_INFO, "%s %d W=%d,H=%d,index=%d\n",
+		  __func__, __LINE__,
+		  cfg->width, cfg->height, index);
+
+	/* Set up work-buffer */
+	mpp_write(mpp, (u32)instance->work.dma_addr, H265E_ADDR_WORK_BASE);
+	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
+	mpp_write(mpp, 0, H265E_WORK_PARAM);
+
+	/* Set up temp-buffer */
+	mpp_write(mpp, (u32)enc->temp.dma_addr, H265E_ADDR_TEMP_BASE);
+	mpp_write(mpp, enc->temp.size, H265E_TEMP_SIZE);
+	mpp_write(mpp, 0, H265E_TEMP_PARAM);
+	/* Secondary AXI */
+#if	H265E_AXI_STATUS
+	mpp_write(mpp, 0x0, H265E_ADDR_SEC_AXI_BASE);
+	mpp_write(mpp, H265E_SEC_AXI_BUF_SIZE, H265E_SEC_AXI_SIZE);
+	mpp_write(mpp, 0xffff, H265E_USE_SEC_AXI);
+#else
+	mpp_write(mpp, 0, H265E_USE_SEC_AXI);
+#endif
+
+	/* Set up BitstreamBuffer */
+	mpp_write(mpp, 0, H265E_BS_START_ADDR);
+	mpp_write(mpp, 0, H265E_BS_SIZE);
+	mpp_write(mpp, 0, H265E_BS_RD_PTR);
+	mpp_write(mpp, 0, H265E_BS_WR_PTR);
+
+	/* SET_PARAM + COMMON */
+	mpp_write(mpp, H265E_OPT_COMMON, H265E_ENC_SET_PARAM_OPTION);
+	mpp_write(mpp, (u32)cfg->cfg_mask, H265E_ENC_SET_PARAM_ENABLE);
+
+	if (cfg->cfg_mask & H265E_CFG_SEQ_SRC_SIZE_CHANGE) {
+		value = ((cfg->height << 16) | cfg->width);
+		mpp_write(mpp, value, H265E_ENC_SEQ_SRC_SIZE);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_SEQ_PARAM_CHANGE) {
+		/* set seq parameter*/
+		value = (cfg->profile << 0) |
+			(cfg->level << 3) |
+			(cfg->tier << 12) |
+			(cfg->bit_depth << 14) |
+			(cfg->chroma_idc << 18) |
+			(cfg->lossless_enable << 20) |
+			(cfg->const_intra_pred_flag << 21) |
+			((cfg->chroma_cb_qp_offset & 0x1f) << 22) |
+			((cfg->chroma_cr_qp_offset & 0x1f) << 27);
+		mpp_write(mpp, value, H265E_ENC_SEQ_PARAM);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_GOP_PARAM_CHANGE)
+		mpp_write(mpp, cfg->gop_idx, H265E_ENC_SEQ_GOP_PARAM);
+	if (cfg->cfg_mask & H265E_CFG_INTRA_PARAM_CHANGE) {
+		value = (cfg->decoding_refresh_type << 0) |
+			(cfg->intra_qp << 3) |
+			(cfg->intra_period << 16);
+		mpp_write(mpp, value, H265E_ENC_SEQ_INTRA_PARAM);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_CONF_WIN_TOP_BOT_CHANGE) {
+		value = (cfg->conf_win_bot << 16) | cfg->conf_win_top;
+		mpp_write(mpp, value, H265E_ENC_SEQ_CONF_WIN_TOP_BOT);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_CONF_WIN_LEFT_RIGHT_CHANGE) {
+		value = (cfg->conf_win_right << 16) | cfg->conf_win_left;
+		mpp_write(mpp, value, H265E_ENC_SEQ_CONF_WIN_LEFT_RIGHT);
+	}
+	if (cfg->cfg_mask & H265E_CFG_FRAME_RATE_CHANGE)
+		mpp_write(mpp, cfg->frame_rate, H265E_ENC_SEQ_FRAME_RATE);
+
+	if (cfg->cfg_mask & H265E_CFG_INDEPENDENT_SLICE_CHANGE) {
+		value = (cfg->independ_slice_mode_arg << 16) |
+			cfg->independ_slice_mode;
+		mpp_write(mpp, value, H265E_ENC_SEQ_INDEPENDENT_SLICE);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_DEPENDENT_SLICE_CHANGE) {
+		value = (cfg->depend_slice_mode_arg << 16) |
+			cfg->depend_slice_mode;
+		mpp_write(mpp, value, H265E_ENC_SEQ_DEPENDENT_SLICE);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_INTRA_REFRESH_CHANGE) {
+		value = (cfg->intra_refresh_arg << 16) |
+			cfg->intra_refresh_mode;
+		mpp_write(mpp, value, H265E_ENC_SEQ_INTRA_REFRESH);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_PARAM_CHANGE) {
+		value = (cfg->use_recommend_param) |
+			(cfg->ctu.ctu_qp_enable << 2) |
+			(cfg->scaling_list_enable << 3) |
+			(cfg->cu_size_mode << 4) |
+			(cfg->tmvp_enable << 7) |
+			(cfg->wpp_enable << 8) |
+			(cfg->max_num_merge << 9) |
+			(cfg->dynamic_merge_8x8_enable << 12) |
+			(cfg->dynamic_merge_16x16_enable << 13) |
+			(cfg->dynamic_merge_32x32_enable << 14) |
+			(cfg->disable_deblk << 15) |
+			(cfg->lf_cross_slice_boundary_enable << 16) |
+			((cfg->beta_offset_div2 & 0xF) << 17) |
+			((cfg->tc_offset_div2 & 0xF) << 21) |
+			(cfg->skip_intra_trans << 25) |
+			(cfg->sao_enable << 26) |
+			(cfg->intra_in_inter_slice_enable << 27) |
+			(cfg->intra_nxn_enable << 28);
+
+		mpp_write(mpp, value, H265E_ENC_PARAM);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_RC_PARAM_CHANGE) {
+		value = (cfg->rc_enable << 0) |
+			(cfg->cu_level_rc_enable << 1) |
+			(cfg->hvs_qp_enable << 2) |
+			(cfg->hvs_qp_scale_enable << 3) |
+			(cfg->hvs_qp_scale << 4) |
+			(cfg->bit_alloc_mode << 7) |
+			(cfg->init_buf_levelx8 << 9) |
+			(cfg->ctu.roi_enable << 13) |
+			(cfg->initial_rc_qp << 14) |
+			(cfg->initial_delay << 20);
+		mpp_write(mpp, value, H265E_ENC_RC_PARAM);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_RC_MIN_MAX_QP_CHANGE) {
+		value = (cfg->min_qp << 0) |
+			(cfg->max_qp << 6) |
+			(cfg->max_delta_qp << 12) |
+			((cfg->intra_qp_offset & 0xFFFF) << 18);
+		mpp_write(mpp, value, H265E_ENC_RC_MIN_MAX_QP);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_RC_TARGET_RATE_LAYER_0_3_CHANGE) {
+		value = (cfg->fixed_bit_ratio[0] << 0) |
+			(cfg->fixed_bit_ratio[1] << 8) |
+			(cfg->fixed_bit_ratio[2] << 16) |
+			(cfg->fixed_bit_ratio[3] << 24);
+		mpp_write(mpp, value, H265E_ENC_RC_BIT_RATIO_LAYER_0_3);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_RC_TARGET_RATE_LAYER_4_7_CHANGE) {
+		value = (cfg->fixed_bit_ratio[4] << 0) |
+			(cfg->fixed_bit_ratio[5] << 8) |
+			(cfg->fixed_bit_ratio[6] << 16) |
+			(cfg->fixed_bit_ratio[7] << 24);
+		mpp_write(mpp, value, H265E_ENC_RC_BIT_RATIO_LAYER_4_7);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_SET_NUM_UNITS_IN_TICK) {
+		mpp_write(mpp, cfg->num_units_in_tick,
+			  H265E_ENC_NUM_UNITS_IN_TICK);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_SET_TIME_SCALE) {
+		mpp_write(mpp, cfg->time_scale,
+			  H265E_ENC_TIME_SCALE);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_SET_NUM_TICKS_POC_DIFF_ONE) {
+		mpp_write(mpp, cfg->num_ticks_poc_diff_one,
+			  H265E_ENC_NUM_TICKS_POC_DIFF_ONE);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_NR_PARAM_CHANGE) {
+		value = (cfg->nr_y_enable << 0) |
+			(cfg->nr_cb_enable << 1) |
+			(cfg->nr_cr_enable << 2) |
+			(cfg->nr_noise_est_enable << 3) |
+			(cfg->nr_noise_sigma_y << 4) |
+			(cfg->nr_noise_sigma_cb << 12) |
+			(cfg->nr_noise_sigma_cr << 20);
+		mpp_write(mpp, value, H265E_ENC_NR_PARAM);
+	}
+
+	if (cfg->cfg_mask & H265E_CFG_NR_WEIGHT_CHANGE) {
+		value = (cfg->nr_intra_weight_y << 0) |
+			(cfg->nr_intra_weight_cb << 5) |
+			(cfg->nr_intra_weight_cr << 10) |
+			(cfg->nr_inter_weight_y << 15) |
+			(cfg->nr_inter_weight_cb << 20) |
+			(cfg->nr_inter_weight_cr << 25);
+		mpp_write(mpp, value, H265E_ENC_NR_WEIGHT);
+	}
+	if (cfg->cfg_mask & H265E_CFG_RC_TARGET_RATE_CHANGE)
+		mpp_write(mpp, cfg->bit_rate, H265E_ENC_RC_TARGET_RATE);
+	if (cfg->cfg_mask & H265E_CFG_RC_TRANS_RATE_CHANGE)
+		mpp_write(mpp, cfg->trans_rate, H265E_ENC_RC_TRANS_RATE);
+	if (cfg->cfg_mask & H265E_CFG_ROT_PARAM_CHANGE)
+		mpp_write(mpp, 0, H265E_ENC_ROT_PARAM);
+	if (cfg->cfg_mask == H265E_CFG_CHANGE_SET_PARAM_ALL) {
+		value = (cfg->intra_max_qp << 6) | cfg->intra_min_qp;
+		mpp_write(mpp, value, H265E_ENC_RC_INTRA_MIN_MAX_QP);
+	}
+	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_SET_PARAM);
+	if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
+		mpp_err("h265e_wait_busy timeout, index=%d\n", index);
+		goto FAIL;
+	}
+	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
+		mpp_err("h265e set common parameter ret fail\n");
+		goto FAIL;
+	}
+	mpp_debug_leave();
+	return 0;
+FAIL:
+	mpp_err("fail,index = %d\n", index);
+	return -1;
+}
+
+static int rockchip_mpp_h265e_set_gop_parameter(struct rockchip_mpp_dev *mpp,
+						int index)
+{
+	u32 value = 0;
+	unsigned int i = 0, j = 0;
+	struct mpp_h265e_cfg *cfg = NULL;
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct rockchip_h265e_instance *instance = NULL;
+
+	mpp_debug_enter();
+
+	if (!mpp || index < 0 || index >= H265E_INSTANCE_NUM) {
+		mpp_err("param is invalid,index = %d", index);
+		return -1;
+	}
+
+	instance = &enc->instance[index];
+	cfg = &instance->cfg;
+
+	/* Set up work-buffer */
+	mpp_write(mpp, (u32)instance->work.dma_addr, H265E_ADDR_WORK_BASE);
+	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
+	mpp_write(mpp, 0, H265E_WORK_PARAM);
+
+	/* Set up temp-buffer */
+	mpp_write(mpp, (u32)enc->temp.dma_addr, H265E_ADDR_TEMP_BASE);
+	mpp_write(mpp, enc->temp.size, H265E_TEMP_SIZE);
+	mpp_write(mpp, 0, H265E_TEMP_PARAM);
+	/* Secondary AXI */
+#if	H265E_AXI_STATUS
+	mpp_write(mpp, 0x0, H265E_ADDR_SEC_AXI_BASE);
+	mpp_write(mpp, H265E_SEC_AXI_BUF_SIZE, H265E_SEC_AXI_SIZE);
+	mpp_write(mpp, 0xffff, H265E_USE_SEC_AXI);
+#else
+	mpp_write(mpp, 0, H265E_USE_SEC_AXI);
+#endif
+
+	/*
+	 * SET_PARAM + CUSTOM_GOP
+	 * only when gop_size == custom_gop,
+	 * custom_gop related registers should be set
+	 */
+	mpp_write(mpp, 0x00010000 | index, H265E_INST_INDEX);
+	if (cfg->gop_idx == PRESET_IDX_CUSTOM_GOP) {
+		mpp_write(mpp, H265E_OPT_CUSTOM_GOP,
+			  H265E_ENC_SET_PARAM_OPTION);
+		mpp_write(mpp, (u32)H265E_CFG_CHANGE_SET_PARAM_ALL,
+			  H265E_ENC_SET_CUSTOM_GOP_ENABLE);
+
+		value = (cfg->gop.custom_gop_size << 0) |
+			(cfg->gop.use_derive_lambda_weight << 4);
+		mpp_write(mpp, value, H265E_ENC_CUSTOM_GOP_PARAM);
+
+		for (i = 0; i < cfg->gop.custom_gop_size; i++) {
+			value = (cfg->gop.pic[i].type << 0) |
+				(cfg->gop.pic[i].offset << 2) |
+				(cfg->gop.pic[i].qp << 6) |
+				((cfg->gop.pic[i].ref_poc_l0 &
+				  0x1F) << 14) |
+				((cfg->gop.pic[i].ref_poc_l1 &
+				  0x1F) << 19) |
+				(cfg->gop.pic[i].temporal_id << 24);
+
+			mpp_write(mpp, value,
+				  H265E_ENC_CUSTOM_GOP_PIC_PARAM_0 + (i * 4));
+			mpp_write(mpp, cfg->gop.gop_pic_lambda[i],
+				  H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_0 + (i * 4));
+		}
+		for (j = i; j < H265E_MAX_GOP_NUM; j++) {
+			mpp_write(mpp, 0,
+				  H265E_ENC_CUSTOM_GOP_PIC_PARAM_0 + (j * 4));
+			mpp_write(mpp, 0,
+				  H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_0 + (j * 4));
+		}
+		rockchip_mpp_h265e_issue_command(mpp,
+						 index,
+						 H265E_CMD_SET_PARAM);
+		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
+			mpp_err("h265e_wait_busy timeout, index=%d\n", index);
+			goto FAIL;
+		}
+		if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
+			mpp_err("h265e set gop ret fail\n");
+			goto FAIL;
+		}
+	}
+
+	value = mpp_read(mpp, H265E_RET_ENC_MIN_FB_NUM);
+	if (value > (u32)instance->min_frame_buffer_count)
+		instance->min_frame_buffer_count = value;
+
+	value = mpp_read(mpp, H265E_RET_ENC_MIN_SRC_BUF_NUM);
+	if (value > (u32)instance->min_src_frame_count)
+		instance->min_src_frame_count = value;
+	mpp_debug(DEBUG_H265E_INFO,
+		  "%s %d,min_frame_buffer_count = %d,min_src_frame_count=%d\n",
+		  __func__, __LINE__, instance->min_frame_buffer_count,
+		  instance->min_src_frame_count);
+	mpp_debug_leave();
+	return 0;
+
+FAIL:
+	mpp_err("fail,index = %d\n", index);
+	return -1;
+}
+
+static int rockchip_mpp_h265e_set_vui_parameter(struct rockchip_mpp_dev *mpp,
+						int index)
+{
+	struct mpp_h265e_cfg *cfg = NULL;
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct rockchip_h265e_instance *instance = NULL;
+	u32 value = 0;
+
+	mpp_debug_enter();
+	if (!mpp || index < 0 || index >= H265E_INSTANCE_NUM) {
+		mpp_err("param is invalid,index = %d", index);
+		return -1;
+	}
+
+	instance = &enc->instance[index];
+	cfg = &instance->cfg;
+	mpp_write(mpp, 0x00010000 | index, H265E_INST_INDEX);
+
+	/* Set up work-buffer */
+	mpp_write(mpp, (u32)instance->work.dma_addr, H265E_ADDR_WORK_BASE);
+	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
+	mpp_write(mpp, 0, H265E_WORK_PARAM);
+
+	if (cfg->vui.flags || cfg->vui_rbsp ||
+	    cfg->hrd_rbsp_in_vps || cfg->hrd_rbsp_in_vui) {
+		/*** VUI encoding by host registers ***/
+		if (cfg->vui.flags) {
+			mpp_write(mpp, H265E_OPT_VUI,
+				  H265E_ENC_SET_PARAM_OPTION);
+			mpp_write(mpp, cfg->vui.flags,
+				  H265E_ENC_VUI_PARAM_FLAGS);
+			mpp_write(mpp, cfg->vui.aspect_ratio_idc,
+				  H265E_ENC_VUI_ASPECT_RATIO_IDC);
+			mpp_write(mpp, cfg->vui.sar_size,
+				  H265E_ENC_VUI_SAR_SIZE);
+			mpp_write(mpp, cfg->vui.over_scan_appropriate,
+				  H265E_ENC_VUI_OVERSCAN_APPROPRIATE);
+			mpp_write(mpp, cfg->vui.signal,
+				  H265E_ENC_VUI_VIDEO_SIGNAL);
+			mpp_write(mpp, cfg->vui.chroma_sample_loc,
+				  H265E_ENC_VUI_CHROMA_SAMPLE_LOC);
+			mpp_write(mpp, cfg->vui.disp_win_left_right,
+				  H265E_ENC_VUI_DISP_WIN_LEFT_RIGHT);
+			mpp_write(mpp, cfg->vui.disp_win_top_bottom,
+				  H265E_ENC_VUI_DISP_WIN_TOP_BOT);
+		} else {
+			mpp_write(mpp, 0, H265E_ENC_VUI_PARAM_FLAGS);
+		}
+		if (cfg->vui_rbsp ||
+		    cfg->hrd_rbsp_in_vps ||
+		    cfg->hrd_rbsp_in_vui) {
+			/*** VUI encoding by given rbsp data ***/
+			mpp_write(mpp, H265E_OPT_VUI,
+				  H265E_ENC_SET_PARAM_OPTION);
+			value = (cfg->hrd_rbsp_in_vps << 2) |
+				(cfg->hrd_rbsp_in_vui << 1) |
+				(cfg->vui_rbsp);
+			mpp_write(mpp, value,
+				  H265E_ENC_VUI_HRD_RBSP_PARAM_FLAG);
+			mpp_write(mpp, cfg->vui_rbsp_data_addr,
+				  H265E_ENC_VUI_RBSP_ADDR);
+			mpp_write(mpp, cfg->vui_rbsp_data_size,
+				  H265E_ENC_VUI_RBSP_SIZE);
+			mpp_write(mpp, cfg->hrd_rbsp_data_addr,
+				  H265E_ENC_HRD_RBSP_ADDR);
+			mpp_write(mpp, cfg->hrd_rbsp_data_size,
+				  H265E_ENC_HRD_RBSP_SIZE);
+		} else {
+			mpp_write(mpp, 0, H265E_ENC_VUI_HRD_RBSP_PARAM_FLAG);
+		}
+		rockchip_mpp_h265e_issue_command(mpp,
+						 index,
+						 H265E_CMD_SET_PARAM);
+		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
+			mpp_err("h265e_wait_busy timeout, index=%d\n", index);
+			goto FAIL;
+		}
+		if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
+			mpp_err("h265e set vui ret fail\n");
+			goto FAIL;
+		}
+	}
+
+	mpp_debug_leave();
+	return 0;
+FAIL:
+	mpp_err("fail,index = %d\n", index);
+	return -1;
+}
+
+static int rockchip_mpp_h265e_set_parameter(struct rockchip_mpp_dev *mpp,
+					    int index)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct rockchip_h265e_instance *instance = &enc->instance[index];
+
+	mpp_debug_enter();
+	mutex_lock(&enc->lock);
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_enable_clk(mpp);
+#endif
+	mpp_dev_power_on(mpp);
+	if (instance->status != H265E_INSTANCE_STATUS_OPENED) {
+		mpp_err("error:status = %d\n", instance->status);
+		goto FAIL;
+	}
+	instance->cfg.cfg_mask = H265E_CFG_CHANGE_SET_PARAM_ALL;
+	if (rockchip_mpp_h265e_set_common_parameter(mpp, index) != 0)
+		goto FAIL;
+	if (rockchip_mpp_h265e_set_gop_parameter(mpp, index) != 0)
+		goto FAIL;
+	if (rockchip_mpp_h265e_set_vui_parameter(mpp, index) != 0)
+		goto FAIL;
+	if (rockchip_mpp_h265e_register_frame_buffer(mpp, index) != 0)
+		goto FAIL;
+	instance->status = H265E_INSTANCE_STATUS_SET_PARAMETER;
+	instance->cfg.cfg_mask = 0;
+	instance->cfg.cfg_option = 0;
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_disable_clk(mpp);
+#endif
+	mutex_unlock(&enc->lock);
+	mpp_debug_leave();
+	return 0;
+FAIL:
+	instance->status = H265E_INSTANCE_STATUS_ERROR;
+	mutex_unlock(&enc->lock);
+	mpp_err("fail,index = %d\n", index);
+	return -1;
+}
+
+static int rockchip_mpp_h265e_change_parameter(struct rockchip_mpp_dev *mpp,
+					       int index)
+{
+	struct rockchip_h265e_dev *enc =
+					container_of(mpp,
+						     struct rockchip_h265e_dev,
+						     dev);
+	struct rockchip_h265e_instance *instance = &enc->instance[index];
+	u32 enable = instance->cfg.cfg_option;
+
+	mpp_debug_enter();
+	mutex_lock(&enc->lock);
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_enable_clk(mpp);
+#endif
+	mpp_dev_power_on(mpp);
+	if (instance->status == H265E_INSTANCE_STATUS_ERROR ||
+	    instance->status == H265E_INSTANCE_STATUS_CLOSE) {
+		mpp_err("error:status = %d\n", instance->status);
+		goto FAIL;
+	}
+
+	instance->status = H265E_INSTANCE_STATUS_OPENED;
+	if (enable & H265E_PARAM_CHANEGED_COMMON) {
+		if (rockchip_mpp_h265e_set_common_parameter(mpp, index) != 0)
+			goto FAIL;
+	}
+	if (enable & H265E_PARAM_CHANEGED_CUSTOM_GOP) {
+		if (rockchip_mpp_h265e_set_gop_parameter(mpp, index) != 0)
+			goto FAIL;
+	}
+	if (enable & H265E_PARAM_CHANEGED_REGISTER_BUFFER) {
+		rockchip_mpp_h265e_free_frame_buffer(mpp, instance);
+		if (rockchip_mpp_h265e_register_frame_buffer(mpp, index) != 0)
+			goto FAIL;
+	}
+	instance->status = H265E_INSTANCE_STATUS_SET_PARAMETER;
+	instance->cfg.cfg_mask = 0;
+	instance->cfg.cfg_option = 0;
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_disable_clk(mpp);
+#endif
+	mutex_unlock(&enc->lock);
+	mpp_debug_leave();
+	return 0;
+FAIL:
+	instance->status = H265E_INSTANCE_STATUS_ERROR;
+	mutex_unlock(&enc->lock);
+	mpp_err("fail,index = %d\n", index);
+	return -1;
+}
+
+static u32 rockchip_mpp_h265e_get_fb_luma_size(u32 map_type,
+					       u32 stride, u32 height)
+{
+	u32 size = stride * height;
+
+	if (map_type == LINEAR_FRAME_MAP)
+		size = stride * height;
+	else if (map_type == COMPRESSED_FRAME_MAP)
+		size = stride * height;
+	else if (map_type == TILED_SUB_CTU_MAP)
+		size = (ALIGN(stride, 32) * ALIGN(height, 32));
+	else
+		mpp_err("unsupport may_type = %d\n", map_type);
+
+	return size;
+}
+
+static u32 rockchip_mpp_h265e_get_fb_chroma_size(u32 map_type,
+						 u32 stride, u32 height)
+{
+	u32 size = 0;
+	u32 chroma_width = stride >> 1;
+	u32 chroma_height = height >> 1;
+
+	if (map_type == LINEAR_FRAME_MAP) {
+		size = chroma_width * chroma_height;
+	} else if (map_type == COMPRESSED_FRAME_MAP) {
+		chroma_width = ALIGN(chroma_width, 16);
+		size = chroma_width * chroma_height;
+	} else if (map_type == TILED_SUB_CTU_MAP) {
+		chroma_width = ALIGN(chroma_width, 16);
+		size = chroma_width * chroma_height / 2;
+	} else {
+		mpp_err("unsupport may_type = %d\n", map_type);
+	}
+
+	return size;
+}
+
+static
+int rockchip_mpp_h265e_register_frame_buffer(struct rockchip_mpp_dev *mpp,
+					     int index)
+{
+	struct mpp_h265e_cfg *cfg = NULL;
+	struct rockchip_h265e_dev *enc =
+				container_of(mpp,
+					     struct rockchip_h265e_dev,
+					     dev);
+	struct rockchip_h265e_instance *instance = NULL;
+	int buf_width = 0;
+	int buf_height = 0;
+	int luma_stride = 0;
+	int chroma_stride = 0;
+	int count = 0;
+	u32 value, mv_col_size = 0;
+	u32 fbc_y_table_size = 0, fbc_c_table_size = 0, sub_sampled_size = 0;
+	int q, j, i, remain, idx;
+	int start_no, end_no;
+	u32 addr_y, addr_cb, addr_cr;
+	int stride;
+	u32 axi_id = 0;
+	int	size_rec_luma, size_rec_chroma;
+	struct mpp_h265e_buffer *buffer = NULL;
+	int interlace = 0;
+	struct mpp_h265e_frame_buffer *frame_buffer = NULL;
+
+	mpp_debug_enter();
+	if (!mpp || index < 0 || index >= H265E_INSTANCE_NUM) {
+		mpp_err("parameter is invalid, index = %d\n", index);
+		return -1;
+	}
+	instance = &enc->instance[index];
+	cfg = &instance->cfg;
+	interlace = (cfg->src_format == H265E_SRC_YUV_420_NV12) ||
+		    (cfg->src_format == H265E_SRC_YUV_420_NV21);
+
+	stride = ALIGN(cfg->width, 32);
+
+	buf_width = ALIGN(cfg->width, 8);
+	buf_height = ALIGN(cfg->height, 8);
+
+	size_rec_luma =
+			rockchip_mpp_h265e_get_fb_luma_size(cfg->map_type,
+							    stride, buf_height);
+	size_rec_chroma =
+			  rockchip_mpp_h265e_get_fb_chroma_size(cfg->map_type,
+								stride,
+								buf_height);
+
+	count = instance->min_frame_buffer_count;
+	memset(&instance->mv, 0, sizeof(struct mpp_h265e_buffer));
+	memset(&instance->fbc_luma, 0, sizeof(struct mpp_h265e_buffer));
+	memset(&instance->fbc_chroma, 0, sizeof(struct mpp_h265e_buffer));
+	if (cfg->map_type == COMPRESSED_FRAME_MAP) {
+		mv_col_size = H265E_MVCOL_BUF_SIZE(buf_width, buf_height);
+		mv_col_size = ALIGN(mv_col_size, 16);
+
+		instance->mv.size = ALIGN(mv_col_size * count, 4096) + 4096;
+		instance->mv.hdl =
+			rockchip_mpp_h265e_dma_alloc(mpp,
+						     instance->session,
+						     instance->mv.size,
+						     MPP_ALIGN_SIZE,
+						     &instance->mv.dma_addr);
+		if (instance->mv.hdl < 0) {
+			mpp_err("alloc mv buffer fail,index = %d\n", index);
+			goto FAIL;
+		}
+
+		fbc_y_table_size =
+			H265E_FBC_LUMA_TABLE_SIZE(buf_width,
+						  buf_height);
+		fbc_y_table_size =
+			ALIGN(fbc_y_table_size, 16);
+		instance->fbc_luma.size =
+			ALIGN(fbc_y_table_size * count, 4096) + 4096;
+		instance->fbc_luma.hdl =
+			rockchip_mpp_h265e_dma_alloc(mpp,
+						     instance->session,
+						     instance->fbc_luma.size,
+						     MPP_ALIGN_SIZE,
+						     &instance->fbc_luma.dma_addr);
+		if (instance->fbc_luma.hdl < 0) {
+			mpp_err("alloc fbc y buffer fail,index = %d\n", index);
+			goto FAIL;
+		}
+
+		fbc_c_table_size =
+				H265E_FBC_CHROMA_TABLE_SIZE(buf_width,
+							    buf_height);
+		fbc_c_table_size = ALIGN(fbc_c_table_size, 16);
+		instance->fbc_chroma.size = ALIGN(fbc_c_table_size * count,
+						  4096) + 4096;
+		instance->fbc_chroma.hdl =
+			rockchip_mpp_h265e_dma_alloc(mpp,
+						     instance->session,
+						     instance->fbc_chroma.size,
+						     MPP_ALIGN_SIZE,
+						     &instance->fbc_chroma.dma_addr);
+		if (instance->fbc_chroma.hdl < 0) {
+			mpp_err("alloc fbc c buffer fail,index = %d\n", index);
+			goto FAIL;
+		}
+	}
+
+	sub_sampled_size = H265E_SUBSAMPLED_ONE_SIZE(buf_width, buf_height);
+	memset(&instance->sub_sample, 0, sizeof(struct mpp_h265e_buffer));
+	instance->sub_sample.size =
+		ALIGN(sub_sampled_size * count, 4096) + 4096;
+	instance->sub_sample.hdl =
+		rockchip_mpp_h265e_dma_alloc(mpp,
+					     instance->session,
+					     instance->sub_sample.size,
+					     MPP_ALIGN_SIZE,
+					     &instance->sub_sample.dma_addr);
+	if (instance->sub_sample.hdl < 0) {
+		mpp_err("alloc fbc c buffer fail,index = %d\n", index);
+		goto FAIL;
+	}
+	mpp_write(mpp, (u32)instance->sub_sample.dma_addr,
+		  H265E_ADDR_SUB_SAMPLED_FB_BASE);
+	mpp_write(mpp, sub_sampled_size, H265E_SUB_SAMPLED_ONE_FB_SIZE);
+
+	value = (buf_width << 16) | buf_height;
+	mpp_write(mpp, value, H265E_PIC_SIZE);
+
+	luma_stride = ALIGN(cfg->width, 16) * 4;
+	luma_stride = ALIGN(luma_stride, 32);
+	chroma_stride = ALIGN(cfg->width / 2, 16) * 4;
+	chroma_stride = ALIGN(chroma_stride, 32);
+	value = (luma_stride << 16) | chroma_stride;
+	mpp_write(mpp, value, H265E_FBC_STRIDE);
+
+	value = ((cfg->src_format == H265E_SRC_YUV_420_NV21) << 29) |
+		((cfg->map_type == LINEAR_FRAME_MAP) << 28) |
+		(axi_id << 24) |
+		(interlace << 16) |
+		stride;
+	mpp_write(mpp, value, H265E_COMMON_PIC_INFO);
+
+	memset(&instance->frame_buffer, -1, sizeof(instance->frame_buffer));
+	/* set frame buffer address*/
+	for (i = 0; i < count; i++) {
+		frame_buffer = &instance->frame_buffer[i];
+		buffer = &frame_buffer->buffer;
+		buffer->size = size_rec_luma + 2 * size_rec_chroma;
+		buffer->hdl = rockchip_mpp_h265e_dma_alloc(mpp,
+							   instance->session,
+							   buffer->size,
+							   MPP_ALIGN_SIZE,
+							   &buffer->dma_addr);
+		if (buffer->hdl < 0) {
+			mpp_err("alloc fbc y buffer fail,index = %d\n", index);
+			goto FAIL;
+		}
+
+		frame_buffer->y = (u32)buffer->dma_addr;
+		frame_buffer->cb = frame_buffer->y + size_rec_luma;
+		frame_buffer->cr = frame_buffer->cb + size_rec_chroma;
+	}
+
+	remain = count;
+	q      = (remain + 7) / 8;
+	idx    = 0;
+	for (j = 0; j < q; j++) {
+		value = (cfg->fb_endian << 16) |
+			((j == q - 1) << 4) |
+			((j == 0) << 3);
+		mpp_write(mpp, value, H265E_SFB_OPTION);
+		start_no = j * 8;
+		end_no   = start_no + (remain >= 8 ? 8 : remain) - 1;
+		value = (start_no << 8) | end_no;
+		mpp_write(mpp, value, H265E_SET_FB_NUM);
+		for (i = 0; i < 8 && i < remain; i++) {
+			frame_buffer = &instance->frame_buffer[i];
+			addr_y  = frame_buffer->y;
+			addr_cb = frame_buffer->cb;
+			addr_cr = frame_buffer->cr;
+			mpp_write(mpp, addr_y,
+				  H265E_ADDR_LUMA_BASE0 + (i << 4));
+			mpp_write(mpp, addr_cb,
+				  H265E_ADDR_CB_BASE0 + (i << 4));
+			if (cfg->map_type == COMPRESSED_FRAME_MAP) {
+				mpp_write(mpp,
+					  ((u32)instance->fbc_luma.dma_addr) +
+					  idx * fbc_y_table_size,
+					  H265E_ADDR_FBC_Y_OFFSET0 + (i << 4));
+				mpp_write(mpp,
+					  ((u32)instance->fbc_chroma.dma_addr) +
+					  idx * fbc_c_table_size,
+					  H265E_ADDR_FBC_C_OFFSET0 + (i << 4));
+				mpp_write(mpp, ((u32)instance->mv.dma_addr) +
+					  idx * mv_col_size,
+					  H265E_ADDR_MV_COL0 + (i << 2));
+			} else {
+				mpp_write(mpp, addr_cr,
+					  H265E_ADDR_CR_BASE0 + (i << 4));
+				mpp_write(mpp, 0,
+					  H265E_ADDR_FBC_C_OFFSET0 + (i << 4));
+				mpp_write(mpp, 0,
+					  H265E_ADDR_MV_COL0 + (i << 2));
+			}
+			idx++;
+		}
+		remain -= i;
+		mpp_write(mpp, (u32)instance->work.dma_addr,
+			  H265E_ADDR_WORK_BASE);
+		mpp_write(mpp, (u32)instance->work.size, H265E_WORK_SIZE);
+		mpp_write(mpp, 0, H265E_WORK_PARAM);
+		rockchip_mpp_h265e_issue_command(mpp,
+						 index,
+						 H265E_CMD_SET_FRAMEBUF);
+		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
+			mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
+			goto FAIL;
+		}
+	}
+	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
+		mpp_err("h265e register frame buffer ret fail\n");
+		goto FAIL;
+	}
+	mpp_debug_leave();
+	return 0;
+FAIL:
+	rockchip_mpp_h265e_free_frame_buffer(mpp, instance);
+	mpp_err("fail,index = %d\n", index);
+	return -1;
+}
+
+static int rockchip_mpp_h265e_encode_one_frame(struct rockchip_mpp_dev *mpp,
+					       struct h265e_ctx *ctx,
+					       int index)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct mpp_h265e_encode_info *en_info = &ctx->cfg;
+	struct rockchip_h265e_instance *instance = &enc->instance[index];
+	struct mpp_h265e_cfg *cfg = &instance->cfg;
+	int luma_stride = 0;
+	int chroma_stride = 0;
+	int src_format = 0;
+	u32 value, src_y, src_cb, src_cr;
+	int interlace = 0;
+	u32 roi_enable = 0;
+	u32 ctu_qp_enable = 0;
+
+	mpp_debug_enter();
+	if (!cfg || !ctx)
+		return -1;
+
+	mutex_lock(&enc->lock);
+	h265e_last = ktime_get();
+#if H265E_POWER_SAVE
+	rockchip_mpp_h265e_enable_clk(mpp);
+#endif
+	mpp_dev_power_on(mpp);
+	if (instance->status != H265E_INSTANCE_STATUS_SET_PARAMETER) {
+		mutex_unlock(&enc->lock);
+		mpp_err("fail,status = %d,index = %d\n",
+			instance->status, index);
+		return -1;
+	}
+
+	luma_stride = cfg->width_stride;
+	interlace = (cfg->src_format == H265E_SRC_YUV_420_NV12) ||
+		    (cfg->src_format == H265E_SRC_YUV_420_NV21);
+	if (cfg->src_format == H265E_SRC_YUV_420_NV12)
+		src_format = 0x02;
+	else if (cfg->src_format == H265E_SRC_YUV_420_NV21)
+		src_format = 0x03;
+	if (cfg->map_type == TILED_SUB_CTU_MAP)
+		src_format = 0x1;
+	mpp_write(mpp, 0xfffffff2, H265E_PERF_LATENCY_CTRL0);
+	mpp_write(mpp, (u32)ctx->bs.dma_addr, H265E_BS_START_ADDR);
+	mpp_write(mpp, ctx->bs.size, H265E_BS_SIZE);
+	mpp_write(mpp, (u32)ctx->bs.dma_addr, H265E_BS_RD_PTR);
+	mpp_write(mpp, (u32)ctx->bs.dma_addr, H265E_BS_WR_PTR);
+
+	value = (cfg->line_buf_int_en << 6) |
+		(cfg->slice_int_enable << 5) |
+		(cfg->ring_buffer_enable << 4) |
+		cfg->bs_endian;
+	mpp_write(mpp, value, H265E_BS_PARAM);
+	mpp_write(mpp, 0, H265E_BS_OPTION);
+
+	mpp_write(mpp, instance->work.dma_addr, H265E_ADDR_WORK_BASE);
+	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
+	mpp_write(mpp, 0, H265E_WORK_PARAM);
+
+	mpp_write(mpp, enc->temp.dma_addr, H265E_ADDR_TEMP_BASE);
+	mpp_write(mpp, enc->temp.size, H265E_TEMP_SIZE);
+	mpp_write(mpp, 0, H265E_TEMP_PARAM);
+
+#if	H265E_AXI_STATUS
+	mpp_write(mpp, 0x0, H265E_ADDR_SEC_AXI_BASE);
+	mpp_write(mpp, H265E_SEC_AXI_BUF_SIZE, H265E_SEC_AXI_SIZE);
+	mpp_write(mpp, 0xffff, H265E_USE_SEC_AXI);
+#else
+	mpp_write(mpp, 0, H265E_USE_SEC_AXI);
+#endif
+	if (cfg->code_option.implicit_header_encode == 1) {
+		value = CODEOPT_ENC_HEADER_IMPLICIT	|
+			CODEOPT_ENC_VCL	|
+			(cfg->code_option.encode_aud << 5) |
+			(cfg->code_option.encode_eos << 6) |
+			(cfg->code_option.encode_eob << 7);
+	} else {
+		value = (cfg->code_option.implicit_header_encode << 0) |
+			(cfg->code_option.encode_vcl << 1) |
+			(cfg->code_option.encode_vps << 2) |
+			(cfg->code_option.encode_sps << 3) |
+			(cfg->code_option.encode_pps << 4) |
+			(cfg->code_option.encode_aud << 5) |
+			(cfg->code_option.encode_eos << 6) |
+			(cfg->code_option.encode_eob << 7) |
+			(cfg->code_option.encode_vui << 9);
+	}
+
+	mpp_write(mpp, value, H265E_CMD_ENC_CODE_OPTION);
+
+	value = (en_info->skip_pic << 0) |
+		(en_info->force_qp_enable << 1) |
+		(en_info->force_qp_i << 2) |
+		(en_info->force_qp_p << 8) |
+		(0 << 14) |
+		(en_info->force_frame_type_enable << 20) |
+		(en_info->force_frame_type << 21);
+	mpp_write(mpp, value, H265E_CMD_ENC_PIC_PARAM);
+	if (en_info->stream_end == 1) {
+		mpp_debug(DEBUG_H265E_INFO,
+			  "%s %d instance %d en_info->stream_end\n",
+			  __func__, __LINE__, index);
+		mpp_write(mpp, 0xFFFFFFFE, H265E_CMD_ENC_SRC_PIC_IDX);
+	} else {
+		mpp_write(mpp, instance->src_idx, H265E_CMD_ENC_SRC_PIC_IDX);
+	}
+	instance->src_idx++;
+	instance->src_idx = instance->src_idx % instance->min_src_frame_count;
+	src_y = (u32)ctx->src.dma_addr;
+	src_cb = src_y + luma_stride * cfg->height_stride;
+	src_cr = src_cb + luma_stride * cfg->height_stride / 4;
+	mpp_write(mpp, src_y, H265E_CMD_ENC_SRC_ADDR_Y);
+	if (cfg->src_format == H265E_SRC_YUV_420_YV12) {
+		mpp_write(mpp, src_cb, H265E_CMD_ENC_SRC_ADDR_V);
+		mpp_write(mpp, src_cr, H265E_CMD_ENC_SRC_ADDR_U);
+	} else {
+		mpp_write(mpp, src_cb, H265E_CMD_ENC_SRC_ADDR_U);
+		mpp_write(mpp, src_cr, H265E_CMD_ENC_SRC_ADDR_V);
+	}
+	chroma_stride = (interlace == 1) ? luma_stride : (luma_stride >> 1);
+	if (cfg->map_type == TILED_SUB_CTU_MAP)
+		chroma_stride = luma_stride;
+	mpp_write(mpp, (luma_stride << 16) | chroma_stride,
+		  H265E_CMD_ENC_SRC_STRIDE);
+	value = (src_format << 0) | (cfg->src_endian << 6);
+	mpp_write(mpp, value, H265E_CMD_ENC_SRC_FORMAT);
+	value = 0;
+	if (cfg->sei.prefix_sei_nal_enable) {
+		mpp_write(mpp, cfg->sei.prefix_sei_nal_addr,
+			  H265E_CMD_ENC_PREFIX_SEI_NAL_ADDR);
+		value = cfg->sei.prefix_sei_data_size << 16 |
+			cfg->sei.prefix_sei_data_order << 1 |
+			cfg->sei.prefix_sei_nal_enable;
+	}
+	mpp_write(mpp, value, H265E_CMD_ENC_PREFIX_SEI_INFO);
+
+	value = 0;
+	if (cfg->sei.suffix_sei_nal_enable) {
+		mpp_write(mpp, cfg->sei.suffix_sei_nal_addr,
+			  H265E_CMD_ENC_SUFFIX_SEI_NAL_ADDR);
+		value = (cfg->sei.suffix_sei_data_size << 16) |
+			(cfg->sei.suffix_sei_data_enc_order << 1) |
+			cfg->sei.suffix_sei_nal_enable;
+	}
+	mpp_write(mpp, value, H265E_CMD_ENC_SUFFIX_SEI_INFO);
+
+	mpp_write(mpp, (u32)ctx->roi.dma_addr,
+		  H265E_CMD_ENC_ROI_ADDR_CTU_MAP);
+	mpp_write(mpp, (u32)ctx->ctu.dma_addr,
+		  H265E_CMD_ENC_CTU_QP_MAP_ADDR);
+
+	if (ctx->roi.dma_addr == 0 || ctx->roi.hdl < 0)
+		roi_enable = 0;
+	else
+		roi_enable = cfg->ctu.roi_enable;
+
+	if (ctx->ctu.dma_addr == 0 || ctx->ctu.hdl < 0)
+		ctu_qp_enable = 0;
+	else
+		ctu_qp_enable = cfg->ctu.ctu_qp_enable;
+	value = ((roi_enable) << 0) |
+			(cfg->ctu.roi_delta_qp << 1) |
+			(ctu_qp_enable << 9) |
+			(cfg->ctu.map_endian << 12) |
+			(cfg->ctu.map_stride << 16);
+
+	mpp_debug(DEBUG_H265E_INFO,
+		  "roi_enable = %d,roi_delta_qp = %d,ctu_qp_enable = %d\n",
+		  cfg->ctu.roi_enable, cfg->ctu.roi_delta_qp, ctu_qp_enable);
+	mpp_write(mpp, value,
+		  H265E_CMD_ENC_CTU_OPT_PARAM);
+
+	mpp_write(mpp, 0, H265E_CMD_ENC_SRC_TIMESTAMP_LOW);
+	mpp_write(mpp, 0, H265E_CMD_ENC_SRC_TIMESTAMP_HIGH);
+
+	value = (cfg->use_cur_as_longterm_pic << 0) |
+		(cfg->use_longterm_ref << 1);
+	mpp_write(mpp, value, H265E_CMD_ENC_LONGTERM_PIC);
+
+	mpp_write(mpp, 0, H265E_CMD_ENC_SUB_FRAME_SYNC_CONFIG);
+	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_ENC_PIC);
+	mpp_debug_leave();
+	return 0;
+}
+
+static int rockchip_mpp_h265e_get_encode_result(struct rockchip_mpp_dev *mpp,
+						struct h265e_ctx *ctx)
+{
+	u32 value, rd, wt;
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct h265e_result *result = NULL;
+	struct h265e_session *session = NULL;
+	int index;
+
+	mpp_debug_enter();
+	if (!mpp || !ctx) {
+		mpp_err("param is invalid");
+		return -1;
+	}
+	session = container_of(ctx->ictx.session,
+			       struct h265e_session,
+			       isession);
+	index = session->instance_index;
+	result = &ctx->result;
+	value = mpp_read(mpp, H265E_RET_SUCCESS);
+	if (value == 0) {
+		result->fail_reason = mpp_read(mpp, H265E_RET_FAIL_REASON);
+		mpp_err("fail reason = 0x%x", result->fail_reason);
+		mutex_unlock(&enc->lock);
+		mpp_debug_leave();
+		return -1;
+	}
+	result->fail_reason = 0;
+	result->enc_pic_cnt = mpp_read(mpp, H265E_RET_ENC_PIC_NUM);
+	value = mpp_read(mpp, H265E_RET_ENC_PIC_TYPE);
+	result->pic_type         = value & 0xFFFF;
+	result->recon_frame_index = mpp_read(mpp, H265E_RET_ENC_PIC_IDX);
+	result->num_of_slice     = mpp_read(mpp, H265E_RET_ENC_PIC_SLICE_NUM);
+	result->pick_skipped     = mpp_read(mpp, H265E_RET_ENC_PIC_SKIP);
+	result->num_intra        = mpp_read(mpp, H265E_RET_ENC_PIC_NUM_INTRA);
+	result->num_merge        = mpp_read(mpp, H265E_RET_ENC_PIC_NUM_MERGE);
+	result->num_skip_block   = mpp_read(mpp, H265E_RET_ENC_PIC_NUM_SKIP);
+	result->avg_ctu_qp       = mpp_read(mpp, H265E_RET_ENC_PIC_AVG_CU_QP);
+	result->bs_size          = mpp_read(mpp, H265E_RET_ENC_PIC_BYTE);
+	result->gop_idx    = mpp_read(mpp, H265E_RET_ENC_GOP_PIC_IDX);
+	result->poc       = mpp_read(mpp, H265E_RET_ENC_PIC_POC);
+	result->src_idx       = mpp_read(mpp, H265E_RET_ENC_USED_SRC_IDX);
+	rd = mpp_read(mpp, H265E_BS_RD_PTR);
+	wt = mpp_read(mpp, H265E_BS_WR_PTR);
+#if PRINT_BS_DATA
+	w_bs_size = result->bs_size;
+#endif
+	h265e_now = ktime_get();
+	mpp_debug(DEBUG_H265E_ENCODE_ONE_FRAME,
+		  "h265e encode time is:%d us\n",
+		  (int)ktime_to_us(ktime_sub(h265e_now, h265e_last)));
+	mpp_debug(DEBUG_H265E_ENCODE_ONE_FRAME,
+		  "RD_AXI_BYTE=%d,WR_AXI_BYTE=%d,WORK_CNT=%d\n",
+		  mpp_read(mpp, H265E_PERF_RD_AXI_TOTAL_BYTE),
+		  mpp_read(mpp, H265E_PERF_WR_AXI_TOTAL_BYTE),
+		  mpp_read(mpp, H265E_PERF_WORKING_CNT));
+	mpp_debug(DEBUG_H265E_ENCODE_ONE_FRAME,
+		  "index = %d, bs_size = %d,size = %d\n",
+		  index, result->bs_size, wt - rd);
+	if (result->recon_frame_index < 0)
+		result->bs_size   = 0;
+#if H265E_POWER_SAVE
+	rockchip_mpp_h265e_disable_clk(mpp);
+#endif
+	mutex_unlock(&enc->lock);
+	mpp_debug_leave();
+	return 0;
+}
+
+static long rockchip_mpp_h265e_ioctl(struct mpp_session *isession,
+				     unsigned int cmd,
+				     unsigned long arg)
+{
+	struct rockchip_mpp_dev *mpp = isession->mpp;
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+
+	struct rockchip_h265e_instance *instance = NULL;
+	struct h265e_session *session =
+					container_of(isession,
+						     struct h265e_session,
+						     isession);
+
+	int ret = 0;
+	int index = session->instance_index;
+
+	if (index < 0 || index >= H265E_INSTANCE_NUM) {
+		mpp_err("error: index = %d is invalid\n", index);
+		return -1;
+	}
+
+	instance = &enc->instance[index];
+	switch (cmd) {
+	case MPP_DEV_H265E_SET_COLOR_PALETTE:
+		break;
+	case MPP_DEV_H265E_SET_PARAMETER:
+		if (copy_from_user(&instance->cfg, (void __user *)arg,
+				   sizeof(struct mpp_h265e_cfg))) {
+			mpp_err("error: set reg copy_from_user failed\n");
+			return -EFAULT;
+		}
+		if (instance->status == H265E_INSTANCE_STATUS_OPENED)
+			ret = rockchip_mpp_h265e_set_parameter(mpp, index);
+		else
+			ret = rockchip_mpp_h265e_change_parameter(mpp, index);
+		break;
+	case MPP_DEV_H265E_GET_HEAD_PARAMETER:
+		{
+			struct hal_h265e_header head;
+
+			if (copy_from_user(&head,
+					   (void __user *)arg, sizeof(head))) {
+				mpp_err("error: set reg copy_from_user failed\n");
+				return -EFAULT;
+			}
+			head.size = 0;
+#ifdef	H265E_STREAM_HEADER
+			if (rockchip_mpp_h265e_get_stream_header(mpp,
+								 index, &head))
+				head.size = 0;
+#endif
+			if (copy_to_user((void __user *)arg,
+					 &head, sizeof(head))) {
+				mpp_err("copy result to user failed\n");
+				return -1;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+struct mpp_dev_ops h265e_ops = {
+	.init = rockchip_mpp_h265e_ctx_init,
+	.prepare = NULL,
+	.run = rockchip_mpp_h265e_run,
+	.done = rockchip_mpp_h265e_done,
+	.irq = rockchip_mpp_h265e_irq,
+	.result = rockchip_mpp_h265e_result,
+	.ioctl = rockchip_mpp_h265e_ioctl,
+	.open = rockchip_mpp_h265e_open,
+	.release = rockchip_mpp_h265e_release,
+	.free = rockchip_mpp_h265e_free,
+};
+
+static void rockchip_mpp_h265e_enable_clk(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+
+	if (enc->aclk)
+		clk_prepare_enable(enc->aclk);
+	if (enc->pclk)
+		clk_prepare_enable(enc->pclk);
+	if (enc->core)
+		clk_prepare_enable(enc->core);
+	if (enc->dsp)
+		clk_prepare_enable(enc->dsp);
+#if H265E_AXI_STATUS
+	if (enc->aclk_axi2sram)
+		clk_prepare_enable(enc->aclk_axi2sram);
+#endif
+}
+
+static void rockchip_mpp_h265e_disable_clk(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+
+	if (enc->dsp)
+		clk_disable_unprepare(enc->dsp);
+	if (enc->core)
+		clk_disable_unprepare(enc->core);
+	if (enc->pclk)
+		clk_disable_unprepare(enc->pclk);
+	if (enc->aclk)
+		clk_disable_unprepare(enc->aclk);
+#if H265E_AXI_STATUS
+	if (enc->aclk_axi2sram)
+		clk_disable_unprepare(enc->aclk_axi2sram);
+#endif
+}
+
+static void rockchip_mpp_h265e_power_on(struct rockchip_mpp_dev *mpp)
+{
+	rockchip_mpp_h265e_enable_clk(mpp);
+}
+
+static void rockchip_mpp_h265e_power_off(struct rockchip_mpp_dev *mpp)
+{
+	rockchip_mpp_h265e_disable_clk(mpp);
+}
+
+static struct mpp_session *rockchip_mpp_h265e_open(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct h265e_session *session = kzalloc(sizeof(*session), GFP_KERNEL);
+	u32 code_base;
+	u32	i, reg_val = 0, remap_size = 0, ret;
+	struct rockchip_h265e_instance *instance = NULL;
+	int index = 0;
+
+	mpp_debug_enter();
+	mutex_lock(&enc->lock);
+	if (!session) {
+		mpp_err("failed to allocate h265e_session data");
+		goto NFREE_FAIL;
+	}
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_enable_clk(mpp);
+#endif
+	mpp_dev_power_on(mpp);
+
+	for (i = 0; i < H265E_INSTANCE_NUM; i++) {
+		instance = &enc->instance[i];
+		instance->session = &session->isession;
+		if (!atomic_read(&instance->is_used)) {
+			instance->work.size = H265E_WORK_BUFFER_SIZE;
+			instance->work.hdl =
+				rockchip_mpp_h265e_dma_alloc(mpp,
+							     instance->session,
+							     instance->work.size,
+							     MPP_ALIGN_SIZE,
+							     &instance->work.dma_addr);
+			instance->index = i;
+			atomic_set(&instance->is_used, 1);
+			break;
+		}
+	}
+	if (i == H265E_INSTANCE_NUM) {
+		mpp_err("error: the num of instance up to H265E_INSTANCE_NUM\n");
+		goto NFREE_FAIL;
+	}
+
+	if (!atomic_read(&enc->load_firmware)) {
+		ret = rockchip_mpp_h265e_load_firmware(mpp, instance->session);
+		if (ret)
+			goto FAIL;
+		atomic_inc(&enc->load_firmware);
+		enc->temp.size = H265E_TEMP_BUFFER_SIZE;
+		enc->temp.hdl =
+			rockchip_mpp_h265e_dma_alloc(mpp,
+						     instance->session,
+						     enc->temp.size,
+						     MPP_ALIGN_SIZE,
+						     &enc->temp.dma_addr);
+		if (enc->temp.hdl < 0) {
+			mpp_err("error: alloc temp buffer error\n");
+			goto FAIL;
+		}
+	}
+
+	index = instance->index;
+	instance->status = H265E_INSTANCE_STATUS_ERROR;
+	mpp_debug(DEBUG_H265E_INFO,
+		  "%s = %d\n", __func__, index);
+	session->instance_index = index;
+	code_base = (u32)enc->firmware.dma_addr;
+	mpp_debug(DEBUG_H265E_INFO, "h265e code_base = %x\n", code_base);
+	if (!atomic_read(&enc->is_init)) {
+		mpp_write(mpp, 0x0, H265E_PO_CONF);
+		mpp_write(mpp, 0x7ffffff, H265E_VPU_RESET_REQ);
+
+		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
+			mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
+			mpp_write(mpp, 0, H265E_VPU_RESET_REQ);
+			goto FAIL;
+		}
+		mpp_write(mpp, 0, H265E_VPU_RESET_REQ);
+		for (i = H265E_COMMAND; i < H265E_CMD_REG_END; i += 4)
+			mpp_write(mpp, 0x00, i);
+		remap_size = 0x100;
+		reg_val = 0x80000000 | (0 << 16) |
+			  (H265E_REMAP_CODE_INDEX << 12) |
+			  (1 << 11) | remap_size;
+		mpp_write(mpp, reg_val, H265E_VPU_REMAP_CTRL);
+		mpp_write(mpp, 0x00000000, H265E_VPU_REMAP_VADDR);
+		mpp_write(mpp, code_base, H265E_VPU_REMAP_PADDR);
+		mpp_write(mpp, code_base, H265E_ADDR_CODE_BASE);
+		mpp_write(mpp, H265E_CODE_BUFFER_SIZE, H265E_CODE_SIZE);
+		mpp_write(mpp, 0, H265E_CODE_PARAM);
+		mpp_write(mpp, 0, H265E_HW_OPTION);
+		mpp_write(mpp, H265E_INT_OPEN, H265E_VPU_VINT_ENABLE);
+		mpp_write(mpp, 0xfffffff2, H265E_PERF_LATENCY_CTRL0);
+		mpp_write(mpp, 0x0, H265E_PERF_LATENCY_CTRL1);
+		mpp_write(mpp, 0x1, H265E_PERF_AXI_CTRL);
+		mpp_write(mpp, 0x01, H265E_VPU_BUSY_STATUS);
+		mpp_write(mpp, H265E_CMD_INIT_VPU, H265E_COMMAND);
+		mpp_write(mpp, 0x01, H265E_VPU_REMAP_CORE_START);
+		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
+			mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
+			goto FAIL;
+		}
+		if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
+			mpp_err("h265e init ret fail\n");
+			goto FAIL;
+		}
+		/* start Init command*/
+		rockchip_mpp_h265e_issue_command(mpp,
+						 index,
+						 H265E_CMD_GET_FW_VERSION);
+		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
+			mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
+			goto FAIL;
+		}
+		if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
+			mpp_err("h265e creat instance ret fail\n");
+			goto FAIL;
+		}
+		reg_val = mpp_read(mpp, H265E_RET_FW_VERSION);
+		mpp_debug(DEBUG_H265E_INFO,
+			  "get_firmware_version:VERSION=%d\n", reg_val);
+		atomic_inc(&enc->is_init);
+	}
+	mpp_write(mpp, 0x0, H265E_CORE_INDEX);
+	mpp_write(mpp, 0x00010000 | index, H265E_INST_INDEX);
+	mpp_write(mpp, (u32)instance->work.dma_addr, H265E_ADDR_WORK_BASE);
+	mpp_write(mpp, H265E_WORK_BUFFER_SIZE, H265E_WORK_SIZE);
+	mpp_write(mpp, 0, H265E_WORK_PARAM);
+	mpp_debug(DEBUG_H265E_INFO,
+		  "open instance=%d work addr=%x\n",
+		  index,
+		  (u32)instance->work.dma_addr);
+	/* create instance*/
+	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_CREATE_INSTANCE);
+	if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
+		mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
+		goto FAIL;
+	}
+	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
+		mpp_err("h265e creat instance ret fail\n");
+		goto FAIL;
+	}
+	/* set default buffer counter*/
+	instance->min_frame_buffer_count = 2;
+	instance->min_src_frame_count = 2;
+	instance->src_idx = 0;
+	instance->status = H265E_INSTANCE_STATUS_OPENED;
+#if H265E_POWER_SAVE
+	rockchip_mpp_h265e_disable_clk(mpp);
+#endif
+	mutex_unlock(&enc->lock);
+	mpp_debug_leave();
+	return &session->isession;
+FAIL:
+	rockchip_mpp_h265e_free_instance(mpp, index);
+NFREE_FAIL:
+	kfree(session);
+	session = NULL;
+	mutex_unlock(&enc->lock);
+	mpp_err("h265e open fail\n");
+	return NULL;
+}
+
+static void rockchip_mpp_h265e_free(struct mpp_session *isession)
+{
+	struct h265e_session *session =
+					container_of(isession,
+						     struct h265e_session,
+						     isession);
+	kfree(session);
+}
+
+static void rockchip_mpp_h265e_release(struct mpp_session *isession)
+{
+	struct h265e_session *session =
+					container_of(isession,
+						     struct h265e_session,
+						     isession);
+	struct rockchip_mpp_dev *mpp = session->isession.mpp;
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	int index = 0;
+
+	mpp_debug_enter();
+	mutex_lock(&enc->lock);
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_enable_clk(mpp);
+#endif
+	mpp_dev_power_on(mpp);
+	index = session->instance_index;
+	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_FINI_SEQ);
+	if (rockchip_mpp_h265e_wait_busy(mpp) == -1)
+		mpp_err("h265e_wait_busy timeout,index=%d\n", index);
+	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0)
+		mpp_err("h265e close instance %d ret fail\n", index);
+	rockchip_mpp_h265e_free_instance(mpp, index);
+#if	H265E_POWER_SAVE
+	rockchip_mpp_h265e_disable_clk(mpp);
+#endif
+	mutex_unlock(&enc->lock);
+	mpp_debug_leave();
+}
+
+static int rockchip_mpp_h265e_probe(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct device_node *np = mpp->dev->of_node;
+	int i;
+
+	enc->dev.ops = &h265e_ops;
+	for (i = 0; i < H265E_INSTANCE_NUM; i++)
+		atomic_set(&enc->instance[i].is_used, 0);
+	atomic_set(&enc->load_firmware, 0);
+	atomic_set(&enc->is_init, 0);
+	mutex_init(&enc->lock);
+#if H265E_CLK
+	enc->aclk = devm_clk_get(mpp->dev, "aclk_h265");
+	if (IS_ERR_OR_NULL(enc->aclk)) {
+		dev_err(mpp->dev, "failed on clk_get aclk\n");
+		enc->aclk = NULL;
+		goto fail;
+	}
+	enc->pclk = devm_clk_get(mpp->dev, "pclk_h265");
+	if (IS_ERR_OR_NULL(enc->pclk)) {
+		dev_err(mpp->dev, "failed on clk_get pclk\n");
+		enc->pclk = NULL;
+		goto fail;
+	}
+	enc->core = devm_clk_get(mpp->dev, "clk_core");
+	if (IS_ERR_OR_NULL(enc->core)) {
+		dev_err(mpp->dev, "failed on clk_get core\n");
+		enc->core = NULL;
+		goto fail;
+	}
+	enc->dsp = devm_clk_get(mpp->dev, "clk_dsp");
+	if (IS_ERR_OR_NULL(enc->dsp)) {
+		dev_err(mpp->dev, "failed on clk_get dsp\n");
+		enc->dsp = NULL;
+		goto fail;
+	}
+#if H265E_AXI_STATUS
+	enc->aclk_axi2sram = devm_clk_get(mpp->dev, "aclk_axi2sram");
+	if (IS_ERR_OR_NULL(enc->aclk_axi2sram)) {
+		dev_err(mpp->dev, "failed on clk_get aclk_axi2sram\n");
+		enc->aclk_axi2sram = NULL;
+		goto fail;
+	}
+#endif
+#endif
+	if (of_property_read_bool(np, "mode_ctrl")) {
+		of_property_read_u32(np, "mode_bit", &enc->mode_bit);
+		of_property_read_u32(np, "mode_ctrl", &enc->mode_ctrl);
+#ifdef CONFIG_MFD_SYSCON
+		enc->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+		if (IS_ERR_OR_NULL(enc->grf)) {
+			enc->grf = NULL;
+			mpp_err("can't find vpu grf property\n");
+			return -1;
+		}
+#endif
+	}
+
+	return 0;
+#if H265E_CLK
+fail:
+	return -1;
+#endif
+}
+
+static void rockchip_mpp_h265e_remove(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_h265e_dev *enc =
+					 container_of(mpp,
+						      struct rockchip_h265e_dev,
+						      dev);
+	struct rockchip_h265e_instance *instance = NULL;
+	struct mpp_h265e_buffer *buf = NULL;
+	struct mpp_session *session = list_first_entry(&mpp->srv->session,
+						       struct mpp_session,
+						       list_session);
+	int i = 0;
+
+	mpp_debug_enter();
+	mutex_lock(&enc->lock);
+	for (i = 0; i < H265E_INSTANCE_NUM; i++) {
+		instance = &enc->instance[i];
+		if (atomic_read(&instance->is_used) == 1) {
+			buf = &instance->work;
+			if (buf->hdl >= 0) {
+				vpu_iommu_unmap_kernel(mpp->iommu_info,
+						       session, buf->hdl);
+				vpu_iommu_free(mpp->iommu_info, session,
+					       buf->hdl);
+			}
+			rockchip_mpp_h265e_free_frame_buffer(mpp, instance);
+			atomic_set(&instance->is_used, 0);
+		}
+	}
+	atomic_set(&enc->is_init, 0);
+	atomic_set(&enc->load_firmware, 0);
+	buf = &enc->temp;
+	if (buf->hdl >= 0) {
+		vpu_iommu_unmap_kernel(mpp->iommu_info, session, buf->hdl);
+		vpu_iommu_free(mpp->iommu_info, session, buf->hdl);
+	}
+
+	if (enc->firmware.hdl >= 0) {
+		vpu_iommu_unmap_kernel(mpp->iommu_info, session,
+				       enc->firmware.hdl);
+		vpu_iommu_free(mpp->iommu_info, session, enc->firmware.hdl);
+	}
+	mutex_unlock(&enc->lock);
+	mpp_debug_leave();
+}
+
+const struct rockchip_mpp_dev_variant h265e_variant = {
+	.data_len = sizeof(struct rockchip_h265e_dev),
+	.trans_info = NULL,
+	.mmu_dev_dts_name = NULL,
+	.hw_probe = rockchip_mpp_h265e_probe,
+	.hw_remove = rockchip_mpp_h265e_remove,
+	.power_on = rockchip_mpp_h265e_power_on,
+	.power_off = rockchip_mpp_h265e_power_off,
+	.reset = NULL,
+};
+EXPORT_SYMBOL(h265e_variant);
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_h265e_define.h b/drivers/video/rockchip/vpu/mpp_dev_h265e_define.h
--- a/drivers/video/rockchip/vpu/mpp_dev_h265e_define.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_h265e_define.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,759 @@
+ /*
+  * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+  * author: hehua,hh@rock-chips.com
+  * lixinhuang, buluess.li@rock-chips.com
+  *
+  * This software is licensed under the terms of the GNU General Public
+  * License version 2, as published by the Free Software Foundation, and
+  * may be copied, distributed, and modified under those terms.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  */
+#ifndef __MPP_DEV_H265E_DEFINE_H__
+#define __MPP_DEV_H265E_DEFINE_H__
+
+#include <linux/bitops.h>
+
+#define H265E_MVCOL_BUF_SIZE(w, h) \
+	((((w) + 63) / 64) * (((h) + 63) / 64) * 128)
+#define H265E_FBC_LUMA_TABLE_SIZE(w, h) \
+	((((h) + 15) / 16) * (((w) + 255) / 256) * 128)
+#define H265E_FBC_CHROMA_TABLE_SIZE(w, h) \
+	((((h) + 15) / 16) * (((w) / 2 + 255) / 256) * 128)
+#define H265E_SUBSAMPLED_ONE_SIZE(w, h) \
+	(((((w) / 4) + 15) & ~15) * ((((h) / 4) + 7) & ~7))
+
+#define H265E_PIC_TYPE_I 0
+#define H265E_PIC_TYPE_P 1
+
+enum H265E_VPU_COMMAND {
+	H265E_CMD_INIT_VPU        = 0x0001,
+	H265E_CMD_SET_PARAM       = 0x0002,
+	H265E_CMD_FINI_SEQ        = 0x0004,
+	H265E_CMD_ENC_PIC         = 0x0008,
+	H265E_CMD_SET_FRAMEBUF    = 0x0010,
+	H265E_CMD_FLUSH_DECODER   = 0x0020,
+	H265E_CMD_GET_FW_VERSION  = 0x0100,
+	H265E_CMD_QUERY_DECODER   = 0x0200,
+	H265E_CMD_SLEEP_VPU       = 0x0400,
+	H265E_CMD_WAKEUP_VPU      = 0x0800,
+	H265E_CMD_CREATE_INSTANCE = 0x4000,
+	H265E_CMD_RESET_VPU	  = 0x10000,
+	H265E_CMD_MAX_VPU_COMD	  = 0x10000,
+};
+
+enum H265E_PIC_CODE_OPTION {
+	CODEOPT_ENC_HEADER_IMPLICIT = BIT(0),
+	CODEOPT_ENC_VCL             = BIT(1),
+	CODEOPT_ENC_VPS             = BIT(2),
+	CODEOPT_ENC_SPS             = BIT(3),
+	CODEOPT_ENC_PPS             = BIT(4),
+	CODEOPT_ENC_AUD             = BIT(5),
+	CODEOPT_ENC_EOS             = BIT(6),
+	CODEOPT_ENC_EOB             = BIT(7),
+	CODEOPT_ENC_RESERVED        = BIT(8),
+	CODEOPT_ENC_VUI             = BIT(9),
+};
+
+enum H265E_TILED_MAP_TYPE {
+	LINEAR_FRAME_MAP            = 0,
+	TILED_FRAME_V_MAP           = 1,
+	TILED_FRAME_H_MAP           = 2,
+	TILED_FIELD_V_MAP           = 3,
+	TILED_MIXED_V_MAP           = 4,
+	TILED_FRAME_MB_RASTER_MAP   = 5,
+	TILED_FIELD_MB_RASTER_MAP   = 6,
+	TILED_FRAME_NO_BANK_MAP     = 7,
+	TILED_FIELD_NO_BANK_MAP     = 8,
+	LINEAR_FIELD_MAP            = 9,
+	CODA_TILED_MAP_TYPE_MAX     = 10,
+	COMPRESSED_FRAME_MAP        = 10,
+	TILED_SUB_CTU_MAP           = 11,
+	ARM_COMPRESSED_FRAME_MAP      = 12,
+};
+
+#define H265E_MAX_NUM_TEMPORAL_LAYER          7
+#define H265E_MAX_GOP_NUM                     8
+#define H265E_MIN_PIC_WIDTH            256
+#define H265E_MIN_PIC_HEIGHT           128
+#define H265E_MAX_PIC_WIDTH            1920
+#define H265E_MAX_PIC_HEIGHT           1080
+#define MAX_ROI_NUMBER  64
+
+enum H265E_GOP_PRESET_IDX {
+	PRESET_IDX_CUSTOM_GOP       = 0,
+	PRESET_IDX_ALL_I            = 1,
+	PRESET_IDX_IPP              = 2,
+	PRESET_IDX_IPPPP            = 6,
+};
+
+enum H265E_SET_PARAM_OPTION {
+	H265E_OPT_COMMON          = 0,
+	H265E_OPT_CUSTOM_GOP      = 1,
+	H265E_OPT_CUSTOM_HEADER   = 2,
+	H265E_OPT_VUI             = 3,
+	H265E_OPT_ALL_PARAM       = 0xffffffff
+};
+
+enum H265E_PARAM_CHANEGED {
+	H265E_PARAM_CHANEGED_COMMON          = 1,
+	H265E_PARAM_CHANEGED_CUSTOM_GOP      = 2,
+	H265E_PARAM_CHANEGED_VUI             = 4,
+	H265E_PARAM_CHANEGED_REGISTER_BUFFER = 8,
+};
+
+enum H265E_COMON_CFG_MASK {
+	/* COMMON parameters*/
+	H265E_CFG_SEQ_SRC_SIZE_CHANGE             = BIT(0),
+	H265E_CFG_SEQ_PARAM_CHANGE                = BIT(1),
+	H265E_CFG_GOP_PARAM_CHANGE                = BIT(2),
+	H265E_CFG_INTRA_PARAM_CHANGE              = BIT(3),
+	H265E_CFG_CONF_WIN_TOP_BOT_CHANGE         = BIT(4),
+	H265E_CFG_CONF_WIN_LEFT_RIGHT_CHANGE      = BIT(5),
+	H265E_CFG_FRAME_RATE_CHANGE               = BIT(6),
+	H265E_CFG_INDEPENDENT_SLICE_CHANGE        = BIT(7),
+	H265E_CFG_DEPENDENT_SLICE_CHANGE          = BIT(8),
+	H265E_CFG_INTRA_REFRESH_CHANGE            = BIT(9),
+	H265E_CFG_PARAM_CHANGE                    = BIT(10),
+	H265E_CFG_CHANGE_RESERVED                 = BIT(11),
+	H265E_CFG_RC_PARAM_CHANGE                 = BIT(12),
+	H265E_CFG_RC_MIN_MAX_QP_CHANGE            = BIT(13),
+	H265E_CFG_RC_TARGET_RATE_LAYER_0_3_CHANGE = BIT(14),
+	H265E_CFG_RC_TARGET_RATE_LAYER_4_7_CHANGE = BIT(15),
+
+	H265E_CFG_SET_NUM_UNITS_IN_TICK		  = BIT(18),
+	H265E_CFG_SET_TIME_SCALE		  = BIT(19),
+	H265E_CFG_SET_NUM_TICKS_POC_DIFF_ONE	  = BIT(20),
+	H265E_CFG_RC_TRANS_RATE_CHANGE            = BIT(21),
+	H265E_CFG_RC_TARGET_RATE_CHANGE           = BIT(22),
+	H265E_CFG_ROT_PARAM_CHANGE                = BIT(23),
+	H265E_CFG_NR_PARAM_CHANGE                 = BIT(24),
+	H265E_CFG_NR_WEIGHT_CHANGE                = BIT(25),
+
+	H265E_CFG_SET_VCORE_LIMIT                 = BIT(27),
+	H265E_CFG_CHANGE_SET_PARAM_ALL            = (0xFFFFFFFF),
+};
+
+/**
+ * @brief    This is a data structure for setting
+ * CTU level options (ROI, CTU mode, CTU QP) in HEVC encoder.
+ */
+struct h265e_ctu {
+	u32 roi_enable;
+	u32 roi_delta_qp;
+	u32 map_endian;
+
+	/*
+	 * Stride of CTU-level ROI/mode/QP map
+	 * Set this with (Width  + CTB_SIZE - 1) / CTB_SIZE
+	 */
+	u32 map_stride;
+	/*
+	 * It enables CTU QP map that allows
+	 * CTUs to be encoded with the given QPs.
+	 * NOTE: rcEnable should be turned off for this,
+	 * encoding with the given CTU QPs.
+	 */
+	u32 ctu_qp_enable;
+};
+
+struct h265e_sei {
+	u8 prefix_sei_nal_enable;
+
+	/*
+	 * A flag whether to encode PREFIX_SEI_DATA
+	 * with a picture of this command or with a source
+	 * picture of the buffer at the moment
+	 * 0 : encode PREFIX_SEI_DATA when a source picture is encoded.
+	 * 1 : encode PREFIX_SEI_DATA at this command.
+	 */
+	u8 prefix_sei_data_order;
+
+	/*
+	 * enables to encode the suffix SEI NAL which is given by host.
+	 */
+	u8 suffix_sei_nal_enable;
+
+	/*
+	 * A flag whether to encode SUFFIX_SEI_DATA
+	 * with a picture of this command or with a source
+	 * picture of the buffer at the moment
+	 * 0 : encode SUFFIX_SEI_DATA when a source picture is encoded.
+	 * 1 : encode SUFFIX_SEI_DATA at this command.
+	 */
+	u8 suffix_sei_data_enc_order;
+
+	/*
+	 * The total byte size of the prefix SEI
+	 */
+	u32 prefix_sei_data_size;
+
+	/*
+	 * The start address of the total prefix SEI NALs to be encoded
+	 */
+	u32 prefix_sei_nal_addr;
+
+	/*
+	 * The total byte size of the suffix SEI
+	 */
+	u32 suffix_sei_data_size;
+
+	/*
+	 * The start address of the total suffix SEI NALs to be encoded
+	 */
+	u32 suffix_sei_nal_addr;
+};
+
+/**
+ * @brief    This is a data structure for setting
+ * VUI parameters in HEVC encoder.
+ */
+struct h265e_vui {
+	/*
+	 * VUI parameter flag
+	 */
+	u32 flags;
+	/**< aspect_ratio_idc */
+	u32 aspect_ratio_idc;
+	/**< sar_width, sar_height
+	 * (only valid when aspect_ratio_idc is equal to 255)
+	 */
+	u32 sar_size;
+	/**< overscan_appropriate_flag */
+	u32 over_scan_appropriate;
+	/**< VUI parameter flag */
+	u32 signal;
+	/**< chroma_sample_loc_type_top_field,
+	 *chroma_sample_loc_type_bottom_field
+	 */
+	u32 chroma_sample_loc;
+	/**< def_disp_win_left_offset, def_disp_win_right_offset */
+	u32 disp_win_left_right;
+	/**< def_disp_win_top_offset, def_disp_win_bottom_offset */
+	u32 disp_win_top_bottom;
+};
+
+/**
+ * @brief    This is a data structure for
+ *custom GOP parameters of the given picture.
+ */
+struct h265e_custom_gop_pic {
+	/**< A picture type of #th picture in the custom GOP */
+	u32 type;
+	/**< A POC offset of #th picture in the custom GOP */
+	u32 offset;
+	/**< A quantization parameter of #th picture in the custom GOP */
+	u32 qp;
+	/**< POC offset of reference L0 of #th picture in the custom GOP */
+	u32 ref_poc_l0;
+	/**< POC offset of reference L1 of #th picture in the custom GOP */
+	u32 ref_poc_l1;
+	/**< A temporal ID of #th picture in the custom GOP */
+	u32 temporal_id;
+};
+
+/**
+ * @brief    This is a data structure for custom GOP parameters.
+ */
+struct h265e_custom_gop {
+	/**< Size of the custom GOP (0~8) */
+	u32 custom_gop_size;
+	/**< It derives a lamda weight internally
+	 * instead of using lamda weight specified.
+	 */
+	u32 use_derive_lambda_weight;
+	/**< picture parameters of #th picture in the custom gop */
+	struct h265e_custom_gop_pic pic[H265E_MAX_GOP_NUM];
+	/**< a lamda weight of #th picture in the custom gop */
+	u32 gop_pic_lambda[H265E_MAX_GOP_NUM];
+};
+
+struct enc_code_opt {
+	/**< whether host encode a header implicitly or not.
+	 * if this value is 1, below encode options will be ignored
+	 */
+	int implicit_header_encode;
+	int encode_vcl;/**< a flag to encode vcl nal unit explicitly*/
+	int encode_vps;/**< a flag to encode vps nal unit explicitly*/
+	int encode_sps;/**< a flag to encode sps nal unit explicitly*/
+	int encode_pps;/**< a flag to encode pps nal unit explicitly*/
+	int encode_aud;/**< a flag to encode aud nal unit explicitly*/
+	int encode_eos;/**< a flag to encode eos nal unit explicitly*/
+	int encode_eob;/**< a flag to encode eob nal unit explicitly*/
+	int encode_vui;/**< a flag to encode vui nal unit explicitly*/
+};
+
+enum H265E_SRC_FORMAT {
+	H265E_SRC_YUV_420 = 0,
+	H265E_SRC_YUV_420_YU12 = 0, /*  3Plane 1.Y, 2.U, 3.V*/
+	H265E_SRC_YUV_420_YV12, /*  3Plane 1.Y, 2.V, 3.U*/
+	H265E_SRC_YUV_420_NV12, /* 2 Plane 1.Y 2. UV*/
+	H265E_SRC_YUV_420_NV21, /* 2 Plane 1.Y 2. VU*/
+	H265E_SRC_YUV_420_MAX,
+};
+
+struct hal_h265e_header {
+	u32         buf;
+	u32         size;
+};
+
+struct mpp_h265e_cfg {
+	/*
+	 * A profile indicator
+	 * 1 : main
+	 * 2 : main10
+	 */
+	u8 profile;
+
+	/*
+	 * only support to level 4.1
+	 */
+	u8 level; /**< A level indicator (level * 10) */
+
+	/*
+	 * A tier indicator
+	 * 0 : main
+	 * 1 : high
+	 */
+	u8 tier;
+
+	/*
+	 * A chroma format indecator, only support YUV420
+	 */
+	u8 chroma_idc;
+
+	/*
+	 * the source's width and height
+	 */
+	u16 width;
+	u16 height;
+	u16 width_stride;
+	u16 height_stride;
+
+	/*
+	 * bitdepth,only support 8 bits(only support 8 bits)
+	 */
+	u8 bit_depth;
+
+	/*
+	 * source yuv's format. The value is defined
+	 * in H265E_FrameBufferFormat(only support YUV420)
+	 * the value could be YU12,YV12,NV12,NV21
+	 */
+	u8 src_format;
+
+	u8 src_endian;
+	u8 bs_endian;
+	u8 fb_endian;
+	u8 frame_rate;
+	u8 frame_skip;
+	u32 bit_rate;
+
+	u32 map_type;
+	u32 line_buf_int_en;
+	u32 slice_int_enable;
+	u32 ring_buffer_enable;
+
+	struct enc_code_opt code_option;
+	/*
+	 * A chroma format indecator, only support YUV420
+	 */
+	int lossless_enable;/**< It enables lossless coding */
+	/**< It enables constrained intra prediction */
+	int const_intra_pred_flag;
+	/**< The value of chroma(cb) qp offset (only for WAVE420L) */
+	int chroma_cb_qp_offset;
+	/**< The value of chroma(cr) qp offset  (only for WAVE420L) */
+	int chroma_cr_qp_offset;
+	/**
+	 * A GOP structure option
+	 * 0: Custom GOP
+	 * 1 : I-I-I-I,..I (all intra, gop_size=1)
+	 * 2 : I-P-P-P,... P (consecutive P, gop_size=1)
+	 * 6 : I-P-P-P-P (consecutive P, gop_size=4)
+	 */
+	u32 gop_idx;
+
+	/**
+	 * An intra picture refresh mode
+	 * 0 : Non-IRAP
+	 * 1 : CRA
+	 * 2 : IDR
+	 */
+	u32 decoding_refresh_type;
+
+	/*
+	 * A quantization parameter of intra picture
+	 */
+	u32 intra_qp;
+
+	/*
+	 * A period of intra picture in GOP size
+	 */
+	u32 intra_period;
+
+	/** A conformance window size of TOP,BUTTOM,LEFT,RIGHT */
+	u16 conf_win_top;
+	u16 conf_win_bot;
+	u16 conf_win_left;
+	u16 conf_win_right;
+
+	/*
+	 * A slice mode for independent slice
+	 * 0 : no multi-slice
+	 * 1 : Slice in CTU number
+	 * 2 : Slice in number of byte
+	 */
+	u32 independ_slice_mode;
+
+	/*
+	 * The number of CTU or bytes for a slice
+	 * when independ_slice_mode is set with 1 or 2.
+	 */
+	u32 independ_slice_mode_arg;
+
+	/**
+	 *A slice mode for dependent slice
+	 * 0 : no multi-slice
+	 * 1 : Slice in CTU number
+	 * 2 : Slice in number of byte
+	 */
+	u32 depend_slice_mode;
+
+	/*
+	 * The number of CTU or bytes for a slice
+	 * when depend_slice_mode is set with 1 or 2.
+	 */
+	u32 depend_slice_mode_arg;
+
+	/*
+	 * An intra refresh mode
+	 * 0 : No intra refresh
+	 * 1 : Row
+	 * 2 : Column
+	 * 3 : Step size in CTU
+	 */
+	u32 intra_refresh_mode;
+
+	/*
+	 * The number of CTU (only valid when intraRefreshMode is 3.)
+	 */
+	u32 intra_refresh_arg;
+
+	/*
+	 * It uses one of the recommended encoder parameter presets.
+	 * 0 : Custom
+	 * 1 : Recommend enc params
+	 * (slow encoding speed, highest picture quality)
+	 * 2 : Boost mode (normal encoding speed, normal picture quality)
+	 * 3 : Fast mode (high encoding speed, low picture quality)
+	 */
+	u8 use_recommend_param;
+	u8 scaling_list_enable; /**< It enables a scaling list */
+
+	/*
+	 * It specifies CU size.
+	 * 3'b001: 8x8
+	 * 3'b010: 16x16
+	 * 3'b100 : 32x32
+	 */
+	u8 cu_size_mode;
+	u8 tmvp_enable;
+	u8 wpp_enable; /**< It enables wave-front parallel processing. */
+	u8 max_num_merge; /**< Maximum number of merge candidates (0~2) */
+	u8 dynamic_merge_8x8_enable;
+	u8 dynamic_merge_16x16_enable;
+	u8 dynamic_merge_32x32_enable;
+	u8 disable_deblk; /**< It disables in-loop deblocking filtering. */
+	/**< it enables filtering across slice
+	 * boundaries for in-loop deblocking.
+	 */
+	u8 lf_cross_slice_boundary_enable;
+	/**< BetaOffsetDiv2 for deblocking filter */
+	u8 beta_offset_div2;
+	/**< TcOffsetDiv3 for deblocking filter */
+	u8 tc_offset_div2;
+	/**< It enables transform skip for an intra CU. */
+	u8 skip_intra_trans;
+	/**< It enables SAO (sample adaptive offset). */
+	u8 sao_enable;
+	/**< It enables to make intra CUs in an inter slice. */
+	u8 intra_in_inter_slice_enable;
+	/**< It enables intra NxN PUs. */
+	u8 intra_nxn_enable;
+
+	/*
+	 * specifies intra QP offset relative
+	 * to inter QP (Only available when rc_enable is enabled)
+	 */
+	s8 intra_qp_offset;
+
+	/*
+	 * It specifies encoder initial delay,
+	 * Only available when RateControl is enabled
+	 * (encoder initial delay = initial_delay * init_buf_levelx8 / 8)
+	 */
+	int init_buf_levelx8;
+
+	/*
+	 * specifies picture bits allocation mode.
+	 * Only available when RateControl is enabled
+	 * and GOP size is larger than 1
+	 * 0: More referenced pictures have
+	 * better quality than less referenced pictures
+	 * 1: All pictures in a GOP have similar image quality
+	 * 2: Each picture bits in a GOP is allocated according to FixedRatioN
+	 */
+	u8 bit_alloc_mode;
+
+	/*
+	 * A fixed bit ratio (1 ~ 255) for each picture of GOP's bitallocation
+	 * N = 0 ~ (MAX_GOP_SIZE - 1)
+	 * MAX_GOP_SIZE = 8
+	 * For instance when MAX_GOP_SIZE is 3, FixedBitRaio0
+	 * to FixedBitRaio2 can be set as 2, 1, and 1 respectively for
+	 * the fixed bit ratio 2:1:1. This is only valid when BitAllocMode is 2.
+	 */
+	u8 fixed_bit_ratio[H265E_MAX_GOP_NUM];
+
+	/*
+	 * enable rate control
+	 */
+	u32 rc_enable;
+
+	/*
+	 * enable CU level rate control
+	 */
+	u8 cu_level_rc_enable;
+
+	/*
+	 * enable CU QP adjustment for subjective quality enhancement
+	 */
+	u8 hvs_qp_enable;
+
+	/*
+	 * enable QP scaling factor for CU QP adjustment when hvs_qp_enable = 1
+	 */
+	u8 hvs_qp_scale_enable;
+
+	/*
+	 * A QP scaling factor for CU QP adjustment when hvs_qp_enable = 1
+	 */
+	s8 hvs_qp_scale;
+
+	/*
+	 * A minimum QP for rate control
+	 */
+	u8 min_qp;
+
+	/*
+	 * A maximum QP for rate control
+	 */
+	u8 max_qp;
+
+	/*
+	 * A maximum delta QP for rate control
+	 */
+	u8 max_delta_qp;
+
+	/*
+	 * A peak transmission bitrate in bps
+	 */
+	u32 trans_rate;
+	/*< It specifies the number of time units of
+	 * a clock operating at the frequency time_scale Hz
+	 */
+	u32 num_units_in_tick;
+	/**< It specifies the number of time units that pass in one second */
+	u32 time_scale;
+	/**< It specifies the number of clock ticks corresponding to a
+	 * difference of picture order count values equal to 1
+	 */
+	u32 num_ticks_poc_diff_one;
+
+	/*< The value of initial QP by host.
+	 * This value is meaningless if INITIAL_RC_QP == 63
+	 */
+	int initial_rc_qp;
+
+	/*
+	 * enables noise reduction algorithm to Y/Cb/Cr component.
+	 */
+	u8 nr_y_enable;
+	u8 nr_cb_enable;
+	u8 nr_cr_enable;
+
+	/*
+	 * enables noise estimation for reduction. When this is disabled,
+	 * noise estimation is carried out ouside VPU.
+	 */
+	u8 nr_noise_est_enable;
+	/*
+	 * It specifies Y/Cb/Cr noise standard deviation
+	 * if no use of noise estimation (nr_noise_est_enable=0)
+	 */
+	u8 nr_noise_sigma_y;
+	u8 nr_noise_sigma_cb;
+	u8 nr_noise_sigma_cr;
+	/* ENC_NR_WEIGHT*/
+	/*< A weight to Y noise level for intra picture (0 ~ 31).
+	 * nr_intra_weight_y/4 is multiplied to the noise
+	 * level that has been estimated.
+	 * This weight is put for intra frame to be filtered more strongly or
+	 * more weakly than just with the estimated noise level.
+	 */
+	u8 nr_intra_weight_y;
+	/**< A weight to Cb noise level for intra picture (0 ~ 31). */
+	u8 nr_intra_weight_cb;
+	/**< A weight to Cr noise level for intra picture (0 ~ 31). */
+	u8 nr_intra_weight_cr;
+	/*< A weight to Y noise level for inter picture (0 ~ 31).
+	 * nr_inter_weight_y/4 is multiplied to the noise
+	 * level that has been estimated.
+	 * This weight is put for inter frame to be filtered more strongly or
+	 * more weakly than just with the estimated noise level.
+	 */
+	u8 nr_inter_weight_y;
+	/**< A weight to Cb noise level for inter picture (0 ~ 31). */
+	u8 nr_inter_weight_cb;
+	/**< A weight to Cr noise level for inter picture (0 ~ 31). */
+	u8 nr_inter_weight_cr;
+	/*
+	 * a minimum QP for intra picture (0 ~ 51).
+	 * It is only available when rc_enable is 1.
+	 */
+	u8 intra_min_qp;
+
+	/*
+	 * a maximum QP for intra picture (0 ~ 51).
+	 * It is only available when rc_enable is 1.
+	 */
+	u8 intra_max_qp;
+
+	u32 initial_delay;
+
+	u8 hrd_rbsp_in_vps;
+	u8 hrd_rbsp_in_vui;
+	u32 vui_rbsp;
+
+	u32 hrd_rbsp_data_size; /**< The size of the HRD rbsp data */
+	u32 hrd_rbsp_data_addr;  /**< The address of the HRD rbsp data */
+
+	u32 vui_rbsp_data_size;   /**< The size of the VUI rbsp data */
+	u32 vui_rbsp_data_addr;   /**< The address of the VUI rbsp data */
+
+	u8 use_long_term;
+	u8 use_cur_as_longterm_pic;
+	u8 use_longterm_ref;
+
+	struct h265e_custom_gop gop;
+	struct h265e_ctu ctu;
+	struct h265e_vui vui;
+	struct h265e_sei sei;
+
+	/*
+	 * define which type of parameters are changed,
+	 * only support common parameter chanegd now,
+	 * see H265eCommonCfgMask
+	 */
+	u32 cfg_option;
+
+	/*
+	 * define which parameters are changed,see H265E_SET_PARAM_OPTION
+	 */
+	u32 cfg_mask;
+};
+
+struct mpp_h265e_encode_info {
+	/*
+	 * the address of source(yuv) data for encoding
+	 */
+	u32 src_fd;
+
+	/*
+	 * the size of source(yuv) data for encoding
+	 */
+	u32 src_size;
+
+	/*
+	 * the address of bitstream buffer
+	 */
+	u32 bs_fd;
+
+	/*
+	 * the size of bitstream buffer
+	 */
+	u32 bs_size;
+	u32 roi_fd;
+	u32 ctu_qp_fd;
+	u32 stream_end;
+
+	/*
+	 * skip current frame
+	 */
+	u32 skip_pic;
+
+	/*
+	 * A flag to use a force picture quantization parameter
+	 */
+	u32 force_qp_enable;
+
+	/*
+	 *Force picture quantization parameter for I picture
+	 */
+	u32 force_qp_i;
+
+	/*
+	 * Force picture quantization parameter for P picture
+	 */
+	u32 force_qp_p;
+
+	/*
+	 * A flag to use a force picture type
+	 */
+	u32 force_frame_type_enable;
+
+	/*
+	 * A force picture type (I, P, B, IDR, CRA)
+	 */
+	u32 force_frame_type;
+};
+
+enum INTERRUPT_BIT {
+	INT_BIT_INIT            = 0,
+	INT_BIT_SEQ_INIT        = 1,
+	INT_BIT_SEQ_END         = 2,
+	INT_BIT_PIC_RUN         = 3,
+	INT_BIT_FRAMEBUF_SET    = 4,
+	INT_BIT_ENC_HEADER      = 5,
+	INT_BIT_DEC_PARA_SET    = 7,
+	INT_BIT_DEC_BUF_FLUSH   = 8,
+	INT_BIT_USERDATA        = 9,
+	INT_BIT_DEC_FIELD       = 10,
+	INT_BIT_DEC_MB_ROWS     = 13,
+	INT_BIT_BIT_BUF_EMPTY   = 14,
+	INT_BIT_BIT_BUF_FULL    = 15
+};
+
+enum H265E_INTERRUPT_BIT {
+	INT_H265E_INIT            = 0,
+	INT_H265E_DEC_PIC_HDR     = 1,
+	INT_H265E_FINI_SEQ        = 2,
+	INT_H265E_ENC_PIC         = 3,
+	INT_H265E_SET_FRAMEBUF    = 4,
+	INT_H265E_FLUSH_DECODER   = 5,
+	INT_H265E_GET_FW_VERSION  = 8,
+	INT_H265E_QUERY_DECODER   = 9,
+	INT_H265E_SLEEP_VPU       = 10,
+	INT_H265E_WAKEUP_VPU      = 11,
+	INT_H265E_CHANGE_INST     = 12,
+	INT_H265E_CREATE_INSTANCE = 14,
+	INT_H265E_BIT_BUF_EMPTY   = 15,
+	INT_H265E_BIT_BUF_FULL    = 15,   /* Encoder */
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_h265e.h b/drivers/video/rockchip/vpu/mpp_dev_h265e.h
--- a/drivers/video/rockchip/vpu/mpp_dev_h265e.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_h265e.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: hehua,hh@rock-chips.com
+ * lixinhuang, buluess.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __ROCKCHIP_MPP_DEV_H265E_H
+#define __ROCKCHIP_MPP_DEV_H265E_H
+
+#include "mpp_dev_h265e_define.h"
+#include "mpp_service.h"
+#include <linux/ioctl.h>
+#include <linux/wakelock.h>
+
+#define MPP_DEV_H265E_SET_COLOR_PALETTE	\
+		_IOW(MPP_IOC_MAGIC, MPP_IOC_CUSTOM_BASE + 1, u32)
+
+#define MPP_DEV_H265E_SET_PARAMETER	\
+		_IOW(MPP_IOC_MAGIC, \
+		MPP_IOC_CUSTOM_BASE + 6, struct mpp_h265e_cfg)
+
+#define MPP_DEV_H265E_GET_HEAD_PARAMETER	\
+		_IOW(MPP_IOC_MAGIC, \
+		MPP_IOC_CUSTOM_BASE + 7, struct hal_h265e_header)
+
+#define H265E_INSTANCE_NUM 4
+
+enum H265E_MODE {
+	H265E_MODE_NONE,
+	H265E_MODE_ONEFRAME,
+	H265E_MODE_LINKTABLE_FIX,
+	H265E_MODE_LINKTABLE_UPDATE,
+	H265E_MODE_NUM
+};
+
+struct regmap;
+
+struct h265e_result {
+	u32 bs_size;
+	u32 enc_pic_cnt;
+	u32 pic_type;
+	u32 num_of_slice;
+	u32 pick_skipped;
+	u32 num_intra;
+	u32 num_merge;
+	u32 num_skip_block;
+	u32 avg_ctu_qp;
+	int recon_frame_index;
+	u32 gop_idx;
+	u32 poc;
+	u32 src_idx;
+	u32 fail_reason;
+};
+
+struct mpp_h265e_buffer {
+	unsigned long dma_addr;
+	u32 size;
+	int hdl;
+};
+
+struct mpp_h265e_frame_buffer {
+	struct mpp_h265e_buffer buffer;
+	u32 y;
+	u32 cb;
+	u32 cr;
+};
+
+struct h265e_ctx {
+	struct mpp_ctx ictx;
+	enum H265E_MODE mode;
+	struct mpp_h265e_buffer bs;
+	char __iomem *bs_data;/*for debug read data*/
+	struct mpp_h265e_buffer src;
+	struct mpp_h265e_buffer roi;
+	struct mpp_h265e_buffer ctu;
+
+	struct mpp_h265e_encode_info cfg;
+
+	/* store status read from hw, oneframe mode used only */
+	struct h265e_result result;
+};
+
+enum H265E_INSTANCE_STATUS {
+	H265E_INSTANCE_STATUS_ERROR,
+	H265E_INSTANCE_STATUS_OPENED,
+	H265E_INSTANCE_STATUS_SET_PARAMETER,
+	H265E_INSTANCE_STATUS_ENCODE,
+	H265E_INSTANCE_STATUS_CLOSE
+};
+
+struct rockchip_h265e_instance {
+	int index;
+	atomic_t is_used;
+	struct mpp_h265e_buffer work;
+	struct mpp_h265e_buffer temp;
+	struct mpp_h265e_buffer mv;
+	struct mpp_h265e_buffer fbc_luma;
+	struct mpp_h265e_buffer fbc_chroma;
+	struct mpp_h265e_buffer sub_sample;
+	/*
+	 * for recon frames
+	 */
+	struct mpp_h265e_frame_buffer frame_buffer[16];
+
+	int min_frame_buffer_count;
+	int min_src_frame_count;
+	int src_idx;
+	int status;
+	struct mpp_h265e_cfg cfg;
+	struct mpp_session *session;
+};
+
+struct rockchip_h265e_dev {
+	struct rockchip_mpp_dev dev;
+	struct rockchip_h265e_instance instance[H265E_INSTANCE_NUM];
+	struct mpp_h265e_buffer temp;
+
+	u32 lkt_index;
+	u32 irq_status;
+	atomic_t is_init;
+	atomic_t load_firmware;
+
+	struct delayed_work work_list;
+	struct mutex lock;
+
+	char __iomem *firmware_cpu_addr;
+	struct mpp_h265e_buffer firmware;
+
+	struct clk *aclk;
+	struct clk *aclk_axi2sram;
+	struct clk *pclk;
+	struct clk *core;
+	struct clk *dsp;
+	void __iomem *grf_base;
+	u32 mode_bit;
+	u32 mode_ctrl;
+	struct regmap *grf;
+};
+
+struct h265e_session {
+	struct mpp_session isession;
+	int instance_index;
+};
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h b/drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h
--- a/drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: hehua,hh@rock-chips.com
+ * lixinhuang, buluess.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _MPP_DEV_H265E_REGISTER_H_
+#define _MPP_DEV_H265E_REGISTER_H_
+
+#define H265E_PO_CONF                        0x0000
+#define H265E_VCPU_CUR_PC                    0x0004
+#define H265E_VPU_PDBG_CTRL                  0x0010
+#define H265E_VPU_PDBG_IDX_REG               0x0014
+#define H265E_VPU_PDBG_WDATA_REG             0x0018
+#define H265E_VPU_PDBG_RDATA_REG             0x001C
+#define H265E_VPU_FIO_CTRL_ADDR              0x0020
+#define H265E_VPU_FIO_DATA                   0x0024
+#define H265E_VPU_VINT_REASON_USR            0x0030
+#define H265E_VPU_VINT_REASON_CLR            0x0034
+#define H265E_VPU_HOST_INT_REQ               0x0038
+#define H265E_VPU_VINT_CLEAR                 0x003C
+#define H265E_VPU_HINT_CLEAR                 0x0040
+#define H265E_VPU_VPU_INT_STS                0x0044
+#define H265E_VPU_VINT_ENABLE                0x0048
+
+#define H265E_CMD_REG_END                    0x0200
+
+#define H265E_VPU_VINT_REASON                0x004c
+#define H265E_VPU_RESET_REQ                  0x0050
+#define H265E_VPU_RESET_STATUS               0x0070
+#define H265E_VPU_REMAP_CTRL                 0x0060
+#define H265E_VPU_REMAP_VADDR                0x0064
+#define H265E_VPU_REMAP_PADDR                0x0068
+#define H265E_VPU_REMAP_CORE_START           0x006C
+#define H265E_VPU_BUSY_STATUS                0x0070
+#define H265E_COMMAND                        0x0100
+#define H265E_CORE_INDEX                     0x0104
+#define H265E_INST_INDEX                     0x0108
+#define H265E_ENC_SET_PARAM_OPTION           0x010C
+#define H265E_RET_FW_VERSION                 0x0118
+#define H265E_ADDR_CODE_BASE                 0x0118
+#define H265E_CODE_SIZE			     0x011C
+#define H265E_CODE_PARAM                     0x0120
+#define H265E_HW_OPTION                      0x0124
+
+#define H265E_RET_SUCCESS                    0x0110
+#define H265E_VPU_HOST_INT_REQ               0x0038
+#define H265E_SFB_OPTION                     0x010C
+#define H265E_RET_FAIL_REASON                0x0114
+#define H265E_BS_START_ADDR                  0x0120
+#define H265E_COMMON_PIC_INFO                0x0120
+#define H265E_BS_SIZE                        0x0124
+#define H265E_PIC_SIZE                       0x0124
+#define H265E_BS_PARAM                       0x0128
+#define H265E_SET_FB_NUM                     0x0128
+#define H265E_BS_OPTION                      0x012C
+#define H265E_BS_RD_PTR                      0x0130
+#define H265E_BS_WR_PTR                      0x0134
+#define H265E_ADDR_WORK_BASE                 0x0138
+#define H265E_WORK_SIZE                      0x013c
+#define H265E_WORK_PARAM                     0x0140
+#define H265E_ADDR_TEMP_BASE                 0x0144
+#define H265E_TEMP_SIZE                      0x0148
+#define H265E_TEMP_PARAM                     0x014C
+#define H265E_FBC_STRIDE                     0x0154
+#define H265E_ENC_SET_PARAM_ENABLE           0x015C
+#define H265E_ENC_SEQ_SRC_SIZE               0x0160
+#define H265E_ADDR_LUMA_BASE0                0x0160
+#define H265E_ADDR_CB_BASE0                  0x0164
+#define H265E_ADDR_CR_BASE0                  0x0168
+#define H265E_ADDR_FBC_Y_OFFSET0             0x0168
+#define H265E_ADDR_FBC_C_OFFSET0             0x016C
+
+#define H265E_ENC_SEQ_PARAM                  0x016C
+#define H265E_ENC_SEQ_GOP_PARAM              0x0170
+#define H265E_ENC_SRC_PIC_IDX                0x0170
+#define H265E_ENC_SEQ_INTRA_PARAM            0x0174
+#define H265E_ENC_SEQ_CONF_WIN_TOP_BOT       0x0178
+#define H265E_ENC_SEQ_CONF_WIN_LEFT_RIGHT    0x017C
+#define H265E_ENC_SEQ_FRAME_RATE             0x0180
+#define H265E_ENC_SEQ_INDEPENDENT_SLICE      0x0184
+#define H265E_ENC_SEQ_DEPENDENT_SLICE        0x0188
+
+#define H265E_ENC_SEQ_INTRA_REFRESH          0x018C
+#define H265E_ENC_PARAM                      0x0190
+#define H265E_ENC_RC_INTRA_MIN_MAX_QP        0x0194
+#define H265E_ENC_RC_PARAM                   0x0198
+#define H265E_ENC_RC_MIN_MAX_QP              0x019C
+#define H265E_ENC_RC_BIT_RATIO_LAYER_0_3     0x01A0
+#define H265E_ENC_RC_BIT_RATIO_LAYER_4_7     0x01A4
+#define H265E_ENC_NR_PARAM                   0x01A8
+#define H265E_ENC_NR_WEIGHT                  0x01AC
+#define H265E_ENC_NUM_UNITS_IN_TICK          0x01B0
+#define H265E_ENC_TIME_SCALE                 0x01B4
+#define H265E_ENC_NUM_TICKS_POC_DIFF_ONE     0x01B8
+#define H265E_ENC_RC_TRANS_RATE              0x01BC
+#define H265E_ENC_RC_TARGET_RATE             0x01C0
+#define H265E_ENC_ROT_PARAM                  0x01C4
+#define H265E_ENC_ROT_RESERVED               0x01C8
+#define H265E_RET_ENC_MIN_FB_NUM             0x01CC
+#define H265E_RET_ENC_NAL_INFO_TO_BE_ENCODED 0x01D0
+#define H265E_RET_ENC_MIN_SRC_BUF_NUM        0x01D8
+
+#define H265E_ADDR_MV_COL0                   0x01E0
+#define H265E_ADDR_MV_COL1                   0x01E4
+#define H265E_ADDR_MV_COL2                   0x01E8
+#define H265E_ADDR_MV_COL3                   0x01EC
+#define H265E_ADDR_MV_COL4                   0x01F0
+#define H265E_ADDR_MV_COL5                   0x01F4
+#define H265E_ADDR_MV_COL6                   0x01F8
+#define H265E_ADDR_MV_COL7                   0x01FC
+
+#define H265E_ADDR_SEC_AXI_BASE              0x150
+#define H265E_SEC_AXI_SIZE                   0x154
+#define H265E_USE_SEC_AXI                    0x158
+
+/************************************************************************/
+/*H265 ENCODER - SET_PARAM + CUSTOM_GOP                                 */
+/************************************************************************/
+#define H265E_ENC_SET_CUSTOM_GOP_ENABLE      0x015C
+#define H265E_ENC_CUSTOM_GOP_PARAM           0x0160
+#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_0     0x0164
+#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_1     0x0168
+#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_2     0x016C
+#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_3     0x0170
+#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_4     0x0174
+#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_5     0x0178
+#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_6     0x017C
+#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_7     0x0180
+#define H265E_ENC_CUSTOM_GOP_RESERVED        0x0184
+#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_0    0x0188
+#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_1    0x018C
+#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_2    0x0190
+#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_3    0x0194
+#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_4    0x0198
+#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_5    0x019C
+#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_6    0x01A0
+#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_7    0x01A4
+
+/************************************************************************/
+/* H265 ENCODER - SET_PARAM + VUI                                       */
+/************************************************************************/
+#define H265E_ENC_VUI_PARAM_FLAGS            0x015C
+#define H265E_ENC_VUI_ASPECT_RATIO_IDC       0x0160
+#define H265E_ENC_VUI_SAR_SIZE               0x0164
+#define H265E_ENC_VUI_OVERSCAN_APPROPRIATE   0x0168
+#define H265E_ENC_VUI_VIDEO_SIGNAL           0x016C
+#define H265E_ENC_VUI_CHROMA_SAMPLE_LOC      0x0170
+#define H265E_ENC_VUI_DISP_WIN_LEFT_RIGHT    0x0174
+#define H265E_ENC_VUI_DISP_WIN_TOP_BOT       0x0178
+
+#define H265E_ENC_VUI_HRD_RBSP_PARAM_FLAG    0x017C
+#define H265E_ENC_VUI_RBSP_ADDR              0x0180
+#define H265E_ENC_VUI_RBSP_SIZE              0x0184
+#define H265E_ENC_HRD_RBSP_ADDR              0x0188
+#define H265E_ENC_HRD_RBSP_SIZE              0x018C
+
+/************************************************************************/
+/* H265 ENCODER - SET_FRAMEBUF                                          */
+/************************************************************************/
+#define H265E_FBC_STRIDE_Y                   0x150
+#define H265E_FBC_STRIDE_C                   0x154
+/* 1/4 sub-sampled buffer (for S2 ME)
+ *      SUB_SAMPLED_ONE_FB_SIZE = ALIGN16(width/4) * ALIGN8(height/4)
+ *      total size for sub-sampled buffer = SUB_SAMPLED_ONE_FB_SIZE * SET_FB_NUM
+ */
+#define H265E_ADDR_SUB_SAMPLED_FB_BASE       0x0158
+#define H265E_SUB_SAMPLED_ONE_FB_SIZE        0x015C
+
+/************************************************************************/
+/* ENCODER - ENC_PIC                                                    */
+/************************************************************************/
+#define H265E_CMD_ENC_ADDR_REPORT_BASE       0x015C
+#define H265E_CMD_ENC_REPORT_SIZE            0x0160
+#define H265E_CMD_ENC_REPORT_PARAM           0x0164
+#define H265E_CMD_ENC_CODE_OPTION            0x0168
+#define H265E_CMD_ENC_PIC_PARAM              0x016C
+#define H265E_CMD_ENC_SRC_PIC_IDX            0x0170
+#define H265E_CMD_ENC_SRC_ADDR_Y             0x0174
+#define H265E_CMD_ENC_SRC_ADDR_U             0x0178
+#define H265E_CMD_ENC_SRC_ADDR_V             0x017C
+#define H265E_CMD_ENC_SRC_STRIDE             0x0180
+#define H265E_CMD_ENC_SRC_FORMAT             0x0184
+#define H265E_CMD_ENC_PREFIX_SEI_NAL_ADDR    0x0188
+#define H265E_CMD_ENC_PREFIX_SEI_INFO        0x018C
+#define H265E_CMD_ENC_SUFFIX_SEI_NAL_ADDR    0x0190
+#define H265E_CMD_ENC_SUFFIX_SEI_INFO        0x0194
+#define H265E_CMD_ENC_LONGTERM_PIC           0x0198
+#define H265E_CMD_ENC_SUB_FRAME_SYNC_CONFIG  0x019C
+#define H265E_CMD_ENC_CTU_OPT_PARAM          0x01A0
+#define H265E_CMD_ENC_ROI_ADDR_CTU_MAP       0x01A4
+#define H265E_CMD_ENC_CTU_QP_MAP_ADDR        0x01AC
+#define H265E_CMD_ENC_SRC_TIMESTAMP_LOW      0x01B0
+#define H265E_CMD_ENC_SRC_TIMESTAMP_HIGH     0x01B4
+
+#define H265E_CMD_ENC_FC_PARAM               0x01E8
+#define H265E_CMD_ENC_FC_TABLE_ADDR_Y        0x01EC
+#define H265E_CMD_ENC_FC_TABLE_ADDR_C        0x01F0
+
+#define H265E_RET_ENC_PIC_IDX                0x01A8
+#define H265E_RET_ENC_PIC_SLICE_NUM          0x01AC
+#define H265E_RET_ENC_PIC_SKIP               0x01B0
+#define H265E_RET_ENC_PIC_NUM_INTRA          0x01B4
+#define H265E_RET_ENC_PIC_NUM_MERGE          0x01B8
+#define H265E_RET_ENC_PIC_FLAG               0x01BC
+#define H265E_RET_ENC_PIC_NUM_SKIP           0x01C0
+#define H265E_RET_ENC_PIC_AVG_CU_QP          0x01C4
+#define H265E_RET_ENC_PIC_BYTE               0x01C8
+#define H265E_RET_ENC_GOP_PIC_IDX            0x01CC
+#define H265E_RET_ENC_PIC_POC                0x01D0
+#define H265E_RET_ENC_USED_SRC_IDX           0x01D8
+#define H265E_RET_ENC_PIC_NUM                0x01DC
+#define H265E_RET_ENC_PIC_TYPE               0x01E0
+#define H265E_RET_ENC_VCL_NUT                0x01E4
+
+#define H265E_PERF_AXI_CTRL	             0x0240
+#define H265E_PERF_LATENCY_CTRL0             0x0264
+#define H265E_PERF_LATENCY_CTRL1             0x0268
+#define H265E_PERF_RD_MAX_LATENCY_NUM0       0x026C
+#define H265E_PERF_RD_LATENCY_SAMP_NUM       0x0270
+#define H265E_PERF_RD_LATENCY_ACC_SUM        0x0274
+#define H265E_PERF_RD_AXI_TOTAL_BYTE         0x0278
+#define H265E_PERF_WR_AXI_TOTAL_BYTE         0x027C
+#define H265E_PERF_WORKING_CNT		     0x0280
+#endif
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_rkvenc.c b/drivers/video/rockchip/vpu/mpp_dev_rkvenc.c
--- a/drivers/video/rockchip/vpu/mpp_dev_rkvenc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_rkvenc.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,813 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/compiler.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/reset.h>
+
+#include "vpu_iommu_ops.h"
+#include "mpp_service.h"
+#include "mpp_dev_common.h"
+#include "mpp_dev_rkvenc.h"
+
+#define MPP_ALIGN_SIZE	0x1000
+
+#define LINK_TABLE_START	12
+#define LINK_TABLE_LEN		128
+
+#define	RKVENC_ENC_START		0x004
+#define		RKVENC_LKT_NUM(x)			(((x) & 0xff) << 0)
+#define		RKVENC_CMD(x)				(((x) & 0x3) << 8)
+#define		RKVENC_CLK_GATE_EN			BIT(16)
+#define	RKVENC_SAFE_CLR			0x008
+#define	RKVENC_LKT_ADDR			0x00c
+#define	RKVENC_INT_EN			0x010
+#define		RKVENC_INT_EN_SAFE_CLEAR		BIT(2)
+#define		RKVENC_INT_EN_TIMEOUT			BIT(8)
+#define	RKVENC_INT_MSK			0x014
+#define		RKVENC_INT_MSK_OVERFLOW			BIT(4)
+#define		RKVENC_INT_MSK_W_FIFO_FULL		BIT(5)
+#define		RKVENC_INT_MSK_W_CHN_ERROR		BIT(6)
+#define		RKVENC_INT_MSK_R_CHN_ERROR		BIT(7)
+#define		RKVENC_INT_MSK_TIMEOUT			BIT(8)
+#define	RKVENC_INT_CLR			0x018
+#define	RKVENC_INT_STATUS		0x01c
+#define		RKVENC_ONE_FRAME_FINISH			BIT(0)
+#define		RKVENC_LINK_TABLE_FINISH		BIT(1)
+#define		RKVENC_SAFE_CLEAR_FINISH		BIT(2)
+#define		RKVENC_ONE_SLICE_FINISH			BIT(3)
+#define		RKVENC_BIT_STREAM_OVERFLOW		BIT(4)
+#define		RKVENC_AXI_WRITE_FIFO_FULL		BIT(5)
+#define		RKVENC_AXI_WRITE_CHANNEL_ERROR		BIT(6)
+#define		RKVENC_AXI_READ_CHANNEL_ERROR		BIT(7)
+#define		RKVENC_TIMEOUT_ERROR			BIT(8)
+#define RKVENC_INT_ERROR_BITS		((RKVENC_BIT_STREAM_OVERFLOW) |	   \
+					 (RKVENC_AXI_WRITE_FIFO_FULL) |	   \
+					 (RKVENC_AXI_WRITE_CHANNEL_ERROR) |\
+					 (RKVENC_AXI_READ_CHANNEL_ERROR) | \
+					 (RKVENC_TIMEOUT_ERROR))
+#define	RKVENC_ENC_PIC			0x034
+#define		RKVENC_ENC_PIC_NODE_INT_EN		BIT(31)
+#define	RKVENC_ENC_WDG			0x038
+#define		RKVENC_PPLN_ENC_LMT(x)			(((x) & 0xff) << 0)
+#define	RKVENC_OSD_CFG			0x1c0
+#define		RKVENC_OSD_PLT_TYPE			BIT(17)
+#define		RKVENC_OSD_CLK_SEL_BIT			BIT(16)
+#define	RKVENC_STATUS(i)		(0x210 + (4 * (i)))
+#define	RKVENC_BSL_STATUS		0x210
+#define		RKVENC_BITSTREAM_LENGTH(x)		((x) & 0x7FFFFFF)
+#define	RKVENC_ENC_STATUS		0x220
+#define		RKVENC_ENC_STATUS_ENC(x)		(((x) >> 0) & 0x3)
+#define	RKVENC_LKT_STATUS		0x224
+#define		RKVENC_LKT_STATUS_FNUM_ENC(x)		(((x) >> 0) & 0xff)
+#define		RKVENC_LKT_STATUS_FNUM_CFG(x)		(((x) >> 8) & 0xff)
+#define		RKVENC_LKT_STATUS_FNUM_INT(x)		(((x) >> 16) & 0xff)
+#define	RKVENC_OSD_PLT(i)		(0x400 + (4 * (i)))
+
+#define to_rkvenc_ctx(ctx)		\
+		container_of(ctx, struct rkvenc_ctx, ictx)
+#define to_rkvenc_session(session)	\
+		container_of(session, struct rkvenc_session, isession)
+#define to_rkvenc_dev(dev)		\
+		container_of(dev, struct rockchip_rkvenc_dev, idev)
+
+/*
+ * file handle translate information
+ */
+static const char trans_tbl_rkvenc[] = {
+	70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
+	124, 125, 126, 127, 128, 129, 130, 131
+};
+
+static struct mpp_trans_info trans_rkvenc[1] = {
+	[0] = {
+		.count = sizeof(trans_tbl_rkvenc),
+		.table = trans_tbl_rkvenc,
+	},
+};
+
+static struct mpp_dev_rkvenc_reg mpp_rkvenc_dummy_reg = {
+	.enc_rsl = 0x00070007,          /* 64x64 */
+	.enc_pic = 0x00001714,          /* h264, qp 30 */
+	.enc_wdg = 0x00000002,
+	.dtrns_map = 0x00007000,
+	.dtrns_cfg = 0x0000007f,
+	.src_fmt = 0x00000018,          /* nv12 */
+	.src_strd = 0x003f003f,
+	.sli_spl = 0x00000004,
+	.me_rnge = 0x00002f7b,
+	.me_cnst = 0x000e0505,
+	.me_ram = 0x000e79ab,
+	.rc_qp = 0x07340000,
+	.rdo_cfg = 0x00000002,
+	.synt_nal = 0x00000017,
+	.synt_sps = 0x0000019c,
+	.synt_pps = 0x01000d03,
+	.synt_sli0 = 0x00000002,
+};
+
+static int rockchip_mpp_rkvenc_reset(struct rockchip_mpp_dev *mpp);
+
+/*
+ * In order to workaround hw bug which make the first frame run failure with
+ * timeout interrupt occur, we make a dummy 64x64 encoding on power on here to
+ * cover the hw bug.
+ */
+static void rockchip_mpp_war_init(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+	size_t img_width = 64;
+	size_t img_height = 64;
+	size_t img_y_size = img_width * img_height;
+	size_t img_uv_size = img_y_size / 2;
+	size_t img_u_size = img_uv_size / 2;
+	size_t img_size = img_y_size + img_uv_size;
+
+	enc->war_reg = &mpp_rkvenc_dummy_reg;
+
+	/* 4k align required */
+	enc->war_reg->adr_rfpw = enc->war_dma_addr;
+	enc->war_reg->adr_srcy = enc->war_reg->adr_rfpw + img_size;
+	enc->war_reg->adr_srcu = enc->war_reg->adr_srcy + img_y_size;
+	enc->war_reg->adr_srcv = enc->war_reg->adr_srcu + img_u_size;
+	enc->war_reg->adr_bsbb = enc->war_reg->adr_srcv + img_u_size;
+	enc->war_reg->adr_bsbt = enc->war_reg->adr_bsbb + img_size;
+	enc->war_reg->adr_bsbr = enc->war_reg->adr_bsbb;
+	enc->war_reg->adr_bsbw = enc->war_reg->adr_bsbb;
+
+	/* 1k align required */
+	enc->war_reg->adr_dspw = enc->war_dma_addr + 0x4000;
+	enc->war_reg->adr_dspr = enc->war_reg->adr_dspw + 0x400;
+
+	enc->dummy_ctx = kzalloc(sizeof(*enc->dummy_ctx), GFP_KERNEL);
+	if (!enc->dummy_ctx)
+		return;
+
+	enc->dummy_ctx->ictx.mpp = mpp;
+	enc->dummy_ctx->ictx.session = NULL;
+	enc->dummy_ctx->mode = RKVENC_MODE_ONEFRAME;
+	enc->dummy_ctx->cfg.mode = RKVENC_MODE_ONEFRAME;
+	atomic_set(&enc->dummy_ctx_in_used, 0);
+	memcpy(enc->dummy_ctx->cfg.elem[0].reg, enc->war_reg,
+	       sizeof(*enc->war_reg));
+	enc->dummy_ctx->cfg.elem[0].reg_num = sizeof(*enc->war_reg) / 4;
+}
+
+static void rockchip_mpp_rkvenc_cfg_palette(struct rockchip_mpp_dev *mpp,
+					    struct mpp_session *isession)
+{
+	struct rkvenc_session *session;
+	int i;
+	u32 reg;
+
+	mpp_debug_enter();
+
+	if (!isession) {
+		mpp_debug(DEBUG_TASK_INFO, "fake ctx, do not cfg palette\n");
+		return;
+	}
+	session = to_rkvenc_session(isession);
+
+	if (!session->palette_valid)
+		return;
+
+	reg = mpp_read(mpp, RKVENC_OSD_CFG);
+	mpp_write(mpp, reg & (~RKVENC_OSD_CLK_SEL_BIT), RKVENC_OSD_CFG);
+
+	for (i = 0; i < RKVENC_OSD_PLT_LEN; i++)
+		mpp_write(mpp, session->palette.plalette[i].elem,
+			  RKVENC_OSD_PLT(i));
+
+	mpp_write(mpp, reg | RKVENC_OSD_CLK_SEL_BIT, RKVENC_OSD_CFG);
+
+	mpp_debug_leave();
+}
+
+static struct mpp_ctx *rockchip_mpp_rkvenc_init(struct rockchip_mpp_dev *mpp,
+						struct mpp_session *session,
+						void __user *src, u32 size)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+	struct rkvenc_ctx *ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	int i;
+
+	mpp_debug_enter();
+
+	if (!ctx)
+		return NULL;
+
+	/* HW defeat workaround start */
+	if (!mpp_dev_is_power_on(mpp) && enc->dummy_ctx &&
+	    atomic_inc_return(&enc->dummy_ctx_in_used) == 1) {
+		mpp_debug(DEBUG_RESET, "add a dummy ctx\n");
+		mpp_srv_pending_locked(mpp->srv, &enc->dummy_ctx->ictx);
+	}
+
+	mpp_dev_common_ctx_init(mpp, &ctx->ictx);
+
+	ctx->ictx.session = session;
+	ctx->mode = RKVENC_MODE_LINKTABLE_FIX;
+
+	size = size > sizeof(ctx->cfg) ? sizeof(ctx->cfg) : size;
+
+	if (copy_from_user(&ctx->cfg, src, size)) {
+		mpp_err("error: copy_from_user failed in reg_init\n");
+		kfree(ctx);
+		return NULL;
+	}
+
+	ctx->mode = ctx->cfg.mode;
+	if (ctx->mode >= RKVENC_MODE_NUM || ctx->mode == RKVENC_MODE_NONE) {
+		mpp_err("Invalid rkvenc running mode %d\n", (int)ctx->mode);
+		kfree(ctx);
+		return NULL;
+	} else if (ctx->mode == RKVENC_MODE_ONEFRAME && ctx->cfg.tbl_num > 1) {
+		mpp_err("Configuration miss match, ignore redundant cfg\n");
+		ctx->cfg.tbl_num = 1;
+	}
+
+	mpp_debug(DEBUG_SET_REG, "tbl num %u, mode %u\n",
+		  ctx->cfg.tbl_num, ctx->cfg.mode);
+
+	for (i = 0; i < ctx->cfg.tbl_num; i++) {
+		if (mpp_reg_address_translate(mpp, ctx->cfg.elem[i].reg,
+					      &ctx->ictx, 0) < 0) {
+			mpp_err("error: translate reg address failed.\n");
+
+			if (unlikely(mpp_dev_debug & DEBUG_DUMP_ERR_REG))
+				mpp_dump_reg_mem(ctx->cfg.elem[i].reg,
+						 ctx->cfg.elem[i].reg_num);
+
+			mpp_dev_common_ctx_deinit(mpp, &ctx->ictx);
+			kfree(ctx);
+
+			return NULL;
+		}
+
+		mpp_debug(DEBUG_SET_REG, "extra info cnt %u, magic %08x",
+			  ctx->cfg.elem[i].ext_inf.cnt,
+			  ctx->cfg.elem[i].ext_inf.magic);
+
+		mpp_translate_extra_info(&ctx->ictx, &ctx->cfg.elem[i].ext_inf,
+					 ctx->cfg.elem[i].reg);
+	}
+
+	mpp_debug_leave();
+
+	return &ctx->ictx;
+}
+
+static int rockchip_mpp_rkvenc_reset_init(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+
+	mpp_debug(DEBUG_RESET, "reset init in:\n");
+	enc->rst_a = devm_reset_control_get(mpp->dev, "video_a");
+	enc->rst_h = devm_reset_control_get(mpp->dev, "video_h");
+	enc->rst_v = devm_reset_control_get(mpp->dev, "video_c");
+
+	if (IS_ERR_OR_NULL(enc->rst_a)) {
+		mpp_err("No aclk reset resource define\n");
+		enc->rst_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(enc->rst_h)) {
+		mpp_err("No hclk reset resource define\n");
+		enc->rst_h = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(enc->rst_v)) {
+		mpp_err("No core reset resource define\n");
+		enc->rst_v = NULL;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvenc_reset(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+	int cnt = 100;
+
+	if (enc->rst_a && enc->rst_h && enc->rst_v) {
+		mpp_debug(DEBUG_RESET, "reset in\n");
+		mpp_write(mpp, 0, RKVENC_INT_EN);
+		mpp_write(mpp, 1, RKVENC_SAFE_CLR);
+		while (cnt-- > 0) {
+			int status;
+
+			usleep_range(100, 200);
+			status = mpp_read(mpp, RKVENC_ENC_STATUS);
+			if (status & 4) {
+				mpp_debug(DEBUG_RESET, "st_enc %08x\n", status);
+				break;
+			}
+		}
+		reset_control_assert(enc->rst_v);
+		reset_control_assert(enc->rst_a);
+		reset_control_assert(enc->rst_h);
+
+		udelay(1);
+
+		reset_control_deassert(enc->rst_v);
+		reset_control_deassert(enc->rst_a);
+		reset_control_deassert(enc->rst_h);
+		mpp_debug(DEBUG_RESET, "reset out\n");
+	}
+	return 0;
+}
+
+static int rockchip_mpp_rkvenc_prepare(struct rockchip_mpp_dev *mpp)
+{
+	struct rkvenc_ctx *ctx_curr;
+	struct rkvenc_ctx *ctx_ready;
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+	u32 lkt_status;
+	u32 fnum_int;
+	u32 fnum_cfg;
+	u32 fnum_enc;
+	u8 *cpu_addr;
+	int i;
+
+	u32 reg = 0;
+
+	mpp_debug_enter();
+
+	if (!mpp_srv_is_running(mpp->srv))
+		return 0;
+
+	/* if service running, determine link table mode */
+	ctx_curr = to_rkvenc_ctx(mpp_srv_get_current_ctx(mpp->srv));
+	ctx_ready = to_rkvenc_ctx(mpp_srv_get_pending_ctx(mpp->srv));
+
+	if (ctx_curr->mode != RKVENC_MODE_LINKTABLE_UPDATE ||
+	    ctx_ready->mode != ctx_curr->mode) {
+		mpp_debug(DEBUG_TASK_INFO,
+			  "link table condition not fulfill\n");
+		return -1;
+	}
+
+	lkt_status = mpp_read(mpp, RKVENC_LKT_STATUS);
+	fnum_int = RKVENC_LKT_STATUS_FNUM_INT(lkt_status);
+	fnum_cfg = RKVENC_LKT_STATUS_FNUM_CFG(lkt_status);
+	fnum_enc = RKVENC_LKT_STATUS_FNUM_ENC(lkt_status);
+	cpu_addr = (u8 *)enc->lkt_cpu_addr + fnum_cfg * LINK_TABLE_LEN * 4;
+
+	mpp_dev_power_on(mpp);
+
+	mpp_debug(DEBUG_GET_REG, "frame number int %u, cfg %u, enc %u\n",
+		  fnum_int, fnum_cfg, fnum_enc);
+
+	for (i = 0; i < ctx_ready->cfg.tbl_num; i++) {
+		u32 *src = ctx_ready->cfg.elem[i].reg;
+
+		memcpy(cpu_addr + i * LINK_TABLE_LEN * 4,
+		       &src[LINK_TABLE_START], LINK_TABLE_LEN * 4);
+	}
+
+	reg = RKVENC_CLK_GATE_EN |
+		RKVENC_CMD(ctx_curr->mode) |
+		RKVENC_LKT_NUM(ctx_ready->cfg.tbl_num);
+	mpp_write_relaxed(mpp, reg, RKVENC_ENC_START);
+
+	/* remove from pending queue */
+	mpp_dev_common_ctx_deinit(mpp, &ctx_ready->ictx);
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvenc_run(struct rockchip_mpp_dev *mpp)
+{
+	struct rkvenc_ctx *ctx =
+			to_rkvenc_ctx(mpp_srv_get_current_ctx(mpp->srv));
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+	u32 reg;
+	int i;
+
+	mpp_debug_enter();
+
+	switch (ctx->mode) {
+	case RKVENC_MODE_ONEFRAME:
+		{
+			u32 *src = ctx->cfg.elem[0].reg;
+
+			for (i = 2; i < (LINK_TABLE_START + LINK_TABLE_LEN); i++)
+				mpp_write_relaxed(mpp, src[i], i * 4);
+
+			rockchip_mpp_rkvenc_cfg_palette(mpp, ctx->ictx.session);
+
+			mpp_write_relaxed(mpp, 0x1ff, RKVENC_INT_EN);
+			reg = RKVENC_CLK_GATE_EN
+				| RKVENC_CMD(1);
+			mpp_write(mpp, reg, RKVENC_ENC_START);
+
+			break;
+		}
+	case RKVENC_MODE_LINKTABLE_FIX:
+	case RKVENC_MODE_LINKTABLE_UPDATE:
+		{
+			for (i = 0; i < ctx->cfg.tbl_num; i++) {
+				u32 *src = ctx->cfg.elem[i].reg;
+
+				memcpy(enc->lkt_cpu_addr +
+				       i * LINK_TABLE_LEN * 4,
+				       &src[LINK_TABLE_START],
+				       LINK_TABLE_LEN * 4);
+			}
+
+			rockchip_mpp_rkvenc_cfg_palette(mpp, ctx->ictx.session);
+
+			mpp_write_relaxed(mpp,
+					  enc->lkt_dma_addr,
+					  RKVENC_LKT_ADDR);
+			mpp_write_relaxed(mpp, 0xffffffff, RKVENC_INT_EN);
+
+			reg = RKVENC_LKT_NUM(ctx->cfg.tbl_num) |
+				RKVENC_CMD(RKVENC_MODE_LINKTABLE_FIX) |
+				RKVENC_CLK_GATE_EN;
+
+			mpp_write_relaxed(mpp, reg, RKVENC_ENC_START);
+
+			break;
+		}
+	default:
+		break;
+	}
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvenc_done(struct rockchip_mpp_dev *mpp)
+{
+	struct mpp_ctx *ictx = mpp_srv_get_current_ctx(mpp->srv);
+	struct rkvenc_ctx *ctx;
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+	struct rkvenc_result *result;
+	int i;
+
+	mpp_debug_enter();
+
+	if (IS_ERR_OR_NULL(ictx)) {
+		mpp_err("Invaidate context to save result\n");
+		return -1;
+	}
+
+	ctx = to_rkvenc_ctx(ictx);
+
+	if (enc->irq_status & RKVENC_INT_ERROR_BITS)
+		/*
+		 * according to war running, if the dummy encoding
+		 * running with timeout, we enable a safe clear process,
+		 * we reset the ip, and complete the war procedure.
+		 */
+		atomic_inc(&mpp->reset_request);
+
+	if (ctx == enc->dummy_ctx) {
+		mpp_debug(DEBUG_RESET, "war done\n");
+
+		/* for war do not trigger service done process */
+		list_del_init(&ictx->status_link);
+		atomic_set(&enc->dummy_ctx_in_used, 0);
+
+		/* dummy ctx, do not trigger service to wake up done process */
+		return -1;
+	}
+
+	result = &ctx->result;
+	switch (ctx->mode) {
+	case RKVENC_MODE_ONEFRAME:
+		result->tbl_num = 1;
+		result->elem[0].status = enc->irq_status;
+		for (i = 0; i < sizeof(result->elem[0].result) / 4; i++)
+			result->elem[0].result[i] =
+						    mpp_read(mpp,
+							     RKVENC_STATUS(i));
+		break;
+	case RKVENC_MODE_LINKTABLE_FIX:
+	case RKVENC_MODE_LINKTABLE_UPDATE:
+		{
+			u32 lkt_status = mpp_read(mpp, RKVENC_LKT_STATUS);
+			u32 fnum_int = RKVENC_LKT_STATUS_FNUM_INT(lkt_status);
+			u32 fnum_cfg = RKVENC_LKT_STATUS_FNUM_CFG(lkt_status);
+			u32 fnum_enc = RKVENC_LKT_STATUS_FNUM_ENC(lkt_status);
+
+			u32 *lkt_cpu_addr = (u32 *)enc->lkt_cpu_addr;
+
+			if (unlikely(mpp_dev_debug & DEBUG_DUMP_ERR_REG))
+				mpp_dump_reg_mem(lkt_cpu_addr, LINK_TABLE_LEN);
+
+			result->tbl_num = fnum_int;
+			for (i = 0; i < fnum_int; i++) {
+				result->elem[i].status = enc->irq_status;
+				memcpy(result->elem[i].result,
+				       &lkt_cpu_addr[i * LINK_TABLE_LEN + 120],
+				       sizeof(result->elem[i].result));
+				mpp_debug(DEBUG_GET_REG, "stream length %u\n",
+					  result->elem[i].result[0]);
+			}
+			mpp_debug(DEBUG_GET_REG, "frame number %u, %u, %u\n",
+				  fnum_int, fnum_cfg, fnum_enc);
+			break;
+		}
+	default:
+		break;
+	}
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvenc_irq(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+
+	enc->irq_status = mpp_read(mpp, RKVENC_INT_STATUS);
+
+	mpp_debug_enter();
+
+	if (enc->irq_status == 0)
+		return -1;
+
+	mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n", enc->irq_status);
+	mpp_write(mpp, 0xffffffff, RKVENC_INT_CLR);
+	if (enc->irq_status & RKVENC_INT_ERROR_BITS) {
+		mpp_err("error irq %08x\n", enc->irq_status);
+		/* time out error */
+		mpp_write(mpp, RKVENC_INT_ERROR_BITS, RKVENC_INT_MSK);
+	}
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvenc_result(struct rockchip_mpp_dev *mpp,
+				      struct mpp_ctx *ictx, u32 __user *dst)
+{
+	struct rkvenc_ctx *ctx = to_rkvenc_ctx(ictx);
+	struct rkvenc_result *result = &ctx->result;
+	unsigned long tbl_size = sizeof(result->tbl_num) +
+				 sizeof(result->elem[0]) * result->tbl_num;
+
+	switch (ctx->mode) {
+	case RKVENC_MODE_ONEFRAME:
+	case RKVENC_MODE_LINKTABLE_FIX:
+	case RKVENC_MODE_LINKTABLE_UPDATE:
+		{
+			if (copy_to_user(dst, &ctx->result, tbl_size)) {
+				mpp_err("copy result to user failed\n");
+				return -1;
+			}
+			break;
+		}
+	default:
+		mpp_err("invalid context mode %d\n", (int)ctx->mode);
+		return -1;
+	}
+
+	return 0;
+}
+
+static long rockchip_mpp_rkvenc_ioctl(struct mpp_session *isession,
+				      unsigned int cmd,
+				      unsigned long arg)
+{
+	struct rkvenc_session *session = to_rkvenc_session(isession);
+
+	mpp_debug_enter();
+
+	switch (cmd) {
+	case MPP_DEV_RKVENC_SET_COLOR_PALETTE:
+		if (copy_from_user(&session->palette, (void __user *)arg,
+				   sizeof(session->palette))) {
+			mpp_err("copy palette from user failed\n");
+			return -EINVAL;
+		}
+		session->palette_valid = true;
+
+		break;
+	default:
+		mpp_err("%s, unknown ioctl cmd %x\n",
+			dev_name(isession->mpp->dev), cmd);
+		break;
+	}
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static struct mpp_session *mpp_dev_rkvenc_open(struct rockchip_mpp_dev *mpp)
+{
+	struct rkvenc_session *session = kzalloc(sizeof(*session), GFP_KERNEL);
+
+	mpp_debug_enter();
+
+	if (!session)
+		return NULL;
+
+	session->palette_valid = false;
+
+	mpp_debug_leave();
+
+	return &session->isession;
+}
+
+static void mpp_dev_rkvenc_free(struct mpp_session *isession)
+{
+	struct rkvenc_session *session = to_rkvenc_session(isession);
+
+	kfree(session);
+}
+
+struct mpp_dev_ops rkvenc_ops = {
+	.init = rockchip_mpp_rkvenc_init,
+	.prepare = rockchip_mpp_rkvenc_prepare,
+	.run = rockchip_mpp_rkvenc_run,
+	.done = rockchip_mpp_rkvenc_done,
+	.irq = rockchip_mpp_rkvenc_irq,
+	.result = rockchip_mpp_rkvenc_result,
+	.ioctl = rockchip_mpp_rkvenc_ioctl,
+	.open = mpp_dev_rkvenc_open,
+	.free = mpp_dev_rkvenc_free,
+};
+
+static void rockchip_mpp_rkvenc_power_on(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+
+	if (enc->aclk)
+		clk_prepare_enable(enc->aclk);
+	if (enc->hclk)
+		clk_prepare_enable(enc->hclk);
+	if (enc->core)
+		clk_prepare_enable(enc->core);
+
+	/*
+	 * Because hw cannot reset status fully in all its modules, we make a
+	 * reset here to make sure the hw status fully reset.
+	 */
+	rockchip_mpp_rkvenc_reset(mpp);
+}
+
+static void rockchip_mpp_rkvenc_power_off(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+
+	if (enc->core)
+		clk_disable_unprepare(enc->core);
+	if (enc->hclk)
+		clk_disable_unprepare(enc->hclk);
+	if (enc->aclk)
+		clk_disable_unprepare(enc->aclk);
+}
+
+static int rockchip_mpp_rkvenc_probe(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+	struct mpp_session *session = list_first_entry(&mpp->srv->session,
+						       struct mpp_session,
+						       list_session);
+	int ret;
+	size_t tmp;
+
+	enc->idev.ops = &rkvenc_ops;
+
+	enc->lkt_hdl = vpu_iommu_alloc(mpp->iommu_info, session,
+				       LINK_TABLE_LEN * 4 * 256,
+				       MPP_ALIGN_SIZE);
+
+	if (enc->lkt_hdl < 0) {
+		dev_err(mpp->dev, "allocate link table buffer failure\n");
+		return -1;
+	}
+
+	ret = vpu_iommu_map_iommu(mpp->iommu_info, session,
+				  enc->lkt_hdl, &enc->lkt_dma_addr, &tmp);
+
+	if (ret < 0) {
+		dev_err(mpp->dev, "get link table dma_addr failed\n");
+		goto fail;
+	}
+
+	enc->lkt_cpu_addr = vpu_iommu_map_kernel(mpp->iommu_info,
+						 session, enc->lkt_hdl);
+
+	/*
+	 * buffer for workaround context running, include input picture, output
+	 * stream, reconstruction picture. we set the output stream buffer to 1
+	 * time picture size, so the total buffer size is 3 times picture size,
+	 * 64 * 64 * 3 / 2 * 3 = 4.5 * 4k.
+	 */
+	enc->war_hdl = vpu_iommu_alloc(mpp->iommu_info, session,
+				       MPP_ALIGN_SIZE * 5,
+				       MPP_ALIGN_SIZE);
+	if (enc->war_hdl < 0) {
+		dev_err(mpp->dev, "allocate workaround buffer failure\n");
+		goto fail;
+	}
+
+	ret = vpu_iommu_map_iommu(mpp->iommu_info, session,
+				  enc->war_hdl, &enc->war_dma_addr, &tmp);
+
+	if (ret < 0) {
+		dev_err(mpp->dev, "get war dma_addr failed\n");
+		goto fail;
+	}
+
+	rockchip_mpp_war_init(mpp);
+
+	enc->aclk = devm_clk_get(mpp->dev, "aclk_vcodec");
+	if (IS_ERR_OR_NULL(enc->aclk)) {
+		dev_err(mpp->dev, "failed on clk_get aclk\n");
+		goto fail;
+	}
+
+	enc->hclk = devm_clk_get(mpp->dev, "hclk_vcodec");
+	if (IS_ERR_OR_NULL(enc->hclk)) {
+		dev_err(mpp->dev, "failed on clk_get hclk\n");
+		goto fail;
+	}
+
+	enc->core = devm_clk_get(mpp->dev, "clk_core");
+	if (IS_ERR_OR_NULL(enc->core)) {
+		dev_err(mpp->dev, "failed on clk_get core\n");
+		goto fail;
+	}
+
+	rockchip_mpp_rkvenc_reset_init(mpp);
+
+	return 0;
+
+fail:
+	kfree(enc->dummy_ctx);
+
+	if (enc->war_hdl >= 0) {
+		vpu_iommu_unmap_iommu(mpp->iommu_info,
+				      session, enc->war_hdl);
+		vpu_iommu_free(mpp->iommu_info, session, enc->war_hdl);
+	}
+	if (enc->lkt_cpu_addr)
+		vpu_iommu_unmap_kernel(mpp->iommu_info, session, enc->lkt_hdl);
+	if (enc->lkt_hdl >= 0) {
+		vpu_iommu_unmap_iommu(mpp->iommu_info,
+				      session, enc->lkt_hdl);
+		vpu_iommu_free(mpp->iommu_info, session, enc->lkt_hdl);
+	}
+
+	return -1;
+}
+
+static void rockchip_mpp_rkvenc_remove(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
+	struct mpp_session *session = list_first_entry(&mpp->srv->session,
+						       struct mpp_session,
+						       list_session);
+
+	vpu_iommu_unmap_kernel(mpp->iommu_info, session, enc->lkt_hdl);
+	vpu_iommu_unmap_iommu(mpp->iommu_info,
+			      session, enc->lkt_hdl);
+	vpu_iommu_free(mpp->iommu_info, session, enc->lkt_hdl);
+
+	vpu_iommu_unmap_iommu(mpp->iommu_info,
+			      session, enc->war_hdl);
+	vpu_iommu_free(mpp->iommu_info, session, enc->war_hdl);
+
+	kfree(enc->dummy_ctx);
+}
+
+const struct rockchip_mpp_dev_variant rkvenc_variant = {
+	.data_len = sizeof(struct rockchip_rkvenc_dev),
+	.reg_len = 140,
+	.trans_info = trans_rkvenc,
+	.hw_probe = rockchip_mpp_rkvenc_probe,
+	.hw_remove = rockchip_mpp_rkvenc_remove,
+	.power_on = rockchip_mpp_rkvenc_power_on,
+	.power_off = rockchip_mpp_rkvenc_power_off,
+	.reset = rockchip_mpp_rkvenc_reset,
+};
+EXPORT_SYMBOL(rkvenc_variant);
+
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_rkvenc.h b/drivers/video/rockchip/vpu/mpp_dev_rkvenc.h
--- a/drivers/video/rockchip/vpu/mpp_dev_rkvenc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_rkvenc.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,177 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ROCKCHIP_MPP_DEV_RKVENC_H
+#define __ROCKCHIP_MPP_DEV_RKVENC_H
+
+union rkvenc_osd_palette_elem {
+	struct  {
+		u8 y;
+		u8 u;
+		u8 v;
+		u8 alpha;
+	};
+	u32 elem;
+};
+
+#define	RKVENC_OSD_PLT_LEN		256
+struct rkvenc_osd_palette {
+	union rkvenc_osd_palette_elem plalette[RKVENC_OSD_PLT_LEN];
+};
+
+#define MPP_DEV_RKVENC_SET_COLOR_PALETTE	\
+			_IOW(MPP_IOC_MAGIC, MPP_IOC_CUSTOM_BASE + 1,	\
+			struct rkvenc_osd_palette)
+
+struct rkvenc_config_elem {
+	u32 reg_num;
+	u32 reg[140];
+	struct extra_info_for_iommu ext_inf;
+};
+
+struct rkvenc_config {
+	u32 mode;
+	u32 tbl_num;
+	struct rkvenc_config_elem elem[10];
+};
+
+struct rkvenc_result_elem {
+	u32 status;
+	u32 result[11];
+};
+
+struct rkvenc_result {
+	u32 tbl_num;
+	struct rkvenc_result_elem elem[10];
+};
+
+struct rkvenc_ctx {
+	struct mpp_ctx ictx;
+	enum RKVENC_MODE mode;
+
+	struct rkvenc_config cfg;
+
+	/* store status read from hw, oneframe mode used only */
+	struct rkvenc_result result;
+};
+
+struct rkvenc_session {
+	struct mpp_session isession;
+
+	struct rkvenc_osd_palette palette;
+	bool palette_valid;
+};
+
+struct mpp_dev_rkvenc_reg {
+	u32 unused_00;
+	u32 enc_strt;
+	u32 enc_clr;
+	u32 lkt_addr;
+	u32 int_en;
+	u32 int_msk;
+	u32 int_clr;
+	u32 unused_20[4];
+	u32 int_stus;
+	/* 12 */
+	u32 enc_rsl;
+	u32 enc_pic;
+	u32 enc_wdg;
+	u32 dtrns_map;
+	u32 dtrns_cfg;
+	u32 src_fmt;
+	u32 src_udfy;
+	u32 src_udfu;
+	u32 src_udfv;
+	u32 src_udfo;
+	u32 src_proc;
+	u32 src_tthrd;
+	u32 src_stbl[5];
+	u32 h3d_tbl[40];
+	u32 src_strd;
+	u32 adr_srcy;
+	u32 adr_srcu;
+	u32 adr_srcv;
+	u32 adr_fltw;
+	u32 adr_fltr;
+	u32 adr_ctuc;
+	u32 adr_rfpw;
+	u32 adr_rfpr;
+	u32 adr_cmvw;
+	u32 adr_cmvr;
+	u32 adr_dspw;
+	u32 adr_dspr;
+	u32 adr_meiw;
+	u32 adr_bsbt;
+	u32 adr_bsbb;
+	u32 adr_bsbr;
+	u32 adr_bsbw;
+	u32 sli_spl;
+	u32 sli_spl_byte;
+	u32 me_rnge;
+	u32 me_cnst;
+	u32 me_ram;
+	u32 rc_cfg;
+	u32 rc_erp[5];
+	u32 rc_adj[2];
+	u32 rc_qp;
+	u32 rc_tgt;
+	u32 rdo_cfg;
+	u32 synt_nal;
+	u32 synt_sps;
+	u32 synt_pps;
+	u32 synt_sli0;
+	u32 synt_sli1;
+	u32 synt_sli2_rodr;
+	u32 synt_ref_mark0;
+	u32 synt_ref_mark1;
+	u32 osd_cfg;
+	u32 osd_inv;
+	u32 unused_1c8[2];
+	u32 osd_pos[8];
+	u32 osd_addr[8];
+	u32 unused_210[9];
+};
+
+struct rockchip_rkvenc_dev {
+	struct rockchip_mpp_dev idev;
+	unsigned long lkt_dma_addr;
+	int lkt_hdl;
+	void *lkt_cpu_addr;
+	u32 irq_status;
+	unsigned long war_dma_addr;
+	int war_hdl;
+	struct mpp_dev_rkvenc_reg *war_reg;
+	struct rkvenc_ctx *dummy_ctx;
+	atomic_t dummy_ctx_in_used;
+
+	struct clk *aclk;
+	struct clk *hclk;
+	struct clk *core;
+
+	struct reset_control *rst_a;
+	struct reset_control *rst_h;
+	struct reset_control *rst_v;
+};
+
+struct link_table_elem {
+	unsigned long lkt_dma_addr;
+	int lkt_hdl;
+	void *lkt_cpu_addr;
+	u32 lkt_index;
+	struct list_head list;
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_vepu.c b/drivers/video/rockchip/vpu/mpp_dev_vepu.c
--- a/drivers/video/rockchip/vpu/mpp_dev_vepu.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_vepu.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,368 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/mfd/syscon.h>
+#include <linux/types.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/rockchip/grf.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include "vpu_iommu_ops.h"
+#include "mpp_dev_common.h"
+#include "mpp_dev_vepu.h"
+#include "mpp_service.h"
+
+#define to_vepu_ctx(ctx)		\
+		container_of(ctx, struct vepu_ctx, ictx)
+#define to_vepu_dev(dev)		\
+		container_of(dev, struct rockchip_vepu_dev, idev)
+
+#define VEPU_REG_INTERRUPT		0x1b4
+#define VEPU_REG_ENC_START		0x19c
+#define		VEPU_ENC_GET_FORMAT(x)		(((x) >> 4) & 0x3)
+#define		VEPU_ENC_FMT_VP8E		1
+#define		VEPU_ENC_ENABLE			BIT(0)
+
+/*
+ * file handle translate information
+ */
+static const char trans_tbl_default[] = {
+	77, 78, 56, 57, 63, 64, 48, 49, 50, 81
+};
+
+static const char trans_tbl_vp8e[] = {
+	77, 78, 56, 57, 63, 64, 48, 49, 50, 76, 106, 108, 81, 80, 44, 45, 27
+};
+
+static struct mpp_trans_info trans_vepu[2] = {
+	[0] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[1] = {
+		.count = sizeof(trans_tbl_vp8e),
+		.table = trans_tbl_vp8e,
+	},
+};
+
+static struct mpp_ctx *rockchip_mpp_vepu_init(struct rockchip_mpp_dev *mpp,
+					      struct mpp_session *session,
+					      void __user *src, u32 size)
+{
+	struct vepu_ctx *ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	u32 reg_len;
+	u32 extinf_len;
+	u32 fmt = 0;
+	int trans_idx = 0;
+	u32 dwsize = size / sizeof(u32);
+
+	mpp_debug_enter();
+
+	if (!ctx)
+		return NULL;
+
+	mpp_dev_common_ctx_init(mpp, &ctx->ictx);
+
+	ctx->ictx.session = session;
+
+	reg_len = dwsize > ROCKCHIP_VEPU_REG_LEN ?
+		  ROCKCHIP_VEPU_REG_LEN : dwsize;
+	extinf_len = dwsize > reg_len ? (dwsize - reg_len) * 4 : 0;
+
+	if (copy_from_user(ctx->reg, src, reg_len * 4)) {
+		mpp_err("error: copy_from_user failed in reg_init\n");
+		kfree(ctx);
+		return NULL;
+	}
+
+	if (extinf_len > 0) {
+		u32 ext_cpy = min_t(size_t, extinf_len, sizeof(ctx->ext_inf));
+
+		if (copy_from_user(&ctx->ext_inf, (u8 *)src +
+				   reg_len * sizeof(u32),
+				   ext_cpy)) {
+			mpp_err("copy_from_user failed when extra info\n");
+			kfree(ctx);
+			return NULL;
+		}
+	}
+
+	fmt = VEPU_ENC_GET_FORMAT(ctx->reg[VEPU_REG_ENC_START / 4]);
+	if (fmt == VEPU_ENC_FMT_VP8E)
+		trans_idx = 1;
+
+	if (mpp_reg_address_translate(mpp, ctx->reg, &ctx->ictx,
+				      trans_idx) < 0) {
+		mpp_err("error: translate reg address failed.\n");
+
+		if (unlikely(mpp_dev_debug & DEBUG_DUMP_ERR_REG))
+			mpp_dump_reg_mem(ctx->reg, ROCKCHIP_VEPU_REG_LEN);
+
+		mpp_dev_common_ctx_deinit(mpp, &ctx->ictx);
+		kfree(ctx);
+
+		return NULL;
+	}
+
+	mpp_debug(DEBUG_SET_REG, "extra info cnt %u, magic %08x",
+		  ctx->ext_inf.cnt, ctx->ext_inf.magic);
+
+	mpp_translate_extra_info(&ctx->ictx, &ctx->ext_inf, ctx->reg);
+
+	mpp_debug_leave();
+
+	return &ctx->ictx;
+}
+
+static int rockchip_mpp_vepu_reset_init(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
+
+	mpp_debug(DEBUG_RESET, "reset init in:\n");
+	enc->rst_a = devm_reset_control_get(mpp->dev, "video_a");
+	enc->rst_h = devm_reset_control_get(mpp->dev, "video_h");
+
+	if (IS_ERR_OR_NULL(enc->rst_a)) {
+		mpp_err("No aclk reset resource define\n");
+		enc->rst_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(enc->rst_h)) {
+		mpp_err("No hclk reset resource define\n");
+		enc->rst_h = NULL;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_vepu_reset(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
+
+	if (enc->rst_a && enc->rst_h) {
+		mpp_debug(DEBUG_RESET, "reset in\n");
+		reset_control_assert(enc->rst_a);
+		reset_control_assert(enc->rst_h);
+
+		udelay(1);
+
+		reset_control_deassert(enc->rst_a);
+		reset_control_deassert(enc->rst_h);
+		mpp_debug(DEBUG_RESET, "reset out\n");
+	}
+	return 0;
+}
+
+static int rockchip_mpp_vepu_run(struct rockchip_mpp_dev *mpp)
+{
+	struct vepu_ctx *ctx =
+			       to_vepu_ctx(mpp_srv_get_current_ctx(mpp->srv));
+	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
+	int i;
+
+	mpp_debug_enter();
+
+	/*
+	 * before encoding running, we have to switch grf ctrl bit to ensure
+	 * ip inner-sram controlled by vepu
+	 */
+#ifdef CONFIG_MFD_SYSCON
+	if (enc->grf) {
+		u32 raw;
+		u32 bits = BIT(enc->mode_bit);
+
+		regmap_read(enc->grf, enc->mode_ctrl, &raw);
+		regmap_write(enc->grf, enc->mode_ctrl,
+			     (raw & (~bits)) | (bits << 16));
+	}
+#endif
+
+	/*
+	 * NOTE: encoder need to setup mode first
+	 */
+	mpp_write(mpp,
+		  ctx->reg[VEPU_REG_ENC_START / 4] & (~VEPU_ENC_ENABLE),
+		  VEPU_REG_ENC_START);
+
+	for (i = 0; i < ROCKCHIP_VEPU_REG_LEN; i++) {
+		if (i * 4 != VEPU_REG_ENC_START)
+			mpp_write_relaxed(mpp, ctx->reg[i], i * 4);
+	}
+
+	mpp_write(mpp, ctx->reg[VEPU_REG_ENC_START / 4], VEPU_REG_ENC_START);
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_vepu_done(struct rockchip_mpp_dev *mpp)
+{
+	struct mpp_ctx *ictx = mpp_srv_get_current_ctx(mpp->srv);
+	struct vepu_ctx *ctx;
+	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
+	int i;
+
+	mpp_debug_enter();
+
+	if (IS_ERR_OR_NULL(ictx)) {
+		mpp_err("Invaidate context to save result\n");
+		return -1;
+	}
+
+	ctx = to_vepu_ctx(ictx);
+
+	for (i = 0; i < ROCKCHIP_VEPU_REG_LEN; i++)
+		ctx->reg[i] = mpp_read(mpp, i * 4);
+
+	ctx->reg[VEPU_REG_INTERRUPT / 4] = enc->irq_status;
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_vepu_irq(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
+
+	enc->irq_status = mpp_read(mpp, VEPU_REG_INTERRUPT);
+
+	mpp_debug_enter();
+
+	if (enc->irq_status == 0)
+		return -1;
+
+	mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n", enc->irq_status);
+	mpp_write(mpp, 0, VEPU_REG_INTERRUPT);
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_vepu_result(struct rockchip_mpp_dev *mpp,
+				    struct mpp_ctx *ictx, u32 __user *dst)
+{
+	struct vepu_ctx *ctx = to_vepu_ctx(ictx);
+
+	if (copy_to_user(dst, ctx->reg, ROCKCHIP_VEPU_REG_LEN * 4)) {
+		mpp_err("copy_to_user failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+struct mpp_dev_ops vepu_ops = {
+	.init = rockchip_mpp_vepu_init,
+	.run = rockchip_mpp_vepu_run,
+	.done = rockchip_mpp_vepu_done,
+	.irq = rockchip_mpp_vepu_irq,
+	.result = rockchip_mpp_vepu_result,
+};
+
+static void rockchip_mpp_vepu_power_on(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
+
+	if (enc->aclk)
+		clk_prepare_enable(enc->aclk);
+	if (enc->hclk)
+		clk_prepare_enable(enc->hclk);
+	if (enc->cclk)
+		clk_prepare_enable(enc->cclk);
+}
+
+static void rockchip_mpp_vepu_power_off(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
+
+	if (enc->hclk)
+		clk_disable_unprepare(enc->hclk);
+	if (enc->aclk)
+		clk_disable_unprepare(enc->aclk);
+	if (enc->cclk)
+		clk_disable_unprepare(enc->cclk);
+}
+
+static int rockchip_mpp_vepu_probe(struct rockchip_mpp_dev *mpp)
+{
+	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
+	struct device_node *np = mpp->dev->of_node;
+
+	enc->idev.ops = &vepu_ops;
+
+	enc->aclk = devm_clk_get(mpp->dev, "aclk_vcodec");
+	if (IS_ERR_OR_NULL(enc->aclk)) {
+		dev_err(mpp->dev, "failed on clk_get aclk\n");
+		goto fail;
+	}
+
+	enc->hclk = devm_clk_get(mpp->dev, "hclk_vcodec");
+	if (IS_ERR_OR_NULL(enc->hclk)) {
+		dev_err(mpp->dev, "failed on clk_get hclk\n");
+		goto fail;
+	}
+
+	enc->cclk = devm_clk_get(mpp->dev, "clk_core");
+	if (IS_ERR_OR_NULL(enc->cclk)) {
+		dev_err(mpp->dev, "failed on clk_get cclk\n");
+		goto fail;
+	}
+
+	if (of_property_read_bool(np, "mode_ctrl")) {
+		of_property_read_u32(np, "mode_bit", &enc->mode_bit);
+		of_property_read_u32(np, "mode_ctrl", &enc->mode_ctrl);
+
+#ifdef COFNIG_MFD_SYSCON
+		enc->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+		if (IS_ERR_OR_NULL(enc->grf)) {
+			enc->grf = NULL;
+			mpp_err("can't find vpu grf property\n");
+			goto fail;
+		}
+#endif
+	}
+
+	rockchip_mpp_vepu_reset_init(mpp);
+
+	return 0;
+
+fail:
+	return -1;
+}
+
+static void rockchip_mpp_vepu_remove(struct rockchip_mpp_dev *mpp)
+{
+}
+
+const struct rockchip_mpp_dev_variant vepu_variant = {
+	.data_len = sizeof(struct rockchip_vepu_dev),
+	.reg_len = ROCKCHIP_VEPU_REG_LEN,
+	.trans_info = trans_vepu,
+	.mmu_dev_dts_name = NULL,
+	.hw_probe = rockchip_mpp_vepu_probe,
+	.hw_remove = rockchip_mpp_vepu_remove,
+	.power_on = rockchip_mpp_vepu_power_on,
+	.power_off = rockchip_mpp_vepu_power_off,
+	.reset = rockchip_mpp_vepu_reset,
+};
+EXPORT_SYMBOL(vepu_variant);
diff -Nupr a/drivers/video/rockchip/vpu/mpp_dev_vepu.h b/drivers/video/rockchip/vpu/mpp_dev_vepu.h
--- a/drivers/video/rockchip/vpu/mpp_dev_vepu.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_dev_vepu.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,47 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ROCKCHIP_MPP_DEV_VEPU_H
+#define __ROCKCHIP_MPP_DEV_VEPU_H
+
+#define ROCKCHIP_VEPU_REG_LEN		184
+
+struct regmap;
+
+struct rockchip_vepu_dev {
+	struct rockchip_mpp_dev idev;
+
+	u32 irq_status;
+
+	struct clk *aclk;
+	struct clk *hclk;
+	struct clk *cclk;
+
+	struct reset_control *rst_a;
+	struct reset_control *rst_h;
+
+	u32 mode_bit;
+	u32 mode_ctrl;
+	struct regmap *grf;
+};
+
+struct vepu_ctx {
+	struct mpp_ctx ictx;
+
+	u32 reg[ROCKCHIP_VEPU_REG_LEN];
+	struct extra_info_for_iommu ext_inf;
+};
+
+#endif
diff -Nupr a/drivers/video/rockchip/vpu/mpp_service.c b/drivers/video/rockchip/vpu/mpp_service.c
--- a/drivers/video/rockchip/vpu/mpp_service.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_service.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,228 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+
+#include "mpp_dev_common.h"
+#include "mpp_service.h"
+
+void mpp_srv_lock(struct mpp_service *pservice)
+{
+	mutex_lock(&pservice->lock);
+}
+EXPORT_SYMBOL(mpp_srv_lock);
+
+void mpp_srv_unlock(struct mpp_service *pservice)
+{
+	mutex_unlock(&pservice->lock);
+}
+EXPORT_SYMBOL(mpp_srv_unlock);
+
+/* service queue schedule */
+void mpp_srv_pending_locked(struct mpp_service *pservice,
+			    struct mpp_ctx *ctx)
+{
+	mpp_srv_lock(pservice);
+
+	list_add_tail(&ctx->status_link, &pservice->pending);
+
+	mpp_srv_unlock(pservice);
+}
+EXPORT_SYMBOL(mpp_srv_pending_locked);
+
+void mpp_srv_run(struct mpp_service *pservice)
+{
+	struct mpp_ctx *ctx = mpp_srv_get_pending_ctx(pservice);
+
+	list_del_init(&ctx->status_link);
+	list_add_tail(&ctx->status_link, &pservice->running);
+}
+EXPORT_SYMBOL(mpp_srv_run);
+
+void mpp_srv_done(struct mpp_service *pservice)
+{
+	struct mpp_ctx *ctx = list_entry(pservice->running.next,
+					 struct mpp_ctx, status_link);
+
+	list_del_init(&ctx->session_link);
+	list_add_tail(&ctx->session_link, &ctx->session->done);
+
+	list_del_init(&ctx->status_link);
+	list_add_tail(&ctx->status_link, &pservice->done);
+
+	wake_up(&ctx->session->wait);
+}
+EXPORT_SYMBOL(mpp_srv_done);
+
+struct mpp_ctx *mpp_srv_get_pending_ctx(struct mpp_service *pservice)
+{
+	return list_entry(pservice->pending.next, struct mpp_ctx, status_link);
+}
+EXPORT_SYMBOL(mpp_srv_get_pending_ctx);
+
+struct mpp_ctx *mpp_srv_get_current_ctx(struct mpp_service *pservice)
+{
+	return list_entry(pservice->running.next, struct mpp_ctx, status_link);
+}
+EXPORT_SYMBOL(mpp_srv_get_current_ctx);
+
+struct mpp_ctx *mpp_srv_get_last_running_ctx(struct mpp_service *pservice)
+{
+	return list_entry(pservice->running.prev, struct mpp_ctx, status_link);
+}
+EXPORT_SYMBOL(mpp_srv_get_last_running_ctx);
+
+struct mpp_session *mpp_srv_get_current_session(struct mpp_service *pservice)
+{
+	struct mpp_ctx *ctx = list_entry(pservice->running.next,
+					 struct mpp_ctx, status_link);
+	return ctx ? ctx->session : NULL;
+}
+EXPORT_SYMBOL(mpp_srv_get_current_session);
+
+struct mpp_ctx *mpp_srv_get_done_ctx(struct mpp_session *session)
+{
+	return list_entry(session->done.next, struct mpp_ctx, session_link);
+}
+EXPORT_SYMBOL(mpp_srv_get_done_ctx);
+
+bool mpp_srv_pending_is_empty(struct mpp_service *pservice)
+{
+	return !!list_empty(&pservice->pending);
+}
+EXPORT_SYMBOL(mpp_srv_pending_is_empty);
+
+void mpp_srv_attach(struct mpp_service *pservice, struct list_head *elem)
+{
+	INIT_LIST_HEAD(elem);
+	list_add_tail(elem, &pservice->subdev_list);
+	pservice->dev_cnt++;
+}
+EXPORT_SYMBOL(mpp_srv_attach);
+
+void mpp_srv_detach(struct mpp_service *pservice, struct list_head *elem)
+{
+	list_del_init(elem);
+	pservice->dev_cnt--;
+}
+EXPORT_SYMBOL(mpp_srv_detach);
+
+bool mpp_srv_is_running(struct mpp_service *pservice)
+{
+	return !list_empty(&pservice->running);
+}
+EXPORT_SYMBOL(mpp_srv_is_running);
+
+static void mpp_init_drvdata(struct mpp_service *pservice)
+{
+	INIT_LIST_HEAD(&pservice->pending);
+	mutex_init(&pservice->lock);
+
+	INIT_LIST_HEAD(&pservice->done);
+	INIT_LIST_HEAD(&pservice->session);
+	INIT_LIST_HEAD(&pservice->subdev_list);
+	INIT_LIST_HEAD(&pservice->running);
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id mpp_service_dt_ids[] = {
+	{ .compatible = "rockchip,mpp_service", },
+	{ },
+};
+#endif
+
+static int mpp_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res = NULL;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct mpp_service *pservice =
+				       devm_kzalloc(dev, sizeof(*pservice),
+						    GFP_KERNEL);
+
+	dev_info(dev, "%s enter\n", __func__);
+
+	pservice->dev = dev;
+
+	mpp_init_drvdata(pservice);
+
+	if (of_property_read_bool(np, "reg")) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+		pservice->reg_base = devm_ioremap_resource(pservice->dev, res);
+		if (IS_ERR(pservice->reg_base)) {
+			dev_err(dev, "ioremap registers base failed\n");
+			ret = PTR_ERR(pservice->reg_base);
+			pservice->reg_base = 0;
+		}
+	} else {
+		pservice->reg_base = 0;
+	}
+
+	pservice->cls = class_create(THIS_MODULE, dev_name(dev));
+
+	if (IS_ERR(pservice->cls)) {
+		ret = PTR_ERR(pservice->cls);
+		dev_err(dev, "class_create err:%d\n", ret);
+		return -1;
+	}
+
+	platform_set_drvdata(pdev, pservice);
+	dev_info(dev, "init success\n");
+
+	return 0;
+}
+
+static int mpp_remove(struct platform_device *pdev)
+{
+	struct mpp_service *pservice = platform_get_drvdata(pdev);
+
+	class_destroy(pservice->cls);
+	return 0;
+}
+
+static struct platform_driver mpp_driver = {
+	.probe = mpp_probe,
+	.remove = mpp_remove,
+	.driver = {
+		.name = "mpp",
+		.owner = THIS_MODULE,
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(mpp_service_dt_ids),
+#endif
+	},
+};
+
+static int __init mpp_service_init(void)
+{
+	int ret = platform_driver_register(&mpp_driver);
+
+	if (ret) {
+		mpp_err("Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+subsys_initcall(mpp_service_init);
+MODULE_LICENSE("GPL");
+
diff -Nupr a/drivers/video/rockchip/vpu/mpp_service.h b/drivers/video/rockchip/vpu/mpp_service.h
--- a/drivers/video/rockchip/vpu/mpp_service.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/mpp_service.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: chenhengming chm@rock-chips.com
+ *	   Alpha Lin, alpha.lin@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __ROCKCHIP_MPP_SERVICE_H
+#define __ROCKCHIP_MPP_SERVICE_H
+
+#include <linux/ioctl.h>
+
+#include "mpp_dev_common.h"
+
+struct mpp_session {
+	/* a linked list of data so we can access them for debugging */
+	struct list_head list_session;
+	/* the session related device private data */
+	struct rockchip_mpp_dev *mpp;
+	struct list_head done;
+	wait_queue_head_t wait;
+	pid_t pid;
+	atomic_t task_running;
+};
+
+enum mpp_srv_state {
+	HW_RUNNING	= BIT(1)
+};
+
+struct mpp_service {
+	/* service structure global lock */
+	struct mutex lock;
+	struct list_head pending;
+	struct list_head done;
+	struct list_head running;
+	/* link to list_session in struct mpp_session */
+	struct list_head session;
+
+	struct device *dev;
+
+	void __iomem *reg_base;
+
+	struct class *cls;
+
+	u32 dev_cnt;
+	struct list_head subdev_list;
+};
+
+void mpp_srv_lock(struct mpp_service *pservice);
+void mpp_srv_unlock(struct mpp_service *pservice);
+void mpp_srv_pending_locked(struct mpp_service *pservice, struct mpp_ctx *ctx);
+void mpp_srv_run(struct mpp_service *pservice);
+void mpp_srv_done(struct mpp_service *pservice);
+void mpp_srv_attach(struct mpp_service *pservice, struct list_head *elem);
+void mpp_srv_detach(struct mpp_service *pservice, struct list_head *elem);
+struct mpp_ctx *mpp_srv_get_pending_ctx(struct mpp_service *pservice);
+struct mpp_ctx *mpp_srv_get_current_ctx(struct mpp_service *pservice);
+struct mpp_ctx *mpp_srv_get_last_running_ctx(struct mpp_service *pservice);
+struct mpp_session *mpp_srv_get_current_session(struct mpp_service *pservice);
+bool mpp_srv_pending_is_empty(struct mpp_service *pservice);
+struct mpp_ctx *mpp_srv_get_done_ctx(struct mpp_session *session);
+bool mpp_srv_is_power_on(struct mpp_service *pservice);
+bool mpp_srv_is_running(struct mpp_service *pservice);
+
+#endif
+
diff -Nupr a/drivers/video/rockchip/vpu/vpu_iommu_drm.c b/drivers/video/rockchip/vpu/vpu_iommu_drm.c
--- a/drivers/video/rockchip/vpu/vpu_iommu_drm.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/vpu_iommu_drm.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,936 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/dma-iommu.h>
+
+#include <linux/dma-buf.h>
+#include <drm/drmP.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_sync_helper.h>
+#include <drm/rockchip_drm.h>
+#include <linux/dma-mapping.h>
+#include <linux/rockchip-iovmm.h>
+#include <linux/pm_runtime.h>
+#include <linux/memblock.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_graph.h>
+#include <linux/component.h>
+#include <linux/fence.h>
+#include <linux/console.h>
+#include <linux/kref.h>
+#include <linux/fdtable.h>
+#include <linux/ktime.h>
+#include <linux/iova.h>
+
+#include "vpu_iommu_ops.h"
+
+#define VPU_DRM_BUFFER_ALLOC	0x00000001
+
+struct vpu_drm_buffer {
+	struct list_head list;
+	struct dma_buf *dma_buf;
+	union {
+		unsigned long iova;
+		unsigned long phys;
+	};
+	void *cpu_addr;
+	unsigned long size;
+	int index;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct sg_table *copy_sgt;
+	struct page **pages;
+	struct kref ref;
+	struct vpu_iommu_session_info *session_info;
+	ktime_t last_used;
+	int flags;
+};
+
+struct vpu_iommu_drm_info {
+	struct iommu_domain *domain;
+	bool attached;
+};
+
+static struct vpu_drm_buffer *
+vpu_drm_get_buffer_no_lock(struct vpu_iommu_session_info *session_info,
+			   int idx)
+{
+	struct vpu_drm_buffer *drm_buffer = NULL, *n;
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		if (drm_buffer->index == idx) {
+			drm_buffer->last_used = ktime_get();
+			return drm_buffer;
+		}
+	}
+
+	return NULL;
+}
+
+static struct vpu_drm_buffer*
+vpu_drm_get_buffer_fd_no_lock(struct vpu_iommu_session_info *session_info,
+			      int fd)
+{
+	struct vpu_drm_buffer *drm_buffer = NULL, *n;
+	struct dma_buf *dma_buf = NULL;
+
+	dma_buf = dma_buf_get(fd);
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		if (drm_buffer->dma_buf == dma_buf) {
+			drm_buffer->last_used = ktime_get();
+			dma_buf_put(dma_buf);
+			return drm_buffer;
+		}
+	}
+
+	dma_buf_put(dma_buf);
+
+	return NULL;
+}
+
+static void vpu_drm_detach(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = iommu_info->dev;
+	struct iommu_domain *domain = drm_info->domain;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (!drm_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return;
+	}
+
+	iommu_detach_device(domain, dev);
+	drm_info->attached = false;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static int vpu_drm_attach_unlock(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = iommu_info->dev;
+	struct iommu_domain *domain = drm_info->domain;
+	int ret = 0;
+
+	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
+	ret = iommu_attach_device(domain, dev);
+	if (ret) {
+		dev_err(dev, "Failed to attach iommu device\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int vpu_drm_attach(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
+	int ret;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (drm_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return 0;
+	}
+
+	ret = vpu_drm_attach_unlock(iommu_info);
+	if (ret) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return ret;
+	}
+
+	drm_info->attached = true;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return ret;
+}
+
+static void *vpu_drm_sgt_map_kernel(struct vpu_drm_buffer *drm_buffer)
+{
+	struct vpu_iommu_session_info *session_info =
+						      drm_buffer->session_info;
+	struct device *dev = session_info->dev;
+	struct scatterlist *sgl, *sg;
+	int nr_pages = PAGE_ALIGN(drm_buffer->size) >> PAGE_SHIFT;
+	int i = 0, j = 0, k = 0;
+	struct page *page;
+
+	drm_buffer->pages = kmalloc_array(nr_pages, sizeof(*drm_buffer->pages),
+					  GFP_KERNEL);
+	if (!(drm_buffer->pages)) {
+		dev_err(dev, "drm map can not alloc pages\n");
+
+		return NULL;
+	}
+
+	sgl = drm_buffer->copy_sgt->sgl;
+
+	for_each_sg(sgl, sg, drm_buffer->copy_sgt->nents, i) {
+		page = sg_page(sg);
+		for (j = 0; j < sg->length / PAGE_SIZE; j++)
+			drm_buffer->pages[k++] = page++;
+	}
+
+	return vmap(drm_buffer->pages, nr_pages, VM_MAP,
+		    pgprot_noncached(PAGE_KERNEL));
+}
+
+static void vpu_drm_sgt_unmap_kernel(struct vpu_drm_buffer *drm_buffer)
+{
+	vunmap(drm_buffer->cpu_addr);
+	kfree(drm_buffer->pages);
+}
+
+static int vpu_finalise_sg(struct scatterlist *sg,
+			   int nents,
+			   dma_addr_t dma_addr)
+{
+	struct scatterlist *s, *cur = sg;
+	unsigned long seg_mask = DMA_BIT_MASK(32);
+	unsigned int cur_len = 0, max_len = DMA_BIT_MASK(32);
+	int i, count = 0;
+
+	for_each_sg(sg, s, nents, i) {
+		/* Restore this segment's original unaligned fields first */
+		unsigned int s_iova_off = sg_dma_address(s);
+		unsigned int s_length = sg_dma_len(s);
+		unsigned int s_iova_len = s->length;
+
+		s->offset += s_iova_off;
+		s->length = s_length;
+		sg_dma_address(s) = DMA_ERROR_CODE;
+		sg_dma_len(s) = 0;
+
+		/*
+		 * Now fill in the real DMA data. If...
+		 * - there is a valid output segment to append to
+		 * - and this segment starts on an IOVA page boundary
+		 * - but doesn't fall at a segment boundary
+		 * - and wouldn't make the resulting output segment too long
+		 */
+		if (cur_len && !s_iova_off && (dma_addr & seg_mask) &&
+		    (cur_len + s_length <= max_len)) {
+			/* ...then concatenate it with the previous one */
+			cur_len += s_length;
+		} else {
+			/* Otherwise start the next output segment */
+			if (i > 0)
+				cur = sg_next(cur);
+			cur_len = s_length;
+			count++;
+
+			sg_dma_address(cur) = dma_addr + s_iova_off;
+		}
+
+		sg_dma_len(cur) = cur_len;
+		dma_addr += s_iova_len;
+
+		if (s_length + s_iova_off < s_iova_len)
+			cur_len = 0;
+	}
+	return count;
+}
+
+static void vpu_invalidate_sg(struct scatterlist *sg, int nents)
+{
+	struct scatterlist *s;
+	int i;
+
+	for_each_sg(sg, s, nents, i) {
+		if (sg_dma_address(s) != DMA_ERROR_CODE)
+			s->offset += sg_dma_address(s);
+		if (sg_dma_len(s))
+			s->length = sg_dma_len(s);
+		sg_dma_address(s) = DMA_ERROR_CODE;
+		sg_dma_len(s) = 0;
+	}
+}
+
+static dma_addr_t vpu_dma_map_sg(struct iommu_domain *domain,
+				 struct scatterlist *sg,
+				 int nents, int prot)
+{
+	struct iova_domain *iovad = domain->iova_cookie;
+	struct iova *iova;
+	struct scatterlist *s, *prev = NULL;
+	dma_addr_t dma_addr;
+	size_t iova_len = 0;
+	unsigned long mask = DMA_BIT_MASK(32);
+	unsigned long shift = iova_shift(iovad);
+	int i;
+
+	/*
+	 * Work out how much IOVA space we need, and align the segments to
+	 * IOVA granules for the IOMMU driver to handle. With some clever
+	 * trickery we can modify the list in-place, but reversibly, by
+	 * stashing the unaligned parts in the as-yet-unused DMA fields.
+	 */
+	for_each_sg(sg, s, nents, i) {
+		size_t s_iova_off = iova_offset(iovad, s->offset);
+		size_t s_length = s->length;
+		size_t pad_len = (mask - iova_len + 1) & mask;
+
+		sg_dma_address(s) = s_iova_off;
+		sg_dma_len(s) = s_length;
+		s->offset -= s_iova_off;
+		s_length = iova_align(iovad, s_length + s_iova_off);
+		s->length = s_length;
+
+		/*
+		 * Due to the alignment of our single IOVA allocation, we can
+		 * depend on these assumptions about the segment boundary mask:
+		 * - If mask size >= IOVA size, then the IOVA range cannot
+		 *   possibly fall across a boundary, so we don't care.
+		 * - If mask size < IOVA size, then the IOVA range must start
+		 *   exactly on a boundary, therefore we can lay things out
+		 *   based purely on segment lengths without needing to know
+		 *   the actual addresses beforehand.
+		 * - The mask must be a power of 2, so pad_len == 0 if
+		 *   iova_len == 0, thus we cannot dereference prev the first
+		 *   time through here (i.e. before it has a meaningful value).
+		 */
+		if (pad_len && pad_len < s_length - 1) {
+			prev->length += pad_len;
+			iova_len += pad_len;
+		}
+
+		iova_len += s_length;
+		prev = s;
+	}
+
+	iova = alloc_iova(iovad, iova_align(iovad, iova_len) >> shift,
+			  mask >> shift, true);
+	if (!iova)
+		goto out_restore_sg;
+
+	/*
+	 * We'll leave any physical concatenation to the IOMMU driver's
+	 * implementation - it knows better than we do.
+	 */
+	dma_addr = iova_dma_addr(iovad, iova);
+	if (iommu_map_sg(domain, dma_addr, sg, nents, prot) < iova_len)
+		goto out_free_iova;
+
+	return vpu_finalise_sg(sg, nents, dma_addr);
+
+out_free_iova:
+	__free_iova(iovad, iova);
+out_restore_sg:
+	vpu_invalidate_sg(sg, nents);
+	return 0;
+}
+
+static void vpu_dma_unmap_sg(struct iommu_domain *domain,
+			     dma_addr_t dma_addr)
+{
+	struct iova_domain *iovad = domain->iova_cookie;
+	unsigned long shift = iova_shift(iovad);
+	unsigned long pfn = dma_addr >> shift;
+	struct iova *iova = find_iova(iovad, pfn);
+	size_t size;
+
+	if (WARN_ON(!iova))
+		return;
+
+	size = iova_size(iova) << shift;
+	size -= iommu_unmap(domain, pfn << shift, size);
+	/* ...and if we can't, then something is horribly, horribly wrong */
+	WARN_ON(size > 0);
+	__free_iova(iovad, iova);
+}
+
+static void vpu_drm_clear_map(struct kref *ref)
+{
+	struct vpu_drm_buffer *drm_buffer =
+					    container_of(ref,
+							 struct vpu_drm_buffer,
+							 ref);
+	struct vpu_iommu_session_info *session_info =
+						      drm_buffer->session_info;
+	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
+	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
+					      struct sg_table *table;
+					      struct scatterlist *sg;
+					      struct page *page;
+					      int i;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+	drm_info = session_info->iommu_info->private;
+
+	if (drm_buffer->cpu_addr) {
+		vpu_drm_sgt_unmap_kernel(drm_buffer);
+		drm_buffer->cpu_addr = NULL;
+	}
+
+	vpu_dma_unmap_sg(drm_info->domain, drm_buffer->iova);
+	if (drm_buffer->flags & VPU_DRM_BUFFER_ALLOC) {
+		table = drm_buffer->copy_sgt;
+		for_each_sg(table->sgl, sg, table->nents, i) {
+			page = sg_page(sg);
+			__free_pages(page, compound_order(page));
+		}
+	}
+	sg_free_table(drm_buffer->copy_sgt);
+	kfree(drm_buffer->copy_sgt);
+
+	if (drm_buffer->attach) {
+		dma_buf_unmap_attachment(drm_buffer->attach, drm_buffer->sgt,
+					 DMA_BIDIRECTIONAL);
+		dma_buf_detach(drm_buffer->dma_buf, drm_buffer->attach);
+		dma_buf_put(drm_buffer->dma_buf);
+		drm_buffer->attach = NULL;
+	}
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static void vcdoec_drm_dump_info(struct vpu_iommu_session_info *session_info)
+{
+	struct vpu_drm_buffer *drm_buffer = NULL, *n;
+
+	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_OPS_DUMP,
+			"still there are below buffers stored in list\n");
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_OPS_DUMP,
+				"index %d drm_buffer dma_buf %p cpu_addr %p\n",
+				drm_buffer->index,
+				drm_buffer->dma_buf, drm_buffer->cpu_addr);
+	}
+}
+
+static int vpu_drm_free(struct vpu_iommu_session_info *session_info,
+			int idx)
+{
+	struct device *dev = session_info->dev;
+	/* please double-check all maps have been release */
+	struct vpu_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		mutex_unlock(&session_info->list_mutex);
+
+		return -EINVAL;
+	}
+
+	if (atomic_read(&drm_buffer->ref.refcount) == 0) {
+		if (drm_buffer->dma_buf)
+			dma_buf_put(drm_buffer->dma_buf);
+		list_del_init(&drm_buffer->list);
+		kfree(drm_buffer);
+		session_info->buffer_nums--;
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+				"buffer nums %d\n", session_info->buffer_nums);
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	return 0;
+}
+
+static int
+vpu_drm_unmap_iommu(struct vpu_iommu_session_info *session_info,
+		    int idx)
+{
+	struct device *dev = session_info->dev;
+	struct vpu_drm_buffer *drm_buffer;
+
+	/* Force to flush iommu table */
+	if (of_machine_is_compatible("rockchip,rk3288"))
+		rockchip_iovmm_invalidate_tlb(session_info->mmu_dev);
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return -EINVAL;
+	}
+
+	kref_put(&drm_buffer->ref, vpu_drm_clear_map);
+
+	return 0;
+}
+
+static int vpu_drm_map_iommu(struct vpu_iommu_session_info *session_info,
+			     int idx,
+			     unsigned long *iova,
+			     unsigned long *size)
+{
+	struct device *dev = session_info->dev;
+	struct vpu_drm_buffer *drm_buffer;
+
+	/* Force to flush iommu table */
+	if (of_machine_is_compatible("rockchip,rk3288"))
+		rockchip_iovmm_invalidate_tlb(session_info->mmu_dev);
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return -EINVAL;
+	}
+
+	kref_get(&drm_buffer->ref);
+	if (iova)
+		*iova = drm_buffer->iova;
+	if (size)
+		*size = drm_buffer->size;
+	return 0;
+}
+
+static int
+vpu_drm_unmap_kernel(struct vpu_iommu_session_info *session_info, int idx)
+{
+	struct device *dev = session_info->dev;
+	struct vpu_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+
+		return -EINVAL;
+	}
+
+	if (drm_buffer->cpu_addr) {
+		vpu_drm_sgt_unmap_kernel(drm_buffer);
+		drm_buffer->cpu_addr = NULL;
+	}
+
+	kref_put(&drm_buffer->ref, vpu_drm_clear_map);
+	return 0;
+}
+
+static int
+vpu_drm_free_fd(struct vpu_iommu_session_info *session_info, int fd)
+{
+	struct device *dev = session_info->dev;
+	/* please double-check all maps have been release */
+	struct vpu_drm_buffer *drm_buffer = NULL;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vpu_drm_get_buffer_fd_no_lock(session_info, fd);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", fd);
+		mutex_unlock(&session_info->list_mutex);
+
+		return -EINVAL;
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	vpu_drm_unmap_iommu(session_info, drm_buffer->index);
+
+	mutex_lock(&session_info->list_mutex);
+	if (atomic_read(&drm_buffer->ref.refcount) == 0) {
+		if (drm_buffer->dma_buf)
+			dma_buf_put(drm_buffer->dma_buf);
+		list_del_init(&drm_buffer->list);
+		kfree(drm_buffer);
+		session_info->buffer_nums--;
+		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+				"buffer nums %d\n", session_info->buffer_nums);
+	}
+	mutex_unlock(&session_info->list_mutex);
+
+	return 0;
+}
+
+static void
+vpu_drm_clear_session(struct vpu_iommu_session_info *session_info)
+{
+	struct vpu_drm_buffer *drm_buffer = NULL, *n;
+
+	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
+				 list) {
+		kref_put(&drm_buffer->ref, vpu_drm_clear_map);
+		vpu_drm_free(session_info, drm_buffer->index);
+	}
+}
+
+static void*
+vpu_drm_map_kernel(struct vpu_iommu_session_info *session_info, int idx)
+{
+	struct device *dev = session_info->dev;
+	struct vpu_drm_buffer *drm_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!drm_buffer) {
+		dev_err(dev, "can not find %d buffer in list\n", idx);
+		return NULL;
+	}
+
+	if (!drm_buffer->cpu_addr)
+		drm_buffer->cpu_addr =
+				       vpu_drm_sgt_map_kernel(drm_buffer);
+
+	kref_get(&drm_buffer->ref);
+
+	return drm_buffer->cpu_addr;
+}
+
+static void vpu_drm_remove_extra_buffer_no_lock(struct vpu_iommu_session_info *session_info)
+{
+	struct vpu_drm_buffer *oldest_buffer = NULL, *loop_buffer = NULL;
+	struct vpu_drm_buffer *n;
+	ktime_t oldest_time = ktime_set(0, 0);
+
+	if (session_info->buffer_nums > BUFFER_LIST_MAX_NUMS) {
+		list_for_each_entry_safe(loop_buffer, n,
+					 &session_info->buffer_list, list) {
+			if (loop_buffer->flags & VPU_DRM_BUFFER_ALLOC)
+				continue;
+
+			if (ktime_to_ns(oldest_time) == 0 ||
+			    ktime_after(oldest_time,
+					loop_buffer->last_used)) {
+				oldest_time = loop_buffer->last_used;
+				oldest_buffer = loop_buffer;
+			}
+		}
+		kref_put(&oldest_buffer->ref, vpu_drm_clear_map);
+		dma_buf_put(oldest_buffer->dma_buf);
+		list_del_init(&oldest_buffer->list);
+		kfree(oldest_buffer);
+		session_info->buffer_nums--;
+	}
+}
+
+static int vpu_drm_import(struct vpu_iommu_session_info *session_info,
+			  int fd)
+{
+	struct vpu_drm_buffer *drm_buffer = NULL, *n;
+	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
+	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
+	struct device *dev = session_info->dev;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct dma_buf *dma_buf;
+	struct scatterlist *sg, *s;
+	int i;
+	int ret = 0;
+
+	dma_buf = dma_buf_get(fd);
+	if (IS_ERR(dma_buf)) {
+		ret = PTR_ERR(dma_buf);
+		return ret;
+	}
+
+	list_for_each_entry_safe(drm_buffer, n,
+				 &session_info->buffer_list, list) {
+		if (drm_buffer->dma_buf == dma_buf) {
+			dma_buf_put(dma_buf);
+			drm_buffer->last_used = ktime_get();
+			return drm_buffer->index;
+		}
+	}
+
+	drm_buffer = kzalloc(sizeof(*drm_buffer), GFP_KERNEL);
+	if (!drm_buffer) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	drm_buffer->dma_buf = dma_buf;
+	drm_buffer->session_info = session_info;
+	drm_buffer->last_used = ktime_get();
+
+	kref_init(&drm_buffer->ref);
+
+	mutex_lock(&iommu_info->iommu_mutex);
+	drm_info = session_info->iommu_info->private;
+
+	attach = dma_buf_attach(drm_buffer->dma_buf, dev);
+	if (IS_ERR(attach)) {
+		ret = PTR_ERR(attach);
+		goto fail_out;
+	}
+
+	get_dma_buf(drm_buffer->dma_buf);
+
+	sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
+	if (IS_ERR(sgt)) {
+		ret = PTR_ERR(sgt);
+		goto fail_detach;
+	}
+
+	/*
+	 * Since we call dma_buf_map_attachment outside attach/detach, this
+	 * will cause incorrectly map. we have to re-build map table native
+	 * and for avoiding destroy their origin map table, we need use a
+	 * copy one sg_table.
+	 */
+	drm_buffer->copy_sgt = kmalloc(sizeof(*drm_buffer->copy_sgt),
+				       GFP_KERNEL);
+	if (!drm_buffer->copy_sgt) {
+		ret = -ENOMEM;
+		goto fail_detach;
+	}
+
+	ret = sg_alloc_table(drm_buffer->copy_sgt, sgt->nents, GFP_KERNEL);
+	s = drm_buffer->copy_sgt->sgl;
+	for_each_sg(sgt->sgl, sg, sgt->nents, i) {
+		sg_set_page(s, sg_page(sg),
+			    PAGE_SIZE << compound_order(sg_page(sg)), 0);
+		sg_dma_address(s) = page_to_phys(sg_page(sg));
+		s->offset = sg->offset;
+		s->length = sg->length;
+		s = sg_next(s);
+	}
+
+	vpu_dma_map_sg(drm_info->domain, drm_buffer->copy_sgt->sgl,
+		       drm_buffer->copy_sgt->nents,
+		       IOMMU_READ | IOMMU_WRITE);
+	drm_buffer->iova = sg_dma_address(drm_buffer->copy_sgt->sgl);
+	drm_buffer->size = drm_buffer->dma_buf->size;
+
+	drm_buffer->attach = attach;
+	drm_buffer->sgt = sgt;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	INIT_LIST_HEAD(&drm_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	session_info->buffer_nums++;
+	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+			"buffer nums %d\n", session_info->buffer_nums);
+	vpu_drm_remove_extra_buffer_no_lock(session_info);
+	drm_buffer->index = session_info->max_idx;
+	list_add_tail(&drm_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return drm_buffer->index;
+
+fail_detach:
+	dev_err(dev, "dmabuf map attach failed\n");
+	dma_buf_detach(drm_buffer->dma_buf, attach);
+	dma_buf_put(drm_buffer->dma_buf);
+fail_out:
+	kfree(drm_buffer);
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return ret;
+}
+
+static int vpu_drm_alloc(struct vpu_iommu_session_info *session_info,
+			 unsigned long size,
+			 unsigned long align)
+{
+	struct sg_table *table;
+	struct scatterlist *sg;
+	struct list_head pages;
+	struct page *page, *tmp_page;
+	long size_remaining = PAGE_ALIGN(size);
+	struct vpu_drm_buffer *drm_buffer;
+	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
+	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
+	int i;
+
+	if (align > PAGE_SIZE)
+		return -EINVAL;
+
+	if (size / PAGE_SIZE > totalram_pages / 2)
+		return -ENOMEM;
+
+	drm_buffer = kzalloc(sizeof(*drm_buffer), GFP_KERNEL);
+	if (!drm_buffer)
+		return -ENOMEM;
+
+	drm_buffer->session_info = session_info;
+	drm_buffer->last_used = ktime_set(0, 0);
+
+	kref_init(&drm_buffer->ref);
+
+	INIT_LIST_HEAD(&pages);
+
+	i = 0;
+	while (size_remaining > 0) {
+		gfp_t gfp_flags = (GFP_HIGHUSER | __GFP_ZERO | __GFP_NOWARN |
+				   __GFP_NORETRY) & ~__GFP_DIRECT_RECLAIM;
+		page = alloc_pages(gfp_flags | __GFP_COMP, 8);
+		if (!page)
+			goto free_pages;
+
+		size_remaining -= PAGE_SIZE << compound_order(page);
+		list_add_tail(&page->lru, &pages);
+		i++;
+	}
+
+	table = kmalloc(sizeof(*table), GFP_KERNEL);
+	if (!table)
+		goto free_pages;
+
+	if (sg_alloc_table(table, i, GFP_KERNEL))
+		goto free_table;
+
+	sg = table->sgl;
+	list_for_each_entry_safe(page, tmp_page, &pages, lru) {
+		sg_set_page(sg, page, PAGE_SIZE << compound_order(page), 0);
+		sg = sg_next(sg);
+		list_del(&page->lru);
+	}
+
+	mutex_lock(&iommu_info->iommu_mutex);
+	drm_info = session_info->iommu_info->private;
+	drm_buffer->copy_sgt = table;
+
+	vpu_dma_map_sg(drm_info->domain, drm_buffer->copy_sgt->sgl,
+		       drm_buffer->copy_sgt->nents,
+		       IOMMU_READ | IOMMU_WRITE);
+	drm_buffer->iova = sg_dma_address(drm_buffer->copy_sgt->sgl);
+	drm_buffer->size = size;
+	drm_buffer->flags = VPU_DRM_BUFFER_ALLOC;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	INIT_LIST_HEAD(&drm_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	session_info->buffer_nums++;
+	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
+			"buffer nums %d\n", session_info->buffer_nums);
+	vpu_drm_remove_extra_buffer_no_lock(session_info);
+	drm_buffer->index = session_info->max_idx;
+	list_add_tail(&drm_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return drm_buffer->index;
+
+free_table:
+	kfree(table);
+free_pages:
+	list_for_each_entry_safe(page, tmp_page, &pages, lru)
+	__free_pages(page, 8);
+
+	kfree(drm_buffer);
+
+	return -ENOMEM;
+}
+
+static int vpu_drm_create(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_drm_info *drm_info;
+	struct iommu_group *group;
+	int ret;
+
+	iommu_info->private = kzalloc(sizeof(*drm_info),
+				      GFP_KERNEL);
+	drm_info = iommu_info->private;
+	if (!drm_info)
+		return -ENOMEM;
+
+	drm_info->domain = iommu_domain_alloc(&platform_bus_type);
+	drm_info->attached = false;
+	if (!drm_info->domain)
+		return -ENOMEM;
+
+	ret = iommu_get_dma_cookie(drm_info->domain);
+	if (ret)
+		goto err_free_domain;
+
+	group = iommu_group_get(iommu_info->dev);
+	if (!group) {
+		group = iommu_group_alloc();
+		if (IS_ERR(group)) {
+			dev_err(iommu_info->dev,
+				"Failed to allocate IOMMU group\n");
+			goto err_put_cookie;
+		}
+		ret = iommu_group_add_device(group, iommu_info->dev);
+		if (ret) {
+			dev_err(iommu_info->dev,
+				"failed to add device to IOMMU group\n");
+			goto err_put_cookie;
+		}
+	}
+	iommu_dma_init_domain(drm_info->domain, 0x10000000, SZ_2G);
+	iommu_group_put(group);
+
+	return 0;
+
+err_put_cookie:
+	iommu_put_dma_cookie(drm_info->domain);
+err_free_domain:
+	iommu_domain_free(drm_info->domain);
+
+	return ret;
+}
+
+static int vpu_drm_destroy(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
+
+	iommu_put_dma_cookie(drm_info->domain);
+	iommu_domain_free(drm_info->domain);
+
+	kfree(drm_info);
+	iommu_info->private = NULL;
+
+	return 0;
+}
+
+static struct vpu_iommu_ops drm_ops = {
+	.create = vpu_drm_create,
+	.alloc = vpu_drm_alloc,
+	.import = vpu_drm_import,
+	.free = vpu_drm_free,
+	.free_fd = vpu_drm_free_fd,
+	.map_kernel = vpu_drm_map_kernel,
+	.unmap_kernel = vpu_drm_unmap_kernel,
+	.map_iommu = vpu_drm_map_iommu,
+	.unmap_iommu = vpu_drm_unmap_iommu,
+	.destroy = vpu_drm_destroy,
+	.dump = vcdoec_drm_dump_info,
+	.attach = vpu_drm_attach,
+	.detach = vpu_drm_detach,
+	.clear = vpu_drm_clear_session,
+};
+
+void vpu_iommu_drm_set_ops(struct vpu_iommu_info *iommu_info)
+{
+	if (!iommu_info)
+		return;
+	iommu_info->ops = &drm_ops;
+}
diff -Nupr a/drivers/video/rockchip/vpu/vpu_iommu_ion.c b/drivers/video/rockchip/vpu/vpu_iommu_ion.c
--- a/drivers/video/rockchip/vpu/vpu_iommu_ion.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/vpu_iommu_ion.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,410 @@
+/*
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "vpu_iommu_ops.h"
+
+#if defined(CONFIG_ION_ROCKCHIP)
+#include <linux/rockchip_ion.h>
+#include <linux/rockchip-iovmm.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/memblock.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_graph.h>
+#include <linux/component.h>
+#include <linux/fence.h>
+#include <linux/console.h>
+#include <linux/kref.h>
+#include <linux/fdtable.h>
+
+struct vpu_ion_buffer {
+	struct list_head list;
+	struct ion_handle *handle;
+	int index;
+};
+
+struct vpu_iommu_ion_info {
+	struct ion_client *ion_client;
+	bool attached;
+};
+
+static struct vpu_ion_buffer*
+vpu_ion_get_buffer_no_lock(struct vpu_iommu_session_info *session_info,
+			   int idx)
+{
+	struct vpu_ion_buffer *ion_buffer = NULL, *n;
+
+	list_for_each_entry_safe(ion_buffer, n,
+				 &session_info->buffer_list, list) {
+		if (ion_buffer->index == idx)
+			return ion_buffer;
+	}
+
+	return NULL;
+}
+
+static void
+vpu_ion_clear_session(struct vpu_iommu_session_info *session_info)
+{
+	/* do nothing */
+}
+
+static int vpu_ion_attach(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
+					      int ret;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (ion_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return 0;
+	}
+
+	rockchip_iovmm_activate(iommu_info->dev);
+
+	ion_info->attached = true;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+
+	return ret;
+}
+
+static void vpu_ion_detach(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
+
+	mutex_lock(&iommu_info->iommu_mutex);
+
+	if (!ion_info->attached) {
+		mutex_unlock(&iommu_info->iommu_mutex);
+		return;
+	}
+
+	rockchip_iovmm_deactivate(iommu_info->dev);
+	ion_info->attached = false;
+
+	mutex_unlock(&iommu_info->iommu_mutex);
+}
+
+static int vpu_ion_destroy(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
+
+	vpu_ion_detach(iommu_info);
+	kfree(ion_info);
+	iommu_info->private = NULL;
+
+	return 0;
+}
+
+static int
+vpu_ion_free(struct vpu_iommu_session_info *session_info, int idx)
+{
+	struct vpu_ion_buffer *ion_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
+
+	if (!ion_buffer) {
+		mutex_unlock(&session_info->list_mutex);
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	list_del_init(&ion_buffer->list);
+	mutex_unlock(&session_info->list_mutex);
+	kfree(ion_buffer);
+
+	return 0;
+}
+
+static int
+vpu_ion_unmap_iommu(struct vpu_iommu_session_info *session_info, int idx)
+{
+	struct vpu_ion_buffer *ion_buffer;
+	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
+	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	ion_free(ion_info->ion_client, ion_buffer->handle);
+
+	return 0;
+}
+
+static int
+vpu_ion_map_iommu(struct vpu_iommu_session_info *session_info, int idx,
+		  unsigned long *iova, unsigned long *size)
+{
+	struct vpu_ion_buffer *ion_buffer;
+	struct device *dev = session_info->dev;
+	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
+	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
+					      int ret = 0;
+
+	/* Force to flush iommu table */
+	rockchip_iovmm_invalidate_tlb(session_info->dev);
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	if (session_info->mmu_dev)
+		ret = ion_map_iommu(dev, ion_info->ion_client,
+				    ion_buffer->handle, iova, size);
+	else
+		ret = ion_phys(ion_info->ion_client, ion_buffer->handle,
+			       iova, (size_t *)size);
+
+	return ret;
+}
+
+static int
+vpu_ion_unmap_kernel(struct vpu_iommu_session_info *session_info,
+		     int idx)
+{
+	struct vpu_ion_buffer *ion_buffer;
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void*
+vpu_ion_map_kernel(struct vpu_iommu_session_info *session_info, int idx)
+{
+	struct vpu_ion_buffer *ion_buffer;
+	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
+	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
+
+	rockchip_iovmm_invalidate_tlb(session_info->dev);
+
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
+	mutex_unlock(&session_info->list_mutex);
+
+	if (!ion_buffer) {
+		pr_err("%s can not find %d buffer in list\n", __func__, idx);
+
+		return NULL;
+	}
+
+	return ion_map_kernel(ion_info->ion_client, ion_buffer->handle);
+}
+
+static int vpu_ion_alloc(struct vpu_iommu_session_info *session_info,
+			 unsigned long size,
+			 unsigned long align)
+{
+	struct vpu_ion_buffer *ion_buffer = NULL;
+	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
+	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
+	unsigned int heap_id_mask;
+
+	if (iommu_info->mmu_dev)
+		heap_id_mask = ION_HEAP_TYPE_SYSTEM;
+	else
+		heap_id_mask = ION_HEAP_TYPE_DMA;
+
+	ion_buffer = kzalloc(sizeof(*ion_buffer), GFP_KERNEL);
+	if (!ion_buffer)
+		return -ENOMEM;
+
+	ion_buffer->handle = ion_alloc(ion_info->ion_client, size,
+				       align, heap_id_mask, 0);
+
+	INIT_LIST_HEAD(&ion_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer->index = session_info->max_idx;
+	list_add_tail(&ion_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return ion_buffer->index;
+}
+
+static int
+vpu_ion_import(struct vpu_iommu_session_info *session_info, int fd)
+{
+	struct vpu_ion_buffer *ion_buffer = NULL;
+	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
+	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
+
+	ion_buffer = kzalloc(sizeof(*ion_buffer), GFP_KERNEL);
+	if (!ion_buffer)
+		return -ENOMEM;
+
+	ion_buffer->handle = ion_import_dma_buf(ion_info->ion_client, fd);
+
+	INIT_LIST_HEAD(&ion_buffer->list);
+	mutex_lock(&session_info->list_mutex);
+	ion_buffer->index = session_info->max_idx;
+	list_add_tail(&ion_buffer->list, &session_info->buffer_list);
+	session_info->max_idx++;
+	if ((session_info->max_idx & 0xfffffff) == 0)
+		session_info->max_idx = 0;
+	mutex_unlock(&session_info->list_mutex);
+
+	return ion_buffer->index;
+}
+
+static int vpu_ion_create(struct vpu_iommu_info *iommu_info)
+{
+	struct vpu_iommu_ion_info *ion_info;
+
+	iommu_info->private = kmalloc(sizeof(*ion_info), GFP_KERNEL);
+
+	ion_info = iommu_info->private;
+	if (!ion_info)
+		return -ENOMEM;
+
+	ion_info->ion_client = rockchip_ion_client_create("vpu");
+	ion_info->attached = false;
+
+	vpu_ion_attach(iommu_info);
+
+	return IS_ERR(ion_info->ion_client) ? -1 : 0;
+}
+
+#else
+
+static void
+vpu_ion_clear_session(struct vpu_iommu_session_info *session_info)
+{
+	/* do nothing */
+}
+
+static int vpu_ion_attach(struct vpu_iommu_info *iommu_info)
+{
+	return 0;
+}
+
+static void vpu_ion_detach(struct vpu_iommu_info *iommu_info)
+{
+}
+
+static int vpu_ion_destroy(struct vpu_iommu_info *iommu_info)
+{
+	return 0;
+}
+
+static int
+vpu_ion_free(struct vpu_iommu_session_info *session_info, int idx)
+{
+	return 0;
+}
+
+static int
+vpu_ion_unmap_iommu(struct vpu_iommu_session_info *session_info, int idx)
+{
+	return 0;
+}
+
+static int
+vpu_ion_map_iommu(struct vpu_iommu_session_info *session_info, int idx,
+		  unsigned long *iova, unsigned long *size)
+{
+	return 0;
+}
+
+static int
+vpu_ion_unmap_kernel(struct vpu_iommu_session_info *session_info,
+		     int idx)
+{
+	return 0;
+}
+
+static void*
+vpu_ion_map_kernel(struct vpu_iommu_session_info *session_info, int idx)
+{
+	return NULL;
+}
+
+static int vpu_ion_alloc(struct vpu_iommu_session_info *session_info,
+			 unsigned long size,
+			 unsigned long align)
+{
+	return 0;
+}
+
+static int
+vpu_ion_import(struct vpu_iommu_session_info *session_info, int fd)
+{
+	return 0;
+}
+
+static int vpu_ion_create(struct vpu_iommu_info *iommu_info)
+{
+	return -1;
+}
+#endif
+
+static struct vpu_iommu_ops ion_ops = {
+	.create = vpu_ion_create,
+	.destroy = vpu_ion_destroy,
+	.alloc = vpu_ion_alloc,
+	.import = vpu_ion_import,
+	.free = vpu_ion_free,
+	.free_fd = NULL,
+	.map_kernel = vpu_ion_map_kernel,
+	.unmap_kernel = vpu_ion_unmap_kernel,
+	.map_iommu = vpu_ion_map_iommu,
+	.unmap_iommu = vpu_ion_unmap_iommu,
+	.dump = NULL,
+	.attach = vpu_ion_attach,
+	.detach = vpu_ion_detach,
+	.clear = vpu_ion_clear_session,
+};
+
+/*
+ * we do not manage the ref number ourselves,
+ * since ion will help us to do that. what we
+ * need to do is just map/unmap and import/free
+ * every time
+ */
+void vpu_iommu_ion_set_ops(struct vpu_iommu_info *iommu_info)
+{
+	if (!iommu_info)
+		return;
+	iommu_info->ops = &ion_ops;
+}
diff -Nupr a/drivers/video/rockchip/vpu/vpu_iommu_ops.c b/drivers/video/rockchip/vpu/vpu_iommu_ops.c
--- a/drivers/video/rockchip/vpu/vpu_iommu_ops.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/vpu_iommu_ops.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,291 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *         Randy Li, randy.li@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/slab.h>
+
+#include "vpu_iommu_ops.h"
+
+static
+struct vpu_iommu_session_info *vpu_iommu_get_session_info(struct vpu_iommu_info *iommu_info,
+							  struct mpp_session *session)
+{
+	struct vpu_iommu_session_info *session_info = NULL, *n;
+
+	list_for_each_entry_safe(session_info, n, &iommu_info->session_list,
+				 head) {
+		if (session_info->session == session)
+			return session_info;
+	}
+
+	return NULL;
+}
+
+int vpu_iommu_create(struct vpu_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->create)
+		return -EINVAL;
+
+	return iommu_info->ops->create(iommu_info);
+}
+
+int vpu_iommu_alloc(struct vpu_iommu_info *iommu_info,
+		    struct mpp_session *session,
+		    unsigned long size,
+		    unsigned long align)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info || !iommu_info->ops->alloc || !session)
+		return -EINVAL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+	if (!session_info) {
+		session_info = kzalloc(sizeof(*session_info), GFP_KERNEL);
+		if (!session_info)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&session_info->head);
+		INIT_LIST_HEAD(&session_info->buffer_list);
+		mutex_init(&session_info->list_mutex);
+		session_info->max_idx = 0;
+		session_info->session = session;
+		session_info->mmu_dev = iommu_info->mmu_dev;
+		session_info->dev = iommu_info->dev;
+		session_info->iommu_info = iommu_info;
+		session_info->buffer_nums = 0;
+		mutex_lock(&iommu_info->list_mutex);
+		list_add_tail(&session_info->head, &iommu_info->session_list);
+		mutex_unlock(&iommu_info->list_mutex);
+	}
+
+	session_info->debug_level = iommu_info->debug_level;
+
+	return iommu_info->ops->alloc(session_info, size, align);
+}
+
+int vpu_iommu_import(struct vpu_iommu_info *iommu_info,
+		     struct mpp_session *session, int fd)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	if (!iommu_info || !iommu_info->ops->import || !session)
+		return -EINVAL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+	if (!session_info) {
+		session_info = kzalloc(sizeof(*session_info), GFP_KERNEL);
+		if (!session_info)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&session_info->head);
+		INIT_LIST_HEAD(&session_info->buffer_list);
+		mutex_init(&session_info->list_mutex);
+		session_info->max_idx = 0;
+		session_info->session = session;
+		session_info->mmu_dev = iommu_info->mmu_dev;
+		session_info->dev = iommu_info->dev;
+		session_info->iommu_info = iommu_info;
+		session_info->buffer_nums = 0;
+		mutex_lock(&iommu_info->list_mutex);
+		list_add_tail(&session_info->head, &iommu_info->session_list);
+		mutex_unlock(&iommu_info->list_mutex);
+	}
+
+	session_info->debug_level = iommu_info->debug_level;
+
+	return iommu_info->ops->import(session_info, fd);
+}
+
+int vpu_iommu_free(struct vpu_iommu_info *iommu_info,
+		   struct mpp_session *session, int idx)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->free || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->free(session_info, idx);
+}
+
+int vpu_iommu_free_fd(struct vpu_iommu_info *iommu_info,
+		      struct mpp_session *session, int fd)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->free_fd || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->free_fd(session_info, fd);
+}
+
+void *vpu_iommu_map_kernel(struct vpu_iommu_info *iommu_info,
+			   struct mpp_session *session, int idx)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->map_kernel || !session_info)
+		return NULL;
+
+	return iommu_info->ops->map_kernel(session_info, idx);
+}
+
+int vpu_iommu_unmap_kernel(struct vpu_iommu_info *iommu_info,
+			   struct mpp_session *session, int idx)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->unmap_kernel || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->unmap_kernel(session_info, idx);
+}
+
+int vpu_iommu_map_iommu(struct vpu_iommu_info *iommu_info,
+			struct mpp_session *session,
+			int idx, unsigned long *iova,
+			unsigned long *size)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->map_iommu || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->map_iommu(session_info, idx, iova, size);
+}
+
+int vpu_iommu_unmap_iommu(struct vpu_iommu_info *iommu_info,
+			  struct mpp_session *session, int idx)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->unmap_iommu || !session_info)
+		return -EINVAL;
+
+	return iommu_info->ops->unmap_iommu(session_info, idx);
+}
+
+int vpu_iommu_destroy(struct vpu_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->destroy)
+		return -EINVAL;
+
+	return iommu_info->ops->destroy(iommu_info);
+}
+
+void vpu_iommu_dump(struct vpu_iommu_info *iommu_info,
+		    struct mpp_session *session)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->dump || !session_info)
+		return;
+
+	iommu_info->ops->dump(session_info);
+}
+
+void vpu_iommu_clear(struct vpu_iommu_info *iommu_info,
+		     struct mpp_session *session)
+{
+	struct vpu_iommu_session_info *session_info = NULL;
+
+	session_info = vpu_iommu_get_session_info(iommu_info, session);
+
+	if (!iommu_info || !iommu_info->ops->clear || !session_info)
+		return;
+
+	iommu_info->ops->clear(session_info);
+
+	mutex_lock(&iommu_info->list_mutex);
+	list_del_init(&session_info->head);
+	kfree(session_info);
+	mutex_unlock(&iommu_info->list_mutex);
+}
+
+int vpu_iommu_attach(struct vpu_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->attach)
+		return 0;
+
+	return iommu_info->ops->attach(iommu_info);
+}
+
+void vpu_iommu_detach(struct vpu_iommu_info *iommu_info)
+{
+	if (!iommu_info || !iommu_info->ops->detach)
+		return;
+
+	return iommu_info->ops->detach(iommu_info);
+}
+
+struct vpu_iommu_info*
+vpu_iommu_info_create(struct device *dev,
+		      struct device *mmu_dev,
+		      int alloc_type)
+{
+	struct vpu_iommu_info *iommu_info = NULL;
+
+	iommu_info = kzalloc(sizeof(*iommu_info), GFP_KERNEL);
+	if (!iommu_info)
+		return NULL;
+
+	iommu_info->dev = dev;
+	INIT_LIST_HEAD(&iommu_info->session_list);
+	mutex_init(&iommu_info->list_mutex);
+	mutex_init(&iommu_info->iommu_mutex);
+	switch (alloc_type) {
+#ifdef CONFIG_DRM
+	case ALLOCATOR_USE_DRM:
+		vpu_iommu_drm_set_ops(iommu_info);
+		break;
+#endif
+#ifdef CONFIG_ION
+	case ALLOCATOR_USE_ION:
+		vpu_iommu_ion_set_ops(iommu_info);
+		break;
+#endif
+	default:
+		iommu_info->ops = NULL;
+		break;
+	}
+
+	iommu_info->mmu_dev = mmu_dev;
+
+	vpu_iommu_create(iommu_info);
+
+	return iommu_info;
+}
+
+int vpu_iommu_info_destroy(struct vpu_iommu_info *iommu_info)
+{
+	vpu_iommu_destroy(iommu_info);
+	kfree(iommu_info);
+
+	return 0;
+}
diff -Nupr a/drivers/video/rockchip/vpu/vpu_iommu_ops.h b/drivers/video/rockchip/vpu/vpu_iommu_ops.h
--- a/drivers/video/rockchip/vpu/vpu_iommu_ops.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/vpu/vpu_iommu_ops.h	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,139 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Jung Zhao jung.zhao@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __VPU_IOMMU_OPS_H__
+#define __VPU_IOMMU_OPS_H__
+
+#include <linux/platform_device.h>
+#include "mpp_service.h"
+
+#define BUFFER_LIST_MAX_NUMS	30
+
+#define ALLOCATOR_USE_ION		0x00000000
+#define ALLOCATOR_USE_DRM		0x00000001
+
+#define DEBUG_IOMMU_OPS_DUMP	0x00020000
+#define DEBUG_IOMMU_NORMAL	0x00040000
+
+#define vpu_iommu_debug_func(debug_level, type, fmt, args...)	\
+	do {							\
+		if (unlikely((debug_level) & type)) {		\
+			pr_info("%s:%d: " fmt,			\
+				 __func__, __LINE__, ##args);	\
+		}						\
+	} while (0)
+#define vpu_iommu_debug(debug_level, type, fmt, args...)	\
+	do {							\
+		if (unlikely((debug_level) & type)) {		\
+			pr_info(fmt, ##args);			\
+		}						\
+	} while (0)
+
+struct vpu_iommu_info;
+struct vpu_iommu_session_info;
+
+struct vpu_iommu_ops {
+	int (*create)(struct vpu_iommu_info *iommu_info);
+	int (*alloc)(struct vpu_iommu_session_info *session_info,
+		     unsigned long size,
+		     unsigned long align);
+	int (*import)(struct vpu_iommu_session_info *session_info, int fd);
+	int (*free)(struct vpu_iommu_session_info *session_info, int idx);
+	int (*free_fd)(struct vpu_iommu_session_info *session_info, int fd);
+	void* (*map_kernel)(struct vpu_iommu_session_info *session_info,
+			    int idx);
+	int (*unmap_kernel)(struct vpu_iommu_session_info *session_info,
+			    int idx);
+	int (*map_iommu)(struct vpu_iommu_session_info *session_info,
+			 int idx,
+			 unsigned long *iova, unsigned long *size);
+	int (*unmap_iommu)(struct vpu_iommu_session_info *session_info,
+			   int idx);
+	int (*destroy)(struct vpu_iommu_info *iommu_info);
+	void (*dump)(struct vpu_iommu_session_info *session_info);
+	int (*attach)(struct vpu_iommu_info *iommu_info);
+	void (*detach)(struct vpu_iommu_info *iommu_info);
+	void (*clear)(struct vpu_iommu_session_info *session_info);
+};
+
+struct vpu_iommu_session_info {
+	struct list_head head;
+	struct mpp_session *session;
+	int buffer_nums;
+	struct list_head buffer_list;
+	struct mutex list_mutex;
+	int max_idx;
+	struct device *dev;
+	struct device *mmu_dev;
+	struct vpu_iommu_info *iommu_info;
+	int debug_level;
+};
+
+struct vpu_iommu_info {
+	struct list_head session_list;
+	struct mutex list_mutex;
+	struct mutex iommu_mutex;
+	struct device *dev;
+	struct device *mmu_dev;
+	struct vpu_iommu_ops *ops;
+	int debug_level;
+	void *private;
+};
+
+#ifdef CONFIG_DRM
+void vpu_iommu_drm_set_ops(struct vpu_iommu_info *iommu_info);
+#endif
+#ifdef CONFIG_ION
+void vpu_iommu_ion_set_ops(struct vpu_iommu_info *iommu_info);
+#endif
+
+struct vpu_iommu_info *vpu_iommu_info_create(struct device *dev,
+					     struct device *mmu_dev,
+					     int alloc_type);
+int vpu_iommu_info_destroy(struct vpu_iommu_info *iommu_info);
+
+int vpu_iommu_create(struct vpu_iommu_info *iommu_info);
+int vpu_iommu_alloc(struct vpu_iommu_info *iommu_info,
+		    struct mpp_session *session,
+		    unsigned long size,
+		    unsigned long align);
+int vpu_iommu_import(struct vpu_iommu_info *iommu_info,
+		     struct mpp_session *session, int fd);
+int vpu_iommu_free(struct vpu_iommu_info *iommu_info,
+		   struct mpp_session *session, int idx);
+int vpu_iommu_free_fd(struct vpu_iommu_info *iommu_info,
+		      struct mpp_session *session, int fd);
+void *vpu_iommu_map_kernel(struct vpu_iommu_info *iommu_info,
+			   struct mpp_session *session, int idx);
+int vpu_iommu_unmap_kernel(struct vpu_iommu_info *iommu_info,
+			   struct mpp_session *session, int idx);
+int vpu_iommu_map_iommu(struct vpu_iommu_info *iommu_info,
+			struct mpp_session *session,
+			int idx,
+			unsigned long *iova,
+			unsigned long *size);
+int vpu_iommu_unmap_iommu(struct vpu_iommu_info *iommu_info,
+			  struct mpp_session *session,
+			  int idx);
+int vpu_iommu_destroy(struct vpu_iommu_info *iommu_info);
+void vpu_iommu_dump(struct vpu_iommu_info *iommu_info,
+		    struct mpp_session *session);
+void vpu_iommu_clear(struct vpu_iommu_info *iommu_info,
+		     struct mpp_session *session);
+
+int vpu_iommu_attach(struct vpu_iommu_info *iommu_info);
+void vpu_iommu_detach(struct vpu_iommu_info *iommu_info);
+
+#endif
diff -Nupr a/drivers/video/rockchip/wimo.c b/drivers/video/rockchip/wimo.c
--- a/drivers/video/rockchip/wimo.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/video/rockchip/wimo.c	2019-05-09 14:31:56.000000000 +0800
@@ -0,0 +1,1261 @@
+/* drivers/video/wimo.c
+ *
+ * Copyright (C) 2010 ROCKCHIP, Inc.
+ * author: chenhengming chm@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/list.h>
+#include <linux/debugfs.h>
+#include <linux/mempolicy.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/cacheflush.h>
+#include <linux/fb.h>
+#include <plat/ipp.h>
+#include "linux/wimo.h"
+#include<linux/rk_fb.h>
+#define WIMO_MIN_ALLOC               PAGE_SIZE
+#define WIMO_IS_PAGE_ALIGNED(addr)   (!((addr) & (~PAGE_MASK)))
+
+#define WIMO_DEBUG                   0
+#define WIMO_DEBUG_MSGS              0
+
+#if WIMO_DEBUG_MSGS
+#define DLOG(fmt,args...) \
+	do { printk(KERN_INFO "[%s:%s:%d] "fmt, __FILE__, __func__, __LINE__, \
+		    ##args); } \
+	while (0)
+#else
+#define DLOG(x...) do {} while (0)
+#endif
+#define WIMO_WRITE_FILE
+
+struct win_set {
+	volatile u32 y_offset;
+	volatile u32 c_offset;
+};
+
+struct win0_par {
+    u32 refcount;
+    u32	pseudo_pal[16];
+    u32 y_offset;
+    u32 c_offset;
+    u32 xpos;         //size in panel
+    u32 ypos;
+    u32 xsize;        //start point in panel
+    u32 ysize;
+    u32 format;
+
+    wait_queue_head_t wait;
+    struct win_set mirror;
+    struct win_set displ;
+    struct win_set done;
+
+    u8 par_seted;
+    u8 addr_seted;
+};
+
+
+/**
+ * struct for global wimo info
+ */
+struct enc_buff_info{
+	u32 bitperpixel;
+	u32 mode;
+	u32 	xaff;
+	u32 	yaff;
+	u32 xpos;
+	u32 ypos;
+	u32 xsize;
+	u32 ysize;
+	u32 src_y;
+	u32 src_uv;
+	u32 dst_width;
+	u32 dst_height;
+	u32 dst_vir_w;
+	u32 dst_vir_h;
+	u32 y_offset;
+	u32 c_offset;
+	u32 src_width;
+	u32 src_height;
+	long long	Frame_Time;
+	unsigned char* ui_buffer;
+	unsigned char* ui_buffer_map;
+	int rotation_flag;
+	
+	
+};
+struct wimo_video_info{
+	u32 				bitperpixel;
+	u32 				mode;
+	u32 				xaff;
+	u32 				yaff;
+	u32 				xpos;
+	u32 				ypos;
+	u32 				xsize;
+	u32 				ysize;
+	u32 				src_y;
+	u32 				src_uv;
+	u32 				dst_width;
+	u32 				dst_height;
+	u32 				rot_dst_width;
+	u32 				rot_dst_height;
+	u32 				src_width;
+	u32 				src_height;
+	u32 				set_flag;
+	int 			Last_rotation_flag;
+	int 			rotation_flag;
+	long long	Last_Frame_Time;
+	struct timeval Wimo_RGB_time;
+	struct timeval Wimo_YUV_time;
+	struct timeval Wimo_Cur_time;
+	struct enc_buff_info enc_buff[4];
+	u32 buffer_num;
+	u32 avail_index;
+	u32 work_index;
+	volatile u32 avail_frame;
+	int test_sign;
+	u32 frame_num;
+
+};
+struct wimo_audio_info{
+	volatile u32			buffer_size;
+	volatile u32 			head_offset;
+	volatile u32 			tail_offset;
+	volatile u32 			data_len;
+	u32					nSamplePerFrame;
+	u32					nChannel;
+	u32					nBytePerSample;
+	u32					nBytePerFrame;
+	unsigned char*		Out_Buffer;
+	struct	timeval		*time_stamp;
+	unsigned char 		*audio_data;
+
+};
+struct wimo_audio_param{
+	u32					buffer_size;
+	u32					nSamplePerFrame;
+	u32					nChannel;
+	u32					nBytePerSample;
+	u32					nBytePerFrame;
+	u32					Reserverd[7];
+};
+int rgb_time;
+int yuv_time;
+struct wimo_info{
+	struct wimo_video_info   	video_info;
+	struct wimo_audio_info		audio_info;
+	struct rw_semaphore 		rw_sem;
+	struct miscdevice 			dev;
+	int video_start_sign;
+	int audio_start_sign;
+	int start_sign;
+	int volumn_open_sign;
+	int rotation_flag;
+};
+struct mutex video_lock;
+struct mutex audio_lock;
+struct mutex wimo_lock;
+//int wimo_prepare_para(struct fb_info *info);
+//int wimo_prepare_buff(struct fb_info *info);
+//int wimo_prepare(struct fb_info *info);
+
+
+static int wimo_count = 0;
+static struct wimo_info wimo;
+#define wdm_rwsem               (wimo.rw_sem)
+extern int (*audio_data_to_wimo)(void* data,int size,int channel);
+extern int (*video_data_to_wimo)(struct fb_info *info,u32 yuv_phy[2]);
+
+unsigned long temp_vv;
+static int frame_num = 0;
+static int Is_Wimo_Loaded()
+{
+	int ret = -1;
+	if(wimo_count > 0)
+		ret = 0;
+	return ret;
+}
+static int wimo_start(void)
+{
+	int ret = 0;
+	wimo.start_sign = 1;
+	
+	return ret;
+}
+static int wimo_stop(void)
+{
+	int ret = 0;
+	
+	wimo.start_sign = 0;
+	return ret;
+}
+static int wimo_set_rotation(int rotation_flag)
+{
+	int ret = 0;
+	
+	wimo.rotation_flag = rotation_flag;
+	return ret;
+}
+struct file* wimo_filp;
+mm_segment_t old_fs;
+struct file* wimo_filp_output;
+mm_segment_t old_fs_output;
+static int wimo_audio_open(unsigned long *temp)
+{
+	int ret = 0;
+	struct wimo_audio_info *audio_info = &wimo.audio_info;
+	struct timeval timeFirst;
+		do_gettimeofday(&timeFirst);	
+	if(wimo.start_sign == 0)
+	{
+		printk("Apk didn't start when audio start \n");
+		return -1;
+	}
+	memset(audio_info, 0, sizeof(struct wimo_audio_info));
+	wimo.audio_start_sign 			= 1;	
+	audio_info->Out_Buffer 		= NULL;
+
+	audio_info->buffer_size 		= 50;
+	audio_info->nSamplePerFrame 	= 1024;
+	audio_info->nBytePerSample		= 2;
+	audio_info->nChannel			= 2;
+	audio_info->nBytePerFrame		= 4096;
+	
+	
+	audio_info->head_offset		= 0;
+	audio_info->tail_offset 			= 0;
+	audio_info->data_len 			= 0;
+	
+	audio_info->audio_data 	= (unsigned char*)kmalloc(audio_info->buffer_size * audio_info->nBytePerFrame,GFP_KERNEL);
+	audio_info->time_stamp 	= (struct timeval*)kmalloc(audio_info->buffer_size * sizeof(struct timeval),GFP_KERNEL);
+	memset(audio_info->audio_data, 0,audio_info->buffer_size * audio_info->nBytePerFrame);
+	printk("audio_info->buffer_size * audio_info->nBytePerFrame  timestamp %d  audio_info->Out_Buffer	 %x time %lld %x %x\n",
+		audio_info->buffer_size * audio_info->nBytePerFrame,audio_info->time_stamp,audio_info->Out_Buffer,(int64_t)timeFirst.tv_sec*1000000ll + timeFirst.tv_usec
+		,__pa(audio_info->audio_data),__pa(audio_info->time_stamp));
+	#ifdef	WIMO_WRITE_FILE
+	wimo_filp = NULL;
+	wimo_filp = filp_open("/data/test/input_cmp.pcm",O_CREAT|O_TRUNC|O_RDWR,0);
+	if (wimo_filp)
+ 	{
+	  old_fs = get_fs();
+	  set_fs(get_ds());
+	}
+	wimo_filp_output = NULL;
+	wimo_filp_output = filp_open("/data/test/output_cmp.pcm",O_CREAT|O_TRUNC|O_RDWR,0);
+	if (wimo_filp_output)
+ 	{
+	  old_fs_output = get_fs();
+	  set_fs(get_ds());
+	}
+	#endif
+	return ret;
+}
+static int wimo_audio_close(void)
+{
+	int ret = 0;
+	struct wimo_audio_info *audio_info = &wimo.audio_info;
+	#ifdef	WIMO_WRITE_FILE
+	set_fs(old_fs);
+  	filp_close(wimo_filp,NULL);
+
+	set_fs(old_fs_output);
+  	filp_close(wimo_filp_output,NULL);
+
+	#endif
+	printk("wimo_audio_close\n");
+	kfree((void *)audio_info->time_stamp);
+	kfree((void *)audio_info->audio_data);
+	
+	audio_info->Out_Buffer 	= NULL;
+	wimo.audio_start_sign 		= 0;
+	return ret;
+}
+static void wimo_audio_set_para(struct wimo_audio_param *param)
+{
+	struct wimo_audio_info *audio_info = &wimo.audio_info;
+	audio_info->buffer_size 		= param->buffer_size;
+	audio_info->nSamplePerFrame 	= param->nSamplePerFrame;
+	audio_info->nChannel 			= param->nChannel;
+	audio_info->nBytePerSample 	= param->nBytePerSample;
+	audio_info->nBytePerFrame 		= param->nBytePerFrame;
+	DLOG("param %d %d %d %d %d  audio_info %d %d %d %d %d",
+		param->buffer_size,param->nSamplePerFrame,param->nChannel,param->nBytePerSample,param->nBytePerFrame,
+		audio_info->buffer_size,audio_info->nSamplePerFrame,audio_info->nChannel,audio_info->nBytePerSample,audio_info->nBytePerFrame);
+	return;
+}
+
+static void wimo_audio_set_vol(u32 temp_data)
+{
+	wimo.volumn_open_sign = temp_data;
+	return;
+}
+static int wimo_audio_find_frame()
+{
+	struct wimo_audio_info *audio_info = &wimo.audio_info;
+	int ret = 0;
+	if(audio_info->data_len >= 1)
+	{
+		audio_info->Out_Buffer = (void*)(&audio_info->audio_data[audio_info->head_offset * audio_info->nBytePerFrame]);
+		//wimo_filp_output->f_op->write(wimo_filp_output, audio_info->Out_Buffer, audio_info->nBytePerFrame, &wimo_filp_output->f_pos);
+		audio_info->data_len --;
+		audio_info->head_offset ++;
+		audio_info->head_offset %= audio_info->buffer_size;
+	}
+	else
+	{
+		ret = -1;
+	}
+	
+	return ret;
+}
+static int wimo_audio_prepare(void* data,int size,int channel)
+{
+	int ret = 0;
+	mutex_lock(&audio_lock);
+	
+	if(wimo.audio_start_sign && wimo.start_sign)
+	{
+		struct timeval timeFirst;
+		unsigned long* temp = (unsigned long*)data;
+		struct wimo_audio_info *audio_info = &wimo.audio_info;
+		unsigned char* buf = data;
+		do_gettimeofday(&timeFirst);	
+		memcpy((void*)(&audio_info->audio_data[audio_info->tail_offset * audio_info->nBytePerFrame]), (void*)data,size);
+		memcpy((void*)(&audio_info->time_stamp[audio_info->tail_offset]),(void*)(&timeFirst),sizeof(struct timeval));
+		audio_info->tail_offset ++;
+		audio_info->tail_offset %= audio_info->buffer_size;
+		wimo_filp->f_op->write(wimo_filp, data, size, &wimo_filp->f_pos);
+		if(audio_info->data_len + 1 < audio_info->buffer_size)
+		{
+			audio_info->data_len ++;
+		}
+		else
+		{
+			audio_info->head_offset=audio_info->tail_offset;
+			audio_info->data_len = audio_info->buffer_size;
+		}
+//		if(wimo.volumn_open_sign==0)
+//		{
+//			memset((void*)data,0,size);
+//
+//		}
+	}		
+	else
+	{
+		//DLOG("wimo_video not open\n");
+		ret = AUDIO_ENCODER_CLOSED;
+	}
+	if(wimo.start_sign && wimo.volumn_open_sign == 0)
+		memset((void*)data,0,size);
+	
+	mutex_unlock(&audio_lock);
+	return ret;
+}
+/*
+	wimo_video can be opened once at a time.
+	Other user must wait for last open closed.
+*/
+static int wimo_video_open(unsigned long *temp)
+{
+	struct wimo_video_info *video_info = &wimo.video_info;
+	int i;
+	int ret =0 ;
+	printk("wimo_video_open\n");
+	if(wimo.start_sign == 0)
+	{
+		printk("Apk didn't start when video start ");
+		return -1;
+	}
+	if(wimo.video_start_sign == 1)
+	{
+		printk("last wimo_video still opened ,something wrong\n");
+		
+	}
+	memset(&wimo.video_info,0,sizeof(struct wimo_video_info));
+	if(wimo.rotation_flag < 0 )
+		DLOG("wimo_set_buff rotation_flag < 0,maybe something wrong\n");
+		
+	video_info->Last_rotation_flag = -1;
+	video_info->rotation_flag = wimo.rotation_flag;
+ 	for(i = 0; i < temp[3]; i++)
+	{
+		video_info->enc_buff[i].ui_buffer= (unsigned char*)temp[i+4];
+		video_info->enc_buff[i].ui_buffer_map= ioremap(temp[i+4],temp[2]);
+		if(video_info->enc_buff[i].ui_buffer_map == NULL)
+		{
+			printk("can't map a buffer for ui\n");
+			return -EFAULT;
+		}
+	}
+	video_info->buffer_num = temp[3];
+	video_info->dst_width 	= (temp[0] + 15) & 0xfff0;
+	video_info->dst_height 	= (temp[1] + 15) & 0xfff0;
+	video_info->xsize 		= video_info->dst_width;
+	video_info->ysize 		= video_info->dst_height;
+	wimo.video_start_sign = 1;	
+	printk("video_info->dst_width %d video_info->dst_height %d num %d %x ui_buffer %x %x   size %d map %x %x\n",
+		video_info->dst_width,video_info->dst_height,video_info->buffer_num,(long)&wimo.video_info.buffer_num,
+		video_info->enc_buff[0].ui_buffer,video_info->enc_buff[1].ui_buffer,temp[2],video_info->enc_buff[0].ui_buffer_map
+		,video_info->enc_buff[1].ui_buffer_map);
+	rgb_time = yuv_time = 0;
+	return ret;
+}
+/*
+close wimo_video .
+release resources.
+
+*/
+static int wimo_video_close(struct wimo_video_info *video_info)
+{
+	int i ;
+	int ret = 0;
+	if(video_info->buffer_num && wimo.video_start_sign && wimo.start_sign)
+		printk("something is okay with wimo video in close");
+		
+	else
+		printk("somethint wrong with wimo video in close");
+	wimo.video_start_sign = 0;
+	DLOG("video_info->dst_width %d video_info->dst_height %d ui_buffer %x %x  ui_buffer_map %x %x\n",
+		video_info->dst_width,video_info->dst_height,video_info->enc_buff[0].ui_buffer,video_info->enc_buff[1].ui_buffer,
+		video_info->enc_buff[0].ui_buffer_map,video_info->enc_buff[1].ui_buffer_map);
+	
+	for(i = 0; i < 4; i++)
+	{	
+		DLOG("closebuf ui_buffer %x ui_buffer_map %x  ui_buffer_map addr %x wimo_info.buffer_num %d i %d\n",
+			(unsigned int)video_info->enc_buff[i].ui_buffer,(unsigned int)video_info->enc_buff[i].ui_buffer_map,(unsigned long)(&video_info->enc_buff[i].ui_buffer_map),video_info->buffer_num,i);
+		if(video_info->enc_buff[i].ui_buffer_map!=0)
+		{
+			iounmap(video_info->enc_buff[i].ui_buffer_map);
+			video_info->enc_buff[i].ui_buffer_map = 0;
+			video_info->enc_buff[i].ui_buffer = 0;
+		}
+	}
+	return ret;
+}
+
+/*
+get video frame 
+it return -1  when no frame is availiable
+*/
+static int wimo_video_find_frame(unsigned long* temp_data,struct wimo_video_info *video_info)
+{
+	
+	int ret = 0;
+	do_gettimeofday(&video_info->Wimo_Cur_time);
+	DLOG("wimo_find_frame video_info %x video_info->buffer_num %d avail_index %d avail_frame %d work_index %d  testIgn %d time %lld curtime %lld last_time %lld %lld %lld yuv rgb time %lld %lld  yuv_time %d\n",
+		(unsigned long)video_info,video_info->buffer_num, video_info->avail_index,video_info->avail_frame,video_info->work_index,video_info->test_sign,video_info->enc_buff[video_info->avail_index].Frame_Time,
+		(long long)video_info->Wimo_Cur_time.tv_sec * 1000000ll + video_info->Wimo_Cur_time.tv_usec,video_info->Last_Frame_Time,video_info->enc_buff[video_info->avail_index].Frame_Time,
+		video_info->enc_buff[1-video_info->avail_index].Frame_Time,(long long)video_info->Wimo_YUV_time.tv_sec * 1000000ll + video_info->Wimo_YUV_time.tv_usec
+		,(long long)video_info->Wimo_RGB_time.tv_sec * 1000000ll + video_info->Wimo_RGB_time.tv_usec,yuv_time);
+	if(video_info->avail_frame)
+	{
+		if(video_info->Last_Frame_Time >  video_info->enc_buff[video_info->avail_index].Frame_Time)
+		{
+			
+			DLOG("wimo_find_frame error avail_index %d avail_frame %d work_index %d  testIgn %d time %lld curtime %lld last_time %lld %lld %lld yuv rgb time %lld %lld  yuv_time %d\n",
+				video_info->avail_index,video_info->avail_frame,video_info->work_index,video_info->test_sign,video_info->enc_buff[video_info->avail_index].Frame_Time,
+			(long long)video_info->Wimo_Cur_time.tv_sec * 1000000ll + video_info->Wimo_Cur_time.tv_usec,video_info->Last_Frame_Time,video_info->enc_buff[video_info->avail_index].Frame_Time,
+				video_info->enc_buff[1-video_info->avail_index].Frame_Time,(long long)video_info->Wimo_YUV_time.tv_sec * 1000000ll + video_info->Wimo_YUV_time.tv_usec
+				,(long long)video_info->Wimo_RGB_time.tv_sec * 1000000ll + video_info->Wimo_RGB_time.tv_usec,yuv_time);
+			video_info->test_sign = 2;
+		}
+		video_info->Last_Frame_Time = video_info->enc_buff[video_info->avail_index].Frame_Time;
+		
+	}
+	else
+	{
+		if(((long long)video_info->Wimo_Cur_time.tv_sec * 1000000ll + video_info->Wimo_Cur_time.tv_usec  >   video_info->Last_Frame_Time + 1000000ll || video_info->frame_num < 30) && video_info->frame_num!=0)
+		{
+			
+			DLOG("wimo_find_frame wait  second avail_index %d avail_frame %d work_index %d  testIgn %d time %lld curtime %lld last_time %lld %lld %lld yuv rgb time %lld %lld  yuv_time %d\n",
+				video_info->avail_index,video_info->avail_frame,video_info->work_index,
+				video_info->test_sign,video_info->enc_buff[video_info->avail_index].Frame_Time,
+			(long long)video_info->Wimo_Cur_time.tv_sec * 1000000ll + video_info->Wimo_Cur_time.tv_usec,video_info->Last_Frame_Time,video_info->enc_buff[video_info->avail_index].Frame_Time,
+				video_info->enc_buff[1- video_info->avail_index].Frame_Time,(long long)video_info->Wimo_YUV_time.tv_sec * 1000000ll + video_info->Wimo_YUV_time.tv_usec
+				,(long long)video_info->Wimo_RGB_time.tv_sec * 1000000ll + video_info->Wimo_RGB_time.tv_usec,yuv_time);
+			video_info->test_sign = 3;
+			video_info->Last_Frame_Time =(long long)video_info->Wimo_Cur_time.tv_sec * 1000000ll + video_info->Wimo_Cur_time.tv_usec;
+			if(video_info->mode == 0 )
+			{
+				video_info->Wimo_RGB_time.tv_sec = video_info->Wimo_Cur_time.tv_sec;
+				video_info->Wimo_RGB_time.tv_usec = video_info->Wimo_Cur_time.tv_usec;
+			}
+			
+			video_info->avail_index--;
+			video_info->avail_index %= video_info->buffer_num;
+			video_info->avail_frame++;
+			
+		}
+		else
+		{
+			video_info->test_sign = 4;
+			DLOG ("no avail frame \n");
+			return -1;
+		}
+		
+	}
+	temp_data[0] = (video_info->enc_buff[video_info->avail_index].bitperpixel << 16);
+	temp_data[0] |= video_info->enc_buff[video_info->avail_index].mode;
+	
+	temp_data[1] = video_info->avail_index ;
+	memcpy(&temp_data[2],&video_info->enc_buff[video_info->avail_index].Frame_Time,8);
+	temp_data[4] = video_info->enc_buff[video_info->avail_index].rotation_flag| (yuv_time<<16);
+	temp_data[5] = video_info->Wimo_Cur_time.tv_sec;
+	temp_data[6] = video_info->Wimo_Cur_time.tv_usec;
+
+	video_info->avail_index++;
+	video_info->avail_index %= video_info->buffer_num;
+	video_info->avail_frame--;
+	video_info->frame_num++;
+	yuv_time = rgb_time = 0;
+	
+	return ret;
+}
+
+#if 1
+ int wimo_prepare_para(struct fb_info *info,struct wimo_video_info *video_info,struct enc_buff_info *enc_buff)
+{
+	
+	//struct rk29fb_inf *inf = dev_get_drvdata(info->device);
+	struct rk_fb_inf *inf = dev_get_drvdata(info->device);
+	struct fb_var_screeninfo *var = &info->var;
+	int ret = 0;
+	struct layer_par *par = NULL;	
+	struct fb_fix_screeninfo * fix = &info->fix;
+	struct rk_lcdc_device_driver *dev_drv = (struct rk_lcdc_device_driver *)info->par;		
+	int layer_id = 0;		
+	layer_id = get_fb_layer_id(fix);		
+	if (layer_id < 0) 
+	{			
+		return -ENODEV;		
+	} 
+	else 
+	{			
+		par = dev_drv->layer_par[layer_id];		
+	}
+	video_info->mode = inf->video_mode;
+	video_info->src_width =  var->xres_virtual;
+	video_info->src_height = var->yres_virtual/2;
+	if(inf->video_mode == 0 )
+	{
+		
+
+		if(par->format == 1)
+		{
+			enc_buff->bitperpixel = 16;
+			enc_buff->rotation_flag = video_info->rotation_flag;
+		}
+		else
+		{
+			enc_buff->bitperpixel =32;// wimo_info.bitperpixel_fb1;
+			enc_buff->rotation_flag = video_info->rotation_flag + 8;
+		}
+		enc_buff->dst_width = video_info->dst_width;
+		enc_buff->dst_height = video_info->dst_height;
+		
+		
+		
+		enc_buff->src_width = video_info->src_width;
+		enc_buff->src_height = video_info->src_height;
+
+		
+		enc_buff->dst_vir_w = video_info->dst_width;
+		enc_buff->dst_vir_h = video_info->dst_height;
+		enc_buff->y_offset = enc_buff->c_offset = 0;
+		enc_buff->mode = 0;
+		
+		enc_buff->src_y = info->fix.smem_start + par->y_offset;//info->screen_base + par->y_offset;//info_buffer[8];
+		enc_buff->src_uv = info->fix.smem_start + par->y_offset + video_info->src_width * video_info->src_height;//dst_width*dst_height;//+ par->y_offset + dst_width*dst_height;//info_buffer[9];
+		enc_buff->Frame_Time = (long long)video_info->Wimo_RGB_time.tv_sec * 1000000ll + video_info->Wimo_RGB_time.tv_usec;
+		
+		if(0)//rotation_sign == IPP_ROT_90  || rotation_sign == IPP_ROT_270)
+		{
+			if(enc_buff->dst_vir_w > enc_buff->dst_vir_h)
+			{
+				enc_buff->dst_height = enc_buff->dst_vir_h;
+				enc_buff->dst_width = ((enc_buff->dst_vir_h * enc_buff->dst_vir_h) / enc_buff->dst_vir_w) & 0xfffc;
+				if(par->format == 1)
+					enc_buff->c_offset = enc_buff->y_offset = ((enc_buff->dst_vir_w - enc_buff->dst_width ) )  & 0xfffc; 
+
+				else
+				enc_buff->c_offset = enc_buff->y_offset = ((enc_buff->dst_vir_w - enc_buff->dst_width ) *2)  & 0xfffc; 
+				
+			}
+			else
+			{
+				enc_buff->dst_width = enc_buff->dst_vir_w;
+				enc_buff->dst_height = ((enc_buff->dst_vir_w * enc_buff->dst_vir_w) / enc_buff->dst_vir_h) ;
+				enc_buff->y_offset = (enc_buff->dst_vir_h - enc_buff->dst_height ) *  enc_buff->dst_vir_w * 2; 
+				enc_buff->c_offset = (enc_buff->dst_vir_h - enc_buff->dst_height ) * enc_buff->dst_vir_w ;  ; 
+			}
+		}
+	//	printk("width height %d %d  vir_w %d vir_h %d y_offset %d c_offset %d rotation_sign %d\n",enc_buff->dst_width,enc_buff->dst_height,enc_buff->dst_vir_w,enc_buff->dst_vir_h,enc_buff->y_offset,
+		//	enc_buff->c_offset,rotation_sign);
+	//	printk("mode 0 enc_buff.src0.w %d %d enc_buff %x enc_buff->mode %d bit %d format %d\n",enc_buff->src_width,enc_buff->src_height,(unsigned long)enc_buff
+		//	,enc_buff->mode,enc_buff->bitperpixel,par->format);
+
+	}	
+	DLOG(" test %d %d %d %d %d %d %x %x\n",enc_buff->dst_vir_w,enc_buff->dst_width,enc_buff->dst_vir_h,enc_buff->dst_height
+		,video_info->Last_rotation_flag , enc_buff->rotation_flag,
+		video_info->enc_buff[0].ui_buffer_map,video_info->enc_buff[1].ui_buffer_map);
+	if((enc_buff->dst_vir_w != enc_buff->dst_width  || enc_buff->dst_vir_h != enc_buff->dst_height )   && video_info->Last_rotation_flag != enc_buff->rotation_flag)//wimo_info.Last_rotation_flag != enc_buff->rotation_sign)
+	{
+		int i;
+		if(enc_buff->rotation_flag & 0x8)
+		{
+			for(i = 0; i < video_info->buffer_num; i++)
+			{
+				memset(video_info->enc_buff[i].ui_buffer_map,0,enc_buff->dst_vir_w * enc_buff->dst_vir_h * 4);//dst_width*dst_height);
+			}
+		}
+		else if((enc_buff->rotation_flag & 0x8 )== 0)
+		{
+			for(i = 0; i < video_info->buffer_num; i++)
+			{
+				memset(video_info->enc_buff[i].ui_buffer_map,0,enc_buff->dst_vir_w * enc_buff->dst_vir_h * 2);//dst_width*dst_height);
+			}
+		}
+	//	memset(ui_buffer_map,0,enc_buff->dst_vir_w * enc_buff->dst_vir_h * 4);//dst_width*dst_height);
+		//memset(ui_buffer_map + enc_buff->dst_height * enc_buff->dst_width, 0x80,enc_buff->dst_height * enc_buff->dst_width / 2);//dst_width*dst_height,0x80,dst_width*dst_height/2);
+	//	printk("rotation change wimo_info.Last_rotation_flag %d enc_buff->rotation_sign %d\n",wimo_info.Last_rotation_flag,enc_buff->rotation_sign);
+	}
+	video_info->Last_rotation_flag = enc_buff->rotation_flag;
+	
+	return ret;
+}
+ int wimo_prepare_buff(struct enc_buff_info *enc_buff)
+{
+	
+	struct rk29_ipp_req overlay_req;
+	struct rk29_ipp_req overlay_req_1;
+	int err = 0;
+	
+	memset(&overlay_req, 0 , sizeof(overlay_req));
+	memset(&overlay_req_1, 0 , sizeof(overlay_req_1));
+	//printk("inf->video_mode %d\n",inf->video_mode);	
+	if(enc_buff->mode == 0 )
+	{
+		
+		overlay_req.src0.YrgbMst = enc_buff->src_y;//info->fix.smem_start + par->y_offset;//info->screen_base + par->y_offset;//info_buffer[8];
+		overlay_req.src0.CbrMst =  enc_buff->src_uv;//info->fix.smem_start + par->y_offset + enc_buff->src_width * enc_buff->src_height;//dst_width*dst_height;//+ par->y_offset + dst_width*dst_height;//info_buffer[9];
+		overlay_req.src0.w = enc_buff->src_width ;//dst_width;//info_buffer[2];
+		overlay_req.src0.h = enc_buff->src_height ;//dst_height;//info_buffer[3];
+		overlay_req.src0.fmt = (enc_buff->bitperpixel == 16) ? 1 : 0;//3;
+		overlay_req.dst0.YrgbMst = (unsigned long)(enc_buff->ui_buffer + enc_buff->y_offset);//overlay_buffer + info_buffer[4] + info_buffer[5] * dst_width;
+		overlay_req.dst0.CbrMst = (unsigned long)(enc_buff->ui_buffer + enc_buff->dst_vir_w * enc_buff->dst_height +  enc_buff->c_offset);//dst_width*dst_height;//(unsigned char*) overlay_buffer + dst_width*dst_height +info_buffer[4] + (  info_buffer[5] * dst_width) / 2;// info_buffer[6] * info_buffer[7];
+
+		overlay_req.dst0.w = enc_buff->dst_width ;//dst_width;//info_buffer[6];
+		overlay_req.dst0.h = enc_buff->dst_height ;//dst_height;//info_buffer[7];
+		overlay_req.dst0.fmt = (enc_buff->bitperpixel== 16) ? 1 : 0;//3;3;
+		overlay_req.deinterlace_enable = 0;
+		overlay_req.timeout = 1000000;
+		overlay_req.src_vir_w = enc_buff->src_width ;//dst_width;//info_buffer[2];
+		overlay_req.dst_vir_w = enc_buff->dst_vir_w ;//dst_width; 
+
+		
+		//printk("mode 0 overlay_req.src0.w %d %d enc_buff %x\n",overlay_req.src0.w,overlay_req.src0.h,(unsigned long)enc_buff);
+		overlay_req.flag = enc_buff->rotation_flag & 0x7;
+		err = ipp_blit_sync(&overlay_req);
+		if(err)
+				goto WIMO_IPP_ERROR;
+				//printk("mode 0err %d w h fmt time out %d %d %d %d",err,overlay_req.src0.w,overlay_req.src0.h,overlay_req.src0.fmt,overlay_req.timeout);
+		//		printk("overlay_req.dst0.w %d overlay_req.dst0.h %d overlay_req.src0.w %d overlay_req.src0.h %d\n",overlay_req.dst0.w,overlay_req.dst0.h,overlay_req.src0.w,overlay_req.src0.h);
+
+		
+		
+		
+		
+	}	
+	else
+	{
+
+	
+		if(enc_buff->xaff * 3 < enc_buff->xsize || enc_buff->yaff * 3 < enc_buff->ysize)// 3time or bigger scale up
+		{
+			unsigned long mid_width, mid_height;
+			struct rk29_ipp_req overlay_req_1;
+			if(enc_buff->xaff * 3 < enc_buff->xsize)
+				mid_width = enc_buff->xaff * 3;
+			else
+				mid_width = enc_buff->xsize;
+			
+			if(enc_buff->yaff * 3 < enc_buff->ysize)
+				mid_height =  enc_buff->yaff * 3;
+			else
+				mid_height = enc_buff->ysize;
+			overlay_req.src0.YrgbMst = enc_buff->src_y;//info_buffer[8];
+			overlay_req.src0.CbrMst = enc_buff->src_uv;//info_buffer[9];
+			overlay_req.src0.w = enc_buff->xaff;// info_buffer[2];
+			overlay_req.src0.h = enc_buff->yaff;// info_buffer[3];
+			overlay_req.src0.fmt = 3;
+			overlay_req.dst0.YrgbMst = (unsigned long)(enc_buff->ui_buffer + 2048000) ;//info_buffer[4] + info_buffer[5] * dst_width;   //2buffer
+			overlay_req.dst0.CbrMst = (unsigned long)( (unsigned char*) enc_buff->ui_buffer + mid_height * mid_width + 2048000);
+		
+			overlay_req.dst0.w = mid_width;//info_buffer[6];
+			overlay_req.dst0.h = mid_height;//info_buffer[7];
+			overlay_req.dst0.fmt = 3;
+			overlay_req.timeout = 100000;
+			overlay_req.src_vir_w = enc_buff->xaff;//info_buffer[2];
+			overlay_req.dst_vir_w = mid_width;//dst_width;
+			overlay_req.flag = IPP_ROT_0;
+
+
+
+
+			overlay_req_1.src0.YrgbMst = (unsigned long)(enc_buff->ui_buffer + 2048000);
+			overlay_req_1.src0.CbrMst = (unsigned long)((unsigned char*) enc_buff->ui_buffer + mid_height * mid_width + 2048000);
+			overlay_req_1.src0.w = mid_width;
+			overlay_req_1.src0.h = mid_height;// info_buffer[3];
+			overlay_req_1.src0.fmt = 3;
+			overlay_req_1.dst0.YrgbMst = (unsigned long)(enc_buff->ui_buffer + ((enc_buff->xpos + 1)&0xfffe) + enc_buff->ypos * enc_buff->dst_width);//info_buffer[4] + info_buffer[5] * dst_width;
+			overlay_req_1.dst0.CbrMst = (unsigned long)((unsigned char*) enc_buff->ui_buffer + enc_buff->dst_width * enc_buff->dst_height + 
+				((enc_buff->xpos + 1)&0xfffe) + ( enc_buff->ypos  / 2)* enc_buff->dst_width) ;
+			
+			overlay_req_1.dst0.w = enc_buff->xsize;//info_buffer[6];
+			overlay_req_1.dst0.h = enc_buff->ysize;//info_buffer[7];
+			overlay_req_1.dst0.fmt = 3;
+			overlay_req_1.timeout = 100000;
+			overlay_req_1.src_vir_w = mid_width;//info_buffer[2];
+			overlay_req_1.dst_vir_w = enc_buff->dst_vir_w;//dst_width;
+			overlay_req_1.flag = IPP_ROT_0;
+			
+
+			err = ipp_blit_sync(&overlay_req);
+			if(err)
+				goto WIMO_IPP_ERROR;
+			dmac_flush_range(enc_buff->ui_buffer_map,enc_buff->ui_buffer_map + enc_buff->dst_height * enc_buff->dst_width * 3/2);//dst_width*dst_height*3/2);
+			err = ipp_blit_sync(&overlay_req_1);
+			if(err)
+				goto WIMO_IPP_ERROR;
+		//	printk("err1 %d w h fmt time out %d %d %d %d workindex %d encbuff %x xaff %d yaff %d xsize %d ysize %d",
+			//	err,overlay_req.src0.w,overlay_req.src0.h,overlay_req.src0.fmt,overlay_req.timeout,wimo_info.work_index,(unsigned long)enc_buff
+			//	,enc_buff->xaff,enc_buff->yaff,enc_buff->xsize,enc_buff->ysize);
+		}
+		else
+		{
+			overlay_req.src0.YrgbMst = enc_buff->src_y;//info_buffer[8];
+			overlay_req.src0.CbrMst = enc_buff->src_uv;//info_buffer[9];
+			overlay_req.src0.w = enc_buff->xaff;// info_buffer[2];
+			overlay_req.src0.h = enc_buff->yaff;// info_buffer[3];
+			overlay_req.src0.fmt = 3;
+			overlay_req.dst0.YrgbMst = (unsigned long)(enc_buff->ui_buffer + ((enc_buff->xpos + 1)&0xfffe) + enc_buff->ypos * enc_buff->dst_width);//info_buffer[4] + info_buffer[5] * dst_width;
+			overlay_req.dst0.CbrMst = (unsigned long)((unsigned char*) enc_buff->ui_buffer +  ((enc_buff->xpos + 1)&0xfffe) + 
+				( enc_buff->ypos  / 2)* enc_buff->dst_width +  enc_buff->dst_width *  enc_buff->dst_height);
+			
+			overlay_req.dst0.w = enc_buff->xsize;//wimo_info.xsize;//wimo_info.xaff;// wimo_info.xsize;//info_buffer[6];
+			overlay_req.dst0.h = (enc_buff->ysize + 1) & 0xfffe;//(wimo_info.ysize + 1) & 0xfffe;//wimo_info.yaff;//(wimo_info.ysize + 1) & 0xfffe;//info_buffer[7];
+			overlay_req.dst0.fmt = 3;
+			overlay_req.timeout = 100000;
+			overlay_req.src_vir_w = (enc_buff->xaff + 15) & 0xfff0;//enc_buff->xaff;//info_buffer[2];
+			overlay_req.dst_vir_w = enc_buff->dst_vir_w;//wimo_info.dst_width;//wimo_info.yaff;//wimo_info.dst_width;//dst_width;
+			overlay_req.flag = IPP_ROT_0;
+			
+			
+			dmac_flush_range(enc_buff->ui_buffer_map,enc_buff->ui_buffer_map + enc_buff->dst_height *enc_buff->dst_width * 3/2);//dst_width*dst_height*3/2);
+			err = ipp_blit_sync(&overlay_req);
+			//printk("mode 1 overlay_req.src0.w %d %d overlay_req.dst0.w %d %d overlay_req.src_vir_w %d %d overlay_req.src0.YrgbMst %x %x overlay_req.dst0.YrgbMst %x %x ui_buffer %x pixel%x %x   %x  %x\n",
+			//	overlay_req.src0.w,overlay_req.src0.h,overlay_req.dst0.w,overlay_req.dst0.h,overlay_req.src_vir_w ,overlay_req.dst_vir_w,overlay_req.src0.YrgbMst,overlay_req.src0.CbrMst,
+			//	overlay_req.dst0.YrgbMst,overlay_req.dst0.CbrMst,ui_buffer,ui_buffer_map[0],ui_buffer_map[1],ui_buffer_map[1024],ui_buffer_map[1025]);
+			if(err)
+				goto WIMO_IPP_ERROR;
+			
+				//printk("err %d w h fmt time out %d %d %d %d",err,overlay_req.src0.w,overlay_req.src0.h,overlay_req.src0.fmt,overlay_req.timeout);
+		}
+	}
+	
+	
+       
+	return 0;
+WIMO_IPP_ERROR:
+	
+	return -1;
+}
+
+int wimo_video_prepare(struct fb_info *info,u32 yuv_phy[2])
+{
+	int ret = 0;
+	static int comin_time = 0;
+	if(wimo_count < 1)
+		return WIMO_COUNT_ZERO;
+	mutex_lock(&video_lock);
+	DLOG("before wimo prepare para wimo_count %d wimo.video_start_sign %d  %d %d %x %x\n"
+			,wimo_count,wimo.video_start_sign,wimo.start_sign,wimo.video_info.avail_frame,wimo.video_info.buffer_num,(long)&wimo.video_info.buffer_num);
+	if(wimo.video_start_sign && wimo.start_sign)
+	{
+		struct wimo_video_info *video_info = &wimo.video_info;
+		struct enc_buff_info *enc_buff = &video_info->enc_buff[video_info->work_index];	
+		//struct rk29fb_inf *inf = dev_get_drvdata(info->device);
+		struct rk_fb_inf *inf = dev_get_drvdata(info->device);
+		int ret;
+		if(comin_time == 1)
+		{
+			printk("ENCODER_BUFFER_FULL wimo.video_info.avail_frame %d wimo.video_info.buffer_num %d\n",wimo.video_info.avail_frame,wimo.video_info.buffer_num);
+		//	ret = ENCODER_BUFFER_FULL;
+		//	goto buffer_full;
+		}
+		comin_time++;
+		if((wimo.video_info.avail_frame>=wimo.video_info.buffer_num-1) )
+		{
+			DLOG("ENCODER_BUFFER_FULL wimo.video_info.avail_frame %d wimo.video_info.buffer_num %d\n",wimo.video_info.avail_frame,wimo.video_info.buffer_num);
+			ret = ENCODER_BUFFER_FULL;
+			goto buffer_full;
+		}
+		
+		if(inf->video_mode == 0)
+		{
+				do_gettimeofday(&wimo.video_info.Wimo_RGB_time);
+				rgb_time++;
+		}
+		else
+		{	
+			printk("videomode = %d err \n",inf->video_mode);
+		}
+		
+		
+		wimo_prepare_para(info,video_info,enc_buff);
+		ret = wimo_prepare_buff(enc_buff);
+		if(ret == 0)
+		{
+			video_info->avail_frame++;
+			//wimo_info.avail_frame%=(wimo_info.buffer_num + 1);
+			video_info->work_index++;
+			video_info->work_index%= video_info->buffer_num;
+			DLOG("prepare video_info->avail_frame %d video_info->work_index %d video_info->avail_index %d\n",video_info->avail_frame,video_info->work_index,video_info->avail_index);
+	//		if(((wimo_info.avail_index + wimo_info.avail_frame) % wimo_info.buffer_num)!=wimo_info.work_index)
+			//	DLOG("wimo_prepare_buff 2 test_sign %d avail_index %d avail_frame %d work_index %d mode %d %d time %lld %lld  bitperpixel %d src_width %d src_height %d dst_width %d dst_height %d dst_y %x dst_uv %x\n",
+			//	wimo_info.test_sign,wimo_info.avail_index,wimo_info.avail_frame,wimo_info.work_index,enc_buff[wimo_info.avail_index].mode,enc_buff[1-wimo_info.avail_index].mode,
+			//	wimo_info.enc_buff[wimo_info.avail_index].Frame_Time,
+			//		wimo_info.enc_buff[1-wimo_info.avail_index].Frame_Time,	
+			//		enc_buff->bitperpixel,enc_buff->src_width,enc_buff->src_height,enc_buff->dst_width,enc_buff->dst_height
+			//		,overlay_req.dst0.YrgbMst,overlay_req.dst0.CbrMst);
+		}
+		else
+		{
+			DLOG("Wimo_IPP_ERROR err %d  enc_buff.src0.w %x %x enc_buff %x enc_buff->mode %x format %x workindex %x xaff %x yaff %x xsize %x ysize %x yuv_num %d %x %x %x %x\n"
+				,ret,enc_buff->src_width,enc_buff->src_height,(u32)enc_buff,enc_buff->mode,enc_buff->bitperpixel,video_info->work_index,
+				enc_buff->xaff,enc_buff->yaff,enc_buff->xsize,
+				enc_buff->ysize,yuv_time,enc_buff->ui_buffer_map[0],enc_buff->ui_buffer_map[1],enc_buff->ui_buffer_map[2],enc_buff->ui_buffer_map[3]);
+		}
+	}
+	else
+	{
+		//DLOG("wimo_video not open\n");
+		ret = VIDEO_ENCODER_CLOSED;
+	}
+	mutex_unlock(&video_lock);
+	
+	return ret;
+buffer_full:
+	mutex_unlock(&video_lock);
+	return ret;
+}
+#endif
+
+
+static int wimo_open(struct inode *inode, struct file *file)
+{
+    int ret = 0;
+
+    DLOG("wimo_open current %u \n", current->pid);
+    
+    return ret;
+}
+
+static int wimo_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int ret = 0;
+	DLOG("wimo_mmap do  nothing current->pid %u\n",current->pid);
+//error:
+	return ret;
+}
+
+static int wimo_release(struct inode *inode, struct file *file)
+{
+    DLOG("wimo_release do  nothing current->pid %u\n",current->pid);
+
+
+    return 0;
+}
+
+static long wimo_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long  ret = 0;
+//	DLOG("wimo_ioctl cmd %d \n",cmd);
+	switch (cmd) {
+	case  WIMO_START:	
+		{
+			{
+				
+				mutex_lock(&wimo_lock);
+				wimo_start();
+				mutex_unlock(&wimo_lock);
+				printk("wimo_ioctl WIMO_START wimo.start_sign %d\n",wimo.start_sign);
+			}
+		}
+		break;
+	case  WIMO_STOP:
+		{
+			{
+				mutex_lock(&wimo_lock);
+				wimo_stop();
+				mutex_unlock(&wimo_lock);
+				printk("wimo_ioctl WIMO_STOP wimo.start_sign %d\n",wimo.start_sign);
+			}
+			{
+				
+			}
+		}
+		break;
+	case  WIMO_SET_ROTATION:			
+		break;
+	case  WIMO_VIDEO_OPEN:		
+		
+		{
+			unsigned long temp[6];
+			
+			if (copy_from_user(temp, (void*)arg, 24))
+				return -EFAULT;
+			mutex_lock(&video_lock);
+			ret = wimo_video_open(temp);
+			mutex_unlock(&video_lock);
+		}
+		
+		break;
+	case  WIMO_VIDEO_CLOSE:	
+		
+		{
+			mutex_lock(&video_lock);
+			ret = wimo_video_close(&wimo.video_info);
+			mutex_unlock(&video_lock);
+		}
+		
+		break;
+	case  WIMO_VIDEO_GET_BUF:		
+		
+		{
+			
+			unsigned long temp_data[8];
+			mutex_lock(&video_lock);
+			
+			if(wimo.video_start_sign == 1 && wimo.start_sign == 1 && wimo.video_info.buffer_num)
+			{
+				
+				ret = wimo_video_find_frame(temp_data,&wimo.video_info);
+				if(ret == 0)
+				{
+					yuv_time =	rgb_time = 0;
+				}
+			}	
+			else
+			{
+				ret = -1111;
+				DLOG("WIMO_VIDEO_GET_BUF starg_sign %d start_video_sign %d",wimo.start_sign,wimo.video_start_sign);
+			}
+			mutex_unlock(&video_lock);
+			if (copy_to_user((void*)arg, temp_data, 28))
+				return -EFAULT;
+		}
+		
+		break;
+		
+	case  WIMO_AUDIO_OPEN:		
+		
+		{
+			unsigned long temp[6];
+			struct wimo_audio_info *audio_info = &wimo.audio_info;
+			if (copy_from_user(temp, (void*)arg, 24))
+				return -EFAULT;
+			mutex_lock(&audio_lock);
+			ret = wimo_audio_open(temp);
+			mutex_unlock(&audio_lock);
+			printk(" wimo_audio_open ret %daudio_info->Out_Buffer	 %x  temp[0] %x audio_info->audio_data %x audio_info->time_stamp  %x  len = 3",
+				ret,(unsigned long)audio_info->Out_Buffer	,(unsigned long)(temp[0]),audio_info->audio_data,audio_info->time_stamp );
+		}
+		
+		break;
+	case  WIMO_AUDIO_CLOSE:	
+		
+		{
+			printk("WIMO_AUDIO_CLOSE\n");
+			mutex_lock(&audio_lock);
+			ret = wimo_audio_close();
+			mutex_unlock(&audio_lock);
+		}
+		
+		break;
+	case  WIMO_AUDIO_SET_PARA:	
+		
+		{
+			struct wimo_audio_param temp_data;
+			if (copy_from_user((void*)(&temp_data), (void*)arg, sizeof(struct wimo_audio_param)))
+				return -EFAULT;
+			mutex_lock(&audio_lock);
+			wimo_audio_set_para(&temp_data);
+			mutex_unlock(&audio_lock);
+		}
+		
+		break;
+	case  WIMO_AUDIO_SET_VOL:	
+		
+		{
+			unsigned long temp_data;
+			
+			if (copy_from_user(&temp_data, (void*)arg, 4))
+				return -EFAULT;
+			//printk("WIMO_AUDIO_SET_VOL set vol %d\n",temp_data);
+			mutex_lock(&audio_lock);
+			wimo.volumn_open_sign = temp_data;
+			mutex_unlock(&audio_lock);
+		}
+		
+		break;	
+	case  WIMO_AUDIO_GET_VOL:
+		{
+			//printk("WIMO_AUDIO_SET_VOL get vol %d\n",wimo.volumn_open_sign);	
+			if(copy_to_user((void*)arg,&wimo.volumn_open_sign,4))
+				return -EFAULT;
+		}
+		break;
+	case  WIMO_AUDIO_GET_BUF:		
+		
+		{
+			struct wimo_audio_info *audio_info = &wimo.audio_info;
+			mutex_lock(&audio_lock); 
+			if(wimo.audio_start_sign == 1 && wimo.start_sign == 1 && wimo.audio_info.buffer_size)
+			{
+				if(audio_info->data_len >= 1)
+				{
+					struct timeval timeFirst;
+					do_gettimeofday(&timeFirst);	
+					audio_info->Out_Buffer = (void*)(&audio_info->audio_data[audio_info->head_offset * audio_info->nBytePerFrame]);
+					
+					
+					wimo_filp_output->f_op->write(wimo_filp_output, audio_info->Out_Buffer, audio_info->nBytePerFrame, &wimo_filp_output->f_pos);
+					if (copy_to_user((void*)arg,audio_info->Out_Buffer,  4096))
+						ret = -EFAULT;
+					if (copy_to_user((void*)arg+4096,(void*)(&audio_info->time_stamp[audio_info->head_offset]),  8))
+						ret = -EFAULT;
+					if (copy_to_user((void*)arg+4104,&timeFirst,  8))
+						ret = -EFAULT;
+					if (copy_to_user((void*)arg+4112,&audio_info->head_offset,  8))
+						ret = -EFAULT;
+					audio_info->data_len --;
+					audio_info->head_offset ++;
+					audio_info->head_offset %= audio_info->buffer_size;
+				}
+				else
+				{
+					ret = -1;
+				}
+			}	
+			else
+			{
+				ret = -1111;
+			}
+			
+			mutex_unlock(&audio_lock);
+		}
+		
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+struct file_operations wimo_fops = {
+	.open = wimo_open,
+	.mmap = wimo_mmap,
+	.unlocked_ioctl = wimo_ioctl,
+	.release = wimo_release,
+};
+
+#if WIMO_DEBUG
+static ssize_t debug_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t debug_read(struct file *file, char __user *buf, size_t count,
+			  loff_t *ppos)
+{
+	wdm_region *region, *tmp_region;
+	const int debug_bufmax = 4096;
+	static char buffer[4096];
+	int n = 0;
+
+	DLOG("debug open\n");
+	n = scnprintf(buffer, debug_bufmax,
+		      "pid #: mapped regions (offset, len, used, post) ...\n");
+	down_read(&wdm_rwsem);
+     {
+        n += scnprintf(buffer + n, debug_bufmax - n,
+                "(%d,%d,%d,%d) ",
+                region->index, region->pfn, region->used, region->post);
+	}
+	up_read(&wdm_rwsem);
+	n++;
+	buffer[n] = 0;
+	return simple_read_from_buffer(buf, count, ppos, buffer, n);
+}
+
+static struct file_operations debug_fops = {
+	.read = debug_read,
+	.open = debug_open,
+};
+#endif
+
+int wimo_setup(struct wimo_platform_data *pdata)
+{
+	int err = 0;
+    DLOG("wimo_setup pdata->name %s\n",pdata->name);
+    if (wimo_count) {
+		printk(KERN_ALERT "Only one wimo driver can be register!\n");
+        goto err_cant_register_device;
+    }
+
+    memset(&wimo, 0, sizeof(struct wimo_info));
+
+    wimo.rotation_flag = IPP_ROT_0;  	
+
+    init_rwsem(&wdm_rwsem);
+    wimo.dev.name = pdata->name;
+    wimo.dev.minor = MISC_DYNAMIC_MINOR;
+    wimo.dev.fops = &wimo_fops;
+   
+    err = misc_register(&wimo.dev);
+    if (err) {
+        printk(KERN_ALERT "Unable to register wimo driver!\n");
+        goto err_cant_register_device;
+    }
+    mutex_init(&video_lock);	
+    mutex_init(&audio_lock);		
+	mutex_init(&wimo_lock);
+    audio_data_to_wimo = wimo_audio_prepare;
+    video_data_to_wimo = wimo_video_prepare;
+    printk("set audio_data_to_wimo %x %x\n",(unsigned long)wimo_audio_prepare,(unsigned long)audio_data_to_wimo);
+    #if WIMO_DEBUG
+    debugfs_create_file(pdata->name, S_IFREG | S_IRUGO, NULL, (void *)wimo.dev.minor,
+                        &debug_fops);
+    #endif
+    printk("%s: %d initialized\n", pdata->name, wimo.dev.minor);
+    wimo_count++;
+	return 0;
+  
+//err_no_mem_for_metadata:
+	misc_deregister(&wimo.dev);
+err_cant_register_device:
+	return -1;
+}
+
+static int wimo_probe(struct platform_device *pdev)
+{
+	struct wimo_platform_data *pdata;
+	printk("wimo_probe\n");
+	if (!pdev || !pdev->dev.platform_data) {
+		printk(KERN_ALERT "Unable to probe wimo!\n");
+		return -1;
+	}
+	pdata = pdev->dev.platform_data;
+	return wimo_setup(pdata);
+}
+
+static int wimo_remove(struct platform_device *pdev)
+{
+    if (!pdev || !pdev->dev.platform_data) {
+    	printk(KERN_ALERT "Unable to remove wimo!\n");
+    	return -1;
+    }
+	mutex_destroy(&wimo_lock);
+    mutex_destroy(&audio_lock);	
+    mutex_destroy(&video_lock);	
+    if (wimo_count) {
+	    misc_deregister(&wimo.dev);
+        wimo_count--;
+    } else {
+		printk(KERN_ALERT "no wimo to remove!\n");
+    }
+	return 0;
+}
+
+static struct platform_driver wimo_driver = {
+	.probe  = wimo_probe,
+	.remove = wimo_remove,
+	.driver = {.name = "wimo"}
+	
+};
+
+
+static int __init wimo_init(void)
+{
+	printk("wimo_init\n");
+	return platform_driver_register(&wimo_driver);
+}
+
+static void __exit wimo_exit(void)
+{
+	platform_driver_unregister(&wimo_driver);
+}
+
+module_init(wimo_init);
+module_exit(wimo_exit);
+
+#if	0//def CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+static int proc_wimo_show(struct seq_file *s, void *v)
+{
+	if (wimo_count) {
+		seq_printf(s, "wimo opened\n");
+	} else {
+		seq_printf(s, "wimo closed\n");
+        return 0;
+	}
+
+    down_read(&wdm_rwsem);
+    	{
+    	}
+
+    up_read(&wdm_rwsem);
+    return 0;
+}
+
+static int proc_wimo_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_wimo_show, NULL);
+}
+
+static const struct file_operations proc_wimo_fops = {
+	.open		= proc_wimo_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init wimo_proc_init(void)
+{
+	proc_create("wimo", 0, NULL, &proc_wimo_fops);
+	return 0;
+
+}
+late_initcall(wimo_proc_init);
+#endif /* CONFIG_PROC_FS */
+
